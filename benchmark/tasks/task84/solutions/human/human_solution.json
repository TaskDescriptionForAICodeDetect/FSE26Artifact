[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n  solve\n  def solve: Unit = {\n    val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n    if (n != 0 && m != 0){\n      val state = Array.tabulate(m){_ ⇒ readLine.trim.toCharArray.map(State(_))}\n      val memo = Array.tabulate(m){_ ⇒ Array.tabulate(n){_ ⇒ Int.MaxValue}}\n      val queue: mutable.PriorityQueue[(Coordinate, Int)] = mutable.PriorityQueue[(Coordinate, Int)]()(Ordering.by[(Coordinate, Int), Int](_._2).reverse)\n      for (y ← 0 until m) {\n        memo(y)(0) = 0\n        memo(y)(n - 1) = 0\n        queue.enqueue(Coordinate(0, y) → 0, Coordinate(n - 1, y) → 0)\n      }\n      for (x ← 1 until n - 1){\n        memo(0)(x) = 0\n        memo(m - 1)(x) = 0\n        queue.enqueue(Coordinate(x, 0) → 0, Coordinate(x, m - 1) → 0)\n      }\n\n      while (queue.head._1.let(c ⇒ state(c.y)(c.x) != Castle)) {\n        val (c, d) = queue.dequeue()\n        if (memo(c.y)(c.x) == d){\n          for (next@Coordinate(x, y) ← c.neighbors){\n            if ((0 until n).contains(x) && (0 until m).contains(y)) {\n              (state(c.y)(c.x), state(y)(x)) match{\n                case (Moat, Moat) if memo(y)(x) > d ⇒ {\n                  memo(y)(x) = d\n                  queue.enqueue(next → d)\n                }\n                case (Moat, _) if memo(y)(x) > d + 1 ⇒ {\n                  memo(y)(x) = d + 1\n                  queue.enqueue(next → (d + 1))\n                }\n                case (Plane, _) if memo(y)(x) > d ⇒ {\n                  memo(y)(x) = d\n                  queue.enqueue(next → d)\n                }\n                case _ ⇒\n              }\n            }\n          }\n        }\n      }\n      println(\n        queue.head._2\n      )\n      solve\n    }\n  }\n  object State{\n    def apply(char: Char): State = char match{\n      case '&' ⇒ Castle\n      case '.' ⇒ Plane\n      case '#' ⇒ Moat\n      case _ ⇒ throw new Exception\n    }\n  }\n  sealed trait State\n  object Moat extends State\n  object Castle extends State\n  object Plane extends State\n  case class Coordinate(x: Int, y: Int) {\n    def neighbors: Iterable[Coordinate] = List(Coordinate(0, 1), Coordinate(0, -1), Coordinate(1, 0), Coordinate(-1, 0)).map(_ + this)\n    def +(that: Coordinate): Coordinate = Coordinate(this.x + that.x, this.y + that.y)\n  }\n  implicit class ScopeFunc[T](val value:T){\n    def let[A](func: T ⇒ A): A = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<vector<char> > VVC;\n\nclass Pox\n{\npublic:\n  P p;\n  int cost;\n  Pox(P p = P(0,0),int cost = 0):p(p),cost(cost){}\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w;\n\nvoid print(VVC G)\n{\n  cout << \"---print---\" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\tcout << G[i][j];\n      cout << endl;\n\n    }\n  cout << endl;\n\n}\n\nvoid draw(VVC& G,P p)\n{\n\n  for(int i=0;i<4;i++)\n    {\n      int nx = p.F + dx[i];\n      int ny = p.S + dy[i];\n      if(!(1<=ny&&ny<=h && 1<=nx&&nx<=w))\n\tcontinue;\n      if(G[ny][nx] == '&' || G[ny][nx] == '#')\n\tcontinue;\n      G[ny][nx] = '&';\n      draw(G,P(nx,ny));\n    }\n  \n}\n\nint main()\n{\n  \n  while(cin >> w >> h,(w||h))\n    {\n      cerr << w << \" \" << h << endl;\n      VVC G;\n      P ed;\n      G.resize(h+2);\n      deque<Pox> deq;\n      int mincost[h+3][w+3];\n      for(int i=0;i<=h+1;i++)\n\t{\n\t  G[i].resize(w+2);\n\t  string line;\n\t  if(i == 0 || i == h+1)\n\t    line = string(h+2,'.');\n\t  else\n\t    {\n\t    cin >> line;\n\t    cerr << line << endl;\n\t    }\n\t  //cout << \"line = \" << line << endl;\n\t  for(int j=0;j<=w+1;j++)\n\t    {\n\t      mincost[i][j] = (1<<28);\n\t      if(i == 0 || j == 0 || i == h+1 || j == w+1)\n\t\t{\n\t\t  G[i][j] = '.';\n\t\t  deq.push_back(Pox(P(j,i),0));\n\t\t  mincost[i][j] = 0;\n\t \t  continue;\n\t\t}\n\t      G[i][j] = line[j-1];\n\t      if(G[i][j] == '&')\n\t\ted = P(j,i);\n\t    }\n\t}\n\n\n     \n      draw(G,ed);\n     \n      int men = (1<<28);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  P p = pox.p;\n\t  int cost = pox.cost;\n\t  if(G[p.S][p.F] == '&')\n\t    {\n\t      men = min(men,cost);\n\t      break;\n\t    }\n\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx = p.F + dx[i];\n\t      int ny = p.S + dy[i];\n\n\t      if(!(1<=nx&&nx<=w && 1<=ny&&ny<=h))\n\t\tcontinue;\n\n\t      int d = G[ny][nx]=='#'?1:0;\n\t      if(mincost[ny][nx] > cost + d)\n\t\t{\n\t\t  mincost[ny][nx] = cost + d;\n\t\t  deq.push_back(Pox(P(nx,ny),mincost[ny][nx]));\n\t\t}\n\t    }\n\n\t}\n      cout << men << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1 << 20\n\nusing namespace std;\n\nint main()\n{\n\tvector<string> s(100);\n\tint ans,h,w,sx,sy;\n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\tint cost[100][100];\n\t\n\twhile(cin >> w >> h)\n\t{\n\t\tif(w == 0 && h == 0) break;\n\t\t\n\t\trep(i,h) rep(j,w) cost[i][j] = INF;\n\t\tans = INF;\n\n\t\trep(i,h)\n\t\t{\n\t\t\tcin >> s[i];\n\t\t}\n\t\t\n\t\trep(i,h)\n\t\t{\n\t\t\trep(j,w)\n\t\t\t{\n\t\t\t\tif(s[i][j] == '&')\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcost[sy][sx] = 0;\n\n\t\tqueue<pair<int,int> > que;\n\t\tque.push(make_pair(sy,sx));\n\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tpair<int,int> p = que.front();\n\t\t\tint y = p.first;\n\t\t\tint x = p.second;\n\t\t\tque.pop();\n\n\t\t\trep(i,4)\n\t\t\t{\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nx = x + dx[i];\n\n\t\t\t\tif(0 <= ny && ny < h && 0 <= nx && nx < w)\n\t\t\t\t{\n\t\t\t\t\tint temp = cost[y][x];\n\t\t\t\t\tif(s[y][x] != '#' && s[ny][nx] == '#')\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(temp < cost[ny][nx])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost[ny][nx] = temp;\n\t\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i,h)\n\t\t{\n\t\t\trep(j,w)\n\t\t\t{\n\t\t\t\tif(i == 0 || i == h-1 || j == 0 || j == w-1)\n\t\t\t\t{\n\t\t\t\t\tans = min(ans,cost[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; memset(dist, 127, sizeof(dist)); queue<pair<int, int>>Q;\n\t\tmemset(X, 127, sizeof(X));\n\t\tif (W == 0 && H == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c; if (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H) {\n\t\t\t\t\tif (j == 1 || j == W) {\n\t\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop(); int cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] <= 1) {\n\t\t\t\t\tint dis = dist[cx][cy] + X[ex][ey];\n\t\t\t\t\tif (dist[ex][ey] > dis) {\n\t\t\t\t\t\tdist[ex][ey] = dis; Q.push(make_pair(ex, ey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint h, w;\nchar mapData[100][100];\nbool visited[100][100];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[100][100];\nint p;\n\nvoid dfs(int y, int x){\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(height[ty][tx] == p && visited[ty][tx]) continue;\n    if(height[ty][tx] < p) return;\n    visited[ty][tx] = true;\n    height[y][x] = p;\n    dfs(ty, tx);\n  }\n}\n\nint solve(){\n  fill(height[0], height[100], INF);\n  int cnt;\n  for(int j=0;j<w;j++){//top to bottom\n    cnt = 0;\n    for(int i=0;i<h;i++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//left to right\n    cnt = 0;\n    for(int j=w-1;j>=0;j--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n\theight[i][j] = min(height[i][j], cnt);\n      }\n    }\n  }\n  for(int j=0;j<w;j++){//bottom to top\n    cnt = 0;\n    for(int i=h-1;i>=0;i--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\t\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//right to left\n    cnt = 0;\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  fill(visited[0], visited[100], false);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#' || visited[i][j]) continue;\n      p = height[i][j];\n      dfs(i, j);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    cout << solve() << endl;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << setw(2) << height[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(ky>=1 && ky<=n && kx>=1 && kx<=m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[120][120];\nint jp[120][120];\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(0,0),0));\n\tjp[0][0]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(kx>=0 && kx<=n+1 && ky>=0 && ky<=m+1){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='&' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcin >> fie[j][i];\n\t\t\t\tif(fie[j][i]=='&')gx=j,gy=i;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",jp[gx][gy]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n \nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n \ndouble h, w;\nchar C[210][210];\n \nint d[210][210];\n \nbool isOutOfRange(int x, int y){\n    if(x <= 0 || x > w || y<= 0 || y > h) return true;\n    return false;\n}\n \nint main(){\n    pii p;\n    int x, y, nx, ny, c, nc;\n    int gx, gy;\n    while(cin>>w>>h && h && w){\n        rep(i, h) scanf(\"%s\", C[i]);\n        //cout<<h<<\" \"<<w<<endl;\n        rep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n        gx++; gy++;\n        rep(i, 210) rep(j, 210) d[i][j] = -1;\n        priority_queue<pii, vector<pii>, greater<pii> > q;\n        rep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n        rep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            y = p.se/1000;\n            x = p.se%1000;\n            c = p.fi;\n            rep(i, 4){\n                nx = x + dx[i];\n                ny = y + dy[i];\n                if(isOutOfRange(nx, ny)) continue;\n                nc = c + (C[ny-1][nx-1]=='#'?1:0);\n                if(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n                d[ny][nx] = nc;\n                if(ny==gy && nx == gx) continue;\n                q.push(mp(nc, ny*1000+nx));\n            }\n        }\n        cout<<d[gy][gx]<<endl;  \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nchar str[102][102];\nint bfs[102][102];\nint v[102][102];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++)\n\t\t\t\tstr[i][j]='.';\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",str[i]+1);\n\t\t}\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++){\n\t\t\t\tbfs[i][j]=-1;\n\t\t\t\tv[i][j]=0;\n\t\t\t}\n\t\tbfs[0][0]=0;\n\t\tdeque<pair<int,int> > Q;\n\t\tQ.push_back(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop_front();\n\t\t\tif(v[row][col])continue;\n\t\t\tv[row][col]=1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<102&&0<=col+dy[i]&&col+dy[i]<102){\n\t\t\t\t\tif((!~bfs[row+dx[i]][col+dy[i]])||(bfs[row+dx[i]][col+dy[i]]>bfs[row][col]+(str[row+dx[i]][col+dy[i]]=='#'?1:0))){\n\t\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col]+(str[row+dx[i]][col+dy[i]]=='#'?1:0);\n\t\t\t\t\t\tif(str[row+dx[i]][col+dy[i]]=='#'){\n\t\t\t\t\t\t\tQ.push_back(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t\t}else Q.push_front(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){\n\t\t\tfor(int j=0;j<102;j++){\n\t\t\t\tif(str[i][j]=='&')printf(\"%d\\n\",bfs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 1e9;\nstatic const int dx[] = {1, 0, -1, 0};\nstatic const int dy[] = {0, -1, 0, 1};\n\nvoid solve()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n || m)\n\t{\n\t\tP start;\n\t\tvector< vector<char> > field(m, vector<char>(n));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '&')\n\t\t\t\t{\n\t\t\t\t\tstart.first = j;\n\t\t\t\t\tstart.second = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<P> Que;\n\t\tQue.push(start);\n\t\tqueue<P> wallQue;\n\t\tvector< vector<int> > fieldStep(m, vector<int>(n));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfieldStep[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfieldStep[start.second][start.first] = 0;\n\t\tint cnt = 0;\n\t\twhile (true)\n\t\t{\n\t\t\twhile (!Que.empty())\n\t\t\t{\n\t\t\t\tP cur = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = cur.first + dx[i];\n\t\t\t\t\tnext.second = cur.second + dy[i];\n\t\t\t\t\tif (!(0 <= next.first && next.first < n && 0 <= next.second && next.second < m) || fieldStep[next.second][next.first] != INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt;\n\t\t\t\t\t\tif (field[next.second][next.first] == '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twallQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!wallQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(wallQue.front());\n\t\t\t\twallQue.pop();\n\t\t\t}\n\t\t\t++cnt;\n\t\t\tif (Que.empty())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint minv = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (field[0][i] != '#')\n\t\t\t{\n\t\t\t\tminv = min(minv, fieldStep[0][i]);\n\t\t\t}\n\t\t\tif (field[m - 1][i] != '#')\n\t\t\t{\n\t\t\t\tminv = min(minv, fieldStep[m - 1][i]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tif (field[i][0] != '#')\n\t\t\t{\n\t\t\t\tminv = min(minv, fieldStep[i][0]);\n\t\t\t}\n\t\t\tif (field[i][n - 1] != '#')\n\t\t\t{\n\t\t\t\tminv = min(minv, fieldStep[i][n - 1]);\n\t\t\t}\n\t\t}\n\t\tcout << minv << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {{1,0},{0,1},{-1,0},{0,-1},{1,-1},{1,1},{-1,1},{-1,-1}};\n\nint main(){\n    int w,h;\n\n    while(cin >> w >> h){\n        if(w == 0 && h == 0) break;\n        VVI vvi(h+2);\n        REP(y,h+2) vvi[y].resize(w+2);\n        int gx = 0, gy = 0;\n        REP(y,h){\n            string s;\n            cin >> s;\n            REP(x,w){\n                if(s[x] == '&') gx = x+1, gy = y+1;\n                if(s[x] == '#') vvi[y+1][x+1] = 1;\n            }\n        }\n        w += 2; h += 2;\n        pr(w); pr(h);\n\n        VVI inq(h, vector<int>(w));\n        VVI cost(h, vector<int>(w,INT_MAX));\n        deque<pair<int,int> > q;\n        q.pb(mp(0,0));\n        cost[0][0] = 0;\n        while(!q.empty()){\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop_front();\n            inq[y][x] = 0;\n            REP(i,4){\n                int mx = x + dir[i][0];\n                int my = y + dir[i][1];\n                if(mx < 0 || my < 0 || mx >= w || my >= h) continue;\n                int c = (vvi[y][x] == 1 && vvi[my][mx] == 0) ? 1 : 0;\n                if(cost[my][mx] > cost[y][x] + c){\n                    cost[my][mx] = cost[y][x] + c;\n                    if(!inq[my][mx]){\n                        q.pb(mp(mx,my));\n                        inq[my][mx] = true;\n                    }\n                }\n            }\n        }\n        cout << cost[gy][gx] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define mp make_pair\ntypedef pair<int, int> P;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint N, M;\nchar maze[110][110];\nunsigned int minp[110][110];\n\nint main() {\n\tfor(;;) {\n\t\tmemset(minp, -1, sizeof minp);\n\t\tscanf(\" %d %d\", &N, &M);\n\t\tif(!N && !M) break;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tscanf(\" %s\", maze[i]);\n\t\t}\n#if 1\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tprintf(\"%s\\n\", maze[i]);\n\t\t}\n#endif\n\n\t\t// P = (x, y)\n\t\t// maze[y][x]\n\t\tqueue<P> que;\n\t\t{\n\t\t\tP put;\n\t\t\tfor(int x = 0; x < N; x++) {\n\t\t\t\tfor(int y = 0; y < M; y++) {\n\t\t\t\t\tif(maze[y][x] == '&') {\n\t\t\t\t\t\tput.first = x;\n\t\t\t\t\t\tput.second = y;\n\t\t\t\t\t\tminp[y][x] = 0;\n\t\t\t\t\t\tmaze[y][x] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.push(put);\n\t\t}\n\t\t;\n\t\twhile(!que.empty()) {\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\t\t\t// endð Èµ ?\n\t\t\t\n\n\t\t\t// push\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first] + 1;\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunsigned int minv = INT_MAX;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tminv = min(minv, min(minp[0][i], minp[M - 1][i]));\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tminv = min(minv, min(minp[i][0], minp[N - 1][i]));\n\t\t}\n\t\tprintf(\"%d\\n\", minv);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n >> m && n+m){\n    vector<vector<char>> v(m+1,vector<char>(n+1,' '));\n    using piii = pair<int,pair<int,int>>;\n    priority_queue<piii> q;\n    vector<vector<int>> d(m+1,vector<int>(n+1,inf));\n    {\n      int x = 0,y = 0;\n      rep(j,m){\n        rep(i,n){\n          cin >> v[j][i];\n          if(v[j][i] == '&'){\n            x = i;\n            y = j;\n          }\n        }\n      }\n      piii pos = mp(0,mp(y,x));\n      d[y][x] = 0;\n      q.push(pos);\n    }\n    int ans = inf;\n    while(q.size()){\n      auto Q = q.top();q.pop();\n      auto p = Q.se;\n      int dpt = Q.fi;\n      int x = p.se,y = p.fi;\n      rep(i,4){\n        int nx = x + dx[i],ny = y + dy[i];\n        if(value(nx,ny,n,m)){\n          if(v[y][x] == v[ny][nx] && d[ny][nx] > d[y][x]){\n            d[ny][nx] = d[y][x];\n            q.push(mp(-dpt,mp(ny,nx)));\n          }\n          else if(d[ny][nx] > d[y][x] + 1){\n            d[ny][nx] = (v[ny][nx] == '#') + d[y][x];\n            q.push(mp(-(dpt+1),mp(ny,nx)));\n          }\n        }\n        else{\n          ans = min(ans,d[y][x]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nint main(){\n\tint n,m;\n\t\n\t\n\twhile(cin>>n>>m,n){\n\t\tchar MA[102][102];\n\t\tint co[102][102];\n\t\tqueue<int>pX;\n\t\tqueue<int>pY;\n\t\tqueue<int>sX;\n\t\tqueue<int>sY;\n\t\t\n\t\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)MA[i][j]='.',co[i][j]=-1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcin>>MA[j][i];\n\t\t\t\tif(MA[j][i]=='&'){\n\t\t\t\t\tpX.push(j);\n\t\t\t\t\tpY.push(i);\n\t\t\t\t\tco[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(co[0][0]==-1){\n\t\t\tif(pX.empty()==0){\n\t\t\t\tint x=pX.front(),y=pY.front();\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(0<=x+vx[i]&&x+vx[i]<=n+1&&0<=y+vy[i]&&y+vy[i]<=m+1){\n\t\t\t\t\t\tif(co[x+vx[i]][y+vy[i]]==-1){\n\t\t\t\t\t\t\tif(MA[x+vx[i]][y+vy[i]]=='.'){\n\t\t\t\t\t\t\t\tpX.push(x+vx[i]);\n\t\t\t\t\t\t\t\tpY.push(y+vy[i]);\n\t\t\t\t\t\t\t\tco[x+vx[i]][y+vy[i]]=co[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tsX.push(x+vx[i]);\n\t\t\t\t\t\t\t\tsY.push(y+vy[i]);\n\t\t\t\t\t\t\t\tco[x+vx[i]][y+vy[i]]=co[x][y]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpX.pop();\n\t\t\t\tpY.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint x=sX.front(),y=sY.front();\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(0<=x+vx[i]&&x+vx[i]<=n+1&&0<=y+vy[i]&&y+vy[i]<=m+1){\n\t\t\t\t\t\tif(co[x+vx[i]][y+vy[i]]==-1){\n\t\t\t\t\t\t\tif(MA[x+vx[i]][y+vy[i]]=='.'){\n\t\t\t\t\t\t\t\tpX.push(x+vx[i]);\n\t\t\t\t\t\t\t\tpY.push(y+vy[i]);\n\t\t\t\t\t\t\t\tco[x+vx[i]][y+vy[i]]=co[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tsX.push(x+vx[i]);\n\t\t\t\t\t\t\t\tsY.push(y+vy[i]);\n\t\t\t\t\t\t\t\tco[x+vx[i]][y+vy[i]]=co[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsX.pop();\n\t\t\t\tsY.pop();\n\t\t\t}\n\t\t}\n\t\tcout<<co[0][0]<<endl;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nchar f[200][200];\nint d[200][200];\n\nstruct st {\n\tint x, y, c;\n};\nbool operator<(st a, st b) { return a.c > b.c; }\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(f, '.', sizeof(f));\n\t\tint gx, gy;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tscanf(\"%s\", f[i] + 1);\n\t\t\tf[i][n + 1] = '.';\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (f[i][j] == '&')gx = i, gy = j;\n\t\t\t}\n\t\t}\n\t\tm++; n++;\n\t\tpriority_queue<st>que;\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\td[0][0] = 0; que.push({ 0,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (p.c != d[p.x][p.y])continue;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.x + dx[i], ny = p.y + dy[i];\n\t\t\t\tif (!(0 <= nx&&nx <= m && 0 <= ny&&ny <= n))continue;\n\t\t\t\tif (f[nx][ny] == '#') {\n\t\t\t\t\tif (d[nx][ny] > p.c + 1) {\n\t\t\t\t\t\td[nx][ny] = p.c + 1;\n\t\t\t\t\t\tque.push({ nx,ny,d[nx][ny] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (d[nx][ny] > p.c) {\n\t\t\t\t\t\td[nx][ny] = p.c;\n\t\t\t\t\t\tque.push({ nx,ny,d[nx][ny] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d[gx][gy]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0,  0};\nconst int dy[] = {0,  0, 1, -1};\nchar field[104][104];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n) {\n        for (int i=0; i<104; ++i) {\n            for (int j=0; j<104; ++j) {\n                if (i % 103 == 0 || j % 103 == 0) {\n                    field[i][j] = '*';\n                } else {\n                    field[i][j] = '.';\n                }\n            }\n        }\n        for (int i=2; i<=m+1; ++i) {\n            for (int j=2; j<=n+1; ++j) {\n                cin >> field[i][j];\n            }\n        }\n        bool ok = false;\n        int k = 0;\n        for (; !ok; ++k) {\n            queue<pair<int,int> > q;\n            q.push(make_pair(1,1));\n            while ( ! q.empty() && ! ok) {\n                int x = q.front().first;\n                int y = q.front().second;\n                q.pop();\n                for (int i=0; i<4; ++i) {\n                    if (field[y + dy[i]][x + dx[i]] == '&') {\n                        ok = true;\n                        break;\n                    }\n                    if (field[y + dy[i]][x + dx[i]] == '.') {\n                        field[y + dy[i]][x + dx[i]] = '#';\n                        q.push(make_pair(x + dx[i], y + dy[i]));\n                    }\n                }\n            }\n            if (ok) break;\n            queue<pair<int,int> > q2;\n            q2.push(make_pair(1,1));\n            while ( ! q2.empty()) {\n                int x = q2.front().first;\n                int y = q2.front().second;\n                q2.pop();\n                for (int i=0; i<4; ++i) {\n                    if (field[y + dy[i]][x + dx[i]] == '#') {\n                        field[y + dy[i]][x + dx[i]] = '.';\n                        q2.push(make_pair(x + dx[i], y + dy[i]));\n                    }\n                }\n            }\n        }\n        cout << k << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x,y;\nchar field[100][100];//field[y][x]\nint flag;\n\nvoid DFS(int a,int b){\n\tif(field[b][a] == '&'){\n\t\tflag = 1;\n\t}\n\telse\n\t\tfield[b][a] = '-';\n\t\t\n\tif((field[b+1][a] == '.'|| field[b+1][a] == '&') && b+1 < y )\n\t\tDFS(a,b+1);\n\tif((field[b-1][a] == '.'|| field[b-1][a] == '&') && b-1 >= 0 )\n\t\tDFS(a,b-1);\t\n\tif((field[b][a+1] == '.'|| field[b][a+1] == '&')&& a+1 < x )\n\t\tDFS(a+1,b);\t\n\tif((field[b][a-1] == '.'|| field[b][a-1] == '&')&& a-1 >= 0 )\n\t\tDFS(a-1,b);\n}\n\nvoid hey(int a,int b){\n\tfield[b][a] = '-';\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tif(field[b+i][a+j]=='#' && b+i >= 0 && b+i < y && a+j >= 0 && a+j < x)\n\t\t\t\they(a+j,b+i);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> x >> y){\n\t\tif(!x && !y)\n\t\t\tbreak;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(field[0][i] == '.')\n\t\t\t\tfield[0][i] = '-';\n\t\t\tif(field[y-1][i] == '.')\n\t\t\t\tfield[y-1][i] = '-';\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tif(field[i][0] == '.')\n\t\t\t\tfield[i][0] = '-';\n\t\t\tif(field[i][x-1] == '.')\n\t\t\t\tfield[i][x-1] = '-';\n\t\t}\n\n\n\t\tint count = 0;\n\t\tflag = 0;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\tDFS(j,i);\n\t\t\t}\n\t\t}\t\n\t\twhile(!flag){\n\t\t\tint a,b;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '#'){\n\t\t\t\t\t\ta = j;b = i;\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext:;\n\t\t\they(a,b);\n\t\t\tcount++;\n\t\t\tflag = 0;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\t\tDFS(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<queue>\nstruct S{int x,y,c;S(int x,int y,int c):x(x),y(y),c(c){}bool operator<(const S&r)const{return c>r.c;}};\nint main()\n{\n\tint w,h,x,y,d[]={0,1,0,-1,0},i;\n\tchar*p,m[102][105];\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tint f[102][102]={0};\n\t\tfor(y=1;y<=h;++y)scanf(\"%s\",m[y]+1);\n\t\th+=2,w+=2;\n\t\tfor(y=0;y<h;++y)m[y][0]=m[y][w-1]='.';\n\t\tfor(x=0;x<w;++x)m[0][x]=m[h-1][x]='.';\n\t\tstd::priority_queue<S>q;\n\t\tq.push(S(0,0,0));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tS p(q.top());q.pop();\n\t\t\tchar c=m[p.y][p.x];\n\t\t\tif(c=='&')\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",p.c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(i=0;i<4;++i)\n\t\t\t{\n\t\t\t\tx=p.x+d[i];\n\t\t\t\ty=p.y+d[i+1];\n\t\t\t\tif(x<0||w<=x||y<0||h<=y||f[y][x])continue;\n\t\t\t\tf[y][x]=1;\n\t\t\t\tchar d=m[y][x];\n\t\t\t\tif(d=='#'&&d-c)q.push(S(x,y,p.c+1));\n\t\t\t\telse q.push(S(x,y,p.c));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define GROUND '.'\n#define MOAT '#'\n\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\nchar M[105][105];\nint  v[105][105];\nint n, m;\t// n: ¼Ì m: ìkÌ \n\nbool dfs (int cr, int cc, int color, char target )\n{\n\tv[cr][cc] = color;\n\tif (cr == 0 || cr == m+1 || cc == 0 || cc == n+1 ){\n\t\treturn true;\n\t} // end if\n\n\trep (k, 4 ){\n\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\tif ((M[nr][nc] == target && v[nr][nc] == INF ) || v[nr][nc] < color ){\n\t\t\treturn dfs (nr, nc, color, target );\n\t\t} // end if\n\t} // end while\n\n\treturn false;\n}\n\nvoid init_map ()\n{\n\trep (i, m+2 ){\n\t\trep (j, n+2 ){\n\t\t\tM[i][j] = GROUND;\n\t\t\tv[i][j] = INF;\n\t\t} // end rep\n\t} // end rep\n}\n\nint main()\n{\n\twhile (cin >> n >> m && n && m ){\n\t\tint sr, sc;\n\t\tinit_map ();\n\t\tfor (int i = 1; i <= m; i++ ){\n\t\t\tfor (int j = 1; j <= n; j++ ){\n\t\t\t\tcin >> M[i][j];\n\t\t\t\tif (M[i][j] == '&' ){\n\t\t\t\t\tsr = i, sc = j;\n\t\t\t\t\tM[i][j] = GROUND;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tif (dfs (sr, sc, res, GROUND ) ){\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t\tres++;\n\t\t\tif (dfs (sr, sc, res, MOAT ) ){\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t\tres++;\n\t\t} // end while\n\t\tcout << res/2 << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\n#define P pair<int,int>\nusing namespace std;\n\nint a, b;\nstring c[105];\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvector<P>V;\nint main() {\n\twhile (cin >> b >> a, a || b) {\n\t\tstring f;\n\t\tfor (int g = 0; g < b + 2; g++)f += \".\";\n\t\tc[0] = c[a + 1] = f;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d + 1] = \".\" + e + \".\";\n\t\t}\n\t\ta+=2; b+=2;\n\t\tfor (int I = 0;; I++) {\n\t\t\tqueue<P>Q;\n\t\t\tQ.push(P(0,0));\n\t\t\tc[0][0] = 0;\n\t\t\tV.push_back(P(0,0));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP t = Q.front(); Q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b) {\n\t\t\t\t\t\tif (c[x][y] == '.') {\n\t\t\t\t\t\t\tV.push_back(P(x, y));\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tQ.push(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '#') {\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tV.push_back(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '&') {\n\t\t\t\t\t\t\tcout << I << endl;\n\t\t\t\t\t\t\tV.clear();\n\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (P o : V) {\n\t\t\t\tc[o.first][o.second] = '.';\n\t\t\t}\n\t\t\tV.clear();\n\t\t}\n\tl:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nchar f[200][200];\nint d[200][200];\n\nstruct st {\n\tint x, y, c;\n};\nbool operator<(st a, st b) { return a.c > b.c; }\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d%d\", &n, &m), n) {\n\t\tmemset(f, '.', sizeof(f));\n\t\tint gx, gy;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tscanf(\"%s\", f[i] + 1);\n\t\t\tf[i][n + 1] = '.';\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (f[i][j] == '&')gx = i, gy = j;\n\t\t\t}\n\t\t}\n\t\tm++; n++;\n\t\tpriority_queue<st>que;\n\t\tmemset(d, 0x3f, sizeof(d));\n\t\td[0][0] = 0; que.push({ 0,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\tst p = que.top(); que.pop();\n\t\t\tif (p.c != d[p.x][p.y])continue;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.x + dx[i], ny = p.y + dy[i];\n\t\t\t\tif (!(0 <= nx&&nx <= m && 0 <= ny&&ny <= n))continue;\n\t\t\t\tif (f[p.x][p.y] != '#'&&f[nx][ny] == '#') {\n\t\t\t\t\tif (d[nx][ny] > p.c + 1) {\n\t\t\t\t\t\td[nx][ny] = p.c + 1;\n\t\t\t\t\t\tque.push({ nx,ny,d[nx][ny] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (d[nx][ny] > p.c) {\n\t\t\t\t\t\td[nx][ny] = p.c;\n\t\t\t\t\t\tque.push({ nx,ny,d[nx][ny] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d[gx][gy]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 100\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint G[MAX+2][MAX+2], m, n;\n\nbool dfs(int D[MAX+2][MAX+2], int x, int y, int num){\n\tif(x*y==0 || x==(m+1) || y==(n+1) ) return true;\n\tif(G[x][y] == 1 && num==0)  return false;\n\tif(D[x][y] >= num+1)  return false;\n\tD[x][y] = num+1;\n\tfor(int r=0; r<4; r++){\n\t\tif(dfs(D, x+dx[r], y+dy[r], (G[x][y]==0)?(num):(num-1))){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main(void){\n\twhile(cin>>m>>n, m){\n\t\tint sx,sy;\n\t\tchar c;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tfor(int j=1; j<=m; j++){\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '&'){\n\t\t\t\t\tG[j][i] = 0;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tG[j][i] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tG[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<1000; i++){\n\t\t\tint D[MAX+2][MAX+2]={0};\n\t\t\tif(dfs(D,sx,sy,i)){\n\t\t\t\tcout << i <<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,r;\nchar p[102][102];\nbool flag;\nvoid rec(int y,int x){\n\tif(p[y][x]=='&')flag = true;\n\tif(flag || p[y][x]=='#')return;\n\tp[y][x]='#';\n\tif(x+1<w+2 )rec(y,x+1);\n\tif(y+1<h+2 )rec(y+1,x);\n\tif(x-1>=0)rec(y,x-1);\n\tif(y-1>=0)rec(y-1,x);\n}\n\nint main(){\n\n\twhile(cin >> w >> h && w){\n\t\tflag = false ;\n\t\tfor(int i=0;i<102;i++)\n\t\tfor(int j=0;j<102;j++)\n\t\t p[i][j] = '.';\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tcin >> p[1+i][1+j];\n\n\t\tr = 0;\n\t\tfor(int i=0;i<h+2;i++)\n\t\tfor(int j=0;j<w+2;j++){\n\t\t\tif(p[i][j]=='.'&& !flag){\n\t\t\t\tr++;\n\t\t\t\trec(i,j);\n\t\t\t}\n\t\t}\n\t\tcout << r-1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 100\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint G[MAX+2][MAX+2], m, n;\n\nbool dfs(int D[MAX+2][MAX+2], int x, int y, int num){\n\tif(x*y==0 || x==(m+1) || y==(n+1) ) return true;\n\tif(G[x][y] == 1 && num==0)  return false;\n\tif(D[x][y] >= num+1)  return false;\n\tD[x][y] = num+1;\n\tfor(int r=0; r<4; r++){\n\t\tif(dfs(D, x+dx[r], y+dy[r], (G[x][y]==0)?(num):(num-1))){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main(void){\n\twhile(cin>>m>>n, m){\n\t\tint sx,sy;\n\t\tchar c;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tfor(int j=1; j<=m; j++){\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '&'){\n\t\t\t\t\tG[j][i] = 0;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tG[j][i] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tG[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tint D[MAX+2][MAX+2]={0};\n\t\t\tif(dfs(D,sx,sy,i)){\n\t\t\t\tcout << i <<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\n#define P pair<int,int>\nusing namespace std;\n\nint a, b;\nstring c[105];\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvector<P>V;\nint main() {\n\twhile (cin >> b >> a, a || b) {\n\t\tstring f;\n\t\tfor (int g = 0; g < b + 2; g++)f += \".\";\n\t\tc[0] = c[a + 1] = f;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d + 1] = \".\" + e + \".\";\n\t\t}\n\t\ta+=2; b+=2;\n\t\tfor (int I = 0;; I++) {\n\t\t\tqueue<P>Q;\n\t\t\tQ.push(P(0,0));\n\t\t\tc[0][0] = 0;\n\t\t\tV.push_back(P(0,0));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP t = Q.front(); Q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b) {\n\t\t\t\t\t\tif (c[x][y] == '.') {\n\t\t\t\t\t\t\tV.push_back(P(x, y));\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tQ.push(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '#') {\n\t\t\t\t\t\t\tV.push_back(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '&') {\n\t\t\t\t\t\t\tcout << I << endl;\n\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (P o : V) {\n\t\t\t\tc[o.first][o.second] = '.';\n\t\t\t}\n\t\t\tV.clear();\n\t\t}\n\tl:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\nint main(){\n  int w,h;\n  string line;\n  while(cin>>w>>h){\n    vector<string> castle;\n    for(int i=0;i<h;i++){\n      cin>>line;\n      castle.push_back(line);\n    }\n    int count[w+2][h+2];\n    int sx,sy;\n    const int MAX = 100;\n    for(int y=1;y<h+1;y++){\n      for(int x=1;x<w+1;x++){\n\tcount[x][y] = MAX;\n\tif (castle[y-1][x-1]=='&'){\n\t  sx = x;\n\t  sy = y;\n\t  castle[y-1][x-1]=='.';\n\t}\n      }\n    }\n    int min = MAX;\n    int dx[4] = {1,0,-1,0};\n    int dy[4] = {0,1,0,-1};\n    count[sx][sy] = 0;\n    stack<int> st;\n    st.push(sy*(w+2)+sx);\n    while(!st.empty()){\n      int x = st.top()%(w+2);\n      int y = st.top()/(w+2);\n      st.pop();\n      char c = castle[y-1][x-1];\n      int n;\n      for(int d=0;d<4;d++){\n\tn = count[x][y];\n\tif(x+dx[d]>0&&y+dy[d]>0&&x+dx[d]<w+1&&y+dy[d]<h+1){\n\t  if(c=='.'&&castle[y+dy[d]-1][x+dx[d]-1]=='#')\n\t    n++;\n\t  if(n<count[x+dx[d]][y+dy[d]]){\n\t    count[x+dx[d]][y+dy[d]] = n;\n\t    st.push((y+dy[d])*(w+2)+x+dx[d]);\n\t  }\n\t}\n\telse{\n\t  if(n<min)\n\t    min = n;\n\t}\n      }\n    }\n    cout<<min<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\nusing namespace std;\nint N,M;\nstring s[100];\nint d[100][100];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nmain()\n{\n\twhile(cin>>M>>N,N)\n\t{\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<M;j++)d[i][j]=i==0||j==0||i==N-1||j==M-1?0:1e9;\n\t\t}\n\t\tdeque<pair<int,int> >P;\n\t\tfor(int i=0;i<N;i++)P.push_back(make_pair(i,0)),P.push_back(make_pair(i,M-1));\n\t\tfor(int j=1;j<M-1;j++)P.push_back(make_pair(0,j)),P.push_back(make_pair(N-1,j));\n\t\twhile(!P.empty())\n\t\t{\n\t\t\tint x=P.front().first,y=P.front().second;\n\t\t\tP.pop_front();\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\t\t\tif(tx<0||ty<0||tx>=N||ty>=M)continue;\n\t\t\t\tint cost=s[x][y]=='#'&&(s[tx][ty]=='.'||s[tx][ty]=='&')?1:0;\n\t\t\t\tif(d[x][y]+cost>=d[tx][ty])continue;\n\t\t\t\td[tx][ty]=d[x][y]+cost;\n\t\t\t\tif(cost==1)P.push_back(make_pair(tx,ty));\n\t\t\t\telse P.push_front(make_pair(tx,ty));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++)for(int j=0;j<M;j++)if(s[i][j]=='&')cout<<d[i][j]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nbool ingrid(int x, int y, int w, int h)\n{\n\treturn x >= 0 && x <= w + 1 && y >= 0 && y <= h + 1;\n}\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tpriority_queue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (!ingrid(tx, ty, w, h)) continue;\n\t\t\t\tif (d[tx][ty] > st.d + (grid[st.x][st.y] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[st.x][st.y] == '#')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\ntypedef pair<int,pii>piii;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n///#include<sstream>\n///#include<cstring>\n///#include<stack>\n///#include<complex>\n\nint W,H;\nchar fld[100][101];\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nint solve(){\n    bool done[100][100]={{0}};\n    priority_queue<piii,vector<piii>,greater<piii> >Q;\n    rep(i,H){\n        Q.push(piii(0,pii(i,0)));\n        Q.push(piii(0,pii(i,W-1)));\n    }\n    rep(j,W){\n        Q.push(piii(0,pii(0,j)));\n        Q.push(piii(0,pii(H-1,j)));\n    }\n\n    while(!Q.empty()){\n        piii p=Q.top();Q.pop();\n        if(done[p.se.fi][p.se.se])continue;\n        done[p.se.fi][p.se.se]=true;\n        if(fld[p.se.fi][p.se.se]=='&')return p.fi;\n\n        rep(i,4){\n            int ty=p.se.fi+dy[i],tx=p.se.se+dx[i];\n            if(ty<0||ty>=H||tx<0||tx>=W)continue;\n            int tcost=p.fi;\n            if(fld[p.se.fi][p.se.se]=='#'&&fld[ty][tx]!='#')tcost++;\n            Q.push(piii(tcost,pii(ty,tx)));\n        }\n    }\n}\n\nint main(){\n    while(scanf(\"%d%d\",&W,&H),W||H){\n        rep(i,H)scanf(\"%s\",fld[i]);\n        printf(\"%d\\n\",solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,a,n) for(int i=(a);i<(n);++i)\n\n#define INV (-1)\n#define N 102\n#define INFTY (1<<30)\n#define PLANE 2\n#define MOAT 1\n\nusing namespace std;\n\nint n,m;\nint map[N][N];\nint M[N][N];\n\nbool inline inRange(int t, int min, int max){\n\treturn min <= t && t < max;\n}\n\nvoid dfs(int i, int j, int now){\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\n\tif( M[i][j] != now )\n\t\treturn ;\n\n\tfor(int k = 0; k < sizeof(ci)/sizeof(*ci); ++k){\n\t\tint ti = i + ci[k];\n\t\tint tj = j + cj[k];\n\t\tif( inRange( ti, 1, m+1 ) && inRange( tj, 1, n+1 ) ){\n\t\t\tif( map[i][j] == MOAT && map[ti][tj] == PLANE ){\n\t\t\t\tM[ti][tj] = min( M[ti][tj], now + 1 );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( M[ti][tj] == now ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tM[ti][tj] = now;\n\t\t\tdfs( ti, tj, now );\n\t\t}\n\t}\n\treturn ;\n}\nvoid ResetMap(){\n\tREP(i,0,N)REP(j,0,N)\n\t{\n\t\tmap[i][j] = PLANE;\n\t\tM[i][j] = INFTY;\n\t}\n}\nvoid PrintMap(){\n\tREP(i,1,m+1){\n\t\tREP(j,1,n+1){\n\t\t\tcout << setw(3) << M[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nbool Completed(int *ans){\n\tREP(i,1,m+1){\n\t\tif( M[i][1] < INFTY ){\n\t\t\t*ans = M[i][1];\n\t\t\treturn true;\n\t\t}\n\t\tif( M[i][n] < INFTY ){\n\t\t\t*ans = M[i][n];\n\t\t\treturn true;\n\t\t}\n\t}\n\tREP(j,1,n+1){\n\t\tif( M[1][j] < INFTY ){\n\t\t\t*ans = M[1][j];\n\t\t\treturn true;\n\t\t}\n\t\tif( M[m][j] < INFTY ){\n\t\t\t*ans = M[m][j];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint now = 0;\n\t\tint ans = 1<<21;\n\t\tint si;\n\t\tint sj;\n\t\t\n\t\tcin>>n>>m;\n\t\tif( m==0&&n==0 )break;\n\t\t\n\t\tResetMap();\n\t\t\n\t\tREP(i,1,m+1){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,1,n+1){\n\t\t\t\tif( s[j-1] == '&' ){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tM[si][sj] = 0;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tmap[i][j] = MOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tREP(i,1,m+1){\n\t\t\t\tREP(j,1,n+1){\n\t\t\t\t\tdfs( i, j, now );\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( Completed(&ans) )\n\t\t\t\tbreak;\n\t\t\telse{\n\t\t\t\t++now;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<29)\n\nint dy[]={1,0,-1,0};\nint dx[]={0,1,0,-1};\nint main(){\n\tint cost[102][102];\n\tchar geo[102][102];\n\tdeque<pair<int,int> > dq;\n\tpair<int,int> a,b;\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tdq.clear();\n\t\tfill_n((char*)geo,102*102,'.');\n\t\tfill_n((int*)cost,102*102,INF);\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tfor(int x=1;x<=n;x++)cin>>geo[y][x];\n\t\t}\n\t\tfor(int y=1;y<=m;y++){\n\t\t\tcost[y][0]=cost[y][n]=0;\n\t\t\tdq.push_back(make_pair(y,0));\n\t\t\tdq.push_back(make_pair(y,n));\n\t\t}\n\t\tfor(int x=2;x<n;x++){\n\t\t\tcost[0][x]=cost[m][x]=0;\n\t\t\tdq.push_back(make_pair(0,x));\n\t\t\tdq.push_back(make_pair(m,x));\n\t\t}\n\t\tint ans;\n\t\twhile(!dq.empty()){\n\t\t\ta = dq.front();\n\t\t\tdq.pop_front();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tb.first = a.first+dy[i];\n\t\t\t\tb.second = a.second+dx[i];\n\t\t\t\tint c = 0;\n\t\t\t\tif(geo[a.first][a.second]=='#'&&geo[b.first][b.second]=='.')c=1;\n\t\t\t\tif(b.first<=0||m<b.first||b.second<=0||n<b.second)continue;\n\t\t\t\tif(geo[b.first][b.second]=='&'){\n\t\t\t\t\tans = c+cost[a.first][a.second];\n\t\t\t\t\tgoto FIND;\n\t\t\t\t}\n\t\t\t\tif(c+cost[a.first][a.second] < cost[b.first][b.second]){\n\t\t\t\t\tif(c==1){\n\t\t\t\t\t\tcost[b.first][b.second] = 1+cost[a.first][a.second];\n\t\t\t\t\t\tdq.push_back(b);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcost[b.first][b.second] = cost[a.first][a.second];\n\t\t\t\t\t\tdq.push_front(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}FIND:\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\ndouble h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\trep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\trep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy+1][gx+1]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<=n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n      if(M[ny][nx] == '#' && T[ny][nx] > s.t+1){\n\tT[ny][nx] = s.t+1;\n\tQ.push(State(nx,ny,s.t+1));\n      }\n\n      if(M[ny][nx] != '#' && T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n\n    init();\n    input();\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-4;\n\nusing namespace std;\n\nint n, m;\nchar g[100][100];\nint d[100][100];\nconst int Inf = 10000000;\n\nint cost(int x, int y)\n{\n\treturn g[y][x] == '#' ? 1 : 0;\n}\nint main()\n{\n\twhile (scanf(\"%d %d\\n\", &n, &m), n | m)\n\t{\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tchar buf[128];\n\t\t\tcin.getline(buf, sizeof(buf));\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tg[i][j] = buf[j];\n\t\t}\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\td[i][j] = i == 0 || j == 0 || i == m-1 || j == n-1 ? 0 : Inf;\n\n\t\tfor (bool changed = true; changed; )\n\t\t{\n\t\t\tchanged = false;\n\t\t\tint ori[100][100];\n\t\t\tmemcpy(ori, d, sizeof(ori));\n\n\t\t\tfor (int y = 0; y < m; ++y)\n\t\t\t\tfor (int x = 1; x < n; ++x)\n\t\t\t\t\td[y][x] = min(d[y][x], d[y][x-1] + cost(x-1, y));\n\t\t\tfor (int y = 0; y < m; ++y)\n\t\t\t\tfor (int x = n-2; x >= 0; --x)\n\t\t\t\t\td[y][x] = min(d[y][x], d[y][x+1] + cost(x+1, y));\n\t\t\tfor (int x = 0; x < n; ++x)\n\t\t\t\tfor (int y = 1; y < m; ++y)\n\t\t\t\t\td[y][x] = min(d[y][x], d[y-1][x] + cost(x, y-1));\n\t\t\tfor (int x = 0; x < n; ++x)\n\t\t\t\tfor (int y = m-2; y >= 0; --y)\n\t\t\t\t\td[y][x] = min(d[y][x], d[y+1][x] + cost(x, y+1));\n\n\t\t\tfor (int i = 0; i < m; ++i)\n\t\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\t\tif (d[i][j] != ori[i][j])\n\t\t\t\t\t\tchanged = true;\n\t\t}\n\n\t\tint destY, destX;\n\t\tfor (destY = 0; destY < m; ++destY)\n\t\t\tfor (destX = 0; destX < n; ++destX)\n\t\t\t\tif (g[destY][destX] == '&')\n\t\t\t\t\tgoto EndLoop;\nEndLoop:\n\t\tprintf(\"%d\\n\", d[destY][destX]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\ndouble h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\tgx++; gy++;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\trep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\trep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tif(ny==gy && nx == gx) continue;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy][gx]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint nx=p.first.first,ny=p.first.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint kx=nx+dx[i],ky=ny+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<n && kx>=0 && kx<m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && fie[nx][ny]=='#' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && (fie[nx][ny]=='.' || fie[nx][ny]=='&') && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; memset(dist, 127, sizeof(dist)); queue<pair<int, int> >Q;\n\t\tmemset(X, 127, sizeof(X));\n\t\tif (W == 0 && H == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c; if (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H) {\n\t\t\t\t\tif (j == 1 || j == W) {\n\t\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop(); int cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] <= 1) {\n\t\t\t\t\tint dis = dist[cx][cy] + X[ex][ey];\n\t\t\t\t\tif (dist[ex][ey] > dis) {\n\t\t\t\t\t\tdist[ex][ey] = dis; Q.push(make_pair(ex, ey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1e9;\n\nint W, H, my[] = {0, 0, 1, -1}, mx[] = {1, -1, 0, 0};\nvector<string> v;\n\nint solve(){\n  priority_queue<PP, vector<PP>, greater<PP> > open;\n  open.push(PP(0, P(H - 1, 0)));\n  open.push(PP(0, P(H - 1, 0)));\n  open.push(PP(0, P(0, W - 1)));\n  open.push(PP(0, P(0, W - 1)));\n  FOR(i, 1, H) open.push(PP(0, P(i, 0)));\n  FOR(i, 1, W) open.push(PP(0, P(0, i)));\n  vector< vector<int> > closed(H, vector<int>(W, INF));\n  while(!open.empty()){\n    PP tmp = open.top(); open.pop();\n    int y = tmp.second.first, x = tmp.second.second, cnt = tmp.first;\n    if(closed[y][x] <= cnt) continue;\n    closed[y][x] = cnt;\n    REP(i, 4){\n      int ny = y + my[i], nx = x + mx[i];\n      if(ny >= 0 && nx >= 0 && ny < H && nx < W) open.push(PP((v[y][x] == '#' && v[ny][nx] != '#' ? cnt + 1 : cnt), P(ny, nx)));\n    }\n  }\n  P tar;\n  REP(i, H) REP(j, W) if(v[i][j] == '&') tar = P(i, j);\n  return closed[tar.first][tar.second];\n}\n\nint main() {\n  while(cin >>W >>H && W){\n    v = vector<string>(H);\n    REP(i, H) cin >>v[i];\n    cout <<solve() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int INF = 1e9 + 10;\n\nusing namespace std;\n\nstruct Point {\n  int y, x, cost;\n  bool f;\n  Point() = default;\n  Point(int y, int x, int c, bool f): y(y), x(x), cost(c), f(f) { }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n\n    vector<string> c(m);\n    for (int i = 0; i < m; i++) {\n      cin >> c[i];\n    }\n\n    Point s;\n    int dy[] = { -1, 0, 1, 0 };\n    int dx[] = { 0, 1, 0, -1 };\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (c[i][j] == '&') {\n          s.y = i;\n          s.x = j;\n          s.cost = 0;\n        }\n      }\n    }\n\n    queue<Point> que;\n    que.push(s);\n\n    int ans = INF;\n\n    vector<vector<int>> checked(m);\n    for (int i = 0; i < m; i++) {\n      checked[i] = vector<int>(n, INF);\n    }\n\n    while (!que.empty()) {\n      if (ans == 0) {\n        break;\n      }\n      Point p = que.front(); que.pop();\n      if (checked[p.y][p.x] <= p.cost) {\n        continue;\n      }\n      checked[p.y][p.x] = p.cost;\n      for (int i = 0; i < 4; i++) {\n        int ny = p.y + dy[i];\n        int nx = p.x + dx[i];\n        if (ny < 0 || ny >= m) {\n          ans = min(ans, p.cost);\n          continue;\n        }\n        if (nx < 0 || nx >= n) {\n          ans = min(ans, p.cost);\n          continue;\n        }\n        int cost = 0;\n        bool f = false;\n        if (!p.f) {\n          if (c[ny][nx] == '#') {\n            f = true;\n            cost = 1;\n          } else {\n            f = false;\n          }\n        }\n        \n\n        que.push(Point(ny, nx, p.cost + cost, f));\n      }\n    }\n\n    cout << ans << endl;\n\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#define mp make_pair\n#define INF 1e+9\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair<int,PP> P;\n\nint main(){\n\tint n,m;\n\twhile(cin >> m >> n,m){\n\t\tint sx,sy,d[100][100];\n\t\tstring field[100];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> field[i];\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(field[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}else d[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0,mp(sx,sy)));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint cost = p.first,x = p.second.first,y = p.second.second;\n\t\t\tif(d[x][y] < cost) continue;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nx = x + dx[i],ny = y + dy[i],next = d[x][y];\n\t\t\t\tif(nx >= 0 && nx < n && ny >= 0 && ny < m){\n\t\t\t\t\tif(field[nx][ny] == '.' && field[x][y] == '#') next++;\n\t\t\t\t\tif(d[nx][ny] > next){\n\t\t\t\t\t\td[nx][ny] = next;\n\t\t\t\t\t\tque.push(mp(next,mp(nx,ny)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(!i || !j || i == n - 1 || j == m - 1) {\n\t\t\t\t\tif(field[i][j] == '#') d[i][j]++;\n\t\t\t\t\tmi = min(mi,d[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nvector<string> m;\nvector<vint> res;\n\nint main() {\n\tint h,w;\n\twhile(cin>>w>>h,h){\n\t\tm.clear();\n\t\tres.clear();\n\t\tint i,j;\n\t\tvint buf;\n\t\tfor(i=0;i<w;i++)buf.push_back(100100100);\n\t\tfor(i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\tm.push_back(str);\n\t\t\tres.push_back(buf);\n\t\t}\n\t\tbool update=true;\n\t\tint xx[]={1,-1,0,0},yy[]={0,0,1,-1};\n\t\tint k;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(i=0;i<h;i++){\n\t\t\t\tfor(j=0;j<w;j++){\n\t\t\t\t\tif(i==0||i==h-1||j==0||j==w-1){\n\t\t\t\t\t\tif(res[i][j]>=2){\n\t\t\t\t\t\t\tres[i][j]=m[i][j]=='#'?1:0;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(m[i][j]=='#'){\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tif(res[i+yy[k]][j+xx[k]]+1<res[i][j]){\n\t\t\t\t\t\t\t\tres[i][j]=res[i+yy[k]][j+xx[k]]+1;\n\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\t\tif(res[i+yy[k]][j+xx[k]]<res[i][j]){\n\t\t\t\t\t\t\t\tres[i][j]=res[i+yy[k]][j+xx[k]];\n\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n//cout<<res[i][j]<<\" \";\n\t\t\t\tif(m[i][j]=='&'){\n\t\t\t\t\tcout<<res[i][j]<<endl;\n\t\t\t\t}\n\t\t\t}\n//cout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#define mp make_pair\n#define INF 1e+9\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair<int,PP> P;\n\nint main(){\n\tint n,m;\n\twhile(cin >> m >> n,m){\n\t\tint sx,sy,d[100][100];\n\t\tstring field[100];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> field[i];\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(field[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t}else d[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0,mp(sx,sy)));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint cost = p.first,x = p.second.first,y = p.second.second;\n\t\t\tif(d[x][y] < cost) continue;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nx = x + dx[i],ny = y + dy[i],next = d[x][y];\n\t\t\t\tif(nx >= 0 && nx < n && ny >= 0 && ny < m){\n\t\t\t\t\tif(field[nx][ny] == '#') next++;\n\t\t\t\t\tif(d[nx][ny] > next){\n\t\t\t\t\t\td[nx][ny] = next;\n\t\t\t\t\t\tque.push(mp(next,mp(nx,ny)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < m;j++){\n\t\t\t\tif(!i || !j || i == n - 1 || j == m - 1) mi = min(mi,d[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\ndouble h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\tgx++; gy++;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\trep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\trep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tif(ny==gy && nx == gx) break;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy][gx]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint main()\n{\n  int n,m;\n  for(;cin>>n>>m,n;)\n    {\n      char maps[m][n];\n      for(int i=0;i<m;i++)\n\tfor(int j=0;j<n;j++)\n\t  cin>>maps[i][j];\n\n      //count,now;\n      priority_queue<pair<int,pair<int,int> > >qu;\n      for(int i=0;i<m;i++)\n\t{\n\t  qu.push(make_pair(0,make_pair(i,0)));\n\t  qu.push(make_pair(0,make_pair(i,n-1)));\n\t}\n      for(int i=0;i<n;i++)\n\t{\n\t  qu.push(make_pair(0,make_pair(0,i)));\n\t  qu.push(make_pair(0,make_pair(m-1,i)));\n\t}\n      bool closed[m][n];\n      memset(closed,false,sizeof(closed));\n      int dx[]={1,-1,0,0};\n      int dy[]={0,0,1,-1};\n      while(!qu.empty())\n\t{\n\t  int cnt=-(qu.top().first);\n\t  pair<int,int> now = qu.top().second;\n\t  int x=now.first;\n\t  int y=now.second;\n\t  qu.pop();\n\t  if(maps[x][y]=='&')\n\t    {\n\t      cout<<cnt<<endl;\n\t      break;\n\t    }\n\t  if(closed[x][y])\n\t    continue;\n\t  closed[x][y]=true;\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx=x+dx[i];\n\t      int ny=y+dy[i];\n\t      if(nx>=0 &&nx<m &&\n\t\t ny>=0 &&ny<n &&\n\t\t !closed[nx][ny])\n\t\t{\n\t\t  int ncnt=cnt;\n\t\t  if(maps[x][y]=='#' && maps[nx][ny]!='#' )\n\t\t    ncnt++;\n\t\t  qu.push(make_pair(-(ncnt),make_pair(nx,ny)));\n\t\t}\n\t    }\n\t}\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0},w,h,t,d[101][101];\nstring s[101];\nvoid dfs(int a,int b,char p){\n  d[a][b]=t;\n  r(i,4){\n    int y=a+dy[i],x=b+dx[i];\n    if(y>=0&&x>=0&&y<h&&x<w)\n      if(d[y][x]==1e9&&s[y][x]==p)dfs(y,x,p);\n  }\n}\nint main(){\n  while(cin>>w>>h,w){\n    r(i,h)r(j,w)d[i][j]=1e9;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)if(s[i][j]=='&'){\n      s[i][j]='.';t=0;\n      dfs(i,j,s[i][j]);\n    }\n    r(o,h*w)r(i,h)r(j,w)if(d[i][j]!=1e9)r(k,4){\n      int y=i+dy[k],x=j+dx[k];\n      if(y<0||x<0||y>=h||x>=w)continue;\n      if(s[i][j]==s[y][x])continue;\n      if(s[i][j]=='.')t=d[i][j]+1;\n      else t=d[i][j];\n      if(d[y][x]>t)dfs(y,x,s[i][j]);\n    }\n    int ans=1e9;\n    r(i,h)ans=min(ans,min(d[i][0],d[i][w-1]));\n    r(i,w)ans=min(ans,min(d[0][i],d[h-1][i]));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define MP make_pair\n\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint main(void){\n\tint n,m;\n\n\twhile(cin >> m && m){\n\t\tcin >> n;\n\t\tchar field[n][m];\n\t\tint step[n][m];\n\t\tbool visited[n][m];\n\t\tstring str;\n\t\tint x,y;\n\t\tdeque<pair<pair<int,int>, int> > q;\n\n\t\tmemset(step, -1, sizeof(step));\n\t\tmemset(visited,false,sizeof(visited));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tfield[i][j] = str[j];\n\t\t\t\tif(str[j] == '&'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpair<int,int> pos;\n\t\tint num;\n\t\tchar pos_type;\n\t\tq.push_back(MP(MP(x,y),0));\n\t\tvisited[x][y] = true;\n\t\twhile(1){\n\t\t\tif(q.empty()){\n\t\t\t\tbool find = false;\n\t\t\t\tfor(int i=0;i<n && !find;i++){\n\t\t\t\t\tfor(int j=0;j<m && !find;j++){\n\t\t\t\t\t\tif(pos_type == '.'){\n\t\t\t\t\t\t\tif(step[i][j] == num+1 && !visited[i][j]){\n\t\t\t\t\t\t\t\tq.push_back(MP(MP(i,j), num+1));\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(step[i][j] == num && !visited[i][j]){\n\t\t\t\t\t\t\t\tq.push_back(MP(MP(i,j), num));\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = q.front().first;\n\t\t\tx = pos.first;\n\t\t\ty = pos.second;\n\t\t\tnum = q.front().second;\n\t\t\tq.pop_front();\n\n\t\t\tpos_type = field[x][y];\n\n\t\t\tif(x == 0 || x == n-1 || y == 0 || y == m-1){\n\t\t\t\tcout << num << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstep[x][y] = num;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(!visited[x+dx[i]][y+dy[i]]){\n\t\t\t\t\tif(field[x+dx[i]][y+dy[i]] == field[x][y]){\n\t\t\t\t\t\tq.push_back(MP(MP(x+dx[i], y+dy[i]), num));\n\t\t\t\t\t\tvisited[x+dx[i]][y+dy[i]] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(pos_type == '.'){\n\t\t\t\t\t\t\tstep[x+dx[i]][y+dy[i]] = num+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tstep[x+dx[i]][y+dy[i]] = num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    int ans = 1<<29;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1\n             || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(ncost, Pii(nx, ny)));\n          }\n        } else {\n          ans = min(ans, cost);\n        }\n      }\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[120][120];\nint jp[120][120];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tque.push(PP(P(i,0),0));\n\t\tjp[i][0]=0;\n\t\tque.push(PP(P(i,m+1),0));\n\t\tjp[i][m+1]=0;\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tque.push(PP(P(0,i),0));\n\t\tjp[0][i]=0;\n\t\tque.push(PP(P(n+1,i),0));\n\t\tjp[n+1][i]=0;\n\t}\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(kx>=0 && kx<=n+1 && ky>=0 && ky<=m+1){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='&' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcin >> fie[j][i];\n\t\t\t\tif(fie[j][i]=='&')gx=j,gy=i;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",jp[gx][gy]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 101;\nint w, h;\nchar G[MAX_N][MAX_N];\n\nbool dfs(int x, int y, char c) {\n  bool isOver = (x==0||x==w-1||y==0||y==h-1);\n  G[y][x] = c;\n  for(int d = -1; d <= 1; d += 2) {\n    for(int i = 0; i < 2; ++i) {\n      int nx = x;\n      int ny = y;\n      if(i) nx += d;\n      else  ny += d;\n      if(nx < 0 || nx >= w) continue;\n      if(ny < 0 || ny >= h) continue;\n      if(G[ny][nx] == c) continue;\n      isOver = isOver || dfs(nx,ny,c);\n    }\n  }\n  return isOver;\n}\n\nint solve(int x, int y) {\n  int t;\n  for(t = 0; !dfs(x,y,'#'); dfs(x,y,'.'),++t);\n  return t;\n}\n\nint main() {\n  while(cin >> w >> h && (w|h)) {\n    int x, y;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n\tcin >> G[i][j];\n\tif(G[i][j] == '&') {\n\t  x = j;\n\t  y = i;\n\t  G[i][j] = '.';\n\t}\n      }\n    }\n    cout << solve(x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\nconst int hardCost = 100000;\nconst int dx[] = {1, 0, 0, -1};\nconst int dy[] = {0, 1, -1, 0};\nstruct P{ int x, y; P(int x, int y) : x(x), y(y) {} };\n\nint main()\n{\n    for(int n, m; cin >> n >> m && (n || m); )\n\t{\n\t\tP c(0, 0);\n\t\tvector<string> field(m);\n\t\tvector<vint> cost(n, vint(m, INF));\n\t\t\n\t\trep(i, m)\n\t\t{\n\t\t\tcin >> field[i];\n\t\t\t\n\t\t\tint pos = field[i].find(\"&\");\n\t\t\tif(pos != string::npos)\n\t\t\t{\n\t\t\t\tc.x = pos;\n\t\t\t\tc.y = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tcost[c.x][c.y] = 0;\n\t\tfor(que.push(c); !que.empty(); que.pop())\n\t\t{\n\t\t\tP cur = que.front();\n\t\t\t\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tP nxt(cur.x + dx[i], cur.y + dy[i]);\n\t\t\t\t\n\t\t\t\tif(0 <= nxt.x && nxt.x < n && 0 <= nxt.y && nxt.y < m)\n\t\t\t\t{\n\t\t\t\t\tint ct = cost[cur.x][cur.y] + (field[nxt.y][nxt.x] == '#' && field[cur.y][cur.x] != '#');\n\t\t\t\t\t\n\t\t\t\t\tif(ct < cost[nxt.x][nxt.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost[nxt.x][nxt.y] = ct;\n\t\t\t\t\t\tque.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 1 << 30;\n\t\t\n\t\trep(i, n) chmin(res, min(cost[i][0], cost[i][m-1]));\n\t\trep(i, m) chmin(res, min(cost[0][i], cost[n-1][i]));\n\t\t\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;//wall y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar A[105][105],B[105][105];\nint d[105][105];\npriority_queue<PP>Q;//need finit\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f,sizeof(d));\n\t\tfor(int i=0;i<=M+1;i++)for(int j=0;j<=N+1;j++)B[i][j]='.';\n\t\tfor(int i=0;i<M;i++)gets(B[i+1]+1);\n\t\tfor(int i=0;i<=M+1;i++){B[i][N+1]='.';B[i][N+2]=0;}\n\t\tN++;M++;\n\t\tQ.push(make_pair(0,make_pair(0,0)));\n\t\t//d[0][0]=0;\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tint cost=tmp.first;\n\t\t\tif(d[y][x]<=cost)continue;\n\t\t\tif(B[y][x]=='&')\n\t\t\t{\n\t\t\t\tres=min(res,cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[y][x]=cost;\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif(ny<0||ny>M||nx<0||nx>N)continue;\n\t\t\t\tint nc=cost+(B[y][x]=='#'&&B[ny][nx]!='#');\n\t\t\t\tif(nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1e9;\n\nint W, H, my[] = {0, 0, 1, -1}, mx[] = {1, -1, 0, 0};\nvector< vector<char> > v;\n\nint solve(){\n  priority_queue<PP, vector<PP>, greater<PP> > open;\n  open.push(PP(0, P(H - 1, 0)));\n  open.push(PP(0, P(H - 1, 0)));\n  open.push(PP(0, P(0, W - 1)));\n  open.push(PP(0, P(0, W - 1)));\n  FOR(i, 1, H) open.push(PP(0, P(i, 0)));\n  FOR(i, 1, W) open.push(PP(0, P(0, i)));\n  vector< vector<int> > closed(H, vector<int>(W, INF));\n  while(!open.empty()){\n  //REP(i, 10){\n    PP tmp = open.top(); open.pop();\n    int y = tmp.second.first, x = tmp.second.second, cnt = tmp.first;\n    if(closed[y][x] <= cnt) continue;\n    closed[y][x] = cnt;\n    REP(i, 4){\n      int ny = y + my[i], nx = x + mx[i];\n      if(ny >= 0 && nx >= 0 && ny < H && nx < W) open.push(PP((v[y][x] == '#' && v[ny][nx] == '.' ? cnt + 1 : cnt), P(ny, nx)));\n    }\n  }\n  P tar;\n  REP(i, H) REP(j, W) if(v[i][j] == '&') tar = P(i, j);\n  return closed[tar.first][tar.second];\n}\n\nint main() {\n  while(cin >>W >>H && W){\n    v = vector< vector<char> >(H, vector<char>(W));\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    cout <<solve() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[110][110];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint const OFFSET = 2;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    fill(grid[0], grid[0]+110*110, 'X');\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i+OFFSET][j+OFFSET];\n        if(grid[i+OFFSET][j+OFFSET] == '&') {\n          sx = j+OFFSET, sy = i+OFFSET;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      if(grid[y][x] == 'X') {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        int ans = 0;\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          Q.push(Piii(-ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass State\n{\npublic:\n  int x, y, cost;\n  bool water;\n\n  State(int _x, int _y, int _cost, bool _water)\n    :x(_x), y(_y), cost(_cost), water(_water) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    int sx, sy;\n    vector<string> castle(m);\n    for (int i = 0; i < m; ++i) {\n      cin >> castle[i];\n      castle[i].insert(castle[i].begin(), '.');\n      castle[i].insert(castle[i].end(), '.');\n\n      if (castle[i].find_first_of(\"&\") != string::npos) {\n\tsx = castle[i].find_first_of(\"&\");\n\tsy = i;\n\tcastle[sy][sx] = '.';\n      }\n    }\n    castle.insert(castle.begin(), string(n+2, '.'));\n    castle.push_back(string(n+2, '.'));\n    ++sy;\n\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0, false));\n    vector<vector<int> > dp(m+2, vector<int>(n+2, INF));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.x == 0 || st.x == n+1 || st.y == 0 || st.y == m+1) {\n\tcout << st.cost << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.x] < st.cost)\n\tcontinue;\n      dp[st.y][st.x] = st.cost;\n\n      for (int d = 0; d < 4; ++d) {\n\tint x = st.x + dx[d];\n\tint y = st.y + dy[d];\n\tif (x < 0 || n+2 <= x || y < 0 || m+2 <= y)\n\t  continue;\n\n\tif (st.water) {\n\t  if (castle[y][x] == '#' && dp[y][x] > st.cost) {\n\t    dp[y][x] = st.cost;\n\t    que.push(State(x, y, st.cost, true));\n\t  }\n\n\t  if (castle[y][x] == '.' && dp[y][x] > st.cost+1) {\n\t    dp[y][x] = st.cost+1;\n\t    que.push(State(x, y, st.cost+1, false));\n\t  }\n\t} else {\n\t  if (castle[y][x] == '#' && dp[y][x] > st.cost) {\n\t    dp[y][x] = st.cost;\n\t    que.push(State(x, y, st.cost, true));\n\t  }\n\n\t  if (castle[y][x] == '.' && dp[y][x] > st.cost) {\n\t    dp[y][x] == st.cost;\n\t    que.push(State(x, y, st.cost, false));\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n \nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n \ndouble h, w;\nchar C[210][210];\n \nint d[210][210];\n \nbool isOutOfRange(int x, int y){\n    if(x <= 0 || x > w || y<= 0 || y > h) return true;\n    return false;\n}\n \nint main(){\n    pii p;\n    int x, y, nx, ny, c, nc;\n    int gx, gy;\n    while(cin>>w>>h && h && w){\n        rep(i, h) scanf(\"%s\", C[i]);\n        //cout<<h<<\" \"<<w<<endl;\n        rep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n        gx++; gy++;\n        rep(i, 210) rep(j, 210) d[i][j] = -1;\n        priority_queue<pii, vector<pii>, greater<pii> > q;\n        rep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n        rep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            y = p.se/1000;\n            x = p.se%1000;\n            c = p.fi;\n            rep(i, 4){\n                nx = x + dx[i];\n                ny = y + dy[i];\n                if(isOutOfRange(nx, ny)) continue;\n                nc = c + (C[ny-1][nx-1]=='#'?1:0);\n                if(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n                d[ny][nx] = nc;\n                //if(ny==gy && nx == gx) continue;\n                q.push(mp(nc, ny*1000+nx));\n            }\n        }\n        cout<<d[gy][gx]<<endl;  \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nint N, M;\n\nstruct Data{\n\tint y, x, cost;\n\tData(){}\n\tData(int _y, int _x, int _cost){\n\t\ty = _y; x = _x; cost = _cost;\n\t}\n};\n\nbool IsOutside(int y, int x){\n\treturn y < 0 || N <= y || x < 0 || M <= x;\n}\n\nint main(){\n\twhile(cin >> N >> M, N || M){\n\t\tswap(N, M);\n\t\t\n\t\tchar fld[100][100];\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tint cost[100][100];\n\t\tfill_n( (int*)cost, 100*100, INT_MAX );\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < M; j++){\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif(fld[i][j] == '&') q.push( Data(i, j, 0) );\n\t\t\t}\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\t\t\tif(cost[q_front.y][q_front.x] <= q_front.cost) continue;\n\t\t\tcost[q_front.y][q_front.x] = q_front.cost;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i], nx = q_front.x + dx[i];\n\t\t\t\t\n\t\t\t\tif( IsOutside(ny, nx) ){\n\t\t\t\t\tans = min(ans, q_front.cost);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif(fld[q_front.y][q_front.x] != '#' && fld[ny][nx] == '#')\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\tq.push( Data(ny, nx, q_front.cost + cnt) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii, vector<Piii>, greater<Piii>> PQ;\n    PQ.push(Piii(0, Pii(sx, sy)));\n    while(!PQ.empty()) {\n      Piii piii = PQ.top(); PQ.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      if(!IN(x, y)) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          PQ.push(Piii(ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * ninja.cpp\n *\n *  Created on: 2011/07/28\n *      Author: isa\n */\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define MP make_pair\n\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint main(void){\n\tint n,m;\n\n\twhile(cin >> m){\n\t\tcin >> n;\n\t\tif((m|n) == 0) break;\n\t\tchar field[n][m];\n\t\tint step[n][m];\n\t\tbool visited[n][m];\n\t\tstring str;\n\t\tint x,y;\n\t\tdeque<pair<pair<int,int>, int> > q;\n\n\t\tmemset(step, -1, sizeof(step));\n\t\tmemset(visited,false,sizeof(visited));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tfield[i][j] = str[j];\n\t\t\t\tif(str[j] == '&'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//f[^ÇÝÝ±±ÜÅ\n\n\t\tpair<int,int> pos;\n\t\tint num;\n\t\tq.push_back(MP(MP(x,y),0));\n\t\t//BFS\n\t\twhile(1){\n\t\t\tif(q.empty()){\n\t\t\t\t//I¹»è\n\t\t\t\tbool ended = true;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\tif(!visited[i][j]) ended = false;\n\t\t\t\t\t\t//printf(\"%2d\", step[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\t//cout << endl;\n\t\t\t\t}\n\t\t\t\t//cout << endl;\n\t\t\t\tif(ended){\n\t\t\t\t\tint ret = 100000;\n\t\t\t\t\t//I¹\n\t\t\t\t\t//cout << \"process ended\" << endl;\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tret = min(ret, step[i][0]);\n\t\t\t\t\t\tret = min(ret, step[i][m-1]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\t\tret = min(ret,step[0][i]);\n\t\t\t\t\t\tret = min(ret,step[n-1][i]);\n\t\t\t\t\t}\n\t\t\t\t\tcout << ret << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t//ÄJ\n\t\t\t\t\tbool find = false;\n\t\t\t\t\tfor(int i=0;i<n && !find;i++){\n\t\t\t\t\t\tfor(int j=0;j<m && !find;j++){\n\t\t\t\t\t\t\t//¢KâÅ\n\t\t\t\t\t\t\tif(!visited[i][j]){\n\t\t\t\t\t\t\t\tint tmpstep=100000;\n\t\t\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\t\t\tif(0 <= i+dx[k] && i+dx[k] <= n-1 && 0 <= j+dy[k] && j+dy[k] <= m-1){\n\t\t\t\t\t\t\t\t\t\tif(visited[i+dx[k]][j+dy[k]]){\n\t\t\t\t\t\t\t\t\t\t\ttmpstep = min(tmpstep, step[i+dx[k]][j+dy[k]]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(tmpstep != 100000){\n\t\t\t\t\t\t\t\t\tif(field[i][j] == '.'){\n\t\t\t\t\t\t\t\t\t\tq.push_back(MP(MP(i,j),tmpstep));\n\t\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\t\tq.push_back(MP(MP(i,j),tmpstep+1));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = q.front().first;\n\t\t\tx = pos.first;\n\t\t\ty = pos.second;\n\t\t\tnum = q.front().second;\n\t\t\tq.pop_front();\n\t\t\tstep[x][y] = num;\n\t\t\tvisited[x][y] = true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0 <= x+dx[i] && x+dx[i] <= n-1 && 0 <= y+dy[i] && y+dy[i] <= m-1){\n\t\t\t\t\tif(field[x][y] == field[x+dx[i]][y+dy[i]]){\n\t\t\t\t\t\tif(!visited[x+dx[i]][y+dy[i]] && find(q.begin(),q.end(),MP(MP(x+dx[i],y+dy[i]), num)) == q.end()){\n\t\t\t\t\t\t\tq.push_back(MP(MP(x+dx[i],y+dy[i]), num));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nchar field[101][101];\nbool passed[101][101];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint h,w;\n// ×ÚÇÀWÌXg\nvector<pair<int,int> > walls;\nvector<pair<int,int> > spList;\n\n\nbool bfs(int sx,int sy,bool w){\n\t// Ü¸ÊÉbfs\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\t\n\tprv->push(make_pair(sy,sx));\n\tbool fin=false;\n\tpassed[sy][sx]=true;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> p = prv->front();\n\t\t\tprv->pop();\n\t\t\t// ÇÉBµ½çAI¹\n\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// lûüÉÚ®\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\tif(!passed[ny][nx]){\n\t\t\t\t\tif(w){\n\t\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t\t\t\t\twalls.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(field[ny][nx]=='#'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]='.'){\n\t\t\t\t\t\t\tspList.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\treturn false;\n}\n\nint main(){\n\n\t// ÇÉÕË·éÜÅbfsðJè©¦·\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\twalls.clear();\n\t\tspList.clear();\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='&')\n\t\t\t\t\tsx=j,sy=i;\n\t\t\t}\n\t\t\tfill(passed[i],passed[i]+w,false);\n\t\t}\n\t\tint cnt=0;\n\t\tbool fin=false;\n\t\tspList.push_back(make_pair(sy,sx));\n\t\twhile(1){\n\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n\t\t\tfor(int i = 0; i < spList.size(); i++){\n\t\t\t\tint cx=spList[i].second;\n\t\t\t\tint cy=spList[i].first;\n\t\t\t\tif(bfs(cx,cy,true)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tspList.clear();\n\t\t\tcnt++;\n\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n\t\t\tfor(int i = 0; i < walls.size(); i++){\n\t\t\t\tint cx=walls[i].second;\n\t\t\t\tint cy=walls[i].first;\n\t\t\t\tif(bfs(cx,cy,false)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\twalls.clear();\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nchar field[101][101];\nbool passed[101][101];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint h,w;\n// ×ÚÇÀWÌXg\nvector<pair<int,int> > walls;\nvector<pair<int,int> > spList;\n\n\nbool bfs(int sx,int sy,bool w){\n\t// Ü¸ÊÉbfs\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\t\n\tprv->push(make_pair(sy,sx));\n\tbool fin=false;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> p = prv->front();\n\t\t\tprv->pop();\n\t\t\tpassed[p.first][p.second]=true;\n\t\t\t// ÇÉBµ½çAI¹\n\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// lûüÉÚ®\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\tif(!passed[ny][nx]){\n\t\t\t\t\tif(w){\n\t\t\t\t\t\tif(field[ny][nx]=='.')\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t\t\t\t\twalls.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(field[ny][nx]=='#'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]='.'){\n\t\t\t\t\t\t\tspList.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\treturn false;\n}\n\nint main(){\n\n\t// ÇÉÕË·éÜÅbfsðJè©¦·\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='&')\n\t\t\t\t\tsx=j,sy=i;\n\t\t\t}\n\t\t\tfill(passed[i],passed[i]+w,false);\n\t\t}\n\t\tint cnt=0;\n\t\tbool fin=false;\n\t\tspList.push_back(make_pair(sy,sx));\n\t\twhile(1){\n\t\t\t//// Ü¸ÊÉbfs\n\t\t\t//queue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\t\t\t//queue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\n\t\t\t//// ×ÚÇÀWÌXg\n\t\t\t//vector<pair<int,int> > walls;\n\n\t\t\t//prv->push(make_pair(sy,sx));\n\t\t\t//bool fin=false;\n\t\t\t//while(prv->size()){\n\t\t\t//\twhile(prv->size()){\n\t\t\t//\t\tpair<int,int> p = prv->front();\n\t\t\t//\t\tprv->pop();\n\t\t\t//\t\tpassed[p.first][p.second]=true;\n\t\t\t//\t\t// ÇÉBµ½çAI¹\n\t\t\t//\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t//\t\t\tfin=true;\n\t\t\t//\t\t\tbreak;\n\t\t\t//\t\t}\n\t\t\t//\t\t// lûüÉÚ®\n\t\t\t//\t\tfor(int i = 0; i < 4; i++){\n\t\t\t//\t\t\tint nx=p.second+dx[i];\n\t\t\t//\t\t\tint ny=p.first+dy[i];\n\t\t\t//\t\t\tif(!passed[ny][nx]){\n\t\t\t//\t\t\t\tif(field[ny][nx]=='.')\n\t\t\t//\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t//\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t//\t\t\t\t\twalls.push_back(make_pair(ny,nx));\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t}\n\t\t\t//\t\t}\n\t\t\t//\t}\n\t\t\t//\tif(fin)\n\t\t\t//\t\tbreak;\n\t\t\t//\tswap(prv,nxt);\n\t\t\t//}\n\n\t\t\t//if(fin)\n\t\t\t//\tbreak;\n\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n\t\t\tfor(int i = 0; i < spList.size(); i++){\n\t\t\t\tint cx=spList[i].second;\n\t\t\t\tint cy=spList[i].first;\n\t\t\t\tif(bfs(cx,cy,true)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tspList.clear();\n\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n\t\t\tfor(int i = 0; i < walls.size(); i++){\n\t\t\t\tint cx=walls[i].second;\n\t\t\t\tint cy=walls[i].first;\n\t\t\t\tif(bfs(cx,cy,false)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\twalls.clear();\n\t\t\t// JEgðâ·\n\t\t\tcnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar field[101][101];\nbool passed[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nqueue<pair<int,int> > *prv;\nqueue<pair<int,int> > *nxt;\n\nbool ok;\n\nvoid dfs(int y,int x){\n    if(y==h-1||y==0||x==0||x==w-1){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]){\n            // xÈçnxtÉpushµÄI¹\n            if(field[ny][nx]=='#'){\n                passed[ny][nx]=true;\n                nxt->push(make_pair(ny,nx));\n            }\n            else{\n                passed[ny][nx]=true;\n                dfs(ny,nx);\n            }\n        }\n    }\n}\nint main(){\n    prv=new queue<pair<int,int> >();\n    nxt=new queue<pair<int,int> >();\n    while(cin>>w>>h&&!(h==0&&w==0)){\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        int sy,sx;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n                if(field[i][j]=='&'){\n                    sy=i;\n                    sx=j;\n                    field[i][j]='.';\n                }\n            }\n        }\n        prv->push(make_pair(sy,sx));\n        int cnt=0;\n        while(prv->size()){\n            while(prv->size()){\n                pair<int,int> &p=prv->front();\n                if(!passed[p.first][p.second]||field[p.first][p.second]=='#'){\n                    passed[p.first][p.second]=true;\n                    dfs(prv->front().first,prv->front().second);\n                }\n                prv->pop();\n            }\n            swap(prv,nxt);\n            if(ok)\n                break;\n            cnt++;\n        }\n        cout<<cnt<<endl;\n        while(prv->size())prv->pop();\n        while(nxt->size())nxt->pop();\n    }\n    delete nxt;\n    delete prv;\n    return 0;\n}\n\n\n//char field[101][101];\n//bool passed[101][101];\n//\n//const int dy[]={-1,0,0,1};\n//const int dx[]={0,-1,1,0};\n//\n//int h,w;\n//// ×ÚÇÀWÌXg\n//set<pair<int,int> > walls;\n//set<pair<int,int> > spList;\n//\n//\n//bool bfs(int sx,int sy,bool w){\n//\t// Ü¸ÊÉbfs\n//\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n//\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n//\t\n//\tprv->push(make_pair(sy,sx));\n//\tbool fin=false;\n//\tpassed[sy][sx]=true;\n//\twhile(prv->size()){\n//\t\twhile(prv->size()){\n//\t\t\tpair<int,int> p = prv->front();\n//\t\t\tprv->pop();\n//\t\t\t// ÇÉBµ½çAI¹\n//\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n//\t\t\t\treturn true;\n//\t\t\t}\n//\t\t\t// lûüÉÚ®\n//\t\t\tfor(int i = 0; i < 4; i++){\n//\t\t\t\tint nx=p.second+dx[i];\n//\t\t\t\tint ny=p.first+dy[i];\n//\t\t\t\tif(!passed[ny][nx]){\n//\t\t\t\t\tif(w){\n//\t\t\t\t\t\tif(field[ny][nx]=='.'){\n//\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n//\t\t\t\t\t\t\tpassed[ny][nx]=true;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n//\t\t\t\t\t\t\twalls.insert(make_pair(ny,nx));\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tif(field[ny][nx]=='#'){\n//\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n//\t\t\t\t\t\t\tpassed[ny][nx]=true;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(field[ny][nx]='.'){\n//\t\t\t\t\t\t\tspList.insert(make_pair(ny,nx));\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tswap(prv,nxt);\n//\t}\n//\treturn false;\n//}\n//\n//int main(){\n//\n//\t// ÇÉÕË·éÜÅbfsðJè©¦·\n//\twhile(cin>>w>>h&&!(w==0&&h==0)){\n//\t\twalls.clear();\n//\t\tspList.clear();\n//\t\tint sx,sy;\n//\t\tfor(int i = 0; i < h; i++){\n//\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\tcin>>field[i][j];\n//\t\t\t\tif(field[i][j]=='&')\n//\t\t\t\t\tsx=j,sy=i;\n//\t\t\t}\n//\t\t\tfill(passed[i],passed[i]+w,false);\n//\t\t}\n//\t\tint cnt=0;\n//\t\tbool fin=false;\n//\t\tspList.insert(make_pair(sy,sx));\n//\t\twhile(1){\n//\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n//\t\t\tfor(set<pair<int,int> >::iterator it = spList.begin(); it != spList.end(); it++){\n//\t\t\t\tint cx=it->second;\n//\t\t\t\tint cy=it->first;\n//\t\t\t\tif(bfs(cx,cy,true)){\n//\t\t\t\t\tfin=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(fin)\n//\t\t\t\tbreak;\n//\t\t\tspList.clear();\n//\t\t\tcnt++;\n//\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n//\t\t\tfor(set<pair<int,int> >::iterator it = walls.begin(); it != walls.end(); it++){\n//\t\t\t\tint cx=it->second;\n//\t\t\t\tint cy=it->first;\n//\t\t\t\tif(bfs(cx,cy,false)){\n//\t\t\t\t\tfin=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(fin)\n//\t\t\t\tbreak;\n//\t\t\twalls.clear();\n//\t\t}\n//\t\tcout<<cnt<<endl;\n//\t}\n//\n//\treturn 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 10000;\nconst int MAX = 100;\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {-1, 0, 1, 0};\nint m,n,sx,sy;\nint step[MAX + 2][MAX + 2];\nchar field[MAX + 2][MAX + 2];\n\nint main()\n{\n    while(cin >> n >> m && m) {\n        memset(step, INF, sizeof(step));\n        memset(field, '.', sizeof(field));\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                cin >> field[i][j];\n                if(field[i][j] == '&') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        queue<P> que;\n        que.push(P(sx, sy));\n        step[sy][sx] = 0;\n        while(!que.empty()) {\n            P p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            for(int k = 0; k < 4; k++) {\n                int nx = x + dx[k], ny = y + dy[k], s = step[y][x];\n                if(field[ny][nx] == '#') s++;\n                if(nx >= 0 && nx <= n + 1  && ny >= 0 && ny <= m + 1 && s < step[ny][nx]) {\n                    step[ny][nx] = s;\n                    que.push(P(nx, ny));\n                }\n            }\n        }\n\n        int res = INF;\n        for(int i = 0; i <= m + 1; i++)\n            for(int j = 0; j <= n + 1; j++)\n                if(i == 0 || i == m + 1 || j == 0 || j == n + 1) \n                    res = min(res, step[i][j]);\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\n\n\nint main()\n{\n\tint x, y;\n\twhile (cin >> x >> y&&x)\n\t{\n\t\tint a[200][200] = {};\n\t\tint f[200][200];\n\t\tmemset(f, -1, sizeof f);\n\t\tpii s;\n\t\tfor (int i = 1; i <= y; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= x; j++)\n\t\t\t{\n\t\t\t\tchar c; cin >> c;\n\t\t\t\ta[i][j] = c == '#';\n\t\t\t\tif (c == '&')\n\t\t\t\t{\n\t\t\t\t\ts.first = i;\n\t\t\t\t\ts.second = j;\n\t\t\t\t}\n\t\t\t\tf[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tf[s.first][s.second] = 0;\n\t\tqueue<pii> que; que.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += dy[i];\n\t\t\t\tnext.second += dx[i];\n\t\t\t\tif (f[next.first][next.second]>f[now.first][now.second] + a[now.first][now.second])\n\t\t\t\t{\n\t\t\t\t\tf[next.first][next.second] = f[now.first][now.second] + a[now.first][now.second];\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= y; i++)ans = min({ ans,f[i][1]+a[i][1],f[i][x]+a[i][x] });\n\t\tfor (int j = 1; j <= x; j++)ans = min({ ans,f[1][j]+a[1][j],f[y][j]+a[y][j] });;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <utility>\n#include <map>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int , int>P;\ntypedef pair<P,P>PP;//wall dist y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar B[105][105];\nP d[105][105];\n\nstruct Order\n{\n\tbool operator ()(PP const&a, PP const&b) const\n\t{\n\t\tif(a.first.first==b.first.first)\n\t\t\treturn a.first.second>b.first.second;\n\t\treturn a.first.first>b.first.first;\n\t}\n};\n\npriority_queue<PP,vector<PP>,Order>Q; //need finit\n\nvoid Pset(int y, int x)\n{\n\td[y][x]=make_pair(0,0);\n\tQ.push(make_pair(make_pair(0,0),make_pair(y,x)));\n}\n\nint main()\n{\n\tfor (;scanf(\"%d%d\\n\" ,&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f, sizeof (d));\n\t\tfor(int i=0;i<=M+1;i++)for(int j=0;j<=N+1;j++)B[i][j]='.';\n\t\tfor(int i=0;i<M;i++)gets(B[i+1]+1);\n\t\tfor(int i=0;i<=M+1;i++){B[i][N+1]='.';B[i][N+2]=0;}\n\t\tN++;M++;\n\t\tQ.push(make_pair(make_pair(0,0),make_pair(0,0)));\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tP cost=tmp.first;\n\t\t\tif (d[y][x]<cost)continue;\n\t\t\tif (B[y][x]=='&' )\n\t\t\t{\n\t\t\t\tres=min(res,cost.first);\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\tfor (int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif (ny<0||ny>M||nx<0||nx>N) continue;\n\t\t\t\tP nc=make_pair(cost.first+(B[y][x]=='#' &&B[ny][nx]!= '#'),cost.second+1);\n\t\t\t\tif (nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\td[ny][nx]=nc;\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf( \"%d\\n\" ,res);\n\t}\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, pair<int, int> > PP;\n\nchar M[105][105];\nbool v[105][105];\n\nint bfs (int m, int n, P sp )\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tpriority_queue<PP, vector <PP>, greater<PP> > que;\n\tque.push (PP(0, sp ) );\n\t\n\twhile (!que.empty() ){\n\t\tPP curr = que.top(); que.pop();\n\t\tint cost = curr.first;\n\t\tint cr = curr.second.first, cc = curr.second.second;\n\t\tv[cr][cc] = true;\n\t\trep (k, 4 ){\n\t\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\t\tif (v[nr][nc] ) continue;\n\t\t\tif (nr < 0 || nr > m+1 || nc < 0 || nc > n+1 )\n\t\t\t\treturn cost;\n\t\t\tif (M[cr][cc] == '#' && M[nr][nc] == '.' ){\n\t\t\t\tque.push ( PP (cost+1, P (nr, nc ) ) );\n\t\t\t}else{\n\t\t\t\tque.push ( PP (cost, P (nr, nc ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn -1;\n} \nvoid init_map (int m, int n )\n{\n\trep (i, m+2 )\n\t\trep (j, n+2 )\n\t\t\tM[i][j] = '.';\n}\n\nint main()\n{\n\tint n, m;\t// n: ¼Ì m: ìkÌ \n\n\twhile (cin >> n >> m && n && m ){\n\t\tP sp;\n\t\tinit_map (m, n );\t\n\t\tmemset (v, false, sizeof (v ) );\t\n\t\tfor (int i = 1; i <= m; i++ ){\n\t\t\tfor (int j = 1; j <= n; j++ ){\n\t\t\t\tcin >> M[i][j];\n\t\t\t\tif (M[i][j] == '&' ){\n\t\t\t\t\tsp.first = i, sp.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tint res = bfs (m, n, sp );\n\t\tcout << res << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tqueue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.front();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\t//res = st.d;\n\t\t\t\t//break;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (d[tx][ty] > st.d + (grid[st.d][st.d] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[st.x][st.y] == '#')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d[0][0]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<string> v(m);\n        for(int i=0; i<m; ++i) {\n            cin >> v[i];\n        }\n\n        int sy, sx;\n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                if(v[i][j] == '&') {\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n\n        using state = tuple<int, int, int>;\n        vector<vector<int>> d(m, vector<int>(n, INF));\n        priority_queue<state, vector<state>, greater<state>> que;\n        d[sy][sx] = 0;\n        que.push(make_tuple(0, sy, sx));\n        int dx[4] = {0, 1, 0, -1},\n            dy[4] = {1, 0, -1, 0};\n        int res = INF;\n        while(!que.empty()) {\n            int cur, y, x;\n            tie(cur, y, x) = que.top();\n            que.pop();\n            if(d[y][x] < cur) {\n                continue;\n            }\n            for(int i=0; i<4; ++i) {\n                int ny = y + dy[i], nx = x + dx[i];\n                if(ny < 0 || m <= ny || nx < 0 || n <= nx) {\n                    res = min(res, d[y][x]);\n                    continue;\n                }\n                if(d[ny][nx] > d[y][x] + ((v[y][x] == '.' || v[y][x] == '&') && v[ny][nx] == '#')) {\n                    d[ny][nx] = d[y][x] + ((v[y][x] == '.' || v[y][x] == '&') && v[ny][nx] == '#');\n                    que.push(make_tuple(d[ny][nx], ny, nx));\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar MapData[100][100];\nint Cost[100][100];\nqueue<pair<int, int> > QueueData;\n\n\nvoid solve(int totalRow, int totalCol) {\n\tint curtRow, curtCol, cost;\n\tint dx[] = { 1,0,-1,0 };\n\tint dy[] = { 0,1,0,-1 };\n\n\t//cout << QueueData.front().first << \" \" << QueueData.front().second << endl;\n\twhile (!QueueData.empty()) {\n\t\tpair<int, int> current = QueueData.front();\n\t\tQueueData.pop();\n\t\tfor (int j = 0; j < 4; j++) {\n\t\t\tcurtRow = current.first + dy[j];\n\t\t\tcurtCol = current.second + dx[j];\n\t\t\tif (curtRow<0 || curtRow>totalRow - 1 || curtCol<0 || curtCol>totalCol - 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcost = Cost[current.first][current.second];\n\t\t\tif (MapData[curtRow][curtCol] == '#' && MapData[current.first][current.second] == '.') {\n\t\t\t\t++cost;\n\t\t\t}\n\t\t\tif (cost >= Cost[curtRow][curtCol]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCost[curtRow][curtCol] = cost;\n\t\t\tQueueData.push(make_pair(curtRow, curtCol));\n\t\t}\n\t}\n}\n\nint main() {\n\tint m, n, cnt;\n\n\twhile (cin >> n >> m, n) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcin >> MapData[i][j];\n\t\t\t\tCost[i][j] = 10000000;\n\t\t\t\tif (MapData[i][j] == '&') {\n\t\t\t\t\tMapData[i][j] = '.';\n\t\t\t\t\tCost[i][j] = 0;\n\t\t\t\t\tQueueData.push(make_pair(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(m, n);\n\t\tcnt = 10000000;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcnt = min(cnt, Cost[i][0]);\n\t\t\tcnt = min(cnt, Cost[i][n - 1]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt = min(cnt, Cost[0][i]);\n\t\t\tcnt = min(cnt, Cost[m - 1][i]);\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\n#define P pair<int,int>\nusing namespace std;\n\nint a, b;\nstring c[105];\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvector<P>V;\nint main() {\n\twhile (cin >> b >> a, a || b) {\n\t\tstring f;\n\t\tfor (int g = 0; g < b + 2; g++)f += \".\";\n\t\tc[0] = c[a + 1] = f;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d + 1] = \".\" + e + \".\";\n\t\t}\n\t\ta+=2; b+=2;\n\t\tfor (int I = 0;I<105; I++) {\n\t\t\tqueue<P>Q;\n\t\t\tQ.push(P(0,0));\n\t\t\tc[0][0] = 0;\n\t\t\tV.push_back(P(0,0));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP t = Q.front(); Q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b) {\n\t\t\t\t\t\tif (c[x][y] == '.') {\n\t\t\t\t\t\t\tV.push_back(P(x, y));\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tQ.push(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '#') {\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tV.push_back(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '&') {\n\t\t\t\t\t\t\tcout << I << endl;\n\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (P o : V) {\n\t\t\t\tc[o.first][o.second] = '.';\n\t\t\t}\n\t\t\tV.clear();\n\t\t}\n\tl:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\n//0156\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n\nint d[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n    if(x < 0 || x >= w || y < 0 || y >= h) return true;\n    return false;\n}\n\nstring s[110];\n\nint main(){\n    int x, y;\n    int sx, sy;\n    while(cin>>x>>y && x && y){\n        rep(i, y) cin>>s[i];\n        rep(i, y) rep(j, x){\n            if(s[i][j] == '&'){\n                sx = j;\n                sy = i;\n            }\n            d[i][j] = INF;\n        }\n        //cout<<y<<\" \"<<x<<endl;\n        priority_queue<pair<int, pii> > q;\n        q.push(mp(0, mp(sy, sx)));\n        d[sy][sx] = 0;\n        pair<int, pii> p;\n        int ans = INF;\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            //cout<<\" \"<<p.fi<<\" (\"<<p.se.fi<<\", \"<<p.se.fi<<endl;\n            rep(i, 4){\n                int nx = p.se.se + dx[i];\n                int ny = p.se.fi + dy[i];\n                if(isOutOfRange(nx, ny, x, y)){\n                    ans = min(ans, -p.fi);\n                    break;\n                }\n                int c = -p.fi + (s[ny][nx]=='#'?1:0);\n                if(d[ny][nx] <= c) continue;\n                d[ny][nx] = c;\n                q.push(mp(-c, mp(ny, nx)));\n            }\n            if(ans != INF) break;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nchar str[102][102];\nint bfs[102][102];\nint v[102][102];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++)\n\t\t\t\tstr[i][j]='.';\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",str[i]+1);\n\t\t}\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++){\n\t\t\t\tbfs[i][j]=-1;\n\t\t\t\tv[i][j]=0;\n\t\t\t}\n\t\tbfs[0][0]=0;\n\t\tdeque<pair<int,int> > Q;\n\t\tQ.push_back(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop_front();\n\t\t\tif(v[row][col])continue;\n\t\t\tv[row][col]=1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<102&&0<=col+dy[i]&&col+dy[i]<102){\n\t\t\t\t\tif((!~bfs[row+dx[i]][col+dy[i]])||(bfs[row+dx[i]][col+dy[i]]>bfs[row][col]+(((str[row][col]=='#')&&(str[row+dx[i]][col+dy[i]]!='#'))?1:0))){\n\t\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col]+(((str[row][col]=='#')&&(str[row+dx[i]][col+dy[i]]!='#'))?1:0);\n\t\t\t\t\t\tif(((str[row][col]=='#')&&(str[row+dx[i]][col+dy[i]]!='#'))){\n\t\t\t\t\t\t\tQ.push_back(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t\t}else Q.push_front(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){\n\t\t\tfor(int j=0;j<102;j++){\n\t\t\t\tif(str[i][j]=='&')printf(\"%d\\n\",bfs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<climits>\nusing namespace std;\n\nconst int dy[4] = {-1, 0, 1, 0}, dx[4] = {0, 1, 0, -1};\n\nint N, M;\n\nstruct Data{\n\tint y, x, cost;\n\tData(){}\n\tData(int _y, int _x, int _cost){\n\t\ty = _y; x = _x; cost = _cost;\n\t}\n};\n\nbool IsOutside(int y, int x){\n\treturn y < 0 || N <= y || x < 0 || M <= x;\n}\n\nint main(){\n\twhile(cin >> N >> M, N || M){\n\t\tswap(N, M);\n\t\t\n\t\tchar fld[100][100];\n\t\tqueue<Data> q;\n\t\tData q_front;\n\t\tint cost[100][100];\n\t\tfill_n( (int*)cost, 100*100, INT_MAX );\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < M; j++){\n\t\t\t\tcin >> fld[i][j];\n\t\t\t\tif(fld[i][j] == '&') q.push( Data(i, j, 0) );\n\t\t\t}\n\t\t}\n\n\t\tint ans = INT_MAX;\n\t\twhile( !q.empty() ){\n\t\t\tq_front = q.front(); q.pop();\n\t\t\tif(cost[q_front.y][q_front.x] <= q_front.cost) continue;\n\t\t\tcost[q_front.y][q_front.x] = q_front.cost;\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint ny = q_front.y + dy[i], nx = q_front.x + dx[i];\n\t\t\t\t\n\t\t\t\tif( IsOutside(ny, nx) ){\n\t\t\t\t\tans = min(ans, q_front.cost);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif(fld[q_front.y][q_front.x] != '#' && fld[ny][nx] == '#')\n\t\t\t\t\t\tcnt = 1;\n\t\t\t\t\tq.push( Data(ny, nx, q_front.cost + cnt) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;//wall y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar B[105][105];\nint d[105][105];\npriority_queue<PP>Q;//need finit\n\nvoid Pset(int y,int x)\n{\n\td[y][x]=0;\n\tQ.push(make_pair(0,make_pair(y,x)));\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f,sizeof(d));\n\t\tfor(int i=0;i<M;i++)gets(B[i]);\n\t\t\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tif(B[i][0]=='.')Pset(i,0);\n\t\t\tif(B[i][N-1]=='.')Pset(i,N-1);\n\t\t}\n\t\tfor(int i=1;i<N-1;i++)\n\t\t{\n\t\t\tif(B[0][i]=='.')Pset(0,i);\n\t\t\tif(B[M-1][i]=='.')Pset(M-1,i);\n\t\t}\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tint cost=tmp.first;\n\t\t\tif(d[y][x]<cost)continue;\n\t\t\tif(B[y][x]=='&')\n\t\t\t{\n\t\t\t\tres=min(res,cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif(ny<0||ny>=M||nx<0||nx>=N)continue;\n\t\t\t\tint nc=cost+(B[y][x]=='#'&&B[ny][nx]!='#');\n\t\t\t\tif(nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\td[ny][nx]=nc;\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar field[101][101];\nbool passed[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nqueue<pair<int,int> > *prv;\nqueue<pair<int,int> > *nxt;\n\nbool ok;\n\nvoid dfs(int y,int x){\n    if(y==h-1||y==0||x==0||x==w-1){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]){\n            // ツ堀ツづ按づァnxtツづ英ushツつオツづ終ツ猟ケ\n            if(field[ny][nx]=='#'){\n                passed[ny][nx]=true;\n                nxt->push(make_pair(ny,nx));\n            }\n            else{\n                passed[ny][nx]=true;\n                dfs(ny,nx);\n            }\n        }\n    }\n}\nint main(){\n    prv=new queue<pair<int,int> >();\n    nxt=new queue<pair<int,int> >();\n    while(cin>>w>>h&&!(h==0&&w==0)){\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        int sy,sx;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n                if(field[i][j]=='&'){\n                    sy=i;\n                    sx=j;\n                    field[i][j]='.';\n                }\n            }\n        }\n        prv->push(make_pair(sy,sx));\n        int cnt=0;\n        while(prv->size()){\n            while(prv->size()){\n                pair<int,int> &p=prv->front();\n                dfs(prv->front().first,prv->front().second);\n                prv->pop();\n            }\n            swap(prv,nxt);\n            if(ok)\n                break;\n            cnt++;\n        }\n        cout<<cnt<<endl;\n        while(prv->size())prv->pop();\n        while(nxt->size())nxt->pop();\n    }\n    delete nxt;\n    delete prv;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,m,flag,dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nchar c[100][100];\n\nvoid paint(int x,int y,char ch){\n\tc[y][x]='o';\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx>=0&&nx<n&&ny>=0&&ny<m){\n\t\t\tif(c[ny][nx]==ch)paint(nx,ny,ch);\n\t\t\tif(c[ny][nx]=='&')flag=1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\tflag=0;\n\t\trep(i,m)rep(j,n){\n\t\t\tcin>>c[i][j];\n\t\t\tif(i==0||i==m-1||j==0||j==n-1){\n\t\t\t\tif(c[i][j]=='.')c[i][j]='o';\n\t\t\t\tif(c[i][j]=='&')flag=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\twhile(!flag){\n\t\t\tif(t==1)rep(i,m)rep(j,n)if((i==0||i==m-1||j==0||j==n-1)&&c[i][j]=='#')c[i][j]='o';\n\t\t\tif(t)rep(i,m)rep(j,n)if(c[i][j]=='o')paint(j,i,'#');\n\t\t\trep(i,m)rep(j,n)if(c[i][j]=='o')paint(j,i,'.');\n\t\t\tif(!flag)t++;\n\t\t}\n\t\tcout<<t<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<int,Pt> P;\n#define fr first\n#define sc second\n#define INF (1 << 30)\n#define FOR(i,b,n) for(int i = (b) ; i < (n) ; ++i )\n#define rep(i,n) FOR(i,0,n)\nchar mas[105][105];\nint w,h,d[]={0,1,0,-1};\nint used[105][105];\nint bfs(){\n  priority_queue< P , vector<P> , greater<P> > que;\n  fill_n(used[0],105*105,INF);\n  que.push(P(0,Pt(0,0)));\n  used[0][0] = 0;\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    if(mas[p.sc.fr][p.sc.sc] == '&') return p.fr;\n    rep(i,4){\n      int nx = p.sc.fr + d[i] , ny = p.sc.sc + d[3-i] , pt = p.fr;\n      if(!(nx>=0&&nx<h+2&&ny>=0&&ny<w+2)) continue;\n      if(mas[nx][ny] == '#') pt++;\n      if(used[nx][ny] > pt){\n        que.push(P(pt,Pt(nx,ny)));\n        used[nx][ny] = pt;\n      }\n    }\n  }\n}\nint main(){\n  rep(i,102) mas[0][i] = '.';\n  while(cin >> w >> h , w){\n    FOR(i,1,h+1){\n      mas[i][0] = mas[i][w+1] = '.';\n      FOR(j,1,w+1) cin >> mas[i][j];\n    }\n    rep(i,w+2) mas[h+1][i] = '.';\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar field[101][101];\nbool passed[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nqueue<pair<int,int> > *prv;\nqueue<pair<int,int> > *nxt;\n\nbool ok;\n\nvoid dfs(int y,int x){\n    if(y==h-1||y==0||x==0||x==w-1){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]){\n            // xÈçnxtÉpushµÄI¹\n            if(field[ny][nx]=='#'){\n                nxt->push(make_pair(ny,nx));\n            }\n            else{\n                passed[ny][nx]=true;\n                dfs(ny,nx);\n            }\n        }\n    }\n}\nint main(){\n    prv=new queue<pair<int,int> >();\n    nxt=new queue<pair<int,int> >();\n    while(cin>>w>>h&&!(h==0&&w==0)){\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        int sy,sx;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n                if(field[i][j]=='&'){\n                    sy=i;\n                    sx=j;\n                    field[i][j]='.';\n                }\n            }\n        }\n        prv->push(make_pair(sy,sx));\n        int cnt=0;\n        while(prv->size()){\n            while(prv->size()){\n                pair<int,int> &p=prv->front();\n                if(!passed[p.first][p.second]){\n                    passed[p.first][p.second]=true;\n                    dfs(prv->front().first,prv->front().second);\n                }\n                prv->pop();\n            }\n            swap(prv,nxt);\n            if(ok)\n                break;\n            cnt++;\n        }\n        cout<<cnt<<endl;\n        while(prv->size())prv->pop();\n        while(nxt->size())nxt->pop();\n    }\n    delete nxt;\n    delete prv;\n    return 0;\n}\n\n\n//char field[101][101];\n//bool passed[101][101];\n//\n//const int dy[]={-1,0,0,1};\n//const int dx[]={0,-1,1,0};\n//\n//int h,w;\n//// ×ÚÇÀWÌXg\n//set<pair<int,int> > walls;\n//set<pair<int,int> > spList;\n//\n//\n//bool bfs(int sx,int sy,bool w){\n//\t// Ü¸ÊÉbfs\n//\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n//\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n//\t\n//\tprv->push(make_pair(sy,sx));\n//\tbool fin=false;\n//\tpassed[sy][sx]=true;\n//\twhile(prv->size()){\n//\t\twhile(prv->size()){\n//\t\t\tpair<int,int> p = prv->front();\n//\t\t\tprv->pop();\n//\t\t\t// ÇÉBµ½çAI¹\n//\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n//\t\t\t\treturn true;\n//\t\t\t}\n//\t\t\t// lûüÉÚ®\n//\t\t\tfor(int i = 0; i < 4; i++){\n//\t\t\t\tint nx=p.second+dx[i];\n//\t\t\t\tint ny=p.first+dy[i];\n//\t\t\t\tif(!passed[ny][nx]){\n//\t\t\t\t\tif(w){\n//\t\t\t\t\t\tif(field[ny][nx]=='.'){\n//\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n//\t\t\t\t\t\t\tpassed[ny][nx]=true;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n//\t\t\t\t\t\t\twalls.insert(make_pair(ny,nx));\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tif(field[ny][nx]=='#'){\n//\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n//\t\t\t\t\t\t\tpassed[ny][nx]=true;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse if(field[ny][nx]='.'){\n//\t\t\t\t\t\t\tspList.insert(make_pair(ny,nx));\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\tswap(prv,nxt);\n//\t}\n//\treturn false;\n//}\n//\n//int main(){\n//\n//\t// ÇÉÕË·éÜÅbfsðJè©¦·\n//\twhile(cin>>w>>h&&!(w==0&&h==0)){\n//\t\twalls.clear();\n//\t\tspList.clear();\n//\t\tint sx,sy;\n//\t\tfor(int i = 0; i < h; i++){\n//\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\tcin>>field[i][j];\n//\t\t\t\tif(field[i][j]=='&')\n//\t\t\t\t\tsx=j,sy=i;\n//\t\t\t}\n//\t\t\tfill(passed[i],passed[i]+w,false);\n//\t\t}\n//\t\tint cnt=0;\n//\t\tbool fin=false;\n//\t\tspList.insert(make_pair(sy,sx));\n//\t\twhile(1){\n//\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n//\t\t\tfor(set<pair<int,int> >::iterator it = spList.begin(); it != spList.end(); it++){\n//\t\t\t\tint cx=it->second;\n//\t\t\t\tint cy=it->first;\n//\t\t\t\tif(bfs(cx,cy,true)){\n//\t\t\t\t\tfin=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(fin)\n//\t\t\t\tbreak;\n//\t\t\tspList.clear();\n//\t\t\tcnt++;\n//\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n//\t\t\tfor(set<pair<int,int> >::iterator it = walls.begin(); it != walls.end(); it++){\n//\t\t\t\tint cx=it->second;\n//\t\t\t\tint cy=it->first;\n//\t\t\t\tif(bfs(cx,cy,false)){\n//\t\t\t\t\tfin=true;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tif(fin)\n//\t\t\t\tbreak;\n//\t\t\twalls.clear();\n//\t\t}\n//\t\tcout<<cnt<<endl;\n//\t}\n//\n//\treturn 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = { 0,-1, 0, 1};\n\nstruct NODE{\n\tint x,y;\n\tint count;\n\tchar sw;\n};\nbool operator<(const NODE &a,const NODE &b){\n\treturn a.count > b.count;\n}\n\nint w,h;\nbool isWrong(const NODE &n){\n\tif(n.x > w+1 || n.y > h+1)return true;\n\tif(n.x <  0  || n.y <  0 )return true;\n\treturn false;\n}\nbool isEdge(const NODE &n){\n\tif(n.x == 0 || n.x == w+1)return true;\n\tif(n.y == 0 || n.y == h+1)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> w >> h, w){\n\t\tchar map[102][102];\n\t\trep(i,102)rep(j,102)map[i][j] = '.';\n\t\tNODE t; t.count = 0, t.sw = '.';\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif(map[i][j] == '&')t.y = i, t.x = j , map[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\t\n\t\tint memo[102][102];\n\t\trep(i,102)rep(j,102)memo[i][j] = (1<<21);\n\t\t\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(t);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(memo[q.y][q.x] <= q.count)continue;\n\t\t\t\n\t\t\tif(isEdge(q)){\n\t\t\t\tcout << q.count << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo[q.y][q.x] = q.count;\n\t\t\trep(i,4){\n\t\t\t\tNODE nt;\n\t\t\t\tnt.x = q.x+dx[i], nt.y = q.y+dy[i], nt.count = q.count;\n\t\t\t\tif(isWrong(nt))continue;\n\t\t\t\tif( q.sw == '#' && map[nt.y][nt.x] == '.')nt.count++;\n\t\t\t\tnt.sw = map[nt.y][nt.x];\n\t\t\t\t\n\t\t\t\tQ.push(nt);\t\t\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> State;\nconst int INF = 1e+8;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\n// デバッグ出力\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ )\n\t\tcout << m[y] << endl;\n}\n\n// 幅と高さ\nint w, h;\n\n// ゴールの位置を調べる\nP search_goal(vector<string>& m){\n\tint gx, gy;\n\tfor(int y = 0 ; y < h ; y++ ){\n\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == '&' ){\n\t\t\t\tm[y][x] = '.';\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn P(gx,gy);\n}\n\nint solve(vector<string>& m){\t\n\t// n := ノード数\n\tint n = w * h; \n\t// d[y][x] := (x,y) への最小コスト, まだ確定していないときはINF\n\tint d[110][110];\n\t// used[y][x] := (x,y) が探索済みかどうか\n\tbool used[110][110];\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t\tused[y][x] = false;\n\t\t}\n\t}\n\t\n\t// ゴールの位置を調べる\n\tP gp = search_goal( m );\n\tint gx = gp.first;\n\tint gy = gp.second;\n\t\n\t// (x,y)=(0,0) を始点として探索する\n\tpriority_queue< State , vector<State> , greater<State> > q;\n\tq.push( State( 0 , P(0,0) ) );\n\td[0][0] = 0;\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\t// コストの小さい座標から順に出てくる\n\t\tint cost = q.top().first;\n\t\tint x = q.top().second.first;\n\t\tint y = q.top().second.second;\n\t\tq.pop();\n\t\t// 座標 (x,y) を確定ノードにする\n\t\tused[y][x] = true;\n\t\t\n\t\t// ゴールのとき\n\t\tif( x == gx && y == gy ){\n\t\t\tresult = min( result , cost );\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\t\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h || used[my][mx] ) continue;\n\t\t\t\n\t\t\tint next_cost = cost;\n\t\t\tif( m[y][x] == '.' && m[my][mx] == '#' ){\n\t\t\t\tnext_cost++;\n\t\t\t}\n\t\t\tif( next_cost < d[my][mx] ){\n\t\t\t\td[my][mx] = next_cost;\n\t\t\t\tState next( next_cost , P(mx,my) );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\t// debug\n\t// debug( m );\n\t/* for(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( d[y][x] == INF ){\n\t\t\t\tcout << \"?\";\n\t\t\t}else{\n\t\t\t\tcout << d[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}*/\n\treturn result;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tvector<string> m(h+2);\n\t\tstring t;\n\t\tfor(int i=0 ; i < w+2 ; i++ ){\n\t\t\tt.push_back('.');\n\t\t}\n\t\tm[0] = m[h+1] = t;\n\t\t\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tstring s, s_;\n\t\t\tcin >> s;\n\t\t\ts_ = \".\" + s + \".\";\n\t\t\tm[y] = s_;\n\t\t}\n\t\tw += 2;\n\t\th += 2;\n\t\tcout << solve( m ) << endl;\n\t\t//debug2();\n\t\t//int ans = d[gy][gx];\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int n,m;\n  while(cin>>n>>m,n|m){\n    char zu[m][n];\n    int sx,sy;\n    rep(i,m){\n      rep(j,n){\n        cin>>zu[i][j];\n        if(zu[i][j]=='&')sx=i,sy=j;\n      }\n    }\n\n    int dp[m][n];\n    memset(dp,-1,sizeof(dp));\n\n\n\n    queue<PI> Q;\n    Q.push(mp(sx,sy));\n    dp[sx][sy]=0;\n\n    \n\n    while(!Q.empty()){\n\n\n      int cx=Q.front().f,cy=Q.front().s;\n      Q.pop();\n      \n      rep(i,4){\n        int nx=cx+dx[i],ny=cy+dy[i];\n        if(nx<0 || nx>=m || ny<0 || ny>=n)continue;\n\n        if(dp[nx][ny]==-1){\n          if(zu[cx][cy]!='#' && zu[nx][ny]=='#')dp[nx][ny]=dp[cx][cy]+1;\n          else dp[nx][ny]=dp[cx][cy];\n          Q.push(mp(nx,ny));\n          continue;\n        }\n\n        if(zu[cx][cy]!='#' && zu[nx][ny]=='#' && dp[nx][ny]>dp[cx][cy]+1){\n          dp[nx][ny]=dp[cx][cy]+1;\n          Q.push(mp(nx,ny));\n          continue;\n        }else if(zu[cx][cy]==zu[nx][ny] && dp[nx][ny]>dp[cx][cy]){\n          dp[nx][ny]=dp[cx][cy];\n          Q.push(mp(nx,ny));\n          continue;\n        }\n      }\n    }\n    int ans=dp[0][0];\n    rep(i,n){\n      ans=min(ans,dp[0][i]);\n      ans=min(ans,dp[m-1][i]);\n    }\n    rep(i,m){\n      ans=min(ans,dp[i][0]);\n      ans=min(ans,dp[i][n-1]);\n    }\n    cout<<ans<<endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nstruct NODE{\n\tint x,y;\n\tint count;\n\tchar sw;\n};\nbool operator<(const NODE &a,const NODE &b){\n\treturn a.count > b.count;\n}\n\nint w,h;\nbool isWrong(const NODE &n){\n\tif(n.x > w+1 || n.y > h+1)return true;\n\tif(n.x < 0 || n.y < 0)return true;\n\treturn false;\n}\n\nbool edge(const NODE &n){\n\tif(n.x == 0 || n.x == w+1)return true;\n\tif(n.y == 0 || n.y == h+1)return true;\n\treturn false;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> w >> h, w){\n\t\tchar map[102][102];\n\t\trep(i,102)rep(j,102)map[i][j] = '.';\n\t\tNODE t; t.count = 0, t.sw = '.';\n\t\t\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tif(map[i][j] == '&')t.y = i, t.x = j , map[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\t//cout<<t.x<<\",\"<<t.y<<endl;\n\t\t//rep(i,h+2)rep(j,w+2)cout << map[i][j];cout << endl;\n\t\tint memo[102][102];\n\t\trep(i,102)rep(j,102)memo[i][j] = (1<<21);\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(t);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(memo[q.y][q.x] <= q.count)continue;\n\t\t\t\n\t\t\tif(edge(q)){\n\t\t\t\tcout << q.count << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo[q.y][q.x] = q.count;\n\t\t\trep(i,4){\n\t\t\t\tNODE nt;\n\t\t\t\tnt.x = q.x+dx[i], nt.y = q.y+dy[i], nt.count = q.count;\n\t\t\t\tif(isWrong(nt))continue;\n\t\t\t\tif( q.sw == '#' && map[nt.y][nt.x] == '.')nt.count++;\n\t\t\t\tnt.sw = map[nt.y][nt.x];\n\t\t\t\t\n\t\t\t\tQ.push(nt);\t\t\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1000000;\nconst int N = 102;\n\nint h, w;\nchar mapData[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[N][N];\n\nclass State{\npublic:\n  int y, x, cost;\n};\n\nint bfs(){\n  State u, v;\n  u.y = 0;\n  u.x = 0;\n  u.cost = 0;\n  queue<State> Q;\n  Q.push(u);\n  int res = INF;\n  fill(height[0], height[N], INF);\n  height[0][0] = 0;\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(mapData[u.y][u.x] == '&') res = min(res, u.cost);\n    for(int i=0;i<4;i++){\n      v.y = u.y + dy[i];\n      v.x = u.x + dx[i];\n      if(v.y < 0 || v.y >= h) continue;\n      if(v.x < 0 || v.x >= w) continue;\n      v.cost = u.cost;\n      if(mapData[v.y][v.x] != '#' && mapData[u.y][u.x] == '#') ++v.cost;\n      if(height[v.y][v.x] <= v.cost) continue;\n      height[v.y][v.x] = v.cost;\n      Q.push(v);\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin >> mapData[i][j];\n      }\n    }\n    h += 2;\n    w += 2;\n    for(int i=0;i<h;i++) mapData[i][0] = '.';\n    for(int i=0;i<h;i++) mapData[i][w-1] = '.';\n    for(int j=0;j<w;j++) mapData[0][j] = '.';\n    for(int j=0;j<w;j++) mapData[h-1][j] = '.';\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<=n && kx>=0 && kx<=m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\nint main(){\n  int w,h;\n  string line;\n  while(true){\n    cin>>w>>h;\n    if(!w&&!h)\n      break;\n    vector<string> castle;\n    for(int i=0;i<h;i++){\n      cin>>line;\n      castle.push_back(line);\n    }\n    int count[w+2][h+2];\n    int sx,sy;\n    const int MAX = 100;\n    for(int y=1;y<h+1;y++){\n      for(int x=1;x<w+1;x++){\n\tcount[x][y] = MAX;\n\tif (castle[y-1][x-1]=='&'){\n\t  sx = x;\n\t  sy = y;\n\t  castle[y-1][x-1]=='.';\n\t}\n      }\n    }\n    int min = MAX;\n    int dx[4] = {1,0,-1,0};\n    int dy[4] = {0,1,0,-1};\n    count[sx][sy] = 0;\n    stack<int> st;\n    st.push(sy*(w+2)+sx);\n    while(!st.empty()){\n      int x = st.top()%(w+2);\n      int y = st.top()/(w+2);\n      st.pop();\n      char c = castle[y-1][x-1];\n      int n;\n      for(int d=0;d<4;d++){\n\tn = count[x][y];\n\tif(x+dx[d]>0&&y+dy[d]>0&&x+dx[d]<w+1&&y+dy[d]<h+1){\n\t  if(c=='.'&&castle[y+dy[d]-1][x+dx[d]-1]=='#')\n\t    n++;\n\t  if(n<count[x+dx[d]][y+dy[d]]){\n\t    count[x+dx[d]][y+dy[d]] = n;\n\t    st.push((y+dy[d])*(w+2)+x+dx[d]);\n\t  }\n\t}\n\telse{\n\t  if(n<min)\n\t    min = n;\n\t}\n      }\n    }\n    cout<<min<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <utility>\n\nusing namespace std;\n\nint INF = 1 << 28;\nint n;\nint m;\nchar map[100][100];\nint visited[100][100];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint ans;\n\nvoid solve(pair<int,int> pos, int c) {\n\n\tint x = pos.first;\n\tint y = pos.second;\n\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\tans = c;\n\t\treturn;\n\t}\n\tif (visited[y][x] <= c)\n\t\treturn;\n\tvisited[y][x] = c;\n\tif (ans <= c) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\t\tsolve(make_pair(nx, ny), c + ((map[y][x] == '#') ? 1 : 0));\n\t}\n}\n\nint main(){\n\twhile (1) {\n\t\tans = INF;\n\t\tcin>>n;\n\t\tcin>>m;\n\t\tif ((n | m) == 0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tvisited[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tif (n <= 2 || m <= 2) {\n\t\t\tcout << 0 <<\"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint sx = 0;\n\t\tint sy = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\ti = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(make_pair(sx,sy), 0);\n\t\tcout <<ans<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int INF = 1e9 + 10;\n\nusing namespace std;\n\nstruct Point {\n  int y, x, cost;\n  Point() = default;\n  Point(int y, int x): y(y), x(x), cost(0) { }\n  Point(int y, int x, int c): y(y), x(x), cost(c) { }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n\n    vector<string> c(m);\n    for (int i = 0; i < m; i++) {\n      cin >> c[i];\n    }\n\n    Point s;\n    int dy[] = { -1, 0, 1, 0 };\n    int dx[] = { 0, 1, 0, -1 };\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (c[i][j] == '&') {\n          s.y = i;\n          s.x = j;\n          s.cost = 0;\n        }\n      }\n    }\n\n    queue<Point> que;\n    que.push(s);\n\n    int ans = INF;\n\n    vector<vector<int>> checked(m);\n    for (int i = 0; i < m; i++) {\n      checked[i] = vector<int>(n, INF);\n    }\n\n    while (!que.empty()) {\n      if (ans == 0) {\n        break;\n      }\n      Point p = que.front(); que.pop();\n      if (checked[p.y][p.x] <= p.cost) {\n        continue;\n      }\n      checked[p.y][p.x] = p.cost;\n      for (int i = 0; i < 4; i++) {\n        int ny = p.y + dy[i];\n        int nx = p.x + dx[i];\n        if (ny < 0 || ny >= m) {\n          ans = min(ans, p.cost);\n          continue;\n        }\n        if (nx < 0 || nx >= n) {\n          ans = min(ans, p.cost);\n          continue;\n        }\n        int cost = 0;\n        if (c[ny][nx] == '#') {\n          cost = 1;\n        }\n        que.push(Point(ny, nx, p.cost + cost));\n      }\n    }\n\n    cout << ans << endl;\n\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nstruct pos {\n\tint x, y;\n\tint cost;\n\tpos() {}\n\tpos(int x_, int y_, int cost_) {\n\t\tx = x_; y = y_; cost = cost_;\n\t}\n\tbool operator<(const pos p) const {\n\t\treturn cost > p.cost;\n\t}\n};\n\nconst int INF = 1000000;\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n | m) {\n\t\tchar in[128][128];\n\t\tint cost[128][128];\n\t\tfor(int i = 0; i < 128; i++) {\n\t\t\tfor(int j = 0; j < 128; j++) {\n\t\t\t\tin[i][j] = '.';\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%s\", in[i + 1] + 1);\n\t\t\tin[i + 1][n + 1] = '.';\n\t\t}\n\n\t\tpriority_queue<pos> q;\n\t\tfor(int i = 1; i < m + 1; i++) {\n\t\t\tfor(int j = 1; j < n + 1; j++) {\n\t\t\t\tif(in[i][j] == '&') {\n\t\t\t\t\tq.push(pos(j, i, 0));\n\t\t\t\t\ti = m + 1;\n\t\t\t\t\tj = n + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dx[] = {-1, 1, 0, 0};\n\t\tint dy[] = {0, 0, -1, 1};\n\t\tint ans = -1;\n\t\twhile(!q.empty()) {\n\t\t\tpos p;\n\t\t\tp = q.top(); q.pop();\n\t\t\tif(cost[p.y][p.x] == INF) {\n\t\t\t\tif(p.x <= 0 || n + 1 <= p.x || p.y <= 0 || m + 1 <= p.y) {\n\t\t\t\t\tans = p.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcost[p.y][p.x] = p.cost;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tif(cost[p.y + dy[i]][p.x + dx[i]] == INF) {\n\t\t\t\t\t\tint c = p.cost;\n\t\t\t\t\t\tif(in[p.y][p.x] == '.' && in[p.y + dy[i]][p.x + dx[i]] == '#') {\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(pos(p.x + dx[i], p.y + dy[i], c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 1; i < m + 1; i++) {\n\t\t\tfor(int j = 1; j < n + 1; j++) {\n\t\t\t\tcout << (cost[i][j] == INF ? in[i][j] : '*');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nchar field[101][101];\nbool passed[101][101];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint h,w;\n// ×ÚÇÀWÌXg\nvector<pair<int,int> > walls;\nvector<pair<int,int> > spList;\n\n\nbool bfs(int sx,int sy,bool w){\n\t// Ü¸ÊÉbfs\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\t\n\tprv->push(make_pair(sy,sx));\n\tbool fin=false;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> p = prv->front();\n\t\t\tprv->pop();\n\t\t\tpassed[p.first][p.second]=true;\n\t\t\t// ÇÉBµ½çAI¹\n\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// lûüÉÚ®\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\tif(!passed[ny][nx]){\n\t\t\t\t\tif(w){\n\t\t\t\t\t\tif(field[ny][nx]=='.')\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t\t\t\t\twalls.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(field[ny][nx]=='#'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]='.'){\n\t\t\t\t\t\t\tspList.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\treturn false;\n}\n\nint main(){\n\n\t// ÇÉÕË·éÜÅbfsðJè©¦·\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='&')\n\t\t\t\t\tsx=j,sy=i;\n\t\t\t}\n\t\t\tfill(passed[i],passed[i]+w,false);\n\t\t}\n\t\tint cnt=0;\n\t\tbool fin=false;\n\t\tspList.push_back(make_pair(sy,sx));\n\t\twhile(1){\n\t\t\t//// Ü¸ÊÉbfs\n\t\t\t//queue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\t\t\t//queue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\n\t\t\t//// ×ÚÇÀWÌXg\n\t\t\t//vector<pair<int,int> > walls;\n\n\t\t\t//prv->push(make_pair(sy,sx));\n\t\t\t//bool fin=false;\n\t\t\t//while(prv->size()){\n\t\t\t//\twhile(prv->size()){\n\t\t\t//\t\tpair<int,int> p = prv->front();\n\t\t\t//\t\tprv->pop();\n\t\t\t//\t\tpassed[p.first][p.second]=true;\n\t\t\t//\t\t// ÇÉBµ½çAI¹\n\t\t\t//\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t//\t\t\tfin=true;\n\t\t\t//\t\t\tbreak;\n\t\t\t//\t\t}\n\t\t\t//\t\t// lûüÉÚ®\n\t\t\t//\t\tfor(int i = 0; i < 4; i++){\n\t\t\t//\t\t\tint nx=p.second+dx[i];\n\t\t\t//\t\t\tint ny=p.first+dy[i];\n\t\t\t//\t\t\tif(!passed[ny][nx]){\n\t\t\t//\t\t\t\tif(field[ny][nx]=='.')\n\t\t\t//\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t//\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t//\t\t\t\t\twalls.push_back(make_pair(ny,nx));\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t}\n\t\t\t//\t\t}\n\t\t\t//\t}\n\t\t\t//\tif(fin)\n\t\t\t//\t\tbreak;\n\t\t\t//\tswap(prv,nxt);\n\t\t\t//}\n\n\t\t\t//if(fin)\n\t\t\t//\tbreak;\n\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n\t\t\tfor(int i = 0; i < spList.size(); i++){\n\t\t\t\tint cx=spList[i].second;\n\t\t\t\tint cy=spList[i].first;\n\t\t\t\tif(bfs(cx,cy,true)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tspList.clear();\n\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n\t\t\tfor(int i = 0; i < walls.size(); i++){\n\t\t\t\tint cx=walls[i].second;\n\t\t\t\tint cy=walls[i].first;\n\t\t\t\tif(bfs(cx,cy,false)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twalls.clear();\n\t\t\t// JEgðâ·\n\t\t\tcnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 120\n#define INF 1e9\n\nint H, W;\nchar field[MAX][MAX];\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n\nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nbool check(int y, int x){\n  if(y == 0 || y == H-1) return true;\n  if(x == 0 || x == W-1) return true;\n  return false;\n}\n\nvoid bfs(int y, int x){\n  int ans = INF;\n  int cost[MAX][MAX];\n  fill(cost[0], cost[MAX], INF);\n  queue<int> nowx, nowy, cnt;\n  nowx.push(x); nowy.push(y); cnt.push(0);\n\n  while(!nowx.empty()){\n    int xx = nowx.front(); nowx.pop();\n    int yy = nowy.front(); nowy.pop();\n    int c = cnt.front(); cnt.pop();\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = xx + dx[i];\n      int ny = yy + dy[i];\n\n      if(!inField(ny, nx)) continue;\n      if(check(ny, nx)){\n        if(field[yy][xx] != '#' && field[ny][nx] == '#'){\n          cost[ny][nx] = min(cost[ny][nx], c+1);\n        }else{\n          cost[ny][nx] = min(cost[ny][nx], c);\n        }\n        continue;\n      }\n      int nc = c;\n      if(field[yy][xx] != '#' && field[ny][nx] == '#') nc++;\n      if(nc < cost[ny][nx]){\n        cost[ny][nx] = nc;\n        nowx.push(nx); nowy.push(ny); cnt.push(nc);\n      }\n    }\n  }\n  for(int i = 0 ; i < H ; i++){\n    ans = min(ans, cost[i][0]);\n    ans = min(ans, cost[i][W-1]);\n  }\n  for(int i = 0 ; i < W ; i++){\n    ans = min(ans, cost[0][i]);\n    ans = min(ans, cost[H-1][i]);\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  int sx, sy;\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == '&'){\n          sx = j; sy = i;\n        }\n      }\n    }  \n    bfs(sy, sx);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;//wall y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar A[105][105],B[105][105];\nint d[105][105];\npriority_queue<PP>Q;//need finit\n\nvoid Pset(int y,int x)\n{\n\td[y][x]=0;\n\tQ.push(make_pair(0,make_pair(y,x)));\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f,sizeof(d));\n\t\tfor(int i=0;i<=M+1;i++)for(int j=0;j<=N+1;j++)B[i][j]='.';\n\t\tfor(int i=0;i<M;i++)gets(B[i+1]+1);\n\t\tfor(int i=0;i<=M+1;i++){B[i][N+1]='.';B[i][N+2]=0;}\n\t\tN++;M++;\n\t\tQ.push(make_pair(0,make_pair(0,0)));\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tint cost=tmp.first;\n\t\t\tif(d[y][x]<cost)continue;\n\t\t\tif(B[y][x]=='&')\n\t\t\t{\n\t\t\t\tres=min(res,cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif(ny<0||ny>M||nx<0||nx>N)continue;\n\t\t\t\tint nc=cost+(B[y][x]=='#'&&B[ny][nx]!='#');\n\t\t\t\tif(nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\td[ny][nx]=nc;\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<n && kx>=0 && kx<m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF (1<<24)\nusing namespace std;\nint W,H,mini,mini_x,mini_y,ny,nx,cost,ans;\nstring str;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nchar t[102][102];\nbool vd[102][102];\nint u[102][102];\n\nint main(){\n  while(cin>>W>>H){\n    if(W==0&&H==0)break;\n    for(int i=0;i<102;i++)for(int j=0;j<102;j++){\n\tt[i][j]='.';\n\tvd[i][j]=false;\n\tu[i][j]=INF;\n      }\n\n    for(int i=1;i<=H;i++){\n      cin>>str;\n      for(int j=1;j<=W;j++){\n\tt[i][j]=str[j-1];\n\tif(t[i][j]=='&')u[i][j]=0;\n      }\n    }\n    /*\n    for(int i=0;i<H+2;i++){\n      for(int j=0;j<W+2;j++){\n\tcout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    \n    while(1){\n      mini=INF;\n      for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++){\n\t  if(mini>u[i][j]&&vd[i][j]==false){\n\t    mini=u[i][j];\n\t    mini_y=i;\n\t    mini_x=j;\n\t  }\n\t}\n      }\n\n      if(mini==INF)break;\n\n      vd[mini_y][mini_x]=true;\n\n      //cout<<mini_y<<' '<<mini_x<<' '<<u[mini_y][mini_x]<<endl;\n\n      \n    \n\n      for(int i=0;i<4;i++){\n\tny=mini_y+dy[i];\n\tnx=mini_x+dx[i];\n\tif(ny<0||nx<0||ny>H+1||nx>W+1)continue;\n\tcost=((t[mini_y][mini_x]!='#'&&t[ny][nx]=='#')?1:0);\n\n\tif(u[ny][nx]>u[mini_y][mini_x]+cost){\n\t  u[ny][nx]=u[mini_y][mini_x]+cost;\n\t}\n      }\n    }\n\n    ans=INF;\n    for(int i=0;i<H+2;i++){\n      ans=max(ans,u[i][0]);\n      ans=max(ans,u[i][W+1]);\t      \n    }\n    for(int i=0;i<W+2;i++){\n      ans=min(ans,u[0][i]);\n      ans=min(ans,u[H+1][i]);\t      \n    }\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nbool dp[110][110][150]={0};\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<string>in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tqueue<pip>q;\n\t\trep(i,110)rep(j,110)rep(k,150)dp[i][j][k]=false;\n\t\tbool h=false;\n\t\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\t\tif(in[i][j]=='&')h=true;\n\t\t\tif(in[i][j]!='#')q.push(pip(i,pii(j,0)));\n\t\t}\n\t\tif(h){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint out=inf;\n\t\twhile(!q.empty()){\n\t\t\tpip p=q.front();\n\t\t\tq.pop();\n\t\t\tint x=p.first,y=p.second.first,cost=p.second.second;\n\t\t\t//cout<<x<<\" \"<<y<<\" \"<<cost<<endl;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tint ncost=cost+(in[nx][ny]=='#'?1:0);\n\t\t\t\tif(in[nx][ny]=='&'){\n\t\t\t\t\tout=min(out,ncost);\n\t\t\t\t}\n\t\t\t\tif(dp[nx][ny][ncost]==0){\n\t\t\t\t\tdp[nx][ny][ncost]=true;\n\t\t\t\t\tq.push(pip(nx,pii(ny,ncost)));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 101;\n\nint W, H;\nchar G[MAX][MAX];\n\nbool dfs(int x, int y, char from, char to) {\n  static int dx[] = {1,0,-1,0};\n  static int dy[] = {0,1,0,-1};\n  G[y][x] = to;\n  bool res = false;\n  for(int i = 0; i < 4; ++i) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || nx >= W || ny < 0 || ny >= H) {\n      res = true;\n      continue;\n    }\n    if(G[ny][nx] != from) continue;\n    res |= dfs(nx, ny, from, to);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    int sx, sy;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n        if(G[i][j] == '&') {\n          sx = j;\n          sy = i;\n          G[i][j] = '.';\n        }\n      }\n    }\n    for(int i = 0; ; ++i) {\n      if(dfs(sx, sy, '.', '#')) {\n        cout << i << endl;\n        break;\n      }\n      dfs(sx, sy, '#', '.');\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 10000;\nconst int MAX = 100;\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {-1, 0, 1, 0};\nint m,n,sx,sy;\nint step[MAX + 2][MAX + 2];\nchar field[MAX + 2][MAX + 2];\n\nint main()\n{\n    while(cin >> n >> m && m) {\n        memset(step, INF, sizeof(step));\n        memset(field, '.', sizeof(field));\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                cin >> field[i][j];\n                if(field[i][j] == '&') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        queue<P> que;\n        que.push(P(sx, sy));\n        step[sy][sx] = 0;\n        while(!que.empty()) {\n            P p = que.front(); que.pop();\n            int x = p.first, y = p.second;\n            for(int k = 0; k < 4; k++) {\n                int nx = x + dx[k], ny = y + dy[k], s = step[y][x];\n                if(field[ny][nx] == '#') s++;\n                if(nx >= 0 && nx <= n + 1  && ny >= 0 && ny <= m + 1 && s < step[ny][nx]) {\n                    step[ny][nx] = s;\n                    que.push(P(nx, ny));\n                }\n            }\n        }\n\n        int res = INF;\n        for(int i = 0; i <= m + 1; i++)\n            for(int j = 0; j <= n + 1; j++)\n                if(i == 0 || i == m + 1 || j == 0 || j == n + 1) \n                    res = min(res, step[i][j]);\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int n,m;\n  while(cin>>n>>m,n|m){\n    char zu[m][n];\n    int sx,sy;\n    rep(i,m){\n      rep(j,n){\n        cin>>zu[i][j];\n        if(zu[i][j]=='&')sx=i,sy=j;\n      }\n    }\n\n    int dp[m][n];\n    memset(dp,-1,sizeof(dp));\n\n    queue<PI> Q;\n    Q.push(mp(sx,sy));\n    dp[sx][sy]=0;\n    \n\n    while(!Q.empty()){\n      int cx=Q.front().f,cy=Q.front().s;\n      Q.pop();\n      bool cc=false;\n/*\n      cout<<cx<<\" \"<<cy<<endl;\n      rep(i,m){\n        rep(j,n)printf(\"%2d\",dp[i][j]);\n        cout<<endl;\n      }\n*/      \n      rep(i,4){\n        int nx=cx+dx[i],ny=cy+dy[i];\n        if(nx<0 || nx>=m || ny<0 || ny>=n)continue;\n\n        if(dp[nx][ny]==-1){\n          if(zu[cx][cy]!='#' && zu[nx][ny]=='#')dp[nx][ny]=dp[cx][cy]+1;\n          else dp[nx][ny]=dp[cx][cy];\n          cc=true;\n          Q.push(mp(nx,ny));\n        }\n\n        if(zu[cx][cy]!='#' && zu[nx][ny]=='#' && dp[nx][ny]>dp[cx][cy]+1){\n          dp[nx][ny]=dp[cx][cy]+1;\n          Q.push(mp(nx,ny));\n          cc=true;\n        }else if(zu[cx][cy]==zu[nx][ny] && dp[nx][ny]>dp[cx][cy]){\n          dp[nx][ny]=dp[cx][cy];\n          Q.push(mp(nx,ny));\n          cc=true;\n        }\n        if(zu[cx][cy]=='#' && zu[nx][ny]!='#' && dp[nx][ny]+1<dp[cx][cy]){\n          dp[cx][cy]=dp[nx][ny]+1;\n          cc=true;\n        }else if(zu[cx][cy]==zu[nx][ny] && dp[nx][ny]<dp[cx][cy])dp[cx][cy]=dp[nx][ny],cc=true;\n      }\n      if(cc)Q.push(mp(cx,cy));\n    }\n/*\n    rep(i,m){\n      rep(j,n)printf(\"%2d\",dp[i][j]);\n      cout<<endl;\n    }\n*/   \n    int ans=dp[0][0];\n    rep(i,n){\n      ans=min(ans,dp[0][i]);\n      ans=min(ans,dp[m-1][i]);\n    }\n    rep(i,m){\n      ans=min(ans,dp[i][0]);\n      ans=min(ans,dp[i][n-1]);\n    }\n    cout<<ans<<endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\nconst int hardCost = 100000;\nconst int dx[] = {1, 0, 0, -1};\nconst int dy[] = {0, 1, -1, 0};\nstruct P{ int x, y; P(int x, int y) : x(x), y(y) {} };\n\nint main()\n{\n    for(int n, m; cin >> n >> m && (n || m); )\n\t{\n\t\tP c(0, 0);\n\t\tvector<string> field(m);\n\t\tvector<vint> cost(n, vint(m, INF));\n\t\t\n\t\trep(i, m)\n\t\t{\n\t\t\tcin >> field[i];\n\t\t\t\n\t\t\tint pos = field[i].find(\"&\");\n\t\t\tif(pos != string::npos)\n\t\t\t{\n\t\t\t\tc.x = pos;\n\t\t\t\tc.y = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tcost[c.x][c.y] = 0;\n\t\tfor(que.push(c); !que.empty(); que.pop())\n\t\t{\n\t\t\tP cur = que.front();\n\t\t\t\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tP nxt(cur.x + dx[i], cur.y + dy[i]);\n\t\t\t\t\n\t\t\t\tif(0 <= nxt.x && nxt.x < n && 0 <= nxt.y && nxt.y < m)\n\t\t\t\t{\n\t\t\t\t\tint ct = cost[cur.x][cur.y] + (field[nxt.y][nxt.x] == '#' ? 1 : 0);\n\t\t\t\t\t\n\t\t\t\t\tif(ct < cost[nxt.x][nxt.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost[nxt.x][nxt.y] = ct;\n\t\t\t\t\t\tque.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 1 << 30;\n\t\t\n\t\trep(i, n) chmin(res, min(cost[i][0], cost[i][m-1]));\n\t\trep(i, m) chmin(res, min(cost[0][i], cost[n-1][i]));\n\t\t\n\t\t\n\t\tcout << res << endl;//hardCost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define mp make_pair\ntypedef pair<int, int> P;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint N, M;\nchar maze[110][110];\nunsigned int minp[110][110];\n\nint main() {\n\tfor(;;) {\n\t\tmemset(minp, -1, sizeof minp);\n\t\tscanf(\" %d %d\", &N, &M);\n\t\tif(!N && !M) break;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tscanf(\" %s\", maze[i]);\n\t\t}\n\n\t\t// P = (x, y)\n\t\t// maze[y][x]\n\t\tqueue<P> que;\n\t\t{\n\t\t\tP put;\n\t\t\tfor(int x = 0; x < N; x++) {\n\t\t\t\tfor(int y = 0; y < M; y++) {\n\t\t\t\t\tif(maze[y][x] == '&') {\n\t\t\t\t\t\tput.first = x;\n\t\t\t\t\t\tput.second = y;\n\t\t\t\t\t\tminp[y][x] = 0;\n\t\t\t\t\t\tmaze[y][x] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.push(put);\n\t\t}\n\t\t;\n\t\twhile(!que.empty()) {\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\n\t\t\t// push\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first] + 1;\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunsigned int minv = 100000000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tminv = min(minv, min(minp[0][i], minp[M - 1][i]));\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tminv = min(minv, min(minp[i][0], minp[N - 1][i]));\n\t\t}\n\t\tprintf(\"%d\\n\", minv);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _USE_MATH_DEFINES\nusing namespace std;\n \n \n#define li\t\t\tlong long int\n#define rep(i,to)\tfor(li i=0;i<((li)(to));i++)\n#define repp(i,start,to)\tfor(li i=(li)(start);i<((li)(to));i++)\n#define pb\t\t\tpush_back\n#define sz(v)\t\t((li)(v).size())\n#define bgn(v)\t\t((v).begin())\n#define eend(v)\t\t((v).end())\n#define allof(v)\t(v).begin(), (v).end()\n#define dodp(v,n)\t\tmemset(v,(li)n,sizeof(v))\n#define bit(n)\t\t(1ll<<(li)(n))\n#define mp(a,b)\t\tmake_pair(a,b)\n#define rin\trep(i,n)\n#define rjm\trep(j,m)\n\n\n#define DBGP 1\n\n\n#define idp if(DBGP)\n#define F first\n#define S second\n#define p2(a,b)\t\tidp cout<<a<<\"\\t\"<<b<<endl\n#define p3(a,b,c)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<endl\n#define p4(a,b,c,d)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<endl\n#define p5(a,b,c,d,e)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<endl\n#define p6(a,b,c,d,e,f)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<endl\n#define p7(a,b,c,d,e,f,g)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<endl\n#define p8(a,b,c,d,e,f,g,h)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<endl\n#define p9(a,b,c,d,e,f,g,h,i)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<endl\n#define p10(a,b,c,d,e,f,g,h,i,j)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<\"\\t\"<<j<<endl\n#define foreach(it,v)\tfor(__typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)\n#define p2p(x)\t\tidp p2((x).F, (x).S)\n#define dump(x,n)\tidp{rep(i,n){cout<<x[i]<<\" \";}puts(\"\");}\n#define dump2(x,n)\tidp{rep(i,n){cout<<\"[\"<<x[i].F<<\" , \"<<x[i].S<<\"] \";}puts(\"\");}\n#define dumpi(x)\tidp{foreach(it, x){cout<<(*it)<<\" \";}puts(\"\");}\n#define dumpi2(x)\tidp{foreach(it, x){cout<<\"[\"<<(it)->F<<\" , \"<<(it)->S<<\"] \";}puts(\"\");}\n\n#define read2d(a,w,h)\trep(i,h)rep(j,w)cin>>a[i][j]\n#define dump2d(a,w,h)\trep(i,h){rep(j,w)cout<<a[i][j]<<\" \";puts(\"\");}\n\n\n#define EPS 1e-10\n#define ETOL 1e-8\n#define MOD 1000000007\n#define INF bit(60)\n\ntypedef pair<li, li> PI;\ntypedef pair<li, PI> PII;\n#define GRAPH_V 101010\n\nvector<PI> edge[GRAPH_V];\nbool visit[GRAPH_V];\n\n\nli dijkstra(li from, li to){\n\trep(i,GRAPH_V)visit[i]=false;\n\tpriority_queue<PI> q;\n\tq.push({0, from});\n\twhile(!q.empty()){\n\t\tPI now=q.top();\n\t\tli now_v=now.S;\n\t\tli now_c=now.F;\n\t\tif(now_v==to)return -now_c;\n\t\tq.pop();\n\t\tif(visit[now_v])continue;\n\t\tvisit[now_v]=true;\n\t\trep(i,sz(edge[now_v])){\n\t\t\tli next=edge[now_v][i].F;\n\t\t\tli w=edge[now_v][i].S;\n\t\t\tif(!visit[next])q.push({now_c-w, next});\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nstring ss[111];\nli w,h;\n\ninline string dots(li x){\n\tstring res=\"\";\n\trep(i,x)res+=\".\";\n\treturn res;\n}\n\ninline li coord(li y, li x){\n\treturn y*(w+2)+x;\n}\n\nint main(int argc, char *argv[]){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(max(w,h)<=0)break;\n\t\tss[0]=ss[h+1]=dots(w+2);\n\t\tstring s;\n\t\trep(i,h){\n\t\t\tcin>>s;\n\t\t\tss[i+1]=\".\"+s+\".\";\n\t\t}\n\t\trep(i,GRAPH_V)edge[i].clear();\n\t\tli goal=-1;\n\t\trep(i,h+2){\n\t\t\trep(j,w+2){\n\t\t\t\tif(ss[i][j]=='&')goal=coord(i,j);\n\t\t\t\tif(j-1>=0)edge[coord(i,j)].pb({coord(i,j-1), ss[i][j-1]=='#' ? 1 : 0});\n\t\t\t\tif(j+1<w+2)edge[coord(i,j)].pb({coord(i,j+1), ss[i][j+1]=='#' ? 1 : 0});\n\t\t\t\tif(i-1>=0)edge[coord(i,j)].pb({coord(i-1,j), ss[i-1][j]=='#' ? 1 : 0});\n\t\t\t\tif(i+1<h+2)edge[coord(i,j)].pb({coord(i+1,j), ss[i+1][j]=='#' ? 1 : 0});\n\t\t\t}\n\t\t}\n\t\t//rep(i,h+2)cout<<ss[i]<<endl;\n\t\tcout<<dijkstra(0, goal)<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n >> m && n+m){\n    vector<vector<char>> v(m,vector<char>(n,' '));\n    queue<pii> q;\n    using pii = pair<int,int>;\n    vector<vector<int>> d(m,vector<int>(n,inf));\n    {\n      int x = 0,y = 0;\n      rep(j,m){\n        rep(i,n){\n          cin >> v[j][i];\n          if(v[j][i] == '&'){\n            x = i;\n            y = j;\n          }\n        }\n      }\n      pii pos = mp(y,x);\n      d[y][x] = 0;\n      q.push(pos);\n    }\n    int ans = inf;\n    while(q.size()){\n      auto Q = q.front();q.pop();\n      int x = Q.se,y = Q.fi;\n      rep(i,4){\n        int nx = x + dx[i],ny = y + dy[i];\n        if(value(nx,ny,n,m) ){\n          if( d[y][x] + (v[ny][nx] == '#') < d[ny][nx]){\n            q.push(mp(ny,nx));\n            d[ny][nx] = (v[ny][nx] == '#') + d[y][x];\n          }\n        }\n        else{\n          ans = min(ans,d[y][x]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 10e-6;\n\nchar stage[100][100];\nint costTable[100][100];\n\nvoid bfs(int w,int h){\n\tconst int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\tint sx,sy;\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tif(stage[y][x] == '&'){\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\nfound:;\n\n\tmemset(costTable,0x3,sizeof(costTable));\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\n\tcostTable[sy][sx] = 0;\n\n\twhile(!que.empty()){\n\t\tint x = que.front().first;\n\t\tint y = que.front().second;\n\t\tque.pop();\t\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = x + t[i][0];\n\t\t\tint dy = y + t[i][1];\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\n\t\t\tint cost = costTable[y][x] + ((stage[dy][dx] == '#' && stage[y][x] != '#') ? 1 : 0);\n\t\t\tif(costTable[dy][dx] <= cost) continue;\n\n\t\t\tcostTable[dy][dx] = cost;\n\t\t\tque.push(P(dx,dy));\n\t\t}\n\t}\n}\n\nint seekExtWall(int w,int h){\n\tint res = 0x3333;\n\n\tfor(int x=0;x<w;x++){\n\t\tres = min(res,costTable[0][x]);\n\t}\n\n\tfor(int x=0;x<w;x++){\n\t\tres = min(res,costTable[h-1][x]);\n\t}\n\n\tfor(int y=0;y<h;y++){\n\t\tres = min(res,costTable[y][0]);\n\t}\n\n\tfor(int y=0;y<h;y++){\n\t\tres = min(res,costTable[y][w-1]);\n\t}\n\n\treturn res;\n}\n\nvoid printCostTable(int w,int h){\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tcout << costTable[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tchar buf[128];\n\t\t\tscanf(\"%s\",buf);\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tstage[y][x] = buf[x];\n\t\t\t}\n\t\t}\n\n\t\tbfs(w,h);\n\t\tcout << seekExtWall(w,h) << endl;\n\t\t//printCostTable(w,h);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tint nx=p.first.first,ny=p.first.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint kx=nx+dx[i],ky=ny+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<n && kx>=0 && kx<m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && fie[nx][ny]=='#' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && fie[nx][ny]=='.' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int n,m;\n  while(cin>>n>>m,n|m){\n    char zu[m][n];\n    int sx,sy;\n    rep(i,m){\n      rep(j,n){\n        cin>>zu[i][j];\n        if(zu[i][j]=='&')sx=i,sy=j;\n      }\n    }\n\n    int dp[m][n];\n    memset(dp,-1,sizeof(dp));\n\n    queue<PI> Q;\n    Q.push(mp(sx,sy));\n    dp[sx][sy]=0;\n    \n\n    while(!Q.empty()){\n      int cx=Q.front().f,cy=Q.front().s;\n      Q.pop();\n      bool cc=false;\n/*\n      cout<<cx<<\" \"<<cy<<endl;\n      rep(i,m){\n        rep(j,n)printf(\"%2d\",dp[i][j]);\n        cout<<endl;\n      }\n*/      \n      rep(i,4){\n        int nx=cx+dx[i],ny=cy+dy[i];\n        if(nx<0 || nx>=m || ny<0 || ny>=n)continue;\n\n        if(dp[nx][ny]==-1){\n          if(zu[cx][cy]!='#' && zu[nx][ny]=='#')dp[nx][ny]=dp[cx][cy]+1;\n          else dp[nx][ny]=dp[cx][cy];\n          cc=true;\n          Q.push(mp(nx,ny));\n        }\n\n        if(zu[cx][cy]!='#' && zu[nx][ny]=='#' && dp[nx][ny]>dp[cx][cy]+1){\n          dp[nx][ny]=dp[cx][cy]+1;\n          Q.push(mp(nx,ny));\n          cc=true;\n        }else if(zu[cx][cy]==zu[nx][ny] && dp[nx][ny]>dp[cx][cy]){\n          dp[nx][ny]=dp[cx][cy];\n          Q.push(mp(nx,ny));\n          cc=true;\n        }\n        if(zu[cx][cy]=='#' && zu[nx][ny]!='#' && dp[nx][ny]+1<dp[cx][cy]){\n          dp[cx][cy]=dp[nx][ny]+1;\n        }else if(zu[cx][cy]==zu[nx][ny] && dp[nx][ny]<dp[cx][cy])dp[cx][cy]=dp[nx][ny];\n      }\n      if(cc)Q.push(mp(cx,cy));\n    }\n/*\n    rep(i,m){\n      rep(j,n)printf(\"%2d\",dp[i][j]);\n      cout<<endl;\n    }\n*/   \n    int ans=dp[0][0];\n    rep(i,n){\n      ans=min(ans,dp[0][i]);\n      ans=min(ans,dp[m-1][i]);\n    }\n    rep(i,m){\n      ans=min(ans,dp[i][0]);\n      ans=min(ans,dp[i][n-1]);\n    }\n    cout<<ans<<endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\nusing namespace std;\n\nint a, b;\nstring c[102];\nvector<int>l, r, x, y;\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nbool S;\nvoid saiki(int n,int  m) {\n\tc[n][m] = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint p = n + dx[i], q = m + dy[i];\n\t\tif (p >= 0 && p < a&&q >= 0 && q < b) {\n\t\t\tif (c[p][q] == '&')S = true;\n\t\t\telse if (c[p][q] == '.') {\n\t\t\t\tsaiki(p, q);\n\t\t\t}\n\t\t\telse if (c[p][q] == '#') {\n\t\t\t\tl.push_back(p);\n\t\t\t\tr.push_back(q);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile (cin >> b >> a, a | b) {\n\t\tstring t;\n\t\tfor (int q = 0; q < b + 2; q++)t += \".\";\n\t\tc[0] = c[a + 1] = t;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d+1] = \".\" + e + \".\";\n\t\t}\n\t\tl.clear(); r.clear(); x.clear(); y.clear();\n\t\tsaiki(0, 0);\n\t\tfor (int f = 0;; f++) {\n\t\t\tif (S) { cout << f << endl; break; }\n\t\t\tx = l; y = r;\n\t\t\tl.clear(); r.clear();\n\t\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\t\tc[x[i]][y[i]] = ',';\n\t\t\t}\n\t\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\t\tsaiki(x[i], y[i]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n};\nclass Compare {\npublic :\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time > r.time;\n\t}\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint main() {\n\twhile (1) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>field(H,vector<int>(W));\n\t\n\t\tfor (int i = 0; i <H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '&')field[i][j] = 2;\n\t\t\t\telse if (st[j] == '.')field[i][j] = 1;\n\t\t\t\telse field[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tvector<vector<int>>memo(H, vector<int>(W, 1e8));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\tque.push(aa{ j,i,0 });\n\t\t\t\tmemo[i][j] = 0;\n\n\t\t\t\tj = W - 1;\n\t\t\t\tque.push(aa{ j,i,0 });\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t{\n\t\t\t\tint i = 0;\n\t\t\t\tque.push(aa{ j,i,0 });\n\t\t\t\tmemo[i][j] = 0;\n\n\t\t\t\ti= H - 1;\n\t\t\t\tque.push(aa{ j,i,0 });\n\t\t\t\tmemo[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tif (field[atop.y][atop.x] == 2) {\n\t\t\t\tans = atop.time;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.pop();\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tconst int nextx = atop.x + dx[way];\n\t\t\t\tconst int nexty = atop.y + dy[way];\n\t\t\t\tif (nextx < W&&nextx >= 0 && nexty >= 0 && nexty < H) {\n\t\t\t\t\tconst int nexttime = atop.time + (field[nexty][nextx] && !field[atop.y][atop.x]);\n\t\t\t\t\tif (memo[nexty][nextx] > nexttime) {\n\t\t\t\t\t\tmemo[nexty][nextx] = nexttime;\n\t\t\t\t\t\tque.push(aa{ nextx,nexty,nexttime });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\tgx++; gy++;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\t//rep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\t//rep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\tq.push(mp(0, gx)); q.push(mp(0, (h+1)*1000+gx));\n\t\tq.push(mp(0, gy*1000)); q.push(mp(0, gy*1000+w+1));\n\t\trep(i, h) {\n\t\t\tif(C[i][0]!='#') q.push(mp(0,(i+1)*1000+1));\n\t\t\tif(C[i][w-1]!='#') q.push(mp(0,(i+1)*1000+w));\n\t\t}\n\t\trep(i, w) {\n\t\t\tif(C[h-1][i]!='#') q.push(mp(0,(h)*1000+i+1));\n\t\t\tif(C[0][i]!='#') q.push(mp(0,1000+i+1));\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tif(ny==gy && nx == gx) break;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy][gx]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x,y;\nchar field[100][100];//field[y][x]\nbool flag;\n\nvoid DFS(int a,int b){\n\tif(field[b][a] == '&'){\n\t\tflag = true;\n\t}\n\telse\n\t\tfield[b][a] = '-';\n\tif(0 <= b+1 && b+1 < y && 0 <= a && a < x && (field[b+1][a] == '.'|| field[b+1][a] == '&'))\n\t\tDFS(a,b+1);\n\tif(0 <= b-1 && b-1 < y && 0 <= a && a < x && (field[b-1][a] == '.'|| field[b-1][a] == '&'))\n\t\tDFS(a,b-1);\t\n\tif(0 <= b && b < y && 0 <= a+1 && a+1 < x && (field[b][a+1] == '.'|| field[b][a+1] == '&'))\n\t\tDFS(a+1,b);\t\n\tif(0 <= b && b < y && 0 <= a-1 && a-1 < x && (field[b][a-1] == '.'|| field[b][a-1] == '&'))\n\t\tDFS(a-1,b);\n}\n\nvoid hey(int a,int b){\n\tfield[b][a] = '-';\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tif((0 <= b+i && b+i < y) && (0 <= a+j && a+j < x) && field[b+i][a+j]=='#')\n\t\t\t\they(a+j,b+i);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> x >> y){\n\t\tif(!x && !y)\n\t\t\tbreak;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(field[0][i] == '.')\n\t\t\t\tfield[0][i] = '-';\n\t\t\tif(field[y-1][i] == '.')\n\t\t\t\tfield[y-1][i] = '-';\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tif(field[i][0] == '.')\n\t\t\t\tfield[i][0] = '-';\n\t\t\tif(field[i][x-1] == '.')\n\t\t\t\tfield[i][x-1] = '-';\n\t\t}\n\t\tint count = 0;\n\t\tflag = false;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\tDFS(j,i);\n\t\t\t}\n\t\t}\n\t\twhile(!flag){\n\t\t\tint a,b;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '#'){\n\t\t\t\t\t\ta = j;b = i;\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext:;\n\t\t\they(a,b);\n\t\t\tcount++;\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\t\tDFS(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\tstatic const long long INF = 1000000000000000000;\n\tint V, E; vector<vector<pair<int, long long> > > G;\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long long> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long long> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long long> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long long w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long long w) { add1(v1, v2, w); add1(v2, v1, w); }\n\tbool operator==(const Graph2& g) const { return G == g.G; }\n\tbool operator!=(const Graph2& g) const { return G != g.G; }\n\tvector<pair<int, long long> > operator[](int x) { return G[x]; }\n\tvector<long long> dist(int s) {\n\t\tpriority_queue<pair<long long, int> > que; que.push(make_pair(0, s));\n\t\tvector<long long> d(V, INF); d[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long long, int> t = que.top(); que.pop();\n\t\t\tint u = t.second;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first; long long e = G[u][i].second;\n\t\t\t\tif (d[v] > d[u] + e) {\n\t\t\t\t\td[v] = d[u] + e;\n\t\t\t\t\tque.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n};\n\n// ------ Main ------ //\nint H, W, g; string s[100];\nint main() {\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) cin >> s[i];\n\t\tGraph2 G(H * W + 1);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 1; j < W; j++) {\n\t\t\t\tG.add1(i * W + j - 1, i * W + j, (s[i][j - 1] == '#' && s[i][j] != '#') ? 1 : 0);\n\t\t\t\tG.add1(i * W + j, i * W + j - 1, (s[i][j - 1] != '#' && s[i][j] == '#') ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tG.add1(i * W + j - W, i * W + j, (s[i - 1][j] == '#' && s[i][j] != '#') ? 1 : 0);\n\t\t\t\tG.add1(i * W + j, i * W + j - W, (s[i - 1][j] != '#' && s[i][j] == '#') ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (i == 0 || i + 1 == H || j == 0 || j + 1 == W) G.add1(H * W, i * W + j, 0);\n\t\t\t\tif (s[i][j] == '&') g = i * W + j;\n\t\t\t}\n\t\t}\n\t\tcout << G.dist(H * W)[g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 150;\nchar table[MAX_N][MAX_N];\nint n, m;\nint bfs(int y, int x)\n{\n    queue<P> que;\n    int used[m + 1][n + 1];\n    for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) used[i][j] = INF;\n    que.push(P(y, x));\n    used[y][x] = 0;\n    while(que.size())\n    {\n        P p = que.front(); que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n            int cnt = used[p.first][p.second];\n            if(ny >= m || nx >= n || ny < 0 || nx < 0) continue;\n            //問題文に注意\n            if(table[ny][nx] == '#' && not (table[p.first][p.second] == '#')) cnt++;\n            if(used[ny][nx] > cnt)\n            {\n                used[ny][nx] = cnt;\n                que.push(P(ny, nx));\n            }\n        }\n    }\n    int res = INF;\n    for(int i = 0; i < m; i++) res = min({res, used[i][0], used[i][n - 1]});\n    for(int j = 0; j < n; j++) res = min({res, used[0][j], used[m - 1][j]});\n    return res;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> n >> m, n | m)\n    {\n        int sy, sx;\n        for(int i = 0; i < m; i++)\n        {\n            for(int j = 0; j < n; j++)\n            {\n                cin >> table[i][j];\n                if(table[i][j] == '&') sy = i, sx = j;\n            }\n        }\n        cout << bfs(sy, sx) << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\ntypedef int cost_type;\nstruct edge {\n\tint to;\n\tcost_type cost;\n\tedge(){}\n\tedge(int to,cost_type cost) : to(to) ,cost(cost) {}\n};\n\ntypedef pair<cost_type,int> P;\n\nvoid dijkstra(int s,vector<P::first_type>& cost_table,vector<vector<edge> >& edges,vector<int>* _prev = NULL){\n\t\n\t//init\n\tcost_table.resize((int)edges.size());\n\tfill(cost_table.begin(),cost_table.end(),P::first_type(INF));\n\tif(_prev) _prev->resize((int)edges.size());\n\tif(_prev) fill(_prev->begin(),_prev->end(),-1);\n\t\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tq.push(P(0,s));\n\tcost_table[s] = 0;\n\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif(cost_table[v] < p.first) continue;\n\t\tfor(int i = 0; i < (int)edges[v].size(); i++){\n\t\t\tedge& e = edges[v][i];\n\t\t\tif(cost_table[e.to] > cost_table[v] + e.cost){\n\t\t\t\tcost_table[e.to] = cost_table[v] + e.cost;\n\t\t\t\tif(_prev) (*_prev)[e.to] = v;\n\t\t\t\tq.push(P(cost_table[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,(n||m)){\n\t\tvector<string> v(m);\n\t\tFOR(i,m) cin>>v[i];\n\t\tvector<vector<edge> >e(n*m);\n\t\tint start;\n\t\tFOR(i,m) FOR(j,n){\n\t\t\tif(v[i][j] == '&'){\n\t\t\t\tstart = i * n + j;\n\t\t\t}\n\t\t\tstatic int dx[] = {0,0,1,-1};\n\t\t\tstatic int dy[] = {1,-1,0,0};\n\t\t\tFOR(k,4){\n\t\t\t\tint nh = dx[k] + i;\n\t\t\t\tint nw = dy[k] + j;\n\t\t\t\tif(nh < 0 || nh >= m || nw <0 || nw >= n) continue;\n\t\t\t\tint nx = nh * n + nw;\n\t\t\t\tint ct = v[i][j] != '#' && v[nh][nw] == '#';\n\t\t\t\te[i * n + j].push_back(edge(nx,ct));\n\t\t\t}\n\t\t}\n\n\t\tvector<int> cost;\n\t\tdijkstra(start,cost,e);\n\n\t\tint ans = INF;\n\t\tFOR(i,m) FOR(j,n){\n\t\t\tif(i == 0 || i == m-1 || j == 0 || j == n-1){\n\t\t\t\tans = min(ans,cost[i*n+j]);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 10e-6;\n\nchar stage[100][100];\nint costTable[100][100];\n\nvoid bfs(int w,int h){\n\tconst int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\tint sx,sy;\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tif(stage[y][x] == '&'){\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\nfound:;\n\n\tmemset(costTable,0x3,sizeof(costTable));\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\n\tcostTable[sy][sx] = 0;\n\n\twhile(!que.empty()){\n\t\tint x = que.front().first;\n\t\tint y = que.front().second;\n\t\tque.pop();\t\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = x + t[i][0];\n\t\t\tint dy = y + t[i][1];\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\n\t\t\tint cost = costTable[y][x] + ((stage[dy][dx] == '#' && stage[y][x] != '#') ? 1 : 0);\n\t\t\tif(costTable[dy][dx] <= cost) continue;\n\n\t\t\tcostTable[dy][dx] = cost;\n\t\t\tque.push(P(dx,dy));\n\t\t}\n\t}\n}\n\nint seekExtWall(int w,int h){\n\tint res = 0x3333;\n\n\tfor(int x=0;x<w;x++){\n\t\tres = min(res,costTable[0][x]);\n\t}\n\n\tfor(int x=0;x<w;x++){\n\t\tres = min(res,costTable[h-1][x]);\n\t}\n\n\tfor(int y=0;y<h;y++){\n\t\tres = min(res,costTable[y][0]);\n\t}\n\n\tfor(int y=0;y<h;y++){\n\t\tres = min(res,costTable[y][w-1]);\n\t}\n\n\treturn res;\n}\n\nvoid printCostTable(int w,int h){\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tcout << costTable[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tchar buf[128];\n\t\t\tscanf(\"%s\",buf);\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tstage[y][x] = buf[x];\n\t\t\t}\n\t\t}\n\n\t\tbfs(w,h);\n\t\tcout << seekExtWall(w,h) << endl;\n\t\t//printCostTable(w,h);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[110][110];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint const OFFSET = 2;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    fill(grid[0], grid[0]+110*110, 'X');\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i+OFFSET][j+OFFSET];\n        if(grid[i+OFFSET][j+OFFSET] == '&') {\n          sx = j+OFFSET, sy = i+OFFSET;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      if(grid[y][x] == 'X') {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[y][x] == '.' && grid[ny][nx] == '#');\n        int ans = 0;\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          Q.push(Piii(-ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/26 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nvoid DFS(char M[104][104], int y, int x, int C[104][104], int c)\n{\n\tC[y][x] = c;\n\n\tif(M[y-1][x]=='.'&&C[y-1][x]==-1)\n\t\tDFS(M, y-1, x, C, c);\n\tif(M[y+1][x]=='.'&&C[y+1][x]==-1)\n\t\tDFS(M, y+1, x, C, c);\n\tif(M[y][x-1]=='.'&&C[y][x-1]==-1)\n\t\tDFS(M, y, x-1, C, c);\n\tif(M[y][x+1]=='.'&&C[y][x+1]==-1)\n\t\tDFS(M, y, x+1, C, c);\n}\n\nvoid DFS2(char M[104][104], int y, int x, int C[104][104], int c)\n{\n\tC[y][x] = c;\n\n\tif(M[y-1][x]=='.'&&C[y-1][x]==-1)\n\t\tDFS(M, y-1, x, C, c);\n\tif(M[y+1][x]=='.'&&C[y+1][x]==-1)\n\t\tDFS(M, y+1, x, C, c);\n\tif(M[y][x-1]=='.'&&C[y][x-1]==-1)\n\t\tDFS(M, y, x-1, C, c);\n\tif(M[y][x+1]=='.'&&C[y][x+1]==-1)\n\t\tDFS(M, y, x+1, C, c);\n\n\tif(M[y-1][x]=='#'&&C[y-1][x]==-1)\n\t\tDFS2(M, y-1, x, C, c);\n\tif(M[y+1][x]=='#'&&C[y+1][x]==-1)\n\t\tDFS2(M, y+1, x, C, c);\n\tif(M[y][x-1]=='#'&&C[y][x-1]==-1)\n\t\tDFS2(M, y, x-1, C, c);\n\tif(M[y][x+1]=='#'&&C[y][x+1]==-1)\n\t\tDFS2(M, y, x+1, C, c);\n}\n\nint main()\n{\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)\n\t\t\tbreak;\n\n\t\tchar M[104][104];\n\t\tfor(int y=0; y<=m+3; y++)\n\t\t\tfor(int x=0; x<=n+3; x++)\n\t\t\t\tM[y][x] = '#';\n\t\tfor(int y=1; y<=m+2; y++)\n\t\t\tfor(int x=1; x<=n+2; x++)\n\t\t\t\tM[y][x] = '.';\n\n\t\tint Y = -1;\n\t\tint X = -1;\n\t\tfor(int y=2; y<=m+1; y++){\n\t\t\tfor(int x=2; x<=n+1; x++){\n\t\t\t\tcin >> M[y][x];\n\t\t\t\tif(M[y][x]=='&'){\n\t\t\t\t\tY = y;\n\t\t\t\t\tX = x;\n\t\t\t\t\tM[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << Y << ' ' << X << endl;\n\n\t\tint C[104][104];\n\t\tfor(int y=0; y<=m+3; y++)\n\t\t\tfor(int x=0; x<=n+3; x++)\n\t\t\t\tC[y][x] = -1;\n\n\t\tint cnt = 0;\n\t\tDFS(M, Y, X, C, cnt);\n\n\t\tif(C[1][1]!=-1){\n\t\t\tcout << C[1][1] << endl;\n\t\t\tcontinue;\n\t\t}\n\n\twhile(true){\n\t\tcnt++;\n\t\tfor(int y=2; y<=m+1; y++){\n\t\t\tfor(int x=2; x<=n+1; x++){\n\t\t\t\tif(M[y][x]=='#'&&C[y][x]==-1&&M[y-1][x]=='.'&&C[y-1][x]==cnt-1)\n\t\t\t\t\tDFS2(M, y, x, C, cnt);\n\t\t\t\tif(M[y][x]=='#'&&C[y][x]==-1&&M[y+1][x]=='.'&&C[y+1][x]==cnt-1)\n\t\t\t\t\tDFS2(M, y, x, C, cnt);\n\t\t\t\tif(M[y][x]=='#'&&C[y][x]==-1&&M[y][x-1]=='.'&&C[y][x-1]==cnt-1)\n\t\t\t\t\tDFS2(M, y, x, C, cnt);\n\t\t\t\tif(M[y][x]=='#'&&C[y][x]==-1&&M[y][x+1]=='.'&&C[y][x+1]==cnt-1)\n\t\t\t\t\tDFS2(M, y, x, C, cnt);\n\t\t\t}\n\t\t}\n\n\t\tif(C[1][1]!=-1){\n\t\t\tcout << C[1][1] << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n/*\n\t\tfor(int y=0; y<=m+3; y++){\n\t\t\tfor(int x=0; x<=n+3; x++){\n\t\t\t\tif(C[y][x]==-1)\n\t\t\t\t\tcout << '-';\n\t\t\t\telse\n\t\t\t\t\tcout << C[y][x];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst int N = 102;\n\nint h, w;\nchar mapData[N][N];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[N][N];\n\nclass State{\npublic:\n  int y, x, cost;\n};\n\nint bfs(){\n  State u, v;\n  u.y = 0;\n  u.x = 0;\n  u.cost = 0;\n  queue<State> Q;\n  Q.push(u);\n  fill(height[0], height[N], INF);\n  height[0][0] = 0;\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    for(int i=0;i<4;i++){\n      v.y = u.y + dy[i];\n      v.x = u.x + dx[i];\n      if(v.y < 0 || v.y > h+1) continue;\n      if(v.x < 0 || v.x > w+1) continue;\n      v.cost = u.cost;\n      if(mapData[v.y][v.x] == '#') ++v.cost;\n      if(height[v.y][v.x] <= v.cost) continue;\n      height[v.y][v.x] = v.cost;\n      Q.push(v);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    int i = 0, j;\n    for(j=0;j<=w+1;j++){\n      mapData[i][j] = '.';\n    }\n    for(i=1;i<=h;i++){\n      for(j=0;;j++){\n\tif(j == 0){\n\t  mapData[i][j] = '.';\n\t  continue;\n\t}\n\tif(j == w + 1){\n\t  mapData[i][j] = '.';\n\t  break;\n\t}\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    for(j=0;j<=w+1;j++){\n      mapData[i][j] = '.';\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[110][110];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      if(x == 0 || y == 0 || x == W-1 || y == H-1) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[y][x] == '.' && grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1 || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(-ncost, Pii(nx, ny)));\n          }\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.front(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        if(IN(nx, ny)) {\n          if(memo[ny][nx] == -1\n             || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(ncost, Pii(nx, ny)));\n          }\n        } else {\n          ans = min(ans, cost);\n        }\n      }\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M; // N: x, M: y\nint map[102][102];\nbool used[1000][102][102];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        memset(used, 0, sizeof(used));\n        memset(map, 0, sizeof(map));\n\n        FOR(i, 1, M+1){\n            FOR(j, 1, N+1){\n                char c;\n                std::cin >> c;\n                if(c == '.'){map[i][j] = 0;}\n                else if(c == '#'){map[i][j] = -1;}\n                else{map[i][j] = 1;}\n            }\n        }\n    \n        std::priority_queue<State,std::vector<State>,std::greater<State>> q;\n        REP(i, N+2){\n            q.push(mp(0, mp(0, i)));\n            q.push(mp(0, mp(M+1, i)));\n        }\n\n        REP(i, M+2){\n            q.push(mp(0, mp(i, 0)));\n            q.push(mp(0, mp(i, N+1)));\n        }\n\n        int res = -1;\n        while(!q.empty()){\n            State s = q.top(); q.pop();\n            int t = s.first, y = s.second.first, x = s.second.second;\n\n            if(t >= 1000){continue;}\n            if(map[y][x] == 1){res = t; break;}\n            if(used[t][y][x]){continue;}\n\n            used[t][y][x] = true;\n        \n            REP(i, 4){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1 &&\n                   !used[t][ny][nx] && map[ny][nx] != -1){\n                    q.push(mp(t, mp(ny, nx)));\n                }\n            }\n\n            REP(i, 4){\n                int mx = x + dx[i], my = y + dy[i], nx = x + dx[i]*2, ny = y + dy[i]*2;\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1 &&\n                   !used[t+1][ny][nx] && map[ny][nx] != -1 && map[my][mx] == -1){\n                    q.push(mp(t+1, mp(ny, nx)));\n                }\n            }\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n\nint d[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n    if(x < 0 || x >= w || y < 0 || y >= h) return true;\n    return false;\n}\n\nstring s[110];\n\nint main(){\n    int x, y;\n    int sx, sy;\n    while(cin>>x>>y && x && y){\n        rep(i, y) cin>>s[i];\n        rep(i, y) rep(j, x){\n            if(s[i][j] == '&'){\n                sx = j;\n                sy = i;\n            }\n            d[i][j] = INF;\n        }\n        //cout<<y<<\" \"<<x<<endl;\n        priority_queue<pair<int, pii> > q;\n        q.push(mp(0, mp(sy, sx)));\n        d[sy][sx] = 0;\n        pair<int, pii> p;\n        int ans = -1;\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            //cout<<\" \"<<p.fi<<\" (\"<<p.se.fi<<\", \"<<p.se.fi<<endl;\n            rep(i, 4){\n                int nx = p.se.se + dx[i];\n                int ny = p.se.fi + dy[i];\n                if(isOutOfRange(nx, ny, x, y)){\n                    ans = -p.fi;\n                    break;\n                }\n                int c = -p.fi + (s[ny][nx]=='#'?1:0);\n                if(d[ny][nx] <= c) continue;\n                d[ny][nx] = c;\n                q.push(mp(-c, mp(ny, nx)));\n            }\n            if(ans != -1) break;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <utility>\n\nusing namespace std;\n\nint INF = 1 << 28;\nint n;\nint m;\nchar map[100][100];\nint visited[100][100];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint ans;\n\nint solve(pair<int,int> pos, int c) {\n\n\tint x = pos.first;\n\tint y = pos.second;\n\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\treturn ans = c;\n\t}\n\tif (visited[y][x] <= c)\n\t\treturn INF;\n\tvisited[y][x] = c;\n\tif (ans < c) {\n\t\treturn INF;\n\t}\n\tint res = INF;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tres = min(res,\n\t\t\tsolve(make_pair(nx, ny), c + ((map[y][x] == '#') ? 1 : 0)));\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (1) {\n\t\tans = INF;\n\t\tcin>>n;\n\t\tcin>>m;\n\t\tif ((n | m) == 0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tvisited[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tif (n <= 2 || m <= 2) {\n\t\t\tcout << 0 <<\"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint sx = 0;\n\t\tint sy = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\ti = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<solve(make_pair(sx,sy), 0)<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[110][110];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      bool ok = 0;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + ((grid[y][x] == '.' || grid[y][x] == '&') && grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1 || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(-ncost, Pii(nx, ny)));\n          }\n        }\n        else {\n          cout << cost << endl;\n          ok = 1;\n        }\n      }\n      if(ok) break;\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint dp[110][110];\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<string>in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tqueue<pip>q;\n\t\tint sx,sy;\n\t\trep(i,110)rep(j,110)dp[i][j]=inf;\n\t\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\t\tif(in[i][j]!='#'){\n\t\t\t\tq.push(pip(i,pii(j,0)));\n\t\t\t\tdp[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,m)if(in[i][j]=='&')sx=i,sy=j;\n\t\twhile(!q.empty()){\n\t\t\tpip p=q.front();\n\t\t\tq.pop();\n\t\t\tint x=p.first,y=p.second.first,cost=p.second.second;\n//\t\t\tcout<<x<<\" \"<<y<<\" \"<<cost<<endl;\n\t\t\tif(dp[x][y]<cost)continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tint ncost=cost+(in[nx][ny]=='#'?1:0);\n//\t\t\t\tcout<<\" \"<<nx<<\" \"<<ny<<\" \"<<ncost<<endl;\n\t\t\t\tif(dp[nx][ny]>ncost){\n\t\t\t\t\tdp[nx][ny]=ncost;\n\t\t\t\t\tq.push(pip(nx,pii(ny,ncost)));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[sx][sy]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n || m) {\n\t\tvector<vector<int> > cnt(m, vector<int>(n, INF));\n\t\tvector<string> str(m);\n\t\tREP(i, m) cin >> str[i];\n\t\t\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n\t\tREP(i, m) {\n\t\t\tpq.push(make_pair(str[i][0] == '#', pii(i, 0)));\n\t\t\tpq.push(make_pair(str[i][n - 1] == '#', pii(i, n - 1)));\n\t\t}\n\t\tREP(i, n) {\n\t\t\tpq.push(make_pair(str[0][i] == '#', pii(0, i)));\n\t\t\tpq.push(make_pair(str[m - 1][i] == '#', pii(m - 1, i)));\n\t\t}\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpair<int, pii> now = pq.top();\n\t\t\tpq.pop();\n\t\t\t\n\t\t\tint x = now.second.second, y = now.second.first;\n\t\t\tif (cnt[y][x] != INF) continue;\n\t\t\tcnt[y][x] = now.first;\n\t\t\t\n\t\t\tif (str[y][x] == '&') {\n\t\t\t\tcout << cnt[y][x] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) continue;\n\t\t\t\tpq.push(make_pair(cnt[y][x] + (str[ny][nx] == '#'), pii(ny, nx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint main(){\n  int h,w;\n  char g[128][128];\n\n  while(scanf(\"%d%d \",&w,&h), w+h){\n    int memo[128][128];\n    int sx, sy;\n\n    memset(memo, -1, sizeof(memo));\n\n    REP(i,h){\n      fgets(g[i], sizeof(g[i]), stdin);\n      REP(j,w) if(g[i][j] == '&'){\n        g[i][j] = '.';\n        sx = j;\n        sy = i;\n      }\n    }\n\n    typedef pair<int, pair<int,int> > data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    q.push(mp(0,mp(sx,sy)));\n\n    while(q.size()){\n      int c = q.top().f;\n      int x = q.top().s.f;\n      int y = q.top().s.s;\n\n      //printf(\"%d,%d => %d\\n\",x,y,c);\n\n      q.pop();\n\n      if(memo[y][x] != -1) continue;\n\n      if(!ISIN(x,y,w,h)){\n        print(c);\n        break;\n      }\n\n      memo[y][x] = c;\n\n      REP(i,4){\n        int xx = x + _dx[i];\n        int yy = y + _dy[i];\n\n        char prev = g[y][x];\n        char now;\n\n        if(memo[yy][xx] != -1) continue;\n\n        if(ISIN(xx,yy,w,h)) now = g[yy][xx];\n        else now = '.';\n\n        //printf(\"(%d,%d):%c (%d,%d):%c\\n\",x,y,prev,xx,yy,now);\n\n        if(prev == '#' && now == '.')\n          q.push(mp(c+1,mp(xx,yy)));\n        else\n          q.push(mp(c,mp(xx,yy)));\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nstruct NODE{\n\tint x,y;\n\tint count;\n\tchar sw;\n};\nbool operator<(const NODE &a,const NODE &b){\n\treturn a.count > b.count;\n}\n\nint w,h;\nbool isWrong(const NODE &n){\n\tif(n.x >= w || n.y >= h)return true;\n\tif(n.x < 0  || n.y <  0)return true;\n\treturn false;\n}\n\nbool edge(const NODE &n){\n\tif(n.x == 0 || n.x == w-1)return true;\n\tif(n.y == 0 || n.y == h-1)return true;\n\treturn false;\n}\n\nint main(){\n\tstring s;\n\twhile(cin >> w >> h, w){\n\t\tvector<string> map(h);\n\t\tNODE t; t.count = 0, t.sw = '.';\n\t\trep(i,h){\n\t\t\tcin >> map[i];\n\t\t\tif(~map[i].find(\"&\"))t.x = map[i].find(\"&\"), t.y = i;\n\t\t}\n\t\tint memo[100][100];\n\t\trep(i,100)rep(j,100)memo[i][j] = (1<<21);\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(t);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(memo[q.y][q.x] <= q.count)continue;\n\t\t\t\n\t\t\tif(edge(q) && q.sw == '.'){\n\t\t\t\tcout << q.count << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemo[q.y][q.x] = q.count;\n\t\t\trep(i,4){\n\t\t\t\tNODE nt;\n\t\t\t\tnt.x = q.x+dx[i], nt.y = q.y+dy[i], nt.count = q.count;\n\t\t\t\tif(isWrong(nt))continue;\n\t\t\t\tif( q.sw == '#' && map[nt.y][nt.x] == '.')nt.count++;\n\t\t\t\tnt.sw = map[nt.y][nt.x];\n\t\t\t\t\n\t\t\t\tQ.push(nt);\t\t\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,a,n) for(int i=(a);i<(n);++i)\n\n#define INV (-1)\n#define N 102\n#define INFTY 1<<30\n#define PLANE 2\n#define MOAT 1\n\nusing namespace std;\n\nstruct Node\n{\n\tint i,j;\n\tint w;\n\tint v;\n\tbool vis;\n};\n\nclass GreaterPNode{\npublic:\n\tbool operator()(const Node *a, const Node *b)const{\n\t\treturn a->w > b->w;\n\t}\n};\n\nint n,m;\nNode map[N][N];\n\nbool inRange(int t, int Min, int Max){\n\treturn Min <= t && t < Max;\n}\n\nint dijkstra(int i, int j, int gi, int gj)\n{\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\tNode* p = &map[i][j];\n\tpriority_queue<Node *, vector<Node *>, GreaterPNode > pq;\n\n\tp->w = 0;\n\tpq.push( p );\n\n\twhile( !pq.empty() ){\n\t\tp = pq.top();\n\t\tpq.pop();\n\n\t\tp->vis=false;\n\t\t\n\t\tfor(int k = 0; k < 4; ++k){\n\t\t\tint ti = p->i+ci[k], tj = p->j + cj[k];\n\t\t\tif( inRange( ti,1,m+1) && inRange( tj,1,n+1) ){\n\t\t\t\tint cost = 0;\n\t\t\t\tNode *q = &map[ ti ][ tj ];\n\n\t\t\t\tif( p->v == MOAT && q->v == PLANE ){\n\t\t\t\t\tcost = 1;\n\t\t\t\t}\n\n\t\t\t\tif( !q->vis && q->w > p->w + cost ){\n\t\t\t\t\tq->w = p->w + cost;\n\t\t\t\t\tpq.push( q );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid ResetMap(bool bAll)\n{\n\tREP(i,0,N)REP(j,0,N){\n\t\tmap[i][j].i=i;\n\t\tmap[i][j].j=j;\n\t\tif( bAll ) map[i][j].v=PLANE;\n\t\tmap[i][j].w=INFTY;\n\t\tmap[i][j].vis=false;\n\t}\n}\n\nvoid PrintMap(){\n\tREP(i,1,m+1){\n\t\tREP(j,1,n+1){\n\t\t\tcout << setw(3) << map[i][j].w;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint gi, gj;\n\t\tint ans = INFTY;\n\t\t\n\t\tcin>>n>>m;\n\t\tif( m==0&&n==0 )break;\n\t\t\n\t\tResetMap( true );\n\t\t\n\t\tREP(i,1,m+1){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,1,n+1){\n\t\t\t\tif( s[j-1] == '&'){\n\t\t\t\t\tgi = i;\n\t\t\t\t\tgj = j;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tmap[i][j].v = MOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i,1,m+1){\n\t\t\tdijkstra(i,1,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tREP(i,1,m+1){\n\t\t\tdijkstra(i,n,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tREP(j,1,n+1){\n\t\t\tdijkstra(1,j,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tREP(j,1,n+1){\n\t\t\tdijkstra(m,j,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <utility>\n\nusing namespace std;\n\nint INF = 1 << 28;\nint n;\nint m;\nchar map[100][100];\nint visited[100][100];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint ans;\n\nint solve(pair<int,int> pos, int c) {\n\n\tint x = pos.first;\n\tint y = pos.second;\n\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\treturn ans = c;\n\t}\n\tif (visited[y][x] <= c)\n\t\treturn INF;\n\tvisited[y][x] = c;\n\tif (ans < c) {\n\t\treturn INF;\n\t}\n\tint res = INF;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tres = min(res,\n\t\t\tsolve(make_pair(nx, ny), c + ((map[y][x] == '#') ? 1 : 0)));\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (1) {\n\t\tans = INF;\n\t\tcin>>n;\n\t\tcin>>m;\n\t\tif ((n | m) == 0)\n\t\t\tbreak;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> map[i];\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvisited[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tif (n <= 2 || m <= 2) {\n\t\t\tcout << 0 <<\"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint sx = 0;\n\t\tint sy = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\ti = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<solve(make_pair(sx,sy), 0)<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF (1<<24)\nusing namespace std;\nint W,H,mini,mini_x,mini_y,ny,nx,cost;\nstring str;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nchar t[102][102];\nbool vd[102][102];\nint u[102][102];\n\nint main(){\n  while(cin>>W>>H){\n    for(int i=0;i<102;i++)for(int j=0;j<102;j++){\n\tt[i][j]='.';\n\tvd[i][j]=false;\n\tu[i][j]=INF;\n      }\n\n    for(int i=1;i<=H;i++){\n      cin>>str;\n      for(int j=1;j<=W;j++){\n\tt[i][j]=str[j-1];\n\tif(t[i][j]=='&')u[i][j]=0;\n      }\n    }\n    /*\n    for(int i=0;i<H+2;i++){\n      for(int j=0;j<W+2;j++){\n\tcout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    \n    while(1){\n      mini=INF;\n      for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++){\n\t  if(mini>u[i][j]&&vd[i][j]==false){\n\t    mini=u[i][j];\n\t    mini_y=i;\n\t    mini_x=j;\n\t  }\n\t}\n      }\n\n      if(mini==INF)break;\n\n      vd[mini_y][mini_x]=true;\n\n      //cout<<mini_y<<' '<<mini_x<<' '<<u[mini_y][mini_x]<<endl;\n\n      \n      if(mini_y==0||mini_x==0||mini_y==H+1||mini_x==W+1){\n\tcout<<u[mini_y][mini_x]<<endl;\n\tbreak;\n      }\n      \n\n      for(int i=0;i<4;i++){\n\tny=mini_y+dy[i];\n\tnx=mini_x+dx[i];\n\n\tcost=((t[mini_y][mini_x]=='#'&&t[ny][nx]=='.')?1:0);\n\n\tif(u[ny][nx]>u[mini_y][mini_x]+cost){\n\t  u[ny][nx]=u[mini_y][mini_x]+cost;\n\t}\n      }\n\t\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 120\n#define INF 1e9\n\nint H, W;\nchar field[MAX][MAX];\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n\nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nbool check(int y, int x){\n  if(y == 0 || y == H-1) return true;\n  if(x == 0 || x == W-1) return true;\n  return false;\n}\n\nvoid bfs(int y, int x){\n  int ans = INF;\n  int cost[MAX][MAX];\n  fill(cost[0], cost[MAX], INF);\n  queue<int> nowx, nowy, cnt;\n  nowx.push(x); nowy.push(y); cnt.push(0);\n\n  while(!nowx.empty()){\n    int xx = nowx.front(); nowx.pop();\n    int yy = nowy.front(); nowy.pop();\n    int c = cnt.front(); cnt.pop();\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = xx + dx[i];\n      int ny = yy + dy[i];\n\n      if(!inField(ny, nx)) continue;\n      if(check(ny, nx)){\n        if(field[ny][nx] == '#'){\n          cost[ny][nx] = min(cost[ny][nx], c+1);\n        }else{\n          cost[ny][nx] = min(cost[ny][nx], c);\n        }\n        continue;\n      }\n      int nc = c;\n      if(field[ny][nx] == '#') nc++;\n      if(nc < cost[ny][nx]){\n        cost[ny][nx] = nc;\n        nowx.push(nx); nowy.push(ny); cnt.push(nc);\n      }\n    }\n  }\n  for(int i = 0 ; i < H ; i++){\n    ans = min(ans, cost[i][0]);\n    ans = min(ans, cost[i][W-1]);\n  }\n  for(int i = 0 ; i < W ; i++){\n    ans = min(ans, cost[0][i]);\n    ans = min(ans, cost[H-1][i]);\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  int sx, sy;\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == '&'){\n          sx = j; sy = i;\n        }\n      }\n    }  \n    bfs(sy, sx);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n\nbool nuru(vector<vector<char> > &field,int y,int x){\n    if(field[y][x] == '#' || field[y][x] == 'x'){\n        field[y][x] = 'x';\n        return false;\n    }\n    if(y==1 || y == field.size()-2 || x==1 || x == field[0].size()-2) return true;\n    field[y][x] = 'x';\n    return nuru(field,y+1,x) || nuru(field,y-1,x) || nuru(field,y,x+1) || nuru(field,y,x-1);\n}\nint solve(int n,int m){\n    int gy,gx;\n    vector<vector<char> > field(m+4,vector<char>(n+4));\n    for(int i=0;i<n+4;i++){\n        field[0][i] = '#';\n        field[m+3][i] = '#';\n    }\n    for(int i=0;i<m+4;i++){\n        field[i][0] = '#';\n        field[i][n+3] = '#';\n    }\n    for(int i=1;i<n+3;i++){\n        field[1][i] = '.';\n        field[m+2][i] = '.';\n    }\n    for(int i=1;i<m+3;i++){\n        field[i][1] = '.';\n        field[i][n+2] = '.';\n    }\n    for(int i=2;i<m+2;i++){\n        for(int j=2;j<n+2;j++){\n            char c;\n            cin >> c;\n            field[i][j] = c;\n            if(c=='&'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    int ret = 0;\n    while(true){\n        if(nuru(field,gy,gx)){\n            return ret;\n        }\n        for(int i=0;i<m+4;i++){\n            for(int j=0;j<n+4;j++){\n                if(field[i][j] == 'x'){\n                    field[i][j] = '.';\n                }\n            }\n        }\n        ret++;\n    }\n    cout << nuru(field,gy,gx) << endl;\n    for(int i=0;i<m+4;i++){\n        for(int j=0;j<n+4;j++){\n            cout << field[i][j];\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==m &&\n\n\n n==0) break;\n        cout << solve(n,m) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define N 102\n\nusing namespace std;\n\nint n,m;\nint omap[N][N];\nint map[N][N];\n\nvoid dfs(int i, int j){\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\t\n\tif( i < 0 || i > m+2 || j < 0 || j > n+2 )\n\t\treturn ;\n\tif( map[i][j] == 1 )\n\t\treturn ;\n\t\n\tmap[i][j] = 1;\n\tfor(int k = 0; k < sizeof(ci)/sizeof(*ci); ++k){\n\t\tdfs( i+ci[k], j+cj[k] );\n\t}\n\treturn ;\n}\nvoid printMap(){\n\tfor(int i=0; i<m+2;++i){\n\t\tfor(int j=0;j<n+2;++j){\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n\nint main(){\n\twhile(true){\n\t\tint si, sj;\n\t\tint ans = 1000;\n\t\tint tans = 0;\n\t\t\n\t\tcin>>n>>m;\n\t\tif(m==0&&n==0)break;\n\t\t\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tfor(int j = 0; j < N; ++j){\n\t\t\t\tomap[i][j] = map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < m+1; ++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(int j = 1; j < n+1; ++j){\n\t\t\t\tif( s[j-1] == '.' ){\n\t\t\t\t\tomap[i][j] = map[i][j] = 0;\n\t\t\t\t}else if( s[j-1] == '&'){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tomap[i][j] = map[i][j] = 0;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tomap[i][j] = map[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = si; i >= 0; --i){ if( map[i][sj] == 0 ){ dfs( i, sj ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\t\tfor(int i = si; i <= m+1; ++i){ if( map[i][sj] == 0 ){ dfs( i, sj ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\t\tfor(int j = sj; j >= 0; --j){ if( map[si][j] == 0 ){ dfs( si, j ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\t\tfor(int j = sj; j <= n+1; ++j){ if( map[si][j] == 0 ){ dfs( si, j ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n\n#define N 102\n\nusing namespace std;\n\nint n,m;\nint omap[N][N];\nint map[N][N];\n\nvoid dfs(int i, int j){\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\t\n\tif( i < 0 || i > m+2 || j < 0 || j > n+2 )\n\t\treturn ;\n\tif( map[i][j] == 1 )\n\t\treturn ;\n\t\n\tmap[i][j] = 1;\n\tfor(int k = 0; k < sizeof(ci)/sizeof(*ci); ++k){\n\t\tdfs( i+ci[k], j+cj[k] );\n\t}\n\treturn ;\n}\nvoid printMap(){\n\tfor(int i=0; i<m+2;++i){\n\t\tfor(int j=0;j<n+2;++j){\n\t\t\tcout << map[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n\nint main(){\n\twhile(true){\n\t\tint si, sj;\n\t\tint ans = 1000;\n\t\tint tans = 0;\n\t\t\n\t\tcin>>n>>m;\n\t\tif(m==0&&n==0)break;\n\t\t\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tfor(int j = 0; j < N; ++j){\n\t\t\t\tomap[i][j] = map[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < m+1; ++i){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tfor(int j = 1; j < n+1; ++j){\n\t\t\t\tif( s[j-1] == '.' ){\n\t\t\t\t\tomap[i][j] = map[i][j] = 0;\n\t\t\t\t}else if( s[j-1] == '&'){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tomap[i][j] = map[i][j] = 0;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tomap[i][j] = map[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = si - 1; i >= 0; --i){ if( map[i][sj] == 0 ){ dfs( i, sj ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\t\tfor(int i = si + 1; i <= m+1; ++i){ if( map[i][sj] == 0 ){ dfs( i, sj ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\t\tfor(int j = sj - 1; j >= 0; --j){ if( map[si][j] == 0 ){ dfs( si, j ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\t\tfor(int j = sj + 1; j <= n+1; ++j){ if( map[si][j] == 0 ){ dfs( si, j ); ++tans; } }\n\t\tfor(int i = 0; i < N; ++i )for(int j = 0; j < N; ++j) map[i][j] = omap[i][j];\n\t\tans = min(ans,tans);\n\n\t\tcout << ans-1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nstruct P {\n  int n;\n  int x;\n  int y;\n  bool b;\n\n  P() {\n    P(0,0,0,false);\n  }\n\n  P(int n, int x, int y, bool b): n(n),x(x),y(y),b(b) {}\n\n  bool operator<(const P &obj) const {\n    return n > obj.n;\n  }\n};\n\nchar a[102][102];\nbool u[102][102];\nint w, h;\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\n\nint solve() {\n  P p;\n  priority_queue<P> q;\n  q.push(P(0,0,0, false));\n  int xx, yy, n;\n  for (int i=0; i<=h+1; i++) {\n    for (int j=0; j<=w+1; j++) {\n      u[i][j] = false;\n    }\n  }\n  while (!q.empty()) {\n    p = q.top();\n    q.pop();\n    u[p.y][p.x] = true;\n    if (a[p.y][p.x] == -1) {\n      return p.n;\n    }\n    for (int i=0; i<4; i++) {\n      xx = p.x + dx[i];\n      yy = p.y + dy[i];\n      if (xx < 0 || xx > w+1 || yy < 0 || yy > h+1 || u[yy][xx]) continue;\n      if (!p.b && a[yy][xx]==1) {\n        n = p.n+1;\n      } else {\n        n = p.n;\n      }\n      q.push(P(n, xx, yy, a[yy][xx]==1));\n    }\n  }\n  return -1;\n}\n\nint main() {\n  char buf[105];\n  while (1) {\n    scanf(\"%d %d\\n\", &w, &h);\n    if (!w && !h) break;\n    for (int i=0; i<=h+1; i++) {\n      for (int j=0; j<=w+1; j++) {\n        a[i][j] = false;\n      }\n    }\n    for (int i=0; i<h; i++) {\n      fgets(buf, sizeof(buf), stdin);\n      for (int j=0; j<w; j++) {\n        if (buf[j] == '#') {\n          a[i+1][j+1] = 1;\n        } else if (buf[j] == '.') {\n          a[i+1][j+1] = 0;\n        } else {\n          a[i+1][j+1] = -1;\n        }\n      }\n    }\n\n    printf(\"%d\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// BFS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> P;\n\n\nint main() {\n  int n,m;\n  while(cin >> n >> m,n||m) {\n    int cx, cy;\n    char ba[n+2][m+2];\n    memset(ba, '.', sizeof(ba));\n    for (int y=1; y<=m; ++y) {\n      for (int x=1; x<=n; ++x) {\n        cin >> ba[x][y];\n        if (ba[x][y] == '&') {\n          cx = x;\n          cy = y;\n        }\n      }\n    }\n    int ans[n][m];\n    memset(ans,-1,sizeof(ans));\n    priority_queue<P, vector<P>, greater<P> > Q;\n    Q.push(P(0,pii(0,0)));\n    while(!Q.empty()) {\n      P nwP = Q.top();\n      Q.pop();\n      pii nwp = nwP.second;\n      int x = nwp.first, y = nwp.second;\n      if (ans[x][y] >= 0) continue;\n      //  printf(\"%d,%d\\n\",x,y);\n      ans[x][y] = nwP.first;\n      REP(k,4) {\n        int xx = x+dx[k], yy = y+dy[k];\n        if (ans[xx][yy] >= 0 || xx<0||n<=xx||yy<0||m<=yy) continue;\n        if (ba[x][y] == '#' && ba[xx][yy] != '#') {\n          Q.push(P(nwP.first+1, pii(xx,yy)));\n        } else {\n          Q.push(P(nwP.first, pii(xx,yy)));\n        }\n      }\n    }\n    cout << ans[cx][cy] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF (1<<24)\nusing namespace std;\nint W,H,mini,mini_x,mini_y,ny,nx,cost;\nstring str;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nchar t[102][102];\nbool vd[102][102];\nint u[102][102];\n\nint main(){\n  while(cin>>W>>H){\n    for(int i=0;i<102;i++)for(int j=0;j<102;j++){\n\tt[i][j]='.';\n\tvd[i][j]=false;\n\tu[i][j]=INF;\n      }\n\n    for(int i=1;i<=H;i++){\n      cin>>str;\n      for(int j=1;j<=W;j++){\n\tt[i][j]=str[j-1];\n\tif(t[i][j]=='&')u[i][j]=0;\n      }\n    }\n    /*\n    for(int i=0;i<H+2;i++){\n      for(int j=0;j<W+2;j++){\n\tcout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    \n    while(1){\n      mini=INF;\n      for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++){\n\t  if(mini>u[i][j]&&vd[i][j]==false){\n\t    mini=u[i][j];\n\t    mini_y=i;\n\t    mini_x=j;\n\t  }\n\t}\n      }\n\n      if(mini==INF)break;\n\n      vd[mini_y][mini_x]=true;\n\n      //cout<<mini_y<<' '<<mini_x<<' '<<u[mini_y][mini_x]<<endl;\n\n      \n      if(mini_y==0||mini_x==0||mini_y==H+1||mini_x==W+1){\n\tcout<<u[mini_y][mini_x]<<endl;\n\tbreak;\n      }\n      \n\n      for(int i=0;i<4;i++){\n\tny=mini_y+dy[i];\n\tnx=mini_x+dx[i];\n\n\tcost=((t[mini_y][mini_x]=='#'&&t[ny][nx]!='#')?1:0);\n\n\tif(u[ny][nx]>u[mini_y][mini_x]+cost){\n\t  u[ny][nx]=u[mini_y][mini_x]+cost;\n\t}\n      }\n\t\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\n\nint main(){\n  int h,w;\n  char g[128][128];\n\n  while(scanf(\"%d%d \",&w,&h), w+h){\n    int memo[128][128];\n    int sx, sy;\n\n    memset(memo, -1, sizeof(memo));\n\n    REP(i,h){\n      fgets(g[i], sizeof(g[i]), stdin);\n      REP(j,w) if(g[i][j] == '&'){\n        g[i][j] = '.';\n        sx = j;\n        sy = i;\n      }\n    }\n\n    typedef pair<int, pair<int,int> > data;\n    priority_queue<data,vector<data>,greater<data> > q;\n\n    q.push(mp(0,mp(sx,sy)));\n\n    while(q.size()){\n      int c = q.top().f;\n      int x = q.top().s.f;\n      int y = q.top().s.s;\n\n      //printf(\"%d,%d => %d\\n\",x,y,c);\n\n      q.pop();\n\n      if(memo[y][x] != -1) continue;\n\n      if(!ISIN(x,y,w,h)){\n        print(c);\n        break;\n      }\n\n      memo[y][x] = c;\n\n      REP(i,4){\n        int xx = x + _dx[i];\n        int yy = y + _dy[i];\n\n        if(memo[yy][xx] != -1) continue;\n\n        if(!ISIN(xx,yy,w,h) || g[yy][xx] == '.' || g[yy][xx] == g[y][x])\n          q.push(mp(c,mp(xx,yy)));\n        else\n          q.push(mp(c+1,mp(xx,yy)));\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<vector<char> > VVC;\n\nclass Pox\n{\npublic:\n  P p;\n  int cost;\n  Pox(P p = P(0,0),int cost = 0):p(p),cost(cost){}\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w;\n\nvoid print(VVC G)\n{\n  cout << \"---print---\" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\tcout << G[i][j];\n      cout << endl;\n\n    }\n  cout << endl;\n\n}\n\nvoid draw(VVC& G,P p)\n{\n\n  for(int i=0;i<4;i++)\n    {\n      int nx = p.F + dx[i];\n      int ny = p.S + dy[i];\n      if(!(1<=ny&&ny<=h && 1<=nx&&nx<=w))\n\tcontinue;\n      if(G[ny][nx] == '&' || G[ny][nx] == '#')\n\tcontinue;\n      G[ny][nx] = '&';\n      draw(G,P(nx,ny));\n    }\n  \n}\n\nint main()\n{\n  \n  while(cin >> w >> h,(w||h))\n    {\n    \n      VVC G;\n      P ed;\n      G.resize(h+2);\n      deque<Pox> deq;\n      int mincost[h+3][w+3];\n      for(int i=0;i<=h+1;i++)\n\t{\n\t  G[i].resize(w+2);\n\t  string line;\n\t  if(i == 0 || i == h+1)\n\t    line = string(h+2,'.');\n\t  else\n\t   cin >> line;\n\t   \n\t   \n\t  //cout << \"line = \" << line << endl;\n\t  for(int j=0;j<=w+1;j++)\n\t    {\n\t      mincost[i][j] = (1<<28);\n\t      if(i == 0 || j == 0 || i == h+1 || j == w+1)\n\t\t{\n\t\t  G[i][j] = '.';\n\t\t  deq.push_back(Pox(P(j,i),0));\n\t\t  mincost[i][j] = 0;\n\t \t  continue;\n\t\t}\n\t      G[i][j] = line[j-1];\n\t      if(G[i][j] == '&')\n\t\ted = P(j,i);\n\t    }\n\t}\n\t  \n      //print(G);\n      draw(G,ed);\n      //print(G);     \n\n      int men = (1<<28);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  P p = pox.p;\n\t  int cost = pox.cost;\n\t  //cout << \"p = \" << p.F << \",\" << p.S << \" \" << cost << endl;\n\t  if(G[p.S][p.F] == '&')\n\t    {\n\t      men = min(men,cost);\n\t      break;\n\t    }\n\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx = p.F + dx[i];\n\t      int ny = p.S + dy[i];\n\n\t      if(!(1<=nx&&nx<=w && 1<=ny&&ny<=h))\n\t\t{\n\t\t  //cout <<\"CONTINUE \" << i << \" th\" << endl;\n\t\t  continue;\n\t      \n\t\t}\n\t      int d = 0;\n\t      if(G[ny][nx] == '#')\n\t\t{\n\t\t  //cout << \"# IN!\" << endl;\n\t\t  while(1<=nx&&nx<=w && 1<=ny&&ny<=h && G[ny][nx] == '#')\n\t\t    {\n\t\t      nx += dx[i];\n\t\t      ny += dy[i];\n\t\t    }\n\t\t  d = 1;\n\t\t}\n\t      \n\t      //int d = G[ny][nx] == '#'?1:0;\n\t      if(mincost[ny][nx] > cost + d)\n\t\t{\n\t\t  // cout << \"RENEW = \" << cost +d << endl;\n\t\t  mincost[ny][nx] = cost + d;\n\t\t  if(G[ny][nx] == '&')\n\t\t    {\n\t\t      men = min(men,mincost[ny][nx]);\n\t\t      continue;\n\t\t    }\n\t\t  deq.push_back(Pox(P(nx,ny),mincost[ny][nx]));\n\t\t}\n\t    }\n\n\t}\n      cout << men << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j] = 1000000000;\n\t\t\t\tdist[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H; queue<pair<int, int>>Q;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] >= 2) { continue; }\n\t\t\t\tint dis = dist[cx][cy];\n\t\t\t\tif (X[cx][cy] == 0 && X[ex][ey] == 1) {\n\t\t\t\t\tdis += 1;\n\t\t\t\t}\n\t\t\t\tif (dist[ex][ey]>dis) {\n\t\t\t\t\tdist[ex][ey] = dis;\n\t\t\t\t\tQ.push(make_pair(ex, ey));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> ii;\n\nstruct Node {\n    int c;\n    bool d;\n    vector<int> tos;\n};\n\nconst int INF = 1 << 30;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nint w, h;\nint c[102][102];\nvector<string> ms;\n\nint n;\nvector<Node> ns;\n\nint dijkstra(int s, int t) {\n    for (int i = 1; i <= n; i++) {\n        ns[i].c = INF;\n        ns[i].d = false;\n    }\n    ns[s].c = 0;\n    priority_queue<ii, vector<ii>, greater<ii> > q;\n    q.push(make_pair(0, s));\n    while (!q.empty()) {\n        int i = q.top().second;\n        q.pop();\n        if (ns[i].d) {\n            continue;\n        }\n        ns[i].d = true;\n        if (i == t) {\n            return ns[i].c;\n        }\n        int cost = ns[i].c + 1;\n        for (vector<int>::iterator it = ns[i].tos.begin(); it != ns[i].tos.end(); it++) {\n            if (!ns[*it].d && cost < ns[*it].c) {\n                ns[*it].c = cost;\n                q.push(make_pair(cost, *it));\n            }\n        }\n    }\n    return -1;\n}\n\nvoid fillC(int x, int y, int id) {\n    c[y][x] = id;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (0 <= nx && nx < w+2 && 0 <= ny && ny < h+2 && c[ny][nx] == 0) {\n            if ((id < 0 && ms[ny][nx] == '#') || (id > 0 && (ms[ny][nx] == '.' || ms[ny][nx] == '&'))) {\n                fillC(nx, ny, id);\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> w >> h, w|h) {\n        ms.clear();\n        string s0(w+2, '.');\n        ms.push_back(s0);\n        for (int i = 0; i < h; i++) {\n            string str;\n            cin >> str;\n            ms.push_back(\".\" + str + \".\");\n        }\n        ms.push_back(s0);\n        for (int y = 0; y < h+2; y++) {\n            for (int x = 0; x < w+2; x++) {\n                c[y][x] = 0;\n            }\n        }\n        int id[2] = {0, 0};\n        ii ts;\n        for (int y = 0; y < h+2; y++) {\n            for (int x = 0; x < w+2; x++) {\n                if (ms[y][x] == '&') {\n                    ts.first = y;\n                    ts.second = x;\n                }\n                if (c[y][x] != 0) {\n                    continue;\n                }\n                if (ms[y][x] == '#') {\n                    fillC(x, y, --id[1]);\n                } else {\n                    fillC(x, y, ++id[0]);\n                }\n            }\n        }\n        int e = -id[1];\n        vector<set<int> > es(e+1);\n        for (int y = 1; y < h+2; y++) {\n            for (int x = 1; x < w+2; x++) {\n                int i, v;\n                if (c[y][x] != c[y][x-1]) {\n                    i = min(c[y][x], c[y][x-1]);\n                    v = max(c[y][x], c[y][x-1]);\n                    es[-i].insert(v);\n                }\n                if (c[y][x] != c[y-1][x]) {\n                    i = min(c[y][x], c[y-1][x]);\n                    v = max(c[y][x], c[y-1][x]);\n                    es[-i].insert(v);\n                }\n            }\n        }\n        set<ii> ess;\n        for (int i = 1; i <= e; i++) {\n            for (set<int>::iterator it = es[i].begin(); it != es[i].end(); it++) {\n                for (set<int>::iterator jt = it; jt != es[i].end(); jt++) {\n                    if (*it != *jt) {\n                        ess.insert(make_pair(*it, *jt));\n                    }\n                }\n            }\n        }\n        n = id[0];\n        ns.clear();\n        ns.resize(n+1);\n        for (set<ii>::iterator it = ess.begin(); it != ess.end(); it++) {\n            ns[it->first].tos.push_back(it->second);\n            ns[it->second].tos.push_back(it->first);\n        }\n        cout << dijkstra(1, c[ts.first][ts.second]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\nint memo[110][110];\nchar field[110][110];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nint n, m;\n\nint main(){\n\twhile(cin >> n >> m && (n || m)){\n\t\tfill(&memo[0][0], &memo[109][109] + 1, INF);\n\t\tfill(&field[0][0], &field[109][109] + 1, '.');\n\t\trep(i, m)rep(j, n) cin >> field[j+1][i+1];\n\t\tmemo[0][0] = 0;\n\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\tque.push(PP(0, P(0, 0)));\n\t\twhile(!que.empty()){\n\t\t\t\n\t\t\tPP pp = que.top();\n\t\t\tque.pop();\n\t\t\tint c = pp.first;\n\t\t\tint x = pp.second.first;\n\t\t\tint y = pp.second.second;\n\t\t\tif(c > memo[x][y]) continue;\n\t\t\tif(field[x][y] == '&') {\n\t\t\t\tcout << c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(i, 4){\n\t\t\t\tint x2 = x + dx[i];\n\t\t\t\tint y2 = y + dy[i];\n\t\t\t\tif(0 <= x2 && x2 <= n + 1 && 0 <= y2 && y2 <= m + 1){\n\t\t\t\t\tint cost = 0;\n\t\t\t\t\tif(field[x][y] == '.' && field[x2][y2] == '#') cost = 1;\n\t\t\t\t\tif(memo[x2][y2] > memo[x][y]+ cost){\n\t\t\t\t\t\tmemo[x2][y2] = memo[x][y] + cost;\n\t\t\t\t\n\t\t\t\t\t\tque.push(PP(memo[x2][y2], P(x2, y2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid print(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cout << T[i][j];\n    cout << endl;\n  }\n}\n\nvoid pp(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cerr << M[i][j];\n    cerr << endl;\n  }\n  cerr << endl;\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n\n      if(M[ny][nx] == '#' && T[ny][nx] > s.t+1){\n\tT[ny][nx] = s.t+1;\n\tQ.push(State(nx,ny,s.t+1));\n      }\n\n      if(M[ny][nx] != '#' && T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n  //cerr << ans << endl;\n  //  print();\n  pp();\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    input();\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dx[] = { 0, -1, 0, 1 }, dy[] = { -1, 0, 1, 0 };\n\nint main() {\n\tint n, m, i, j, d, res;\n\twhile (scanf(\"%d%d\", &n, &m) && n + m) {\n\t\tchar cas[128][128];\n\t\tint cnt[128][128];\n\t\trep(i, m)\n\t\t\trep(j, n)\n\t\t\t\tcnt[i][j] = INF;\n\t\trep(i, m)\n\t\t\tscanf(\"%s\", cas[i]);\n\t\tint x, y;\n\t\trep(i, m)\n\t\t\trep(j, n)\n\t\t\t\tif (cas[i][j] == '&') {\n\t\t\t\t\ty = i;\n\t\t\t\t\tx = j;\n\t\t\t\t}\n\t\tcnt[y][x] = 0;\n\t\tcas[y][x] = '.';\n\t\tqueue<pi> q;\n\t\tq.push(make_pair(y, x));\n\t\twhile (!q.empty()) {\n\t\t\tint qsize = (int) q.size();\n\t\t\trep(i, qsize)\n\t\t\t{\n\t\t\t\tpi now = q.front();\n\t\t\t\tq.pop();\n\t\t\t\trep(d, 4)\n\t\t\t\t{\n\t\t\t\t\tint ny = now.Y + dy[d], nx = now.X + dx[d];\n\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= m || nx >= n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint cost =\n\t\t\t\t\t\t\tcnt[now.Y][now.X]\n\t\t\t\t\t\t\t\t\t+ ((cas[ny][nx] == '#'\n\t\t\t\t\t\t\t\t\t\t\t&& cas[now.Y][now.X] != '#') ? 1 : 0);\n\t\t\t\t\tif (cnt[ny][nx] <= cost)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcnt[ny][nx] = cost;\n\t\t\t\t\tq.push(make_pair(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tres = INF;\n\t\trep(i, m)\n\t\t{\n\t\t\tres = min(res, cnt[i][0]);\n\t\t\tres = min(res, cnt[i][n - 1]);\n\t\t}\n\t\trep(i, n)\n\t\t{\n\t\t\tres = min(res, cnt[0][i]);\n\t\t\tres = min(res, cnt[m - 1][i]);\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n \nusing namespace std;\n \n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n \nchar field[128][128];\nint memo[128][128];\nint w, h;\n \nvoid fillup(int y, int x, int num, char c)\n{\n    memo[y][x] = num;\n     \n    const int dy[] = {-1, 0, 0, 1};\n    const int dx[] = {0, 1, -1, 0};\n     \n    rep(i, 4){\n        int py = y + dy[i];\n        int px = x + dx[i];\n        if(py<0 || h<=py || px<0 || w<=px || (memo[py][px] != -2 && memo[py][px] != -1))\n            continue;\n         \n        if(field[py][px] != c)\n            memo[py][px] = -2;\n        else\n            fillup(py, px, num, c);\n    }\n}\n \nint main()\n{\n    while(scanf(\"%d%d\", &w, &h), w){\n        int y, x;\n        rep(i, h){\n            scanf(\"%s\", field[i+1]+1);\n            rep(j, w){\n                if(field[i+1][j+1] == '&'){\n                    y = i + 1;\n                    x = j + 1;\n                    field[y][x] = '.';\n                }\n            }\n        }\n         \n        h += 2;\n        w += 2;\n        fill_n(field[0], w, '.');\n        fill_n(field[h-1], w, '.');\n        rep(i, h)\n            field[i][0] = field[i][w-1] = '.';\n         \n        rep(i, h)\n            fill_n(memo[i], w, -1);\n         \n        memo[y][x] = -2;\n        for(int i=0;; ++i){\n            const char chars[] = {'#', '.'};\n            bool found = false;\n            rep(l, 2){\n                rep(j, h) rep(k, w){\n                    if(field[j][k] == chars[l] && memo[j][k] == -2){\n                        found = true;\n                        fillup(j, k, i, chars[l]);\n                    }\n                }\n            }\n            if(!found)\n                break;\n        }\n        printf(\"%d\\n\", memo[0][0]);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct NODE{\n\tint x,y,c;\n\tNODE(int x,int y,int c):x(x),y(y),c(c){}\n\t\n};\nchar c[102][102];\nint main(){\n\tint H,W;\n\twhile(cin >> W >> H && W){\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i <= H+1 ; i++)\n\t\t\tfor(int j = 0 ; j <= W+1 ; j++)\n\t\t\t\tc[i][j] = '.';\n\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] == '&'){\n\t\t\t\t\tsx = j , sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dx[] = {-1,0,1,0};\n\t\tint dy[] = {0,1,0,-1};\n\t\tdeque<NODE> Q;\n\t\tint memo[102][102] = {} ;\n\t\tQ.push_back(NODE(sx,sy,0));\n\t\tmemo[sy][sx] = 1;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop_front();\n\t\t\tif(q.x == W+1 || q.x == 0 || q.y == H+1 || q.y == 0){\n\t\t\t\tcout << q.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tint tx = q.x + dx[i];\n\t\t\t\tint ty = q.y + dy[i];\n\t\t\t\tif(memo[ty][tx]) continue;\n\t\t\t\tif( c[q.y][q.x] != '#' && c[ty][tx] == '#' ){\n\t\t\t\t\tQ.push_back(NODE(tx,ty,q.c+1));\n\t\t\t\t}else{\n\t\t\t\t\tQ.push_front(NODE(tx,ty,q.c));\n\t\t\t\t}\n\t\t\t\tmemo[ty][tx] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nconst int INF = 1<<30;\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        char mat[m][n];\n        int si, sj;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                cin >> mat[i][j];\n                if(mat[i][j]=='&')  mat[i][j] = '.', si = i, sj = j;\n            }\n        }\n        vector<vector<bool>> visit(m, vector<bool>(n, 0));\n        vector<vector<int>> d(m, vector<int>(n, INF));\n        queue<pair<int,pair<int,int>>> pq;\n        pq.push({0,{si,sj}});\n        while(!pq.empty()){\n            auto p = pq.front();    pq.pop();\n            int cost = p.first, i = p.second.first, j = p.second.second;\n            if(d[i][j] <= cost)   continue;\n            d[i][j] = cost;\n            for(int k = 0; k < 4; k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(!inRange(ni,0,m)||!inRange(nj,0,n))  continue;\n                int ncost = cost + (mat[i][j]=='.'&&mat[ni][nj]=='#');\n                if(d[ni][nj] > ncost)   pq.push({ncost,{ni,nj}});\n            }\n        }\n        int ans = 1<<30;\n        for(int i = 0; i < m; i++)  ans = min({ans, d[i][0], d[i][n-1]});\n        for(int j = 0; j < n; j++)  ans = min({ans, d[0][j], d[m-1][j]});\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n\ntypedef pair<int, int> P;\ntypedef pair <int, pair<int, int> > PP;\n\nconst int INF = 1 << 30;\n\nchar Map[105][105];\nint cost[105][105];\n\nint bfs (P sp, int m, int n )\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\tque.push (PP(0, sp ) );\n\n\twhile (!que.empty() ){\n\t\tPP curr = que.top(); que.pop();\n\t\tint c = curr.first;\n\t\tint cr = curr.second.first, cc = curr.second.second;\n\t\tif (cr == 0 || cr == m || cc == 0 || cc == n )\n\t\t\treturn c;\n\t\tif (cost[cr][cc] > c ) cost[cr][cc] = c;\n\t\telse\n\t\t\tcontinue;\n\t\trep (k, 4 ){\n\t\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\t\tif (Map[cr][cc] == '.' && Map[nr][nc] == '#' ){\n\t\t\t\tque.push (PP(c+1, P (nr, nc ) ) );\n\t\t\t} // end if\n\t\t\telse{\n\t\t\t\tque.push (PP (c, P(nr, nc ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn -1;\n} \n\nint main()\n{\n\tint n, m;\t// n: ¼Ì m: ìkÌ \n\n\twhile (cin >> n >> m && n && m ){\n\t\tmemset (Map, 0, sizeof (Map ) );\n\t\trep (i, m+2 )\n\t\t\trep (j, n+2 )\n\t\t\t\tcost[i][j] = INF;\n\n\t\tP sp;\t// VçtÌÊu\n\n\t\trep (i, m ){\n\t\t\trep (j, n ){\n\t\t\t\tcin >> Map[i][j];\n\t\t\t} // end rep\n\t\t} // end rep\n\t\trep (i, m ){\n\t\t\trep (j, n ){\n\t\t\t\tif (Map[i][j] == '&' ){\n\t\t\t\t\tsp.first = i, sp.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end rep\n\n\t\tint res = bfs (sp, m, n );\n\n\t\tcout << res << endl;\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n >> m && n+m){\n    vector<vector<char>> v(n,vector<char>(m,' '));\n    int x = 0,y = 0;\n    rep(i,m){\n      rep(j,n){\n        cin >> v[j][i];\n        if(v[j][i] == '&'){\n          x = j;\n          y = i;\n        }\n      }\n    }\n    int ans = inf;\n    using pii = pair<int,int>;\n    vector<vector<int>> d(n,vector<int>(m,inf));\n    pii pos = mp(x,y);\n    d[x][y] = 0;\n    queue<pii> q;\n    q.push(pos);\n    while(q.size()){\n      auto Q = q.front();q.pop();\n      int x = Q.fi,y = Q.se;\n      rep(i,4){\n        int nx = Q.fi + dx[i],ny = Q.se + dy[i];\n        if(value(nx,ny,n,m) ){\n          if( d[x][y] + (v[nx][ny] == '#') < d[nx][ny]){\n            q.push(mp(nx,ny));\n            d[nx][ny] = (v[nx][ny] == '#') + d[x][y];\n          }\n        }\n        else{\n          ans = min(ans,d[x][y]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii, vector<Piii>, greater<Piii>> PQ;\n    PQ.push(Piii(0, Pii(sx, sy)));\n    while(!PQ.empty()) {\n      Piii piii = PQ.top(); PQ.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      if(!IN(x, y)) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          PQ.push(Piii(ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j] = 1000000000;\n\t\t\t\tdist[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H; queue<pair<int, int>>Q;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tint dis = dist[cx][cy];\n\t\t\t\tif (X[cx][cy] == 0 && X[ex][ey] == 1) {\n\t\t\t\t\tdis += 1;\n\t\t\t\t}\n\t\t\t\tif (dist[ex][ey]>dis) {\n\t\t\t\t\tdist[ex][ey] = dis;\n\t\t\t\t\tQ.push(make_pair(ex, ey));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,a,n) for(int i=(a);i<(n);++i)\n\n#define INV (-1)\n#define N 102\n#define INFTY (-1)\n#define PLANE 2\n#define MOAT 1\n\nusing namespace std;\n\nint n,m;\nint map[N][N];\nint M[N][N];\n\nbool inline inRange(int t, int min, int max){\n\treturn min <= t && t < max;\n}\n\nvoid dfs(int i, int j, int now){\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\n\tif( M[i][j] != now )\n\t\treturn ;\n\n\tfor(int k = 0; k < sizeof(ci)/sizeof(*ci); ++k){\n\t\tint ti = i + ci[k];\n\t\tint tj = j + cj[k];\n\t\tif( inRange( ti, 1, m+1 ) && inRange( tj, 1, n+1 ) ){\n\t\t\tif( map[i][j] == MOAT && map[ti][tj] == PLANE ){\n\t\t\t\tM[ti][tj] = now + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( M[ti][tj] == now ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tM[ti][tj] = now;\n\t\t\tdfs( ti, tj, now );\n\t\t}\n\t}\n\treturn ;\n}\nvoid ResetMap(){\n\tREP(i,0,N)REP(j,0,N)\n\t{\n\t\tmap[i][j] = PLANE;\n\t\tM[i][j] = INFTY;\n\t}\n}\nvoid PrintMap(){\n\tREP(i,1,m+1){\n\t\tREP(j,1,n+1){\n\t\t\tcout << setw(3) << M[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nbool Completed(int *ans){\n\tREP(i,1,m+1){\n\t\tif( M[i][1] > INFTY ){\n\t\t\t*ans = M[i][1];\n\t\t\treturn true;\n\t\t}\n\t\tif( M[i][n] > INFTY ){\n\t\t\t*ans = M[i][n];\n\t\t\treturn true;\n\t\t}\n\t}\n\tREP(j,1,n+1){\n\t\tif( M[1][j] > INFTY ){\n\t\t\t*ans = M[1][j];\n\t\t\treturn true;\n\t\t}\n\t\tif( M[m][j] > INFTY ){\n\t\t\t*ans = M[m][j];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint now = 0;\n\t\tint ans = 1<<21;\n\t\tint si;\n\t\tint sj;\n\t\t\n\t\tcin>>n>>m;\n\t\tif( m==0&&n==0 )break;\n\t\t\n\t\tResetMap();\n\t\t\n\t\tREP(i,1,m+1){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,1,n+1){\n\t\t\t\tif( s[j-1] == '&' ){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tM[si][sj] = 0;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tmap[i][j] = MOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tREP(i,1,m+1){\n\t\t\t\tREP(j,1,n+1){\n\t\t\t\t\tdfs( i, j, now );\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( Completed(&ans) )\n\t\t\t\tbreak;\n\t\t\telse{\n\t\t\t\t++now;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1e9;\n\nint W, H, my[] = {0, 0, 1, -1}, mx[] = {1, -1, 0, 0};\nvector< vector<char> > v;\n\nint solve(){\n  priority_queue<PP, vector<PP>, greater<PP> > open;\n  open.push(PP(0, P(H - 1, 0)));\n  open.push(PP(0, P(H - 1, 0)));\n  open.push(PP(0, P(0, W - 1)));\n  open.push(PP(0, P(0, W - 1)));\n  FOR(i, 1, H) open.push(PP(0, P(i, 0)));\n  FOR(i, 1, W) open.push(PP(0, P(0, i)));\n  vector< vector<int> > closed(H, vector<int>(W, INF));\n  while(!open.empty()){\n    PP tmp = open.top(); open.pop();\n    int y = tmp.second.first, x = tmp.second.second, cnt = tmp.first;\n    if(closed[y][x] <= cnt) continue;\n    closed[y][x] = cnt;\n    REP(i, 4){\n      int ny = y + my[i], nx = x + mx[i];\n      if(ny >= 0 && nx >= 0 && ny < H && nx < W) open.push(PP((v[y][x] == '#' && v[ny][nx] != '#' ? cnt + 1 : cnt), P(ny, nx)));\n    }\n  }\n  P tar;\n  REP(i, H) REP(j, W) if(v[i][j] == '&') tar = P(i, j);\n  return closed[tar.first][tar.second];\n}\n\nint main() {\n  while(cin >>W >>H && W){\n    v = vector< vector<char> >(H, vector<char>(W));\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    cout <<solve() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 1e9;\nstatic const int dx[] = {1, 0, -1, 0};\nstatic const int dy[] = {0, -1, 0, 1};\n\nvoid solve()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n || m)\n\t{\n\t\tP start;\n\t\tvector< vector<char> > field(m, vector<char>(n));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '&')\n\t\t\t\t{\n\t\t\t\t\tstart.first = j;\n\t\t\t\t\tstart.second = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<P> Que;\n\t\tQue.push(start);\n\t\tqueue<P> wallQue;\n\t\tvector< vector<int> > fieldStep(m, vector<int>(n));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfieldStep[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfieldStep[start.second][start.first] = 0;\n\t\tint cnt = 0;\n\t\twhile (true)\n\t\t{\n\t\t\twhile (!Que.empty())\n\t\t\t{\n\t\t\t\tP cur = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = cur.first + dx[i];\n\t\t\t\t\tnext.second = cur.second + dy[i];\n\t\t\t\t\tif (!(0 <= next.first && next.first < n && 0 <= next.second && next.second < m) || fieldStep[next.second][next.first] != INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (field[next.second][next.first] == '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt + 1;\n\t\t\t\t\t\t\twallQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt;\n\t\t\t\t\t\t\tQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!wallQue.empty())\n\t\t\t{\n\t\t\t\tQue.push(wallQue.front());\n\t\t\t\twallQue.pop();\n\t\t\t}\n\t\t\t++cnt;\n\t\t\tif (Que.empty())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint minv = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tminv = min(minv, fieldStep[0][i]);\n\t\t\tminv = min(minv, fieldStep[m - 1][i]);\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tminv = min(minv, fieldStep[i][0]);\n\t\t\tminv = min(minv, fieldStep[i][n - 1]);\n\t\t}\n\t\tcout << minv << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst int N = 102;\n\nint h, w;\nchar mapData[N][N];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[N][N];\n\nclass State{\npublic:\n  int y, x, cost;\n};\n\nint bfs(){\n  State u, v;\n  u.y = 0;\n  u.x = 0;\n  u.cost = 0;\n  queue<State> Q;\n  Q.push(u);\n  fill(height[0], height[N], INF);\n  height[0][0] = 0;\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    for(int i=0;i<4;i++){\n      v.y = u.y + dy[i];\n      v.x = u.x + dx[i];\n      if(v.y < 0 || v.y >= h) continue;\n      if(v.x < 0 || v.x >= w) continue;\n      v.cost = u.cost;\n      if(mapData[v.y][v.x] == '#') ++v.cost;\n      if(height[v.y][v.x] <= v.cost) continue;\n      height[v.y][v.x] = v.cost;\n      Q.push(v);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    int i = 0, j;\n    for(j=0;j<=w+1;j++){\n      mapData[i][j] = '.';\n    }\n    for(i=1;i<=h;i++){\n      for(j=0;;j++){\n\tif(j == 0){\n\t  mapData[i][j] = '.';\n\t  continue;\n\t}\n\tif(j == w + 1){\n\t  mapData[i][j] = '.';\n\t  break;\n\t}\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    for(j=0;j<=w+1;j++){\n      mapData[i][j] = '.';\n    }\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0},w,h,t,d[101][101];\nstring s[101];\ntypedef pair<int,int> P;\nqueue<P>q;\nvoid dfs(int a,int b,char p){\n  d[a][b]=t;\n  r(i,4){\n    int y=a+dy[i],x=b+dx[i];\n    if(y>=0&&x>=0&&y<h&&x<w){\n      if(d[y][x]==1e9){\n        if(s[a][b]==s[y][x])dfs(y,x,p);\n        else q.push(P(y,x));\n      }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){\n    while(!q.empty())q.pop();\n    r(i,h)r(j,w)d[i][j]=1e9;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)if(s[i][j]=='&'){\n      s[i][j]='.';t=0;\n      dfs(i,j,s[i][j]);\n    }\n    r(i,1e9){\n      if(i%2==0)t++;\n      if(q.empty())break;\n      queue<P>pp;\n      while(!q.empty())pp.push(q.front()),q.pop();\n      while(!pp.empty()){\n        P pt=pp.front();pp.pop();\n        int y=pt.first,x=pt.second;\n        if(d[y][x]==1e9)dfs(y,x,s[y][x]);\n      }\n    }\n    int ans=1e9;\n    r(i,h)ans=min(ans,min(d[i][0],d[i][w-1]));\n    r(i,w)ans=min(ans,min(d[0][i],d[h-1][i]));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint main(){\n  int n, m, i, j, d, res;\n  while(scanf(\"%d%d\", &n, &m) && n+m){\n    char cas[128][128];\n    int cnt[128][128];\n    rep(i, m) rep(j, n) cnt[i][j] = INF;\n    rep(i, m) scanf(\"%s\", cas[i]);\n\n    int x, y;\n    rep(i, m) rep(j, n) if(cas[i][j] == '&'){ y = i; x = j;}\n    cnt[y][x] = 0;\n    cas[y][x] = '.';\n    queue<pi>q;\n    q.push(make_pair(y, x));\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpi now = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", now.Y, now.X);\n\trep(d, 4){\n\t  int ny = now.Y + dy[d], nx = now.X + dx[d];\n\t  if(ny < 0 || nx < 0 || ny >= m || nx >= n) continue;\n\t  int cost = cnt[now.Y][now.X] + ((cas[ny][nx] == '#' && cas[now.Y][now.X] != '#') ? 1 : 0);\n\t  if(cnt[ny][nx] <= cost) continue;\n\t  cnt[ny][nx] = cost;\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n    }\n\n    /*    rep(i, m){\n      rep(j, n) printf(\"%d \", cnt[i][j]); puts(\"\");\n      }*/\n\n    res = INF;\n    rep(i, m){\n      res = min(res, cnt[i][0]);\n      res = min(res, cnt[i][n-1]);\n    }\n    rep(i, n){\n      res = min(res, cnt[0][i]);\n      res = min(res, cnt[m-1][i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nvoid solve(vs& field,int i,int j,vvi& cost)\n{\n\tint h=field.size(),w=field[0].size();\n\t\n\tint di[]={-1,1,0,0};\n\tint dj[]={0,0,-1,1};\n\trep(k,4){\n\t\tint ni=i+di[k],nj=j+dj[k];\n\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\tcontinue;\n\t\tif(field[ni][nj]==field[i][j] && cost[ni][nj]>cost[i][j]){\n\t\t\tcost[ni][nj]=cost[i][j];\n\t\t\tsolve(field,ni,nj,cost);\n\t\t}\n\t}\n\trep(k,4){\n\t\tint ni=i+di[k],nj=j+dj[k];\n\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\tcontinue;\n\t\tif(field[i][j]=='.' && field[ni][nj]=='#' && cost[ni][nj]>cost[i][j]){\n\t\t\tcost[ni][nj]=cost[i][j];\n\t\t\tsolve(field,ni,nj,cost);\n\t\t}\n\t}\n\trep(k,4){\n\t\tint ni=i+di[k],nj=j+dj[k];\n\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\tcontinue;\n\t\tif(field[i][j]=='#' && field[ni][nj]=='.' && cost[ni][nj]>cost[i][j]){\n\t\t\tcost[ni][nj]=cost[i][j]+1;\n\t\t\tsolve(field,ni,nj,cost);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int w,h; cin>>w>>h,w|h;){\n\t\tvs field(h+2);\n\t\tfield[0]=field[h+1]=string(w+2,'.');\n\t\trep(i,h){\n\t\t\tcin>>field[i+1];\n\t\t\tfield[i+1]='.'+field[i+1]+'.';\n\t\t}\n\t\tpii p;\n\t\trep(i,field.size()) rep(j,field[0].size())\n\t\t\tif(field[i][j]=='&'){\n\t\t\t\tp=mp(i,j);\n\t\t\t\tfield[i][j]='.';\n\t\t\t}\n\t\tvvi cost(field.size(),vi(field[0].size(),1<<29));\n\t\tcost[0][0]=0;\n\t\tsolve(field,0,0,cost);\n\t\tcout<<cost[p.first][p.second]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nstruct pos {\n\tint x, y;\n\tint cost;\n\tpos() {}\n\tpos(int x_, int y_, int cost_) {\n\t\tx = x_; y = y_; cost = cost_;\n\t}\n\tbool operator<(const pos p) const {\n\t\treturn cost > p.cost;\n\t}\n};\n\nconst int INF = 1000000;\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n | m) {\n\t\tchar in[128][128];\n\t\tint cost[128][128];\n\t\tfor(int i = 0; i < 128; i++) {\n\t\t\tfor(int j = 0; j < 128; j++) {\n\t\t\t\tin[i][j] = '.';\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%s\", in[i + 1] + 1);\n\t\t\tin[i + 1][n + 1] = '.';\n\t\t}\n\n\t\tpriority_queue<pos> q;\n\t\tfor(int i = 1; i < m + 1; i++) {\n\t\t\tfor(int j = 1; j < n + 1; j++) {\n\t\t\t\tif(in[i][j] == '&') {\n\t\t\t\t\tq.push(pos(j, i, 0));\n\t\t\t\t\ti = m + 1;\n\t\t\t\t\tj = n + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint dx[] = {-1, 1, 0, 0};\n\t\tint dy[] = {0, 0, -1, 1};\n\t\tint ans = -1;\n\t\twhile(!q.empty()) {\n\t\t\tpos p;\n\t\t\tp = q.top(); q.pop();\n\t\t\tif(cost[p.y][p.x] == INF) {\n\t\t\t\tif(p.x <= 0 || n + 1 <= p.x || p.y <= 0 || m + 1 <= p.y) {\n\t\t\t\t\tans = p.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcost[p.y][p.x] = p.cost;\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tif(cost[p.y + dy[i]][p.x + dx[i]] == INF) {\n\t\t\t\t\t\tint c = p.cost;\n\t\t\t\t\t\tif(in[p.y][p.x] == '#' && in[p.y + dy[i]][p.x + dx[i]] == '.') {\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(pos(p.x + dx[i], p.y + dy[i], c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 1; i < m + 1; i++) {\n\t\t\tfor(int j = 1; j < n + 1; j++) {\n\t\t\t\tcout << (cost[i][j] == INF ? in[i][j] : '*');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    int ans = 1<<29;\n    \n    queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.front(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1\n             || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(ncost, Pii(nx, ny)));\n          }\n        } else {\n          ans = min(ans, cost);\n        }\n      }\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint main(){\n  int n, m, i, j, d, res;\n  while(scanf(\"%d%d\", &n, &m) && n+m){\n    char cas[128][128];\n    int cnt[128][128];\n    rep(i, m) rep(j, n) cnt[i][j] = INF;\n    rep(i, m) scanf(\"%s\", cas[i]);\n\n    int x, y;\n    rep(i, m) rep(j, n) if(cas[i][j] == '&'){ y = i; x = j;}\n    cnt[y][x] = 0;\n    queue<pi>q;\n    q.push(make_pair(y, x));\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpi now = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", now.Y, now.X);\n\trep(d, 4){\n\t  int ny = now.Y + dy[d], nx = now.X + dx[d];\n\t  if(ny < 0 || nx < 0 || ny >= m || nx >= n) continue;\n\t  if(cnt[ny][nx] <= cnt[now.Y][now.X]) continue;\n\t  if(cas[ny][nx] == '#'){\n\t    cnt[ny][nx] = cnt[now.Y][now.X] + 1;\n\t  }else{\n\t    cnt[ny][nx] = cnt[now.Y][now.X];\n\t  }\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n    }\n\n    /*    rep(i, m){\n      rep(j, n) printf(\"%d \", cnt[i][j]); puts(\"\");\n      }*/\n\n    res = INF;\n    rep(i, m){\n      if(cas[i][0] != '#') res = min(res, cnt[i][0]);\n      if(cas[i][n-1] != '#') res = min(res, cnt[i][0]);\n    }\n    rep(i, n){\n      if(cas[0][i] != '#') res = min(res, cnt[0][i]);\n      if(cas[m-1][i] != '#') res = min(res, cnt[0][i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//「這い上がる」の定義があいまいなことから、エスパー力が本質っぽい問題だと思う。\n#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint h, w;\nchar data[114][514];\nint dp[552194];\nqueue<P> que;\n\nint dy[4] = {1,0,-1,0};\nint dx[4] = {0,1,0,-1};\nint main(){\n\tint i,j;\n\twhile (cin >> w >> h) {\n\t\tint g;\n\t\tif (!h) break;\n\t\tfor (i = 0; i < h; i++) cin >> data[i];\n\t\tfor (i = 0; i < w*h; i++) dp[i] = 5642194;\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (i == 0 || i == h-1 || j == 0 || j == w-1)\n\t\t\t\t\tque.push(P(0, i*w + j));\n\t\t\t\tif (data[i][j] == '&')\n\t\t\t\t\tg = i * w + j;\n\t\t\t}\n\t\twhile(!que.empty()) {\n\t\t\tint cost = que.front().first;\n\t\t\tint pos = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (dp[pos] <= cost)\n\t\t\t\tcontinue;\n\t\t\tdp[pos] = cost;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tint ny = pos/w + dy[i];\n\t\t\t\tint nx = pos%w + dx[i];\n\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w)\n\t\t\t\t\tcontinue;\n\t\t\t\tque.push( P( cost + (data[ny][nx] != '#' && data[pos/w][pos%w] == '#'), ny*w + nx ) );\n\t\t\t}\n\t\t}\n\t\tcout << dp[g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stack>\n\nusing namespace std;\n\nstruct da{ int x,y; };\n\nint main() {\n\tint x,y,i,j,c,f1,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\tchar d[101][101],g[2]={'.','#'};\n\tda a,b;\n\tstack<da> st[2];\n while(cin >> x >> y) {\n\t if (x==0) break;\n     for (i=0;i<y;i++) cin >> d[i];\n\t c=0; f1=0;\n\t for (i=0;i<y;i++) for (j=0;j<x;j++) if (d[i][j]=='&') {a.x=j; a.y=i; st[0].push(a);}\n\t while(f1==0) {\n\t while(!st[c % 2].empty()) {\n\t\t a=st[c % 2].top(); st[c % 2].pop();\n\t\t if (a.x==0 || a.x==x-1 || a.y==0 || a.y==y-1) { f1=1; continue;}\n\t\t for (i=0;i<4;i++) {\n\t\t\t b.x=a.x+dx[i]; b.y=a.y+dy[i];\n\t\t\t if (d[b.y][b.x]==g[c % 2]) { st[c % 2].push(b); d[b.y][a.x]='&';}\n\t\t\t if (d[b.y][b.x]==g[(c+1) % 2]) { st[(c+1) % 2].push(b); d[b.y][a.x]='&';}\n\t\t }\n\t }\n\t c++;\n\t }\n\t while(!st[c % 2].empty()) st[c % 2].pop();\n\t cout << c/2 << endl;\n }\n return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nchar field[100][101];\nint w,h,memo[100][100];\n\nint main(){\n\tfor(;scanf(\"%d%d\",&w,&h),w;){\n\t\tfor(int i=0;i<h;i++)\tscanf(\"%s\",field[i]);\n\n\t\tint sx,sy;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(field[i][j]=='&')\tsy=i,sx=j,field[i][j]='.';\n\t\t\tmemo[i][j]=1<<30;\n\t\t}\n\n\t\tint ans;\n\t\tmemo[sy][sx]=0;\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(0,mp(sy,sx)));\n\t\twhile(1){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint cost=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tif(x==0 || x==w-1 || y==0 || y==h-1){ ans=cost; break; }\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i],nextcost;\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h){\n\t\t\t\t\tif(field[y][x]=='.' && field[yy][xx]=='#')\tnextcost=cost+1;\n\t\t\t\t\telse\tnextcost=cost;\n\t\t\t\t\tif(nextcost<memo[yy][xx]){\n\t\t\t\t\t\tmemo[yy][xx]=nextcost;\n\t\t\t\t\t\tpq.push(mp(-nextcost,mp(yy,xx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j] = 1000000000;\n\t\t\t\tdist[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H; queue<pair<int, int>>Q;\n\t\tif (W == 0 && H == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] >= 2) { continue; }\n\t\t\t\tint dis = dist[cx][cy];\n\t\t\t\tif (X[cx][cy] == 0 && X[ex][ey] == 1) {\n\t\t\t\t\tdis += 1;\n\t\t\t\t}\n\t\t\t\tif (dist[ex][ey]>dis) {\n\t\t\t\t\tdist[ex][ey] = dis;\n\t\t\t\t\tQ.push(make_pair(ex, ey));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst int N = 102;\n\nint h, w;\nchar mapData[N][N];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[N][N];\n\nvoid dfs(int y, int x, int cost){\n  if(mapData[y][x] == '#') ++ cost;\n  height[y][x] = cost;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(height[ty][tx] <= cost) continue;\n    dfs(ty, tx, cost);\n  }\n}\n\nint solve(){\n  fill(height[0], height[N], INF);\n  dfs(0, 0, 0);\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    int i = 0, j;\n    for(j=0;j<=w+1;j++){\n      mapData[i][j] = '.';\n    }\n    for(i=1;i<=h;i++){\n      for(j=0;;j++){\n\tif(j == 0){\n\t  mapData[i][j] = '.';\n\t  continue;\n\t}\n\tif(j == w + 1){\n\t  mapData[i][j] = '.';\n\t  break;\n\t}\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    for(j=0;j<=w+1;j++){\n      mapData[i][j] = '.';\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint dp[110][110];\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<string>in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tqueue<pip>q;\n\t\tint sx,sy;\n\t\trep(i,110)rep(j,110)dp[i][j]=inf;\n\t\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\t\tif(in[i][j]!='#'){\n\t\t\t\tq.push(pip(i,pii(j,0)));\n\t\t\t\tdp[i][j]=0;\n\t\t\t}else{\n\t\t\t\tq.push(pip(i,pii(j,1)));\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,m)if(in[i][j]=='&')sx=i,sy=j;\n\t\twhile(!q.empty()){\n\t\t\tpip p=q.front();\n\t\t\tq.pop();\n\t\t\tint x=p.first,y=p.second.first,cost=p.second.second;\n//\t\t\tcout<<x<<\" \"<<y<<\" \"<<cost<<endl;\n\t\t\tif(dp[x][y]<cost)continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tint ncost=cost+(in[nx][ny]=='#'?1:0);\n\t\t\t\tif(in[nx][ny]=='#'&&in[x][y]=='#')ncost--;\n//\t\t\t\tcout<<\" \"<<nx<<\" \"<<ny<<\" \"<<ncost<<endl;\n\t\t\t\tif(dp[nx][ny]>ncost){\n\t\t\t\t\tdp[nx][ny]=ncost;\n\t\t\t\t\tq.push(pip(nx,pii(ny,ncost)));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[sx][sy]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define MAX 120\n#define INF 1e9\n\nint H, W;\nchar field[MAX][MAX];\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n\nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nbool check(int y, int x){\n  if(y == 0 || y == H-1) return true;\n  if(x == 0 || x == W-1) return true;\n  return false;\n}\n\nvoid bfs(int y, int x){\n  int ans = INF;\n  int cost[MAX][MAX];\n  fill(cost[0], cost[MAX], INF);\n  queue<int> nowx, nowy;\n  nowx.push(x); nowy.push(y); \n  cost[y][x] = 0;\n\n  while(!nowx.empty()){\n    int xx = nowx.front(); nowx.pop();\n    int yy = nowy.front(); nowy.pop();\n    int cnt = cost[yy][xx];\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = xx + dx[i];\n      int ny = yy + dy[i];\n\n      if(!inField(ny, nx)) continue;\n      if(check(ny, nx)){\n        if(field[yy][xx] != '#' && field[ny][nx] == '#'){\n          cost[ny][nx] = min(cost[ny][nx], cnt+1);\n        }else{\n          cost[ny][nx] = min(cost[ny][nx], cnt);\n        }\n        continue;\n      }\n      int ncnt = cnt;\n      if(field[yy][xx] != '#' && field[ny][nx] == '#') ncnt++;\n      if(ncnt < cost[ny][nx]){\n        cost[ny][nx] = ncnt;\n        nowx.push(nx); nowy.push(ny);\n      }\n    }\n  }\n  for(int i = 0 ; i < H ; i++){\n    ans = min(ans, cost[i][0]);\n    ans = min(ans, cost[i][W-1]);\n  }\n  for(int i = 0 ; i < W ; i++){\n    ans = min(ans, cost[0][i]);\n    ans = min(ans, cost[H-1][i]);\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  int sx, sy;\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == '&'){\n          sx = j; sy = i;\n        }\n      }\n    }  \n    bfs(sy, sx);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-1, 1, 0, 0};\n    int dx[] = {0, 0, 1, -1};\n\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<string> s(h+2);\n        s[0] = s[h+1] = string(w+2, ' ');\n        int y0, x0;\n        for(int i=1; i<=h; ++i){\n            cin >> s[i];\n            s[i] = ' ' + s[i] + ' ';\n            int j = s[i].find('&');\n            if(j != string::npos){\n                y0 = i;\n                x0 = j;\n                s[i][j] = '.';\n            }\n        }\n\n        vector<vector<int> > check(h+2, vector<int>(w+2, INT_MAX));\n        check[y0][x0] = 0;\n        multimap<int, pair<int, int> > mm;\n        mm.insert(make_pair(0, make_pair(y0, x0)));\n        for(;;){\n            int cost = mm.begin()->first;\n            int y = mm.begin()->second.first;\n            int x = mm.begin()->second.second;\n            mm.erase(mm.begin());\n\n            if(s[y][x] == ' '){\n                cout << cost << endl;\n                break;\n            }\n\n            for(int i=0; i<4; ++i){\n                int y1 = y + dy[i];\n                int x1 = x + dx[i];\n                int c = cost;\n                if(s[y][x] == '.' && s[y1][x1] == '#')\n                    ++ c;\n                if(c < check[y1][x1]){\n                    mm.insert(make_pair(c, make_pair(y1, x1)));\n                    check[y1][x1] = c;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii, vector<Piii>, greater<Piii>> PQ;\n    PQ.push(Piii(0, Pii(sx, sy)));\n    while(!PQ.empty()) {\n      Piii piii = PQ.top(); PQ.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      if(!IN(x, y)) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          PQ.push(Piii(ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * ninja.cpp\n *\n *  Created on: 2011/07/28\n *      Author: isa\n */\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <deque>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\n#define MP make_pair\n\nint dx[4] = {0,-1,0,1};\nint dy[4] = {1,0,-1,0};\n\nint main(void){\n\tint n,m;\n\n\twhile(cin >> m && m){\n\t\tcin >> n;\n\t\tchar field[n][m];\n\t\tint step[n][m];\n\t\tbool visited[n][m];\n\t\tstring str;\n\t\tint x,y;\n\t\tdeque<pair<pair<int,int>, int> > q;\n\n\t\tmemset(step, -1, sizeof(step));\n\t\tmemset(visited,false,sizeof(visited));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tfield[i][j] = str[j];\n\t\t\t\tif(str[j] == '&'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpair<int,int> pos;\n\t\tint num;\n\t\tchar pos_type;\n\t\tq.push_back(MP(MP(x,y),0));\n\t\tvisited[x][y] = true;\n\t\twhile(1){\n\t\t\tif(q.empty()){\n\t\t\t\tbool find = false;\n\t\t\t\tfor(int i=0;i<n && !find;i++){\n\t\t\t\t\tfor(int j=0;j<m && !find;j++){\n\t\t\t\t\t\tif(pos_type == '.'){\n\t\t\t\t\t\t\tif(step[i][j] == num+1 && !visited[i][j]){\n\t\t\t\t\t\t\t\tq.push_back(MP(MP(i,j), num+1));\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(step[i][j] == num && !visited[i][j]){\n\t\t\t\t\t\t\t\tq.push_back(MP(MP(i,j), num));\n\t\t\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos = q.front().first;\n\t\t\tx = pos.first;\n\t\t\ty = pos.second;\n\t\t\tnum = q.front().second;\n\t\t\tq.pop_front();\n\n\t\t\tpos_type = field[x][y];\n\n\t\t\tif(x == 0 || x == n-1 || y == 0 || y == m-1){\n\t\t\t\tcout << num << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstep[x][y] = num;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(!visited[x+dx[i]][y+dy[i]]){\n\t\t\t\t\tif(field[x+dx[i]][y+dy[i]] == field[x][y]){\n\t\t\t\t\t\tq.push_back(MP(MP(x+dx[i], y+dy[i]), num));\n\t\t\t\t\t\tvisited[x+dx[i]][y+dy[i]] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(pos_type == '.'){\n\t\t\t\t\t\t\tstep[x+dx[i]][y+dy[i]] = num+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tstep[x+dx[i]][y+dy[i]] = num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint main() {\n\tint x,y,i,j,k,c,f1,f2,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\tchar d[101][101],g[2]={'.','#'};\n while(cin >> x >> y) {\n\t if (x==0) break;\n     for (i=0;i<y;i++) cin >> d[i];\n\t c=0;\n\t while(true) {\n      f1=0; f2=0;\n\t  while (f1+f2==0) {\n\t\t  f1=1;\n\t\t  for (i=0;i<y;i++) for (j=0;j<x;j++) {\n\t\t\t  if (d[i][j]=='&') {\n\t\t\t\t  for (k=0;k<4;k++) {\n\t\t\t\t\t  if (d[i+dy[k]][j+dx[k]]==g[c % 2]) { \n\t\t\t\t\t\t  f1=0; d[i+dy[k]][j+dx[k]]='&';  \n                          if (i+dy[k]==0 || i+dy[k]==y-1 || j+dx[k]==0 || j+dx[k]==x-1) f2=1;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t  }\n\t  }\n       if (f2==1) break;\n\t   c++;\n\t }\n      cout << (c+1)/2 << endl;\n }\n return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long int;\nusing ull = unsigned long long int;\nusing P = pair<int, int>;\nusing P3 = pair<int,P>;\nusing PP = pair<P ,P>;\nconstexpr ll MOD = ll(1e9+7);\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-8;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n\nint d[105][105];\nvector<string> s;\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w){\n        s.resize(h);\n        int si, sj;\n        for(int i=0;i<h;i++){\n            cin >> s[i];\n            for(int j=0;j<w;j++){\n                if(s[i][j] == '&'){\n                    si = i;\n                    sj = j;\n                }\n            }\n        }\n        for(int i=0;i<h;i++){\n            fill(d[i], d[i]+w, IINF);\n        }\n        d[si][sj] = 0;\n        deque<P> que;\n        que.push_back(P(si,sj));\n        while(!que.empty()){\n            P p = que.front();\n            que.pop_front();\n            int i = p.first, j = p.second;\n            for(int k=0;k<4;k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(ni < 0 || ni >= h) continue;\n                if(nj < 0 || nj >= w) continue;\n                if(s[i][j] != '#' && s[ni][nj] == '#'){\n                    if(d[ni][nj] > d[i][j] + 1){\n                        d[ni][nj] = d[i][j] + 1;\n                        que.push_back(P(ni,nj));\n                    }\n                }else{\n                    if(d[ni][nj] > d[i][j]){\n                        d[ni][nj] = d[i][j];\n                        que.push_front(P(ni,nj));\n                    }\n                }\n            }\n        }\n        int ans = IINF;\n        for(int i=0;i<h;i++){\n            ans = min(ans, min(d[i][0], d[i][w-1]));\n        }\n        for(int j=0;j<w;j++){\n            ans = min(ans, min(d[0][j], d[h-1][j]));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0},w,h,t,d[101][101];\nstring s[101];\nvoid dfs(int a,int b,char p){\n  d[a][b]=t;\n  r(i,4){\n    int y=a+dy[i],x=b+dx[i];\n    if(y>=0&&x>=0&&y<h&&x<w)\n      if(d[y][x]==1e9&&s[y][x]==p)dfs(y,x,p);\n  }\n}\nint main(){\n  while(cin>>w>>h,w){\n    r(i,h)r(j,w)d[i][j]=1e9;\n    r(i,h)cin>>s[i];\n    r(i,h)r(j,w)if(s[i][j]=='&'){\n      s[i][j]='.';t=0;\n      dfs(i,j,s[i][j]);\n    }\n    r(o,1000)r(i,h)r(j,w)if(d[i][j]!=1e9)r(k,4){\n      int y=i+dy[k],x=j+dx[k];\n      if(y<0||x<0||y>=h||x>=w)continue;\n      if(s[i][j]==s[y][x])continue;\n      if(s[i][j]=='.')t=d[i][j]+1;\n      else t=d[i][j];\n      if(d[y][x]>t)dfs(y,x,s[i][j]);\n    }\n    int ans=1e9;\n    r(i,h)ans=min(ans,min(d[i][0],d[i][w-1]));\n    r(i,w)ans=min(ans,min(d[0][i],d[h-1][i]));\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nchar mt[110][110];\nint res[110][110];\n\nint main() {\n\tint n,m;\n\twhile(n=in(),m=in()){\n\t\tint i,j;\n\t\tfor(i=0;i<m;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tcin>>mt[i][j];\n\t\t\t\tres[i][j]=1000000000;\n\t\t\t}\n\t\t}\n\t\tint k;\n\t\tfor(k=0;k<n*m;k++){\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(i==0||j==0||i==m-1||j==n-1){\n\t\t\t\t\t\tif(mt[i][j]=='#')res[i][j]=1;\n\t\t\t\t\t\telse res[i][j]=0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint p;\n\t\t\t\t\t\tint xx[]={1,-1,0,0};\n\t\t\t\t\t\tint yy[]={0,0,1,-1};\n\t\t\t\t\t\tfor(p=0;p<4;p++){\n\t\t\t\t\t\t\tif(0<=i+yy[p]&&i+yy[p]<m&&0<=j+xx[p]&&j+xx[p]<n){\n\t\t\t\t\t\t\t\tif(mt[i][j]=='#')chmin(res[i][j],res[i+yy[p]][j+xx[p]]+1);\n\t\t\t\t\t\t\t\telse chmin(res[i][j],res[i+yy[p]][j+xx[p]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(mt[i][j]=='&')cout<<res[i][j]<<endl;\n//cout<<res[i][j];\n\t\t\t}\n//cout<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nstruct Point {\n\tint x;\n\tint y;\n\tint cost;\n\tbool checked;\n};\nbool operator > (const Point& p, const Point& q) { return p.cost > q.cost; }\n\nint main()\n{\n\tint n, m;\n\twhile (true) {\n\t\tstd::cin >> n >> m;\n\t\tif (n==0) break;\n\t\tchar** board = new char*[m+2];\n\t\tfor (int i=0; i<m+2; i++) board[i] = new char[n+2];\n\t\tfor (int i=0; i<m+2; i++) { board[i][0] = board[i][n+1] = '.'; }\n\t\tfor (int j=1; j<m+1; j++) { board[0][j] = board[m+1][j] = '.'; }\n\t\tfor (int i=1; i<=m; i++) {\n\t\t\tfor (int j=1; j<=n; j++) std::cin >> board[i][j];\n\t\t}\n\t\tPoint** points = new Point*[m+2];\n\t\tfor (int i=0; i<m+2; i++) points[i] = new Point[n+2];\n\t\tfor (int i=0; i<m+2; i++) {\n\t\t\tfor (int j=0; j<n+2; j++) {\n\t\t\t\tpoints[i][j].x = i;\n\t\t\t\tpoints[i][j].y = j;\n\t\t\t\tpoints[i][j].cost = m+n;\n\t\t\t\tpoints[i][j].checked = false;\n\t\t\t}\n\t\t}\n\t\tpoints[0][0].cost = 0;\n\t\tstd::priority_queue<Point, std::vector<Point>, std::greater<std::vector<Point>::value_type> > pq;\n\t\tpq.push(points[0][0]);\n\t\twhile (!pq.empty()) {\n\t\t\tPoint p = pq.top(); pq.pop();\n\t\t\t// std::cout << p.x << \" \" << p.y << \" \" << p.cost << \" \" << p.checked << std::endl;\n\t\t\tpoints[p.x][p.y].checked = true;\n\t\t\tchar c = board[p.x][p.y];\n\t\t\tif (c == '&') {\n\t\t\t\tstd::cout << points[p.x][p.y].cost << std::endl; break;\n\t\t\t}\n\t\t\tif (p.x > 0) {\n\t\t\t\tif (!points[p.x-1][p.y].checked) {\n\t\t\t\t\tchar d = board[p.x-1][p.y];\n\t\t\t\t\tint cost = (c == '#' && d != '#') ? 1 : 0;\n\t\t\t\t\tif (points[p.x-1][p.y].cost > points[p.x][p.y].cost + cost) {\n\t\t\t\t\t\tpoints[p.x-1][p.y].cost = points[p.x][p.y].cost + cost;\n\t\t\t\t\t\tpq.push(points[p.x-1][p.y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p.y > 0) {\n\t\t\t\tif (!points[p.x][p.y-1].checked) {\n\t\t\t\t\tchar d = board[p.x][p.y-1];\n\t\t\t\t\tint cost = (c == '#' && d != '#') ? 1 : 0;\n\t\t\t\t\tif (points[p.x][p.y-1].cost > points[p.x][p.y].cost + cost) {\n\t\t\t\t\t\tpoints[p.x][p.y-1].cost = points[p.x][p.y].cost + cost;\n\t\t\t\t\t\tpq.push(points[p.x][p.y-1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p.x < m+1) {\n\t\t\t\tif (!points[p.x+1][p.y].checked) {\n\t\t\t\t\tchar d = board[p.x+1][p.y];\n\t\t\t\t\tint cost = (c == '#' && d != '#') ? 1 : 0;\n\t\t\t\t\tif (points[p.x+1][p.y].cost > points[p.x][p.y].cost + cost) {\n\t\t\t\t\t\tpoints[p.x+1][p.y].cost = points[p.x][p.y].cost + cost;\n\t\t\t\t\t\tpq.push(points[p.x+1][p.y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p.y < n+1) {\n\t\t\t\tif (!points[p.x][p.y+1].checked) {\n\t\t\t\t\tchar d = board[p.x][p.y+1];\n\t\t\t\t\tint cost = (c == '#' && d != '#') ? 1 : 0;\n\t\t\t\t\tif (points[p.x][p.y+1].cost > points[p.x][p.y].cost + cost) {\n\t\t\t\t\t\tpoints[p.x][p.y+1].cost = points[p.x][p.y].cost + cost;\n\t\t\t\t\t\tpq.push(points[p.x][p.y+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0; i<m+2; i++) { delete[] board[i]; delete[] points[i]; }\n\t\tdelete[] board; delete[] points;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing P = pair<int, int>;\n\nint N, M;\nchar field[111][111];\n\nint solve() {\n    int memo[111][111];\n    for (int j = 0; j < M; ++j) { fill(memo[j], memo[j]+N, INF); }\n\n    priority_queue<P> que;\n\n    for (int j = 0; j < M; ++j) {\n        for (int k = 0; k < N; ++k) {\n            if (field[j][k] == '&') {\n                memo[j][k] = 0;\n                que.emplace(0, j*N + k);\n            }\n        }\n    }\n\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int cost = -p.first, x = p.second/N, y = p.second%N;\n\n        if (cost > memo[x][y]) { continue; }\n\n        char st = field[x][y];\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x+dx[d], ny = y+dy[d];\n            if (nx < 0 || M <= nx || ny < 0 || N <= ny) { continue; }\n\n            int next_cost = cost + (st != '#' && field[nx][ny] == '#');\n\n            if (next_cost < memo[nx][ny]) {\n                memo[nx][ny] = next_cost;\n                que.emplace(-next_cost, nx*N+ny);\n            }\n        }\n    }\nint ans = INF;\n    for (int j = 0; j < M; ++j) {\n        ans = min(ans, memo[j][0]);\n        ans = min(ans, memo[j][N-1]);\n    }\n    for (int j = 0; j < N; ++j) {\n        ans = min(ans, memo[0][j]);\n        ans = min(ans, memo[M-1][j]);\n    }\n    return ans;\n}\n\nbool loop() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n    for (int j = 0; j < M; ++j) { cin >> field[j]; }\n\n    cout << solve() << endl;\n\n    return true;\n}\n\nint main() { while (loop()); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; memset(dist, 127, sizeof(dist)); queue<pair<int, int> >Q;\n\t\tmemset(X, 127, sizeof(X));\n\t\tif (W == 0 && H == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c; if (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop(); int cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] <= 1) {\n\t\t\t\t\tint dis = dist[cx][cy] + X[ex][ey];\n\t\t\t\t\tif (dist[ex][ey] > dis) {\n\t\t\t\t\t\tdist[ex][ey] = dis; Q.push(make_pair(ex, ey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tpriority_queue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (d[tx][ty] > st.d + (grid[tx][ty] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[tx][ty] == '#')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n\tint x,y,i,j,c,f1,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\tchar d[101][101],g[2]={'.','#'};\n\tpair<int,int> a,b;\n\tstack<pair<int,int>> st[2];\n while(cin >> x >> y) {\n\t if (x==0) break;\n     for (i=0;i<y;i++) cin >> d[i];\n\t c=0; f1=0;\n\t for (i=0;i<y;i++) for (j=0;j<x;j++) if (d[i][j]=='&') {a.first=j; a.second=i; st[0].push(a);}\n\t while(f1==0) {\n\t while(!st[c % 2].empty()) {\n\t\t a=st[c % 2].top(); st[c % 2].pop();\n\t\t if (a.first==0 || a.first==x-1 || a.second==0 || a.second==y-1) { f1=1; continue;}\n\t\t for (i=0;i<4;i++) {\n\t\t\t b.first=a.first+dx[i]; b.second=a.second+dy[i];\n\t\t\t if (d[b.second][b.first]==g[c % 2]) { st[c % 2].push(b); d[b.second][a.first]='&';}\n\t\t\t if (d[b.second][b.first]==g[(c+1) % 2]) { st[(c+1) % 2].push(b); d[b.second][a.first]='&';}\n\t\t }\n\t }\n\t c++;\n\t }\n\t while(!st[c % 2].empty()) st[c % 2].pop();\n\t cout << c/2 << endl;\n }\n return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-4;\n\nusing namespace std;\n\nint n, m;\nchar g[100][100];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\ntypedef pair<int, int> Q;\ntypedef pair<int, Q> P;\n\nint main()\n{\n\twhile (scanf(\"%d %d\\n\", &n, &m), n | m)\n\t{\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tchar buf[128];\n\t\t\tcin.getline(buf, sizeof(buf));\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tg[i][j] = buf[j];\n\t\t}\n\n\t\tint destY, destX;\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif (g[i][j] == '&')\n\t\t\t\t{\n\t\t\t\t\tdestY = i;\n\t\t\t\t\tdestX = j;\n\t\t\t\t\tg[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool visited[100][100];\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P(0, Q(destX, destY)));\n\t\tvisited[destY][destX] = true;\n\t\tint ans = -1;\n\t\twhile (ans == -1)\n\t\t{\n\t\t\tP v = q.top();\n\t\t\tq.pop();\n\t\t\tint x = v.second.first;\n\t\t\tint y = v.second.second;\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= n || ny >= m)\n\t\t\t\t{\n\t\t\t\t\tans = v.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (visited[ny][nx])\n\t\t\t\t\tcontinue;\n\t\t\t\tint c = v.first;\n\t\t\t\tif (g[y][x] == '.' && g[ny][nx] == '#')\n\t\t\t\t\t++c;\n\t\t\t\tq.push(P(c, Q(nx, ny)));\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint dd[]={1,0,-1,0,1};\n\nVV(char) vv;\nvvint vis;\nvvint tmp;\nint h,w;\nbool foo2(int a,int b){\n\t// cout<<a<<\" \"<<b<<endl;\n\tif(vv[a][b]==' ') return true;\n\tif(vis[a][b]) return false;\n\tif(tmp[a][b]==-1) return false;\n\tif(vv[a][b]=='#'&&tmp[a][b]==0){\n\t\t// vis[a][b]=1;\n\t\ttmp[a][b]=-1;\n\t\treturn false;\n\t}\n\t// if(vv[a][b]=='#') return false;\n\tvis[a][b]=1;\n\tbool ret=false;\n\trep(i,4){\n\t\tret|=foo2(a+dd[i],b+dd[i+1]);\n\t}\n\treturn ret;\n}\nvoid foo3(int a,int b){\n\tif(vv[a][b]!='#') return;\n\ttmp[a][b]=-1;\n\trep(i,4){\n\t\tif(tmp[a+dd[i]][b+dd[i+1]]==-1) continue;\n\t\tfoo3(a+dd[i],b+dd[i+1]);\n\t}\n}\nint foo(int c){\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n\t// rep(i,h+2){\n\t\t// rep(j,w+2){\n\t\t\t// cout<<tmp[i][j];\n\t\t// }\n\t\t// cout<<endl;\n\t// }\n\t// cout<<endl;\n\t// int a;\n\t// cin>>a;\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==1){\n\t\t\t\t// cout<<\"aaa \"<<endl;\n\t\t\t\tif(foo2(i,j)) return c;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==1){\n\t\t\t\ttmp[i][j]=2;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==-1){\n\t\t\t\tfoo3(i,j);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==-1){\n\t\t\t\ttmp[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn foo(c+1);\n}\n\nvoid mainmain(){\n\t// int w,h;\n\twhile(cin>>w>>h,w||h){\n\t\tinitvv(vv,h+2,w+2,' ');\n\t\tinitvv(vis,h+2,w+2,0);\n\t\tinitvv(tmp,h+2,w+2,0);\n\t\treep(i,1,h+1){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\treep(j,1,w+1){\n\t\t\t\tvv[i][j]=s[j-1];\n\t\t\t\tif(vv[i][j]=='&'){\n\t\t\t\t\ttmp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// rep(i,h+2){\n\t\t\t// rep(j,w+2){\n\t\t\t\t// cout<<vv[i][j];\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\tcout<<foo(0)<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[100];\nchar c[]={'#','.'};\nint w,h,p,sum;\nvoid dfs1(int i,int j){\n  if(i==h||j==w||i<0||j<0)return;\n  if(s[i][j]!=',')return;\n  if(i+1<h)if(s[i+1][j]=='#')s[i+1][j]='.';\n  if(i-1>=0)if(s[i-1][j]=='#')s[i-1][j]='.';\n  if(j+1<w)if(s[i][j+1]=='#')s[i][j+1]='.';\n  if(j-1>=0)if(s[i][j-1]=='#')s[i][j-1]='.';\n  dfs1(i+1,j);\n  dfs1(i-1,j);\n  dfs1(i,j+1);\n  dfs1(i,j-1);\n  if(i==h-1||j==w-1||i*j==0)sum=1;\n}\nvoid dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0)return;\n  if(s[i][j]=='#')return;\n  s[i][j]=',';\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j+1);\n  dfs(i,j-1);\n  if(i==h-1||j==w-1||i*j==0)sum=1;\n}\nmain(){int cc=0;\n  while(cin>>w>>h,w){sum=0;\n    r(i,h)cin>>s[i];\n    int su=0;\n    r(i,h)r(j,w){\n      if(s[i][j]=='&'){\n        p=0;\n        dfs(i,j);if(sum)goto L;\n        su++;p=1;\n        dfs(i,j);if(sum)goto L;\n      }\n    }\n        L:cout<<su<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n \nusing namespace std;\n \nint H, W;\nchar grid[110][110];\n \nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n \nint memo[101][101];\n \ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n \nint const INF = 1<<29;\n \nint main() {\n   \n  while(cin >> W >> H && W) {\n     \n    int sx, sy;\n     \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n          grid[i][j] = '.';\n        }\n      }\n    }\n     \n    int ans = 1<<29;\n     \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n     \n    queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.front(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n       \n      if(x == 0 || y == 0 || x == W-1 || y == H-1) {\n        cout << cost << endl;\n        break;\n      }\n       \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[y][x] == '.' && grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1 || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(ncost, Pii(nx, ny)));\n          }\n        }\n      }\n    }\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\n// ------ Class ------ //\nclass Graph2 {\npublic:\n\t// ------ Variables ------ //\n\tstatic const long long INF = 1000000000000000000;\n\tint V, E; vector<vector<pair<int, long long> > > G;\n\n\t// ------ Constructors ------ //\n\tGraph2() : V(0), E(0), G(vector<vector<pair<int, long long> > >()) {}\n\tGraph2(int v) : V(v), E(0), G(vector<vector<pair<int, long long> > >(v)) {}\n\tGraph2(vector<vector<pair<int, long long> > > g) : V(g.size()), G(g) { for (int i = 0; i < g.size(); i++) E += g[i].size(); }\n\n\t// ------ Basic Functions ------ //\n\tint size() { return V; }\n\tvoid add1(int v1, int v2, long long w) { G[v1].push_back(make_pair(v2, w)); E++; }\n\tvoid add2(int v1, int v2, long long w) { add1(v1, v2, w); add1(v2, v1, w); }\n\n\t// ------ Operators ------ //\n\tfriend bool operator==(const Graph2& g1, const Graph2& g2) { return g1.G == g2.G; }\n\tfriend bool operator!=(const Graph2& g1, const Graph2& g2) { return g1.G != g2.G; }\n\tvector<pair<int, long long> > operator[](int x) { return G[x]; }\n\n\t// ------ Algorithms ------ //\n\tvector<long long> dist(int s) {\n\t\tpriority_queue<pair<long long, int> > que; que.push(make_pair(0, s));\n\t\tvector<long long> d(V, INF); d[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<long long, int> t = que.top(); que.pop();\n\t\t\tint u = t.second;\n\t\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\t\tint v = G[u][i].first; long long e = G[u][i].second;\n\t\t\t\tif (d[v] > d[u] + e) {\n\t\t\t\t\td[v] = d[u] + e;\n\t\t\t\t\tque.push(make_pair(-d[v], v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n};\n\n// ------ Main ------ //\nint H, W, g; string s[100];\nint main() {\n\twhile (cin >> W >> H, H) {\n\t\tfor (int i = 0; i < H; i++) cin >> s[i];\n\t\tGraph2 G(H * W + 1);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 1; j < W; j++) {\n\t\t\t\tG.add1(i * H + j - 1, i * H + j, (s[i][j - 1] == '#' && s[i][j] != '#') ? 1 : 0);\n\t\t\t\tG.add1(i * H + j, i * H + j - 1, (s[i][j - 1] != '#' && s[i][j] == '#') ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tG.add1(i * H + j - H, i * H + j, (s[i - 1][j] == '#' && s[i][j] != '#') ? 1 : 0);\n\t\t\t\tG.add1(i * H + j, i * H + j - H, (s[i - 1][j] != '#' && s[i][j] == '#') ? 1 : 0);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (i == 0 || i + 1 == H || j == 0 || j + 1 == W) G.add1(H * W, i * H + j, 0);\n\t\t\t\tif (s[i][j] == '&') g = i * H + j;\n\t\t\t}\n\t\t}\n\t\tcout << G.dist(H * W)[g] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing P = pair<int, int>;\n\nint N, M;\nchar field[111][111];\n\nint solve() {\n    int memo[111][111];\n    for (int j = 0; j < M; ++j) { fill(memo[j], memo[j]+N, INF); }\n\n    priority_queue<P> que;\n\n    for (int j = 0; j < M; ++j) {\n        for (int k = 0; k < N; ++k) {\n            if (field[j][k] == '&') {\n                memo[j][k] = 0;\n                que.emplace(0, j*N + k);\n            }\n        }\n    }\n\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int cost = -p.first, x = p.second/N, y = p.second%N;\n\n        if (cost > memo[x][y]) { continue; }\n\n        char st = field[x][y];\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x+dx[d], ny = y+dy[d];\n            if (nx < 0 || M <= nx || ny < 0 || N <= ny) { continue; }\n\n            int next_cost = cost + (st == '#' && field[nx][ny] == '.');\n\n            if (next_cost < memo[nx][ny]) {\n                memo[nx][ny] = next_cost;\n                que.emplace(-next_cost, nx*N+ny);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < M; ++j) {\n        if (field[j][0] != '#') {\n            ans = min(ans, memo[j][0]);\n        }\n        if (field[j][N-1] != '#') {\n            ans = min(ans, memo[j][N-1]);\n        }\n    }\n    for (int j = 0; j < N; ++j) {\n        if (field[0][j] != '#') {\n            ans = min(ans, memo[0][j]);\n        }\n        if (field[M-1][j] != '#') {\n            ans = min(ans, memo[M-1][j]);\n        }\n    }\n    return ans;\n}\n\nbool loop() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n    for (int j = 0; j < M; ++j) { cin >> field[j]; }\n\n    cout << solve() << endl;\n\n    return true;\n}\n\nint main() { while (loop()); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define mp make_pair\ntypedef pair<int, int> P;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint N, M;\nchar maze[110][110];\nunsigned int minp[110][110];\n\nint main() {\n\tfor(;;) {\n\t\tmemset(minp, -1, sizeof minp);\n\t\tscanf(\" %d %d\", &N, &M);\n\t\tif(!N && !M) break;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tscanf(\" %s\", maze[i]);\n\t\t}\n\n\t\t// P = (x, y)\n\t\t// maze[y][x]\n\t\tqueue<P> que;\n\t\t{\n\t\t\tP put;\n\t\t\tfor(int x = 0; x < N; x++) {\n\t\t\t\tfor(int y = 0; y < M; y++) {\n\t\t\t\t\tif(maze[y][x] == '&') {\n\t\t\t\t\t\tput.first = x;\n\t\t\t\t\t\tput.second = y;\n\t\t\t\t\t\tminp[y][x] = 0;\n\t\t\t\t\t\tmaze[y][x] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.push(put);\n\t\t}\n\t\t;\n\t\twhile(!que.empty()) {\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\n\t\t\t// push\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first] + 1;\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunsigned int minv = INT_MAX;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tminv = min(minv, min(minp[0][i], minp[M - 1][i]));\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tminv = min(minv, min(minp[i][0], minp[N - 1][i]));\n\t\t}\n\t\tprintf(\"%d\\n\", minv);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar field[101][101];\nbool passed[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nqueue<pair<int,int> > *prv;\nqueue<pair<int,int> > *nxt;\nbool ok;\n\nvoid dfs(int y,int x){\n    if(y==h-1||y==0||x==0||x==w-1){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]){\n            passed[ny][nx]=true;\n            // ツ堀ツづ按づァnxtツづ英ushツつオツづ終ツ猟ケ\n            if(field[y][x]!='#'&&field[ny][nx]=='#')\n                nxt->push(make_pair(ny,nx));\n            else\n                dfs(ny,nx);\n            if(ok)return;\n        }\n    }\n}\nint main(){\n    prv=new queue<pair<int,int> >();\n    nxt=new queue<pair<int,int> >();\n    while(cin>>w>>h&&!(h==0&&w==0)){\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        int sy,sx;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n                if(field[i][j]=='&'){\n                    sy=i,sx=j;\n                    field[i][j]='.';\n                }\n            }\n        }\n        prv->push(make_pair(sy,sx));\n        int cnt=0;\n        while(prv->size()){\n            while(prv->size()){\n                pair<int,int> &p=prv->front();\n                passed[p.first][p.second]=true;\n                dfs(p.first,p.second);\n                prv->pop();\n                if(ok)break;\n            }\n            if(ok)break;\n            swap(prv,nxt);\n            cnt++;\n        }\n        cout<<cnt<<endl;\n        while(prv->size())prv->pop();\n        while(nxt->size())nxt->pop();\n    }\n    delete nxt;\n    delete prv;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\ntypedef pair<int,pii>piii;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n///#include<sstream>\n///#include<cstring>\n///#include<stack>\n///#include<complex>\n\nint W,H;\nchar fld[100][101];\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nint solve(){\n    bool done[100][100]={{0}};\n    priority_queue<piii,vector<piii>,greater<piii> >Q;\n    rep(i,H){\n        if(fld[i][0]!='#')Q.push(piii(0,pii(i,0)));\n        if(fld[i][W-1]!='#')Q.push(piii(0,pii(i,W-1)));\n    }\n    rep(j,W){\n        if(fld[0][j]!='#')Q.push(piii(0,pii(0,j)));\n        if(fld[H-1][j]!='#')Q.push(piii(0,pii(H-1,j)));\n    }\n\n    while(!Q.empty()){\n        piii p=Q.top();Q.pop();\n        if(done[p.se.fi][p.se.se])continue;\n        done[p.se.fi][p.se.se]=true;\n        if(fld[p.se.fi][p.se.se]=='&')return p.fi;\n\n        rep(i,4){\n            int ty=p.se.fi+dy[i],tx=p.se.se+dx[i];\n            if(ty<0||ty>=H||tx<0||tx>=W)continue;\n            int tcost=p.fi;\n            if(fld[p.se.fi][p.se.se]=='#'&&fld[ty][tx]!='#')tcost++;\n            Q.push(piii(tcost,pii(ty,tx)));\n        }\n    }\n}\n\nint main(){\n    while(scanf(\"%d%d\",&W,&H),W||H){\n        rep(i,H)scanf(\"%s\",fld[i]);\n        printf(\"%d\\n\",solve());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tvs field(m);\n\t\tpii s;\n\t\tREP(i, m) {\n\t\t\tcin >> field[i];\n\t\t\tREP(j, n) {\n\t\t\t\tif(field[i][j] == '&') {\n\t\t\t\t\ts.first = i;\n\t\t\t\t\ts.second = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pii> Q;\n\t\tQ.push(s);\n\t\tvvi cost(m, vi(n, INF));\n\t\tcost[s.first][s.second] = 0;\n\t\tint ans = INF;\n\t\twhile(!Q.empty()) {\n\t\t\tpii p = Q.front();\n\t\t\tQ.pop();\n\t\t\tint sy = p.first;\n\t\t\tint sx = p.second;\n\t\t\tint sc = cost[sy][sx];\n\n\t\t\tREP(d, 4) {\n\t\t\t\tint ny = sy + dy[d];\n\t\t\t\tint nx = sx + dx[d];\n\t\t\t\tint nc = sc;\n\t\t\t\tif(nx < 0 || n <= nx || ny < 0 || m <= ny) {\n\t\t\t\t\tans = min(ans, sc);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[ny][nx] == '#') {\n\t\t\t\t\tnc++;\n\t\t\t\t}\n\t\t\t\tif(nc < cost[ny][nx]) {\n\t\t\t\t\tcost[ny][nx] = nc;\n\t\t\t\t\tQ.push(make_pair(ny, nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<algorithm>\n#define F first\n#define S second\n#define INF 1<<28\nusing namespace std;\n\nint w, h;\nchar maze[999][999]; //y,x\nint data[999][999]; //y,x\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint bfs(int sy, int sx){\n\n  typedef pair < int, int > P; //y, x\n  queue < P > que;\n  int ans = INF;\n\n  que.push(P(sy, sx));\n  data[sy][sx] = 0;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    int nx = p.S, ny = p.F;\n\n    for(int i=0;i<4;i++){\n      int x = nx + dx[i], y = ny + dy[i];\n\n      if(x < 0 || y < 0 || x == w || y == h){\n\tans = min(ans, data[ny][nx]);\n\tcontinue;\n      }\n\n      if(maze[y][x] == '#' && data[y][x] > data[ny][nx]+1){\n\tdata[y][x] = data[ny][nx]+1;\n\tque.push(P(y,x));\n      }\n\n      else if(maze[y][x] == '.' && data[y][x] > data[ny][nx]){\n\tdata[y][x] = data[ny][nx];\n\tque.push(P(y,x));\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    int sx, sy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> maze[i][j];\n\tdata[i][j] = INF;\n\tif(maze[i][j] == '&') sx = j, sy = i;\n      }\n    }\n\n    cout << bfs(sy, sx) << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\ntypedef vector <string> VS;\ntypedef vector <int> VI;\ntypedef vector <VI> VVI;\n\nconst int inf = 1<<24;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> Node;\ntypedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\n\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n\n        VS lines(m);\n        for ( int i = 0; i < m; i++ ) {\n            cin >> lines[i];\n        }\n        VVI O(m, VI(n, inf));\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                O[i][j] = lines[i][j] == '#' ? 1 : 0;\n            }\n        }\n        int sr, sc;\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( lines[i][j] == '&' ) {\n                    sr = i;\n                    sc = j;\n                }\n            }\n        }\n\n        VVI D(m, VI(n, inf));\n        Queue Q;\n        Node start( 0, PII( sr, sc ) );\n        Q.push( start );\n        D[sr][sc] = 0;\n\n        while ( !Q.empty() ) {\n            Node node = Q.top();\n            Q.pop();\n\n            int cost = node.first;\n            int r = node.second.first;\n            int c = node.second.second;\n\n            if ( r == 0 || r == m-1 || c == 0 || c == n-1 ) {\n                cout << cost << endl;\n                break;\n            }\n\n            for ( int i = 0; i < 4; i++ ) {\n                int nr = r + dr[i];\n                int nc = c + dc[i];\n                if ( nr < 0 || nr >= m || nc < 0 || nc >= n ) continue;\n                int ncost = cost + ( !O[r][c] && O[nr][nc] ? 1 : 0 );\n                if ( ncost >= D[nr][nc] ) continue;\n                D[nr][nc] = ncost;\n                Node nnode( ncost, PII( nr, nc ) );\n                Q.push( nnode );\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\nusing namespace std;\nint main(){\n  int w,h;\n  string line;\n  while(true){\n    cin>>w>>h;\n    if(!w&&!h)\n      break;\n    vector<string> castle;\n    for(int i=0;i<h;i++){\n      cin>>line;\n      castle.push_back(line);\n    }\n    int count[w+2][h+2];\n    int sx,sy;\n    const int MAX = 1000;\n    for(int y=1;y<h+1;y++){\n      for(int x=1;x<w+1;x++){\n\tcount[x][y] = MAX;\n\tif (castle[y-1][x-1]=='&'){\n\t  sx = x;\n\t  sy = y;\n\t  castle[y-1][x-1]='.';\n\t}\n      }\n    }\n    int min = MAX;\n    int dx[4] = {1,0,-1,0};\n    int dy[4] = {0,1,0,-1};\n    count[sx][sy] = 0;\n    stack<int> st;\n    st.push(sy*(w+2)+sx);\n    while(!st.empty()){\n      int x = st.top()%(w+2);\n      int y = st.top()/(w+2);\n      st.pop();\n      char c = castle[y-1][x-1];\n      int n;\n      for(int d=0;d<4;d++){\n\tn = count[x][y];\n\tif(x+dx[d]>0&&y+dy[d]>0&&x+dx[d]<w+1&&y+dy[d]<h+1){\n\t  if(c=='.'&&castle[y+dy[d]-1][x+dx[d]-1]=='#')\n\t    n++;\n\t  if(n<count[x+dx[d]][y+dy[d]]){\n\t    count[x+dx[d]][y+dy[d]] = n;\n\t    st.push((y+dy[d])*(w+2)+x+dx[d]);\n\t  }\n\t}\n\telse{\n\t  if(n<min)\n\t    min = n;\n\t}\n      }\n    }\n    cout<<min<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n || m) {\n\t\tvector<vector<int> > cnt(m, vector<int>(n, INF));\n\t\tvector<string> str(m);\n\t\tREP(i, m) cin >> str[i];\n\t\t\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n\t\tREP(i, m) {\n\t\t\tpq.push(make_pair(str[i][0] == '#', pii(i, 0)));\n\t\t\tpq.push(make_pair(str[i][n - 1] == '#', pii(i, n - 1)));\n\t\t}\n\t\tREP(i, n) {\n\t\t\tpq.push(make_pair(str[0][i] == '#', pii(0, i)));\n\t\t\tpq.push(make_pair(str[m - 1][i] == '#', pii(m - 1, i)));\n\t\t}\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpair<int, pii> now = pq.top();\n\t\t\tpq.pop();\n\t\t\t\n\t\t\tint x = now.second.second, y = now.second.first;\n\t\t\tif (cnt[y][x] != INF) continue;\n\t\t\tcnt[y][x] = now.first;\n\t\t\t\n\t\t\tif (str[y][x] == '&') {\n\t\t\t\tcout << cnt[y][x] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) continue;\n\t\t\t\tpq.push(make_pair(cnt[y][x] + (str[y][x] != '#' && str[ny][nx] == '#'), pii(ny, nx)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n || m) {\n\t\tvector<vector<int> > cnt(m, vector<int>(n, INF));\n\t\tvector<string> str(m);\n\t\tREP(i, m) cin >> str[i];\n\t\t\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n\t\tREP(i, m) {\n\t\t\tpq.push(make_pair(str[i][0] == '#', pii(i, 0)));\n\t\t\tpq.push(make_pair(str[i][n - 1] == '#', pii(i, n - 1)));\n\t\t}\n\t\tREP(i, n) {\n\t\t\tpq.push(make_pair(str[0][i] == '#', pii(0, i)));\n\t\t\tpq.push(make_pair(str[m - 1][i] == '#', pii(m - 1, i)));\n\t\t}\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpair<int, pii> now = pq.top();\n\t\t\tpq.pop();\n\t\t\t\n\t\t\tint x = now.second.second, y = now.second.first;\n\t\t\tif (cnt[y][x] != INF) continue;\n\t\t\tcnt[y][x] = now.first;\n\t\t\t\n\t\t\tint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) continue;\n\t\t\t\tpq.push(make_pair(cnt[y][x] + (str[ny][nx] == '#'), pii(ny, nx)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint gx, gy;\n\t\tREP(i, m) REP(j, n) if (str[i][j] == '&') gx = j, gy = i;\n\t\tcout << cnt[gy][gx] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;//wall dist y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar B[105][105];\nP d[105][105];\npriority_queue<PP>Q;//need finit\n\nvoid Pset(int y,int x)\n{\n\td[y][x]=make_pair(0,0);\n\tQ.push(make_pair(make_pair(0,0),make_pair(y,x)));\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f,sizeof(d));\n\t\tfor(int i=0;i<M;i++)gets(B[i]);\n\t\t\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tif(B[i][0]=='.')Pset(i,0);\n\t\t\tif(B[i][N-1]=='.')Pset(i,N-1);\n\t\t}\n\t\tfor(int i=1;i<N-1;i++)\n\t\t{\n\t\t\tif(B[0][i]=='.')Pset(0,i);\n\t\t\tif(B[M-1][i]=='.')Pset(M-1,i);\n\t\t}\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tP cost=tmp.first;\n\t\t\tif(d[y][x]<cost)continue;\n\t\t\tif(B[y][x]=='&')\n\t\t\t{\n\t\t\t\tres=min(res,cost.first);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif(ny<0||ny>=M||nx<0||nx>=N)continue;\n\t\t\t\tP nc=make_pair(cost.first+(B[y][x]=='#'&&B[ny][nx]!='#'),cost.second+1);\n\t\t\t\tif(nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\td[ny][nx]=nc;\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int src,int dst,int weight):src(src),dst(dst),weight(weight){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid Dijkstra(const Graph& g,int begin,vi& cost,vi& prev)\n{\n\tint size=g.size();\n\tcost.assign(size,INFTY);\n\tprev.assign(size,-1);\n\t\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,begin,0));\n\tcost[begin]=0;\n\twhile(!pq.empty()){\n\t\tEdge e=pq.top();\n\t\tpq.pop();\n\t\tif(prev[e.dst]!=-1)\n\t\t\tcontinue;\n\t\tprev[e.dst]=e.src;\n\t\trep(i,g[e.dst].size()){\n\t\t\tEdge cand=g[e.dst][i]; // candidate\n\t\t\tif(cost[cand.dst]>e.weight+cand.weight){\n\t\t\t\tcost[cand.dst]=e.weight+cand.weight;\n\t\t\t\tpq.push(Edge(cand.src,cand.dst,e.weight+cand.weight));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tfor(int w,h; cin>>w>>h,w|h;){\n\t\tvs field(h+2);\n\t\tfield[0]=field[h+1]=string(w+2,'.');\n\t\trep(i,h){\n\t\t\tcin>>field[i+1];\n\t\t\tfield[i+1]='.'+field[i+1]+'.';\n\t\t}\n\t\th=field.size();w=field[0].size();\n\t\tGraph g(h*w);\n\t\trep(i,h) rep(j,w){\n\t\t\tint di[]={-1,1,0,0};\n\t\t\tint dj[]={0,0,-1,1};\n\t\t\trep(k,4){\n\t\t\t\tint ni=i+di[k],nj=j+dj[k];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj)\n\t\t\t\t\tcontinue;\n\t\t\t\tg[i*w+j].push_back(Edge(i*w+j,ni*w+nj,field[i][j]=='#' && field[ni][nj]!='#'));\n\t\t\t}\n\t\t}\n\t\tvi cost,prev;\n\t\tDijkstra(g,0,cost,prev);\n\t\trep(i,h) rep(j,w)\n\t\t\tif(field[i][j]=='&')\n\t\t\t\tcout<<cost[i*w+j]<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\ndouble h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\trep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\trep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy+1][gx+1]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <set>\nusing namespace std;\n\nconst int SIZE = 102;\nconst int OFFSET = 50;\nconst int dir[ 4 ][ 2 ] = { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } };\n\nint main()\n{\n\tint n, m;\n\n\twhile( cin >> n >> m && ( n || m ) ){\n\t\tint map[ SIZE ][ SIZE ];\n\t\tmemset( map, 0, sizeof(map) );\n\t\tint sx, sy;\n\t\tfor( int i = 1; i < m + 1; ++i ){\n\t\t\tfor( int j = 1; j < n + 1; ++j ){\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif( c == '&' ){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tc = OFFSET + 1;\n\t\t\t\t}\n\t\t\t\tmap[ i ][ j ] = c;\n\t\t\t}\n\t\t}\n\t\tset< pair< int, int > > q;\n\t\tq.insert( make_pair( sx, sy ) );\n\n\t\tint count = OFFSET;\n\t\tbool end = false;\n\t\twhile( !end ){\n\t\t\tset< pair< int, int > > nextq;\n\t\t\t++count;\n\t\t\twhile( !q.empty() ){\n\t\t\t\tpair< int, int > p = *(q.begin());\n\t\t\t\tq.erase( q.begin() );\n\t\t\t\tchar a = count % 2 ? '.' : '#';\n\t\t\t\tchar b = count % 2 ? '#' : '.';\n\n\t\t\t\tfor( int i = 0; i < 4; ++i ){\n\t\t\t\t\tint x = p.first + dir[ i ][ 0 ];\n\t\t\t\t\tint y = p.second + dir[ i ][ 1 ];\n\t\t\t\t\tchar c = map[ y ][ x ];\n\t\t\t\t\tif( c == 0 ){\n\t\t\t\t\t\tend = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif( c == a ){\n\t\t\t\t\t\tmap[ y ][ x ] = count;\n\t\t\t\t\t\tq.insert( make_pair( x, y ) );\n\t\t\t\t\t}\n\t\t\t\t\tif( c == b ){\n\t\t\t\t\t\tmap[ y ][ x ] = count + 1;\n\t\t\t\t\t\tnextq.insert( make_pair( x, y ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( end ) break;\n\t\t\t}\n\t\t\tif( end ) break;\n\t\t\tq = nextq;\n\t\t}\n\t\tcout << ( count - OFFSET ) / 2 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<vector<char> > VVC;\n\nclass Pox\n{\npublic:\n  P p;\n  int cost;\n  Pox(P p = P(0,0),int cost = 0):p(p),cost(cost){}\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w;\n\nvoid print(VVC G)\n{\n  cout << \"---print---\" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\tcout << G[i][j];\n      cout << endl;\n\n    }\n  cout << endl;\n\n}\n\nvoid draw(VVC& G,P p)\n{\n\n  for(int i=0;i<4;i++)\n    {\n      int nx = p.F + dx[i];\n      int ny = p.S + dy[i];\n      if(!(1<=ny&&ny<=h && 1<=nx&&nx<=w))\n\tcontinue;\n      if(G[ny][nx] == '&' || G[ny][nx] == '#')\n\tcontinue;\n      G[ny][nx] = '&';\n      draw(G,P(nx,ny));\n    }\n  \n}\n\nint main()\n{\n  \n  while(cin >> w >> h,(w||h))\n    {\n      VVC G;\n      P ed;\n      G.resize(h+2);\n      deque<Pox> deq;\n      int mincost[h+3][w+3];\n      for(int i=0;i<=h+1;i++)\n\t{\n\t  G[i].resize(w+2);\n\t  string line;\n\t  if(i == 0 || i == h+1)\n\t    line = string(h+2,'.');\n\t  else\n\t    cin >> line;\n\n\t  //cout << \"line = \" << line << endl;\n\t  for(int j=0;j<=w+1;j++)\n\t    {\n\t      mincost[i][j] = (1<<28);\n\t      if(i == 0 || j == 0 || i == h+1 || j == w+1)\n\t\t{\n\t\t  G[i][j] = '.';\n\t\t  deq.push_back(Pox(P(j,i),0));\n\t\t  mincost[i][j] = 0;\n\t \t  continue;\n\t\t}\n\t      G[i][j] = line[j-1];\n\t      if(G[i][j] == '&')\n\t\ted = P(j,i);\n\t    }\n\t}\n\n\n     \n      draw(G,ed);\n     \n      int men = (1<<28);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  P p = pox.p;\n\t  int cost = pox.cost;\n\t  if(G[p.S][p.F] == '&')\n\t    {\n\t      men = min(men,cost);\n\t      break;\n\t    }\n\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx = p.F + dx[i];\n\t      int ny = p.S + dy[i];\n\n\t      if(!(1<=nx&&nx<=w && 1<=ny&&ny<=h))\n\t\tcontinue;\n\n\t      int d = G[ny][nx]=='#'?1:0;\n\t      if(mincost[ny][nx] > cost + d)\n\t\t{\n\t\t  mincost[ny][nx] = cost + d;\n\t\t  deq.push_back(Pox(P(nx,ny),mincost[ny][nx]));\n\t\t}\n\t    }\n\n\t}\n      cout << men << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,a,n) for(int i=(a);i<(n);++i)\n\n#define INV (-1)\n#define N 102\n#define INFTY 1<<30\n#define PLANE 2\n#define MOAT 1\n\nusing namespace std;\n\nstruct Node\n{\n\tint i,j;\n\tint w;\n\tint v;\n\tbool vis;\n};\n\nclass GreaterPNode{\npublic:\n\tbool operator()(const Node *a, const Node *b)const{\n\t\treturn a->w > b->w;\n\t}\n};\n\nint n,m;\nNode map[N][N];\n\nbool inRange(int t, int Min, int Max){\n\treturn Min <= t && t < Max;\n}\n\nint dijkstra(int i, int j, int gi, int gj)\n{\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\tNode* p = &map[i][j];\n\tpriority_queue<Node *, vector<Node *>, GreaterPNode > pq;\n\n\tp->w = 0;\n\tpq.push( p );\n\n\twhile( !pq.empty() ){\n\t\tp = pq.top();\n\t\tpq.pop();\n\n\t\tp->vis=false;\n\t\tif( p->i == gi && p->j == gj )\n\t\t\treturn 1;\n\t\t\n\t\tfor(int k = 0; k < 4; ++k){\n\t\t\tint ti = p->i+ci[k], tj = p->j + cj[k];\n\t\t\tif( inRange( ti,1,m+1) && inRange( tj,1,n+1) ){\n\t\t\t\tint cost = 0;\n\t\t\t\tNode *q = &map[ ti ][ tj ];\n\n\t\t\t\tif( p->v == MOAT && q->v == PLANE ){\n\t\t\t\t\tcost = 1;\n\t\t\t\t}\n\n\t\t\t\tif( !q->vis && q->w > p->w + cost ){\n\t\t\t\t\tq->w = p->w + cost;\n\t\t\t\t\tpq.push( q );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid ResetMap(bool bAll)\n{\n\tREP(i,0,N)REP(j,0,N){\n\t\tmap[i][j].i=i;\n\t\tmap[i][j].j=j;\n\t\tif( bAll ) map[i][j].v=PLANE;\n\t\tmap[i][j].w=INFTY;\n\t\tmap[i][j].vis=false;\n\t}\n}\n\nvoid PrintMap(){\n\tREP(i,1,m+1){\n\t\tREP(j,1,n+1){\n\t\t\tcout << setw(3) << map[i][j].w;\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint gi, gj;\n\t\tint ans = INFTY;\n\t\t\n\t\tcin>>n>>m;\n\t\tif( m==0&&n==0 )break;\n\t\t\n\t\tResetMap( true );\n\t\t\n\t\tREP(i,1,m+1){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,1,n+1){\n\t\t\t\tif( s[j-1] == '&'){\n\t\t\t\t\tgi = i;\n\t\t\t\t\tgj = j;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tmap[i][j].v = MOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i,1,m+1){\n\t\t\tdijkstra(i,1,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tREP(i,1,m+1){\n\t\t\tdijkstra(i,n,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tREP(j,1,n+1){\n\t\t\tdijkstra(1,j,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tREP(j,1,n+1){\n\t\t\tdijkstra(m,j,gi,gj);\n\t\t\tans = min(ans, map[gi][gj].w);\n\t\t\tResetMap( false );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[100];\nchar c[]={'#','.'};\nint w,h,p,sum;\nvoid dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0)return;\n  if(s[i][j]==c[p])return;\n  s[i][j]=c[p];\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j+1);\n  dfs(i,j-1);\n  if(i==h-1||j==w-1||i*j==0)sum=1;\n}\nmain(){int cc=0;\n  while(cin>>w>>h,w){sum=0;\n    r(i,h)cin>>s[i];\n    int su=0;\n    r(i,h)r(j,w){\n      if(s[i][j]=='&'){\n        p=0;\n        dfs(i,j);if(sum)goto L;\n        su++;p=1;\n        dfs(i,j);if(sum)goto L;\n      }\n    }\n        L:cout<<su<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,a,n) for(int i=(a);i<(n);++i)\n\n#define INV (-1)\n#define N 102\n#define INFTY (1<<30)\n#define PLANE 2\n#define MOAT 1\n\nusing namespace std;\n\nint n,m;\nint map[N][N];\nint M[N][N];\n\nbool inline inRange(int t, int min, int max){\n\treturn min <= t && t < max;\n}\n\nvoid dfs(int i, int j, int now){\n\tconst int ci[] = {-1,0,1,0};\n\tconst int cj[] = {0,1,0,-1};\n\n\tif( M[i][j] != now )\n\t\treturn ;\n\n\tfor(int k = 0; k < sizeof(ci)/sizeof(*ci); ++k){\n\t\tint ti = i + ci[k];\n\t\tint tj = j + cj[k];\n\t\tif( inRange( ti, 0, m+2 ) && inRange( tj, 0, n+2 ) ){\n\t\t\tif( map[i][j] == MOAT && map[ti][tj] == PLANE ){\n\t\t\t\tM[ti][tj] = min( M[ti][tj], now + 1 );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( M[ti][tj] == now ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tM[ti][tj] = now;\n\t\t\tdfs( ti, tj, now );\n\t\t}\n\t}\n\treturn ;\n}\nvoid ResetMap(){\n\tREP(i,0,N)REP(j,0,N)\n\t{\n\t\tmap[i][j] = PLANE;\n\t\tM[i][j] = INFTY;\n\t}\n}\nvoid PrintMap(){\n\tREP(i,1,m+1){\n\t\tREP(j,1,n+1){\n\t\t\tcout << setw(3) << M[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\nbool Completed(int *ans){\n\tREP(i,0,m+2){\n\t\tif( M[i][0] < INFTY ){\n\t\t\t*ans = M[i][0];\n\t\t\treturn true;\n\t\t}\n\t\tif( M[i][n+1] < INFTY ){\n\t\t\t*ans = M[i][n+1];\n\t\t\treturn true;\n\t\t}\n\t}\n\tREP(j,0,n+2){\n\t\tif( M[0][j] < INFTY ){\n\t\t\t*ans = M[0][j];\n\t\t\treturn true;\n\t\t}\n\t\tif( M[m+1][j] < INFTY ){\n\t\t\t*ans = M[m+1][j];\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main(){\n\twhile(true){\n\t\tint now = 0;\n\t\tint ans = 1<<21;\n\t\tint si;\n\t\tint sj;\n\t\t\n\t\tcin>>n>>m;\n\t\tif( m==0&&n==0 )break;\n\t\t\n\t\tResetMap();\n\t\t\n\t\tREP(i,1,m+1){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,1,n+1){\n\t\t\t\tif( s[j-1] == '&' ){\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tM[si][sj] = 0;\n\t\t\t\t}else if( s[j-1] == '#' ){\n\t\t\t\t\tmap[i][j] = MOAT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile( true ){\n\t\t\tREP(i,1,m+1){\n\t\t\t\tREP(j,1,n+1){\n\t\t\t\t\tdfs( i, j, now );\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( Completed(&ans) )\n\t\t\t\tbreak;\n\t\t\telse{\n\t\t\t\t++now;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <utility>\n\nusing namespace std;\n\nint INF = 1 << 28;\nint n;\nint m;\nchar map[100][100];\nint visited[100][100];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint ans;\n\nvoid solve(pair<int,int> pos, int c) {\n\n\tint x = pos.first;\n\tint y = pos.second;\n\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\tans = c;\n\t\treturn;\n\t}\n\tif (visited[y][x] <= c)\n\t\treturn;\n\tvisited[y][x] = c;\n\tif (ans <= c) {\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\t\tsolve(make_pair(nx, ny), c + ((map[y][x] == '#') ? 1 : 0));\n\t}\n}\n\nint main(){\n\twhile (1) {\n\t\tans = INF;\n\t\tcin>>n;\n\t\tcin>>m;\n\t\tif ((n | m) == 0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t\tvisited[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint sx = 0;\n\t\tint sy = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\ti = INF;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(make_pair(sx,sy), 0);\n\n\t\tcout <<ans<<\"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nvoid label(vector<vector<char> >& dt, char sdt, vector<vector<int> >& lb, int slb)\n{\n\tint h = dt.size();\n\tint w = dt[0].size();\n\n\tbool flag; // YÓª êÎ[v·é\n\tdo\n\t{\n\t\tflag=false;\n\t\t\n\t\t// O¤ÈOÌSZÉÎµ\n\t\tfor(int i=1; i<h-1; i++)\n\t\t{\n\t\t\tfor(int j=1; j<w-1; j++)\n\t\t\t{\n\t\t\t\t// õ¶ñÅxª¢Ýè\n\t\t\t\tif(dt[i][j]==sdt && lb[i][j]==-1)\n\t\t\t\t{\n\t\t\t\t\t// ×ÚZÉõxª êÎ\n\t\t\t\t\tif(lb[i][j+1]==slb || lb[i+1][j]==slb\n\t\t\t\t\t|| lb[i][j-1]==slb || lb[i-1][j]==slb)\n\t\t\t\t\t{\n\t\t\t\t\t\t// xðÝèµA½tOð§Äé\n\t\t\t\t\t\tlb[i][j] = slb;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(flag);\n\t\n\treturn;\n}\n\nint main()\n{\n\tstringstream ss;\n\t\n\t// üÍ\n\tint wid,hei,tmp,targetX,targetY;\n\twhile(1)\n\t{\n\t\tcin >> wid >> hei;\n\t\tif(wid==0 && hei==0) { break; } // 0 0 ÅI¹\n\t\t\n\t\t// lûðêZ¸ÂgåµÄÌæðmÛ\n\t\twid+=2; hei+=2;\n\t\tvector<vector<char> > map_data(hei,vector<char>(wid));\n\t\tvector<vector<int> > lab_data(hei,vector<int>(wid));\n\t\t\n\t\t// MAPð'.'ÅALabelð0Åú»\n\t\tfor(int i=0; i<hei; i++)\n\t\tfor(int j=0; j<wid; j++)\n\t\t{\n\t\t\tmap_data[i][j] = '.';\n\t\t\tlab_data[i][j] = 0;\n\t\t}\n\n\t\t// f[^ðüÍAxÉ-1ðÝè\n\t\tfor(int i=1; i<hei-1; i++)\n\t\t{\n\t\t\tfor(int j=1; j<wid-1; j++)\n\t\t\t{\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tchar pk=cin.peek();\n\t\t\t\t\tif(pk=='.' || pk=='#')\n\t\t\t\t\t{\n\t\t\t\t\t\tmap_data[i][j] = cin.get();\n\t\t\t\t\t\tlab_data[i][j] = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(pk=='&')\n\t\t\t\t\t{\n\t\t\t\t\t\tmap_data[i][j] = cin.get();\n\t\t\t\t\t\tlab_data[i][j] = -1;\n\t\t\t\t\t\ttargetY = i;\t// S[ÌÀW\n\t\t\t\t\t\ttargetX = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{ cin.ignore(); }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint count = 0;\n\t\twhile(1)\n\t\t{\n\t\t\t// u.¨#¨&vÌ(~è¸ÉÚ®Å«é)²ÆÉxt¯\n\t\t\tlabel(map_data,'.',lab_data,count);\n\t\t\tlabel(map_data,'#',lab_data,count);\n\t\t\tlabel(map_data,'&',lab_data,count);\n\t\t\t// &ÉxªÂ¯çê½çI¹\n\t\t\tif(lab_data[targetY][targetX] != -1)\n\t\t\t{ ss << count << endl; break; }\n\t\t\t\n\t\t\t// countÌ×ÚZÉcount+1ðZbg\n\t\t\tfor(int i=1; i<hei-1; i++)\n\t\t\t{\n\t\t\t\tfor(int j=1; j<wid-1; j++)\n\t\t\t\t{\n\t\t\t\t\t// xª¢Ýè\n\t\t\t\t\tif(lab_data[i][j]==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ×ÚZÉcountª êÎ\n\t\t\t\t\t\tif(lab_data[i][j+1]==count || lab_data[i+1][j]==count\n\t\t\t\t\t\t|| lab_data[i][j-1]==count || lab_data[i-1][j]==count)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// xðÝè·é\n\t\t\t\t\t\t\tlab_data[i][j] = count+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\tcout << ss.str();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\n#define P pair<int,int>\nusing namespace std;\n\nint a, b;\nstring c[100];\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvector<P>V;\nint main() {\n\twhile (cin >> b >> a, a | b) {\n\t\tstring f;\n\t\tfor (int g = 0; g < b + 2; g++)f += \".\";\n\t\tc[0] = c[a + 1] = f;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d + 1] = \".\" + e + \".\";\n\t\t}\n\t\ta+=2; b+=2;\n\t\tfor (int I = 0;; I++) {\n\t\t\tqueue<P>Q;\n\t\t\tQ.push(P(0,0));\n\t\t\tc[0][0] = 0;\n\t\t\tV.push_back(P(0,0));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP t = Q.front(); Q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b) {\n\t\t\t\t\t\tif (c[x][y] == '.') {\n\t\t\t\t\t\t\tV.push_back(P(x, y));\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tQ.push(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '#') {\n\t\t\t\t\t\t\tV.push_back(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '&') {\n\t\t\t\t\t\t\tcout << I << endl;\n\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (P o : V) {\n\t\t\t\tc[o.first][o.second] = '.';\n\t\t\t}\n\t\t\tV.clear();\n\t\t}\n\tl:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M; // N: x, M: y\nint map[102][102];\nbool used[1000][102][102];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        memset(used, 0, sizeof(used));\n        memset(map, 0, sizeof(map));\n\n        FOR(i, 1, M+1){\n            FOR(j, 1, N+1){\n                char c;\n                std::cin >> c;\n                if(c == '.'){map[i][j] = 0;}\n                else if(c == '#'){map[i][j] = -1;}\n                else{map[i][j] = 1;}\n            }\n        }\n    \n        std::priority_queue<State,std::vector<State>,std::greater<State>> q;\n        REP(i, N+2){\n            q.push(mp(0, mp(0, i)));\n            q.push(mp(0, mp(M+1, i)));\n        }\n\n        REP(i, M+2){\n            q.push(mp(0, mp(i, 0)));\n            q.push(mp(0, mp(i, N+1)));\n        }\n\n        int res = -1;\n        while(!q.empty()){\n            State s = q.top(); q.pop();\n            int t = s.first, y = s.second.first, x = s.second.second;\n\n            if(t >= 1000){continue;}\n            if(map[y][x] == 1){res = t; break;}\n            if(used[t][y][x]){continue;}\n\n            used[t][y][x] = true;\n        \n            REP(i, 4){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1 &&\n                   !used[t][ny][nx] && map[ny][nx] != -1){\n                    q.push(mp(t, mp(ny, nx)));\n                }\n            }\n\n            REP(i, 4){\n                int mx = x + dx[i], my = y + dy[i], nx = x + dx[i]*2, ny = y + dy[i]*2;\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1 &&\n                   !used[t+1][ny][nx] && map[ny][nx] != -1 && map[my][mx] == -1){\n                    q.push(mp(t+1, mp(ny, nx)));\n                }\n            }\n        }\n\n        assert(res != -1);\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<n && kx>=0 && kx<m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-10\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long \n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nclass Data{\n\tpublic:\n\tint y;\n\tint x;\n\tint cnt;\n\tbool flg;\n\tData(){}\n\tData(int _y,int _x,int _cnt,bool _flg){\n\t\ty = _y;\n\t\tx = _x;\n\t\tcnt = _cnt;\n\t\tflg = _flg;\n\t}\n\tbool operator<(const Data &a)const{\n\t\treturn cnt >= a.cnt;\n\t}\n};\nint main(){\n\tint w,h;\n\twhile(scanf(\"%d%d\",&w,&h),(w|h)){\n\t\tchar stage[128][128];\n\t\tbool memo[128][128]={{0}};\n\t\trep(i,h+2){\n\t\t\trep(j,w+2){\n\t\t\t\tstage[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",stage[i+1]+1);\n\t\t\tstage[i+1][w+1] = '.';\n\t\t\tstage[i+1][w+2] = '\\0';\n\t\t}\n\t\th += 2;\n\t\tw += 2;\n\t\tint ans = -1;\n\t\tpriority_queue < Data > Q;\n\t\tQ.push(Data(0,0,0,0));\n\t\tmemo[0][0] = 1;\n\t\twhile( !Q.empty() ){\n\t\t\tData d = Q.top();Q.pop();\n\t\t\tif(stage[d.y][d.x] == '&'){\n\t\t\t\tans = d.cnt;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tint ny = d.y + dy[i];\n\t\t\t\tint nx = d.x + dx[i];\n\t\t\t\tif(ny < 0 || ny > h-1 || nx < 0 || nx > w-1 || memo[ny][nx]==1)continue;\n\t\t\t\tmemo[ny][nx]=1;\n\t\t\t\tif(stage[ny][nx] == '#'){\n\t\t\t\t\tif(d.flg == 1)Q.push(Data(ny,nx,d.cnt,1));\n\t\t\t\t\telse Q.push(Data(ny,nx,d.cnt+1,1));\n\t\t\t\t}\n\t\t\t\telse Q.push(Data(ny,nx,d.cnt,0));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nconst int INF = 1000000;\nconst int N = 102;\n\nint h, w;\nchar mapData[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[N][N];\n\nclass State{\npublic:\n  int y, x, cost;\n};\n\nint bfs(){\n  State u, v;\n  u.y = 0;\n  u.x = 0;\n  u.cost = 0;\n  queue<State> Q;\n  Q.push(u);\n  int res = INF;\n  fill(height[0], height[N], INF);\n  height[0][0] = 0;\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n    if(mapData[u.y][u.x] == '&') res = min(res, u.cost);\n    for(int i=0;i<4;i++){\n      v.y = u.y + dy[i];\n      v.x = u.x + dx[i];\n      if(v.y < 0 || v.y >= h) continue;\n      if(v.x < 0 || v.x >= w) continue;\n      v.cost = u.cost;\n      if(mapData[v.y][v.x] == '#') ++v.cost;\n      if(height[v.y][v.x] <= v.cost) continue;\n      height[v.y][v.x] = v.cost;\n      Q.push(v);\n    }\n  }\n  return res;\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tcin >> mapData[i][j];\n      }\n    }\n    h += 2;\n    w += 2;\n    for(int i=0;i<h;i++) mapData[i][0] = '.';\n    for(int i=0;i<h;i++) mapData[i][w-1] = '.';\n    for(int j=0;j<w;j++) mapData[0][j] = '.';\n    for(int j=0;j<w;j++) mapData[h-1][j] = '.';\n    cout << bfs() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef pair<int,int> P;\n\nint main() {\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  \n  int n,m;\n  while(cin >> n >> m,n||m) {\n    char ba[n][m];\n    P castle;\n    REP(y,m) {\n      REP(x,n) {\n        cin >> ba[x][y];\n        if (ba[x][y] == '&')\n          castle = P(x,y);\n      }\n    }\n    int dp[n][m];\n    REP(x,n) {\n      REP(y,m) {\n        if (x == 0 || x == n-1 || y == 0 || y == m-1)\n          dp[x][y] = (ba[x][y] == '#') ? 1 : 0;\n        else\n          dp[x][y] = INF;\n      }\n    }\n    bool update = true;\n    while(update) {\n      update = false;\n      for (int x=1; x<n-1; ++x) {\n        for (int y=1; y<m-1; ++y) {\n          REP(k,4) {\n            int xx = x+dx[k], yy = y+dy[k];\n            if (ba[x][y] == '#') {\n              if (dp[x][y] > dp[xx][yy] + 1) {\n                dp[x][y] = dp[xx][yy] + 1;\n                update = true;\n              }\n            } else {\n              if (dp[x][y] > dp[xx][yy]) {\n                dp[x][y] = dp[xx][yy];\n                update = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << dp[castle.first][castle.second] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<queue>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<int,Pt> P;\n#define fr first\n#define sc second\n#define INF (1 << 26)\n#define rep(i,n) for(int i = 0 ; i < (n) ; i++)\nPt st;\nchar mas[105][105];\nint w,h,d[]={0,1,0,-1};\nbool used[105][105];\nint bfs(){\n  priority_queue< P , vector<P> , greater<P> > que;\n  fill_n(used[0],105*105,false);\n  que.push(P(0,st));\n  used[st.fr][st.sc] = true;\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    rep(i,4){\n      int nx = p.sc.fr + d[i] , ny = p.sc.sc + d[3-i] , pt = p.fr;\n      if(nx < 0 || ny < 0 || nx >= h || ny >= w) return pt;\n      if(used[nx][ny]) continue;\n      if(mas[p.sc.fr][p.sc.sc] == '.' && mas[nx][ny] == '#') pt++;\n      que.push(P(pt,Pt(nx,ny)));\n      used[nx][ny] = true;\n    }\n  }\n}\nint main(){\n  while(cin >> w >> h , w){\n    rep(i,h) rep(j,w){\n      cin >> mas[i][j];\n      if(mas[i][j] == '&') st = Pt(i,j) , mas[i][j] = '.';\n    }\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {-1, 1, 0, 0};\n    int dx[] = {0, 0, 1, -1};\n\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<string> s(h+2);\n        s[0] = s[h+1] = string(w+2, ' ');\n        int y0, x0;\n        for(int i=1; i<=h; ++i){\n            cin >> s[i];\n            s[i] = ' ' + s[i] + ' ';\n            int j = s[i].find('&');\n            if(j != string::npos){\n                y0 = i;\n                x0 = j;\n            }\n        }\n\n        vector<vector<int> > check(h+2, vector<int>(w+2, INT_MAX));\n        check[y0][x0] = 0;\n        multimap<int, pair<int, int> > mm;\n        mm.insert(make_pair(0, make_pair(y0, x0)));\n        for(;;){\n            int cost = mm.begin()->first;\n            int y = mm.begin()->second.first;\n            int x = mm.begin()->second.second;\n            mm.erase(mm.begin());\n\n            if(s[y][x] == ' '){\n                cout << cost << endl;\n                break;\n            }\n\n            for(int i=0; i<4; ++i){\n                int y1 = y + dy[i];\n                int x1 = x + dx[i];\n                int c = cost;\n                if(s[y][x] == '.' && s[y1][x1] == '#')\n                    ++ c;\n                if(c < check[y1][x1]){\n                    mm.insert(make_pair(c, make_pair(y1, x1)));\n                    check[y1][x1] = c;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n\tint x,y,i,j,c,f1,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\tchar d[101][101],g[2]={'.','#'};\n\tpair<int,int> a,b;\n\tstack<pair<int,int>> st[2];\n while(cin >> x >> y) {\n\t if (x==0) break;\n     for (i=0;i<y;i++) cin >> d[i];\n\t c=0; f1=0;\n\t for (i=0;i<y;i++) for (j=0;j<x;j++) if (d[i][j]=='&') {a.first=j; a.second=i; st[0].push(a);}\n\t while(f1==0) {\n\t while(!st[c % 2].empty()) {\n\t\t a=st[c % 2].top(); st[c % 2].pop();\n\t\t if (a.first==0 || a.first==x-1 || a.second==0 || a.second==y-1) { f1=1; continue;}\n\t\t for (i=0;i<4;i++) {\n\t\t\t b.first=a.first+dx[i]; b.second=a.second+dy[i];\n\t\t\t if (d[b.second][b.first]==g[c % 2]) { st[c % 2].push(b); d[b.second][a.first]='&';}\n\t\t\t if (d[b.second][b.first]==g[(c+1) % 2]) { st[(c+1) % 2].push(b); d[b.second][a.first]='&';}\n\t\t }\n\t }\n\t c++;\n\t }\n\t while(!st[c % 2].empty()) st[c % 2].pop();\n\t cout << c/2 << endl;\n }\n return 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\n//0156\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n\nint d[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n    if(x < 0 || x >= w || y < 0 || y >= h) return true;\n    return false;\n}\n\nstring s[110];\n\nint main(){\n    int x, y;\n    int sx, sy;\n    while(cin>>x>>y && x && y){\n        rep(i, y) cin>>s[i];\n        rep(i, y) rep(j, x){\n            if(s[i][j] == '&'){\n                sx = j;\n                sy = i;\n            }\n            d[i][j] = INF;\n        }\n        //cout<<y<<\" \"<<x<<endl;\n        priority_queue<pair<int, pii> > q;\n        q.push(mp(0, mp(sy, sx)));\n        d[sy][sx] = 0;\n        pair<int, pii> p;\n        int ans = INF;\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            //cout<<\" \"<<p.fi<<\" (\"<<p.se.fi<<\", \"<<p.se.fi<<endl;\n            rep(i, 4){\n                int nx = p.se.se + dx[i];\n                int ny = p.se.fi + dy[i];\n                if(isOutOfRange(nx, ny, x, y)){\n                    ans = min(ans, -p.fi);\n                    break;\n                }\n                int c = -p.fi + (s[y][x]!='#'&&s[ny][nx]=='#'?1:0);\n                if(d[ny][nx] <= c) continue;\n                d[ny][nx] = c;\n                q.push(mp(-c, mp(ny, nx)));\n            }\n            if(ans != INF) break;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define ALL(x) (x).begin(),(x).end()\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\" :\"<<x<<endl;\n# define EPS 1e-12\ntemplate<class T> void debug(T a) { for (auto i : a)cout << i << endl; }\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n\n\n\nint main()\n{\n\tint x, y;\n\twhile (cin >> x >> y&&x)\n\t{\n\t\tint a[200][200] = {};\n\t\tint f[200][200];\n\t\tmemset(f, -1, sizeof f);\n\t\tpii s;\n\t\tfor (int i = 1; i <= y; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= x; j++)\n\t\t\t{\n\t\t\t\tchar c; cin >> c;\n\t\t\t\ta[i][j] = c == '#';\n\t\t\t\tif (c == '&')\n\t\t\t\t{\n\t\t\t\t\ts.first = i;\n\t\t\t\t\ts.second = j;\n\t\t\t\t}\n\t\t\t\tf[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tf[s.first][s.second] = 0;\n\t\tqueue<pii> que; que.push(s);\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += dy[i];\n\t\t\t\tnext.second += dx[i];\n\t\t\t\tif (f[next.first][next.second]>f[now.first][now.second]+(a[now.first][now.second]&&!a[next.first][next.second]) )\n\t\t\t\t{\n\t\t\t\t\tf[next.first][next.second] = f[now.first][now.second] + (a[now.first][now.second] && !a[next.first][next.second]);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint ans = INT_MAX;\n\t\tfor (int i = 1; i <= y; i++)ans = min({ ans,f[i][1]+a[i][1],f[i][x]+a[i][x] });\n\t\tfor (int j = 1; j <= x; j++)ans = min({ ans,f[1][j]+a[1][j],f[y][j]+a[y][j] });;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "def ReadMap(n, m):\n  Map = [0] * m\n  for i in range(m):\n    a = raw_input()\n    b = list(a)\n    if a.count('&')>0:\n      j = a.index('&')\n      PosCas = [j, i]\n      b[j] = '.'\n    Map[i] = b\n  return Map, PosCas\n\ndef fill(SP, c1, c2):\n  for x, y in SP:\n    try:\n      if Map[y][x] != c1:continue\n    except: continue\n    if x in [0, n-1] or y in [0, m-1]: return 1\n    Map[y][x] = c2\n    SP += [[x+1, y], [x-1, y], [x, y+1], [x, y-1]]\n  return 0\n\nwhile 1:\n  n, m = map(int, raw_input().split())\n  if n == m == 0: break\n  Map, PosCas = ReadMap(n, m)\n  c = 0\n  while 1:\n    SP = [PosCas]\n    if fill(SP, '.', '#'): break\n    c += 1\n    if fill(SP, '#', '.'): break\n  print c"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M; // N: x, M: y\nint map[102][102];\nbool used[1000][102][102];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        memset(used, 0, sizeof(used));\n        memset(map, 0, sizeof(map));\n\n        FOR(i, 1, M+1){\n            FOR(j, 1, N+1){\n                char c;\n                std::cin >> c;\n                if(c == '.'){map[i][j] = 0;}\n                else if(c == '#'){map[i][j] = -1;}\n                else{map[i][j] = 1;}\n            }\n        }\n    \n        std::priority_queue<State,std::vector<State>,std::greater<State>> q;\n        REP(i, N+2){\n            q.push(mp(0, mp(0, i)));\n            q.push(mp(0, mp(M+1, i)));\n        }\n\n        REP(i, M+2){\n            q.push(mp(0, mp(i, 0)));\n            q.push(mp(0, mp(i, N+1)));\n        }\n\n        int res = -1;\n        while(!q.empty()){\n            State s = q.top(); q.pop();\n            int t = s.first, y = s.second.first, x = s.second.second;\n\n            if(t >= 1000){continue;}\n            if(map[y][x] == 1){res = t; break;}\n            if(used[t][y][x]){continue;}\n\n            used[t][y][x] = true;\n        \n            REP(i, 4){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1){\n                    if(map[y][x] == 0 && map[ny][nx] == -1){\n                        if(!used[t+1][ny][nx]){\n                            q.push(mp(t+1, mp(ny, nx)));\n                        }\n                    }else{\n                        q.push(mp(t, mp(ny, nx)));\n                    }\n                }\n            }\n        }\n\n        assert(res != -1);\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n \nusing namespace std;\n \nint H, W;\nchar grid[110][110];\n \nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n \nint memo[101][101];\n \ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n \nint const INF = 1<<29;\n \nint main() {\n   \n  while(cin >> W >> H && W) {\n     \n    int sx, sy;\n     \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n     \n    int ans = 1<<29;\n     \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n     \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n       \n      bool ok = 0;\n       \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + ((grid[y][x] == '.' || grid[y][x] == '&') && grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1 || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(-ncost, Pii(nx, ny)));\n          }\n        }\n        else {\n          cout << cost << endl;\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) break;\n    }\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define EPS 1e-10\n#define PB push_back\n#define fi first\n#define se second\n#define ll long long \n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\nclass Data{\n\tpublic:\n\tint y;\n\tint x;\n\tint cnt;\n\tData(){}\n\tData(int _y,int _x,int _cnt){\n\t\ty = _y;\n\t\tx = _x;\n\t\tcnt = _cnt;\n\t}\n\tbool operator<(const Data &a)const{\n\t\tif(cnt != a.cnt)return cnt > a.cnt;\n\t\treturn y > a.y;\n\t}\n};\nint main(){\n\tint w,h;\n\twhile(scanf(\"%d%d\",&w,&h),w){\n\t\tchar stage[128][128];\n\t\tbool memo[128][128]={{0}};\n\t\trep(i,h+2){\n\t\t\trep(j,w+2){\n\t\t\t\tstage[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\tscanf(\"%s\",stage[i+1]+1);\n\t\t\tstage[i+1][w+1] = '.';\n\t\t\tstage[i+1][w+2] = '\\0';\n\t\t}\n\t\th += 2;\n\t\tw += 2;\n\t\tint ans = -1;\n\t\tpriority_queue < Data > Q;\n\t\tQ.push(Data(0,0,0));\n\t\tmemo[0][0] = 1;\n\t\twhile( !Q.empty() ){\n\t\t\tData d = Q.top();Q.pop();\n\t\t\tif(stage[d.y][d.x] == '&'){\n\t\t\t\tans = d.cnt;\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tint ny = d.y + dy[i];\n\t\t\t\tint nx = d.x + dx[i];\n\t\t\t\tif(ny < 0 || ny > h-1 || nx < 0 || nx > w-1 || memo[ny][nx]==1)continue;\n\t\t\t\tmemo[ny][nx]=1;\n\t\t\t\tif(stage[ny][nx] == '#')Q.push(Data(ny,nx,d.cnt+1));\n\t\t\t\telse Q.push(Data(ny,nx,d.cnt));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.front(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1\n             || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(ncost, Pii(nx, ny)));\n          }\n        } else {\n          ans = min(ans, cost);\n        }\n      }\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;//wall y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar A[105][105],B[105][105];\nint d[105][105];\npriority_queue<PP>Q;//need finit\n\nvoid Pset(int y,int x)\n{\n\td[y][x]=0;\n\tQ.push(make_pair(0,make_pair(y,x)));\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f,sizeof(d));\n\t\tfor(int i=0;i<=M+1;i++)for(int j=0;j<=N+1;j++)B[i][j]='.';\n\t\tfor(int i=0;i<M;i++)gets(B[i+1]+1);\n\t\tfor(int i=0;i<=M+1;i++){B[i][N+1]='.';B[i][N+2]=0;}\n\t\tN++;M++;\n\t\tQ.push(make_pair(0,make_pair(0,0)));\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tint cost=tmp.first;\n\t\t\tif(d[y][x]<=cost)continue;\n\t\t\tif(B[y][x]=='&')\n\t\t\t{\n\t\t\t\tres=min(res,cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif(ny<0||ny>M||nx<0||nx>N)continue;\n\t\t\t\tint nc=cost+(B[y][x]=='#'&&B[ny][nx]!='#');\n\t\t\t\tif(nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\td[ny][nx]=nc;\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[100];\nchar c[]={'#','.'};\nint a,b,p1,p2,dx[]={1,-1,0,0},dy[]={0,0-1,1};\nint dfs(int y,int x){\n  int sum=0;\n  s[y][x]=c[p1];\n  if(y==0||x==0||y==a-1||x==b-1)return 1;\n  r(i,4)if(x+dx[i]>=0&&dx[i]+x<b&&y+dy[i]>=0&&dy[i]+y<a)\n    if(s[y+dy[i]][x+dx[i]]==c[p2])sum=dfs(y+dy[i],x+dx[i]);\n  return sum;\n}\nmain(){\n  while(cin>>a>>b,a){\n    r(i,a)cin>>s[i];\n    int su=0;\n    r(i,a)r(j,b){\n      if(s[i][j]=='&'){\n        p1=0;p2=1;\n        if(dfs(i,j))goto L;\n        p1=1;p2=0;\n        su++;\n        if(dfs(i,j))goto L;\n      }\n    }\n    L:cout<<su<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nchar str[102][102];\nint bfs[102][102];\nint v[102][102];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++)\n\t\t\t\tstr[i][j]='.';\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s\",str[i+1]+1);\n\t\t}\n\t\tfor(int i=0;i<102;i++)\n\t\t\tfor(int j=0;j<102;j++){\n\t\t\t\tbfs[i][j]=-1;\n\t\t\t\tv[i][j]=0;\n\t\t\t}\n\t\tbfs[0][0]=0;\n\t\tdeque<pair<int,int> > Q;\n\t\tQ.push_back(make_pair(0,0));\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop_front();\n\t\t\tif(v[row][col])continue;\n\t\t\tv[row][col]=1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<102&&0<=col+dy[i]&&col+dy[i]<102){\n\t\t\t\t\tif((!~bfs[row+dx[i]][col+dy[i]])||(bfs[row+dx[i]][col+dy[i]]>bfs[row][col]+(((str[row][col]=='#')&&(str[row+dx[i]][col+dy[i]]!='#'))?1:0))){\n\t\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col]+(((str[row][col]=='#')&&(str[row+dx[i]][col+dy[i]]!='#'))?1:0);\n\t\t\t\t\t\tif((str[row][col]=='#')&&(str[row+dx[i]][col+dy[i]]!='#')){\n\t\t\t\t\t\t\tQ.push_back(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t\t}else Q.push_front(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<102;i++){\n\t\t\tfor(int j=0;j<102;j++){\n\t\t\t\tif(str[i][j]=='&')printf(\"%d\\n\",bfs[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<int,Pt> P;\n#define fr first\n#define sc second\n#define INF (1 << 30)\n#define FOR(i,b,n) for(int i = (b) ; i < (n) ; ++i )\n#define rep(i,n) FOR(i,0,n)\nchar mas[105][105];\nint w,h,d[]={0,1,0,-1};\nint used[105][105];\nint bfs(){\n  int ans = INF;\n  queue<P> que;\n  fill_n(used[0],105*105,INF);\n  que.push(P(0,Pt(0,0)));\n  used[0][0] = 0;\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    if(mas[p.sc.fr][p.sc.sc] == '&'){\n      ans = min(ans,p.fr);\n      continue;\n    }\n    rep(i,4){\n      int nx = p.sc.fr + d[i] , ny = p.sc.sc + d[3-i] , pt = p.fr;\n      if(!(nx>=0&&nx<h+2&&ny>=0&&ny<w+2)) continue;\n      if(mas[nx][ny] == '#') pt++;\n      if(used[nx][ny] > pt){\n        que.push(P(pt,Pt(nx,ny)));\n        used[nx][ny] = pt;\n      }\n    }\n  }\n  return ans;\n}\nint main(){\n  rep(i,102) mas[0][i] = '.';\n  while(cin >> w >> h , w){\n    FOR(i,1,h+1){\n      mas[i][0] = mas[i][w+1] = '.';\n      FOR(j,1,w+1) cin >> mas[i][j];\n    }\n    rep(i,w+2) mas[h+1][i] = '.';\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint main(){\n  int n, m, i, j, d, res;\n  while(scanf(\"%d%d\", &n, &m) && n+m){\n    char cas[128][128];\n    int cnt[128][128];\n    rep(i, m) rep(j, n) cnt[i][j] = INF;\n    rep(i, m) scanf(\"%s\", cas[i]);\n\n    int x, y;\n    rep(i, m) rep(j, n) if(cas[i][j] == '&'){ y = i; x = j;}\n    cnt[y][x] = 0;\n    queue<pi>q;\n    q.push(make_pair(y, x));\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpi now = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", now.Y, now.X);\n\trep(d, 4){\n\t  int ny = now.Y + dy[d], nx = now.X + dx[d];\n\t  if(ny < 0 || nx < 0 || ny >= m || nx >= n) continue;\n\t  if(cnt[ny][nx] <= cnt[now.Y][now.X]) continue;\n\t  if(cas[ny][nx] == '#'){\n\t    cnt[ny][nx] = cnt[now.Y][now.X] + 1;\n\t  }else{\n\t    cnt[ny][nx] = cnt[now.Y][now.X];\n\t  }\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n    }\n    res = 0;\n    rep(i, m){\n      if(cas[i][0] != '#') res = max(res, cnt[i][0]);\n      if(cas[i][n-1] != '#') res = max(res, cnt[i][0]);\n    }\n    rep(i, n){\n      if(cas[0][i] != '#') res = max(res, cnt[0][i]);\n      if(cas[m-1][i] != '#') res = max(res, cnt[0][i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <queue>\nusing namespace std;\n\n#define loop(i, n) for (int i = 0; i < n; i++)\n\ntypedef pair<int, int> i_i;\nbool dfs(int x, int y, char a, char b, \n        vector<vector<char> > &g);\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint h, w;\n\nint main()\n{\n    while (cin >> w >> h, (w|h)) {\n        vector<vector<char> > g(h, vector<char>(w));\n        int sx, sy, cnt = 0;\n        loop(i, h) {\n            loop(j, w) {\n                cin >> g[i][j];\n                if (g[i][j] == '&') {\n                    sx = i;\n                    sy = j;\n                    g[i][j] = '.';\n                }\n            }\n        }\n        while (!dfs(sx, sy, '.', '#', g)) {\n            cnt++;\n            dfs(sx, sy, '#', '.', g);\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}\n\nbool dfs(int x, int y, char a, char b, \n        vector<vector<char> > &g) {\n    bool ret = false;\n    g[x][y] = b;\n    for (int i = 0; i < 4; i++) {\n        if (x+dx[i] < 0 || y+dy[i] < 0 || \n            h <= x+dx[i] || w <= y+dy[i] ) {\n            return true;\n        }\n        if (g[x+dx[i]][y+dy[i]] == a) {\n            ret = dfs(x+dx[i], y+dy[i], a, b, g);\n        }\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint a[100][100],p,w,h;\nint fn(int x,int y){\n  if(0){\n  }else if(a[x][y]==-2){\n    a[x][y]=p+1;\n  }else if(a[x][y]==-1){\n    if(x==0||x==w-1||y==0||y==h-1)\n      return 1;\n    a[x][y]=p;\n    if(fn(x-1,y)||fn(x,y-1)||fn(x+1,y)||fn(x,y+1))\n      return 1;\n  }\n  return 0;\n}\nint fm(int x,int y){\n  if(0){\n  }else if(a[x][y]==-2){\n    if(x==0||x==w-1||y==0||y==h-1)\n      return 1;\n    a[x][y]=p;\n    if(fm(x-1,y)||fm(x,y-1)||fm(x+1,y)||fm(x,y+1))\n      return 1;\n  }\n  return 0;\n}\nint main(){\n  int i,j,k;\n  char c;\n  while(cin>>w>>h&&w+h){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin>>c;\n\tif(0){\n\t}else if(c=='#'){\n\t  a[j][i]=-2;\n\t}else if(c=='.'){\n\t  a[j][i]=-1;\n\t}else if(c=='&'){\n\t  a[j][i]=0;\n\t}\n      }\n    }\n    for(p=0;;){\n      for(j=0;j<h;j++){\n\tfor(k=0;k<w;k++){\n\t  if(a[k][j]==p){\n\t    if(k==0||k==w-1||j==0||j==h-1)\n\t      break;\n\t    if(fn(k-1,j)||fn(k,j-1)||fn(k+1,j)||fn(k,j+1))\n\t      break;\n\t  }\n\t}\n\tif(k!=w)\n\t  break;\n      }\n      if(j!=h)\n\tbreak;\n      p++;\n      for(j=0;j<h;j++){\n\tfor(k=0;k<w;k++){\n\t  if(a[k][j]==p){\n\t    if(k==0||k==w-1||j==0||j==h-1)\n\t      break;\n\t    if(fm(k-1,j)||fm(k,j-1)||fm(k+1,j)||fm(k,j+1))\n\t      break;\n\t  }\n\t}\n\tif(k!=w)\n\t  break;\n      }\n      if(j!=h)\n\tbreak;\n    }\n    cout<<p<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst int INF = 1 << 30;\nint dy[] = {-1, 0, 0, 1};\nint dx[] = {0, -1, 1, 0};\nint n, m;\nstring c[110];\n\nvoid solve() {\n  c[0] = c[m + 1] = string(n + 2, '.');\n  for (int i = 1; i <= m; i++) {\n    cin >> c[i];\n    c[i] = \".\" + c[i] + \".\";\n  }\n  n += 2, m += 2;\n  int dis[110][110];\n  fill_n((int*)dis, 110 * 110, INF);\n  dis[0][0] = 0;\n  deque<pii> deq = {{0, 0}};\n  while (!deq.empty()) {\n    int y, x;\n    tie(y, x) = deq.front(); deq.pop_front();\n    if (c[y][x] == '&') {\n      cout << dis[y][x] << endl;\n      return;\n    }\n    for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i], nx = x + dx[i];\n      if (ny >= 0 && ny < m && nx >= 0 && nx < n) {\n        int cost = (c[y][x] == '.' && c[ny][nx] == '#');\n        if (dis[ny][nx] > dis[y][x] + cost) {\n          dis[ny][nx] = dis[y][x] + cost;\n          if (cost) deq.emplace_back(ny, nx);\n          else deq.emplace_front(ny, nx);\n        }\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> n >> m, n) {\n    solve();\n  }  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<int,Pt> P;\n#define fr first\n#define sc second\n#define FOR(i,b,n) for(int i = (b) ; i < (n) ; ++i )\n#define rep(i,n) FOR(i,0,n)\nchar mas[105][105];\nint w,h,d[]={0,1,0,-1};\nbool used[105][105];\nint bfs(){\n  priority_queue< P , vector<P> , greater<P> > que;\n  fill_n(used[0],105*105,false);\n  que.push(P(0,Pt(0,0)));\n  used[0][0] = true;\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    if(mas[p.sc.fr][p.sc.sc] == '&') return p.fr;\n    rep(i,4){\n      int nx = p.sc.fr + d[i] , ny = p.sc.sc + d[3-i] , pt = p.fr;\n      if(nx>=0&&nx<h+2&&ny>=0&&ny<w+2&&!used[nx][ny]){\n        if(mas[nx][ny] == '#') pt++;\n        que.push(P(pt,Pt(nx,ny)));\n        used[nx][ny] = true;\n      }\n    }\n  }\n}\nint main(){\n  rep(i,102) mas[0][i] = '.';\n  while(cin >> w >> h , w){\n    FOR(i,1,h+1){\n      mas[i][0] = mas[i][w+1] = '.';\n      FOR(j,1,w+1) cin >> mas[i][j];\n    }\n    rep(i,w+2) mas[h+1][i] = '.';\n    cout << bfs() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint h, w;\nchar mapData[100][100];\nbool visited[100][100];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[100][100];\nint p;\n\nvoid dfs(int y, int x){\n  height[y][x] = p;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(height[ty][tx] == p && visited[ty][tx]) continue;\n    if(height[ty][tx] < p) continue;\n    visited[ty][tx] = true;\n    dfs(ty, tx);\n  }\n}\n\nint solve(){\n  fill(height[0], height[100], INF);\n  int cnt;\n  for(int j=0;j<w;j++){//top to bottom\n    cnt = 0;\n    for(int i=0;i<h;i++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//left to right\n    cnt = 0;\n    for(int j=w-1;j>=0;j--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int j=0;j<w;j++){//bottom to top\n    cnt = 0;\n    for(int i=h-1;i>=0;i--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\t\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//right to left\n    cnt = 0;\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  fill(visited[0], visited[100], false);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#' || visited[i][j]) continue;\n      p = height[i][j];\n      dfs(i, j);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    cout << solve() << endl;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << setw(2) << height[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int b[][100],int x,int y,int m,int n,int c){\n  int mn=100;\n  if(x==0||x==m-1||y==0||y==n-1){\n    if(a[x][y])\n      return c+1;\n    else\n      return c;\n  }\n  if(b[x][y]==-1){\n    if(a[x][y])\n      b[x][y]=c+1;\n    else{\n      b[x][y]=c;\n      int tmp;\n      if((tmp=f(a,b,x-1,y,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x,y-1,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x+1,y,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x,y+1,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if(mn!=100)\n\treturn mn;\n    }\n  }\n  return -1;\n}\nint main(){\n  int i,j,k;\n  int a[100][100],b[100][100],mn,x,y,m,n;\n  string s;\n  for(;;){\n    cin>>m>>n;\n    if(m+n==0)\n      break;\n    memset(a,0,sizeof(a));\n    memset(b,-1,sizeof(b));\n    for(i=0;i<n;i++){\n      cin>>s;\n      for(j=0;j<m;j++){\n\tif(s[j]=='#')\n\t  a[j][i]=1;\n\telse if(s[j]=='&'){\n\t  x=j;\n\t  y=i;\n\t  b[x][y]=0;\n\t}\n      }\n    }\n    for(i=0;;i++){\n      mn=100;\n      for(j=0;j<m;j++){\n\tfor(k=0;k<n;k++){\n\t  if(b[j][k]==i){\n\t    int tmp;\n\t    if((tmp=f(a,b,j-1,k,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if((tmp=f(a,b,j,k-1,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if((tmp=f(a,b,j+1,k,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if((tmp=f(a,b,j,k+1,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t  }\n\t}\n      }\n      if(mn!=100)\n\tbreak;\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nstring grid[100];\nint dis[100][100];\n\nvoid dfs(int y, int x, int mode){\n  int dx[] = {0,0,1,-1}, dy[] = {1,-1,0,0};\n  for(int i=0;i<4;i++){\n    int sx = x + dx[i], sy = y+dy[i];\n    if(sx<0 || sy<0 || m<=sy || n<=sx)continue;\n    if(mode){\n      if(dis[sy][sx] < 0){\n\tif(grid[sy][sx] == '#'){\n\t  dis[sy][sx] = dis[y][x];\n\t  dfs(sy,sx,mode);\n\t}\n\tif(grid[sy][sx] == '.')dis[sy][sx] = dis[y][x];\n      }\n    }else{\n      if(dis[sy][sx] < 0){\n\tif(grid[sy][sx] == '.'){\n\t  dis[sy][sx] = dis[y][x];\n\t  dfs(sy,sx,mode);\n\t}\n\tif(grid[sy][sx] == '#')dis[sy][sx] = dis[y][x] + 1;\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin >> n >> m;\n    if(!n && !m)break;\n\n    for(int i=0;i<m;i++)cin >> grid[i];\n    \n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tdis[i][j] = -1;\n    \n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(grid[i][j] == '&'){\n\t  dis[i][j] = 0;\n\t  grid[i][j] = '.';\n\t}\n    \n    int cnt = 0;\n    while(1){\n      bool f = false;\n      for(int i=0;i<m;i++)\n\tfor(int j=0;j<n;j++)\n\t  if(dis[i][j] == cnt && grid[i][j] == '.'){\n\t    dfs(i,j,0);\n\t    f = true;\n\t  }\n      \n      cnt++;\n\n      for(int i=0;i<m;i++)\n\tfor(int j=0;j<n;j++)\n\t  if(dis[i][j] == cnt && grid[i][j] == '#'){\n\t    dfs(i,j,1);\n\t    f = true;\n\t  }\n      if(!f)break;\n    }\n    \n    int ans = 10000;\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(!i || !j || i==m-1 || j==n-1)ans = min(ans,dis[i][j]);\n    \n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n\ntypedef pair<int, int> P;\ntypedef pair <int, pair<int, int> > PP;\n\nconst int INF = 1 << 30;\n\nchar Map[105][105];\nint cost[105][105];\n\nint bfs (P sp, int m, int n )\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\tque.push (PP(0, sp ) );\n\n\twhile (!que.empty() ){\n\t\tPP curr = que.top(); que.pop();\n\t\tint c = curr.first;\n\t\tint cr = curr.second.first, cc = curr.second.second;\n\t\tif (cr == 0 || cr == m+1 || cc == 0 || cc == n+1 )\n\t\t\treturn c;\n\t\tif (cost[cr][cc] > c ) cost[cr][cc] = c;\n\t\telse\n\t\t\tcontinue;\n\t\trep (k, 4 ){\n\t\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\t\tif (Map[cr][cc] == '.' && Map[nr][nc] == '#' ){\n\t\t\t\tque.push (PP(c+1, P (nr, nc ) ) );\n\t\t\t} // end if\n\t\t\telse{\n\t\t\t\tque.push (PP (c, P(nr, nc ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn 0;\n} \n\nint main()\n{\n\tint n, m;\t// n: ¼Ì m: ìkÌ \n\n\twhile (cin >> n >> m && n && m ){\n\t\tmemset (Map, 0, sizeof (Map ) );\n\t\trep (i, m+2 )\n\t\t\trep (j, n+2 )\n\t\t\t\tcost[i][j] = INF;\n\n\t\tP sp;\t// VçtÌÊu\n\n\t\trep (i, m ){\n\t\t\trep (j, n ){\n\t\t\t\tcin >> Map[i][j];\n\t\t\t} // end rep\n\t\t} // end rep\n\t\trep (i, m ){\n\t\t\trep (j, n ){\n\t\t\t\tif (Map[i][j] == '&' ){\n\t\t\t\t\tsp.first = i, sp.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end rep\n\n\t\tint res = bfs (sp, m, n );\n\n\t\tcout << res << endl;\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1e9;\n\nint W, H, my[] = {0, 0, 1, -1}, mx[] = {1, -1, 0, 0};\nvector< vector<char> > v;\n\nint solve(){\n  priority_queue<PP, vector<PP>, greater<PP> > open;\n  open.push(PP(0, P(0, 0)));\n  vector< vector<int> > closed(H, vector<int>(W, INF));\n  while(!open.empty()){\n    PP tmp = open.top(); open.pop();\n    int y = tmp.second.first, x = tmp.second.second, cnt = tmp.first;\n    if(closed[y][x] <= cnt) continue;\n    closed[y][x] = cnt;\n    REP(i, 4){\n      int ny = y + my[i], nx = x + mx[i];\n      if(ny >= 0 && nx >= 0 && ny < H && nx < W) open.push(PP((v[y][x] == '#' && v[ny][nx] != '#' ? cnt + 1 : cnt), P(ny, nx)));\n    }\n  }\n  P tar;\n  REP(i, H) REP(j, W) if(v[i][j] == '&') tar = P(i, j);\n  return closed[tar.first][tar.second];\n}\n\nint main() {\n  while(cin >>W >>H && W){\n    H += 2; W += 2;\n    v = vector< vector<char> >(H, vector<char>(W, '.'));\n    FOR(i, 1, H - 1) FOR(j, 1, W - 1) cin >>v[i][j];\n    cout <<solve() <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\n#define INF 1<<28\nusing namespace std;\n\nint w, h;\nchar maze[999][999]; //y,x\nint data[999][999]; //y,x\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint bfs(int sy, int sx){\n\n  typedef pair < int, int > P; //y, x\n  queue < P > que;\n  int ans = INF;\n\n  que.push(P(sy, sx));\n  data[sy][sx] = 0;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    int nx = p.S, ny = p.F;\n\n    for(int i=0;i<4;i++){\n      int x = nx + dx[i], y = ny + dy[i];\n\n      if(x < 0 || y < 0 || x == w || y == h){\n\tans = min(ans, data[ny][nx]);\n\tcontinue;\n      }\n\n      if(maze[y][x] == '#' && data[y][x] > data[ny][nx]+1){\n\tdata[y][x] = data[ny][nx]+1;\n\tque.push(P(y,x));\n      }\n\n      else if(maze[y][x] == '.' && data[y][x] > data[ny][nx]){\n\tdata[y][x] = data[ny][nx];\n\tque.push(P(y,x));\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    int sx, sy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> maze[i][j];\n\tdata[i][j] = INF;\n\tif(maze[i][j] == '&') sx = j, sy = i;\n      }\n    }\n\n    cout << bfs(sy, sx) << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<vector<char> > VVC;\n\nclass Pox\n{\npublic:\n  P p;\n  int cost;\n  Pox(P p = P(0,0),int cost = 0):p(p),cost(cost){}\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w;\n\nvoid print(VVC G)\n{\n  cout << \"---print---\" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\tcout << G[i][j];\n      cout << endl;\n\n    }\n  cout << endl;\n\n}\n\nvoid draw(VVC& G,P p)\n{\n\n  for(int i=0;i<4;i++)\n    {\n      int nx = p.F + dx[i];\n      int ny = p.S + dy[i];\n      if(!(1<=ny&&ny<=h && 1<=nx&&nx<=w))\n\tcontinue;\n      if(G[ny][nx] == '&' || G[ny][nx] == '#')\n\tcontinue;\n      G[ny][nx] = '&';\n      draw(G,P(nx,ny));\n    }\n  \n}\n\nint main()\n{\n  \n  while(cin >> w >> h,(w||h))\n    {\n      VVC G;\n      P ed;\n      G.resize(h+2);\n      deque<Pox> deq;\n      int mincost[h+3][w+3];\n      for(int i=0;i<=h+1;i++)\n\t{\n\t  G[i].resize(w+2);\n\t  string line;\n\t  if(i == 0 || i == h+1)\n\t    line = string(h+2,'.');\n\t  else\n\t    cin >> line;\n\n\t  //cout << \"line = \" << line << endl;\n\t  for(int j=0;j<=w+1;j++)\n\t    {\n\t      mincost[i][j] = (1<<28);\n\t      if(i == 0 || j == 0 || i == h+1 || j == w+1)\n\t\t{\n\t\t  G[i][j] = '.';\n\t\t  deq.push_back(Pox(P(j,i),0));\n\t\t  mincost[i][j] = 0;\n\t \t  continue;\n\t\t}\n\t      G[i][j] = line[j-1];\n\t      if(G[i][j] == '&')\n\t\ted = P(j,i);\n\t    }\n\t}\n\n\n     \n      //draw(G,ed);\n     \n      int men = (1<<28);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  P p = pox.p;\n\t  int cost = pox.cost;\n\t  if(G[p.S][p.F] == '&')\n\t    {\n\t      men = min(men,cost);\n\t      break;\n\t    }\n\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx = p.F + dx[i];\n\t      int ny = p.S + dy[i];\n\n\t      if(!(1<=nx&&nx<=w && 1<=ny&&ny<=h))\n\t\tcontinue;\n\n\t      int d = G[ny][nx]=='#'?1:0;\n\t      if(mincost[ny][nx] > cost + d)\n\t\t{\n\t\t  mincost[ny][nx] = cost + d;\n\t\t  deq.push_back(Pox(P(nx,ny),mincost[ny][nx]));\n\t\t}\n\t    }\n\n\t}\n      cout << men << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing P = pair<int, int>;\n\nint N, M;\nchar field[111][111];\n\nint solve() {\n    int memo[111][111];\n    for (int j = 0; j < M; ++j) { fill(memo[j], memo[j]+N, INF); }\n\n    priority_queue<P> que;\n\n    for (int j = 0; j < M; ++j) {\n        for (int k = 0; k < N; ++k) {\n            if (field[j][k] == '&') {\n                memo[j][k] = 0;\n                que.emplace(0, j*N + k);\n            }\n        }\n    }\n\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int cost = -p.first, x = p.second/N, y = p.second%N;\n\n        if (cost > memo[x][y]) { continue; }\n\n        char st = field[x][y];\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x+dx[d], ny = y+dy[d];\n            if (nx < 0 || M <= nx || ny < 0 || N <= ny) { continue; }\n\n            int next_cost = cost + (st == '.' && field[nx][ny] == '#');\n\n            if (next_cost < memo[nx][ny]) {\n                memo[nx][ny] = next_cost;\n                que.emplace(-next_cost, nx*N+ny);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < M; ++j) {\n        ans = min(ans, min(memo[j][0], memo[j][N-1]));\n    }\n    for (int j = 0; j < N; ++j) {\n        ans = min(ans, min(memo[0][j], memo[M-1][j]));\n    }\n    return ans;\n}\n\nbool loop() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n    for (int j = 0; j < M; ++j) { cin >> field[j]; }\n\n    cout << solve() << endl;\n\n    return true;\n}\n\nint main() { while (loop()); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int x,int y,int p,int w,int h){\n  if(0){\n  }else if(a[x][y]==-2){\n    a[x][y]=p+1;\n  }else if(a[x][y]==-1){\n    if(x==0||x==w-1||y==0||y==h-1)\n      return 1;\n    a[x][y]=p;\n    if(f(a,x-1,y,p,w,h))\n      return 1;\n    if(f(a,x,y-1,p,w,h))\n      return 1;\n    if(f(a,x+1,y,p,w,h))\n      return 1;\n    if(f(a,x,y+1,p,w,h))\n      return 1;\n  }\n  return 0;\n}\nint main(){\n  int i,j,k;\n  int a[100][100],w,h;\n  char c;\n  while(cin>>w>>h&&w+h){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin>>c;\n\tif(0){\n\t}else if(c=='#'){\n\t  a[j][i]=-2;\n\t}else if(c=='.'){\n\t  a[j][i]=-1;\n\t}else if(c=='&'){\n\t  a[j][i]=0;\n\t}\n      }\n    }\n    for(i=0;;i++){\n      for(j=0;j<h;j++){\n\tfor(k=0;k<w;k++){\n\t  if(a[k][j]==i){\n\t    if(k==0||k==w-1||j==0||j==h-1)\n\t      break;\n\t    if(f(a,k-1,j,i,w,h))\n\t      break;\n\t    if(f(a,k,j-1,i,w,h))\n\t      break;\n\t    if(f(a,k+1,j,i,w,h))\n\t      break;\n\t    if(f(a,k,j+1,i,w,h))\n\t      break;\n\t  }\n\t}\n\tif(k!=w)\n\t  break;\n      }\n      if(j!=h)\n\tbreak;\n    }\n    cout<<i<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\ntypedef pair<int,int> P;\n\nint main() {\n  int dx[] = {0,1,0,-1};\n  int dy[] = {-1,0,1,0};\n  \n  int n,m;\n  while(cin >> n >> m,n||m) {\n    char ba[n][m];\n    P castle;\n    REP(y,m) {\n      REP(x,n) {\n        cin >> ba[x][y];\n        if (ba[x][y] == '&')\n          castle = P(x,y);\n      }\n    }\n    int dp[n][m];\n    REP(x,n) {\n      REP(y,m) {\n        if (x == 0 || x == n-1 || y == 0 || y == m-1)\n          dp[x][y] = 0;\n        else\n          dp[x][y] = INF;\n      }\n    }\n    bool update = true;\n    while(update) {\n      update = false;\n      for (int x=1; x<n-1; ++x) {\n        for (int y=1; y<m-1; ++y) {\n          REP(k,4) {\n            int xx = x+dx[k], yy = y+dy[k];\n            if (ba[x][y] != '#' && ba[xx][yy] == '#') {\n              if (dp[x][y] > dp[xx][yy] + 1) {\n                dp[x][y] = dp[xx][yy] + 1;\n                update = true;\n              }\n            } else {\n              if (dp[x][y] > dp[xx][yy]) {\n                dp[x][y] = dp[xx][yy];\n                update = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << dp[castle.first][castle.second] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint main(){\n  int n, m, i, j, d, res;\n  while(scanf(\"%d%d\", &n, &m) && n+m){\n    char cas[128][128];\n    int cnt[128][128];\n    rep(i, m) rep(j, n) cnt[i][j] = INF;\n    rep(i, m) scanf(\"%s\", cas[i]);\n\n    int x, y;\n    rep(i, m) rep(j, n) if(cas[i][j] == '&'){ y = i; x = j;}\n    cnt[y][x] = 0;\n    queue<pi>q;\n    q.push(make_pair(y, x));\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpi now = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", now.Y, now.X);\n\trep(d, 4){\n\t  int ny = now.Y + dy[d], nx = now.X + dx[d];\n\t  if(ny < 0 || nx < 0 || ny >= m || nx >= n) continue;\n\t  if(cnt[ny][nx] <= cnt[now.Y][now.X]) continue;\n\t  if(cas[ny][nx] == '#'){\n\t    cnt[ny][nx] = cnt[now.Y][now.X] + 1;\n\t  }else{\n\t    cnt[ny][nx] = cnt[now.Y][now.X];\n\t  }\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n    }\n\n    /*    rep(i, m){\n      rep(j, n) printf(\"%d \", cnt[i][j]); puts(\"\");\n      }*/\n\n    res = INF;\n    rep(i, m){\n      res = min(res, cnt[i][0]);\n      res = min(res, cnt[i][0]);\n    }\n    rep(i, n){\n      res = min(res, cnt[0][i]);\n      res = min(res, cnt[0][i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1 << 20)\n#define MAX_V 12000\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int, int> P; // first??????????????¢???second??????????????????\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\n// ?????????O(|E|log|V|)\n\nvoid shortest_path(int s, int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\tint W, H;\n\t\n\twhile(true){\n\t\t\n\t\tcin >> W >> H;\n\t\t\n\t\tif(W * H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tstring map[200];\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> map[i + 1];\n\t\t\tmap[i + 1] = \".\" + map[i + 1] + \".\";\n\t\t}\n\t\t\n\t\tH += 2;\n\t\tW += 2;\n\t\t\n\t\tstring str = \"\";\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tstr = str + \".\";\n\t\t\tmap[0] = str;\n\t\t\tmap[H - 1] = str;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i < H - 1; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tint index1 = i * W + j;\n\t\t\t\tint index2 = (i + 1) * W + j;\n\t\t\t\tint cost;\n\t\t\t\tif(map[i][j] != map[i + 1][j] && (map[i][j] == '#' || map[i + 1][j] == '#')){\n\t\t\t\t\tcost = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tedge e1, e2;\n\t\t\t\te1.to = index2;\n\t\t\t\te2.to = index1;\n\t\t\t\te1.cost = cost;\n\t\t\t\te2.cost = cost;\n\t\t\t\tG[index1].push_back(e1);\n\t\t\t\tG[index2].push_back(e2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W - 1; j++){\n\t\t\t\tint index1 = i * W + j;\n\t\t\t\tint index2 = i * W + j + 1;\n\t\t\t\tint cost;\n\t\t\t\tif(map[i][j] != map[i][j + 1] && (map[i][j] == '#' || map[i][j + 1] == '#')){\n\t\t\t\t\tcost = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tedge e1, e2;\n\t\t\t\te1.to = index2;\n\t\t\t\te2.to = index1;\n\t\t\t\te1.cost = cost;\n\t\t\t\te2.cost = cost;\n\t\t\t\tG[index1].push_back(e1);\n\t\t\t\tG[index2].push_back(e2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint index_goal;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(map[i][j] == '&'){\n\t\t\t\t\tindex_goal = i * W + j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint V = H * W;\n\t\t\n\t\tshortest_path(0, V);\n\t\t\n\t\tcout << d[index_goal] / 2 << endl;\n\t\t/*\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tcout << d[i * W + j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<algorithm>\n#define INF 1<<28\nusing namespace std;\n\nstruct P{\n  int x, y, c;\n  P(int x, int y, int c):x(x),y(y),c(c){}\n};\n\nint w, h;\nchar s[999][999];\nint sx, sy;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint bfs(){\n\n  deque < P > que;\n  int ans = INF;\n  bool flag[999][999] = {};\n\n  que.push_front(P(sx, sy, 0));\n  flag[sy][sx] = true;\n \n  while(!que.empty()){\n    P p = que.front(); que.pop_front();\n    int nx = p.x, ny = p.y;\n\n    for(int i=0;i<4;i++){\n      int x = nx + dx[i], y = ny + dy[i];\n\n      if(flag[y][x]) continue;\n      if(!y || !x || y == h+1 || x == w+1){\n\tans = min(p.c, ans);\n\tcontinue;\n      }\n      \n      if(s[ny][nx] != '#' && s[y][x] == '#') que.push_back(P(x,y,p.c+1));\n      else que.push_front(P(x,y,p.c));\n    }\n    flag[ny][nx] = true;\n  }\n  return ans;\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<999;i++){\n      for(int j=0;j<999;j++){\n\ts[i][j] = '.';\n\tif(i > h || j > w || !i || !j) continue;\n\tcin >> s[i][j];\n\tif(s[i][j] == '&') sx = j, sy = i;\n      }\n    }\n\n    cout << bfs() << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint h, w;\nchar mapData[100][100];\nbool visited[100][100];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[100][100];\nint p;\n\nvoid dfs(int y, int x){\n  height[y][x] = p;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= h) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(height[ty][tx] == p && visited[ty][tx]) continue;\n    if(height[ty][tx] < p) return;\n    visited[ty][tx] = true;\n    dfs(ty, tx);\n  }\n}\n\nint solve(){\n  fill(height[0], height[100], INF);\n  int cnt;\n  for(int j=0;j<w;j++){//top to bottom\n    cnt = 0;\n    for(int i=0;i<h;i++){\n      if(mapData[i][j] == '#') cnt++;\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//left to right\n    cnt = 0;\n    for(int j=w-1;j>=0;j--){\n      if(mapData[i][j] == '#') cnt++;\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int j=0;j<w;j++){//bottom to top\n    cnt = 0;\n    for(int i=h-1;i>=0;i--){\n      if(mapData[i][j] == '#') cnt++;\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//right to left\n    cnt = 0;\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#') cnt++;\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  fill(visited[0], visited[100], false);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#' || visited[i][j]) continue;\n      p = height[i][j];\n      dfs(i, j);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nint main() {\n\tint n, m;\n\twhile (cin >> m >> n) {\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<char> > c(n, vector<char>(m));\n\t\tvector< vector<int> > d(n, vector<int>(m, 1000));\n\t\tint si, sj;\n\t\tsi = sj = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif (c[i][j] == '&') {\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tc[si][sj] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[si][sj] = 0;\n\t\tqueue<Q> q;\n\t\tint di[] = {1, 0, -1, 0};\n\t\tint dj[] = {0, 1, 0, -1};\n\t\tq.push(Q(P(si, sj), 0));\n\t\twhile (!q.empty()) {\n\t\t\tQ qq = q.front();\n\t\t\tq.pop();\n\t\t\tP pp = qq.first;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < n && pp.second+dj[i] >= 0 && pp.second+dj[i] < m) {\n\t\t\t\t\tint aa = qq.second;\n\t\t\t\t\tif (c[pp.first][pp.second] == '.' && c[pp.first+di[i]][pp.second+dj[i]] == '#') {\n\t\t\t\t\t\taa++;\n\t\t\t\t\t}\n\t\t\t\t\tif (d[pp.first+di[i]][pp.second+dj[i]] > aa) {\n\t\t\t\t\t\td[pp.first+di[i]][pp.second+dj[i]] = aa;\n\t\t\t\t\t\tq.push(Q(P(pp.first+di[i], pp.second+dj[i]), aa));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcout << d[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tint MIN = 1000;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tMIN = min(MIN, min(d[i][0], d[i][m-1]));\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tMIN = min(MIN, min(d[0][i], d[n-1][i]));\n\t\t}\n\t\tcout << MIN << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[110][110];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n          grid[i][j] = '.';\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      if(x == 0 || y == 0 || x == W-1 || y == H-1) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[y][x] == '.' && grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1 || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(-ncost, Pii(nx, ny)));\n          }\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nbool ingrid(int x, int y, int w, int h)\n{\n\treturn x >= 0 && x <= h + 1 && y >= 0 && y <= w + 1;\n}\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tpriority_queue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (!ingrid(tx, ty, w, h)) continue;\n\t\t\t\tif (d[tx][ty] > st.d + (grid[st.x][st.y] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[st.x][st.y] == '#')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\n\ntypedef pair<int, int> P;\ntypedef pair <int, pair<int, int> > PP;\n\nconst int INF = 1 << 30;\n\nchar Map[101][101];\nint cost[105][105];\n\nint bfs (P sp, int m, int n )\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\tque.push (PP(0, sp ) );\n\n\twhile (!que.empty() ){\n\t\tPP curr = que.top(); que.pop();\n\t\tint c = curr.first;\n\t\tint cr = curr.second.first, cc = curr.second.second;\n\t\tif (cr == 0 || cr == m+1 || cc == 0 || cc == n+1 )\n\t\t\treturn c;\n\t\tif (cost[cr][cc] > c ) cost[cr][cc] = c;\n\t\telse\n\t\t\tcontinue;\n\t\trep (k, 4 ){\n\t\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\t\tif (Map[cr][cc] == '.' && Map[nr][nc] == '#' ){\n\t\t\t\tque.push (PP(c+1, P (nr, nc ) ) );\n\t\t\t} // end if\n\t\t\telse{\n\t\t\t\tque.push (PP (c, P(nr, nc ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn -1;\n} \n\nint main()\n{\n\tint n, m;\t// n: ¼Ì m: ìkÌ \n\n\twhile (cin >> n >> m && n && m ){\n\t\tmemset (Map, 0, sizeof (Map ) );\n\t\trep (i, m+2 )\n\t\t\trep (j, n+2 )\n\t\t\t\tcost[i][j] = INF;\n\n\t\tP sp;\t// VçtÌÊu\n\n\t\trep (i, m ){\n\t\t\trep (j, n ){\n\t\t\t\tcin >> Map[i][j];\n\t\t\t} // end rep\n\t\t} // end rep\n\t\trep (i, m ){\n\t\t\trep (j, n ){\n\t\t\t\tif (Map[i][j] == '&' ){\n\t\t\t\t\tsp.first = i, sp.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end rep\n\n\t\tint res = bfs (sp, m, n );\n\n\t\tcout << res << endl;\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n      if(M[ny][nx] == '#' && T[ny][nx] > s.t+1){\n\tT[ny][nx] = s.t+1;\n\tQ.push(State(nx,ny,s.t+1));\n      }\n\n      if(M[ny][nx] != '#' && T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n\n    init();\n    input();\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nbool ingrid(int x, int y, int w, int h)\n{\n\treturn x >= 0 && x <= h + 1 && y >= 0 && y <= w + 1;\n}\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tpriority_queue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (!ingrid(tx, ty, w, h)) continue;\n\t\t\t\tif (d[tx][ty] > st.d + (grid[st.x][st.y] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[st.x][st.y] == '#' && grid[tx][ty] == '.')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n \nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n \ndouble h, w;\nchar C[210][210];\n \nint d[210][210];\n \nbool isOutOfRange(int x, int y){\n    if(x <= 0 || x > w || y<= 0 || y > h) return true;\n    return false;\n}\n \nint main(){\n    pii p;\n    int x, y, nx, ny, c, nc;\n    int gx, gy;\n    while(cin>>w>>h && h && w){\n        rep(i, h) scanf(\"%s\", C[i]);\n        //cout<<h<<\" \"<<w<<endl;\n        rep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n        gx++; gy++;\n        rep(i, 210) rep(j, 210) d[i][j] = -1;\n        priority_queue<pii/*, vector<pii>, greater<pii>*/ > q;\n        rep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n        rep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            y = p.se/1000;\n            x = p.se%1000;\n            c = p.fi;\n            rep(i, 4){\n                nx = x + dx[i];\n                ny = y + dy[i];\n                if(isOutOfRange(nx, ny)) continue;\n                nc = c + (C[ny-1][nx-1]=='#'?1:0);\n                if(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n                d[ny][nx] = nc;\n                //if(ny==gy && nx == gx) continue;\n                q.push(mp(nc, ny*1000+nx));\n            }\n        }\n        cout<<d[gy][gx]<<endl;  \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<=n && kx>=0 && kx<=m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=i,gy=j;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\n#define P pair<int,int>\nusing namespace std;\n\nint a, b;\nstring c[105];\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvector<P>V;\nint main() {\n\twhile (cin >> b >> a, a || b) {\n\t\tstring f;\n\t\tfor (int g = 0; g < b + 2; g++)f += \".\";\n\t\tc[0] = c[a + 1] = f;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d + 1] = \".\" + e + \".\";\n\t\t}\n\t\ta+=2; b+=2;\n\t\tfor (int I = 0;I<10005; I++) {\n\t\t\tqueue<P>Q;\n\t\t\tQ.push(P(0,0));\n\t\t\tc[0][0] = 0;\n\t\t\tV.push_back(P(0,0));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP t = Q.front(); Q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b) {\n\t\t\t\t\t\tif (c[x][y] == '.') {\n\t\t\t\t\t\t\tV.push_back(P(x, y));\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tQ.push(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '#') {\n\t\t\t\t\t\t\tV.push_back(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '&') {\n\t\t\t\t\t\t\tcout << I << endl;\n\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (P o : V) {\n\t\t\t\tc[o.first][o.second] = '.';\n\t\t\t}\n\t\t\tV.clear();\n\t\t}\n\tl:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x,y;\nchar field[100][100];//field[y][x]\nbool flag;\n\nvoid DFS(int a,int b){\n\tif(field[b][a] == '&'){\n\t\tflag = true;\n\t}\n\telse\n\t\tfield[b][a] = '-';\n\tif(0 <= b+1 && b+1 < y && 0 <= a && a < x && (field[b+1][a] == '.'|| field[b+1][a] == '&'))\n\t\tDFS(a,b+1);\n\tif(0 <= b-1 && b-1 < y && 0 <= a && a < x && (field[b-1][a] == '.'|| field[b-1][a] == '&'))\n\t\tDFS(a,b-1);\t\n\tif(0 <= b && b < y && 0 <= a+1 && a+1 < x && (field[b][a+1] == '.'|| field[b][a+1] == '&'))\n\t\tDFS(a+1,b);\t\n\tif(0 <= b && b < y && 0 <= a-1 && a-1 < x && (field[b][a-1] == '.'|| field[b][a-1] == '&'))\n\t\tDFS(a-1,b);\n}\n\nvoid hey(int a,int b){\n\tfield[b][a] = '-';\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tif(field[b+i][a+j]=='#' && (0 <= a+j && b+i < y) && (0 <= a+j && a+j < x))\n\t\t\t\they(a+j,b+i);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> x >> y){\n\t\tif(!x && !y)\n\t\t\tbreak;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(field[0][i] == '.')\n\t\t\t\tfield[0][i] = '-';\n\t\t\tif(field[y-1][i] == '.')\n\t\t\t\tfield[y-1][i] = '-';\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tif(field[i][0] == '.')\n\t\t\t\tfield[i][0] = '-';\n\t\t\tif(field[i][x-1] == '.')\n\t\t\t\tfield[i][x-1] = '-';\n\t\t}\n\t\tint count = 0;\n\t\tflag = false;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\tDFS(j,i);\n\t\t\t}\n\t\t}\n\t\twhile(!flag){\n\t\t\tint a,b;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '#'){\n\t\t\t\t\t\ta = j;b = i;\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext:;\n\t\t\they(a,b);\n\t\t\tcount++;\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\t\tDFS(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint h, w;\nchar mapData[100][100];\nbool visited[100][100];\nbool visited2[100][100];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[100][100];\nint valm;\n\nvoid dfs(int y, int x){\n  valm = min(valm, height[y][x]);\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(visited[ty][tx]) continue;\n    visited[ty][tx] = true;\n    dfs(ty, tx);\n  }\n}\n\nvoid dfs2(int y, int x){\n  height[y][x] = valm;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(visited2[ty][tx]) continue;\n    visited2[ty][tx] = true;\n    dfs2(ty, tx);\n  }\n}\n\nint solve(){\n  fill(height[0], height[100], INF);\n  int cnt;\n  for(int j=0;j<w;j++){//top to bottom\n    cnt = 0;\n    for(int i=0;i<h;i++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//left to right\n    cnt = 0;\n    for(int j=w-1;j>=0;j--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int j=0;j<w;j++){//bottom to top\n    cnt = 0;\n    for(int i=h-1;i>=0;i--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\t\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//right to left\n    cnt = 0;\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  fill(visited[0], visited[100], false);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#' || visited[i][j]) continue;\n      valm = INF;\n      dfs(i, j);\n      fill(visited2[0], visited2[100], false);\n      dfs2(i, j);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    cout << solve() << endl;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << setw(2) << height[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<set>\n#include<functional>\nusing namespace std;\n\nconst char Water = '#';\nconst char Earth = '.';\nconst char Tower = '&';\n\nconst vector<vector<int>> Next = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nenum {COST, Y, X};\ntypedef tuple<int, int, int> Node;\n\nint bfs(const vector<string>& field) {\n    int h = field.size();\n    int w = field[0].size();\n\n    set<tuple<int, int>> visited;\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    q.push(Node(0, 0, 0));\n    while(!q.empty()) {\n        int y = get<Y>(q.top());\n        int x = get<X>(q.top());\n        int cost = get<COST>(q.top());\n        q.pop();\n        if(field[y][x] == Tower) return cost;\n        if(visited.count(tuple<int, int>(y, x))) continue;\n        visited.insert(tuple<int, int>(y, x));\n        for(const auto& d: Next) {\n            int ny = y + d[0];\n            int nx = x + d[1];\n            int ncost = cost;\n            if(ny < 0 || h <= ny) continue;\n            if(nx < 0 || w <= nx) continue;\n            if(field[y][x] == Water && field[ny][nx] != Water) ++ncost;\n            q.push(Node(ncost, ny, nx));\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n | m) {\n        vector<string> field(m + 2);\n        for(int i = 1; i <= m; ++i) {\n            string s;\n            cin >> s;\n            field[i] = Earth + s + Earth;\n        }\n        for(int j = 0; j < n + 2; ++j) {\n            field[0] += Earth;\n            field[m + 1] += Earth;\n        }\n        cout << bfs(field) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid print(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cout << T[i][j];\n    cout << endl;\n  }\n}\n\nvoid pp(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cerr << M[i][j];\n    cerr << endl;\n  }\n  cerr << endl;\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n\n      if(M[ny][nx] == '#' && T[ny][nx] > s.t+1){\n\tT[ny][nx] = s.t+1;\n\tQ.push(State(nx,ny,s.t+1));\n      }\n\n      if(M[ny][nx] != '#' && T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n  //cerr << ans << endl;\n  //  print();\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n    cerr << n << \" \" << m << endl;\n    init();\n    input();\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_num){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tnum = arg_num;\n\t}\n\n\tint row,col,num;\n};\n\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H+1 && col >= 0 && col <= W+1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tchar map[H+2][W+3];\n\n\tfor(int row = 0; row <= H+1; row++){\n\t\tfor(int col = 0; col <= W+1; col++){\n\t\t\tmap[row][col] = '.';\n\t\t}\n\t}\n\n\tchar buf[W+1];\n\tint goal_row,goal_col;\n\n\tfor(int row = 1; row <= H; row++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tmap[row][col] = buf[col-1];\n\t\t\tif(buf[col-1] == '&'){\n\t\t\t\tgoal_row = row;\n\t\t\t\tgoal_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint min_count[H+2][W+2];\n\n\tfor(int row = 0; row <= H+1; row++){\n\t\tfor(int col = 0; col <= W+1; col++){\n\t\t\tmin_count[row][col] = BIG_NUM;\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tfor(int col = 1; col <= W; col++){\n\t\tmin_count[0][col] = 0;\n\t\tQ.push(Info(0,col,0));\n\t\tmin_count[H+1][col] = 0;\n\t\tQ.push(Info(H+1,col,0));\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tmin_count[row][0] = 0;\n\t\tQ.push(Info(row,0,0));\n\t\tmin_count[row][W+1] = 0;\n\t\tQ.push(Info(row,W+1,0));\n\t}\n\n\tint next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row == goal_row && Q.front().col == goal_col){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().num > min_count[Q.front().row][Q.front().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\tif(!rangeCheck(next_row,next_col))continue;\n\n\t\t\t\tif(map[next_row][next_col] == '#'){\n\t\t\t\t\tif(min_count[next_row][next_col] > Q.front().num+1){\n\t\t\t\t\t\tmin_count[next_row][next_col] = Q.front().num+1;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().num+1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(min_count[next_row][next_col] > Q.front().num){\n\t\t\t\t\t\tmin_count[next_row][next_col] = Q.front().num;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().num));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_count[goal_row][goal_col]);\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii, vector<Piii>, greater<Piii>> PQ;\n    PQ.push(Piii(0, Pii(sx, sy)));\n    while(!PQ.empty()) {\n      Piii piii = PQ.top(); PQ.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      if(!IN(x, y)) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          PQ.push(Piii(ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nconst int INF = 10000;\nconst int MAX = 100;\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {-1, 0, 1, 0};\nint m,n,sx,sy;\nint step[MAX + 2][MAX + 2];\nchar field[MAX + 2][MAX + 2];\n\nint main()\n{\n    while(cin >> n >> m && m) {\n        memset(step, -1, sizeof(step));\n        memset(field, '.', sizeof(field));\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                cin >> field[i][j];\n                if(field[i][j] == '&') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        priority_queue<S, vector<S>, greater<S> > que;\n        que.push(S(0, P(sx, sy)));\n        while(!que.empty()) {\n            S s = que.top(); que.pop();\n            int x = s.second.first, y = s.second.second, z = s.first;\n            if(step[y][x] >= 0) continue;\n            step[y][x] = z;\n\n            for(int i = 0; i < 4; i++) {\n                int nx = x + dx[i], ny = y + dy[i], nz = z;\n                if(field[ny][nx] == '#' && field[y][x] != '#') nz++;\n                if(nx >= 0 && nx <= n + 1 && ny >= 0 && ny <= m + 1) {\n                    que.push(S(nz, P(nx, ny)));\n                }\n            }\n        }\n\n        int res = INF;\n        for(int i = 0; i <= m + 1; i++)\n            for(int j = 0; j <= n + 1; j++)\n                if(i == 0 || i == m + 1 || j == 0 || j == n + 1) \n                    res = min(res, step[i][j]);\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x,y;\nchar field[100][100];//field[y][x]\nbool flag;\n\nvoid DFS(int a,int b){\n\tif(field[b][a] == '&'){\n\t\tflag = true;\n\t}\n\telse\n\t\tfield[b][a] = '-';\n\tif(0 <= b+1 && b+1 < y && 0 <= a && a < x && (field[b+1][a] == '.'|| field[b+1][a] == '&'))\n\t\tDFS(a,b+1);\n\tif(0 <= b-1 && b-1 < y && 0 <= a && a < x && (field[b-1][a] == '.'|| field[b-1][a] == '&'))\n\t\tDFS(a,b-1);\t\n\tif(0 <= b && b < y && 0 <= a+1 && a+1 < x && (field[b][a+1] == '.'|| field[b][a+1] == '&'))\n\t\tDFS(a+1,b);\t\n\tif(0 <= b && b < y && 0 <= a-1 && a-1 < x && (field[b][a-1] == '.'|| field[b][a-1] == '&'))\n\t\tDFS(a-1,b);\n}\n\nvoid hey(int a,int b){\n\tfield[b][a] = '-';\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tif((0 <= a+j && b+i < y) && (0 <= a+j && a+j < x) && field[b+i][a+j]=='#')\n\t\t\t\they(a+j,b+i);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> x >> y){\n\t\tif(!x && !y)\n\t\t\tbreak;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(field[0][i] == '.')\n\t\t\t\tfield[0][i] = '-';\n\t\t\tif(field[y-1][i] == '.')\n\t\t\t\tfield[y-1][i] = '-';\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tif(field[i][0] == '.')\n\t\t\t\tfield[i][0] = '-';\n\t\t\tif(field[i][x-1] == '.')\n\t\t\t\tfield[i][x-1] = '-';\n\t\t}\n\t\tint count = 0;\n\t\tflag = false;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\tDFS(j,i);\n\t\t\t}\n\t\t}\n\t\twhile(!flag){\n\t\t\tint a,b;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '#'){\n\t\t\t\t\t\ta = j;b = i;\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext:;\n\t\t\they(a,b);\n\t\t\tcount++;\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\t\tDFS(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,r;\nchar p[150][150];\nbool flag;\nvoid rec(int y,int x){\n\tif(p[y][x]=='&')flag = true;\n\tif(flag || p[y][x]=='#')return;\n\tp[y][x]='#';\n\tif(x+1<w )rec(y,x+1);\n\tif(y+1<h )rec(y+1,x);\n\tif(x-1>=0)rec(y,x-1);\n\tif(y-1>=0)rec(y-1,x);\n}\n\nint main(){\n\n\twhile(cin >> w >> h && w){\n\t\tflag = false ;\n\t\tfor(int i=0;i<102;i++)\n\t\tfor(int j=0;j<102;j++)\n\t\t p[i][j] = '.';\n\t\t\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tcin >> p[1+\ti][1+j];\n\t\tr = 0;\n\t\tw+=2;h+=2;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(p[i][j]=='.'&& !flag){\n\t\t\t\tr++;\n\t\t\t\trec(i,j);\n\t\t\t}\n\t\t}\n\t\tcout << r-1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\nnamespace orislib {\nstruct Edge {\n  typedef int weight_t;\n  int from, to;\n  weight_t w;\n  Edge(int from, int to, weight_t w) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& e) const {\n    return w != e.w ? w > e.w : from != e.from ? from < e.from : to < e.to;\n  }\n  static const weight_t INF;\n};\nconst int Edge::INF=INT_MAX;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\n//{{{ void dijkstra(g, s, &dist, &prev)\nvoid dijkstra(const Graph& g, int s, vector<Edge::weight_t>& dist, vector<int>& prev)\n{\n  const int V = g.size();\n  prev.assign(V, -1);\n  dist.assign(V, Edge::INF);\n  dist[s] = 0;\n  priority_queue<Edge> pq;\n  for (pq.push(Edge(-2, s, 0)); !pq.empty();){\n    Edge c = pq.top();\n    pq.pop();\n    if (prev[c.to] != -1) continue;\n    prev[c.to] = c.from;\n    for (const auto& e : g[c.to]){\n      if (dist[e.to] > e.w + c.w){\n        dist[e.to] = e.w + c.w;\n        pq.push(Edge(e.from, e.to, e.w + c.w));\n      }\n    }\n  }\n}\n//}}}\n\nint main()\n{\n  int w, h;\n  while (w = in(), h = in()){\n    Graph g(w * h);\n    char field[128][128];\n    for (int i = 0; i < h; i++) scanf(\"%s\", field[i]);\n    int s;\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        if (field[i][j] == '&'){\n          s = i * w + j;\n          field[i][j] = '.';\n        }\n        for (int d = 0; d < 4; d++){\n          int nx = j + dx[d], ny = i + dy[d];\n          if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n          g[i * w + j].emplace_back(i * w + j, ny * w + nx, field[i][j] == '.' && field[ny][nx] == '#');\n        }\n      }\n    }\n    vector<int> dist, prev;\n    dijkstra(g, s, dist, prev);\n    int mini = 1000000;\n    for (int i = 0; i < h; i++){\n      mini = min(mini, dist[i * w]);\n      mini = min(mini, dist[i * w + w - 1]);\n    }\n    for (int i = 0; i < w; i++){\n      mini = min(mini, dist[i]);\n      mini = min(mini, dist[(h - 1) * w + i]);\n    }\n    printf(\"%d\\n\", mini);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[110][110];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    int ans = 1<<29;\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      bool ok = 0;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + ((grid[y][x] == '.' || grid[y][x] == '&') && grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1 || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(-ncost, Pii(nx, ny)));\n          }\n        }\n        else {\n          cout << cost << endl;\n          ok = 1;\n          break;\n        }\n      }\n      if(ok) break;\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\n//0156\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n\nint d[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n    if(x < 0 || x >= w || y < 0 || y >= h) return true;\n    return false;\n}\n\nstring s[110];\n\nint main(){\n    int x, y;\n    int sx, sy;\n    while(cin>>x>>y && x && y){\n        rep(i, y) cin>>s[i];\n        rep(i, y) rep(j, x){\n            if(s[i][j] == '&'){\n                sx = j;\n                sy = i;\n            }\n            d[i][j] = INF;\n        }\n        //cout<<y<<\" \"<<x<<endl;\n        priority_queue<pair<int, pii> > q;\n        q.push(mp(0, mp(sy, sx)));\n        d[sy][sx] = 0;\n        pair<int, pii> p;\n        int ans = INF;\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            //cout<<\" \"<<p.fi<<\" (\"<<p.se.fi<<\", \"<<p.se.fi<<endl;\n            rep(i, 4){\n                int nx = p.se.se + dx[i];\n                int ny = p.se.fi + dy[i];\n                if(isOutOfRange(nx, ny, x, y)){\n                    ans = min(ans, -p.fi);\n                    break;\n                }\n                int c = -p.fi + ((s[p.se.fi][p.se.se]!='#'&&s[ny][nx]=='#')?1:0);\n                if(d[ny][nx] <= c) continue;\n                d[ny][nx] = c;\n                q.push(mp(-c, mp(ny, nx)));\n            }\n            if(ans != INF) break;\n        }\n        cout<<ans<<endl;\n        // rep(i, y){\n        //     rep(j, x){\n        //         cout<<\" \"<<d[i][j];\n        //     }\n        //     cout<<endl;\n        // }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint h, w;\nchar data[114][514];\nint dp[552194];\nqueue<P> que;\n\nint dy[4] = {1,0,-1,0};\nint dx[4] = {0,1,0,-1};\nint main(){\n\tint i,j;\n\twhile (cin >> w >> h) {\n\t\tint g;\n\t\tif (!h) break;\n\t\tfor (i = 0; i < h; i++) cin >> data[i];\n\t\tfor (i = 0; i < w*h; i++) dp[i] = 5642194;\n\t\tfor (i = 0; i < h; i++)\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (i == 0 || i == h-1 || j == 0 || j == w-1)\n\t\t\t\t\tque.push(P((data[i][j] == '#'), i*w + j));\n\t\t\t\tif (data[i][j] == '&')\n\t\t\t\t\tg = i * w + j;\n\t\t\t}\n\t\twhile(!que.empty()) {\n\t\t\tint cost = que.front().first;\n\t\t\tint pos = que.front().second;\n\t\t\tque.pop();\n\t\t\tif (dp[pos] <= cost)\n\t\t\t\tcontinue;\n\t\t\tdp[pos] = cost;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tint ny = pos/w + dy[i];\n\t\t\t\tint nx = pos%w + dx[i];\n\t\t\t\tif (ny < 0 || ny >= h || nx < 0 || nx >= w)\n\t\t\t\t\tcontinue;\n\t\t\t\tque.push( P( cost + (data[ny][nx] == '#'), ny*w + nx ) );\n\t\t\t}\n\t\t}\n\t\tcout << dp[g] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint h, w;\nchar mapData[100][100];\nbool visited[100][100];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[100][100];\nint p;\n\nvoid dfs(int y, int x){\n  height[y][x] = p;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(height[ty][tx] == p && visited[ty][tx]) continue;\n    if(height[ty][tx] < p) continue;\n    visited[ty][tx] = true;\n    dfs(ty, tx);\n  }\n}\n\nint solve(){\n  fill(height[0], height[100], INF);\n  int cnt;\n  for(int j=0;j<w;j++){//top to bottom\n    cnt = 0;\n    for(int i=0;i<h;i++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//left to right\n    cnt = 0;\n    for(int j=w-1;j>=0;j--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n\theight[i][j] = min(height[i][j], cnt);\n      }\n    }\n  }\n  for(int j=0;j<w;j++){//bottom to top\n    cnt = 0;\n    for(int i=h-1;i>=0;i--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\t\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//right to left\n    cnt = 0;\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  fill(visited[0], visited[100], false);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#' || visited[i][j]) continue;\n      p = height[i][j];\n      dfs(i, j);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    cout << solve() << endl;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << setw(2) << height[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing P = pair<int, int>;\n\nint N, M;\nchar field[111][111];\n\nint solve() {\n    int memo[111][111];\n    for (int j = 0; j < M; ++j) { fill(memo[j], memo[j]+N, INF); }\n\n    priority_queue<P> que;\n\n    for (int j = 0; j < M; ++j) {\n        for (int k = 0; k < N; ++k) {\n            if (field[j][k] == '&') {\n                memo[j][k] = 0;\n                que.emplace(0, j*N + k);\n            }\n        }\n    }\n\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int cost = -p.first, x = p.second/N, y = p.second%N;\n\n        if (cost > memo[x][y]) { continue; }\n\n        char st = field[x][y];\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x+dx[d], ny = y+dy[d];\n            if (nx < 0 || M <= nx || ny < 0 || N <= ny) { continue; }\n\n            int next_cost = cost + (st == '#' && field[nx][ny] != '#');\n\n            if (next_cost < memo[nx][ny]) {\n                memo[nx][ny] = next_cost;\n                que.emplace(-next_cost, nx*N+ny);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < M; ++j) {\n        if (field[j][0] != '#') { ans = min(ans, memo[j][0]); }\n        if (field[j][N-1] != '#') { ans = min(ans, memo[j][N-1]); }\n    }\n    for (int j = 0; j < N; ++j) {\n        if (field[0][j] != '#') { ans = min(ans, memo[0][j]); }\n        if (field[M-1][j] != '#') { ans = min(ans, memo[M-1][j]); }\n    }\n    return ans;\n}\n\nbool loop() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n    for (int j = 0; j < M; ++j) { cin >> field[j]; }\n\n    cout << solve() << endl;\n\n    return true;\n}\n\nint main() { while (loop()); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=10000000;\nchar fie[120][120];\nint jp[120][120];\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tque.push(PP(P(i,0),0));\n\t\tjp[i][0]=0;\n\t\tque.push(PP(P(i,m+1),0));\n\t\tjp[i][m+1]=0;\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tque.push(PP(P(0,i),0));\n\t\tjp[0][i]=0;\n\t\tque.push(PP(P(n+1,i),0));\n\t\tjp[n+1][i]=0;\n\t}\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(kx>=0 && kx<=n+1 && ky>=0 && ky<=m+1){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='&' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcin >> fie[j][i];\n\t\t\t\tif(fie[j][i]=='&')gx=j,gy=i;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",jp[gx][gy]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nvector<string> m;\nvector<vint> res;\n\nint main() {\n\tint h,w;\n\twhile(cin>>w>>h,h){\n\t\tm.clear();\n\t\tres.clear();\n\t\tint i,j;\n\t\tvint buf;\n\t\tfor(i=0;i<w;i++)buf.push_back(100100100);\n\t\tfor(i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\tm.push_back(str);\n\t\t\tres.push_back(buf);\n\t\t}\n\t\tfor(i=0;i<w;i++)res[0][i]=res[h-1][i]=0;\n\t\tfor(i=0;i<h;i++)res[i][0]=res[i][w-1]=0;\n\t\tbool update=true;\n\t\tint xx[]={1,-1,0,0},yy[]={0,0,1,-1};\n\t\tint k;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(i=1;i<h-1;i++){\n\t\t\t\tfor(j=1;j<w-1;j++){\n\t\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\t\tif(m[i+yy[k]][j+xx[k]]=='#'&&m[i][j]!='#'){\n\t\t\t\t\t\t\tif(res[i+yy[k]][j+xx[k]]+1<res[i][j]){\n\t\t\t\t\t\t\t\tres[i][j]=res[i+yy[k]][j+xx[k]]+1;\n\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(res[i+yy[k]][j+xx[k]]<res[i][j]){\n\t\t\t\t\t\t\t\tres[i][j]=res[i+yy[k]][j+xx[k]];\n\t\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<h;i++){\n\t\t\tfor(j=0;j<w;j++){\n//cout<<res[i][j]<<\" \";\n\t\t\t\tif(m[i][j]=='&'){\n\t\t\t\t\tcout<<res[i][j]<<endl;\n\t\t\t\t}\n\t\t\t}\n//cout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 10e-6;\n\nchar stage[100][100];\nint costTable[100][100];\n\nvoid bfs(int w,int h){\n\tconst int t[][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n\tint sx,sy;\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tif(stage[y][x] == '&'){\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\nfound:;\n\n\tmemset(costTable,0x3,sizeof(costTable));\n\tqueue<P> que;\n\tque.push(P(sx,sy));\n\n\tcostTable[sy][sx] = 0;\n\n\twhile(!que.empty()){\n\t\tint x = que.front().first;\n\t\tint y = que.front().second;\n\t\tque.pop();\t\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint dx = x + t[i][0];\n\t\t\tint dy = y + t[i][1];\n\t\t\tif(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n\n\t\t\tint cost = costTable[y][x] + ((stage[dy][dx] == '#' && stage[y][x] != '#') ? 1 : 0);\n\t\t\tif(costTable[dy][dx] <= cost) continue;\n\n\t\t\tif(cost == 2){\n\t\t\t\tint a = 3;\n\t\t\t}\n\t\t\tcostTable[dy][dx] = cost;\n\t\t\tque.push(P(dx,dy));\n\t\t}\n\t}\n}\n\nint seekExtWall(int w,int h){\n\tint res = 0x3333;\n\n\tfor(int x=0;x<w;x++){\n\t\tres = min(res,costTable[0][x]);\n\t}\n\n\tfor(int x=0;x<w;x++){\n\t\tres = min(res,costTable[h-1][x]);\n\t}\n\n\tfor(int y=0;y<h;y++){\n\t\tres = min(res,costTable[y][0]);\n\t}\n\n\tfor(int y=0;y<h;y++){\n\t\tres = min(res,costTable[y][w-1]);\n\t}\n\n\treturn res;\n}\n\nvoid printCostTable(int w,int h){\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tcout << costTable[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main(){\n\tint w,h;\n\twhile(~scanf(\"%d %d\",&w,&h)){\n\t\tif(w==0 && h==0) break;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tchar buf[128];\n\t\t\tscanf(\"%s\",buf);\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tstage[y][x] = buf[x];\n\t\t\t}\n\t\t}\n\n\t\tbfs(w,h);\n\t\tcout << seekExtWall(w,h) << endl;\n\t\t//printCostTable(w,h);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\nconst int hardCost = 1000;\nconst int dx[] = {1, 0, 0, -1};\nconst int dy[] = {0, 1, -1, 0};\nstruct P{ int x, y; P(int x, int y) : x(x), y(y) {} };\n\nint main()\n{\n    for(int n, m; cin >> n >> m && (n || m); )\n\t{\n\t\tP c(0, 0);\n\t\tvector<string> field(m);\n\t\tvector<vint> cost(n, vint(m, INF));\n\t\t\n\t\trep(i, m)\n\t\t{\n\t\t\tcin >> field[i];\n\t\t\t\n\t\t\tint pos = field[i].find(\"&\");\n\t\t\tif(pos != string::npos)\n\t\t\t{\n\t\t\t\tc.x = pos;\n\t\t\t\tc.y = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tcost[c.x][c.y] = 0;\n\t\tfor(que.push(c); !que.empty(); que.pop())\n\t\t{\n\t\t\tP cur = que.front();\n\t\t\t\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tP nxt(cur.x + dx[i], cur.y + dy[i]);\n\t\t\t\t\n\t\t\t\tif(0 <= nxt.x && nxt.x < n && 0 <= nxt.y && nxt.y < m)\n\t\t\t\t{\n\t\t\t\t\tint ct = cost[cur.x][cur.y] + (field[nxt.y][nxt.x] == '#' ? hardCost : 1);\n\t\t\t\t\t\n\t\t\t\t\tif(ct < cost[nxt.x][nxt.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost[nxt.x][nxt.y] = ct;\n\t\t\t\t\t\tque.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 1 << 30;\n\t\t\n\t\trep(i, n) chmin(res, min(cost[i][0], cost[i][m-1]));\n\t\trep(i, m) chmin(res, min(cost[0][i], cost[n-1][i]));\n\t\t\n\t\t\n\t\tcout << res / hardCost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint dx[]={-1,1,0,0};\nint dy[]={0,0,-1,1};\n\nint d[110][110];\n\nbool isOutOfRange(int x, int y, int w, int h){\n    if(x < 0 || x >= w || y < 0 || y >= h) return true;\n    return false;\n}\n\nstring s[110];\n\nint main(){\n    int x, y;\n    int sx, sy;\n    while(cin>>x>>y && x && y){\n        rep(i, y) cin>>s[i];\n        rep(i, y) rep(j, x){\n            if(s[i][j] == '&'){\n                sx = j;\n                sy = i;\n            }\n            d[i][j] = INF;\n        }\n        //cout<<y<<\" \"<<x<<endl;\n        priority_queue<pair<int, pii> > q;\n        q.push(mp(0, mp(sy, sx)));\n        pair<int, pii> p;\n        int ans = -1;\n        while(!q.empty()){\n            p = q.top(); q.pop();\n            //cout<<\" \"<<p.fi<<\" (\"<<p.se.fi<<\", \"<<p.se.fi<<endl;\n            rep(i, 4){\n                int nx = p.se.se + dx[i];\n                int ny = p.se.fi + dy[i];\n                if(isOutOfRange(nx, ny, x, y)){\n                    ans = -p.fi;\n                    break;\n                }\n                int c = -p.fi + (s[ny][nx]=='#'?1:0);\n                if(d[ny][nx] <= c) continue;\n                d[ny][nx] = c;\n                q.push(mp(-c, mp(ny, nx)));\n            }\n            if(ans != -1) break;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <cstring>\n#include <cassert>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nint N, M; // N: x, M: y\nint map[102][102];\nbool used[5000][102][102];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        memset(used, 0, sizeof(used));\n        memset(map, 0, sizeof(map));\n\n        FOR(i, 1, M+1){\n            FOR(j, 1, N+1){\n                char c;\n                std::cin >> c;\n                if(c == '.'){map[i][j] = 0;}\n                else if(c == '#'){map[i][j] = -1;}\n                else{map[i][j] = 1;}\n            }\n        }\n    \n        std::priority_queue<State,std::vector<State>,std::greater<State>> q;\n        REP(i, N+2){\n            q.push(mp(0, mp(0, i)));\n            q.push(mp(0, mp(M+1, i)));\n        }\n\n        REP(i, M+2){\n            q.push(mp(0, mp(i, 0)));\n            q.push(mp(0, mp(i, N+1)));\n        }\n\n        int res = -1;\n        while(!q.empty()){\n            State s = q.top(); q.pop();\n            int t = s.first, y = s.second.first, x = s.second.second;\n\n            if(t >= 5000){continue;}\n            if(map[y][x] == 1){res = t; break;}\n            if(used[t][y][x]){continue;}\n\n            used[t][y][x] = true;\n        \n            REP(i, 4){\n                int nx = x + dx[i], ny = y + dy[i];\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1 &&\n                   !used[t][ny][nx] && map[ny][nx] != -1){\n                    q.push(mp(t, mp(ny, nx)));\n                }\n            }\n\n            REP(i, 4){\n                int mx = x + dx[i], my = y + dy[i], nx = x + dx[i]*2, ny = y + dy[i]*2;\n                if(0 <= nx && nx <= N+1 &&\n                   0 <= ny && ny <= M+1 &&\n                   !used[t+1][ny][nx] && map[ny][nx] != -1 && map[my][mx] == -1){\n                    q.push(mp(t+1, mp(ny, nx)));\n                }\n            }\n        }\n\n        assert(res != -1);\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint dd[]={1,0,-1,0,1};\n\nVV(char) vv;\nvvint vis;\nvvint tmp;\nint h,w;\nbool foo2(int a,int b){\n\tif(vv[a][b]==' ') return true;\n\tif(vis[a][b]!=INF) return false;\n\tif(vv[a][b]=='#'&&tmp[a][b]!=1){\n\t\ttmp[a][b]=-1;\n\t\treturn false;\n\t}\n\tvis[a][b]=1;\n\tbool ret=false;\n\trep(i,4){\n\t\tret|=foo2(a+dd[i],b+dd[i+1]);\n\t}\n\treturn ret;\n}\nint foo(int c){\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<endl;\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==1){\n\t\t\t\tif(foo2(i,j)) return c;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==1){\n\t\t\t\ttmp[i][j]=2;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h+2){\n\t\trep(j,w+2){\n\t\t\tif(tmp[i][j]==-1){\n\t\t\t\ttmp[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn foo(c+1);\n}\n\nvoid mainmain(){\n\t// int w,h;\n\twhile(cin>>w>>h,w||h){\n\t\tinitvv(vv,h+2,w+2,' ');\n\t\tint x,y;\n\t\tinitvv(vis,h+2,w+2,INF);\n\t\tinitvv(tmp,h+2,w+2,0);\n\t\treep(i,1,h+1){\n\t\t\treep(j,1,w+1){\n\t\t\t\tcin>>vv[i][j];\n\t\t\t\tif(vv[i][j]=='&'){\n\t\t\t\t\ttmp[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<foo(0)<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid nuru(int y,int x,vector<vector<char> > &v){\n    if(v[y][x]=='#' || v[y][x] == 'x') return;\n    v[y][x] = 'x';\n    nuru(y-1,x,v);\n    nuru(y+1,x,v);\n    nuru(y,x-1,v);\n    nuru(y,x+1,v);\n}\nvoid nuru2(int y,int x,vector<vector<char> > &v){\n    nuru(y,x,v);\n    for(int i=1;i<v.size()-1;i++){\n        for(int j=1;j<v[i].size()-1;j++){\n            if(v[i][j]=='x'){\n                if(v[i+1][j]=='#')v[i+1][j]='x';\n                if(v[i-1][j]=='#')v[i-1][j]='x';\n                if(v[i][j+1]=='#')v[i][j+1]='x';\n                if(v[i][j-1]=='#')v[i][j-1]='x';\n            }\n        }\n    }\n}\nint solve(int n,int m){\n    int gy,gx;\n    vector<vector<char> > field(m+4,vector<char>(n+4));\n    for(int i=0;i<n+4;i++){\n        field[0][i] = 'x';\n        field[m+3][i] = 'x';\n    }\n    for(int i=0;i<m+4;i++){\n        field[i][0] = 'x';\n        field[i][n+3] = 'x';\n    }\n    for(int i=1;i<n+3;i++){\n        field[1][i] = '.';\n        field[m+2][i] = '.';\n    }\n    for(int i=1;i<m+3;i++){\n        field[i][1] = '.';\n        field[i][n+2] = '.';\n    }\n    for(int i=2;i<m+2;i++){\n        for(int j=2;j<n+2;j++){\n            char c;\n            cin >> c;\n            field[i][j] = c;\n            if(c=='&'){\n                gy = i;\n                gx = j;\n            }\n        }\n    }\n    int ret = 0;\n    while(true){\n        int x,y;\n        for(int i=1;i<field.size()-1;i++){\n            for(int j=1;j<field[i].size()-1;j++){\n                if(field[i][j]=='.'){\n                    y = i;x = j;\n                    goto OUT;\n                }\n            }\n        }\n    OUT:\n        nuru2(y,x,field);\n        if(field[gy][gx]=='x')return ret;\n        ret = ret + 1;\n    }\n}\n\nint main(){\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==m && n==0) break;\n        cout << solve(n,m) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P>PP;//wall y x\nint M,N,mv[5]={-1,0,1,0,-1},res;\nchar A[105][105],B[105][105];\nint d[105][105];\npriority_queue<PP>Q;//need finit\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&N,&M),N+M;)\n\t{\n\t\tres=100000000;\n\t\tmemset(d,0x7f,sizeof(d));\n\t\tfor(int i=0;i<=M+1;i++)for(int j=0;j<=N+1;j++)B[i][j]='.';\n\t\tfor(int i=0;i<M;i++)gets(B[i+1]+1);\n\t\tfor(int i=0;i<=M+1;i++){B[i][N+1]='.';B[i][N+2]=0;}\n\t\tN++;M++;\n\t\tQ.push(make_pair(0,make_pair(0,0)));\n\t\t//d[0][0]=0;\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tPP tmp=Q.top();Q.pop();\n\t\t\tint y=tmp.second.first;\n\t\t\tint x=tmp.second.second;\n\t\t\tint cost=tmp.first;\n\t\t\tif(d[y][x]<cost)continue;\n\t\t\td[y][x]=cost;\n\t\t\tif(B[y][x]=='&')\n\t\t\t{\n\t\t\t\tres=min(res,cost);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+mv[i];\n\t\t\t\tint nx=x+mv[i+1];\n\t\t\t\tif(ny<0||ny>M||nx<0||nx>N)continue;\n\t\t\t\tint nc=cost+(B[y][x]=='#'&&B[ny][nx]!='#');\n\t\t\t\tif(nc<d[ny][nx])\n\t\t\t\t{\n\t\t\t\t\td[ny][nx]=nc;\n\t\t\t\t\tQ.push(make_pair(nc,make_pair(ny,nx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    priority_queue<Piii> PQ;\n    PQ.push(Piii(0, Pii(sx, sy)));\n    while(!PQ.empty()) {\n      Piii piii = PQ.top(); PQ.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = -piii.first;\n      \n      if(!IN(x, y)) {\n        cout << cost << endl;\n        break;\n      }\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        int ncost = cost + (grid[ny][nx] == '#');\n        if(memo[ny][nx] == -1\n           || memo[ny][nx] > ncost) {\n          memo[ny][nx] = ncost;\n          PQ.push(Piii(-ncost, Pii(nx, ny)));\n        }\n      }\n    }\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n || m) {\n\t\tvector<vector<int> > cnt(m, vector<int>(n, INF));\n\t\tvector<string> str(m);\n\t\tREP(i, m) cin >> str[i];\n\t\t\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n\t\tREP(i, m) {\n\t\t\tpq.push(make_pair(0, pii(i, 0)));\n\t\t\tpq.push(make_pair(0, pii(i, n - 1)));\n\t\t}\n\t\tREP(i, n) {\n\t\t\tpq.push(make_pair(0, pii(0, i)));\n\t\t\tpq.push(make_pair(0, pii(m - 1, i)));\n\t\t}\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpair<int, pii> now = pq.top();\n\t\t\tpq.pop();\n\t\t\t\n\t\t\t\n\t\t\tint x = now.second.second, y = now.second.first;\n\t\t\tif (cnt[y][x] != INF) continue;\n\t\t\t\n\t\t\tcnt[y][x] = now.first;\n\t\t\tint to = now.first;\n\t\t\tif (str[y][x] == '#') to++;\n\t\t\t\n\t\t\tint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\t\t\tREP(i, 4) {\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (!(nx >= 0 && nx < n && ny >= 0 && ny < m)) continue;\n\t\t\t\tpq.push(make_pair(to, pii(ny, nx)));\n\t\t\t}\n\t\t}\n\t\tint gx, gy;\n\t\tREP(i, m) REP(j, n) if (str[i][j] == '&') gx = j, gy = i;\n\t\tcout << cnt[gy][gx] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint main(){\n  while(1){\n  int dx[5]={1,-1,0,0},dy[5]={0,0,1,-1};\n  int i,j,n,m,a[110][110],b[110][110];\n  char s;\n  int INF=(1<<29);\n  scanf(\"%d %d\\n\",&m,&n);\n  if(m==0 && n==0){\n    return 0;\n  }\n  for(i=0;i<=n+1;i++){\n    for(j=0;j<=m+1;j++){\n      a[i][j]=2;\n      b[i][j]=INF;\n    }\n  }\n  queue<P> que;\n  for(i=1;i<=n;i++){\n   for(j=1;j<=m;j++){\n     scanf(\"%c\",&s);\n     if(s=='.'){\n       a[i][j]=0;\n     }\n     else if(s=='&'){\n       a[i][j]=0,b[i][j]=0;\n       que.push(P(i,j));\n     }\n     else{\n       a[i][j]=1;\n     }\n   }\n    scanf(\"\\n\");\n  }\n  while(!que.empty()){\n    P p=que.front();\n    que.pop();\n    for(i=0;i<4;i++){\n      if(a[p.first][p.second]==1 && a[p.first+dx[i]][p.second+dy[i]]==0){\n        if(b[p.first+dx[i]][p.second+dy[i]]>b[p.first][p.second]+1){\n          que.push(P(p.first+dx[i],p.second+dy[i]));\n          b[p.first+dx[i]][p.second+dy[i]]=b[p.first][p.second]+1;\n        }\n      }\n      else if(a[p.first][p.second]==1 && a[p.first+dx[i]][p.second+dy[i]]==2){\n        if(b[p.first+dx[i]][p.second+dy[i]]>b[p.first][p.second]+1){\n          b[p.first+dx[i]][p.second+dy[i]]=b[p.first][p.second]+1;\n        }\n      }\n      else if(a[p.first+dx[i]][p.second+dy[i]]==2){\n        if(b[p.first+dx[i]][p.second+dy[i]]>b[p.first][p.second]){\n          b[p.first+dx[i]][p.second+dy[i]]=b[p.first][p.second];\n        }\n      }\n      else{\n        if(b[p.first+dx[i]][p.second+dy[i]]>b[p.first][p.second]){\n          que.push(P(p.first+dx[i],p.second+dy[i]));\n          b[p.first+dx[i]][p.second+dy[i]]=b[p.first][p.second];\n        }\n      }\n    }\n  }\n  int ans=INF;\n  for(i=0;i<=n+1;i++){\n    for(j=0;j<=m+1;j++){\n      if(a[i][j]==2 && ans>b[i][j]){\n        ans=b[i][j];\n      }\n    }\n  }\n  cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define MAX 100\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint G[MAX+2][MAX+2], m, n;\n\nbool dfs(int D[MAX+2][MAX+2], int x, int y, int num){\n\tif(x*y==0 || x==(m+1) || y==(n+1) ) return true;\n\tif(G[x][y] == 1 && num==0)  return false;\n\tif(D[x][y] >= num+1)  return false;\n\tD[x][y] = num+1;\n\tfor(int r=0; r<4; r++){\n\t\tif(dfs(D, x+dx[r], y+dy[r], (G[x][y]==0||G[x+dx[r]][y+dy[r]]==1)?(num):(num-1))){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main(void){\n\twhile(cin>>m>>n, m){\n\t\tint sx,sy;\n\t\tchar c;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tfor(int j=1; j<=m; j++){\n\t\t\t\tcin >> c;\n\t\t\t\tif(c == '&'){\n\t\t\t\t\tG[j][i] = 0;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tG[j][i] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tG[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<100; i++){\n\t\t\tint D[MAX+2][MAX+2]={0};\n\t\t\tif(dfs(D,sx,sy,i)){\n\t\t\t\tcout << i <<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct St{\n\tint x, y, c;\n\tSt(int cst, P p): c(cst), y(p.first), x(p.second) {}\n\tbool operator>(const St &s) const{\n\t\treturn c > s.c;\n\t}\n};\n\nconst int inf = 999999;\nint xdir[4] = {0, -1, 0, 1}, ydir[4] = {1, 0, -1, 0};\nint bfs(char a[101][101], int w, int h, P p)\n{\n\tint r = -1, vis[101][101];\n\tpriority_queue<St, vector<St>, greater<St> > que;\n\tfill(&vis[0][0], &vis[h][w], inf);\n\tvis[p.first][p.second] = 0;\n\tque.push(St(0, p));\n\twhile(!que.empty()){\n\t\tSt s = que.top();\n\t\tque.pop();\n\t\tif(s.x < 0 || s.x >= w || s.y < 0 || s.y >= h){\n\t\t\tr = s.c;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint dy = s.y+ydir[i], dx = s.x+xdir[i];\n\t\t\tif(dy < 0 || dy >= h || dx < 0 || dx >= w){\n\t\t\t\tSt t = (a[s.y][s.x] == '#')? St((s.c+1), P(dy, dx)): St(s.c, P(dy, dx));\n\t\t\t\tque.push(t);\n\t\t\t} else if(vis[dy][dx] > s.c){\n\t\t\t\tint u = inf;\n\t\t\t\tif(a[s.y][s.x] == '#' && a[dy][dx] == '.'){\n\t\t\t\t\tu = s.c+1;\n\t\t\t\t} else {\n\t\t\t\t\tu = s.c;\n\t\t\t\t}\n\t\t\t\tif(u < vis[dy][dx]){\n\t\t\t\t\tvis[dy][dx] = u;\n\t\t\t\t\tque.push(St(u, P(dy, dx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint main()\n{\n\tint w, h;\n\tchar a[101][101];\n\tP p;\n\t\n\twhile(cin>>w>>h && (w+h)){\n\t\tfor(int i =0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif(a[i][j] == '&'){\n\t\t\t\t\tp = P(i, j);\n\t\t\t\t\ta[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, w, h, p) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<vector<char> > VVC;\n\nclass Pox\n{\npublic:\n  P p;\n  int cost;\n  Pox(P p = P(0,0),int cost = 0):p(p),cost(cost){}\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w;\n\nvoid draw(VVC& G,P p)\n{\n\n  for(int i=0;i<4;i++)\n    {\n      int nx = p.F + dx[i];\n      int ny = p.S + dy[i];\n      if(!(1<=ny&&ny<=h && 1<=nx&&nx<=w))\n\tcontinue;\n      if(G[ny][nx] == '&' || G[ny][nx] == '#')\n\tcontinue;\n      G[ny][nx] = '&';\n      draw(G,P(nx,ny));\n    }\n  \n}\n\nint main()\n{\n  \n  while(cin >> w >> h,(w||h))\n    {\n    \n      VVC G;\n      P ed;\n      G.resize(h+2);\n      deque<Pox> deq;\n      int mincost[h+3][w+3];\n      for(int i=0;i<=h+1;i++)\n\t{\n\t  G[i].resize(w+2);\n\t  string line;\n\t  if(i == 0 || i == h+1)\n\t    line = string(h+2,'.');\n\t  else\n\t   cin >> line;\n\t   \n\t  for(int j=0;j<=w+1;j++)\n\t    {\n\t      mincost[i][j] = (1<<28);\n\t      if(i == 0 || j == 0 || i == h+1 || j == w+1)\n\t\t{\n\t\t  G[i][j] = '.';\n\t\t  deq.push_back(Pox(P(j,i),0));\n\t\t  mincost[i][j] = 0;\n\t \t  continue;\n\t\t}\n\t      G[i][j] = line[j-1];\n\t      if(G[i][j] == '&')\n\t\ted = P(j,i);\n\t    }\n\t}\n\t  \n      draw(G,ed);\n      \n      int men = (1<<28);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  P p = pox.p;\n\t  int cost = pox.cost;\n\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx = p.F + dx[i];\n\t      int ny = p.S + dy[i];\n\n\t      if(!(1<=nx&&nx<=w && 1<=ny&&ny<=h))\n\t\t  continue;\n\t\t\n\t      int d = 0;\n\t      if(G[ny][nx] == '#')\n\t\t{\n\t\t  while(1<=nx&&nx<=w && 1<=ny&&ny<=h && G[ny][nx] == '#')\n\t\t    nx += dx[i],ny += dy[i];\n\t\t  d = 1;\n\t\t}\n\t      \n\t      if(mincost[ny][nx] > cost + d)\n\t\t{\n\t\t  mincost[ny][nx] = cost + d;\n\t\t  if(G[ny][nx] == '&')\n\t\t    {\n\t\t      men = min(men,mincost[ny][nx]);\n\t\t      continue;\n\t\t    }\n\t\t  deq.push_back(Pox(P(nx,ny),mincost[ny][nx]));\n\t\t}\n\t    }\n\n\t}\n      cout << men << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\nusing namespace std;\n\nstruct NODE{\n\tint x,y,c;\n\tNODE(int x,int y,int c):x(x),y(y),c(c){}\n\t\n};\nchar c[102][102];\nint main(){\n\tint H,W;\n\twhile(cin >> W >> H && W){\n\t\tint sx , sy;\n\t\tfor(int i = 0 ; i <= H+1 ; i++)\n\t\t\tfor(int j = 0 ; j <= W+1 ; j++)\n\t\t\t\tc[i][j] = '.';\n\n\t\tfor(int i = 1 ; i <= H ; i++){\n\t\t\tfor(int j = 1 ; j <= W ; j++){\n\t\t\t\tcin >> c[i][j];\n\t\t\t\tif(c[i][j] == '&'){\n\t\t\t\t\tsx = j , sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dx[] = {-1,0,1,0};\n\t\tint dy[] = {0,1,0,-1};\n\t\tdeque<NODE> Q;\n\t\tint memo[102][102] = {} ;\n\t\tQ.push_back(NODE(sx,sy,0));\n\t\tmemo[sy][sx] = 1;\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front(); Q.pop_front();\n\t\t\tif(q.x == W+1 || q.x == 0 || q.y == H+1 || q.y == 0){\n\t\t\t\tcout << q.c << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\tint tx = q.x + dx[i];\n\t\t\t\tint ty = q.y + dy[i];\n\t\t\t\tif(memo[ty][tx]) continue;\n\t\t\t\tif( c[q.y][q.x] == '.' && c[ty][tx] == '#' ){\n\t\t\t\t\tQ.push_back(NODE(tx,ty,q.c+1));\n\t\t\t\t}else{\n\t\t\t\t\tQ.push_front(NODE(tx,ty,q.c));\n\t\t\t\t}\n\t\t\t\tmemo[ty][tx] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//22\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nstruct S{\n  int x,y,t;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    char g[100][100];\n    priority_queue<S> que;\n    for(int y=0;y<m;y++){\n      for(int x=0;x<n;x++){\n\tcin>>g[y][x];\n\tif(x==0||y==0||x==n-1||y==m-1){\n\t  S is={x,y,g[y][x]=='#'};\n\t  que.push(is);\n\t}\n      }\n    }\n    bool mem[100][100]={{}};\n    for(;;){\n      S c=que.top();\n      if(g[c.y][c.x]=='&')break;\n      que.pop();\n      if(mem[c.y][c.x]++)continue;\n      for(int i=0;i<4;i++){\n\tint d[]={0,1,0,-1,0};\n\tint ny=c.y+d[i];\n\tint nx=c.x+d[i+1];\n\tif(0<=nx&&nx<n&&0<=ny&&ny<m){\n\t  S ns={nx,ny,c.t+((g[c.y][c.x]=='.')&&(g[ny][nx]=='#'))};\n\t  que.push(ns);\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dis[110][110],p[110][110];\ntypedef pair<int,pair<int,int> >P;\npriority_queue<P,vector<P>,greater<P> >Q;\nvoid Qpush(int a,int b,int c){Q.push(make_pair(a,make_pair(b,c)));}\nint main(){\n  int h,w;\n  while(cin>>w>>h&&h+w){\n    lol(i,h)lol(j,w){\n      char z;cin>>z;\n      if(z=='&')Qpush(0,i,j);\n      if(z=='#')p[i][j]=1;\n      else p[i][j]=0;\n      dis[i][j]=mod;\n    }\n    while(!Q.empty()){\n      int cost=Q.top().first;\n      int y=Q.top().second.first;\n      int x=Q.top().second.second;\n      Q.pop();\n      if(dis[y][x]<=cost)continue;\n      dis[y][x]=cost;\n      int dx[]={-1,0,1,0},dy[]={0,1,0,-1};\n      lol(i,4){\n\tint xx=x+dx[i],yy=y+dy[i];\n\tif(xx<0||xx==w||yy<0||yy==h)continue;\n\tif(dis[yy][xx]>cost+p[yy][xx])Qpush(cost+p[yy][xx],yy,xx);\n      }\n    }\n    int ans=mod;\n    for(int i=0;i<h;i++)ans=min(ans,min(dis[i][0],dis[i][w-1]));\n    for(int j=0;j<w;j++)ans=min(ans,min(dis[0][j],dis[h-1][j]));\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// BFS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 1<<30\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> P;\n\n\nint main() {\n  int n,m;\n  while(cin >> n >> m,n||m) {\n    int cx, cy;\n    char ba[n+2][m+2];\n    memset(ba, '.', sizeof(ba));\n    for (int y=1; y<=m; ++y) {\n      for (int x=1; x<=n; ++x) {\n        cin >> ba[x][y];\n        if (ba[x][y] == '&') {\n          cx = x;\n          cy = y;\n        }\n      }\n    }\n    int ans[n+2][m+2];\n    memset(ans,-1,sizeof(ans));\n    priority_queue<P, vector<P>, greater<P> > Q;\n    Q.push(P(0,pii(0,0)));\n    while(!Q.empty()) {\n      P nwP = Q.top();\n      Q.pop();\n      pii nwp = nwP.second;\n      int x = nwp.first, y = nwp.second;\n      if (ans[x][y] >= 0) continue;\n      //  printf(\"%d,%d\\n\",x,y);\n      ans[x][y] = nwP.first;\n      REP(k,4) {\n        int xx = x+dx[k], yy = y+dy[k];\n        if (ans[xx][yy] >= 0 || xx<0||n+2<=xx||yy<0||m+2<=yy) continue;\n        if (ba[x][y] == '#' && ba[xx][yy] != '#') {\n          Q.push(P(nwP.first+1, pii(xx,yy)));\n        } else {\n          Q.push(P(nwP.first, pii(xx,yy)));\n        }\n      }\n    }\n    // REP(y,m) {\n    //   REP(x,n) {\n    //     cout << ans[x+1][y+1] << \"\" ;\n    //   }\n    //   cout << endl;\n    // }\n    cout << ans[cx][cy] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint H, W;\nchar grid[101][101];\n\nint const dx[4] = {-1,1,0,0};\nint const dy[4] = {0,0,-1,1};\n\nint memo[101][101];\n\ninline bool IN(int x, int y) {\n  return 0<=x && x<W && 0<=y && y<H;\n}\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    \n    int sx, sy;\n    \n    for(int i=0; i<H; i++) {\n      for(int j=0; j<W; j++) {\n        cin >> grid[i][j];\n        if(grid[i][j] == '&') {\n          sx = j, sy = i;\n        }\n      }\n    }\n    \n    memset(memo, -1, sizeof(memo));\n    typedef pair<int, int> Pii;\n    typedef pair<int, Pii> Piii;\n    \n    int ans = 1<<29;\n    \n    priority_queue<Piii> Q;\n    Q.push(Piii(0, Pii(sx, sy)));\n    while(!Q.empty()) {\n      Piii piii = Q.top(); Q.pop();\n      int const x = piii.second.first;\n      int const y = piii.second.second;\n      int const cost = piii.first;\n      \n      for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(IN(nx, ny)) {\n          int ncost = cost + (grid[ny][nx] == '#');\n          if(memo[ny][nx] == -1\n             || memo[ny][nx] > ncost) {\n            memo[ny][nx] = ncost;\n            Q.push(Piii(ncost, Pii(nx, ny)));\n          }\n        } else {\n          ans = min(ans, cost);\n        }\n      }\n    }\n    \n    cout << ans << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n/** 東西の幅 */\nint w;\n#define W 100\n/** 南北の幅 */\nint h;\n#define H 100\n/** 見取り図 */\nchar map[ W ][ H ];\n\n/** 指定された座標が範囲内かを判定する */\n#define nanikaka(X,Y) \\\n  ( (X) >= 0 && (X) < w && (Y) >= 0 && (Y) < h )\n\n/** 速度x 座標 */\n#define VN 4\nconst int vx[ VN ] = { -1,  1,  0,  0 };\nconst int vy[ VN ] = {  0,  0, -1,  1 };\n\n/** 重み付き座標 */\nstruct point\n{\n  int x;\n  int y;\n  int weight;\n\n  point (\n    int x,\n    int y,\n    int weight\n    )\n  {\n    this->x      = x;\n    this->y      = y;\n    this->weight = weight;\n  }\n\n  bool\n  operator> (\n    const point &p\n    )\n  const\n  {\n    return ( weight > p.weight );\n  }\n};\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i, j;\n\n  for ( ; ; )\n  {\n    priority_queue<point, vector<point>, greater<point> > lis;\n\n    /* 基本情報読み込み */\n    scanf ( \" %d %d\", &w, &h );\n    if ( w == 0 && h == 0 ) break ;\n\n    /* 見取り図読み込み */\n    for ( i = 0; i < h; ++i )\n    for ( j = 0; j < w; ++j )\n    {\n      scanf ( \" %c\", &map[ j ][ i ] );\n\n      /* 天守閣を検出したら探索開始点として記録 */\n      if ( map[ j ][ i ] == '&' )\n      {\n        map[ j ][ i ] = '.';\n        lis.push ( point ( j, i, 0 ) );\n      }\n    }\n\n    /* 天守閣から城外方向に堀優先探索 */\n    while ( !lis.empty ( ) )\n    {\n      const point pt = lis.top ( );\n      lis.pop ( );\n\n      /* 城外に到達したら処理終了 */\n      if ( !nanikaka ( pt.x, pt.y ) )\n      {\n        printf ( \"%d\\n\", pt.weight );\n        break ;\n      }\n      /* 既に探索済みなら処理しない */\n      if ( map[ pt.x ][ pt.y ] == '&' )\n        continue ;\n\n      /* 隣接座標の探索を予約．堀脱出な移動には重みを加算． */\n      for ( i = 0; i < VN; ++i )\n      {\n        const int nx = pt.x + vx[ i ];\n        const int ny = pt.y + vy[ i ];\n        lis.push ( point ( nx, ny, pt.weight + !!( nanikaka ( nx, ny )\n                                                && map[ pt.x ][ pt.y ] != '#'\n                                                && map[ nx ][ ny ] == '#' ) ) );\n      }\n      /* 探索済みのマークをつける */\n      map[ pt.x ][ pt.y ] = '&';\n    }\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1 << 30;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, pair<int, int> > PP;\n\nchar M[105][105];\nint v[105][105];\n\nint bfs (int m, int n, P sp )\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tpriority_queue<PP, vector <PP>, greater<PP> > que;\n\tque.push (PP(0, sp ) );\n\t\n\twhile (!que.empty() ){\n\t\tPP curr = que.top(); que.pop();\n\t\tint cost = curr.first;\n\t\tint cr = curr.second.first, cc = curr.second.second;\n\t\tif (cr == 0 || cr == m+1 || cc == 0 || cc == n+1 )\n\t\t\treturn cost;\n\n\t\tif (v[cr][cc] > cost ) \n\t\t\tv[cr][cc] = cost;\n\t\telse\n\t\t\tcontinue;\n\t\trep (k, 4 ){\n\t\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\t\tif (M[cr][cc] == '.' && M[nr][nc] == '#' ){\n\t\t\t\tque.push ( PP (cost+1, P (nr, nc ) ) );\n\t\t\t}else{\n\t\t\t\tque.push ( PP (cost, P (nr, nc ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn -1;\n}\n \nvoid init_map (int m, int n )\n{\n\trep (i, m+2 )\n\t\trep (j, n+2 ){\n\t\t\tM[i][j] = '.';\n\t\t\tv[i][j] = INF;\n\t\t} // end rep\n}\nint main()\n{\n\tint n, m;\t// n: ¼Ì m: ìkÌ \n\n\twhile (cin >> n >> m && n && m ){\n\t\tP sp;\n\t\tinit_map (m, n );\t\n\t\tfor (int i = 1; i <= m; i++ ){\n\t\t\tfor (int j = 1; j <= n; j++ ){\n\t\t\t\tcin >> M[i][j];\n\t\t\t\tif (M[i][j] == '&' ){\n\t\t\t\t\tsp.first = i, sp.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tint res = bfs (m, n, sp );\n\t\tcout << res << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[100];\nchar c[]={'#','.'};\nint w,h,p,sum;\nvoid dfs1(int i,int j){\n  if(i==h||j==w||i<0||j<0)return;\n  if(s[i][j]!=',')return;\n  if(i+1<h)if(s[i+1][j]=='#')s[i+1][j]='.';\n  if(i-1>=0)if(s[i-1][j]=='#')s[i-1][j]='.';\n  if(j+1<w)if(s[i][j+1]=='#')s[i][j+1]='.';\n  if(j-1>=0)if(s[i][j-1]=='#')s[i][j-1]='.';\n  dfs1(i+1,j);\n  dfs1(i-1,j);\n  dfs1(i,j+1);\n  dfs1(i,j-1);\n  if(i==h-1||j==w-1||i*j==0)sum=1;\n}\nvoid dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0)return;\n  if(s[i][j]=='#')return;\n  s[i][j]=',';\n  dfs(i+1,j);\n  dfs(i-1,j);\n  dfs(i,j+1);\n  dfs(i,j-1);\n  if(i==h-1||j==w-1||i*j==0)sum=1;\n}\nmain(){int cc=0;\n  while(cin>>w>>h,w){sum=0;\n    r(i,h)cin>>s[i];\n    int su=0;\n    r(i,h)r(j,w){\n      if(s[i][j]=='&'){\n        p=0;\n        dfs(i,j);if(sum)goto L;\n        su++;p=1;\n        dfs1(i,j);if(sum)goto L;\n      }\n    }\n        L:cout<<su<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n >> m && n+m){\n    vector<vector<char>> v(m+1,vector<char>(n+1,' '));\n    using piii = pair<int,pair<int,int>>;\n    priority_queue<piii> q;\n    vector<vector<int>> d(m+1,vector<int>(n+1,inf));\n    {\n      int x = 0,y = 0;\n      rep(j,m){\n        rep(i,n){\n          cin >> v[j][i];\n          if(v[j][i] == '&'){\n            x = i;\n            y = j;\n          }\n        }\n      }\n      piii pos = mp(0,mp(y,x));\n      d[y][x] = 0;\n      q.push(pos);\n    }\n    int ans = inf;\n    while(q.size()){\n      auto Q = q.top();q.pop();\n      auto p = Q.se;\n      int dpt = Q.fi;\n      int x = p.se,y = p.fi;\n      rep(i,4){\n        int nx = x + dx[i],ny = y + dy[i];\n        if(value(nx,ny,n,m)){\n          if(v[y][x] == v[ny][nx] && d[ny][nx] > d[y][x]){\n            d[ny][nx] = d[y][x];\n            q.push(mp(-dpt,mp(ny,nx)));\n          }\n          else if(d[ny][nx] > d[y][x] + (v[ny][nx] == '#')){\n            d[ny][nx] = (v[ny][nx] == '#') + d[y][x];\n            q.push(mp(-(dpt+1),mp(ny,nx)));\n          }\n        }\n        else{\n          ans = min(ans,d[y][x]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint dp[110][110];\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tvector<string>in(n);\n\t\trep(i,n)cin>>in[i];\n\t\tqueue<pip>q;\n\t\tint sx,sy;\n\t\trep(i,110)rep(j,110)dp[i][j]=inf;\n\t\trep(i,n)rep(j,m)if(i==0||j==0||i==n-1||j==m-1){\n\t\t\tif(in[i][j]!='#'){\n\t\t\t\tq.push(pip(i,pii(j,0)));\n\t\t\t\tdp[i][j]=0;\n\t\t\t}else{\n\t\t\t\tq.push(pip(i,pii(j,1)));\n\t\t\t\tdp[i][j]=1;\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,m)if(in[i][j]=='&')sx=i,sy=j;\n\t\twhile(!q.empty()){\n\t\t\tpip p=q.front();\n\t\t\tq.pop();\n\t\t\tint x=p.first,y=p.second.first,cost=p.second.second;\n//\t\t\tcout<<x<<\" \"<<y<<\" \"<<cost<<endl;\n\t\t\tif(dp[x][y]<cost)continue;\n\t\t\trep(k,4){\n\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tint ncost=cost+(in[nx][ny]=='#'?1:0);\n//\t\t\t\tcout<<\" \"<<nx<<\" \"<<ny<<\" \"<<ncost<<endl;\n\t\t\t\tif(dp[nx][ny]>ncost){\n\t\t\t\t\tdp[nx][ny]=ncost;\n\t\t\t\t\tq.push(pip(nx,pii(ny,ncost)));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<dp[sx][sy]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n#include <limits.h>\nusing namespace std;\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int x_,int y_):x(x_),y(y_){}\n};\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint main(void)\n{\n\twhile(1){\n\t\tint w,h;\n\t\tint field[105][105] = {};\n\t\tint costfield[105][105];\n\t\tPoint gPoint(0,0);\n\t\tcin >> w >> h;\n\n\t\tfor(int i=0;i<105;++i){\n\t\t\tfor(int j=0;j<105;++j){\n\t\t\t\tcostfield[i][j] = INT_MAX;\n\t\t\t\tif(i==0||j==0||i==h+3||j==w+3)\n\t\t\t\t\tcostfield[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tif(w == 0 && h == 0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=h+2;++y){\n\t\t\tfor(int x=1;x<=w+2;++x){\n\t\t\t\tif(x==1 || y==1 || x==w+2 || y==h+2)\n\t\t\t\t{\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tscanf(\" %c\",&field[y][x]);\n\t\t\t\t\tif(field[y][x] == '&')\n\t\t\t\t\t\tgPoint = Point(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcostfield[1][1] = 0;\n\n\t\tqueue<Point> que;\n\t\tque.push(Point(1,1));\n\t\twhile(!que.empty()){\n\t\t\tPoint now = que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tPoint next(now.x+dx[i],now.y+dy[i]);\n\t\t\t\tint c = costfield[now.y][now.x] + (field[now.y][now.x] == '.' && field[next.y][next.x] == '#' ? 1 : 0);\n\t\t\t\tif(c < costfield[next.y][next.x]){\n\t\t\t\t\tcostfield[next.y][next.x] = c;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << costfield[gPoint.y][gPoint.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j] = 1000000000;\n\t\t\t\tdist[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H; queue<pair<int, int>>Q;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] >= 2) { continue; }\n\t\t\t\tint dis = dist[cx][cy];\n\t\t\t\tif (X[cx][cy] == 0 && X[ex][ey] == 1) {\n\t\t\t\t\tdis += 1;\n\t\t\t\t}\n\t\t\t\tif (dist[ex][ey]>dis) {\n\t\t\t\t\tdist[ex][ey] = dis;\n\t\t\t\t\tQ.push(make_pair(ex, ey));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nchar field[101][101];\nbool passed[101][101];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint h,w;\n// ×ÚÇÀWÌXg\nset<pair<int,int> > walls;\nset<pair<int,int> > spList;\n\n\nbool bfs(int sx,int sy,bool w){\n\t// Ü¸ÊÉbfs\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\t\n\tprv->push(make_pair(sy,sx));\n\tbool fin=false;\n\tpassed[sy][sx]=true;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> p = prv->front();\n\t\t\tprv->pop();\n\t\t\t// ÇÉBµ½çAI¹\n\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// lûüÉÚ®\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\tif(!passed[ny][nx]){\n\t\t\t\t\tif(w){\n\t\t\t\t\t\tif(field[ny][nx]=='.'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t\t\t\t\twalls.insert(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(field[ny][nx]=='#'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t\tpassed[ny][nx]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]='.'){\n\t\t\t\t\t\t\tspList.insert(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\treturn false;\n}\n\nint main(){\n\n\t// ÇÉÕË·éÜÅbfsðJè©¦·\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\twalls.clear();\n\t\tspList.clear();\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='&')\n\t\t\t\t\tsx=j,sy=i;\n\t\t\t}\n\t\t\tfill(passed[i],passed[i]+w,false);\n\t\t}\n\t\tint cnt=0;\n\t\tbool fin=false;\n\t\tspList.insert(make_pair(sy,sx));\n\t\twhile(1){\n\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n\t\t\tfor(set<pair<int,int> >::iterator it = spList.begin(); it != spList.end(); it++){\n\t\t\t\tint cx=it->second;\n\t\t\t\tint cy=it->first;\n\t\t\t\tif(bfs(cx,cy,true)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tspList.clear();\n\t\t\tcnt++;\n\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n\t\t\tfor(set<pair<int,int> >::iterator it = walls.begin(); it != walls.end(); it++){\n\t\t\t\tint cx=it->second;\n\t\t\t\tint cy=it->first;\n\t\t\t\tif(bfs(cx,cy,false)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\twalls.clear();\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<vector<char> > VVC;\n\nclass Pox\n{\npublic:\n  P p;\n  int cost;\n  Pox(P p = P(0,0),int cost = 0):p(p),cost(cost){}\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint h,w;\n\nvoid print(VVC G)\n{\n  cout << \"---print---\" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\tcout << G[i][j];\n      cout << endl;\n\n    }\n  cout << endl;\n\n}\n\nvoid draw(VVC& G,P p)\n{\n\n  for(int i=0;i<4;i++)\n    {\n      int nx = p.F + dx[i];\n      int ny = p.S + dy[i];\n      if(!(1<=ny&&ny<=h && 1<=nx&&nx<=w))\n\tcontinue;\n      if(G[ny][nx] == '&' || G[ny][nx] == '#')\n\tcontinue;\n      G[ny][nx] = '&';\n      draw(G,P(nx,ny));\n    }\n  \n}\n\nint main()\n{\n  \n  while(cin >> w >> h,(w||h))\n    {\n      cerr << w << \" \" << h << endl;\n      VVC G;\n      P ed;\n      G.resize(h+2);\n      deque<Pox> deq;\n      int mincost[h+3][w+3];\n      for(int i=0;i<=h+1;i++)\n\t{\n\t  G[i].resize(w+2);\n\t  string line;\n\t  if(i == 0 || i == h+1)\n\t    line = string(h+2,'.');\n\t  else\n\t    cin >> line;\n\t  cerr << line << endl;\n\t  //cout << \"line = \" << line << endl;\n\t  for(int j=0;j<=w+1;j++)\n\t    {\n\t      mincost[i][j] = (1<<28);\n\t      if(i == 0 || j == 0 || i == h+1 || j == w+1)\n\t\t{\n\t\t  G[i][j] = '.';\n\t\t  deq.push_back(Pox(P(j,i),0));\n\t\t  mincost[i][j] = 0;\n\t \t  continue;\n\t\t}\n\t      G[i][j] = line[j-1];\n\t      if(G[i][j] == '&')\n\t\ted = P(j,i);\n\t    }\n\t}\n\n\n     \n      draw(G,ed);\n     \n      int men = (1<<28);\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  P p = pox.p;\n\t  int cost = pox.cost;\n\t  if(G[p.S][p.F] == '&')\n\t    {\n\t      men = min(men,cost);\n\t      break;\n\t    }\n\n\t  for(int i=0;i<4;i++)\n\t    {\n\t      int nx = p.F + dx[i];\n\t      int ny = p.S + dy[i];\n\n\t      if(!(1<=nx&&nx<=w && 1<=ny&&ny<=h))\n\t\tcontinue;\n\n\t      int d = G[ny][nx]=='#'?1:0;\n\t      if(mincost[ny][nx] > cost + d)\n\t\t{\n\t\t  mincost[ny][nx] = cost + d;\n\t\t  deq.push_back(Pox(P(nx,ny),mincost[ny][nx]));\n\t\t}\n\t    }\n\n\t}\n      cout << men << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nint h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\tgx++; gy++;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\t//rep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\t//rep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\tq.push(mp(0, gx)); q.push(mp(0, (h+1)*1000+gx));\n\t\tq.push(mp(0, gy*1000)); q.push(mp(0, gy*1000+w+1));\n\t\trep(i, h) {\n\t\t\tif(C[i][0]!='#') q.push(mp(0,(i+1)*1000+1));\n\t\t\tif(C[i][w-1]!='#') q.push(mp(0,(i+1)*1000+w));\n\t\t}\n\t\trep(i, w) {\n\t\t\tif(C[h-1][i]!='#') q.push(mp(0,(h)*1000+i+1));\n\t\t\tif(C[0][i]!='#') q.push(mp(0,1000+i+1));\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tif(ny==gy && nx == gx) break;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy][gx]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint n,m,ans;\nchar f[110][110];\n\nint di[4]={0,0,1,-1};\nint dj[4]={1,-1,0,0};\n\nclass Info{\npublic:\n\tint i,j,walk;\n};\n\nvoid bfs(int i,int j){\n\tint k,l,w[110][110];\n\tqueue<Info> q;\n\tInfo tmp = {i,j,0};\n\n\tif(f[i][j] == 'G'){ans = 0; return;}\n\tfor(k=0;k<110;k++) for(l=0;l<110;l++) w[k][l] = 99999;\n\n\tw[i][j] = 0;\n\tans = 99999;\n\tq.push(tmp);\n\n\twhile(!q.empty()){\n\t\ttmp = q.front(); q.pop();\n\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = tmp.i + di[k];\n\t\t\tint nj = tmp.j + dj[k];\n\t\t\tint nwalk = tmp.walk;\n\n\t\t\tif(f[tmp.i][tmp.j] == '.' && f[ni][nj] == '#') nwalk++;\n\n\t\t\tif(f[ni][nj] == 'G'){\n\t\t\t\tif(ans > tmp.walk) ans = tmp.walk;\n\t\t\t}\n\t\t\telse if(nwalk < w[ni][nj]){\n\t\t\t\tInfo tmp2 = {ni,nj,nwalk};\n\n\t\t\t\tw[ni][nj] = nwalk;\n\t\t\t\tq.push(tmp2);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int i,int j){\n\tf[i][j] = 'G';\n\tfor(int k=0;k<4;k++){\n\t\tint ni = i + di[k];\n\t\tint nj = j + dj[k];\n\t\tif(f[ni][nj] == '.') dfs(ni,nj);\n\t}\n}\n\nint main(void){\n\tint i,j,si,sj;\n\n\twhile(cin>>n>>m && (n || m)){\n\t\tmemset(f,'.',sizeof(f));\n\t\tfor(i=1;i<=m;i++){\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tcin>>f[i][j];\n\t\t\t\tif(f[i][j] == '&'){f[i][j]='.'; si=i; sj=j;}\n\t\t\t}\n\t\t}\n\n\t\tdfs(0,0);\n\t\tbfs(si,sj);\n\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define repa(i,s,e) for(int i=s; i<=e; i++)\n#define repd(i,s,e) for(int i=s; i>=e; i--)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint N, M;\nstring line;\nvector<string> field;\n\nconst int MAX_V = 11000;\nconst int INF = 1000000009;\nint V;\nstruct edge { int to, cap, cost, rev; };\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V];\nint preve[MAX_V];\n\nint dx[4] = {-1, 0, 0, 1};\nint dy[4] = {0, -1, 1, 0};\n\nvoid add_edge(int from, int to, int cap, int cost) {\n\tedge e1 = { to, cap, cost, G[to].size() };\n\tedge e2 = { from, 0, -cost, G[from].size() };\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\n\nvoid bellman_ford(int s) {\n\tfill(dist, dist+V, INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update) {\n\t\tupdate = false;\n\t\trep(v,V) {\n\t\t\tif(dist[v] == INF) continue;\n\t\t\trep(i,G[v].size()) {\n\t\t\t\tedge& e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\twhile(f > 0) {\n\t\tbellman_ford(s);\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor(int v=t; v!=s; v=prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tres += d * dist[t];\n\t\tf -= d;\n\t\tfor(int v=t; v!=s; v=prevv[v]) {\n\t\t\tedge& e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tV = N * M + 2;\n\tint s = V - 2;\n\tint t = V - 1;\n\trep(v,V) G[v].clear();\n\n\trep(y,M) {\n\t\trep(x,N) {\n\t\t\tif(field[y][x] == '&') {\n\t\t\t\tadd_edge(y*N+x, t, 1, 0);\n\t\t\t}\n\t\t\trep(k,4) {\n\t\t\t\tint xx = x + dx[k];\n\t\t\t\tint yy = y + dy[k];\n\t\t\t\tif(xx >= 0 && yy >= 0 && xx < N && yy < M) {\n\t\t\t\t\tif(field[y][x] == '.' && field[yy][xx] == '#') {\n\t\t\t\t\t\tadd_edge(y*N+x, yy*N+xx, 1, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tadd_edge(y*N+x, yy*N+xx, 1, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(y,M) {\n\t\tif(field[y][0] == '#') {\n\t\t\tadd_edge(s, y*N+0, 1, 1); \n\t\t} else {\n\t\t\tadd_edge(s, y*N+0, 1, 0); \n\t\t}\n\n\t\tif(field[y][N-1] == '#') {\n\t\t\tadd_edge(s, y*N+N-1, 1, 1); \n\t\t} else {\n\t\t\tadd_edge(s, y*N+N-1, 1, 0); \t\t\t\n\t\t}\n\t}\n\n\trepa(x,1,N-2) {\n\t\tif(field[0][x] == '#') {\n\t\t\tadd_edge(s, 0*N+x, 1, 1);\n\t\t} else {\n\t\t\tadd_edge(s, 0*N+x, 1, 0);\n\t\t}\n\n\t\tif(field[M-1][x] == '#') {\n\t\t\tadd_edge(s, (M-1)*N+x, 1, 1);\n\t\t} else {\n\t\t\tadd_edge(s, (M-1)*N+x, 1, 0);\t\t\t\n\t\t}\n\t}\n\t\n\tint res = min_cost_flow(s, t, 1);\n\tcout << res << endl;\n}\n\nint main() {\n\twhile(scanf(\"%d%d\", &N, &M), N|M) {\n\t\tfield.clear();\n\t\trep(i,M) {\n\t\t\tcin >> line;\n\t\t\tfield.push_back(line);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1 << 30;\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, pair<int, int> > PP;\n\nchar M[105][105];\nint v[105][105];\n\nint bfs (int m, int n, P sp )\n{\n\tconst int dir[][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\n\tpriority_queue<PP, vector <PP>, greater<PP> > que;\n\tque.push (PP(0, sp ) );\n\t\n\twhile (!que.empty() ){\n\t\tPP curr = que.top(); que.pop();\n\t\tint cost = curr.first;\n\t\tint cr = curr.second.first, cc = curr.second.second;\n\t\tif (v[cr][cc] > cost ) \n\t\t\tv[cr][cc] = cost;\n\t\telse\n\t\t\tcontinue;\n\t\trep (k, 4 ){\n\t\t\tint nr = cr + dir[k][0], nc = cc + dir[k][1];\n\t\t\tif (nr < 0 || nr > m+1 || nc < 0 || nc > n+1 )\n\t\t\t\treturn cost;\n\t\t\tif (M[cr][cc] == '.' && M[nr][nc] == '#' ){\n\t\t\t\tque.push ( PP (cost+1, P (nr, nc ) ) );\n\t\t\t}else{\n\t\t\t\tque.push ( PP (cost, P (nr, nc ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\n\n\treturn -1;\n}\n \nvoid init_map (int m, int n )\n{\n\trep (i, m+2 )\n\t\trep (j, n+2 ){\n\t\t\tM[i][j] = '.';\n\t\t\tv[i][j] = INF;\n\t\t} // end rep\n}\nint main()\n{\n\tint n, m;\t// n: ¼Ì m: ìkÌ \n\n\twhile (cin >> n >> m && n && m ){\n\t\tP sp;\n\t\tinit_map (m, n );\t\n\t\tfor (int i = 1; i <= m; i++ ){\n\t\t\tfor (int j = 1; j <= n; j++ ){\n\t\t\t\tcin >> M[i][j];\n\t\t\t\tif (M[i][j] == '&' ){\n\t\t\t\t\tsp.first = i, sp.second = j;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end for\n\t\tint res = bfs (m, n, sp );\n\t\tcout << res << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <utility>\n \nusing namespace std;\n \nint INF = 1 << 28;\nint n;\nint m;\nchar map[100][100];\nint visited[100][100];\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { 1, 0, -1, 0 };\nint ans;\n \nvoid solve(pair<int,int> pos, int c) {\n \n    int x = pos.first;\n    int y = pos.second;\n    \n    if (visited[y][x] <= c)\n        return;\n    visited[y][x] = c;\n    if (ans <= c) {\n        return;\n    }\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\t\tif (nx < 0 || ny < 0 || nx >= n || ny >= m) {\n        ans = c;\n        return;\n    }\n            solve(make_pair(nx, ny), c + ((map[y][x] != '#' && map[ny][nx] == '#') ? 1 : 0));\n    }\n}\n \nint main(){\n    while (1) {\n        ans = INF;\n        cin>>n;\n        cin>>m;\n        if ((n | m) == 0)\n            break;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                cin >> map[i][j];\n                visited[i][j] = INF;\n            }\n        }\n        int sx = 0;\n        int sy = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (map[i][j] == '&') {\n                    sx = j;\n                    sy = i;\n                    i = INF;\n                    break;\n                }\n            }\n        }\n        solve(make_pair(sx,sy), 0);\n \n        cout <<ans<<\"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nbool ingrid(int x, int y, int w, int h)\n{\n\treturn x >= 0 && x <= w + 1 && y >= 0 && y <= h + 1;\n}\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tpriority_queue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\t//res = st.d;\n\t\t\t\t//break;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (!ingrid(tx, ty, w, h)) continue;\n\t\t\t\tif (d[tx][ty] > st.d + (grid[st.x][st.y] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[st.x][st.y] == '#')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", d[0][0]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint h, w;\nchar mapData[100][100];\nbool visited[100][100];\nint gx, gy;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nint height[100][100];\nint p;\n\nvoid dfs(int y, int x){\n  height[y][x] = p;\n  for(int i=0;i<4;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty < 0 || ty >= h) continue;\n    if(tx < 0 || tx >= w) continue;\n    if(mapData[ty][tx] == '#') continue;\n    if(height[ty][tx] == p && visited[ty][tx]) continue;\n    if(height[ty][tx] < p) return;\n    visited[ty][tx] = true;\n    dfs(ty, tx);\n  }\n}\n\nint solve(){\n  fill(height[0], height[100], INF);\n  int cnt;\n  for(int j=0;j<w;j++){//top to bottom\n    cnt = 0;\n    for(int i=0;i<h;i++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//left to right\n    cnt = 0;\n    for(int j=w-1;j>=0;j--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n\theight[i][j] = min(height[i][j], cnt);\n      }\n    }\n  }\n  for(int j=0;j<w;j++){//bottom to top\n    cnt = 0;\n    for(int i=h-1;i>=0;i--){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\t\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  for(int i=0;i<h;i++){//right to left\n    cnt = 0;\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#'){\n\theight[i][j] = -1;\n\tcnt++;\n      }\n      height[i][j] = min(height[i][j], cnt);\n    }\n  }\n  fill(visited[0], visited[100], false);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(mapData[i][j] == '#' || visited[i][j]) continue;\n      p = height[i][j];\n      dfs(i, j);\n    }\n  }\n  return height[gy][gx];\n}\n\nmain(){\n  while(cin >> w >> h && (h || w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> mapData[i][j];\n\tif(mapData[i][j] == '&'){\n\t  mapData[i][j] = '.';\n\t  gy = i;\n\t  gx = j;\n\t}\n      }\n    }\n    cout << solve() << endl;\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcout << setw(2) << height[i][j];\n      }\n      cout << endl;\n      }*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nstring s[100];\nchar c[]={'#','.'};\nint a,b,p1,p2,dx[]={1,-1,0,0},dy[]={0,0-1,1};\nint dfs(int y,int x){\n  int sum=0;\n  s[y][x]=c[p1];\n  if(y==0||x==0||y==a-1||x==b-1)return 1;\n  r(i,4)if(x+dx[i]>=0&&dx[i]+x<b&&y+dy[i]>=0&&dy[i]+y<a)\n    if(s[y+dy[i]][x+dx[i]]==c[p2])\n      sum=dfs(y+dy[i],x+dx[i]);\n  return sum;\n}\nmain(){\n  while(cin>>b>>a,a){\n    r(i,a)cin>>s[i];\n    int su=0;\n    r(i,a)r(j,b){\n      if(s[i][j]=='&'){\n        p1=0;p2=1;\n        if(dfs(i,j))goto L;\n        p1=1;p2=0;\n        su++;\n        if(dfs(i,j))goto L;\n      }\n    }\n    L:cout<<su<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid print(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cout << T[i][j];\n    cout << endl;\n  }\n\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n\n      if(M[ny][nx] == '#' && T[ny][nx] > s.t+1){\n\tT[ny][nx] = s.t+1;\n\tQ.push(State(nx,ny,s.t+1));\n      }\n\n      if(M[ny][nx] != '#' && T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n  cerr << ans << endl;\n  //  print();\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    input();\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar field[101][101];\nbool passed[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nqueue<pair<int,int> > *prv;\nqueue<pair<int,int> > *nxt;\n\nbool ok;\n\nvoid dfs(int y,int x){\n    if(y==h-1||y==0||x==0||x==w-1){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]){\n            passed[ny][nx]=true;\n            // ツ堀ツづ按づァnxtツづ英ushツつオツづ終ツ猟ケ\n            if(field[ny][nx]=='#')\n                nxt->push(make_pair(ny,nx));\n            else\n                dfs(ny,nx);\n            if(ok)return;\n        }\n    }\n}\nint main(){\n    prv=new queue<pair<int,int> >();\n    nxt=new queue<pair<int,int> >();\n    while(cin>>w>>h&&!(h==0&&w==0)){\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        int sy,sx;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n                if(field[i][j]=='&'){\n                    sy=i;\n                    sx=j;\n                    field[i][j]='.';\n                }\n            }\n        }\n        prv->push(make_pair(sy,sx));\n        int cnt=0;\n        while(prv->size()){\n            while(prv->size()){\n                pair<int,int> &p=prv->front();\n                passed[p.first][p.second]=true;\n                dfs(prv->front().first,prv->front().second);\n                prv->pop();\n            }\n            if(ok)break;\n            swap(prv,nxt);\n            cnt++;\n        }\n        cout<<cnt<<endl;\n        while(prv->size())prv->pop();\n        while(nxt->size())nxt->pop();\n    }\n    delete nxt;\n    delete prv;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int n,m;\n  while(cin>>n>>m,n|m){\n    char zu[m][n];\n    int sx,sy;\n    rep(i,m){\n      rep(j,n){\n        cin>>zu[i][j];\n        if(zu[i][j]=='&')sx=i,sy=j;\n      }\n    }\n\n    int dp[m][n];\n    memset(dp,-1,sizeof(dp));\n\n    queue<PI> Q;\n    Q.push(mp(sx,sy));\n    dp[sx][sy]=0;\n    zu[sx][sy]='.';\n    int bury=1;\n\n    while(bury<m*n){\n      queue<PI> nQ;\n      while(!Q.empty()){\n        int cx=Q.front().f,cy=Q.front().s;Q.pop();\n        rep(i,4){\n          int nx=cx+dx[i],ny=cy+dy[i];\n          if(nx<0 || nx>=m || ny<0 || ny>=n || dp[nx][ny]!=-1)continue;\n          if(zu[nx][ny]!=zu[cx][cy]){\n            dp[nx][ny]=dp[cx][cy]+1;\n            ++bury;\n            nQ.push(mp(nx,ny));\n          }else{\n            dp[nx][ny]=dp[cx][cy];\n            ++bury;\n            Q.push(mp(nx,ny));\n          }\n        }\n      }\n      Q=nQ;\n    }\n/*\n    rep(i,m){\n      rep(j,n)printf(\"%2d\",dp[i][j]);\n      cout<<endl;\n    }\n*/   \n    int ans=dp[0][0];\n    rep(i,n){\n      ans=min(ans,dp[0][i]);\n      ans=min(ans,dp[m-1][i]);\n    }\n    rep(i,m){\n      ans=min(ans,dp[i][0]);\n      ans=min(ans,dp[i][n-1]);\n    }\n    cout<<(1+ans)/2<<endl;\n  }\n}\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid print(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cout << T[i][j];\n    cout << endl;\n  }\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n\n      if(M[ny][nx] == '#'){\n\tif(M[s.y][s.x] == '#' && T[ny][nx] > s.t){\n\t  T[ny][nx] = s.t;\n\t  Q.push(State(nx,ny,s.t+1));\n\t}\n\tif(M[s.y][s.x] != '#' && T[ny][nx] > s.t+1){\n\t  T[ny][nx] = s.t+1;\n\t  Q.push(State(nx,ny,s.t+1));\n\t}\n      }else if(T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n  //  print();\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    input();\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[120][120];\nint jp[120][120];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=m;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tque.push(PP(P(i,0),0));\n\t\tjp[i][0]=0;\n\t\tque.push(PP(P(i,m+1),0));\n\t\tjp[i][m+1]=0;\n\t}\n\tfor(int i=0;i<=m;i++){\n\t\tque.push(PP(P(0,i),0));\n\t\tjp[0][i]=0;\n\t\tque.push(PP(P(n+1,i),0));\n\t\tjp[n+1][i]=0;\n\t}\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(kx>=0 && kx<=n+1 && ky>=0 && ky<=m+1){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='&' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcin >> fie[j][i];\n\t\t\t\tif(fie[j][i]=='&')gx=j,gy=i;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",jp[gx][gy]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> State;\nconst int INF = 1e+8;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\n// デバッグ出力\nvoid debug(const vector<string>& m){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < m.size() ; y++ )\n\t\tcout << m[y] << endl;\n}\n\n// 幅と高さ\nint w, h;\n\n// ゴールの位置を調べる\nP search_goal(vector<string>& m){\n\tint gx, gy;\n\tfor(int y = 0 ; y < h ; y++ ){\n\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == '&' ){\n\t\t\t\tm[y][x] = '.';\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn P(gx,gy);\n}\n\nint solve(vector<string>& m){\t\n\t// n := ノード数\n\tint n = w * h; \n\t// d[y][x] := (x,y) への最小コスト, まだ確定していないときはINF\n\tint d[110][110];\n\t// used[y][x] := (x,y) が探索済みかどうか\n\tbool used[110][110];\n\t// 初期化\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t\tused[y][x] = false;\n\t\t}\n\t}\n\t\n\t// ゴールの位置を調べる\n\tP gp = search_goal( m );\n\tint gx = gp.first;\n\tint gy = gp.second;\n\t\n\t// (x,y)=(0,0) を始点として探索する\n\tpriority_queue< State , vector<State> , greater<State> > q;\n\tq.push( State( 0 , P(0,0) ) );\n\td[0][0] = 0;\n\t\n\tint result = INF;\n\twhile( !q.empty() ){\n\t\t// コストの小さい座標から順に出てくる\n\t\tint cost = q.top().first;\n\t\tint x = q.top().second.first;\n\t\tint y = q.top().second.second;\n\t\tq.pop();\n\t\t// 座標 (x,y) を確定ノードにする\n\t\tused[y][x] = true;\n\t\t\n\t\t// ゴールのとき\n\t\tif( x == gx && y == gy ){\n\t\t\tresult = min( result , cost );\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\t\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h || used[my][mx] ) continue;\n\t\t\t\n\t\t\tint next_cost = cost;\n\t\t\tif( m[my][mx] == '#' ){\n\t\t\t\tnext_cost++;\n\t\t\t}\n\t\t\tif( next_cost < d[my][mx] ){\n\t\t\t\td[my][mx] = next_cost;\n\t\t\t\tState next( next_cost , P(mx,my) );\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\t// debug\n\t// debug( m );\n\t/* for(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( d[y][x] == INF ){\n\t\t\t\tcout << \"?\";\n\t\t\t}else{\n\t\t\t\tcout << d[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}*/\n\treturn result;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tvector<string> m(h+2);\n\t\tstring t;\n\t\tfor(int i=0 ; i < w+2 ; i++ ){\n\t\t\tt.push_back('.');\n\t\t}\n\t\tm[0] = m[h+1] = t;\n\t\t\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tstring s, s_;\n\t\t\tcin >> s;\n\t\t\ts_ = \".\" + s + \".\";\n\t\t\tm[y] = s_;\n\t\t}\n\t\tw += 2;\n\t\th += 2;\n\t\tcout << solve( m ) << endl;\n\t\t//debug2();\n\t\t//int ans = d[gy][gx];\n\t\t//cout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct St{\n\tint x, y, c;\n\tSt(int cst, P p): c(cst), y(p.first), x(p.second) {}\n\tbool operator>(const St &s) const{\n\t\treturn c > s.c;\n\t}\n};\n\nconst int inf = 999999;\nint xdir[4] = {0, -1, 0, 1}, ydir[4] = {1, 0, -1, 0};\nint bfs(char a[101][101], int w, int h, P p)\n{\n\tint r = -1, vis[101][101];\n\tpriority_queue<St, vector<St>, greater<St>> que;\n\tfill(&vis[0][0], &vis[h][w], inf);\n\tvis[p.first][p.second] = 0;\n\tque.push(St(0, p));\n\twhile(!que.empty()){\n\t\tSt s = que.top();\n\t\tque.pop();\n\t\tif(s.x < 0 || s.x >= w || s.y < 0 || s.y >= h){\n\t\t\tr = s.c;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint dy = s.y+ydir[i], dx = s.x+xdir[i];\n\t\t\tif(dy < 0 || dy >= h || dx < 0 || dx >= w){\n\t\t\t\tSt t = (a[s.y][s.x] == '#')? St((s.c+1), P(dy, dx)): St(s.c, P(dy, dx));\n\t\t\t\tque.push(t);\n\t\t\t} else if(vis[dy][dx] > s.c){\n\t\t\t\tint u = inf;\n\t\t\t\tif(a[s.y][s.x] == '#' && a[dy][dx] == '.'){\n\t\t\t\t\tu = s.c+1;\n\t\t\t\t} else {\n\t\t\t\t\tu = s.c;\n\t\t\t\t}\n\t\t\t\tif(u < vis[dy][dx]){\n\t\t\t\t\tvis[dy][dx] = u;\n\t\t\t\t\tque.push(St(u, P(dy, dx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint main()\n{\n\tint w, h;\n\tchar a[101][101];\n\tP p;\n\t\n\twhile(cin>>w>>h && (w+h)){\n\t\tfor(int i =0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif(a[i][j] == '&'){\n\t\t\t\t\tp = P(i, j);\n\t\t\t\t\ta[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << bfs(a, w, h, p) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> State;\nconst int INF = 1e+9;\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\n\nvoid debug(const vector<string>& m){\n\tfor(int y=0 ; y < m.size() ; y++ )\n\t\tcout << m[y] << endl;\n}\n\n// Æ³\nint w, h;\n// d[y][x] Í(y,x)ÌÅ¬RXg, Ü¾mèµÄ¢È¢Æ«ÍINF\nint d[110][110];\n// used[p] ÍP p=(x,y)ªTõÏÝ©Ç¤©\nmap<P,bool> used;\n// n ÍÀWÌ(=w*h)\nint n;\n// S[ÌÊu\nint gx, gy;\n\nvoid debug2(){\n\tcout << \"d:\" << endl;\n\tfor(int y = 0 ; y < h ; y++ ){\n\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\tif( d[y][x] == INF ){\n\t\t\t\tcout << '?';\n\t\t\t}else if( d[y][x] >= 0 && d[y][x] <= 9 ){\n\t\t\t\tcout << d[y][x];\n\t\t\t}else{\n\t\t\t\tcout << 9;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n// S[ÌÊuð²×é\nvoid search_goal(vector<string>& m){\n\tfor(int y = 0 ; y < h ; y++ ){\n\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\tif( m[y][x] == '&' ){\n\t\t\t\tm[y][x] = '.';\n\t\t\t\tgx = x;\n\t\t\t\tgy = y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(vector<string>& m){\n\t// ú»\n\tw += 2;\n\th += 2;\n\tn = w * h;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t\tused[P(x,y)] = false;\n\t\t}\n\t}\n\t// S[ÌÊuð²×é\n\tsearch_goal( m );\n\t\n\t// (x,y)=(0,0) ðn_ÆµÄTõ·é\n\tP sp(0,0);\n\td[0][0] = 0;\n\tused[sp] = true;\n\t// State s; ÉÂ¢Ä s.first ÍRXg, s.second ÍÀW(pair<int,int>)\n\tState ini( 0 , sp );\n\tpriority_queue< State , vector<State> , greater<State> > q;\n\tq.push( ini );\n\t\n\twhile( !q.empty() ){\n\t\t// RXgÌ¬³¢ÀW©çÉoÄ­é\n\t\tint cost = q.top().first;\n\t\tP p = q.top().second;\n\t\tq.pop();\n\t\t// ÀW p ðmèm[hÉ·é\n\t\tused[p] = true;\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = p.first + dx[i];\n\t\t\tint my = p.second + dy[i];\n\t\t\tP next_p(mx,my);\n\t\t\t\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h || used[next_p] == true ) continue;\n\t\t\t\n\t\t\tint next_cost;\n\t\t\tif( m[my][mx] == '#' ){\n\t\t\t\td[my][mx] = min( d[my][mx] , cost + 1 );\n\t\t\t\tnext_cost = cost + 1;\n\t\t\t}else if( m[my][mx] == '.' ){\n\t\t\t\td[my][mx] = min( d[my][mx] , cost );\n\t\t\t\tnext_cost = cost;\n\t\t\t}\n\t\t\tState next( next_cost , next_p );\n\t\t\tq.push( next );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tvector<string> m(h+2);\n\t\tstring t;\n\t\tfor(int i=0 ; i < w+2 ; i++ )\n\t\t\tt.push_back('.');\n\t\tm[0] = m[h+1] = t;\n\t\t\n\t\tfor(int y = 1 ; y <= h ; y++ ){\n\t\t\tstring s, s_;\n\t\t\tcin >> s;\n\t\t\ts_ = \".\" + s + \".\";\n\t\t\tm[y] = s_;\n\t\t}\n\t\t//debug( m );\n\t\tsolve( m );\n\t\t//debug2();\n\t\tint ans = d[gy][gx];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; memset(dist, 10, sizeof(dist)); queue<pair<int, int> >Q;\n\t\tmemset(X, 10, sizeof(X));\n\t\tif (W == 0 && H == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c; if (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop(); int cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] <= 1) {\n\t\t\t\t\tint dis = dist[cx][cy] + X[ex][ey];\n\t\t\t\t\tif (dist[ex][ey] > dis) {\n\t\t\t\t\t\tdist[ex][ey] = dis; Q.push(make_pair(ex, ey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\n\nint main() {\n    int n, m;\n    array<int, 4> dx{-1, 1, 0, 0}, dy{0, 0, -1, 1};\n    while(cin >> m >> n, n){\n        auto G = make_v(n+4, m+4, -1);\n        for (int i = 1; i < n+3; ++i) {\n            for (int j = 1; j < m+3; ++j) {\n                G[i][j] = 1;\n            }\n        }\n        int gx = 0, gy = 0;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            for (int j = 0; j < m; ++j) {\n                G[i+2][j+2] = (s[j] != '#');\n                if(s[j] == '&'){\n                    gy = i+2, gx = j+2;\n                }\n            }\n        }\n        auto dp = make_v(n+4, m+4, -1);\n        dp[1][1] = 0;\n        deque<pair<int, int>> Q;\n        Q.emplace_back(1, 1);\n        while(!Q.empty()){\n            int y, x; tie(y, x) = Q.front(); Q.pop_front();\n            for (int k = 0; k < 4; ++k) {\n                if(!~G[y+dy[k]][x+dx[k]] || ~dp[y+dy[k]][x+dx[k]]) continue;\n                if(G[y][x] == G[y+dy[k]][x+dx[k]]){\n                    dp[y+dy[k]][x+dx[k]] = dp[y][x];\n                    Q.emplace_front(y+dy[k], x+dx[k]);\n                }else {\n                    dp[y+dy[k]][x+dx[k]] = dp[y][x]+1;\n                    Q.emplace_back(y+dy[k], x+dx[k]);\n                }\n            }\n        }\n        cout << dp[gy][gx]/2 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\nnamespace orislib {\nstruct Edge {\n  typedef int weight_t;\n  int from, to;\n  weight_t w;\n  Edge(int from, int to, weight_t w) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& e) const {\n    return w != e.w ? w > e.w : from != e.from ? from < e.from : to < e.to;\n  }\n  static const weight_t INF;\n};\nconst int Edge::INF=INT_MAX;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n}\n#endif\n//}}}\n\nusing namespace std;\nusing namespace orislib;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000 + 0;\n//{{{ templates\n#define TT_ template<typename T>inline\n#define TTF_ template<typename T,typename F>inline\nTT_ T sq(T x){return x*x;}\nTT_ T In(){T x;cin>>x;return x;}\nTT_ void Out(T&x){cout<<x;}\nTT_ void sort(T&v){sort(begin(v),end(v));}\nTT_ void revs(T&v){reverse(begin(v),end(v));}\nTT_ void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT_ int ubnd(T&v,typename T::value_type x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT_ int lbnd(T&v,typename T::value_type x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTTF_ void inpt(T&v,int n,F f){for(v.reserve(n);n--;v.emplace_back(f()));}\nTTF_ void show(T&v,F f,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),f(x);cout<<e;}\nTT_ typename T::iterator minel(T&v){return min_element(begin(v),end(v));}\nTT_ typename T::iterator maxel(T&v){return max_element(begin(v),end(v));}\n\ninline void fast_io(){ios_base::sync_with_stdio(0);cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline ll pow_mod(ll a,ll k,ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a,ll p){return pow_mod(a,p-2,p);}\n//}}} priority_queue queue deque front stringstream max_element min_element insert count make_tuple\n\n//{{{ void dijkstra(g, s, &dist, &prev)\nvoid dijkstra(const Graph& g, int s, vector<Edge::weight_t>& dist, vector<int>& prev)\n{\n  const int V = g.size();\n  prev.assign(V, -1);\n  dist.assign(V, Edge::INF);\n  dist[s] = 0;\n  priority_queue<Edge> pq;\n  for (pq.push(Edge(-2, s, 0)); !pq.empty();){\n    Edge c = pq.top();\n    pq.pop();\n    if (prev[c.to] != -1) continue;\n    prev[c.to] = c.from;\n    for (const auto& e : g[c.to]){\n      if (dist[e.to] > e.w + c.w){\n        dist[e.to] = e.w + c.w;\n        pq.push(Edge(e.from, e.to, e.w + c.w));\n      }\n    }\n  }\n}\n//}}}\n\nint main()\n{\n  int w, h;\n  while (w = in(), h = in()){\n    Graph g(w * h);\n    char field[128][128];\n    for (int i = 0; i < h; i++) scanf(\"%s\", field[i]);\n    int s;\n    for (int i = 0; i < h; i++){\n      for (int j = 0; j < w; j++){\n        if (field[i][j] == '&') s = i * w + j;\n        for (int d = 0; d < 4; d++){\n          int nx = j + dx[d], ny = i + dy[d];\n          if (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n          g[i * w + j].emplace_back(i * w + j, ny * w + nx, field[ny][nx] == '#');\n        }\n      }\n    }\n    vector<int> dist, prev;\n    dijkstra(g, s, dist, prev);\n    int mini = 1000000;\n    for (int i = 0; i < h; i++){\n      mini = min(mini, dist[i * w]);\n      mini = min(mini, dist[i * w + w - 1]);\n    }\n    for (int i = 0; i < w; i++){\n      mini = min(mini, dist[i]);\n      mini = min(mini, dist[(h - 1) * w + i]);\n    }\n    printf(\"%d\\n\", mini);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-3;\nconst double PI = acos(-1);\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\ndouble h, w;\nchar C[210][210];\n\nint d[210][210];\n\nbool isOutOfRange(int x, int y){\n\tif(x <= 0 || x > w || y<= 0 || y > h) return true;\n\treturn false;\n}\n\nint main(){\n\tpii p;\n\tint x, y, nx, ny, c, nc;\n\tint gx, gy;\n\twhile(cin>>w>>h && h && w){\n\t\trep(i, h) scanf(\"%s\", C[i]);\n\t\t//cout<<h<<\" \"<<w<<endl;\n\t\trep(i, h) rep(j, w) if(C[i][j]=='&') gx = j, gy = i;\n\t\trep(i, 210) rep(j, 210) d[i][j] = -1;\n\t\tpriority_queue<pii> q;\n\t\trep(i, h) q.push(mp(0, (i+1)*1000)), q.push(mp(0, (i+1)*1000+w+1));\n\t\trep(i, w) q.push(mp(0, i+1)), q.push(mp(0, (h+1)*1000+i+1));\n\t\twhile(!q.empty()){\n\t\t\tp = q.top(); q.pop();\n\t\t\ty = p.se/1000;\n\t\t\tx = p.se%1000;\n\t\t\tc = p.fi;\n\t\t\trep(i, 4){\n\t\t\t\tnx = x + dx[i];\n\t\t\t\tny = y + dy[i];\n\t\t\t\tif(isOutOfRange(nx, ny)) continue;\n\t\t\t\tnc = c + (C[ny-1][nx-1]=='#'?1:0);\n\t\t\t\tif(d[ny][nx]!=-1 && d[ny][nx] <= nc) continue;\n\t\t\t\td[ny][nx] = nc;\n\t\t\t\tq.push(mp(nc, ny*1000+nx));\n\t\t\t}\n\t\t}\n\t\tcout<<d[gy+1][gx+1]<<endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tcin >> W >> H; memset(dist, 127, sizeof(dist)); queue<pair<int, int> >Q;\n\t\tmemset(X, 127, sizeof(X));\n\t\tif (W == 0 && H == 0) { break; }\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c; if (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop(); int cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tif (X[ex][ey] <= 1) {\n\t\t\t\t\tint dis = dist[cx][cy] + X[ex][ey];\n\t\t\t\t\tif (dist[ex][ey] > dis) {\n\t\t\t\t\t\tdist[ex][ey] = dis; Q.push(make_pair(ex, ey));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF (1<<24)\nusing namespace std;\nint W,H,mini,mini_x,mini_y,ny,nx,cost,ans;\nstring str;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nchar t[102][102];\nbool vd[102][102];\nint u[102][102];\n\nint main(){\n  while(cin>>W>>H){\n    if(W==0&&H==0)break;\n    for(int i=0;i<102;i++)for(int j=0;j<102;j++){\n\tt[i][j]='.';\n\tvd[i][j]=false;\n\tu[i][j]=INF;\n      }\n\n    for(int i=1;i<=H;i++){\n      cin>>str;\n      for(int j=1;j<=W;j++){\n\tt[i][j]=str[j-1];\n\tif(t[i][j]=='&')u[i][j]=0;\n      }\n    }\n    /*\n    for(int i=0;i<H+2;i++){\n      for(int j=0;j<W+2;j++){\n\tcout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    */\n\n    while(1){\n      mini=INF;\n      for(int i=0;i<H+2;i++){\n\tfor(int j=0;j<W+2;j++){\n\t  if(mini>u[i][j]&&vd[i][j]==false){\n\t    mini=u[i][j];\n\t    mini_y=i;\n\t    mini_x=j;\n\t  }\n\t}\n      }\n\n      if(mini==INF)break;\n\n      vd[mini_y][mini_x]=true;\n\n      //cout<<mini_y<<' '<<mini_x<<' '<<u[mini_y][mini_x]<<endl;\n\n      \n    \n\n      for(int i=0;i<4;i++){\n\tny=mini_y+dy[i];\n\tnx=mini_x+dx[i];\n\tif(ny<0||nx<0||ny>H+1||nx>W+1)continue;\n\tcost=((t[mini_y][mini_x]!='#'&&t[ny][nx]=='#')?1:0);\n\n\tif(u[ny][nx]>u[mini_y][mini_x]+cost){\n\t  u[ny][nx]=u[mini_y][mini_x]+cost;\n\t}\n      }\n    }\n\n    ans=INF;\n    for(int i=0;i<H+2;i++){\n      ans=max(ans,u[i][0]);\n      ans=max(ans,u[i][W+1]);\t      \n    }\n    for(int i=0;i<W+2;i++){\n      ans=min(ans,u[0][i]);\n      ans=min(ans,u[H+1][i]);\t      \n    }\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n#include <limits.h>\n#include <cstdio>\nusing namespace std;\n\nstruct Point\n{\n\tint x;\n\tint y;\n\tPoint(int x_,int y_):x(x_),y(y_){}\n};\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint main(void)\n{\n\twhile(1){\n\t\tint w,h;\n\t\tint field[105][105] = {};\n\t\tint costfield[105][105];\n\t\tPoint gPoint(0,0);\n\t\tcin >> w >> h;\n\n\t\tfor(int i=0;i<105;++i){\n\t\t\tfor(int j=0;j<105;++j){\n\t\t\t\tcostfield[i][j] = INT_MAX;\n\t\t\t\tif(i==0||j==0||i==h+3||j==w+3)\n\t\t\t\t\tcostfield[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tif(w == 0 && h == 0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=h+2;++y){\n\t\t\tfor(int x=1;x<=w+2;++x){\n\t\t\t\tif(x==1 || y==1 || x==w+2 || y==h+2)\n\t\t\t\t{\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tscanf(\" %c\",&field[y][x]);\n\t\t\t\t\tif(field[y][x] == '&')\n\t\t\t\t\t\tgPoint = Point(x,y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcostfield[1][1] = 0;\n\n\t\tqueue<Point> que;\n\t\tque.push(Point(1,1));\n\t\twhile(!que.empty()){\n\t\t\tPoint now = que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tPoint next(now.x+dx[i],now.y+dy[i]);\n\t\t\t\tint c = costfield[now.y][now.x] + (field[now.y][now.x] == '.' && field[next.y][next.x] == '#' ? 1 : 0);\n\t\t\t\tif(c < costfield[next.y][next.x]){\n\t\t\t\t\tcostfield[next.y][next.x] = c;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << costfield[gPoint.y][gPoint.x] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\nconst int INF = 10000;\nconst int MAX = 100;\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {-1, 0, 1, 0};\nint m,n,sx,sy;\nint step[MAX + 2][MAX + 2];\nchar field[MAX + 2][MAX + 2];\n\nint main()\n{\n    while(cin >> n >> m && m) {\n        memset(step, -1, sizeof(step));\n        memset(field, '.', sizeof(field));\n        \n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                cin >> field[i][j];\n                if(field[i][j] == '&') {\n                    sx = j;\n                    sy = i;\n                }\n            }\n        }\n\n        priority_queue<S, vector<S>, greater<S> > que;\n        que.push(S(0, P(sx, sy)));\n        while(!que.empty()) {\n            S s = que.top(); que.pop();\n            int x = s.second.first, y = s.second.second, z = s.first;\n            if(step[y][x] >= 0) continue;\n            step[y][x] = z;\n\n            for(int i = 0; i < 4; i++) {\n                int nx = x + dx[i], ny = y + dy[i], nz = z;\n                if(field[ny][nx] == '#') nz++;\n                if(nx >= 0 && nx <= n + 1 && ny >= 0 && ny <= m + 1) {\n                    que.push(S(nz, P(nx, ny)));\n                }\n            }\n        }\n\n        int res = INF;\n        for(int i = 0; i <= m + 1; i++)\n            for(int j = 0; j <= n + 1; j++)\n                if(i == 0 || i == m + 1 || j == 0 || j == n + 1) \n                    res = min(res, step[i][j]);\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int b[][100],int x,int y,int m,int n,int c){\n  int mn=100;\n  if(x==0||x==m-1||y==0||y==n-1){\n    if(a[x][y])\n      return c+1;\n    else\n      return c;\n  }\n  if(b[x][y]==-1){\n    if(a[x][y])\n      b[x][y]=c+1;\n    else{\n      b[x][y]=c;\n      int tmp;\n      if((tmp=f(a,b,x-1,y,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x,y-1,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x+1,y,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x,y+1,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if(mn!=100)\n\treturn mn;\n    }\n  }\n  return -1;\n}\nint main(){\n  int i,j,k;\n  int a[100][100],b[100][100],mn,x,y,m,n;\n  string s;\n  for(;;){\n    cin>>m>>n;\n    if(m+n==0)\n      break;\n    memset(a,0,sizeof(a));\n    memset(b,-1,sizeof(b));\n    for(i=0;i<n;i++){\n      cin>>s;\n      for(j=0;j<m;j++){\n\tif(s[j]=='#')\n\t  a[j][i]=1;\n\telse if(s[j]=='&'){\n\t  x=j;\n\t  y=i;\n\t  b[x][y]=0;\n\t}\n      }\n    }\n    for(i=0;;i++){\n      for(j=0;j<m;j++){\n\tfor(k=0;k<n;k++){\n\t  if(b[j][k]==i){\n\t    int tmp;\n\t    mn=100;\n\t    if((tmp=f(a,b,j-1,k,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if((tmp=f(a,b,j,k-1,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if((tmp=f(a,b,j+1,k,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if((tmp=f(a,b,j,k+1,m,n,i))>=0)\n\t      mn=min(mn,tmp);\n\t    if(mn!=100)\n\t      break;\n\t  }\n\t}\n\tif(k!=n)\n\t  break;\n      }\n      if(j!=m)\n\tbreak;\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint n,m,flag,dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nchar c[100][100];\n\nvoid paint(int x,int y,char ch){\n\tc[y][x]='o';\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx>=0&&nx<n&&ny>=0&&ny<m){\n\t\t\tif(c[ny][nx]==ch)paint(nx,ny,ch);\n\t\t\tif(c[ny][nx]=='&')flag=1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>n>>m&&n){\n\t\tflag=0;\n\t\trep(i,m)rep(j,n){\n\t\t\tcin>>c[i][j];\n\t\t\tif(i==0||i==m-1||j==0||j==n-1){\n\t\t\t\tif(c[i][j]=='.')c[i][j]='o';\n\t\t\t\tif(c[i][j]=='&')flag=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\twhile(!flag){\n\t\t\tif(t==1)c[0][0]='o';\n\t\t\tif(t)rep(i,m)rep(j,n)if(c[i][j]=='o')paint(j,i,'#');\n\t\t\trep(i,m)rep(j,n)if(c[i][j]=='o')paint(j,i,'.');\n\t\t\tif(!flag)t++;\n\t\t}\n\t\tcout<<t<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nchar field[128][128];\nint memo[128][128];\nint w, h;\n\nvoid fillup(int y, int x, int num, char c)\n{\n\tmemo[y][x] = num;\n\t\n\tconst int dy[] = {-1, 0, 0, 1};\n\tconst int dx[] = {0, 1, -1, 0};\n\t\n\trep(i, 4){\n\t\tint py = y + dy[i];\n\t\tint px = x + dx[i];\n\t\tif(py<0 || h<=py || px<0 || w<=px || (memo[py][px] != -2 && memo[py][px] != -1))\n\t\t\tcontinue;\n\t\t\n\t\tif(field[py][px] != c)\n\t\t\tmemo[py][px] = -2;\n\t\telse\n\t\t\tfillup(py, px, num, c);\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tint y, x;\n\t\trep(i, h){\n\t\t\tscanf(\"%s\", field[i+1]+1);\n\t\t\trep(j, w){\n\t\t\t\tif(field[i+1][j+1] == '&'){\n\t\t\t\t\ty = i + 1;\n\t\t\t\t\tx = j + 1;\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\th += 2;\n\t\tw += 2;\n\t\tfill_n(field[0], w, '.');\n\t\tfill_n(field[h-1], w, '.');\n\t\trep(i, h)\n\t\t\tfield[i][0] = field[i][w-1] = '.';\n\t\t\n\t\trep(i, h)\n\t\t\tfill_n(memo[i], w, -1);\n\t\t\n\t\tmemo[y][x] = -2;\n\t\tfor(int i=0;; ++i){\n\t\t\tconst char chars[] = {'#', '.'};\n\t\t\tbool found = false;\n\t\t\trep(l, 2){\n\t\t\t\trep(j, h) rep(k, w){\n\t\t\t\t\tif(field[j][k] == chars[l] && memo[j][k] == -2){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tfillup(j, k, i, chars[l]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%d\\n\", memo[0][0]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint vx[]={1,0,-1,0},vy[]={0,-1,0,1};\n\nint main(){\n    for(;;){\n        int n,m;\n        scanf(\"%d %d\\n\",&n,&m);\n        if(n==0&&m==0) break;\n        char ma[100][100];\n        int dx,dy;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                scanf(\"%c\",&ma[i][j]);\n                if(ma[i][j]=='&'){\n                    dx=i;\n                    dy=j;\n                }\n            }\n            scanf(\"\\n\");\n        }\n        int dist[100][100];\n        const int INF=100000;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                dist[i][j]=INF;\n            }\n        }\n        dist[dx][dy]=0;\n        priority_queue<pair<int,P>,vector<pair<int,P> >,greater<pair<int,P> > > que;\n        que.push(make_pair(0,P(dx,dy)));\n        while(!que.empty()){\n            pair<int,P> now=que.top();\n            que.pop();\n            int di=now.first,nox=now.second.first,noy=now.second.second;\n            if(dist[nox][noy]<di) continue;\n            for(int v=0;v<4;v++){\n                int nex=nox+vx[v],ney=noy+vy[v];\n                if(0<=nex&&nex<m&&0<=ney&&ney<n){\n                    if(ma[nox][noy]=='#'){\n                        if(dist[nex][ney]>dist[nox][noy]){\n                            dist[nex][ney]=dist[nox][noy];\n                            que.push(make_pair(dist[nex][ney],P(nex,ney)));\n                        }\n                    }else{\n                        int nedist=dist[nox][noy];\n                        if(ma[nex][ney]=='#') nedist++;\n                        if(dist[nex][ney]>nedist){\n                            dist[nex][ney]=nedist;\n                            que.push(make_pair(dist[nex][ney],P(nex,ney)));\n                        }\n                    }\n                }\n            }\n        }\n        int mi=INF;\n        for(int i=0;i<m;i++){\n            mi=min(mi,dist[i][0]);\n            mi=min(mi,dist[i][n-1]);\n        }\n        for(int i=0;i<n;i++){\n            mi=min(mi,dist[0][i]);\n            mi=min(mi,dist[m-1][i]);\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dir[][2] = {\n\t1, 0,\n\t0, 1,\n\t-1, 0,\n\t0, -1\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tVS board( h );\n\n\t\tEACH( line, board )\n\t\t{\n\t\t\tcin >> line;\n\t\t}\n\n\t\tint sy, sx;\n\n\t\tREP( i, 0, h )\n\t\t{\n\t\t\tREP( j, 0, w )\n\t\t\t{\n\t\t\t\tif ( board[i][j] == '&' )\n\t\t\t\t{\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVVI cost( h, VI( w, INT_MAX ) );\n\t\tcost[ sy ][ sx ] = 0;\n\n\t\tqueue< PII > que;\n\t\tque.push( MP( sy, sx ) );\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tauto cur = que.front();\n\t\t\tque.pop();\n\n\t\t\tREP( d, 0, 4 )\n\t\t\t{\n\t\t\t\tauto next = cur;\n\n\t\t\t\tnext.fst += dir[d][0];\n\t\t\t\tnext.snd += dir[d][1];\n\n\t\t\t\tif ( !( 0 <= next.fst && next.fst < h && 0 <= next.snd && next.snd < w ) )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tint nextcost = cost[ cur.fst ][ cur.snd ] + ( board[ cur.fst ][ cur.snd ] == '.' && board[ next.fst ][ next.snd ] == '#' );\n\n\t\t\t\tif ( cost[ next.fst ][ next.snd ] <= nextcost )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tcost[ next.fst ][ next.snd ] = nextcost;\n\t\n\t\t\t\tque.push( next );\n\t\t\t}\n\t\t}\n\n\t\tint res = INT_MAX;\n\n\t\tREP( i, 0, w )\n\t\t{\n\t\t\tres = min( res, min( cost[0][i], cost[ h - 1 ][i] ) );\n\t\t}\n\n\t\tREP( i, 0, h )\n\t\t{\n\t\t\tres = min( res, min( cost[i][0], cost[i][ w - 1 ] ) );\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint fn(int a[][100],int x,int y,int p,int w,int h){\n  if(0){\n  }else if(a[x][y]==-2){\n    a[x][y]=p+1;\n  }else if(a[x][y]==-1){\n    if(x==0||x==w-1||y==0||y==h-1)\n      return 1;\n    a[x][y]=p;\n    if(0||\n       fn(a,x-1,y,p,w,h)||\n       fn(a,x,y-1,p,w,h)||\n       fn(a,x+1,y,p,w,h)||\n       fn(a,x,y+1,p,w,h))\n      return 1;\n  }\n  return 0;\n}\nint fm(int a[][100],int x,int y,int p,int w,int h){\n  if(0){\n  }else if(a[x][y]==-2){\n    if(x==0||x==w-1||y==0||y==h-1)\n      return 1;\n    a[x][y]=p;\n    if(0||\n       fm(a,x-1,y,p,w,h)||\n       fm(a,x,y-1,p,w,h)||\n       fm(a,x+1,y,p,w,h)||\n       fm(a,x,y+1,p,w,h))\n      return 1;\n  }\n  return 0;\n}\nint main(){\n  int i,j,k;\n  int a[100][100],w,h;\n  char c;\n  while(cin>>w>>h&&w+h){\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin>>c;\n\tif(0){\n\t}else if(c=='#'){\n\t  a[j][i]=-2;\n\t}else if(c=='.'){\n\t  a[j][i]=-1;\n\t}else if(c=='&'){\n\t  a[j][i]=0;\n\t}\n      }\n    }\n    for(i=0;;){\n      for(j=0;j<h;j++){\n\tfor(k=0;k<w;k++){\n\t  if(a[k][j]==i){\n\t    if(k==0||k==w-1||j==0||j==h-1)\n\t      break;\n\t    if(0||\n\t       fn(a,k-1,j,i,w,h)||\n\t       fn(a,k,j-1,i,w,h)||\n\t       fn(a,k+1,j,i,w,h)||\n\t       fn(a,k,j+1,i,w,h))\n\t      break;\n\t  }\n\t}\n\tif(k!=w)\n\t  break;\n      }\n      if(j!=h)\n\tbreak;\n      i++;\n      for(j=0;j<h;j++){\n\tfor(k=0;k<w;k++){\n\t  if(a[k][j]==i){\n\t    if(k==0||k==w-1||j==0||j==h-1)\n\t      break;\n\t    if(0||\n\t       fm(a,k-1,j,i,w,h)||\n\t       fm(a,k,j-1,i,w,h)||\n\t       fm(a,k+1,j,i,w,h)||\n\t       fm(a,k,j+1,i,w,h))\n\t      break;\n\t  }\n\t}\n\tif(k!=w)\n\t  break;\n      }\n      if(j!=h)\n\tbreak;\n    }\n    cout<<i<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconstexpr int INF = 1 << 29;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing P = pair<int, int>;\n\nint N, M;\nchar field[111][111];\n\nint solve() {\n    int memo[111][111];\n    for (int j = 0; j < M; ++j) { fill(memo[j], memo[j]+N, INF); }\n\n    priority_queue<P> que;\n\n    for (int j = 0; j < M; ++j) {\n        for (int k = 0; k < N; ++k) {\n            if (field[j][k] == '&') {\n                memo[j][k] = 0;\n                que.emplace(0, j*N + k);\n            }\n        }\n    }\n\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int cost = -p.first, x = p.second/N, y = p.second%N;\n\n        if (cost > memo[x][y]) { continue; }\n\n        char st = field[x][y];\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x+dx[d], ny = y+dy[d];\n            if (nx < 0 || M <= nx || ny < 0 || N <= ny) { continue; }\n\n            int next_cost = cost + (st == '#' && field[nx][ny] == '.');\n\n            if (next_cost < memo[nx][ny]) {\n                memo[nx][ny] = next_cost;\n                que.emplace(-next_cost, nx*N+ny);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int j = 0; j < M; ++j) {\n        if (field[j][0] == '.') {\n            ans = min(ans, memo[j][0]);\n        }\n        if (field[j][N-1] == '.') {\n            ans = min(ans, memo[j][N-1]);\n        }\n    }\n    for (int j = 0; j < N; ++j) {\n        if (field[0][j] == '.') {\n            ans = min(ans, memo[0][j]);\n        }\n        if (field[M-1][j] == '.') {\n            ans = min(ans, memo[M-1][j]);\n        }\n    }\n    return ans;\n}\n\nbool loop() {\n    cin >> N >> M;\n    if (N+M == 0) { return false; }\n    for (int j = 0; j < M; ++j) { cin >> field[j]; }\n\n    cout << solve() << endl;\n\n    return true;\n}\n\nint main() { while (loop()); return 0; }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint w, h;\nint cnt;\nchar cur;\nvector<string> F;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nbool finish() {\n    for (int i = 0; i < w; i++) {\n        if (F[0][i] == '&') return true;\n        if (F[h-1][i] == '&') return true;\n    }\n    for (int i = 0; i < h; i++) {\n        if (F[i][0] == '&') return true;\n        if (F[i][w-1] == '&') return true;\n    }\n    return false;\n}\n\n#define MAX 100\nbool used[MAX][MAX];\nvoid dfs(int y, int x) {\n    used[y][x] = true;\n    F[y][x] = '&';\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (0 <= nx && nx < w && 0 <= ny && ny < h && !used[ny][nx] && (F[ny][nx] == cur || F[ny][nx] == '&')) {\n            dfs(ny, nx);\n        }\n    }\n}\n\nint main() {\n    while (cin >> w >> h, w || h) {\n        F.clear(); F.resize(h);\n        for (int i = 0; i < h; i++) {\n            cin >> F[i];\n        }\n        int y, x; // &の位置\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (F[i][j] == '&') {\n                    y = i;\n                    x = j;\n                }\n            }\n        }\n        cnt = 0;\n        cur = '.';\n        while (!finish()) {\n            memset(used, 0, sizeof(used));\n            dfs(y, x);\n            if (cur == '#') {\n                cur = '.';\n                cnt++;\n            } else cur = '#';\n        }\n        cout << cnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\nconst int hardCost = 100000;\nconst int dx[] = {1, 0, 0, -1};\nconst int dy[] = {0, 1, -1, 0};\nstruct P{ int x, y; P(int x, int y) : x(x), y(y) {} };\n\nint main()\n{\n    for(int n, m; cin >> n >> m && (n || m); )\n\t{\n\t\tP c(0, 0);\n\t\tvector<string> field(m);\n\t\tvector<vint> cost(n, vint(m, INF));\n\t\t\n\t\trep(i, m)\n\t\t{\n\t\t\tcin >> field[i];\n\t\t\t\n\t\t\tint pos = field[i].find(\"&\");\n\t\t\tif(pos != string::npos)\n\t\t\t{\n\t\t\t\tc.x = pos;\n\t\t\t\tc.y = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tcost[c.x][c.y] = 0;\n\t\tfor(que.push(c); !que.empty(); que.pop())\n\t\t{\n\t\t\tP cur = que.front();\n\t\t\t\n\t\t\trep(i, 4)\n\t\t\t{\n\t\t\t\tP nxt(cur.x + dx[i], cur.y + dy[i]);\n\t\t\t\t\n\t\t\t\tif(0 <= nxt.x && nxt.x < n && 0 <= nxt.y && nxt.y < m)\n\t\t\t\t{\n\t\t\t\t\tint ct = cost[cur.x][cur.y] + (field[nxt.y][nxt.x] == '#' ? hardCost : 1);\n\t\t\t\t\t\n\t\t\t\t\tif(ct < cost[nxt.x][nxt.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tcost[nxt.x][nxt.y] = ct;\n\t\t\t\t\t\tque.push(nxt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 1 << 30;\n\t\t\n\t\trep(i, n) chmin(res, min(cost[i][0], cost[i][m-1]));\n\t\trep(i, m) chmin(res, min(cost[0][i], cost[n-1][i]));\n\t\t\n\t\t\n\t\tcout << res / hardCost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdlib>\n#include <climits>\n#include <iostream>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w + h){\n    vector<string> g(h);\n    int sx, sy;\n\n    REP(i,h) cin >> g[i];\n\n    REP(i,h) REP(j,w) if(g[i][j] == '&'){\n      g[i][j] = '.';\n      sx = j; sy = i;\n    }\n\n    typedef pair<int, pair<int, int> > data;\n    priority_queue<data, vector<data>, greater<data> > q;\n    vector<vector<int> > memo(h, vector<int>(w, -1));\n\n    int ans = INT_MAX;\n\n    q.push(make_pair(0, make_pair(sx, sy)));\n\n    while(q.size()){\n      const auto d = q.top(); q.pop();\n      const int cost = d.first;\n      const int x = d.second.first;\n      const int y = d.second.second;\n\n      if(ISIN(x, y, w, h) && memo[y][x] != -1) continue;\n      if(ISIN(x, y, w, h)) memo[y][x] = cost;\n\n      if(!ISIN(x, y, w, h)){\n\tans = min(ans, cost);\n      }else{\n\tconst char prev = g[y][x];\n\tREP(i,4){\n\t  const int xx = x + _dx[i];\n\t  const int yy = y + _dy[i];\n\t  if(!ISIN(xx, yy, w, h) || memo[yy][xx] == -1){\n\t    const char next = ISIN(xx, yy, w, h) ? g[yy][xx] : '.';\n\t    const int cc = prev == '.' && next == '#' ? cost + 1 : cost;\n\t    q.push(make_pair(cc, make_pair(xx, yy)));\n\t  }\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 1e9;\nstatic const int dx[] = {1, 0, -1, 0};\nstatic const int dy[] = {0, -1, 0, 1};\n\nvoid solve()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n || m)\n\t{\n\t\tP start;\n\t\tvector< vector<char> > field(m, vector<char>(n));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tif (field[i][j] == '&')\n\t\t\t\t{\n\t\t\t\t\tstart.first = j;\n\t\t\t\t\tstart.second = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<P> Que;\n\t\tQue.push(start);\n\t\tqueue<P> wallQue;\n\t\tvector< vector<int> > fieldStep(m, vector<int>(n));\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tfieldStep[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfieldStep[start.second][start.first] = 0;\n\t\tint cnt = 0;\n\t\twhile (true)\n\t\t{\n\t\t\twhile (!Que.empty())\n\t\t\t{\n\t\t\t\tP cur = Que.front();\n\t\t\t\tQue.pop();\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = cur.first + dx[i];\n\t\t\t\t\tnext.second = cur.second + dy[i];\n\t\t\t\t\tif (!(0 <= next.first && next.first < n && 0 <= next.second && next.second < m) || fieldStep[next.second][next.first] != INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (field[next.second][next.first] == '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt + 1;\n\t\t\t\t\t\t\twallQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt;\n\t\t\t\t\t\t\tQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t++cnt;\n\t\t\twhile (!wallQue.empty())\n\t\t\t{\n\t\t\t\tP cur = wallQue.front();\n\t\t\t\twallQue.pop();\n\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t{\n\t\t\t\t\tP next;\n\t\t\t\t\tnext.first = cur.first + dx[i];\n\t\t\t\t\tnext.second = cur.second + dy[i];\n\t\t\t\t\tif (!(0 <= next.first && next.first < n && 0 <= next.second && next.second < m) || fieldStep[next.second][next.first] != INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (field[next.second][next.first] == '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt;\n\t\t\t\t\t\t\twallQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldStep[next.second][next.first] = cnt;\n\t\t\t\t\t\t\tQue.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Que.empty())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint minv = INF;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tminv = min(minv, fieldStep[0][i]);\n\t\t\tminv = min(minv, fieldStep[m - 1][i]);\n\t\t}\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tminv = min(minv, fieldStep[i][0]);\n\t\t\tminv = min(minv, fieldStep[i][n - 1]);\n\t\t}\n\t\tcout << minv << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=10000000;\nchar fie[120][120];\nint jp[120][120];\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=m+1;i++){\n\t\tfor(int j=0;j<=n+1;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(0,0),0));\n\tjp[0][0]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(kx>=0 && kx<=n+1 && ky>=0 && ky<=m+1){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='&' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tcin >> fie[j][i];\n\t\t\t\tif(fie[j][i]=='&')gx=j,gy=i;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",jp[gx][gy]);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <vector>\nusing namespace std;\n#define mp make_pair\ntypedef pair<int, int> P;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint N, M;\nchar maze[110][110];\nunsigned int minp[110][110];\n\nint main() {\n\tfor(;;) {\n\t\tmemset(minp, -1, sizeof minp);\n\t\tscanf(\" %d %d\", &N, &M);\n\t\tif(!N && !M) break;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tscanf(\" %s\", maze[i]);\n\t\t}\n\n\t\t// P = (x, y)\n\t\t// maze[y][x]\n\t\tqueue<P> que;\n\t\t{\n\t\t\tP put;\n\t\t\tfor(int x = 0; x < N; x++) {\n\t\t\t\tfor(int y = 0; y < M; y++) {\n\t\t\t\t\tif(maze[y][x] == '&') {\n\t\t\t\t\t\tput.first = x;\n\t\t\t\t\t\tput.second = y;\n\t\t\t\t\t\tminp[y][x] = 0;\n\t\t\t\t\t\tmaze[y][x] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tque.push(put);\n\t\t}\n\t\t;\n\t\twhile(!que.empty()) {\n\t\t\tP p = que.front();\n\t\t\tque.pop();\n\n\t\t\t// push\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\tint nx = p.first + dx[i];\n\t\t\t\tint ny = p.second + dy[i];\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '.' && maze[ny][nx] == '#' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first] + 1;\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\n\t\t\t\tif(0 <= nx && nx < N && 0 <= ny && ny < M && maze[p.second][p.first] == '#' && maze[ny][nx] == '.' && minp[ny][nx] > minp[p.second][p.first]) {\n\t\t\t\t\tminp[ny][nx] = minp[p.second][p.first];\n\t\t\t\t\tque.push(mp(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tunsigned int minv = 100000000;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tminv = min(minv, min(minp[0][i], minp[M - 1][i]));\n\t\t}\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tminv = min(minv, min(minp[i][0], minp[N - 1][i]));\n\t\t}\n\t\tprintf(\"%d\\n\", minv);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n\nconst int INF = 100000000;\nconst int MAX_N = 100;\nconst int MAX_M = 100;\nconst int dy[4] = {-1, 0, 1, 0 };\nconst int dx[4] = { 0, 1, 0,-1 };\n\nchar maze[MAX_N][MAX_M+1];\nint N, M;\nint sy, sx;\nint cost[MAX_N][MAX_M];\n\nint bfs (void ){\n\trep (i, N ) rep (j, M ) cost[i][j] = INF;\n\tqueue<P> que;\n\tque.push (P (sy, sx ) );\n\tcost[sy][sx] = 0;\n\twhile (!que.empty() ){\n\t\tP cur = que.front(); que.pop();\n\t\tint cy = cur.first;\n\t\tint cx = cur.second;\n\t\tint cc = cost[cy][cx];\n\t\trep (k, 4 ){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny >= N || nx < 0 || nx >= M ) continue;\n\t\t\tint next_cost = cost[cy][cx] + ((maze[ny][nx] == '#' && maze[cy][cx] != '#') ? 1 : 0 );\n\t\t\tif (next_cost >= cost[ny][nx] ) continue;\n\t\t\tcost[ny][nx] = next_cost;\n\t\t\tque.push (P (ny, nx ) );\n\t\t} // end rep\n\t} // end rep\n\n\tint res = INF;\n\trep (i, N ) res = min (res, cost[i][0] );\n\trep (i, N ) res = min (res, cost[i][M-1] );\n\trep (j, M ) res = min (res, cost[0][j] );\n\trep (j, M ) res = min (res, cost[N-1][j] );\n\n\treturn res;\t\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\twhile (cin >> M >> N, M ){\n\t\tmemset (maze, 0, sizeof (maze ) );\n\t\tmemset (cost, 0, sizeof (cost ) );\n\t\trep (i, N ) rep (j, M ) cin >> maze[i][j];\n\t\trep (i, N ) rep (j, M ) if (maze[i][j] == '&' ){ sy = i, sx = j; }\n\t\tint res = bfs ();\n\t\tcout << res << endl;\n\t} // end while\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\n\nint main(){\n\tint w,h,sx,sy; char m[101][101];\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)rep(j,w){\n\t\t\tcin>>m[i][j];\n\t\t\tif(m[i][j]=='&')sy=i,sx=j;\n\t\t}\n\t\t\n\t\tvector<pair<int,int> > frontier,next;\n\t\tint cost[h][w]; rep(i,h)rep(j,w)cost[i][j]=99999;\n\t\tcost[sy][sx]=0;\n\t\tfrontier.push_back(make_pair(sy,sx));\n\t\t\n\t\tfor(int step=0;!frontier.empty();step++){\n\t\t\tnext.clear();\n\t\t\trep(i,frontier.size()){\n\t\t\t\tint x=frontier[i].second,y=frontier[i].first,cx,cy,c;\n\t\t\t\trep(d,4){\n\t\t\t\t\tcx=x+dx[d],cy=y+dy[d];\n\t\t\t\t\tif(!ck(cy,h)||!ck(cx,w))continue;\n\t\t\t\t\tc=m[y][x]!='#'&&m[cy][cx]=='#'?1:0;\n\t\t\t\t\tif(cost[cy][cx]>cost[y][x]+c){\n\t\t\t\t\t\tcost[cy][cx]=cost[y][x]+c;\n\t\t\t\t\t\tnext.push_back(make_pair(cy,cx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfrontier=next;\n\t\t}\n\t\tint mn=99999;\n\t\trep(i,h){\n\t\t\tif(i==0||i==h-1){\n\t\t\t\trep(j,w)if(mn>cost[i][j])mn=cost[i][j];\n\t\t\t}else{\n\t\t\t\tif(mn>cost[i][0])mn=cost[i][0];\n\t\t\t\tif(mn>cost[i][w-1])mn=cost[i][w-1];\n\t\t\t}\n\t\t}\n\t\tcout<<mn<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n\nusing namespace std;\n\nint h,w;\nchar field[101][101];\nbool passed[101][101];\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nqueue<pair<int,int> > *prv;\nqueue<pair<int,int> > *nxt;\n\nbool ok;\n\nvoid dfs(int y,int x){\n    if(y==h-1||y==0||x==0||x==w-1){\n        ok=true;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]){\n            passed[ny][nx]=true;\n            // ツ堀ツづ按づァnxtツづ英ushツつオツづ終ツ猟ケ\n            if(field[ny][nx]=='#')\n                nxt->push(make_pair(ny,nx));\n            else\n                dfs(ny,nx);\n            if(ok)return;\n        }\n    }\n}\nint main(){\n    prv=new queue<pair<int,int> >();\n    nxt=new queue<pair<int,int> >();\n    while(cin>>w>>h&&!(h==0&&w==0)){\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        int sy,sx;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin>>field[i][j];\n                if(field[i][j]=='&'){\n                    sy=i,sx=j;\n                    field[i][j]='.';\n                }\n            }\n        }\n        prv->push(make_pair(sy,sx));\n        int cnt=0;\n        while(prv->size()){\n            while(prv->size()){\n                pair<int,int> &p=prv->front();\n                passed[p.first][p.second]=true;\n                dfs(p.first,p.second);\n                prv->pop();\n                if(ok)\n                    break;\n            }\n            if(ok)break;\n            swap(prv,nxt);\n            cnt++;\n        }\n        cout<<cnt<<endl;\n        while(prv->size())prv->pop();\n        while(nxt->size())nxt->pop();\n    }\n    delete nxt;\n    delete prv;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAX_N 1000\nint X[MAX_N][MAX_N], dist[MAX_N][MAX_N], W, H, gx, gy; char c;\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tX[i][j] = 1000000000;\n\t\t\t\tdist[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\tcin >> W >> H; queue<pair<int, int>>Q;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == '&') { gx = i; gy = j; }\n\t\t\t\tif (c == '#') { X[i][j] = 1; }\n\t\t\t\telse { X[i][j] = 0; }\n\t\t\t\tif (i == 1 || i == H || j == 1 || j == W) {\n\t\t\t\t\tQ.push(make_pair(i, j));\n\t\t\t\t\tdist[i][j] = X[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!Q.empty()) {\n\t\t\tpair<int, int>pa = Q.front(); Q.pop();\n\t\t\tint cx = pa.first, cy = pa.second;\n\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\t\t\tint dis = dist[cx][cy];\n\t\t\t\tif (X[cx][cy] == 0 && X[ex][ey] == 1) {\n\t\t\t\t\tdis += 1;\n\t\t\t\t}\n\t\t\t\tif (dist[ex][ey]>dis) {\n\t\t\t\t\tdist[ex][ey] = dis;\n\t\t\t\t\tQ.push(make_pair(ex, ey));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << dist[gx][gy] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nchar field[101][101];\nbool passed[101][101];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint h,w;\n// ×ÚÇÀWÌXg\nvector<pair<int,int> > walls;\nvector<pair<int,int> > spList;\n\n\nbool bfs(int sx,int sy,bool w){\n\t// Ü¸ÊÉbfs\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\t\n\tprv->push(make_pair(sy,sx));\n\tbool fin=false;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> p = prv->front();\n\t\t\tprv->pop();\n\t\t\tpassed[p.first][p.second]=true;\n\t\t\t// ÇÉBµ½çAI¹\n\t\t\tif(p.first==0||p.first==h-1||p.second==0||p.second==w-1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// lûüÉÚ®\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nx=p.second+dx[i];\n\t\t\t\tint ny=p.first+dy[i];\n\t\t\t\tif(!passed[ny][nx]){\n\t\t\t\t\tif(w){\n\t\t\t\t\t\tif(field[ny][nx]=='.')\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\telse if(field[ny][nx]=='#'){\n\t\t\t\t\t\t\twalls.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(field[ny][nx]=='#'){\n\t\t\t\t\t\t\tnxt->push(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(field[ny][nx]='.'){\n\t\t\t\t\t\t\tspList.push_back(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\treturn false;\n}\n\nint main(){\n\n\t// ÇÉÕË·éÜÅbfsðJè©¦·\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\twalls.clear();\n\t\tspList.clear();\n\t\tint sx,sy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='&')\n\t\t\t\t\tsx=j,sy=i;\n\t\t\t}\n\t\t\tfill(passed[i],passed[i]+w,false);\n\t\t}\n\t\tint cnt=0;\n\t\tbool fin=false;\n\t\tspList.push_back(make_pair(sy,sx));\n\t\twhile(1){\n\t\t\t// ÇÀWÌXgªèÉüéÌÅA»ÌÇÀW©çBÅ«éêðTõ\n\t\t\tfor(int i = 0; i < spList.size(); i++){\n\t\t\t\tint cx=spList[i].second;\n\t\t\t\tint cy=spList[i].first;\n\t\t\t\tif(bfs(cx,cy,true)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\tspList.clear();\n\t\t\t// ÇðÂ½ÁÄ¢¯éªðTõµA»ÌãÇÉ×Ú·éÀWðÛµÄ¨«A[v\n\t\t\tfor(int i = 0; i < walls.size(); i++){\n\t\t\t\tint cx=walls[i].second;\n\t\t\t\tint cy=walls[i].first;\n\t\t\t\tif(bfs(cx,cy,false)){\n\t\t\t\t\tfin=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(fin)\n\t\t\t\tbreak;\n\t\t\twalls.clear();\n\t\t\t// JEgðâ·\n\t\t\tcnt++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\nint main(){\n  int n, m, i, j, d, res;\n  while(scanf(\"%d%d\", &n, &m) && n+m){\n    char cas[128][128];\n    int cnt[128][128];\n    rep(i, m) rep(j, n) cnt[i][j] = INF;\n    rep(i, m) scanf(\"%s\", cas[i]);\n\n    int x, y;\n    rep(i, m) rep(j, n) if(cas[i][j] == '&'){ y = i; x = j;}\n    cnt[y][x] = 0;\n    cas[y][x] = '.';\n    queue<pi>q;\n    q.push(make_pair(y, x));\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpi now = q.front(); q.pop();\n\t//\tprintf(\"%d %d\\n\", now.Y, now.X);\n\trep(d, 4){\n\t  int ny = now.Y + dy[d], nx = now.X + dx[d];\n\t  if(ny < 0 || nx < 0 || ny >= m || nx >= n) continue;\n\t  if(cnt[ny][nx] <= cnt[now.Y][now.X]) continue;\n\t  if(cas[ny][nx] == '#'){\n\t    cnt[ny][nx] = cnt[now.Y][now.X] + 1;\n\t  }else{\n\t    cnt[ny][nx] = cnt[now.Y][now.X];\n\t  }\n\t  q.push(make_pair(ny, nx));\n\t}\n      }\n    }\n\n    /*    rep(i, m){\n      rep(j, n) printf(\"%d \", cnt[i][j]); puts(\"\");\n      }*/\n\n    res = INF;\n    rep(i, m){\n      res = min(res, cnt[i][0]);\n      res = min(res, cnt[i][n-1]);\n    }\n    rep(i, n){\n      res = min(res, cnt[0][i]);\n      res = min(res, cnt[m-1][i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<25);\n\nstruct State{\n  int x,y,t;\n  State(int a,int b, int c):x(a),y(b),t(c){}\n  bool operator < (const State& s) const {return t>s.t;}\n};\n\nint T[MAX][MAX];\nchar M[MAX][MAX];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m;\nint sx,sy;\n\nvoid print(){\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++) cout << T[i][j];\n    cout << endl;\n  }\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      T[i][j] = INF;\n}\n\nvoid input(){\n  for(int i = 0; i < m; i++)\n    for(int j = 0; j < n; j++){\n      cin >> M[i][j];\n      if(M[i][j] == '&'){\n\tsx = j;\n\tsy = i;\n      }\n    }\n}\n\nbool isInside(int x, int y){return 0<=x&&x<n&&0<=y&&y<m;}\n\nvoid solve(){\n\n  T[sy][sx] = 0;\n\n  priority_queue<State> Q;\n\n  Q.push(State(sx,sy,0));\n\n  while(!Q.empty()){\n    State s = Q.top();\n    Q.pop();\n\n    if(T[s.y][s.x] < s.t) continue;\n\n    for(int i = 0; i < 4; i++){\n      int nx = s.x+dx[i];\n      int ny = s.y+dy[i];\n      if(!isInside(nx,ny)) continue;\n\n      /*   if(M[ny][nx] == '#' && T[ny][nx] > s.t+1){\n\tT[ny][nx] = s.t+1;\n\tQ.push(State(nx,ny,s.t+1));\n      }\n\n      if(M[ny][nx] != '#' && T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n\t}*/\n\n      if(M[ny][nx] == '#'){\n\n\tif(M[s.y][s.x] == '#' && T[ny][nx] > s.t){\n\t  T[ny][nx] = s.t;\n\t  Q.push(State(nx,ny,s.t));\n\t}\n\tif(M[s.y][s.x] != '#' && T[ny][nx] > s.t+1){\n\t  T[ny][nx] = s.t+1;\n\t  Q.push(State(nx,ny,s.t+1));\n\t}\n\n      }else if(T[ny][nx] > s.t){\n\tT[ny][nx] = s.t;\n\tQ.push(State(nx,ny,s.t));\n      }\n    }\n  }\n\n  int ans = INF;\n\n  for(int i = 0; i < n; i++) ans = min(ans,min(T[0][i],T[m-1][i]));\n  for(int i = 0; i < m; i++) ans = min(ans,min(T[i][0],T[i][n-1]));\n\n  cout << ans << endl;\n  //  print();\n}\nint main(){\n\n  while(cin >> n >> m && n+m){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x,y;\nchar field[100][100];//field[y][x]\nbool flag;\n\nvoid DFS(int a,int b){\n\tif(field[b][a] == '&'){\n\t\tflag = true;\n\t}\n\telse\n\t\tfield[b][a] = '-';\n\tif((field[b+1][a] == '.'|| field[b+1][a] == '&') && 0 <= b+1 && b+1 < y && 0 <= a && a < x)\n\t\tDFS(a,b+1);\n\tif((field[b-1][a] == '.'|| field[b-1][a] == '&') && 0 <= b-1 && b-1 < y && 0 <= a && a < x)\n\t\tDFS(a,b-1);\t\n\tif((field[b][a+1] == '.'|| field[b][a+1] == '&') && 0 <= b && b < y && 0 <= a+1 && a+1 < x)\n\t\tDFS(a+1,b);\t\n\tif((field[b][a-1] == '.'|| field[b][a-1] == '&') && 0 <= b && b < y && 0 <= a-1 && a-1 < x)\n\t\tDFS(a-1,b);\n}\n\nvoid hey(int a,int b){\n\tfield[b][a] = '-';\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tif(field[b+i][a+j]=='#' && (0 <= a+j && b+i < y) && (0 <= a+j && a+j < x))\n\t\t\t\they(a+j,b+i);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> x >> y){\n\t\tif(!x && !y)\n\t\t\tbreak;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<x;i++){\n\t\t\tif(field[0][i] == '.')\n\t\t\t\tfield[0][i] = '-';\n\t\t\tif(field[y-1][i] == '.')\n\t\t\t\tfield[y-1][i] = '-';\n\t\t}\n\t\tfor(int i=0;i<y;i++){\n\t\t\tif(field[i][0] == '.')\n\t\t\t\tfield[i][0] = '-';\n\t\t\tif(field[i][x-1] == '.')\n\t\t\t\tfield[i][x-1] = '-';\n\t\t}\n\t\tint count = 0;\n\t\tflag = false;\n\t\tfor(int i=0;i<y;i++){\n\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\tDFS(j,i);\n\t\t\t}\n\t\t}\n\t\twhile(!flag){\n\t\t\tint a,b;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '#'){\n\t\t\t\t\t\ta = j;b = i;\n\t\t\t\t\t\tgoto next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext:;\n\t\t\they(a,b);\n\t\t\tcount++;\n\t\t\tflag = false;\n\t\t\tfor(int i=0;i<y;i++){\n\t\t\t\tfor(int j=0;j<x;j++){\n\t\t\t\t\tif(field[i][j] == '-')\n\t\t\t\t\t\tDFS(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int b[][100],int x,int y,int m,int n,int c){\n  int mn=100;\n  if(x==0||x==m-1||y==0||y==n-1){\n    if(a[x][y])\n      return c+1;\n    else\n      return c;\n  }\n  if(b[x][y]==-1){\n    if(a[x][y])\n      b[x][y]=c+1;\n    else{\n      b[x][y]=c;\n      int tmp;\n      if((tmp=f(a,b,x-1,y,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x,y-1,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x+1,y,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if((tmp=f(a,b,x,y+1,m,n,c))>=0)\n\tmn=min(mn,tmp);\n      if(mn!=100)\n\treturn mn;\n    }\n  }\n  return -1;\n}\nint main(){\n  int i,j,k;\n  int a[100][100],b[100][100],mn,x,y,m,n;\n  string s;\n  for(;;){\n    cin>>m>>n;\n    if(m+n==0)\n      break;\n    memset(a,0,sizeof(a));\n    memset(b,-1,sizeof(b));\n    for(i=0;i<n;i++){\n      cin>>s;\n      for(j=0;j<m;j++){\n\tif(s[j]=='#')\n\t  a[j][i]=1;\n\telse if(s[j]=='&'){\n\t  x=j;\n\t  y=i;\n\t  b[x][y]=0;\n\t}\n      }\n    }\n    if(x==0||x==m-1||y==0||y==n-1)\n      mn=0;\n    else{\n      for(i=0;;i++){\n\tmn=100;\n\tfor(j=0;j<m;j++){\n\t  for(k=0;k<n;k++){\n\t    if(b[j][k]==i){\n\t      int tmp;\n\t      if((tmp=f(a,b,j-1,k,m,n,i))>=0)\n\t\tmn=min(mn,tmp);\n\t      if((tmp=f(a,b,j,k-1,m,n,i))>=0)\n\t\tmn=min(mn,tmp);\n\t      if((tmp=f(a,b,j+1,k,m,n,i))>=0)\n\t\tmn=min(mn,tmp);\n\t      if((tmp=f(a,b,j,k+1,m,n,i))>=0)\n\t\tmn=min(mn,tmp);\n\t    }\n\t  }\n\t}\n\tif(mn!=100)\n\t  break;\n      }\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint H,W;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_num){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tnum = arg_num;\n\t}\n\n\tint row,col,num;\n};\n\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H+1 && col >= 0 && col <= W+1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid func(){\n\n\tchar map[H+2][W+3];\n\n\tfor(int row = 0; row <= H+1; row++){\n\t\tfor(int col = 0; col <= W+1; col++){\n\t\t\tmap[row][col] = '.';\n\t\t}\n\t}\n\n\tchar buf[W+1];\n\tint goal_row,goal_col;\n\n\tfor(int row = 1; row <= H; row++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int col = 1; col <= W; col++){\n\t\t\tmap[row][col] = buf[col-1];\n\t\t\tif(buf[col-1] == '&'){\n\t\t\t\tgoal_row = row;\n\t\t\t\tgoal_col = col;\n\t\t\t}\n\t\t}\n\t}\n\n\tint min_count[H+2][W+2];\n\n\tfor(int row = 0; row <= H+1; row++){\n\t\tfor(int col = 0; col <= W+1; col++){\n\t\t\tmin_count[row][col] = BIG_NUM;\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tfor(int col = 1; col <= W; col++){\n\t\tmin_count[0][col] = 0;\n\t\tQ.push(Info(0,col,0));\n\t\tmin_count[H+1][col] = 0;\n\t\tQ.push(Info(H+1,col,0));\n\t}\n\n\tfor(int row = 1; row <= H; row++){\n\t\tmin_count[row][0] = 0;\n\t\tQ.push(Info(row,0,0));\n\t\tmin_count[row][W+1] = 0;\n\t\tQ.push(Info(row,W+1,0));\n\t}\n\n\tint next_row,next_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row == goal_row && Q.front().col == goal_col){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().num > min_count[Q.front().row][Q.front().col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\tif(!rangeCheck(next_row,next_col))continue;\n\n\t\t\t\tif(map[Q.front().row][Q.front().col] == '#' && map[next_row][next_col] != '#'){\n\t\t\t\t\tif(min_count[next_row][next_col] > Q.front().num+1){\n\t\t\t\t\t\tmin_count[next_row][next_col] = Q.front().num+1;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().num+1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(min_count[next_row][next_col] > Q.front().num){\n\t\t\t\t\t\tmin_count[next_row][next_col] = Q.front().num;\n\t\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().num));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",min_count[goal_row][goal_col]);\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1 << 20)\n#define MAX_V 12000\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int, int> P; // first??????????????¢???second??????????????????\n\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\n// ?????????O(|E|log|V|)\n\nvoid shortest_path(int s, int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\td[s] = 0;\n\t\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\tint W, H;\n\t\n\twhile(true){\n\t\t\n\t\tcin >> W >> H;\n\t\t\n\t\tif(W * H == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tstring map[200];\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> map[i + 1];\n\t\t\tmap[i + 1] = \".\" + map[i + 1] + \".\";\n\t\t}\n\t\t\n\t\tH += 2;\n\t\tW += 2;\n\t\t\n\t\tstring str = \"\";\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tstr = str + \".\";\n\t\t\tmap[0] = str;\n\t\t\tmap[H - 1] = str;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i < H - 1; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tint index1 = i * W + j;\n\t\t\t\tint index2 = (i + 1) * W + j;\n\t\t\t\tint cost;\n\t\t\t\tif(map[i][j] != map[i + 1][j] && (map[i][j] == '#' || map[i + 1][j] == '#')){\n\t\t\t\t\tcost = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tedge e1, e2;\n\t\t\t\te1.to = index2;\n\t\t\t\te2.to = index1;\n\t\t\t\te1.cost = cost;\n\t\t\t\te2.cost = cost;\n\t\t\t\tG[index1].push_back(e1);\n\t\t\t\tG[index2].push_back(e2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W - 1; j++){\n\t\t\t\tint index1 = i * W + j;\n\t\t\t\tint index2 = i * W + j + 1;\n\t\t\t\tint cost;\n\t\t\t\tif(map[i][j] != map[i][j + 1] && (map[i][j] == '#' || map[i][j + 1] == '#')){\n\t\t\t\t\tcost = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcost = 0;\n\t\t\t\t}\n\t\t\t\tedge e1, e2;\n\t\t\t\te1.to = index2;\n\t\t\t\te2.to = index1;\n\t\t\t\te1.cost = cost;\n\t\t\t\te2.cost = cost;\n\t\t\t\tG[index1].push_back(e1);\n\t\t\t\tG[index2].push_back(e2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint index_goal;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(map[i][j] == '&'){\n\t\t\t\t\tindex_goal = i * W + j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint V = H * W;\n\t\t\n\t\tshortest_path(0, V);\n\t\t\n\t\tcout << d[index_goal] / 2 << endl;\n\t\t/*\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tcout << d[i * W + j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nstruct STATE\n{\n\tint x, y, d;\n\tbool operator<(const STATE &t)const{\n\t\treturn d > t.d;\n\t}\n};\n\nchar grid[128][128];\nint d[128][128];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(grid, '.', sizeof(grid));\n\t\tfor (int i = 0; i < 128; i++){\n\t\t\tfor (int j = 0; j < 128; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint sx, sy;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == '&'){\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\tpriority_queue<STATE> que;\n\t\tfor (que.push({sx, sy, 0}); !que.empty(); que.pop()){\n\t\t\tSTATE st = que.top();\n\t\t\tif (d[st.x][st.y] <= st.d) continue;\n\t\t\td[st.x][st.y] = st.d;\n\t\t\tif (st.x == 0 || st.y == 0 || st.x == h + 1 || st.y == w + 1){\n\t\t\t\tres = st.d;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (d[tx][ty] > st.d + (grid[st.d][st.d] == '#')){\n\t\t\t\t\tque.push({tx, ty, st.d + (grid[st.x][st.y] == '#')});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nint n,m;\nint gx,gy;\nint INF=1000000;\nchar fie[121][121];\nint jp[121][121];\nint ans;\nint dx[5]={1,0,-1,0,0};\nint dy[5]={0,1,0,-1,0};\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nvoid bfs(){\n\tqueue<PP> que;\n\tfor(int i=0;i<=120;i++){\n\t\tfor(int j=0;j<=120;j++){\n\t\t\tjp[j][i]=INF;\n\t\t}\n\t}\n\tque.push(PP(P(gx,gy),0));\n\tjp[gx][gy]=0;\n\twhile(que.size()){\n\t\tPP p=que.front();que.pop();\n\t\tfor(int i=0;i<=4;i++){\n\t\t\tint kx=p.first.first+dx[i],ky=p.first.second+dy[i],k=p.second;\n\t\t\tif(ky>=0 && ky<n && kx>=0 && kx<m){\n\t\t\t\tif(fie[kx][ky]=='.' && k<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k));\n\t\t\t\t\tjp[kx][ky]=k;\n\t\t\t\t}\n\t\t\t\tif(fie[kx][ky]=='#' && k+1<jp[kx][ky]){\n\t\t\t\t\tque.push(PP(P(kx,ky),k+1));\n\t\t\t\t\tjp[kx][ky]=k+1;\n\t\t\t\t}\n\t\t\t}else ans=min(ans,k);\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\tans=INF;\n\t\tmemset(fie,'.',sizeof(fie));\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> fie[i];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(fie[i][j]=='&')gx=j,gy=i;\n\t\t\t}\n\t\t}\n\t\tbfs();\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n \nusing namespace std;\n \n#define MAX 120\n#define INF 1e9\n \nint H, W;\nchar field[MAX][MAX];\nconst int dx[] = {-1,0,0,1};\nconst int dy[] = {0,-1,1,0};\n \nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nbool check(int y, int x){\n  if(y == 0 || y == H-1) return true;\n  if(x == 0 || x == W-1) return true;\n  return false;\n}\n \nvoid bfs(int y, int x){\n  int ans = INF;\n  int cost[MAX][MAX];\n  fill(cost[0], cost[MAX], INF);\n  queue<int> nowx, nowy;\n  nowx.push(x); nowy.push(y); \n  cost[y][x] = 0;\n \n  while(!nowx.empty()){\n    int xx = nowx.front(); nowx.pop();\n    int yy = nowy.front(); nowy.pop();\n    int cnt = cost[yy][xx];\n \n    for(int i = 0 ; i < 4 ; i++){\n      int nx = xx + dx[i];\n      int ny = yy + dy[i];\n \n      if(!inField(ny, nx)) continue;\n      if(check(ny, nx)){\n        if(field[yy][xx] != '#' && field[ny][nx] == '#'){\n          cost[ny][nx] = min(cost[ny][nx], cnt+1);\n        }else{\n          cost[ny][nx] = min(cost[ny][nx], cnt);\n        }\n        continue;\n      }\n      int ncnt = cnt;\n      if(field[yy][xx] != '#' && field[ny][nx] == '#') ncnt++;\n      if(ncnt < cost[ny][nx]){\n        cost[ny][nx] = ncnt;\n        nowx.push(nx); nowy.push(ny);\n      }\n    }\n  }\n  for(int i = 0 ; i < H ; i++){\n    ans = min(ans, cost[i][0]);\n    ans = min(ans, cost[i][W-1]);\n  }\n  for(int i = 0 ; i < W ; i++){\n    ans = min(ans, cost[0][i]);\n    ans = min(ans, cost[H-1][i]);\n  }\n \n  cout << ans << endl;\n}\n \nint main(){\n  int sx, sy;\n  while(cin >> W >> H, (W | H)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == '&'){\n          sx = j; sy = i;\n        }\n      }\n    }  \n    bfs(sy, sx);\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nint dis[110][110],p[110][110];\ntypedef pair<int,pair<int,int> >P;\npriority_queue<P,vector<P>,greater<P> >Q;\nvoid Qpush(int a,int b,int c){Q.push(make_pair(a,make_pair(b,c)));}\nint main(){\n  int h,w;\n  while(cin>>w>>h&&h+w){\n    lol(i,h)lol(j,w){\n      char z;cin>>z;\n      if(z=='&')Qpush(0,i,j);\n      if(z=='#')p[i][j]=1;\n      else p[i][j]=0;\n      dis[i][j]=mod;\n    }\n    while(!Q.empty()){\n      int cost=Q.top().first;\n      int y=Q.top().second.first;\n      int x=Q.top().second.second;\n      Q.pop();\n      if(dis[y][x]<=cost)continue;\n      dis[y][x]=cost;\n      int dx[]={-1,0,1,0},dy[]={0,1,0,-1};\n      lol(i,4){\n\tint xx=x+dx[i],yy=y+dy[i];\n\tif(xx<0||xx==w||yy<0||yy==h)continue;\n\tint newcost=cost+(p[y][x]!=p[yy][xx]);\n\tif(dis[yy][xx]>newcost)Qpush(newcost,yy,xx);\n      }\n    }\n    int ans=mod;\n    for(int i=0;i<h;i++)ans=min(ans,min(dis[i][0],dis[i][w-1]));\n    for(int j=0;j<w;j++)ans=min(ans,min(dis[0][j],dis[h-1][j]));\n    cout<<(ans+1)/2<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\nusing namespace std;\nint main(){\n  int w,h;\n  string line;\n  while(true){\n    cin>>w>>h;\n    if(!w&&!h)\n      break;\n    vector<string> castle;\n    for(int i=0;i<h;i++){\n      cin>>line;\n      castle.push_back(line);\n    }\n    int count[w+2][h+2];\n    int sx,sy;\n    const int MAX = 100;\n    for(int y=1;y<h+1;y++){\n      for(int x=1;x<w+1;x++){\n\tcount[x][y] = MAX;\n\tif (castle[y-1][x-1]=='&'){\n\t  sx = x;\n\t  sy = y;\n\t  castle[y-1][x-1]='.';\n\t}\n      }\n    }\n    int min = MAX;\n    int dx[4] = {1,0,-1,0};\n    int dy[4] = {0,1,0,-1};\n    count[sx][sy] = 0;\n    queue<int> st;\n    st.push(sy*(w+2)+sx);\n    while(!st.empty()){\n      int x = st.front()%(w+2);\n      int y = st.front()/(w+2);\n      st.pop();\n      char c = castle[y-1][x-1];\n      int n;\n      for(int d=0;d<4;d++){\n\tn = count[x][y];\n\tif(x+dx[d]>0&&y+dy[d]>0&&x+dx[d]<w+1&&y+dy[d]<h+1){\n\t  if(c=='.'&&castle[y+dy[d]-1][x+dx[d]-1]=='#')\n\t    n++;\n\t  if(n<count[x+dx[d]][y+dy[d]]){\n\t    count[x+dx[d]][y+dy[d]] = n;\n\t    st.push((y+dy[d])*(w+2)+x+dx[d]);\n\t  }\n\t}\n\telse{\n\t  if(n<min)\n\t    min = n;\n\t}\n      }\n    }\n    cout<<min<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF (1<<24)\nusing namespace std;\nint W,H,mini,mini_x,mini_y,ny,nx,cost;\nstring str;\n\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\n\nchar t[102][102];\nbool vd[102][102];\nint u[102][102];\n\nint main(){\n  while(cin>>W>>H){\n    for(int i=0;i<102;i++)for(int j=0;j<102;j++){\n\tt[i][j]='.';\n\tvd[i][j]=false;\n\tu[i][j]=INF;\n      }\n\n    for(int i=1;i<=H;i++){\n      cin>>str;\n      for(int j=1;j<=W;j++){\n\tt[i][j]=str[j-1];\n\tif(t[i][j]=='&')u[i][j]=0;\n      }\n    }\n    /*\n    for(int i=0;i<H+2;i++){\n      for(int j=0;j<W+2;j++){\n\tcout<<t[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    \n    while(1){\n      mini=INF;\n      for(int i=0;i<H;i++){\n\tfor(int j=0;j<W;j++){\n\t  if(mini>u[i][j]&&vd[i][j]==false){\n\t    mini=u[i][j];\n\t    mini_y=i;\n\t    mini_x=j;\n\t  }\n\t}\n      }\n\n      if(mini==INF)break;\n\n      vd[mini_y][mini_x]=true;\n\n      //cout<<mini_y<<' '<<mini_x<<' '<<u[mini_y][mini_x]<<endl;\n\n      \n      if(mini_y==0||mini_x==0||mini_y==H+1||mini_x==W+1){\n\tcout<<u[mini_y][mini_x]<<endl;\n\tbreak;\n      }\n      \n\n      for(int i=0;i<4;i++){\n\tny=mini_y+dy[i];\n\tnx=mini_x+dx[i];\n\n\tcost=((t[mini_y][mini_x]!='#'&&t[ny][nx]=='#')?1:0);\n\n\tif(u[ny][nx]>u[mini_y][mini_x]+cost){\n\t  u[ny][nx]=u[mini_y][mini_x]+cost;\n\t}\n      }\n\t\n      \n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\n#include<unordered_map>\n#include<map>\n#define P pair<int,int>\nusing namespace std;\n\nint a, b;\nstring c[102];\nint dx[4] = { -1,0,0,1 }, dy[4] = { 0,-1,1,0 };\nvector<P>V;\nint main() {\n\twhile (cin >> b >> a, a | b) {\n\t\tstring f;\n\t\tfor (int g = 0; g < b + 2; g++)f += \".\";\n\t\tc[0] = c[a + 1] = f;\n\t\tfor (int d = 0; d < a; d++) {\n\t\t\tstring e; cin >> e;\n\t\t\tc[d + 1] = \".\" + e + \".\";\n\t\t}\n\t\ta+=2; b+=2;\n\t\tfor (int I = 0;; I++) {\n\t\t\tqueue<P>Q;\n\t\t\tQ.push(P(0,0));\n\t\t\tc[0][0] = 0;\n\t\t\tV.push_back(P(0,0));\n\t\t\twhile (Q.size()) {\n\t\t\t\tP t = Q.front(); Q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint x = t.first + dx[i], y = t.second + dy[i];\n\t\t\t\t\tif (x >= 0 && x < a&&y >= 0 && y < b) {\n\t\t\t\t\t\tif (c[x][y] == '.') {\n\t\t\t\t\t\t\tV.push_back(P(x, y));\n\t\t\t\t\t\t\tc[x][y] = 0;\n\t\t\t\t\t\t\tQ.push(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '#') {\n\t\t\t\t\t\t\tV.push_back(P(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (c[x][y] == '&') {\n\t\t\t\t\t\t\tcout << I << endl;\n\t\t\t\t\t\t\tgoto l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (P o : V) {\n\t\t\t\tc[o.first][o.second] = '.';\n\t\t\t}\n\t\t\tV.clear();\n\t\t}\n\tl:;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n#define MAX_M 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = { 0,-1, 0, 1};\nque_t queue[QUE_SIZE];\nint mx[MAX_M];\nint my[MAX_M];\nint que_in;\nint que_out;\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nbool\nbfs()\n{\n\tque_t que;\n\n\tix = 0;\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tmx[ix] = nx, my[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs())\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tcx = mx[i], cy = my[i];\n\t\t\tfield[cy][cx] = '.';\n\t\t\tque_push(cx, cy);\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "tdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nque_t queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(que_t *que)\n{\n\tqueue[que_in].x = que->x;\n\tqueue[que_in].y = que->y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int dy = -1; dy <= 1; ++dy)\n\t{\n\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t{\n\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '#')\n\t\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nbool\nbfs(int *cx, int *cy)\n{\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = { 0,-1, 0, 1};\n\tint mx = 0, my = 0;\n\tque_t que;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tque.x = *cx, que.y = *cy;\n\tque_push(&que);\n\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque.x = nx, que.y = ny;\n\t\t\t\t\tque_push(&que);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tif (nx > mx || ny > my)\n\t\t\t\t\t\tmx = nx, my = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*cx = mx, *cy = my;\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tfield[cy][cx] = ' ';\n\tint count = 0;\n\twhile (!bfs(&cx, &cy))\n\t{\n\t\tdfs(cx, cy);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint x[2000000],y[2000000];\nint main(){\n  int i,j,k,n,m,min,nx,ny,r,t;\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    char d[102][102]={0};\n    int c[102][102]={0};\n    for(i=1;i<=m;i++){\n      for(j=1;j<=n;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='&'){\n\t  y[t=0]=i;\n\t  x[t=0]=j;\n\t  d[i][j]='.';\n\t  c[i][j]=1;\n\t}\n      }\n    }\n    for(r=1;r-t;t++){\n      for(k=0;k<4;k++){\n\tny=y[t]+Y[k];\n\tnx=x[t]+X[k];\n\tif(!d[ny][nx])continue;\n\tif(d[y[t]][x[t]]==d[ny][nx]){\n\t  if(c[y[t]][x[t]]<c[ny][nx]||c[ny][nx]==0){\n\t    c[ny][nx]=c[y[t]][x[t]];\n\t    x[r  ]=nx;\n\t    y[r++]=ny;\n\t  }\n\t}\n\telse{\n\t  if(c[y[t]][x[t]]+1<c[ny][nx]||c[ny][nx]==0){\n\t    c[ny][nx]=c[y[t]][x[t]]+1;\n\t    x[r  ]=nx;\n\t    y[r++]=ny;\n\t  }\n\t}\n      }\n    }\n    /*for(i=1;i<=m;i++){\n      for(j=1;j<=n;j++)printf(\"%d \",c[i][j]);\n      printf(\"\\n\");\n      }*/\n    min=1000;\n    for(i=1;i<=m;i++){\n      if(min>c[i][1])min=c[i][1];\n      if(min>c[i][n])min=c[i][n];\n    }\n    for(i=1;i<=n;i++){\n      if(min>c[1][i])min=c[1][i];\n      if(min>c[m][i])min=c[m][i];\n    }\n    printf(\"%d\\n\",min/2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n#define MAX_M 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = { 0,-1, 0, 1};\nque_t queue[QUE_SIZE];\nint mx[MAX_M];\nint my[MAX_M];\nint que_in;\nint que_out;\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '*')\n\t\t\tdfs(nx, ny);\n\t}\n}\n\nbool\nbfs()\n{\n\tque_t que;\n\n\tix = 0;\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tmx[ix] = nx, my[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs())\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tdfs(mx[i], my[i]);\n\t\t\tque_push(mx[i], my[i]);\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[100000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 100000){\n        tail = 0;\n    }\n}\n\n\nint x, y;\n\nint floor(int ty, int tx)\n{\n    int ans;\n    \n    tx = tx >= x / 2 ? x - tx : tx + 1;\n    ty = ty >= y / 2 ? y - ty : ty + 1;\n    \n    ans = tx > ty ? ty : tx;\n    \n    return (ans);\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 100000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[100][100];\n    char map[100][101];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        getchar();\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                cost[i][j] = 100000;\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            if (0 == temp.tx || 0 == temp.ty || x - 1 == temp.tx || y - 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n            }\n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                if (0 <= mx && mx < x && 0 <= my && my < y && cost[my][mx] > temp.sharp){\n                    add = temp;\n                    cost[my][mx] = temp.sharp;\n                    if ((map[my][mx] == '#') && (floor(temp.ty, temp.tx) >= floor(my, mx))){\n                        cost[my][mx]++;\n                        add.sharp++;\n                    }\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nclass State\n{\npublic:\n  int x, y, cost;\n  bool water;\n\n  State(int _x, int _y, int _cost, bool _water)\n    :x(_x), y(_y), cost(_cost), water(_water) {}\n\n  bool operator < (const State& st) const\n  {\n    return this->cost > st.cost;\n  }\n};\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    if ((n|m) == 0)\n      break;\n\n    int sx, sy;\n    vector<string> castle(m);\n    for (int i = 0; i < m; ++i) {\n      cin >> castle[i];\n      castle[i].insert(castle[i].begin(), '.');\n      castle[i].insert(castle[i].end(), '.');\n\n      if (castle[i].find_first_of(\"&\") != string::npos) {\n\tsx = castle[i].find_first_of(\"&\");\n\tsy = i;\n\tcastle[sy][sx] = '.';\n      }\n    }\n    castle.insert(castle.begin(), string(n+2, '.'));\n    castle.push_back(string(n+2, '.'));\n    ++sy;\n\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0, false));\n    vector<vector<int> > dp(m+2, vector<int>(n+2, INF));\n    while (!que.empty()) {\n      const State st = que.top();\n      que.pop();\n\n      if (st.x == 0 || st.x == n+1 || st.y == 0 || st.y == m+1) {\n\tcout << st.cost << endl;\n\tbreak;\n      }\n\n      if (dp[st.y][st.x] < st.cost)\n\tcontinue;\n      dp[st.y][st.x] = st.cost;\n\n      for (int d = 0; d < 4; ++d) {\n\tint x = st.x + dx[d];\n\tint y = st.y + dy[d];\n\tif (x < 0 || n+2 <= x || y < 0 || m+2 <= y)\n\t  continue;\n\n\tif (st.water) {\n\t  if (castle[y][x] == '#' && dp[y][x] > st.cost) {\n\t    dp[y][x] = st.cost;\n\t    que.push(State(x, y, st.cost, true));\n\t  }\n\n\t  if (castle[y][x] == '.' && dp[y][x] > st.cost+1) {\n\t    dp[y][x] = st.cost+1;\n\t    que.push(State(x, y, st.cost+1, false));\n\t  }\n\t} else {\n\t  if (castle[y][x] == '#' && dp[y][x] > st.cost) {\n\t    dp[y][x] = st.cost;\n\t    que.push(State(x, y, st.cost, true));\n\t  }\n\n\t  if (castle[y][x] == '.' && dp[y][x] > st.cost) {\n\t    dp[y][x] == st.cost;\n\t    que.push(State(x, y, st.cost, false));\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define min(x,y)((x)<(y)?(x):(y))\nH,W,M[101*104],S[101*104];\ni,f,s;\nmain(){\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;){\n\t\tW++;\n\t\tmemset(M,'.',sizeof(M));\n\t\tmemset(S,1,sizeof(S));\n\t\tfor(i=0;i<H*W;i++){\n\t\t\tf=getchar();\n\t\t\tif(f=='&')\n\t\t\t\tS[W*2+i]=0;\n\t\t\tM[W*2+i]=f!='#';\n\t\t}\n\t\tfor(f=1;f;){\n\t\t\tf=0;\n\t\t\tfor(i=0;i<(H+2)*W;i++){\n\t\t\t\ts=S[W+i];\n\t\t\t\ts=min(s,S[W+i+1]+(M[W+i]<M[W+i+1]));\n\t\t\t\ts=min(s,S[W+i-1]+(M[W+i]<M[W+i-1]));\n\t\t\t\ts=min(s,S[W+i+W]+(M[W+i]<M[W+i+W]));\n\t\t\t\ts=min(s,S[W+i-W]+(M[W+i]<M[W+i-W]));\n\t\t\t\tif(S[W+i]!=s)\n\t\t\t\t\tS[W+i]=s,f=1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",S[W]);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nvoid func(void);\nvoid back(int,int,char,int);\n\nchar tizu[102][102];\nint flg[102][102];\nint n,m;\nint f;\n\nint main(void)\n{\n\tscanf(\"%d %d\",&n,&m);\n\twhile(!(n==0 && m==0))\t{\n\t\tfunc();\n\t\tscanf(\"%d %d\",&n,&m);\n\t}\n\treturn 0;\n}\nvoid func(void)\n{\n\tint i,j,cnt;\n\tchar buf[101];\n\tfor(j=0;j<n+2;j++)\t{\n\t\ttizu[0][j]='.';\n\t\ttizu[m+1][j]='.';\n\t}\n\tfor(i=1;i<m+1;i++)\t{\n\t\tscanf(\"%s\",buf);\n\t\ttizu[i][0]='.';\n\t\ttizu[i][n+1]='.';\n\t\tfor(j=1;j<n+1;j++)\t{\n\t\t\ttizu[i][j]=buf[j-1];\n\t\t}\n\t}\n\tfor(i=0;i<m+2;i++)\t{\n\t\tfor(j=0;j<n+2;j++)\t{\n\t\t\tflg[i][j]=-1;\n\t\t}\n\t}\n\tcnt=0;\tf=0;\n\twhile(1)\t{\n\t\tif(cnt==0)\t{\n\t\t\tflg[0][0]=cnt;\n\t\t\tback(0,0,'.',0);\n\t\t\tif(f==1)\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfor(i=0;i<m+2;i++)\t{\n\t\t\t\tfor(j=0;j<n+2;j++)\t{\n\t\t\t\t\tif(flg[i][j]==cnt-1 && tizu[i][j]=='#')\t{\n\t\t\t\t\t\tback(i,j,'.',cnt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==1)\tbreak;\n\t\t}\n\t\tfor(i=0;i<m+2;i++)\t{\n\t\t\tfor(j=0;j<n+2;j++)\t{\n\t\t\t\tif(flg[i][j]==cnt && tizu[i][j]=='.')\t{\n\t\t\t\t\tback(i,j,'#',cnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f==1)\t{\n\t\t\tcnt++;\n\t\t\tbreak;\t\t\n\t\t}\n\t\tcnt++;\n\t}\n\tprintf(\"%d\\n\",cnt);\n}\nvoid back(int y,int x,char c,int cnt)\n{\n\tint i,j,k;\n\tint xx,yy;\n\tint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\n\t\n\tfor(k=0;k<4;k++)\t{\n\t\txx=x+dx[k];\tyy=y+dy[k];\n\t\tif(yy>=0 && yy<m+2 && xx>=0 && xx<n+2 && flg[yy][xx]==-1 )\t{\n\t\t\tif(tizu[yy][xx]=='&')\t{\n\t\t\t\tflg[yy][xx]=cnt;\n\t\t\t\tf=1;\n\t\t\t}\n\t\t\tif(tizu[yy][xx]==c)\t{\n\t\t\t\tflg[yy][xx]=cnt;\n\t\t\t\tback(yy,xx,c,cnt);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[10000000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 10000000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 10000000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y + 1; i++){\n            for (j = 0; j <= x + 1; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[40000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 40000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 40000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int mx, my;\n    int x, y;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[100][100];\n    char map[100][101];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        getchar();\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                cost[i][j] = 10000;\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            if (0 == temp.tx || 0 == temp.ty || x - 1 == temp.tx || y - 1 == temp.ty){\n                cost[temp.ty][temp.tx] = temp.sharp;\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n            }\n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                if (0 <= mx && mx < x && 0 <= my && my < y && cost[my][mx] > temp.sharp){\n                    add = temp;\n                    cost[my][mx] = temp.sharp;\n                    if (map[my][mx] == '#'){\n                        cost[my][mx]++;\n                        add.sharp++;\n                    }\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint result;\nchar map[102][103];\nint map2[102][102];\n\nvoid tansaku(int x,int y,int now_cost,int is_hori) {\n\tint here_is_hori;\n\tif(x<0 || x>width+1 || y<0 || y>height+1)return;\n\tif(is_hori && map[y][x]!='#')now_cost++;\n\tif(map2[y][x]<=now_cost)return;\n\tmap2[y][x]=now_cost;\n\tif(map[y][x]=='&')result=now_cost;\n\there_is_hori=(map[y][x]=='#');\n\ttansaku(x-1,y,now_cost,here_is_hori);\n\ttansaku(x+1,y,now_cost,here_is_hori);\n\ttansaku(x,y-1,now_cost,here_is_hori);\n\ttansaku(x,y+1,now_cost,here_is_hori);\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][0]='.';\n\t\t\tmap[i][width+1]='.';\n\t\t}\n\t\tfor(i=0;i<=width+1;i++) {\n\t\t\tmap[0][i]='.';\n\t\t\tmap[height+1][i]='.';\n\t\t\tfor(j=0;j<=height+1;j++) {\n\t\t\t\tmap2[j][i]=0x7fffffff;\n\t\t\t}\n\t\t}\n\t\ttansaku(0,0,0,0);\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0156 Moats around the Castle\n   2017.8.22 bal4u@uu\n   ?????¢?????£?????§???Union???????????§?????????\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x7fffffff\n#define N 105\t\t\t// >= 100+2\n#define MAX 11500\t\t// >= N*N\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX], pmax;\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1; }\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\n\n\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n  int l, r;\n  int smallest;\n\n  l = LEFT(i), r = RIGHT(i);\n  if (l < qsize && que[l].t < que[i].t) smallest = l; else smallest = i;\n  if (r < qsize && que[r].t < que[smallest].t) smallest = r;\n  if (smallest != i) {\n    QUE t = que[i]; que[i] = que[smallest]; que[smallest] = t;\n    min_heapify(smallest);\n  }\n}\n\nint deq(int *n)\n{\n  if (qsize == 0) return 0;\n  *n = que[0].node;\n  que[0] = que[--qsize];\n  min_heapify(0);\n  return 1;\n}\n\nvoid enq(int n, int t)\n{\n  int i, ii;\n\n  i = qsize++;\n  que[i].node = n, que[i].t = t;\n  while (i > 0 && que[ii = PARENT(i)].t > que[i].t) {\n    QUE tt = que[i]; que[i] = que[ii]; que[ii] = tt;\n    i = ii;\n  }\n}\n\ntypedef struct { char c; int x; } T;\nT map[N+5][N+5]; int R, C;\n\n#define TOSIZE 500\ntypedef struct { int len, lim, *to; } TBL;\nTBL *tbl; int *node; char *visited; int size;\nint tr[MAX];\n\nint start, goal, gr, gc;\n\nint search(void)\n{\n\tint i, k, s, e;\n\tTBL *tp;\n\n\tqsize = 0;\n\tfor (i = 0; i < size; i++) node[i] = INF, visited[i] = 0;\n\tnode[start] = 0;\n\tenq(start, 0);\n\twhile(deq(&s)) {\n\t\tif (s == goal) break;\n\t\tif (visited[s]) continue;\n\t\tvisited[s] = 1;\n\t\ttp = tbl + s;\n\t\tfor (i = 0; i < tp->len; i++) {\n\t\t\te = tp->to[i];\n\t\t\tif (visited[e]) continue;\n\t\t\tk = node[s] + 1;\n\t\t\tif (k < node[e]) node[e] = k, enq(e, k); \n\t\t}\n\t}\n\treturn node[goal];\n}\n\nvoid checkMem(TBL *p)\n{\n\tint *to;\n\tif (p->len < p->lim) return;\n\tto = calloc(2 * p->lim + 2, sizeof(int));\n\tmemcpy(to, p->to, p->lim * sizeof(int));\n\tp->lim *= 2;\n\tfree(p->to);\n\tp->to = to;\n}\n\nvoid lnk(int r1, int c1, int r2, int c2) { union_set(map[r1][c1].x, map[r2][c2].x); }\n\nint main()\n{\n\tint r, c, r2, c2, k, cc, x1, x2, i;\n\tchar buf[N];\n\tint mv[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tfor (r = 1; r <= R; r++) {\n\t\t\tscanf(\"%s\", buf+1);\n\t\t\tfor (c = 1; c <= C; c++) map[r][c].c = buf[c];\n\t\t}\n\t\tR += 2, C += 2;\n\t\tfor (r = 0; r < R; r++) map[r][0].c = map[r][C-1].c = '.';\n\t\tfor (c = 0; c < C; c++) map[0][c].c = map[R-1][c].c = '.';\n\t\tfor (pmax = 1, r = 0; r < R; r++) for (c = 0; c < C; c++) {\n\t\t\tif (map[r][c].c == '&') gr = r, gc = c, map[r][c].x = 0, make_set(0);\n\t\t\telse map[r][c].x = pmax, make_set(pmax++);\n\t\t}\n\t\tfor (r = 0; r < R; r++) lnk(r, 0, 0, 0), lnk(r, C-1, 0, 0);\n\t\tfor (c = 0; c < C; c++) lnk(0, c, 0, 0), lnk(R-1, c, 0, 0);\n\n\t\tR--, C--;\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tcc = map[r][c].c;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif ((r == gr && c == gc && map[r2][c2].c == '.') || map[r2][c2].c == cc) lnk(r2, c2, r, c);\n\t\t\t}\n\t\t}\n\n\t\tstart = find_set(map[0][0].x), goal = find_set(map[gr][gc].x);\n\t\tif (start == goal) { puts(\"0\"); continue; }\n\n\t\tmemset(tr, 0, sizeof(tr));\n\t\tfor (x1 = 0; x1 < pmax; x1++) tr[find_set(x1)] = 1;\n\t\tfor (size = 0, x1 = 0; x1 < pmax; x1++) if (tr[x1]) tr[x1] = size++;\n\t\tstart = tr[start], goal = tr[goal];\n\n\t\ttbl = calloc(size+2, sizeof(TBL));\n\t\tnode = calloc(size+2, sizeof(int));\n\t\tvisited = calloc(size+2, sizeof(char));\n\t\tfor (i = 0; i < size; i++) {\n\t\t\ttbl[i].len = 0, tbl[i].lim = TOSIZE, tbl[i].to = calloc(TOSIZE+2, sizeof(int));\n\t\t}\n\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tx1 = find_set(map[r][c].x), x2 = find_set(map[r2][c2].x);\n\t\t\t\tif (x1 == x2) continue;\n\t\t\t\tx1 = tr[x1], x2 = tr[x2];\n\t\t\t\tfor (i = 0; i < tbl[x1].len; i++) {\n\t\t\t\t\tif (tbl[x1].to[i] == x2) break;\n\t\t\t\t}\n\t\t\t\tif (i < tbl[x1].len) continue;\n\t\t\t\tcheckMem(tbl+x1);\n\t\t\t\ttbl[x1].to[tbl[x1].len++] = x2;\n\t\t\t\tcheckMem(tbl+x2);\n\t\t\t\ttbl[x2].to[tbl[x2].len++] = x1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", search() / 2);\n\t\tfor (i = 0; i < size; i++) free(tbl[i].to);\n\t\tfree(visited), free(node), free(tbl);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nque_t queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(que_t *que)\n{\n\tqueue[que_in].x = que->x;\n\tqueue[que_in].y = que->y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int dy = -1; dy <= 1; ++dy)\n\t{\n\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t{\n\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '#')\n\t\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nbool\nbfs(int *cx, int *cy)\n{\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = { 0,-1, 0, 1};\n\tint mx = 0, my;\n\tque_t que;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tque.x = *cx, que.y = *cy;\n\tque_push(&que);\n\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque.x = nx, que.y = ny;\n\t\t\t\t\tque_push(&que);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tif (nx > mx)\n\t\t\t\t\t\tmx = nx, my = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*cx = mx, *cy = my;\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tfield[cy][cx] = ' ';\n\tint count = 0;\n\twhile (!bfs(&cx, &cy))\n\t{\n\t\tdfs(cx, cy);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint result;\nchar map[102][103];\nint map2[102][102];\n\nint tansaku(int x,int y,int now_cost,int is_hori,int force_hori) {\n\tint here_is_hori;\n\tint tansaku_did=0;\n\tif(x<0 || x>width+1 || y<0 || y>height+1)return 0;\n\tif(force_hori && map[y][x]!='#')return 0;\n\tif(is_hori && map[y][x]!='#')now_cost++;\n\tif(map2[y][x]<=now_cost)return 0;\n\tmap2[y][x]=now_cost;\n\there_is_hori=(map[y][x]=='#');\n\tif(here_is_hori) {\n\t\ttansaku_did|=tansaku(x+1,y,now_cost,here_is_hori,1);\n\t\ttansaku_did|=tansaku(x,y+1,now_cost,here_is_hori,1);\n\t\ttansaku_did|=tansaku(x-1,y,now_cost,here_is_hori,1);\n\t\ttansaku_did|=tansaku(x,y-1,now_cost,here_is_hori,1);\n\t}\n\tif(!tansaku_did) {\n\t\ttansaku(x+1,y,now_cost,here_is_hori,0);\n\t\ttansaku(x,y+1,now_cost,here_is_hori,0);\n\t\ttansaku(x-1,y,now_cost,here_is_hori,0);\n\t\ttansaku(x,y-1,now_cost,here_is_hori,0);\n\t}\n\treturn 1;\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][0]='.';\n\t\t\tmap[i][width+1]='.';\n\t\t}\n\t\tfor(i=0;i<=width+1;i++) {\n\t\t\tmap[0][i]='.';\n\t\t\tmap[height+1][i]='.';\n\t\t\tfor(j=0;j<=height+1;j++) {\n\t\t\t\tmap2[j][i]=0x7fffffff;\n\t\t\t}\n\t\t}\n\t\ttansaku(0,0,0,0,0);\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tfor(j=1;j<=width;j++) {\n\t\t\t\tif(map[i][j]=='&') {\n\t\t\t\t\tprintf(\"%d\\n\",map2[i][j]);\n\t\t\t\t\ti=width+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,h,w,x,y,s,ll,sss,set[150][150],q[20000][2];\nchar map[150][150];\n\nint mark(int x,int y,int k,int lev){\n\tif(x<0 || y<0 || x>h+1 || y>w+1 || set[x][y]>=sss)return 0;\n\tchar c =map[x][y];\n\tif(c=='&'){\n\t\tprintf(\"%d\\n\",k-sss+lev);\n\t\treturn 1;\n\t}\n\tif( (c=='#' && lev==0) || (c!='#' && lev==1) ){\n\t\tset[x][y]=k+lev;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t\treturn 0;\n\t}\n\tset[x][y]=k;\n\tif(mark(x-1,y,k,lev))return 1;\n\tif(mark(x+1,y,k,lev))return 1;\n\tif(mark(x,y-1,k,lev))return 1;\n\tif(mark(x,y+1,k,lev))return 1;\n\treturn 0;\n}\n\n\nint main(){\n\twhile(scanf(\"%d %d\",&w,&h)*w*h){\n\t\tfor(i=0;i<=h+1;i++)memset(map[i],'.',w+2);\n\t\tfor(i=1;i<=h;i++)scanf(\"%s\",&map[i][1]);\n\t\t\n\t\tsss+=200;\n\t\tq[0][0]=0;q[0][1]=0;\n\t\tset[0][0]=sss;\n\t\ti=0;j=1;\n\n\t\twhile(i<j){\n\t\t\tx=q[i][0]; y=q[i][1]; s=set[x][y];\n\t\t\tif(map[x][y]=='#')ll=1; else ll=0;\n\t\t\tif(mark(x-1,y,s,ll))break;\n\t\t\tif(mark(x+1,y,s,ll))break;\n\t\t\tif(mark(x,y-1,s,ll))break;\n\t\t\tif(mark(x,y+1,s,ll))break;\n\t\t\ti++;\n\n\t\t\tint x,y;\n\t\t\tfor(x=0;x<=h+1;x++){\n\t\t\t\tfor(y=0;y<=w+1;y++){\n\t\t\t\t\tprintf(\"%4d\",set[x][y]-sss);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n#define MAX_M 1000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = { 0,-1, 0, 1};\nque_t queue[QUE_SIZE];\nint mx[MAX_M];\nint my[MAX_M];\nint que_in;\nint que_out;\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nbool\nbfs()\n{\n\tque_t que;\n\n\tix = 0;\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tmx[ix] = nx, my[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs())\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tcx = mx[i], cy = my[i];\n\t\t\tfield[cy][cx] = '.';\n\t\t\tque_push(cx, cy);\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0156 Moats around the Castle\n   2017.8.22 bal4u@uu\n   ?????¢?????£?????§???Union???????????§?????????\n*/\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n\n#define N 105\t\t\t// >= 100+2\n#define MAX 11500\t\t// >= N*N\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1; }\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\ntypedef struct { char c; int x; } T;\nT map[N+5][N+5]; int R, C;\nint gr, gc;\n\nvoid lnk(int r1, int c1, int r2, int c2) { union_set(map[r1][c1].x, map[r2][c2].x); }\n\n#define MAX2 3000\nint node[MAX2], len;\nint dis[MAX2][MAX2];\nint f[MAX];\nint s, g;\n\n#define INF 100000\nchar visited[MAX2+2];\nint total[MAX2+2];\n\nint search(int n, int s, int g)\n{\n\tint  i, j, next, min;\n\n\tfor (i = 0; i < n; i++) visited[i] = 0, total[i] = INF;\n\ttotal[s] = 0, next = s;\n\tdo {\n\t\ti = next, visited[i] = 1, min = INF;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (visited[j]) continue;\n\t\t\tif (dis[i][j] > 0 && total[i] + dis[i][j] < total[j]) {\n\t\t\t\ttotal[j] = total[i] + dis[i][j];\n\t\t\t}\n\t\t\tif (total[j] < min) min = total[j], next = j;\n\t\t}\n\t} while (min < INF);\n\treturn total[g];\n}\n\nint main()\n{\n\tint r, c, r2, c2, k, cc, x1, x2;\n\tchar buf[N];\n\tint mv[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tfor (r = 1; r <= R; r++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfor (c = 1; c <= C; c++) map[r][c].c = buf[c-1];\n\t\t}\n\t\tR += 2, C += 2;\n\t\tfor (r = 0; r < R; r++) map[r][0].c = map[r][C-1].c = '.';\n\t\tfor (c = 0; c < C; c++) map[0][c].c = map[R-1][c].c = '.';\n\t\tfor (k = r = 0; r < R; r++) for (c = 0; c < C; c++) map[r][c].x = k, make_set(k++);\n\t\tfor (r = 0; r < R; r++) lnk(r, 0, 0, 0), lnk(r, C-1, 0, 0);\n\t\tfor (c = 0; c < R; c++) lnk(0, c, 0, 0), lnk(R-1, c, 0, 0);\n\n\t\tR--, C--;\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tif (map[r][c].c == '&') gr = r, gc = c;\n\t\t\tcc = map[r][c].c;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r2][c2].c == cc) lnk(r2, c2, r, c);\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tr2 = gr + mv[k][0], c2 = gc + mv[k][1];\n\t\t\tif (map[r2][c2].c == '.') lnk(r2, c2, gr, gc);\n\t\t}\n\t\tif (p[map[0][0].x] == p[map[gr][gc].x]) { puts(\"0\"); continue; }\n\n\t\tmemset(f, -1, sizeof(f)); memset(dis, -1, sizeof(dis));\n\t\tfor (len = 0, r = 0; r <= R; r++) for (c = 0; c <= C; c++) {\n\t\t\tx1 = p[map[r][c].x];\n\t\t\tif (f[x1] < 0) f[x1] = len, node[len++] = x1;\n\t\t}\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c < C; c++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r][c].x != map[r2][c2].x) {\n\t\t\t\t\tx1 = f[p[map[r][c].x]], x2 = f[p[map[r2][c2].x]];\n\t\t\t\t\tdis[x1][x2] = dis[x2][x1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = search(len, f[p[map[0][0].x]], f[p[map[gr][gc].x]]);\n\t\tif (k & 1) k++;\n\t\tprintf(\"%d\\n\", k >> 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0156 Moats around the Castle\n   2017.8.22 bal4u@uu\n   ?????¢?????£?????§???Union???????????§?????????\n*/\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n\n#define N 105\t\t\t// >= 100+2\n#define MAX 11500\t\t// >= N*N\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1; }\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\ntypedef struct { char c; int x; } T;\nT map[N+5][N+5]; int R, C;\nint gr, gc;\n\nvoid lnk(int r1, int c1, int r2, int c2) { union_set(map[r1][c1].x, map[r2][c2].x); }\n\n#define MAX2 500\nint node[MAX2], len;\nint dis[MAX2][MAX2];\nint f[MAX];\nint s, g;\n\n#define INF 100000\nchar visited[MAX2+2];\nint total[MAX2+2];\n\nint search(int n, int s, int g)\n{\n\tint  i, j, next, min;\n\n\tfor (i = 0; i < n; i++) visited[i] = 0, total[i] = INF;\n\ttotal[s] = 0, next = s;\n\tdo {\n\t\ti = next, visited[i] = 1, min = INF;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (visited[j]) continue;\n\t\t\tif (dis[i][j] > 0 && total[i] + dis[i][j] < total[j]) {\n\t\t\t\ttotal[j] = total[i] + dis[i][j];\n\t\t\t}\n\t\t\tif (total[j] < min) min = total[j], next = j;\n\t\t}\n\t} while (min < INF);\n\treturn total[g];\n}\n\nint main()\n{\n\tint r, c, r2, c2, k, cc, x1, x2;\n\tchar buf[N];\n\tint mv[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tfor (r = 1; r <= R; r++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfor (c = 1; c <= C; c++) map[r][c].c = buf[c-1];\n\t\t}\n\t\tR += 2, C += 2;\n\t\tfor (r = 0; r < R; r++) map[r][0].c = map[r][C-1].c = '.';\n\t\tfor (c = 0; c < C; c++) map[0][c].c = map[R-1][c].c = '.';\n\t\tfor (k = r = 0; r < R; r++) for (c = 0; c < C; c++) map[r][c].x = k, make_set(k++);\n\t\tfor (r = 0; r < R; r++) lnk(r, 0, 0, 0), lnk(r, C-1, 0, 0);\n\t\tfor (c = 0; c < R; c++) lnk(0, c, 0, 0), lnk(R-1, c, 0, 0);\n\n\t\tR--, C--;\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tif (map[r][c].c == '&') gr = r, gc = c;\n\t\t\tcc = map[r][c].c;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r2][c2].c == cc) lnk(r2, c2, r, c);\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tr2 = gr + mv[k][0], c2 = gc + mv[k][1];\n\t\t\tif (map[r2][c2].c == '.') lnk(r2, c2, gr, gc);\n\t\t}\n\t\tif (p[map[0][0].x] == p[map[gr][gc].x]) { puts(\"0\"); continue; }\n\n\t\tmemset(f, -1, sizeof(f)); memset(dis, -1, sizeof(dis));\n\t\tfor (len = 0, r = 0; r <= R; r++) for (c = 0; c <= C; c++) {\n\t\t\tx1 = p[map[r][c].x];\n\t\t\tif (f[x1] < 0) f[x1] = len, node[len++] = x1;\n\t\t}\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c < C; c++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r][c].x != map[r2][c2].x) {\n\t\t\t\t\tx1 = f[p[map[r][c].x]], x2 = f[p[map[r2][c2].x]];\n\t\t\t\t\tdis[x1][x2] = dis[x2][x1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = search(len, f[p[map[0][0].x]], f[p[map[gr][gc].x]]);\n\t\tif (k & 1) k++;\n\t\tprintf(\"%d\\n\", k >> 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint x, y;\nint cost[100][100];\nchar map[100][101];\n\nint getmin(int sy, int sx, int d)\n{\n    int i;\n    int ret = 100000;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int mx, my;\n    int temp;\n    \n    if (0 == sx || 0 == sy || x - 1 == sx || y - 1 == sy){\n        cost[my][mx] = d;\n        return (cost[my][mx]);\n    }\n    \n    for (i = 0; i < 4; i++){\n        mx = sx + dx[i];\n        my = sy + dy[i];\n        \n        if (0 <= mx && mx < x && 0 <= my && my < y && cost[my][mx] > d){\n            cost[my][mx] = d;\n            if (map[my][mx] == '#'){\n                cost[my][mx]++;\n                temp = getmin(my, mx, d + 1);\n            }\n            else {\n                temp = getmin(my, mx, d);\n            }\n            ret = temp > ret ? ret : temp;\n        }\n    }\n    \n    return (ret);\n}\n\nint main(void)\n{\n    int ans;\n    int i, j;\n    int sx, sy;\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        getchar();\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                cost[i][j] = 100000;\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    sx = j;\n                    sy = i;\n                }\n            }\n            getchar();\n        }\n        cost[sy][sx] = 0;\n        ans = getmin(sy, sx, 0);\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nque_t queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tque_push(x, y);\n\tfor (int dy = -1; dy <= 1; ++dy)\n\t{\n\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t{\n\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '*')\n\t\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nbool\nbfs(int *cx, int *cy)\n{\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = { 0,-1, 0, 1};\n\tque_t que;\n\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tif (nx > *cx)\n\t\t\t\t\t\t*cx = nx, *cy = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs(&cx, &cy))\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\t\tdfs(cx, cy);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0156 Moats around the Castle\n   2017.8.22 bal4u@uu\n   ?????¢?????£?????§???Union???????????§?????????\n*/\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n\n#define N 105\t\t\t// >= 100+2\n#define MAX 11500\t\t// >= N*N\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1; }\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\ntypedef struct { char c; int x; } T;\nT map[N+5][N+5]; int R, C;\nint gr, gc;\n\nvoid lnk(int r1, int c1, int r2, int c2) { union_set(map[r1][c1].x, map[r2][c2].x); }\n\n#define MAX2 5000\nint node[MAX2], len;\nint dis[MAX2][MAX2];\nint f[MAX];\nint s, g;\n\n#define INF 100000\nchar visited[MAX2+2];\nint total[MAX2+2];\n\nint search(int n, int s, int g)\n{\n\tint  i, j, next, min;\n\n\tfor (i = 0; i < n; i++) visited[i] = 0, total[i] = INF;\n\ttotal[s] = 0, next = s;\n\tdo {\n\t\ti = next, visited[i] = 1, min = INF;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (visited[j]) continue;\n\t\t\tif (dis[i][j] > 0 && total[i] + dis[i][j] < total[j]) {\n\t\t\t\ttotal[j] = total[i] + dis[i][j];\n\t\t\t}\n\t\t\tif (total[j] < min) min = total[j], next = j;\n\t\t}\n\t} while (min < INF);\n\treturn total[g];\n}\n\nint main()\n{\n\tint r, c, r2, c2, k, cc, x1, x2;\n\tchar buf[N];\n\tint mv[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tfor (r = 1; r <= R; r++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfor (c = 1; c <= C; c++) map[r][c].c = buf[c-1];\n\t\t}\n\t\tR += 2, C += 2;\n\t\tfor (r = 0; r < R; r++) map[r][0].c = map[r][C-1].c = '.';\n\t\tfor (c = 0; c < C; c++) map[0][c].c = map[R-1][c].c = '.';\n\t\tfor (k = r = 0; r < R; r++) for (c = 0; c < C; c++) map[r][c].x = k, make_set(k++);\n\t\tfor (r = 0; r < R; r++) lnk(r, 0, 0, 0), lnk(r, C-1, 0, 0);\n\t\tfor (c = 0; c < R; c++) lnk(0, c, 0, 0), lnk(R-1, c, 0, 0);\n\n\t\tR--, C--;\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tif (map[r][c].c == '&') gr = r, gc = c;\n\t\t\tcc = map[r][c].c;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r2][c2].c == cc) lnk(r2, c2, r, c);\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tr2 = gr + mv[k][0], c2 = gc + mv[k][1];\n\t\t\tif (map[r2][c2].c == '.') lnk(r2, c2, gr, gc);\n\t\t}\n\t\tif (p[map[0][0].x] == p[map[gr][gc].x]) { puts(\"0\"); continue; }\n\n\t\tmemset(f, -1, sizeof(f)); memset(dis, -1, sizeof(dis));\n\t\tfor (len = 0, r = 0; r <= R; r++) for (c = 0; c <= C; c++) {\n\t\t\tx1 = p[map[r][c].x];\n\t\t\tif (f[x1] < 0) f[x1] = len, node[len++] = x1;\n\t\t}\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c < C; c++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r][c].x != map[r2][c2].x) {\n\t\t\t\t\tx1 = f[p[map[r][c].x]], x2 = f[p[map[r2][c2].x]];\n\t\t\t\t\tdis[x1][x2] = dis[x2][x1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = search(len, f[p[map[0][0].x]], f[p[map[gr][gc].x]]);\n\t\tif (k & 1) k++;\n\t\tprintf(\"%d\\n\", k >> 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n#define MAX_M 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nque_t queue[QUE_SIZE];\nint mx[MAX_M];\nint my[MAX_M];\nint que_in;\nint que_out;\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\nmoat()\n{\n\tfor (int i = 0; i < ix; ++i)\n\t{\n\t\tfor (int dy = -1; dy <= 1; ++dy)\n\t\t{\n\t\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t\t{\n\t\t\t\tint nx = mx[i] + dx, ny = my[i] + dy;\n\t\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '*')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '.';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool\nbfs()\n{\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = { 0,-1, 0, 1};\n\tque_t que;\n\n\tix = 0;\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tmx[ix] = nx, my[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs())\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\t\tmoat();\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0156 Moats around the Castle\n   2017.8.22 bal4u@uu\n   ?????¢?????£?????§???Union???????????§?????????\n*/\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n\n#define N 105\t\t\t// >= 100+2\n#define MAX 11500\t\t// >= N*N\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1; }\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\ntypedef struct { char c; int x; } T;\nT map[N+5][N+5]; int R, C;\nint gr, gc;\n\nvoid lnk(int r1, int c1, int r2, int c2) { union_set(map[r1][c1].x, map[r2][c2].x); }\n\nint node[N], len;\nint dis[N][N];\nint f[MAX];\nint s, g;\n\n#define INF 100000\nchar visited[2*N + 2];\nint total[2*N + 2];\n\nint search(int n, int s, int g)\n{\n\tint  i, j, next, min;\n\n\tfor (i = 0; i < n; i++) visited[i] = 0, total[i] = INF;\n\ttotal[s] = 0, next = s;\n\tdo {\n\t\ti = next, visited[i] = 1, min = INF;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (visited[j]) continue;\n\t\t\tif (dis[i][j] > 0 && total[i] + dis[i][j] < total[j]) {\n\t\t\t\ttotal[j] = total[i] + dis[i][j];\n\t\t\t}\n\t\t\tif (total[j] < min) min = total[j], next = j;\n\t\t}\n\t} while (min < INF);\n\treturn total[g];\n}\n\nint main()\n{\n\tint r, c, r2, c2, k, cc, x1, x2;\n\tchar buf[N];\n\tint mv[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tfor (r = 1; r <= R; r++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfor (c = 1; c <= C; c++) map[r][c].c = buf[c-1];\n\t\t}\n\t\tR += 2, C += 2;\n\t\tfor (r = 0; r < R; r++) map[r][0].c = map[r][C-1].c = '.';\n\t\tfor (c = 0; c < C; c++) map[0][c].c = map[R-1][c].c = '.';\n\t\tfor (k = r = 0; r < R; r++) for (c = 0; c < C; c++) map[r][c].x = k, make_set(k++);\n\t\tfor (r = 0; r < R; r++) lnk(r, 0, 0, 0), lnk(r, C-1, 0, 0);\n\t\tfor (c = 0; c < R; c++) lnk(0, c, 0, 0), lnk(R-1, c, 0, 0);\n\n\t\tR--, C--;\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tif (map[r][c].c == '&') gr = r, gc = c;\n\t\t\tcc = map[r][c].c;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r2][c2].c == cc) lnk(r2, c2, r, c);\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tr2 = gr + mv[k][0], c2 = gc + mv[k][1];\n\t\t\tif (map[r2][c2].c == '.') lnk(r2, c2, gr, gc);\n\t\t}\n\t\tif (p[map[0][0].x] == p[map[gr][gc].x]) { puts(\"0\"); continue; }\n\n\t\tmemset(f, -1, sizeof(f)); memset(dis, -1, sizeof(dis));\n\t\tfor (len = 0, r = 0; r <= R; r++) for (c = 0; c <= C; c++) {\n\t\t\tx1 = p[map[r][c].x];\n\t\t\tif (f[x1] < 0) f[x1] = len, node[len++] = x1;\n\t\t}\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c < C; c++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r][c].x != map[r2][c2].x) {\n\t\t\t\t\tx1 = f[p[map[r][c].x]], x2 = f[p[map[r2][c2].x]];\n\t\t\t\t\tdis[x1][x2] = dis[x2][x1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = search(len, f[p[map[0][0].x]], f[p[map[gr][gc].x]]);\n\t\tif (k & 1) k++;\n\t\tprintf(\"%d\\n\", k >> 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nque_t queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tque_push(x, y);\n\tfor (int dy = -1; dy <= 1; ++dy)\n\t{\n\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t{\n\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '#')\n\t\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nbool\nbfs(int *cx, int *cy)\n{\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = { 0,-1, 0, 1};\n\tque_t que;\n\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tif (nx > *cx)\n\t\t\t\t\t\t*cx = nx, *cy = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs(&cx, &cy))\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\t\tdfs(cx, cy);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n   Aizu Vol-1 0156 Moats around the Castle\n   2017.8.22 bal4u@uu\n   ?????¢?????£?????§???Union???????????§?????????\n*/\n#include <stdio.h>\n//#include <stdlib.h>\n#include <string.h>\n\n#define N 105\t\t\t// >= 100+2\n#define MAX 11500\t\t// >= N*N\n\n/* <UNION-FIND library> */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1; }\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n/* </UNION-FIND library> */\n\ntypedef struct { char c; int x; } T;\nT map[N+5][N+5]; int R, C;\nint gr, gc;\n\nvoid lnk(int r1, int c1, int r2, int c2) { union_set(map[r1][c1].x, map[r2][c2].x); }\n\n#define MAX2 1500\nint node[MAX2], len;\nint dis[MAX2][MAX2];\nint f[MAX];\nint s, g;\n\n#define INF 100000\nchar visited[MAX2+2];\nint total[MAX2+2];\n\nint search(int n, int s, int g)\n{\n\tint  i, j, next, min;\n\n\tfor (i = 0; i < n; i++) visited[i] = 0, total[i] = INF;\n\ttotal[s] = 0, next = s;\n\tdo {\n\t\ti = next, visited[i] = 1, min = INF;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (visited[j]) continue;\n\t\t\tif (dis[i][j] > 0 && total[i] + dis[i][j] < total[j]) {\n\t\t\t\ttotal[j] = total[i] + dis[i][j];\n\t\t\t}\n\t\t\tif (total[j] < min) min = total[j], next = j;\n\t\t}\n\t} while (min < INF);\n\treturn total[g];\n}\n\nint main()\n{\n\tint r, c, r2, c2, k, cc, x1, x2;\n\tchar buf[N];\n\tint mv[4][2] = { {-1,0}, {1,0}, {0,-1}, {0,1} };\n\n\twhile (scanf(\"%d%d\", &C, &R) && C) {\n\t\tfor (r = 1; r <= R; r++) {\n\t\t\tscanf(\"%s\", buf);\n\t\t\tfor (c = 1; c <= C; c++) map[r][c].c = buf[c-1];\n\t\t}\n\t\tR += 2, C += 2;\n\t\tfor (r = 0; r < R; r++) map[r][0].c = map[r][C-1].c = '.';\n\t\tfor (c = 0; c < C; c++) map[0][c].c = map[R-1][c].c = '.';\n\t\tfor (k = r = 0; r < R; r++) for (c = 0; c < C; c++) map[r][c].x = k, make_set(k++);\n\t\tfor (r = 0; r < R; r++) lnk(r, 0, 0, 0), lnk(r, C-1, 0, 0);\n\t\tfor (c = 0; c < R; c++) lnk(0, c, 0, 0), lnk(R-1, c, 0, 0);\n\n\t\tR--, C--;\n\t\tfor (r = 1; r < R; r++) for (c = 1; c < C; c++) {\n\t\t\tif (map[r][c].c == '&') gr = r, gc = c;\n\t\t\tcc = map[r][c].c;\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r2][c2].c == cc) lnk(r2, c2, r, c);\n\t\t\t}\n\t\t}\n\t\tfor (k = 0; k < 4; k++) {\n\t\t\tr2 = gr + mv[k][0], c2 = gc + mv[k][1];\n\t\t\tif (map[r2][c2].c == '.') lnk(r2, c2, gr, gc);\n\t\t}\n\t\tif (p[map[0][0].x] == p[map[gr][gc].x]) { puts(\"0\"); continue; }\n\n\t\tmemset(f, -1, sizeof(f)); memset(dis, -1, sizeof(dis));\n\t\tfor (len = 0, r = 0; r <= R; r++) for (c = 0; c <= C; c++) {\n\t\t\tx1 = p[map[r][c].x];\n\t\t\tif (f[x1] < 0) f[x1] = len, node[len++] = x1;\n\t\t}\n\t\tfor (r = 1; r <= R; r++) for (c = 1; c < C; c++) {\n\t\t\tfor (k = 0; k < 4; k++) {\n\t\t\t\tr2 = r + mv[k][0], c2 = c + mv[k][1];\n\t\t\t\tif (map[r][c].x != map[r2][c2].x) {\n\t\t\t\t\tx1 = f[p[map[r][c].x]], x2 = f[p[map[r2][c2].x]];\n\t\t\t\t\tdis[x1][x2] = dis[x2][x1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tk = search(len, f[p[map[0][0].x]], f[p[map[gr][gc].x]]);\n\t\tif (k & 1) k++;\n\t\tprintf(\"%d\\n\", k >> 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,h,w,x,y,s,ll,sss,set[150][150],q[20000][2];\nchar map[150][150];\n\nint mark(int x,int y,int k,int lev){\n\tif(x<0 || y<0 || x>h+1 || y>w+1 || set[x][y]>=sss)return 0;\n\tchar c =map[x][y];\n\tif(c=='&'){\n\t\tprintf(\"%d\\n\",k-sss+lev);\n\t\treturn 1;\n\t}\n\tif( (c=='#' && lev==0) || (c!='#' && lev==1) ){\n\t\tset[x][y]=k+lev;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t\treturn 0;\n\t}\n\tset[x][y]=k;\n\tif(mark(x-1,y,k,lev))return 1;\n\tif(mark(x+1,y,k,lev))return 1;\n\tif(mark(x,y-1,k,lev))return 1;\n\tif(mark(x,y+1,k,lev))return 1;\n\treturn 0;\n}\n\n\nint main(){\n\twhile(scanf(\"%d %d\",&w,&h)*w*h){\n\t\tfor(i=0;i<=h+1;i++)memset(map[i],'.',w+2);\n\t\tfor(i=1;i<=h;i++)scanf(\"%s\",&map[i][1]);\n\t\t\n\t\tsss+=200;\n\t\tq[0][0]=0;q[0][1]=0;\n\t\tset[0][0]=sss;\n\t\ti=0;j=1;\n\n\t\twhile(i<j){\n\t\t\tx=q[i][0]; y=q[i][1]; s=set[x][y];\n\t\t\tif(map[x][y]=='#')ll=1; else ll=0;\n\t\t\tif(mark(x-1,y,s,ll))break;\n\t\t\tif(mark(x+1,y,s,ll))break;\n\t\t\tif(mark(x,y-1,s,ll))break;\n\t\t\tif(mark(x,y+1,s,ll))break;\n\t\t\ti++;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,h,w,x,y,s,sss,set[150][150],q[20000][2];\nchar map[150][150];\n\nint mark(int x,int y,int k){\n\tif(x<0 || y<0 || x>h+1 || y>w+1 || set[x][y]>=sss)return 0;\n\tchar c =map[x][y];\n\tif(c=='&'){\n\t\tprintf(\"%d\\n\",k-sss);\n\t\treturn 1;\n\t}\n\tif(c=='#'){\n\t\tset[x][y]=k+1;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t\treturn 0;\n\t}\n\tset[x][y]=k;\n\tif(mark(x-1,y,k))return 1;\n\tif(mark(x+1,y,k))return 1;\n\tif(mark(x,y-1,k))return 1;\n\tif(mark(x,y+1,k))return 1;\n\treturn 0;\n}\n\n\nint main(){\n\twhile(scanf(\"%d %d\",&w,&h)*w*h){\n\t\tfor(i=0;i<=h+1;i++)memset(map[i],'.',w+2);\n\t\tfor(i=1;i<=h;i++)scanf(\"%s\",&map[i][1]);\n\t\t\n\t\tsss+=200;\n\t\tq[0][0]=0;q[0][1]=0;\n\t\tset[0][0]=sss;\n\t\ti=0;j=1;\n\n\t\twhile(i<j){\n\t\t\tx=q[i][0]; y=q[i][1]; s=set[x][y];\n\t\t\tif(mark(x-1,y,s))break;\n\t\t\tif(mark(x+1,y,s))break;\n\t\t\tif(mark(x,y-1,s))break;\n\t\t\tif(mark(x,y+1,s))break;\n\t\t\ti++;\n\t\t}\n\n\t\tfor(i=0;i<=h+1;i++){\n\t\t\tfor(j=0;j<=w+1;j++){\n\t\t\t\tprintf(\"%4d\",set[i][j]-sss);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,h,w,x,y,s,ll,sss,set[150][150],q[20000][2];\nchar map[150][150];\n\nint mark(int x,int y,int k,int lev){\n\tif(x<0 || y<0 || x>h+1 || y>w+1 || set[x][y]>=sss)return 0;\n\tchar c =map[x][y];\n\tif(c=='&'){\n\t\tprintf(\"%d\\n\",k-sss);\n\t\treturn 1;\n\t}\n\tif( (c=='#' && lev==0) || (c!='#' && lev==1) ){\n\t\tset[x][y]=k+lev;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t\treturn 0;\n\t}\n\tset[x][y]=k;\n\tif(mark(x-1,y,k,lev))return 1;\n\tif(mark(x+1,y,k,lev))return 1;\n\tif(mark(x,y-1,k,lev))return 1;\n\tif(mark(x,y+1,k,lev))return 1;\n\treturn 0;\n}\n\n\nint main(){\n\twhile(scanf(\"%d %d\",&w,&h)*w*h){\n\t\tfor(i=0;i<=h+1;i++)memset(map[i],'.',w+2);\n\t\tfor(i=1;i<=h;i++)scanf(\"%s\",&map[i][1]);\n\t\t\n\t\tsss+=200;\n\t\tq[0][0]=0;q[0][1]=0;\n\t\tset[0][0]=sss;\n\t\ti=0;j=1;\n\n\t\twhile(i<j){\n\t\t\tx=q[i][0]; y=q[i][1]; s=set[x][y];\n\t\t\tif(map[x][y]=='#')ll=1; else ll=0;\n\t\t\tif(mark(x-1,y,s,ll))break;\n\t\t\tif(mark(x+1,y,s,ll))break;\n\t\t\tif(mark(x,y-1,s,ll))break;\n\t\t\tif(mark(x,y+1,s,ll))break;\n\t\t\ti++;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[100000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 100000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 100000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y; i++){\n            for (j = 0; j <= x; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '#') && map[temp.ty][temp.tx] != '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[100000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 100000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 100000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y; i++){\n            for (j = 0; j <= x; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '#') && map[temp.ty][temp.tx] == '.'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,h,w,x,y,s,sss,set[150][150],q[20000][2];\nchar map[150][150];\n\nint mark(int x,int y,int k){\n\tif(x<0 || y<0 || x>h+1 || y>w+1 || set[x][y]>=sss)return 0;\n\tchar c =map[x][y];\n\tif(c=='&'){\n\t\tprintf(\"%d\\n\",k-sss);\n\t\treturn 1;\n\t}\n\tif(c=='#'){\n\t\tset[x][y]=k+1;\n\t\tq[j][0]=x;q[j][1]=y;\n\t\tj++;\n\t\treturn 0;\n\t}\n\tset[x][y]=k;\n\tif(mark(x-1,y,k))return 1;\n\tif(mark(x+1,y,k))return 1;\n\tif(mark(x,y-1,k))return 1;\n\tif(mark(x,y+1,k))return 1;\n\treturn 0;\n}\n\n\nint main(){\n\twhile(scanf(\"%d %d\",&w,&h)*w*h){\n\t\tfor(i=1;i<=h;i++)scanf(\"%s\",&map[i][1]);\n\t\tmemset(map[h+1],'.',w+2);\n\n\t\tsss+=200;\n\t\tq[0][0]=0;q[0][1]=0;\n\t\tset[0][0]=sss;\n\t\ti=0;j=1;\n\n\t\twhile(i<j){\n\t\t\tx=q[i][0]; y=q[i][1]; s=set[x][y];\n\t\t\tif(mark(x-1,y,s))break;\n\t\t\tif(mark(x+1,y,s))break;\n\t\t\tif(mark(x,y-1,s))break;\n\t\t\tif(mark(x,y+1,s))break;\n\t\t\ti++;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define min(x,y)((x)<(y)?(x):(y))\nH,W,M[101*104],S[101*104];\ni,f,s;\nmain(){\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;){\n\t\tW++;\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,1,sizeof(S));\n\t\tfor(i=0;i<H*W;i++){\n\t\t\tf=getchar();\n\t\t\tif(f=='&')\n\t\t\t\tS[W*2+i]=0;\n\t\t\tM[W*2+i]=f=='#';\n\t\t}\n\t\tfor(f=1;f;){\n\t\t\tf=0;\n\t\t\tfor(i=0;i<(H+2)*W;i++){\n\t\t\t\ts=S[W+i];\n\t\t\t\ts=min(s,S[W+i+1]+(M[W+i]>M[W+i+1]));\n\t\t\t\ts=min(s,S[W+i-1]+(M[W+i]>M[W+i-1]));\n\t\t\t\ts=min(s,S[W+i+W]+(M[W+i]>M[W+i+W]));\n\t\t\t\ts=min(s,S[W+i-W]+(M[W+i]>M[W+i-W]));\n\t\t\t\tif(S[W+i]!=s)\n\t\t\t\t\tS[W+i]=s,f=1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(i=0;i<(H+2)*W;i++){\n\t\t\tprintf(\"%d\",S[W+i]);\n\t\t\tif(i%W==W-1)\n\t\t\t\tputs(\"\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",S[W]);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint result;\nchar map[102][103];\nint map2[102][102];\n\nint tansaku(int x,int y,int now_cost,int is_hori,int force_hori) {\n\tint here_is_hori;\n\tint tansaku_did=0;\n\tif(x<0 || x>width+1 || y<0 || y>height+1)return 0;\n\tif(force_hori && map[y][x]!='#')return 0;\n\tif(is_hori && map[y][x]!='#')now_cost++;\n\tif(map2[y][x]<=now_cost)return 0;\n\tmap2[y][x]=now_cost;\n\there_is_hori=(map[y][x]=='#');\n\tif(here_is_hori) {\n\t\ttansaku_did|=tansaku(x+1,y,now_cost,here_is_hori,1);\n\t\ttansaku_did|=tansaku(x,y+1,now_cost,here_is_hori,1)*2;\n\t\ttansaku_did|=tansaku(x-1,y,now_cost,here_is_hori,1)*4;\n\t\ttansaku_did|=tansaku(x,y-1,now_cost,here_is_hori,1)*8;\n\t}\n\tif(!(tansaku_did & 1))tansaku(x+1,y,now_cost,here_is_hori,0);\n\tif(!(tansaku_did & 2))tansaku(x,y+1,now_cost,here_is_hori,0);\n\tif(!(tansaku_did & 4))tansaku(x-1,y,now_cost,here_is_hori,0);\n\tif(!(tansaku_did & 8))tansaku(x,y-1,now_cost,here_is_hori,0);\n\treturn 1;\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][0]='.';\n\t\t\tmap[i][width+1]='.';\n\t\t}\n\t\tfor(i=0;i<=width+1;i++) {\n\t\t\tmap[0][i]='.';\n\t\t\tmap[height+1][i]='.';\n\t\t\tfor(j=0;j<=height+1;j++) {\n\t\t\t\tmap2[j][i]=0x7fffffff;\n\t\t\t}\n\t\t}\n\t\ttansaku(0,0,0,0,0);\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tfor(j=1;j<=width;j++) {\n\t\t\t\tif(map[i][j]=='&') {\n\t\t\t\t\tprintf(\"%d\\n\",map2[i][j]);\n\t\t\t\t\ti=width+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nchar map[102][103];\nint map2[102][102];\n\nvoid tansaku(int x,int y,int now_cost,int is_hori) {\n\tint here_is_hori;\n\tif(x<0 || x>width+1 || y<0 || y>height+1)return;\n\tif(is_hori && map[y][x]!='#')now_cost++;\n\tif(map2[y][x]<=now_cost)return;\n\tmap2[y][x]=now_cost;\n\there_is_hori=(map[y][x]=='#');\n\ttansaku(x-1,y,now_cost,here_is_hori);\n\ttansaku(x+1,y,now_cost,here_is_hori);\n\ttansaku(x,y-1,now_cost,here_is_hori);\n\ttansaku(x,y+1,now_cost,here_is_hori);\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][0]='.';\n\t\t\tmap[i][width+1]='.';\n\t\t}\n\t\tfor(i=0;i<=width+1;i++) {\n\t\t\tmap[0][i]='.';\n\t\t\tmap[height+1][i]='.';\n\t\t\tfor(j=0;j<=height+1;j++) {\n\t\t\t\tmap2[j][i]=0x7fffffff;\n\t\t\t}\n\t\t}\n\t\ttansaku(0,0,0,0);\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tfor(j=1;j<=width;j++) {\n\t\t\t\tif(map[i][j]=='&') {\n\t\t\t\t\tprintf(\"%d\\n\",map2[i][j]);\n\t\t\t\t\ti=width+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[100000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 100000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 100000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int mx, my;\n    int x, y;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[100][100];\n    char map[100][101];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        getchar();\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                cost[i][j] = 100000;\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            if (0 == temp.tx || 0 == temp.ty || x - 1 == temp.tx || y - 1 == temp.ty){\n                cost[temp.ty][temp.tx] = temp.sharp;\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n            }\n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                if (0 <= mx && mx < x && 0 <= my && my < y && cost[my][mx] > temp.sharp){\n                    add = temp;\n                    cost[my][mx] = temp.sharp;\n                    if (map[my][mx] == '#'){\n                        cost[my][mx]++;\n                        add.sharp++;\n                    }\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ty;\n    int tx;\n    int sharp;\n} POINT;\n\nPOINT queue[1000000];\nint head, tail;\n\nvoid enq(POINT t)\n{\n    queue[tail++] = t;\n    if (tail == 1000000){\n        tail = 0;\n    }\n}\n\nvoid deq(POINT *t)\n{\n    *t = queue[head++];\n    if (head == 1000000){\n        head = 0;\n    }\n}\n\nint main(void)\n{\n    POINT temp, add;\n    int ans;\n    int i, j;\n    int x, y;\n    int mx, my;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n    int cost[102][102];\n    char map[102][103];\n    \n    while (1){\n        scanf(\"%d%d\", &x, &y);\n        \n        if (x + y == 0){\n            break;\n        }\n        getchar();\n        \n        memset(map, '.', sizeof(map));\n        \n        for (i = 1; i <= y; i++){\n            for (j = 1; j <= x; j++){\n                scanf(\"%c\", &map[i][j]);\n                \n                if (map[i][j] == '&'){\n                    temp.tx = j;\n                    temp.ty = i;\n                }\n            }\n            getchar();\n        }\n        \n        for (i = 0; i <= y; i++){\n            for (j = 0; j <= x; j++){\n                cost[i][j] = 100000;\n            }\n        }\n        \n        cost[temp.ty][temp.tx] = 0;\n        temp.sharp = 0;\n        head = tail = 0;\n        enq(temp);\n        ans = 100000;\n        \n        while (head != tail){\n            deq(&temp);\n            \n            if (0 == temp.tx || 0 == temp.ty || x + 1 == temp.tx || y + 1 == temp.ty){\n                ans = (ans > temp.sharp ? temp.sharp : ans);\n                continue;\n            }\n            \n            for (i = 0; i < 4; i++){\n                mx = temp.tx + dx[i];\n                my = temp.ty + dy[i];\n                add = temp;\n                if (cost[my][mx] > add.sharp){\n                    if ((map[my][mx] == '.') && map[temp.ty][temp.tx] == '#'){\n                        add.sharp++;\n                    }\n                    cost[my][mx] = add.sharp;\n                    add.tx = mx;\n                    add.ty = my;\n                    enq(add);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint x[200000],y[200000];\nint main(){\n  int min,i,j,nx,ny,t,r,w,h;\n  char m[101][101];\n  int X[]={0,1, 0,-1};\n  int Y[]={1,0,-1, 0};\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int c[101][101]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c\",&m[i][j]);\n\tif(m[i][j]=='&'){\n\t  m[i][j]='.';\n\t  y[0]=i;\n\t  x[t=0]=j;\n\t  c[i][j]=1;\n\t}\n      }\n    }\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=x[t]+X[i];\n\tny=y[t]+Y[i];\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(m[y[t]][x[t]]==m[ny][nx]){\n\t  if(c[y[t]][x[t]]<c[ny][nx]||0==c[ny][nx]){\n\t    c[ny][nx]=c[y[t]][x[t]];\n\t    x[r  ]=nx;\n\t    y[r++]=ny;\n\t  }\n\t}\n\telse{\n\t  if(c[y[t]][x[t]]+1<c[ny][nx]||0==c[ny][nx]){\n\t    c[ny][nx]=c[y[t]][x[t]]+1;\n\t    x[r  ]=nx;\n\t    y[r++]=ny;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%d\",c[i][j]);\n      printf(\"\\n\");\n      }*/\n    min=w;\n    for(i=0;i<w;i++){\n      if(c[0  ][i]/2<min)min=c[0  ][i]/2;\n      if(c[h-1][i]/2<min)min=c[h-1][i]/2;\n    }\n    for(i=0;i<h;i++){\n      if(c[i][0  ]/2<min)min=c[i][0  ]/2;\n      if(c[i][w-1]/2<min)min=c[i][w-1]/2;\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n#define MAX_M 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = { 0,-1, 0, 1};\nque_t queue[QUE_SIZE];\nint mx[MAX_M];\nint my[MAX_M];\nint que_in;\nint que_out;\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '#')\n\t\t\tdfs(nx, ny);\n\t}\n}\n\nbool\nbfs()\n{\n\tque_t que;\n\n\tix = 0;\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tmx[ix] = nx, my[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs())\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tdfs(mx[i], my[i]);\n\t\t\tque_push(mx[i], my[i]);\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define MAX_M 10000\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = { 0,-1, 0, 1};\nque_t queue[QUE_SIZE];\nint mx[MAX_M];\nint my[MAX_M];\nint que_in;\nint que_out;\nint ix;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(int x, int y)\n{\n\tqueue[que_in].x = x;\n\tqueue[que_in].y = y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '#')\n\t\t\tdfs(nx, ny);\n\t}\n}\n\nbool\nbfs()\n{\n\tque_t que;\n\n\tix = 0;\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque_push(nx, ny);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tmx[ix] = nx, my[ix] = ny;\n\t\t\t\t\tix++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tfield[cy][cx] = ' ';\n\tque_push(cx, cy);\n\n\tint count = 0;\n\twhile (!bfs())\n\t{\n\t\tque_in = 0;\n\t\tque_out = 0;\n\n\t\tfor (int i = 0; i < ix; ++i)\n\t\t{\n\t\t\tque_push(mx[i], my[i]);\n\t\t\tdfs(mx[i], my[i]);\n\t\t}\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint result;\nchar map[102][103];\nint map2[102][102];\n\nvoid tansaku(int x,int y,int now_cost,int is_hori) {\n\tint here_is_hori;\n\tif(x<0 || x>width+1 || y<0 || y>height+1)return;\n\tif(is_hori && map[y][x]!='#')now_cost++;\n\tif(map2[y][x]<=now_cost)return;\n\tmap2[y][x]=now_cost;\n\there_is_hori=(map[y][x]=='#');\n\ttansaku(x+1,y,now_cost,here_is_hori);\n\ttansaku(x,y+1,now_cost,here_is_hori);\n\ttansaku(x-1,y,now_cost,here_is_hori);\n\ttansaku(x,y-1,now_cost,here_is_hori);\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][0]='.';\n\t\t\tmap[i][width+1]='.';\n\t\t}\n\t\tfor(i=0;i<=width+1;i++) {\n\t\t\tmap[0][i]='.';\n\t\t\tmap[height+1][i]='.';\n\t\t\tfor(j=0;j<=height+1;j++) {\n\t\t\t\tmap2[j][i]=0x7fffffff;\n\t\t\t}\n\t\t}\n\t\ttansaku(0,0,0,0);\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tfor(j=1;j<=width;j++) {\n\t\t\t\tif(map[i][j]=='&') {\n\t\t\t\t\tprintf(\"%d\\n\",map2[i][j]);\n\t\t\t\t\ti=width+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint result;\nchar map[102][103];\nint map2[102][102];\n\nvoid tansaku(int x,int y,int now_cost,int is_hori) {\n\tint here_is_hori;\n\tif(x<0 || x>width+1 || y<0 || y>height+1)return;\n\tif(is_hori && map[y][x]!='#')now_cost++;\n\tif(map2[y][x]<=now_cost)return;\n\tmap2[y][x]=now_cost;\n\there_is_hori=(map[y][x]=='#');\n\ttansaku(x-1,y,now_cost,here_is_hori);\n\ttansaku(x,y-1,now_cost,here_is_hori);\n\ttansaku(x+1,y,now_cost,here_is_hori);\n\ttansaku(x,y+1,now_cost,here_is_hori);\n}\n\nint main(void) {\n\tint i,j;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tscanf(\"%s\",&map[i][1]);\n\t\t\tmap[i][0]='.';\n\t\t\tmap[i][width+1]='.';\n\t\t}\n\t\tfor(i=0;i<=width+1;i++) {\n\t\t\tmap[0][i]='.';\n\t\t\tmap[height+1][i]='.';\n\t\t\tfor(j=0;j<=height+1;j++) {\n\t\t\t\tmap2[j][i]=0x7fffffff;\n\t\t\t}\n\t\t}\n\t\ttansaku(0,0,0,0);\n\t\tfor(i=1;i<=height;i++) {\n\t\t\tfor(j=1;j<=width;j++) {\n\t\t\t\tif(map[i][j]=='&') {\n\t\t\t\t\tprintf(\"%d\\n\",map2[i][j]);\n\t\t\t\t\ti=width+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nque_t queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(que_t *que)\n{\n\tqueue[que_in].x = que->x;\n\tqueue[que_in].y = que->y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int dy = -1; dy <= 1; ++dy)\n\t{\n\t\tfor (int dx = -1; dx <= 1; ++dx)\n\t\t{\n\t\t\tint nx = x + dx, ny = y + dy;\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '#')\n\t\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nbool\nbfs(int *cx, int *cy)\n{\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = { 0,-1, 0, 1};\n\tint mx = 0, my = 0;\n\tque_t que;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tque.x = *cx, que.y = *cy;\n\tque_push(&que);\n\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque.x = nx, que.y = ny;\n\t\t\t\t\tque_push(&que);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tif (nx > mx || ny > my)\n\t\t\t\t\t\tmx = nx, my = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*cx = mx, *cy = my;\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tfield[cy][cx] = ' ';\n\tint count = 0;\n\twhile (!bfs(&cx, &cy))\n\t{\n\t\tdfs(cx, cy);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), fprintf(), scanf()\n#include <stdlib.h>         // exit()\n#include <stdbool.h>\n\n#define SZ_FIELD 100\n#define QUE_SIZE 10000\n\ntypedef struct que_tbl\n{\n\tint x;\n\tint y;\n} que_t;\n\nint N, M;\nchar field[SZ_FIELD][SZ_FIELD + 1];\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = { 0,-1, 0, 1};\nque_t queue[QUE_SIZE];\nint que_in;\nint que_out;\n\nvoid\ncleanup(int ecode)\n{\n\texit(ecode);\n}\n\nint\nque_empty()\n{\n\treturn que_in == que_out;\n}\n\nvoid\nque_push(que_t *que)\n{\n\tqueue[que_in].x = que->x;\n\tqueue[que_in].y = que->y;\n\tque_in = (que_in + 1) % QUE_SIZE;\n\n\tif (que_in == que_out)\n\t{\n\t\tfprintf(stderr, \"Queue overflow. size:%d\\n\", QUE_SIZE);\n\t\tcleanup(1);\n\t}\n}\n\nvoid\nque_pop()\n{\n\tif (que_out == que_in)\n\t{\n\t\tfprintf(stderr, \"Queue underflow\\n\");\n\t\tcleanup(1);\n\t}\n\n\tque_out = (que_out + 1) % QUE_SIZE;\n}\n\nvoid\nque_front(que_t *que)\n{\n\tque->x = queue[que_out].x;\n\tque->y = queue[que_out].y;\n}\n\nvoid\ndfs(int x, int y)\n{\n\tfield[y][x] = '.';\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M && field[ny][nx] == '*')\n\t\t\tdfs(nx, ny);\n\t}\n}\n\nbool\nbfs(int *cx, int *cy)\n{\n\tint mx = 0, my;\n\tque_t que;\n\n\tque_in = 0;\n\tque_out = 0;\n\n\tque.x = *cx, que.y = *cy;\n\tque_push(&que);\n\n\twhile (!que_empty())\n\t{\n\t\tque_front(&que); que_pop();\n\t\tint x = que.x, y = que.y;\n\t\tif (x == 0 || x == N - 1 || y == 0 || y == M - 1)\n\t\t\treturn true;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < N && 0 <= ny && ny < M)\n\t\t\t{\n\t\t\t\tif (field[ny][nx] == '.')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = ' ';\n\t\t\t\t\tque.x = nx, que.y = ny;\n\t\t\t\t\tque_push(&que);\n\t\t\t\t}\n\t\t\t\telse if (field[ny][nx] == '#')\n\t\t\t\t{\n\t\t\t\t\tfield[ny][nx] = '*';\n\t\t\t\t\tif (nx > mx)\n\t\t\t\t\t\tmx = nx, my = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t*cx = mx, *cy = my;\n\treturn false;\n}\n\nint\nsolve()\n{\n\tint cx, cy;\n\n\tfor (cy = 0; cy < M; ++cy)\n\t{\n\t\tfor (cx = 0; cx < N; ++cx)\n\t\t{\n\t\t\tif (field[cy][cx] == '&')\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (cx < N)\n\t\t\tbreak;\n\t}\n\n\tfield[cy][cx] = ' ';\n\tint count = 0;\n\twhile (!bfs(&cx, &cy))\n\t{\n\t\tdfs(cx, cy);\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint\nmain(int argc, char **argv)\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < M; ++i)\n\t\t\tscanf(\"%s\", &field[i][0]);\n\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint x[20000],y[20000];\nint main(){\n  int min,i,j,nx,ny,t,r,w,h;\n  char m[101][101];\n  int X[]={0,1, 0,-1};\n  int Y[]={1,0,-1, 0};\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int c[101][101]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c\",&m[i][j]);\n\tif(m[i][j]=='&'){\n\t  m[i][j]='.';\n\t  y[0]=i;\n\t  x[t=0]=j;\n\t  c[i][j]=1;\n\t}\n      }\n    }\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tnx=x[t]+X[i];\n\tny=y[t]+Y[i];\n\tif(nx<0||w<=nx||ny<0||h<=ny)continue;\n\tif(m[y[t]][x[t]]==m[ny][nx]){\n\t  if(c[y[t]][x[t]]<c[ny][nx]||0==c[ny][nx]){\n\t    c[ny][nx]=c[y[t]][x[t]];\n\t    x[r  ]=nx;\n\t    y[r++]=ny;\n\t  }\n\t}\n\telse{\n\t  if(c[y[t]][x[t]]+1<c[ny][nx]||0==c[ny][nx]){\n\t    c[ny][nx]=c[y[t]][x[t]]+1;\n\t    x[r  ]=nx;\n\t    y[r++]=ny;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%d\",c[i][j]);\n      printf(\"\\n\");\n      }*/\n    min=w;\n    for(i=0;i<w;i++){\n      if(c[0  ][i]/2<min)min=c[0  ][i]/2;\n      if(c[h-1][i]/2<min)min=c[h-1][i]/2;\n    }\n    for(i=0;i<h;i++){\n      if(c[i][0  ]/2<min)min=c[i][0  ]/2;\n      if(c[i][w-1]/2<min)min=c[i][w-1]/2;\n    }\n    printf(\"%d\\n\",min);\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[] dx = new short[]{-1,0,1,0},dy = new short[]{0,1,0,-1};\n\tstatic final short INF = Short.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint a = 6;\n\t\twhile(a-->0){\n\t\t\tshort w = scan.nextShort();\n\t\t\tshort h = scan.nextShort();\n\t\t\tif(w==0) break;\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\tshort[][] cost = new short[h][w];\n\t\t\tQueue<short[]> que = new LinkedList<short[]>();\n\t\t\tfor (short i = 0; i < h; i++) {\n\t\t\t\tString text = scan.next();\n\t\t\t\tfor (short j = 0; j < w; j++) {\n\t\t\t\t\tchar chr = text.charAt(j);\n\t\t\t\t\tif(chr=='.') map[i][j] = true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j]=false;\n\t\t\t\t\t\tif(chr=='&'){\n\t\t\t\t\t\t\tque.offer(new short[]{i,j,0});\t\t//(y,x,cost)\n\t\t\t\t\t\t\tmap[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tshort[] yxc = que.poll();\n\t\t\t\tint py = yxc[0],px = yxc[1],pc = yxc[2];\n\t\t\t\tcost[py][px]=yxc[2];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint y = py+dy[i],x = px+dx[i],c = pc;\n\t\t\t\t\tif(x<0 || x>=w || y<0 || y>=h){\n\t\t\t\t\t\tmin = Math.min(min, c);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!map[y][x] && map[py][px]) c++;\n\t\t\t\t\tif(cost[y][x]>c && min>c) que.offer(new short[]{(short)y,(short)x,(short)c});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(min);\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h + 2][w + 2];\n\t\t\tint gx = -1;\n\t\t\tint gy = -1;\n\t\t\tfor (char[] m : map) {\n\t\t\t\tArrays.fill(m, '.');\n\t\t\t}\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tmap[i][j] = c[j - 1];\n\t\t\t\t\tif (c[j - 1] == '&') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 24);\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tDeque<int[]> deque = new ArrayDeque<int[]>();\n\t\t\tdeque.offer(new int[] { 0, 0 });\n\t\t\tcnt[0][0] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint[] d = deque.poll();\n\t\t\t\tint dy = d[0];\n\t\t\t\tint dx = d[1];\n\t\t\t\tfor (int[] xy : dxy) {\n\t\t\t\t\tint py = xy[0] + dy;\n\t\t\t\t\tint px = xy[1] + dx;\n\t\t\t\t\tint r;\n\t\t\t\t\tif (0 <= py && py < h + 2 && 0 <= px && px < w + 2) {\n\t\t\t\t\t\tif (map[dy][dx] == '#' && map[py][px] != '#') {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[py][px] > cnt[dy][dx] + r) {\n\t\t\t\t\t\t\tdeque.offer(new int[] { py, px });\n\t\t\t\t\t\t\tcnt[py][px] = cnt[dy][dx] + r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tchar[][] map = new char[h+2][w+2];\n\t\t\tint gx = -1;\n\t\t\tint gy = -1;\n\t\t\tfor(int i=0;i<h+2;i++) Arrays.fill(map[i], '.');\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i+1][j+1] = c[j];\n\t\t\t\t\tif(c[j]=='&'){\n\t\t\t\t\t\tgx = j+1;\n\t\t\t\t\t\tgy = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cnt = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<h+2;i++) Arrays.fill(cnt[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tint[] a = new int[]{0,0,1,-1};\n\t\t\tint[] b = new int[]{1,-1,0,0};\n\t\t\tArrayDeque<Integer> x = new ArrayDeque<Integer>();\n\t\t\tArrayDeque<Integer> y = new ArrayDeque<Integer>();\n\t\t\tx.offer(0);\n\t\t\ty.offer(0);\n\t\t\tcnt[0][0] = 0;\n\t\t\tint p, q, r;\n\t\t\twhile(x.size()!=0){\n\t\t\t\tp = x.poll();\n\t\t\t\tq = y.poll();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint u = p+a[i];\n\t\t\t\t\tint v = q+b[i];\n\t\t\t\t\tif(0<=u && u<w+2 && 0<=v && v<h+2){\n\t\t\t\t\t\tif(map[q][p]=='#' && map[v][u]!='#') r = 1;\n\t\t\t\t\t\telse r = 0;\n\t\t\t\t\t\tif(cnt[v][u] > cnt[q][p] + r){\n\t\t\t\t\t\t\tx.offer(u);\n\t\t\t\t\t\t\ty.offer(v);\n\t\t\t\t\t\t\tcnt[v][u] = cnt[q][p] + r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] field;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(s[j]=='.'){\n\t\t\t\t\t\tfield[i][j]=-1;\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j]=='&'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t\tq.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j]=='#'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a=q.poll();\n\t\t\t\tint x=a[0];\n\t\t\t\tint y=a[1];\n\t\t\t\tfield[x][y]=0;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+v1[i];\n\t\t\t\t\tint yy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n\t\t\t\t\tif(field[xx][yy]==-1){\n\t\t\t\t\t\tfield[xx][yy]=0;\n\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tfor(int cnt=0;;cnt++){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(field[i][j]==cnt){\n\t\t\t\t\t\t\t// someru\n\t\t\t\t\t\t\tq.add(new int[]{i,j});\n\t\t\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\t\t\tint[] a=q.poll();\n\t\t\t\t\t\t\t\tint x=a[0];\n\t\t\t\t\t\t\t\tint y=a[1];\n\t\t\t\t\t\t\t\tfor(int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\t\t\tint xx=x+v1[kk];\n\t\t\t\t\t\t\t\t\tint yy=y+v2[kk];\n\t\t\t\t\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\t\t\t\t\t\tSystem.out.println(cnt+1);\n\t\t\t\t\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(field[xx][yy]==-1){\n\t\t\t\t\t\t\t\t\t\tfield[xx][yy]=cnt;\n\t\t\t\t\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// tobikosu\n\t\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\t\tint ii=i+v1[k];\n\t\t\t\t\t\t\t\tint jj=j+v2[k];\n\t\t\t\t\t\t\t\tif(field[ii][jj]==-2){\n\t\t\t\t\t\t\t\t\tq.add(new int[]{ii,jj});\n\t\t\t\t\t\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\t\t\t\t\t\tint[] a=q.poll();\n\t\t\t\t\t\t\t\t\t\tint x=a[0];\n\t\t\t\t\t\t\t\t\t\tint y=a[1];\n\t\t\t\t\t\t\t\t\t\tfor(int kk=0;kk<4;kk++){\n\t\t\t\t\t\t\t\t\t\t\tint xx=x+v1[kk];\n\t\t\t\t\t\t\t\t\t\t\tint yy=y+v2[kk];\n\t\t\t\t\t\t\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\t\t\t\t\t\t\t\tSystem.out.println(cnt+1);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(field[xx][yy]==-(cnt+2)){\n\t\t\t\t\t\t\t\t\t\t\t\tfield[xx][yy]--;\n\t\t\t\t\t\t\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif(field[xx][yy]==-1){\n\t\t\t\t\t\t\t\t\t\t\t\tfield[xx][yy]=cnt+1;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean a(Queue<int[]> q,int cnt){\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] a=q.poll();\n\t\t\tint x=a[0];\n\t\t\tint y=a[1];\n\t\t\tif(field[x][y]==-1){\n\t\t\t\tfield[x][y]=cnt+1;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+v1[i];\n\t\t\t\tint yy=y+v2[i];\n\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif(field[xx][yy]==cnt){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[xx][yy]==-1){\n\t\t\t\t\tfield[xx][yy]=cnt+1;\n\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t}\n\t\t\t\tif(field[xx][yy]==-2&&field[x][y]==cnt){\n\t\t\t\t\txx=x+v1[i];\n\t\t\t\t\tyy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tfield[xx][yy]=cnt+1;\n\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tstatic int n;\n\tstatic int m;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tmap = new char[m][];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint gx = 0;\n\t\t\tint gy = 0;\n\t\t\tIN:for(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif(map[i][j] == '&') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tbreak IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsolv(gy,gx);\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tmin = Math.min(costMap[0][j], min);\n\t\t\t\t\tmin = Math.min(costMap[m-1][j], min);\n\t\t\t}\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tmin = Math.min(costMap[j][0], min);\n\t\t\t\tmin = Math.min(costMap[j][n-1], min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint x;\n\t\tint y;\n\t\tint c;\n\t\t\n\t\tData(int d, int e, int f) {\n\t\t\ty = d;\n\t\t\tx = e;\n\t\t\tc = f;\n\t\t}\n\t}\n\t\n\tstatic int[] vx = new int[] {1,0,-1,0};\n\tstatic int[] vy = new int[] {0,1,0,-1};\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tstatic int[][] costMap = new int[m][n];\n\t\n\t\n\tstatic void solv(int gy, int gx) {\n\t\tcostMap = new int[m][n];\n\t\tcostMap[gy][gx] = 0;\n\t\t\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tArrays.fill(costMap[i], 2 << 27);\n\t\t}\n\t\tqueue.addLast(new Data(gy,gx,0));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tBFS(queue.pollFirst());\n\t\t}\n\t}\n\t\n\tstatic void BFS(Data a) {\n\t\tif(!rangeCheck(a.y,a.x)) return;\n\t\tif(costMap[a.y][a.x] <= a.c) return;\n\t\tcostMap[a.y][a.x] = a.c;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(!rangeCheck(a.y+ vy[i],a.x+ vx[i])) continue;\n\t\t\tif(map[a.y][a.x] == '.' && map[a.y + vy[i]][a.x + vx[i]] == '#') {\n\t\t\t\tqueue.addLast(new Data(a.y + vy[i],a.x + vx[i], a.c+1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueue.addLast(new Data(a.y + vy[i],a.x + vx[i], a.c));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean rangeCheck(int a, int b) {\n\t\tif(a < 0 || b < 0 || a >= m || b >= n) return false;\n\t\treturn true;\n\t}\n\t\n\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Moats around the Castle\npublic class Main{\n\n\tstatic int N, M;\n\tstatic boolean safe(int i, int j){\n\t\treturn 0<=i&&i<M&&0<=j&&j<N;\n\t}\n\tstatic int[][] d;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tN = n+2;\n\t\t\tM = m+2;\n\t\t\tchar[][] map = new char[M][N];\n\t\t\tfor(int i=0;i<M;i++)map[i][0]=map[i][N-1]='.';\n\t\t\tfor(int j=0;j<N;j++)map[0][j]=map[M-1][j]='.';\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<n;j++)map[i][j+1]=s[j];\n\t\t\t}\n\t\t\td = new int[M][N];\n\t\t\tfor(int i=0;i<M;i++)Arrays.fill(d[i], Integer.MAX_VALUE);\n\t\t\td[0][0] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(M, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn d[o1[0]][o1[1]]-d[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tif(map[i][j]=='&'){\n\t\t\t\t\tSystem.out.println(d[i][j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\tif(safe(ni,nj)){\n\t\t\t\t\t\tint cost = d[i][j] + (map[i][j]=='#'&&map[ni][nj]=='.'?1:0);\n\t\t\t\t\t\tif(cost < d[ni][nj]){\n\t\t\t\t\t\t\td[ni][nj] = cost;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\tint WALL = 10000;\n\tint GOAL = 100;\n\tint w, h;\n\tint map[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) { \n\t\t\t\t\tswitch (str.charAt(j-1)) {\n\t\t\t\t\tcase '#': map[i][j] = WALL; break;\n\t\t\t\t\tcase '&': map[i][j] = GOAL; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint c=1;\n\t\t\tfor(;; c++) {\n//\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\tif( bfs(c) ) break;\n\t\t\t}\n\t\t\tSystem.out.println(c-1);\n\t\t}\n\t}\n\t\n\tint dx[] ={-1,0,1,0};\n\tint dy[] ={0,-1,0,1};\n\t\n\tboolean bfs(int c) {\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\tque.add(new P(0,0));\n\t\tmap[0][0] = c;\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP now = que.removeFirst();\n//\t\t\tdebug(now.x, now.y);\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tif( nx < 0 || nx >= w+2 || ny < 0 || ny >= h+2 ) continue;\n\t\t\t\t\n\t\t\t\tif( map[ny][nx] < c ) {\n\t\t\t\t\tque.add(new P(nx,ny));\n\t\t\t\t\tmap[ny][nx] = c;\n\t\t\t\t}\n\t\t\t\telse if(map[ny][nx] == WALL) map[ny][nx] = c;\n\t\t\t\telse if(map[ny][nx] == GOAL) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tfor(;;)\n\t\t{\n\t\t\tint W=in.nextInt();\n\t\t\tint H=in.nextInt();\n\t\t\tif((H|W)==0)\n\t\t\t\treturn;\n\t\t\tint sh=0,sw=0;\n\t\t\tint cost[][]=new int[H][W];\n\t\t\tchar map[][]=new char[H][W];\n\t\t\tLinkedList<String>que=new LinkedList<String>();\n\t\t\tfor(int p[]: cost)\n\t\t\t\tArrays.fill(p, 100);\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=st.charAt(j);\n\t\t\t\t\tif(map[i][j]=='&')\n\t\t\t\t\t{\n\t\t\t\t\t\tsh=i;\n\t\t\t\t\t\tsw=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost[sh][sw]=0;\n\t\t\tque.add(sh+\" \"+sw);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tString now[]=que.poll().split(\" \");\n\t\t\t\t\tint nh=Integer.valueOf(now[0]);\n\t\t\t\t\tint nw=Integer.valueOf(now[1]);\n\t\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint h=dy[j]+nh;\n\t\t\t\t\t\tint w=dx[j]+nw;\n\t\t\t\t\t\tif(h>=0&&h<H&&w>=0&&w<W)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((map[nh][nw]=='#'||map[h][w]=='.')&&cost[nh][nw]<cost[h][w])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcost[h][w]=cost[nh][nw];\n\t\t\t\t\t\t\t\tque.add(h+\" \"+w);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(map[nh][nw]!='#'&&map[h][w]=='#'&&cost[nh][nw]+1<cost[h][w])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcost[h][w]=cost[nh][nw]+1;\n\t\t\t\t\t\t\t\tque.add(h+\" \"+w);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=100;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i<1||i>H-2||j<1||j>W-2)\n\t\t\t\t\t\tans=Math.min(ans, cost[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[] dx = new short[]{-1,0,1,0},dy = new short[]{0,1,0,-1};\n\tstatic final short INF = Short.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\twhile(true){\n\t\t\tshort w = scan.nextShort();\n\t\t\tshort h = scan.nextShort();\n\t\t\tif(w==0) break;\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\tshort[][] cost = new short[h][w];\n\t\t\tQueue<short[]> que = new LinkedList<short[]>();\n\t\t\tfor (short i = 0; i < h; i++) {\n\t\t\t\tString text = scan.next();\n\t\t\t\tfor (short j = 0; j < w; j++) {\n\t\t\t\t\tchar chr = text.charAt(j);\n\t\t\t\t\tif(chr=='.') map[i][j] = true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j]=false;\n\t\t\t\t\t\tif(chr=='&'){\n\t\t\t\t\t\t\tque.offer(new short[]{i,j,0});\t\t//(y,x,cost)\n\t\t\t\t\t\t\tmap[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tshort[] yxc = que.poll();\n\t\t\t\tint py = yxc[0],px = yxc[1],pc = yxc[2];\n\t\t\t\tcost[py][px]=yxc[2];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint y = py+dy[i],x = px+dx[i],c = pc;\n\t\t\t\t\tif(x<0 || x>=w || y<0 || y>=h){\n\t\t\t\t\t\tmin = Math.min(min, c);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!map[y][x] && map[py][px]) c++;\n\t\t\t\t\tif(cost[y][x]>c && min>c) que.offer(new short[]{(short)y,(short)x,(short)c});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(min);\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc =new Scanner(System.in);\n\t\n\tclass T<A,B extends Comparable<B>> implements Comparable<T>{\n\t\tA first;\n\t\tB second;\n\t\tT(A f,B s){\n\t\t\tfirst = f;\n\t\t\tsecond = s;\n\t\t}\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic int compareTo(T target){\n\t\t\treturn second.compareTo((B) target.second);\n\t\t}\n\t}\n\t\n\tboolean type[][] ;\n\tint map[][];\n\t\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ttype = new boolean[n][m];\n\t\t\tmap = new int[n][m];\n\t\t\t\n\t\t\tint x = 0 ;int y = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\tArrays.fill(map[i], -1);\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor(int j = 0 ; j < m;j++){\n\t\t\t\t\ttype[i][j] = (buffer.charAt(j) != '#');\n\n\t\t\t\t\tif(buffer.charAt(j) == '&'){\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<T<T<Integer,Integer>,Integer>> q = new PriorityQueue<T<T<Integer,Integer>,Integer>>();\n\t\t\t\n\t\t\tq.add(new T<T<Integer,Integer>,Integer>(new T<Integer,Integer>(x,y),0));\n\t\t\t\n\t\t\tfor(;;){\n\t\t\t\tif(q.isEmpty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tT<T<Integer,Integer>,Integer> p = q.poll();\n\t\t\t\t\n\t\t\t\tif(map[p.first.first][p.first.second] != -1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmap[p.first.first][p.first.second] = p.second;\n\t\t\t\t\n\t\t\t\tint dx[] = {1,-1,0,0};\n\t\t\t\tint dy[] = {0,0,1,-1};\n\t\t\t\t\n\t\t\t\tfor(int i = 0 ; i < 4; i++){\n\t\t\t\t\tint ni = p.first.first + dx[i];\n\t\t\t\t\tint nj = p.first.second + dy[i];\n\t\t\t\t\t\n\t\t\t\t\tif(ni < 0 || nj < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ni >= n || nj >= m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[ni][nj] != -1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\tq.add(new T<T<Integer,Integer>,Integer>(new T<Integer,Integer>(ni,nj),p.second + ((type[p.first.first][p.first.second] == type[ni][nj])?0:1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tans = Math.min(ans,map[i][0]);\n\t\t\t\tans = Math.min(ans,map[i][m-1]);\n\t\t\t}\n\n\t\t\tfor(int j = 0 ; j < m ; j++){\n\t\t\t\tans = Math.min(ans,map[0][j]);\n\t\t\t\tans = Math.min(ans,map[n-1][j]);\n\t\t\t}\n\n\t\t\tSystem.out.println((ans+1)/2);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ0156().doIt();\n\t}\n\t\n\tclass AOJ0156{\n\t\tint mx,my;\n\t\tchar[][] map;\n\t\tint[][] cost;\n\t\tint[] sx,sy;\n\t\tvoid doIt(){\n\t\t\tsx = new int[4];sx[0]=0;sx[1]=1;sx[2]=0;sx[3]=-1;\n\t\t\tsy = new int[4];sy[0]=1;sy[1]=0;sy[2]=-1;sy[3]=0;\n\t\t\twhile(true){\n\t\t\t\tmx = in.nextInt();\n\t\t\t\tmy = in.nextInt();\n\t\t\t\tif(mx+my == 0)return;\n\t\t\t\tmap = new char[my+2][mx+2];\n\t\t\t\tcost = new int[my+2][mx+2];\n\t\t\t\tfor(int i=0;i<my+2;i++){\n\t\t\t\t\tArrays.fill(map[i], '.');\n\t\t\t\t\tArrays.fill(cost[i], -1);\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<my;i++){\n\t\t\t\t\tchar input[] = in.next().toCharArray();\n\t\t\t\t\tfor(int s=0;s<mx;s++)map[i+1][s+1] = input[s];\n\t\t\t\t}\n//\t\t\t\tprint();\n\t\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\t\tq.add(new State(0, 0, 0,false));int result = 0;\n\t\t\t\twhile(q.size()>0){\n\t\t\t\t\tState now = q.remove();\n//\t\t\t\t\tSystem.out.println(now.x+\" \"+now.y+\" \"+now.cost);\n\t\t\t\t\tif(map[now.y][now.x]=='&'){\n\t\t\t\t\t\tresult = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint nx = now.x+sx[i];\n\t\t\t\t\t\tint ny = now.y+sy[i];\n\t\t\t\t\t\tif(nx<0||nx>=mx+2||ny<0||ny>=my+2)continue;\n\t\t\t\t\t\tif(cost[ny][nx]>=now.cost)continue;\n\t\t\t\t\t\tboolean plus = map[now.y][now.x]=='.'&&map[ny][nx]=='#';\n\t\t\t\t\t\tcost[ny][nx] = plus?now.cost+1:now.cost;\n\t\t\t\t\t\tq.add(new State(nx, ny, cost[ny][nx], map[ny][nx]=='#'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(result);\n//\t\t\t\tfor(int i=0;i<my+2;i++){\n//\t\t\t\t\tfor(int s=0;s<mx+2;s++)System.out.print(cost[i][s]);\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<my+2;i++){\n\t\t\t\tfor(int s=0;s<mx+2;s++)System.out.print(map[i][s]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,cost;\n\t\t\tboolean isHori;\n\t\t\tpublic State(int x,int y,int cost,boolean isHori) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.cost = cost;\n\t\t\t\tthis.isHori = isHori;\n\t\t\t}\n\t\t\tpublic int compareTo(State o) {\n\t\t\t\treturn cost-o.cost;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int w,h,gx,gy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tstatic int[][] cost;\n\tstatic char[][] field;\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0) return false;\n\t\t\n\t\tfield = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) field[i] = sc.next().toCharArray();\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(field[i][j] == '&') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve() {\n\t\tint ans = Integer.MAX_VALUE;\n\t\tsearch();\n\t\tfor(int i = 0; i < w; i++) ans = min(ans, min(cost[0][i], cost[h-1][i]));\n\t\tfor(int i = 0; i < h; i++) ans = min(ans, min(cost[i][0], cost[i][w-1]));\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic int search() {\n\t\tcost = new int[h][w];\n\t\tfor(int i = 0; i < h; i++) fill(cost[i], -1);\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.offer(new State(gx, gy, 0));\n\t\t\n\t\tState s = null;\n\t\twhile(!pq.isEmpty()) {\n\t\t\ts = pq.poll();\n\t\t\tif(cost[s.y][s.x] >= s.step) continue;\n\t\t\tcost[s.y][s.x] = s.step;\n\t\t\t\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint x = s.x + dx[k], y = s.y + dy[k];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h || cost[y][x] != -1) continue;\n\t\t\t\tswitch(field[y][x]) {\n\t\t\t\tcase '.':\n\t\t\t\t\tpq.offer(new State(x, y, s.step));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tpq.offer(new State(x, y, s.step + 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) solve();\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint x,y,step;\n\tState(int x, int y, int step) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.step = step;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.step - s.step;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Map.Entry;\n\npublic class Sample {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tMap<Integer, Integer> memo = new HashMap<Integer, Integer>();\n\t\t\tmemo.put(0, 1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tMap<Integer, Integer> tmp = new HashMap<Integer, Integer>();\n\t\t\t\ttmp.putAll(memo);\n\t\t\t\tfor (Entry<Integer, Integer> entry : memo.entrySet()) {\n\t\t\t\t\tfor (int j = 1; j <= b; j++) {\n\t\t\t\t\t\tint c = entry.getKey() + a * j;\n\t\t\t\t\t\tif (c > 1000) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint d = entry.getValue();\n\t\t\t\t\t\tif (tmp.containsKey(c)) {\n\t\t\t\t\t\t\ttmp.put(c, d + tmp.get(c));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp.put(c, d);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmemo = tmp;\n\n\t\t\t}\n\t\t\tint s = scanner.nextInt();\n\t\t\twhile (s-- > 0) {\n\t\t\t\tint m = scanner.nextInt();\n\t\t\t\tif (!memo.containsKey(m)) {\n\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(memo.get(m));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint x;\n\t\tint y;\n\t\tint cost;\n\t\t\n\t\tpublic Walk(int x, int y, int cost) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] is_wall = new boolean[h][w];\n\t\t\tboolean[][] is_visited = new boolean[h][w];\n\t\t\t\n\t\t\tint goal_x = -1, goal_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tis_wall[i][j] = ch[j] == '#';\n\t\t\t\t\t\n\t\t\t\t\tif(ch[j] == '&'){\n\t\t\t\t\t\tgoal_x = j;\n\t\t\t\t\t\tgoal_y = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>(); \n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(i == 0 || i == (h - 1) || j == 0 || j ==(w - 1)){\n\t\t\t\t\t\tqueue.add(new Walk(j, i, is_wall[i][j] ? 1 : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.x + \" \" + walk.y + \" \" + walk.cost);\n\t\t\t\t\n\t\t\t\tif(walk.x == goal_x && walk.y == goal_y){\n\t\t\t\t\tSystem.out.println(walk.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.y][walk.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tis_visited[walk.y][walk.x] = true;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(walk.x != 0 && !is_visited[walk.y][walk.x - 1]){\n\t\t\t\t\tqueue.add(new Walk(walk.x - 1,walk.y, walk.cost + ((!is_wall[walk.y][walk.x] && is_wall[walk.y][walk.x - 1]) ? 1 : 0)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.x != (w-1) && !is_visited[walk.y][walk.x + 1]){\n\t\t\t\t\tqueue.add(new Walk(walk.x + 1,walk.y, walk.cost + ((!is_wall[walk.y][walk.x] && is_wall[walk.y][walk.x + 1]) ? 1 : 0)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.y != 0 && !is_visited[walk.y - 1][walk.x]){\n\t\t\t\t\tqueue.add(new Walk(walk.x,walk.y - 1, walk.cost + ((!is_wall[walk.y][walk.x] && is_wall[walk.y - 1][walk.x]) ? 1 : 0)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.y != (h-1) && !is_visited[walk.y + 1][walk.x]){\n\t\t\t\t\tqueue.add(new Walk(walk.x,walk.y + 1, walk.cost + ((!is_wall[walk.y][walk.x] && is_wall[walk.y + 1][walk.x]) ? 1 : 0)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tclass Point{\n\t\tint y, x;\n\t\tPoint(int y, int x){\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\n\tchar[][] board;\n\tint[] dx = {0,0,1,-1};\n\tint[] dy = {1,-1,0,0};\n\tint W, H;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tW = in.nextInt() + 2;\n\t\t\tH = in.nextInt() + 2;\n\t\t\tif(W==2 && H==2) return;\n\t\t\tboard = new char[H][W];\n\t\t\tfor(int i=0; i<H; i++){\n\t\t\t\tArrays.fill(board[i], '.');\n\t\t\t}\n\t\t\tfor(int i=0; i<H-2; i++){\n\t\t\t\tString line = in.next();\n\t\t\t\tfor(int j=0; j<W-2; j++){\n\t\t\t\t\tboard[i+1][j+1] = line.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tQueue<Point> Q1 = new LinkedList<Point>(), Q2 = new LinkedList<Point>();\n\t\tint[][] dist = new int[H][W];\n\t\tboolean[][] visited = new boolean[H][W];\n\t\tfor(int i=0; i<H; i++){\n\t\t\tvisited[i][0] = true;\n\t\t\tvisited[i][W-1] = true;\n\t\t\tQ1.add(new Point(i,0));\n\t\t\tQ1.add(new Point(i,W-1));\n\t\t}\n\t\tfor(int j=1; j<W-1; j++){\n\t\t\tvisited[0][j] = true;\n\t\t\tvisited[H-1][j] = true;\n\t\t\tQ1.add(new Point(0,j));\n\t\t\tQ1.add(new Point(H-1,j));\n\t\t}\n\t\tfor(;;){\n\t\t\twhile(!Q1.isEmpty()){\n\t\t\t\tPoint tp = Q1.poll();\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tint ny = tp.y + dy[k], nx = tp.x + dx[k];\n\t\t\t\t\tif(0<=ny && ny<H && 0<=nx && nx<W && !visited[ny][nx]){\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\tif(board[ny][nx] == '&'){\n\t\t\t\t\t\t\treturn dist[tp.y][tp.x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(board[ny][nx] == '.'){\n\t\t\t\t\t\t\tdist[ny][nx] = dist[tp.y][tp.x];\n\t\t\t\t\t\t\tQ1.add(new Point(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(board[ny][nx] == '#'){\n\t\t\t\t\t\t\tdist[ny][nx] = dist[tp.y][tp.x] + 1;\n\t\t\t\t\t\t\tQ2.add(new Point(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q2.isEmpty()){\n\t\t\t\tPoint tp = Q2.poll();\n\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\tint ny = tp.y + dy[k], nx = tp.x + dx[k];\n\t\t\t\t\tif(0<=ny && ny<H && 0<=nx && nx<W && !visited[ny][nx]){\n\t\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t\t\tif(board[ny][nx] == '&'){\n\t\t\t\t\t\t\treturn dist[tp.y][tp.x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(board[ny][nx] == '.'){\n\t\t\t\t\t\t\tdist[ny][nx] = dist[tp.y][tp.x];\n\t\t\t\t\t\t\tQ1.add(new Point(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(board[ny][nx] == '#'){\n\t\t\t\t\t\t\tdist[ny][nx] = dist[tp.y][tp.x];\n\t\t\t\t\t\t\tQ2.add(new Point(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tint gy = -1;\n\t\t\tint gx = -1;\n\t\t\tboolean[][] map = new boolean[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (c[j - 1] == '#') {\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t} else if (c[j - 1] == '&') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\t\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 10);\n\t\t\t}\n\t\t\tcnt[0][0] = 0;\n\t\t\tDeque<List<Integer>> deque = new ArrayDeque<List<Integer>>();\n\t\t\tdeque.offer(Arrays.asList(0, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tList<Integer> list = deque.poll();\n\t\t\t\tint y = list.get(0);\n\t\t\t\tint x = list.get(1);\n\t\t\t\tfor (int[] d : dxy) {\n\t\t\t\t\tint dy = y + d[0];\n\t\t\t\t\tint dx = x + d[1];\n\t\t\t\t\tif (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {\n\t\t\t\t\t\tint r;\n\t\t\t\t\t\tif (map[y][x] && !map[dy][dx]) {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[dy][dx] > cnt[y][x] + r) {\n\t\t\t\t\t\t\tcnt[dy][dx] = cnt[y][x] + r;\n\t\t\t\t\t\t\tdeque.offer(Arrays.asList(dy, dx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tnew AOJ0156().doIt();\n\t}\n\t\n\tclass AOJ0156{\n\t\tint mx,my;\n\t\tchar[][] map;\n\t\tint[][] cost;\n\t\tint INF = Integer.MAX_VALUE/2;\n\t\tint[] sx,sy;\n\t\tvoid doIt(){\n\t\t\tsx = new int[4];sx[0]=0;sx[1]=1;sx[2]=0;sx[3]=-1;\n\t\t\tsy = new int[4];sy[0]=1;sy[1]=0;sy[2]=-1;sy[3]=0;\n\t\t\twhile(true){\n\t\t\t\tmx = in.nextInt();\n\t\t\t\tmy = in.nextInt();\n\t\t\t\tif(mx+my == 0)return;\n\t\t\t\tmap = new char[my+2][mx+2];\n\t\t\t\tcost = new int[my+2][mx+2];\n\t\t\t\tfor(int i=0;i<my+2;i++){\n\t\t\t\t\tArrays.fill(map[i], '.');\n\t\t\t\t\tArrays.fill(cost[i], -1);\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<my;i++){\n\t\t\t\t\tchar input[] = in.next().toCharArray();\n\t\t\t\t\tfor(int s=0;s<mx;s++)map[i+1][s+1] = input[s];\n\t\t\t\t}\n//\t\t\t\tprint();\n\t\t\t\tPriorityQueue<State> q = new PriorityQueue<State>();\n\t\t\t\tq.add(new State(0, 0, 0,false));int result = 0;\n\t\t\t\twhile(q.size()>0){\n\t\t\t\t\tState now = q.remove();\n//\t\t\t\t\tSystem.out.println(now.x+\" \"+now.y+\" \"+now.cost);\n\t\t\t\t\tif(map[now.y][now.x]=='&'){\n\t\t\t\t\t\tresult = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint nx = now.x+sx[i];\n\t\t\t\t\t\tint ny = now.y+sy[i];\n\t\t\t\t\t\tif(nx<0||nx>=mx+2||ny<0||ny>=my+2)continue;\n\t\t\t\t\t\tif(cost[ny][nx]>=now.cost)continue;\n\t\t\t\t\t\tcost[ny][nx] = map[ny][nx]=='#'&&!now.isHori?now.cost+1:now.cost;\n\t\t\t\t\t\tboolean sw = map[now.y][now.x]!=map[ny][nx] && map[ny][nx]=='#';\n\t\t\t\t\t\tq.add(new State(nx, ny, cost[ny][nx], sw));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(result);\n\t\t\t}\n\t\t}\t\t\n\t\tvoid print(){\n\t\t\tfor(int i=0;i<my+2;i++){\n\t\t\t\tfor(int s=0;s<mx+2;s++)System.out.print(map[i][s]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tclass State implements Comparable<State>{\n\t\t\tint x,y,cost;\n\t\t\tboolean isHori;\n\t\t\tpublic State(int x,int y,int cost,boolean isHori) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.cost = cost;\n\t\t\t\tthis.isHori = isHori;\n\t\t\t}\n\t\t\tpublic int compareTo(State o) {\n\t\t\t\treturn cost-o.cost;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int w,h,gx,gy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tstatic int[][] cost;\n\tstatic char[][] field;\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0) return false;\n\t\t\n\t\tfield = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) field[i] = sc.next().toCharArray();\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(field[i][j] == '&') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve() {\n\t\tint ans = Integer.MAX_VALUE;\n\t\tsearch();\n\t\tfor(int i = 0; i < w; i++) {\n\t\t\tif(field[0][i] == '.' || field[0][i] == '&') {\n\t\t\t\tans = min(ans, cost[0][i]);\n\t\t\t}\n\t\t\tif(field[h-1][i] == '.' || field[h-1][i] == '&') {\n\t\t\t\tans = min(ans, cost[h-1][i]);\n\t\t\t} \n\t\t}\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tif(field[i][0] == '.' || field[i][0] == '&') {\n\t\t\t\tans = min(ans, cost[i][0]);\n\t\t\t}\n\t\t\tif(field[i][w-1] == '.' || field[i][w-1] == '&') {\n\t\t\t\tans = min(ans, cost[i][w-1]);\n\t\t\t} \n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic int search() {\n\t\tcost = new int[h][w];\n\t\tfor(int i = 0; i < h; i++) fill(cost[i], -1);\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.offer(new State(gx, gy, 0));\n\t\t\n\t\tState s = null;\n\t\twhile(!pq.isEmpty()) {\n\t\t\ts = pq.poll();\n\t\t\tcost[s.y][s.x] = s.step;\n\t\t\t\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint x = s.x + dx[k], y = s.y + dy[k];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h || cost[y][x] != -1) continue;\n\t\t\t\tswitch(field[y][x]) {\n\t\t\t\tcase '.':\n\t\t\t\t\tpq.offer(new State(x, y, s.step));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tpq.offer(new State(x, y, s.step + 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) solve();\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint x,y,step;\n\tState(int x, int y, int step) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.step = step;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.step - s.step;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = 1 << 28;\n\tint n;\n\tint m;\n\tchar[][] map;\n\tint[][] visited;\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[m][n];\n\t\t\tvisited = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tArrays.fill(visited[i], INF);\n\t\t\t}\n\t\t\tif (n <= 2 || m <= 2) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ti = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(new Point(sx, sy), 0));\n\t\t}\n\t}\n\n\tint solve(Point pos, int c) {\n\n\t\tint x = pos.x;\n\t\tint y = pos.y;\n\t\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\t\treturn c;\n\t\t}\n\t\tif (visited[y][x] <= c)\n\t\t\treturn INF;\n\t\tvisited[y][x] = c;\n\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tres = Math.min(res,\n\t\t\t\t\tsolve(new Point(nx, ny), c + ((map[y][x] == '#') ? 1 : 0)));\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint WALL = 10000;\n\tint GOAL = 100000;\n\tint w, h;\n\tint map[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) { \n\t\t\t\t\tswitch (str.charAt(j-1)) {\n\t\t\t\t\tcase '#': map[i][j] = WALL; break;\n\t\t\t\t\tcase '&': map[i][j] = GOAL; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint c=1;\n\t\t\tfor(;; c++) {\n//\t\t\t\tfor(int[] a: map) debug(a);\n\t\t\t\tif( bfs(c) ) break;\n\t\t\t}\n\t\t\tSystem.out.println(c-1);\n\t\t}\n\t}\n\t\n\tint dx[] ={-1,0,1,0};\n\tint dy[] ={0,-1,0,1};\n\t\n\tboolean bfs(int c) {\n\t\tLinkedList<P> que = new LinkedList<P>();\n\t\tque.add(new P(0,0));\n\t\tmap[0][0] = c;\n\t\t\n\t\tfor(;!que.isEmpty();) {\n\t\t\tP now = que.removeFirst();\n//\t\t\tdebug(now.x, now.y);\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tif( nx < 0 || nx >= w+2 || ny < 0 || ny >= h+2 ) continue;\n\t\t\t\t\n\t\t\t\tif( map[ny][nx] < c ) {\n\t\t\t\t\tque.add(new P(nx,ny));\n\t\t\t\t\tmap[ny][nx] = c;\n\t\t\t\t}\n\t\t\t\telse if(map[ny][nx] == WALL) map[ny][nx] = c;\n\t\t\t\telse if(map[ny][nx] == GOAL) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tData[] list = new Data[n*2];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tlong a = sc.nextLong();\n\t\t\t\tlong b = sc.nextLong();\n\t\t\t\tlist[i*2] = new Data(m,a);\n\t\t\t\tlist[i*2+1] = new Data(-m,b);\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(list,new MyComp());\n\t\t\tfor(int i = 0; i < n*2-1; i++) {\n\t\t\t\tif(list[i].a == list[i+1].a) {\n\t\t\t\t\tlist[i+1].m += list[i].m;\n\t\t\t\t\tlist[i].m = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tboolean flg = false;\n\t\t\tfor(int i = 0; i < n*2; i++) {\n\t\t\t\tsum += list[i].m;\n\t\t\t\tif(sum > 150) {\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) {\n\t\t\t\tSystem.out.println(\"NG\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"OK\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint m;\n\t\tlong a;\n\t\tData(int c, long d) {\n\t\t\tm = c;\n\t\t\ta = d;\n\t\t}\n\t}\n\t\n\tstatic class MyComp implements Comparator<Data> {\n\n\t\t@Override\n\t\tpublic int compare(Data o1, Data o2) {\n\t\t\tif(o1.a > o2.a) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(o1.a < o2.a){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint x;\n\t\tint y;\n\t\tint cost;\n\t\t\n\t\tpublic Walk(int x, int y, int cost) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] is_wall = new boolean[h][w];\n\t\t\tboolean[][] is_visited = new boolean[h][w];\n\t\t\t\n\t\t\tint goal_x = -1, goal_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] ch = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tis_wall[i][j] = ch[j] == '#';\n\t\t\t\t\t\n\t\t\t\t\tif(ch[j] == '&'){\n\t\t\t\t\t\tgoal_x = j;\n\t\t\t\t\t\tgoal_y = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>(); \n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(i == 0 || i == (h - 1) || j == 0 || j ==(w - 1)){\n\t\t\t\t\t\tqueue.add(new Walk(j, i, is_wall[i][j] ? 1 : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.x + \" \" + walk.y + \" \" + walk.cost);\n\t\t\t\t\n\t\t\t\tif(walk.x == goal_x && walk.y == goal_y){\n\t\t\t\t\tSystem.out.println(walk.cost);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.y][walk.x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tis_visited[walk.y][walk.x] = true;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(walk.x != 0 && !is_visited[walk.y][walk.x - 1]){\n\t\t\t\t\tqueue.add(new Walk(walk.x - 1,walk.y, walk.cost + (is_wall[walk.y][walk.x - 1] ? 1 : 0)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.x != (w-1) && !is_visited[walk.y][walk.x + 1]){\n\t\t\t\t\tqueue.add(new Walk(walk.x + 1,walk.y, walk.cost + (is_wall[walk.y][walk.x + 1] ? 1 : 0)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.y != 0 && !is_visited[walk.y - 1][walk.x]){\n\t\t\t\t\tqueue.add(new Walk(walk.x,walk.y - 1, walk.cost + (is_wall[walk.y - 1][walk.x] ? 1 : 0)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.y != (h-1) && !is_visited[walk.y + 1][walk.x]){\n\t\t\t\t\tqueue.add(new Walk(walk.x,walk.y + 1, walk.cost + (is_wall[walk.y + 1][walk.x] ? 1 : 0)));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint w = scanner.nextInt();\n\t\t\tint h = scanner.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tint gy = -1;\n\t\t\tint gx = -1;\n\t\t\tboolean[][] map = new boolean[h + 2][w + 2];\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tchar[] c = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (c[j - 1] == '#') {\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t} else if (c[j - 1] == '&') {\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\t\t\tint[][] cnt = new int[h + 2][w + 2];\n\t\t\t\n\t\t\tfor (int[] c : cnt) {\n\t\t\t\tArrays.fill(c, 1 << 10);\n\t\t\t}\n\t\t\tcnt[0][0] = 0;\n\t\t\tDeque<List<Integer>> deque = new ArrayDeque<>();\n\t\t\tdeque.offer(Arrays.asList(0, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tList<Integer> list = deque.poll();\n\t\t\t\tint y = list.get(0);\n\t\t\t\tint x = list.get(1);\n\t\t\t\tfor (int[] d : dxy) {\n\t\t\t\t\tint dy = y + d[0];\n\t\t\t\t\tint dx = x + d[1];\n\t\t\t\t\tif (0 <= dy && dy < h + 2 && 0 <= dx & dx < w + 2) {\n\t\t\t\t\t\tint r;\n\t\t\t\t\t\tif (map[y][x] && !map[dy][dx]) {\n\t\t\t\t\t\t\tr = 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt[dy][dx] > cnt[y][x] + r) {\n\t\t\t\t\t\t\tcnt[dy][dx] = cnt[y][x] + r;\n\t\t\t\t\t\t\tdeque.offer(Arrays.asList(dy, dx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Moats around the Castle\npublic class Main{\n\n\tstatic int N, M;\n\tstatic boolean safe(int i, int j){\n\t\treturn 0<=i&&i<M&&0<=j&&j<N;\n\t}\n\tstatic int[][] d;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tN = n+2;\n\t\t\tM = m+2;\n\t\t\tchar[][] map = new char[M][N];\n\t\t\tfor(int i=0;i<M;i++)map[i][0]=map[i][N-1]='.';\n\t\t\tfor(int j=0;j<N;j++)map[0][j]=map[M-1][j]='.';\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<n;j++)map[i][j+1]=s[j];\n\t\t\t}\n\t\t\td = new int[M][N];\n\t\t\tfor(int i=0;i<M;i++)Arrays.fill(d[i], Integer.MAX_VALUE);\n\t\t\td[0][0] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(M, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn d[o1[0]][o1[1]]-d[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0,0});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tif(map[i][j]=='&'){\n\t\t\t\t\tSystem.out.println(d[i][j]);break;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\tif(safe(ni,nj)){\n\t\t\t\t\t\tint cost = d[i][j] + (map[i][j]=='#'&&map[ni][nj]!='#'?1:0);\n\t\t\t\t\t\tif(cost < d[ni][nj]){\n\t\t\t\t\t\t\td[ni][nj] = cost;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc =new Scanner(System.in);\n\t\n\tclass T<A,B extends Comparable<B>> implements Comparable<T>{\n\t\tA first;\n\t\tB second;\n\t\tT(A f,B s){\n\t\t\tfirst = f;\n\t\t\tsecond = s;\n\t\t}\n\t\t\n\t\tpublic int compareTo(T target){\n\t\t\treturn second.compareTo((B) target.second);\n\t\t}\n\t}\n\t\n\tboolean type[][] ;\n\tint map[][];\n\t\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((n|m)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\ttype = new boolean[n][m];\n\t\t\tmap = new int[n][m];\n\t\t\t\n\t\t\tint x = 0 ;int y = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < n ; i++){\n\t\t\t\tArrays.fill(map[i], -1);\n\t\t\t\tString buffer = sc.next();\n\t\t\t\tfor(int j = 0 ; j < m;j++){\n\t\t\t\t\ttype[i][j] = (buffer.charAt(j) != '#');\n\n\t\t\t\t\tif(buffer.charAt(j) == '&'){\n\t\t\t\t\t\tx = i;\n\t\t\t\t\t\ty = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<T<T<Integer,Integer>,Integer>> q = new PriorityQueue<T<T<Integer,Integer>,Integer>>();\n\t\t\t\n\t\t\tq.add(new T<T<Integer,Integer>,Integer>(new T<Integer,Integer>(x,y),0));\n\t\t\t\n\t\t\tfor(;;){\n\t\t\t\tif(q.isEmpty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tT<T<Integer,Integer>,Integer> p = q.poll();\n\t\t\t\t\n\t\t\t\tif(map[p.first.first][p.first.second] != -1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmap[p.first.first][p.first.second] = p.second;\n\t\t\t\t\n\t\t\t\tint dx[] = {1,-1,0,0};\n\t\t\t\tint dy[] = {0,0,1,-1};\n\t\t\t\t\n\t\t\t\tfor(int i = 0 ; i < 4; i++){\n\t\t\t\t\tint ni = p.first.first + dx[i];\n\t\t\t\t\tint nj = p.first.second + dy[i];\n\t\t\t\t\t\n\t\t\t\t\tif(ni < 0 || nj < 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(ni >= n || nj >= m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(map[ni][nj] != -1){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\tq.add(new T<T<Integer,Integer>,Integer>(new T<Integer,Integer>(ni,nj),p.second + ((type[p.first.first][p.first.second] == type[ni][nj])?0:1)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\t\tans = Math.min(ans,map[i][0]);\n\t\t\t\tans = Math.min(ans,map[i][m-1]);\n\t\t\t}\n\n\t\t\tfor(int j = 0 ; j < m ; j++){\n\t\t\t\tans = Math.min(ans,map[0][j]);\n\t\t\t\tans = Math.min(ans,map[n-1][j]);\n\t\t\t}\n\n\t\t\tSystem.out.println((ans+1)/2);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tfinal int INF = 100101001;\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint C = sc.nextInt();\n\t\t\tint R = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tchar[][] table = new char[R][C];\n\t\t\tfor (int i = 0; i < R; i++) table[i] = sc.next().toCharArray();\n\t\t\tint[][] best = new int[R][C];\n\t\t\tfor (int i = 0; i < R; i++) for (int j = 0; j < C; j++) best[i][j] = INF;\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tfor (int i = 0; i < R; i++) for (int j = 0; j < C; j++) {\n\t\t\t\tif (i == 0 || j == 0 || i == R - 1 || j == C - 1) {\n\t\t\t\t\tbest[i][j] = 0;\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tq.add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] dr = {0, -1, 0, 1};\n\t\t\tint[] dc = {1, 0, -1, 0};\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint r = q.pollFirst();\n\t\t\t\tint c = q.pollFirst();\n\t\t\t\tif (table[r][c] == '&') {\n\t\t\t\t\tSystem.out.println(best[r][c]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nr = r + dr[i];\n\t\t\t\t\tint nc = c + dc[i];\n\t\t\t\t\tif (0 <= nr && nr < R && 0 <= nc && nc < C) {\n\t\t\t\t\t\tboolean heavy = (table[r][c] == '#' && table[nr][nc] == '.');\n\t\t\t\t\t\tint ncost = best[r][c] + (heavy ? 1 : 0);\n\t\t\t\t\t\tif (best[nr][nc] > ncost) {\n\t\t\t\t\t\t\tbest[nr][nc] = ncost;\n\t\t\t\t\t\t\tif (heavy) {\n\t\t\t\t\t\t\t\tq.add(nr);\n\t\t\t\t\t\t\t\tq.add(nc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tq.addFirst(nc);\n\t\t\t\t\t\t\t\tq.addFirst(nr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[] dx = new short[]{-1,0,1,0},dy = new short[]{0,1,0,-1};\n\tstatic final short INF = Short.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\twhile(true){\n\t\t\tshort w = scan.nextShort();\n\t\t\tshort h = scan.nextShort();\n\t\t\tif(w==0) break;\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\tshort[][] cost = new short[h][w];\n\t\t\tQueue<short[]> que = new LinkedList<short[]>();\n\t\t\tfor (short i = 0; i < h; i++) {\n\t\t\t\tString text = scan.next();\n\t\t\t\tfor (short j = 0; j < w; j++) {\n\t\t\t\t\tchar chr = text.charAt(j);\n\t\t\t\t\tif(chr=='.') map[i][j] = true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j]=false;\n\t\t\t\t\t\tif(chr=='&'){\n\t\t\t\t\t\t\tque.offer(new short[]{i,j,0});\t\t//(y,x,cost)\n\t\t\t\t\t\t\tmap[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tshort[] yxc = que.poll();\n\t\t\t\tint py = yxc[0],px = yxc[1],pc = yxc[2];\n\t\t\t\tcost[py][px]=yxc[2];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint y = py+dy[i],x = px+dx[i],c = pc;\n\t\t\t\t\tif(x<0 || x>=w || y<0 || y>=h){\n\t\t\t\t\t\tmin = Math.min(min, c);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!map[y][x] && map[py][px]) c++;\n\t\t\t\t\tif(cost[y][x]>c) que.offer(new short[]{(short)y,(short)x,(short)c});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(min);\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tchar [][] data;\n\tint w,h;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass State implements Comparable<State>{\n\t\tint nowx,nowy, cost;\n\n\t\tpublic State(int nowx, int nowy, int cost) {\n\t\t\tthis.nowx = nowx;\n\t\t\tthis.nowy = nowy;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [nowx=\" + nowx + \", nowy=\" + nowy + \", cost=\" + cost\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i] = s.toCharArray();\n\t\t\t\tint res = s.indexOf('&');\n\t\t\t\tif(res >= 0){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = solve(sx,sy);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate int solve(int sx, int sy) {\n\t\tint INF = 1 << 24;\n\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\topen.add(new State(sx, sy, 0));\n\t\tint[][] close = new int[h][w];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tArrays.fill(close[i], INF);\n\t\t}\n\t\tclose[sy][sx] = 0;\n\t\tint ans = INF;\n\t\twhile(! open.isEmpty()){\n\t\t\tState now = open.poll();\n\t\t\tif(isGoal(now)){\n\t\t\t\tans = now.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = now.nowx + vx[i];\n\t\t\t\tint yy = now.nowy + vy[i];\n\t\t\t\tint nextcost = now.cost;\n\t\t\t\tif(data[yy][xx] == '#'){\n\t\t\t\t\tnextcost++;\n\t\t\t\t}\n\t\t\t\tif(close[yy][xx] <= nextcost) continue;\n\t\t\t\topen.add(new State(xx, yy, nextcost));\n\t\t\t\tclose[yy][xx] = nextcost;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate boolean isGoal(State now) {\n\t\tif(now.nowx == 0 || now.nowy == 0 || now.nowx == w-1 || now.nowy == h-1) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,1,0,-1};\n\t\tfor(;;)\n\t\t{\n\t\t\tint W=in.nextInt();\n\t\t\tint H=in.nextInt();\n\t\t\tif((H|W)==0)\n\t\t\t\treturn;\n\t\t\tint sh=0,sw=0;\n\t\t\tint cost[][]=new int[H][W];\n\t\t\tchar map[][]=new char[H][W];\n\t\t\tLinkedList<String>que=new LinkedList<String>();\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t\tArrays.fill(cost[i], 100);\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tmap[i][j]=st.charAt(j);\n\t\t\t\t\tif(map[i][j]=='&')\n\t\t\t\t\t{\n\t\t\t\t\t\tsh=i;\n\t\t\t\t\t\tsw=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcost[sh][sw]=0;\n\t\t\tque.add(sh+\" \"+sw);\n\t\t\twhile(!que.isEmpty())\n\t\t\t{\n\t\t\t\tint size=que.size();\n\t\t\t\tfor(int i=0;i<size;i++)\n\t\t\t\t{\n\t\t\t\t\tString now[]=que.poll().split(\" \");\n\t\t\t\t\tint nh=Integer.valueOf(now[0]);\n\t\t\t\t\tint nw=Integer.valueOf(now[1]);\n\t\t\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint h=dy[j]+nh;\n\t\t\t\t\t\tint w=dx[j]+nw;\n\t\t\t\t\t\tif(h>=0&&h<H&&w>=0&&w<W)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif((map[nh][nw]=='#'||map[h][w]=='.')&&cost[nh][nw]<cost[h][w])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcost[h][w]=cost[nh][nw];\n\t\t\t\t\t\t\t\t\t\tque.add(h+\" \"+w);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(map[nh][nw]!='#'&&map[h][w]=='#'&&cost[nh][nw]+1<cost[h][w])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcost[h][w]=cost[nh][nw]+1;\n\t\t\t\t\t\t\t\tque.add(h+\" \"+w);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=100;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(i<1||i>H-2||j<1||j>W-2)\n\t\t\t\t\t\tans=Math.min(ans, cost[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[] dx = new short[]{-1,0,1,0},dy = new short[]{0,1,0,-1};\n\tstatic final short INF = Short.MAX_VALUE;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tint a = 3;\n\t\twhile(a-->0){\n\t\t\tshort w = scan.nextShort();\n\t\t\tshort h = scan.nextShort();\n\t\t\tif(w==0) break;\n\t\t\tboolean[][] map = new boolean[h][w];\n\t\t\tshort[][] cost = new short[h][w];\n\t\t\tQueue<short[]> que = new LinkedList<short[]>();\n\t\t\tfor (short i = 0; i < h; i++) {\n\t\t\t\tString text = scan.next();\n\t\t\t\tfor (short j = 0; j < w; j++) {\n\t\t\t\t\tchar chr = text.charAt(j);\n\t\t\t\t\tif(chr=='.') map[i][j] = true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j]=false;\n\t\t\t\t\t\tif(chr=='&'){\n\t\t\t\t\t\t\tque.offer(new short[]{i,j,0});\t\t//(y,x,cost)\n\t\t\t\t\t\t\tmap[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tshort[] yxc = que.poll();\n\t\t\t\tint py = yxc[0],px = yxc[1],pc = yxc[2];\n\t\t\t\tcost[py][px]=yxc[2];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint y = py+dy[i],x = px+dx[i],c = pc;\n\t\t\t\t\tif(x<0 || x>=w || y<0 || y>=h){\n\t\t\t\t\t\tmin = Math.min(min, c);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!map[y][x] && map[py][px]) c++;\n\t\t\t\t\tif(cost[y][x]>c && min>c) que.offer(new short[]{(short)y,(short)x,(short)c});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(min);\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = 1 << 28;\n\tint n;\n\tint m;\n\tchar[][] map;\n\tint[][] visited;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tif (n <= 2 || m <= 2) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmap = new char[m][n];\n\t\t\tvisited = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tArrays.fill(visited[i], INF);\n\t\t\t}\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ti = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(new Point(sx, sy), 0));\n\t\t}\n\t}\n\n\tint solve(Point pos, int c) {\n\n\t\tint x = pos.x;\n\t\tint y = pos.y;\n\t\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\t\treturn c;\n\t\t}\n\t\tif (visited[y][x] <= c)\n\t\t\treturn INF;\n\t\tvisited[y][x] = c;\n\t\tint dx[] = { 0, 1, 0, -1 };\n\t\tint dy[] = { 1, 0, -1, 0 };\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tres = Math.min(res,\n\t\t\t\t\tsolve(new Point(nx, ny), c + ((map[y][x] == '#') ? 1 : 0)));\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tchar[][] map = new char[h+2][w+2];\n\t\t\tint gx = -1;\n\t\t\tint gy = -1;\n\t\t\tfor(int i=0;i<h+2;i++) Arrays.fill(map[i], '.');\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i+1][j+1] = c[j];\n\t\t\t\t\tif(c[j]=='&'){\n\t\t\t\t\t\tgx = j+1;\n\t\t\t\t\t\tgy = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cnt = new int[h+2][w+2];\n\t\t\tfor(int i=0;i<h;i++) Arrays.fill(cnt[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tint[] a = new int[]{0,0,1,-1};\n\t\t\tint[] b = new int[]{1,-1,0,0};\n\t\t\tArrayDeque<Integer> x = new ArrayDeque<Integer>();\n\t\t\tArrayDeque<Integer> y = new ArrayDeque<Integer>();\n\t\t\tx.offer(0);\n\t\t\ty.offer(0);\n\t\t\tcnt[0][0] = 0;\n\t\t\tint p, q, r;\n\t\t\twhile(x.size()!=0){\n\t\t\t\tp = x.poll();\n\t\t\t\tq = y.poll();\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint u = p+a[i];\n\t\t\t\t\tint v = q+b[i];\n\t\t\t\t\tif(0<=u && u<w+2 && 0<=v && v<h+2){\n\t\t\t\t\t\tif(map[q][p]=='#' && map[v][u]!='#') r = 1;\n\t\t\t\t\t\telse r = 0;\n\t\t\t\t\t\tif(cnt[v][u] > cnt[q][p] + r){\n\t\t\t\t\t\t\tx.offer(u);\n\t\t\t\t\t\t\ty.offer(v);\n\t\t\t\t\t\t\tcnt[v][u] = cnt[q][p] + r;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Moats around the Castle\npublic class Main{\n\n\tstatic int N, M;\n\tstatic boolean safe(int i, int j){\n\t\treturn 0<=i&&i<M&&0<=j&&j<N;\n\t}\n\tstatic int[][] d;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tN = n+2;\n\t\t\tM = m+2;\n\t\t\tchar[][] map = new char[M][N];\n\t\t\tfor(int i=0;i<M;i++)map[i][0]=map[i][N-1]='.';\n\t\t\tfor(int j=0;j<N;j++)map[0][j]=map[M-1][j]='.';\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<n;j++)map[i][j+1]=s[j];\n\t\t\t}\n\t\t\td = new int[M][N];\n\t\t\tfor(int i=0;i<M;i++)Arrays.fill(d[i], Integer.MAX_VALUE);\n\t\t\td[0][0] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(M, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn d[o1[0]][o1[1]]-d[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0,0});\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tif(map[i][j]=='&'){\n\t\t\t\t\tans = Math.min(ans, d[i][j]);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\tif(safe(ni,nj)){\n\t\t\t\t\t\tint cost = d[i][j] + (map[i][j]=='#'&&map[ni][nj]!='#'?1:0);\n\t\t\t\t\t\tif(cost < d[ni][nj]){\n\t\t\t\t\t\t\td[ni][nj] = cost;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.util.Arrays.deepToString;\n\nimport java.util.ArrayDeque;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tfinal int INF = 100101001;\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tfor (;sc.hasNext();) {\n\t\t\tint C = sc.nextInt();\n\t\t\tint R = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tchar[][] table = new char[R][C];\n\t\t\tfor (int i = 0; i < R; i++) table[i] = sc.next().toCharArray();\n\t\t\tint[][] best = new int[R][C];\n\t\t\tfor (int i = 0; i < R; i++) for (int j = 0; j < C; j++) best[i][j] = INF;\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tfor (int i = 0; i < R; i++) for (int j = 0; j < C; j++) {\n\t\t\t\tif (i == 0 || j == 0 || i == R - 1 || j == C - 1) {\n\t\t\t\t\tbest[i][j] = 0;\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tq.add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[] dr = {0, -1, 0, 1};\n\t\t\tint[] dc = {1, 0, -1, 0};\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint r = q.pollFirst();\n\t\t\t\tint c = q.pollFirst();\n\t\t\t\tif (table[r][c] == '&') {\n\t\t\t\t\tSystem.out.println(best[r][c]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nr = r + dr[i];\n\t\t\t\t\tint nc = c + dc[i];\n\t\t\t\t\tif (0 <= nr && nr < R && 0 <= nc && nc < C) {\n\t\t\t\t\t\tboolean heavy = (table[r][c] == '#' && (table[nr][nc] == '.'||table[nr][nc] =='&'));\n\t\t\t\t\t\tint ncost = best[r][c] + (heavy ? 1 : 0);\n\t\t\t\t\t\tif (best[nr][nc] > ncost) {\n\t\t\t\t\t\t\tbest[nr][nc] = ncost;\n\t\t\t\t\t\t\tif (heavy) {\n\t\t\t\t\t\t\t\tq.add(nr);\n\t\t\t\t\t\t\t\tq.add(nc);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tq.addFirst(nc);\n\t\t\t\t\t\t\t\tq.addFirst(nr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Moats around the Castle\npublic class Main{\n\n\tstatic int N, M;\n\tstatic boolean safe(int i, int j){\n\t\treturn 0<=i&&i<M&&0<=j&&j<N;\n\t}\n\tstatic int[][] d;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tN = n+2;\n\t\t\tM = m+2;\n\t\t\tchar[][] map = new char[M][N];\n\t\t\tfor(int i=0;i<M;i++)map[i][0]=map[i][N-1]='.';\n\t\t\tfor(int j=0;j<N;j++)map[0][j]=map[M-1][j]='.';\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<n;j++)map[i][j+1]=s[j];\n\t\t\t}\n\t\t\td = new int[M][N];\n\t\t\tfor(int i=0;i<M;i++)Arrays.fill(d[i], Integer.MAX_VALUE);\n\t\t\td[0][0] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(M, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn d[o1[0]][o1[1]]-d[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0,0});\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tif(map[i][j]=='&'){\n\t\t\t\t\tans = Math.min(ans, d[i][j]);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\tif(safe(ni,nj)){\n\t\t\t\t\t\tint cost = d[i][j] + (map[i][j]=='#'?1:0);\n\t\t\t\t\t\tif(cost < d[ni][nj]){\n\t\t\t\t\t\t\td[ni][nj] = cost;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic short[] dx = new short[]{-1,0,1,0},dy = new short[]{0,1,0,-1};\n\tstatic final short INF = Short.MAX_VALUE;\n\tstatic boolean[][] map = new boolean[100][100];\n\tstatic short[][] cost = new short[100][100];\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\twhile(true){\n\t\t\tshort w = scan.nextShort();\n\t\t\tshort h = scan.nextShort();\n\t\t\tif(w==0) break;\n//\t\t\tboolean[][] map = new boolean[h][w];\n//\t\t\tshort[][] cost = new short[h][w];\n\t\t\tQueue<short[]> que = new LinkedList<short[]>();\n\t\t\tfor (short i = 0; i < h; i++) {\n\t\t\t\tString text = scan.next();\n\t\t\t\tfor (short j = 0; j < w; j++) {\n\t\t\t\t\tchar chr = text.charAt(j);\n\t\t\t\t\tif(chr=='.') map[i][j] = true;\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap[i][j]=false;\n\t\t\t\t\t\tif(chr=='&'){\n\t\t\t\t\t\t\tque.offer(new short[]{i,j,0});\t\t//(y,x,cost)\n\t\t\t\t\t\t\tmap[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = INF;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tshort[] yxc = que.poll();\n\t\t\t\tint py = yxc[0],px = yxc[1],pc = yxc[2];\n\t\t\t\tcost[py][px]=yxc[2];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint y = py+dy[i],x = px+dx[i],c = pc;\n\t\t\t\t\tif(x<0 || x>=w || y<0 || y>=h){\n\t\t\t\t\t\tmin = Math.min(min, c);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!map[y][x] && map[py][px]) c++;\n\t\t\t\t\tif(cost[y][x]>c && min>c) que.offer(new short[]{(short)y,(short)x,(short)c});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(min);\n\t\t}\n\n\t\tout.flush();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = 1 << 28;\n\tint n;\n\tint m;\n\tchar[][] map;\n\tint[][] visited;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[m][n];\n\t\t\tvisited = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tArrays.fill(visited[i], INF);\n\t\t\t}\n\t\t\tif (n <= 2 || m <= 2) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ti = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(new Point(sx, sy), 0));\n\t\t}\n\t}\n\n\tint solve(Point pos, int c) {\n\n\t\tint x = pos.x;\n\t\tint y = pos.y;\n\t\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\t\treturn c;\n\t\t}\n\t\tif (visited[y][x] <= c)\n\t\t\treturn INF;\n\t\tvisited[y][x] = c;\n\t\tint dx[] = { 0, 1, 0, -1 };\n\t\tint dy[] = { 1, 0, -1, 0 };\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tres = Math.min(res,\n\t\t\t\t\tsolve(new Point(nx, ny), c + ((map[y][x] == '#') ? 1 : 0)));\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint WALL = 10000;\n\tint GOAL = 100000;\n\tint w, h;\n\tint map[][];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmap = new int[h+2][w+2];\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) { \n\t\t\t\t\tswitch (str.charAt(j-1)) {\n\t\t\t\t\tcase '#': map[i][j] = WALL; break;\n\t\t\t\t\tcase '&': map[i][j] = GOAL; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint c=1;\n\t\t\t\n\t\t\tSystem.out.println(bfs());\n\t\t}\n\t}\n\t\n\tint dx[] ={-1,0,1,0};\n\tint dy[] ={0,-1,0,1};\n\t\n\tint bfs() {\n\t\tPriorityQueue<P> que = new PriorityQueue<P>();\n\t\tque.add(new P(0,0,0,false));\n\t\tmap[0][0] = INF;\n\t\t\n\t\tfor(;;) {\n\t\t\tP now = que.remove();\n//\t\t\tdebug(now.x, now.y);\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx = now.x + dx[i];\n\t\t\t\tint ny = now.y + dy[i];\n\t\t\t\tif( nx < 0 || nx >= w+2 || ny < 0 || ny >= h+2 ) continue;\n\t\t\t\t\n\t\t\t\tif( map[ny][nx] < WALL ) {\n\t\t\t\t\tmap[ny][nx] = INF;\n\t\t\t\t\tque.add(new P(nx,ny,now.c,false));\n\t\t\t\t}\n\t\t\t\telse if(map[ny][nx] == WALL) {\n\t\t\t\t\tmap[ny][nx] = INF;\n\t\t\t\t\tque.add(new P(nx,ny,now.c+(now.isWall? 0:1),true));\n\t\t\t\t}\n\t\t\t\telse if(map[ny][nx] == GOAL) return now.c;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint x, y, c;\n\t\tboolean isWall;\n\t\tP(int x, int y, int c, boolean w) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.c = c;\n\t\t\tisWall = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\tif(c != o.c)\n\t\t\t\treturn c-o.c;\n\t\t\treturn isWall? -1:1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = 1 << 28;\n\tint n;\n\tint m;\n\tchar[][] map;\n\tint[][] visited;\n\tint dx[] = { 0, 1, 0, -1 };\n\tint dy[] = { 1, 0, -1, 0 };\n\tint min = INF;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[m][n];\n\t\t\tvisited = new int[m][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tArrays.fill(visited[i], INF);\n\t\t\t}\n\t\t\tif (n <= 2 || m <= 2) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (map[i][j] == '&') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ti = INF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve(new Point(sx, sy), 0));\n\t\t}\n\t}\n\n\tint solve(Point pos, int c) {\n\n\t\tint x = pos.x;\n\t\tint y = pos.y;\n\t\tif (x < 0 || y < 0 || x >= n || y >= m) {\n\t\t\treturn min = c;\n\t\t}\n\t\tif (visited[y][x] <= c)\n\t\t\treturn INF;\n\t\tvisited[y][x] = c;\n\t\tif (min < c) {\n\t\t\treturn INF;\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tres = Math.min(res,\n\t\t\t\t\tsolve(new Point(nx, ny), c + ((map[y][x] == '#') ? 1 : 0)));\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass P{\n\tint x;\n\tint y;\n\tint d;\n\tP(int x,int y,int d){\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t\tthis.d=d;\n\t}\n}\n\npublic class Main {\n\t\n\tint n,m;\n\tchar map[][];\n\tint mx[]={-1,0,1,0};\n    int my[]={0,-1,0,1};\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO ティツ?ェテ・ツ仰陛ァツ板淌ヲツ按静」ツ?陛」ツつ古」ツ?淌」ツδ。テ」ツつステ」ツδε」ツδ嘉」ツδサテ」ツつケテ」ツつソテ」ツδ?\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn=sc.nextInt();//x\n\t\t\tm=sc.nextInt();//y\n\t\t\tif(n+m==0) break;\n\t\t\tmap=new char[m][n];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tmap[i]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tint sx=-1,sy=-1;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(map[i][j]=='&'){\n\t\t\t\t\t\tsx=j;\n\t\t\t\t\t\tsy=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tint ans=bfs(new P(sx, sy, 0));\n\t\t\tint ans=dijkstra(sx,sy);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tint dijkstra(int sx,int sy){\n\t\tint y,x,ans;\n\t\tans=2<<15;\n\t\tboolean use[][]=new boolean[m][n];\n\t\tint cost[][]=new int[m][n];\n\t\tfor(int a=0; a<m; a++){\n\t\t\tfor(int b=0; b<n; b++){\n\t\t\t\tuse[a][b]=false;\n\t\t\t\tcost[a][b]=2<<15;\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx]=0;\n\t\twhile(true){\n\t\t\tx=y=-1;\n\t\t\t//テ」ツ?セテ」ツ??、ツスツソテ」ツ?」テ」ツ?ヲテ」ツ?ェテ」ツ??」ツつ?」ツ?、テ」ツ?ァテ」ツ??\n\t\t\tfor(int a=0; a<m; a++){\n\t\t\t\tfor(int b=0; b<n; b++){\n\t\t\t\t\tif(!use[a][b] && \n\t\t\t\t\t\t\t(x==-1 || cost[a][b]<cost[y][x])){\n\t\t\t\t\t\ty=a;x=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(x==-1) break;\n\t\t\t//System.out.println(y+\" \"+x);\n\t\t\tuse[y][x]=true;\n\n\t\t\t//テ、ツサツ甘・ツ崢榲」ツ?ョテァツァツサテ・ツ仰陛」ツ?ッ4テヲツ鳴ケテ・ツ青?\n\t\t\t//テ」ツ?敕」ツつ古」ツ?ォテ」ツ?づ」ツつ湘」ツ?崚」ツ?ヲテ」ツ?ョテ」ツつオテ」ツつ、テ」ツつウテ」ツδュテ」ツ?ョテァツ崢ョテ」ツ?ョテ・ツ、ツ嘉・ツ個姪」ツ?ォテ」ツ?づ」ツつ湘」ツ?崚」ツ?ヲティツィツ暗ァツョツ?\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t//テァツァツサテ・ツ仰陛」ツ?ァテ」ツ?催」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツ?ョテ」ツδ?」ツつァテ」ツδε」ツつッ テ・ツ」ツ?」ツδ?」ツつァテ」ツδε」ツつッ\n\t\t\t\tif(y+my[i]<0 || x+mx[i]<0 || m<=y+my[i] || n<=x+mx[i]){\n\t\t\t\t\tif(map[y][x]=='#'){\n\t\t\t\t\t\tans=Math.min(ans,cost[y][x]+1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tans=Math.min(ans,cost[y][x]);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(map[y][x]=='#' && map[y+my[i]][x+mx[i]]=='.'){\n\t\t\t\t\tcost[y+my[i]][x+mx[i]]=Math.min(cost[y+my[i]][x+mx[i]], cost[y][x]+1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcost[y+my[i]][x+mx[i]]=cost[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n//\tint bfs(P sp){\n//\t\tQueue<P> q=new LinkedList<P>();\n//\t\tq.offer(sp);//テ」ツつケテ」ツつソテ」ツδシテ」ツδ暗」ツ?ョsテ」ツつ津」ツつュテ」ツδ・テ」ツδシテ」ツ?ォテ」ツ??」ツつ古」ツ?ヲテ」ツ??\n//\t\n//\t\twhile(!q.isEmpty()){//テ」ツつュテ」ツδ・テ」ツδシテ」ツ?古ァツゥツコテ」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?セテ」ツ?ァテ」ツつ?」ツつ?\n//\t\t\tP now=q.poll();//テ」ツつュテ」ツδ・テ」ツδシテ」ツ?ョテ・ツ?暗ゥツ?ュテ」ツつ津・ツ渉姪」ツつ甘・ツ?コテ」ツ??\n//\t\t\tint nx=now.x;\n//\t\t\tint ny=now.y;\n//\t\t\tif(nx < 0 || n <= nx || ny < 0 || m <= ny){\n//\t\t\t\treturn now.d;\n//\t\t\t}\n//\t\t\tmap[nx][ny]='@';\n//\t\t\t//テ」ツ?禿」ツ?禿」ツ?凝」ツつ嘉ゥツ?キテァツァツサテ・ツ?暗」ツつ津」ツつュテ」ツδ・テ」ツδシテ」ツ?ォテ・ツ?・テ」ツつ古」ツ?ヲテ」ツ??」ツ??\n//\t\t\tfor(int i=0; i<4; i++){\n//\t\t\t\tif(nx+mx[i] < 0 || n <= nx+mx[i] || ny+my[i] < 0 || m <= ny+my[i]){\n//\t\t\t\t\treturn now.d;\n//\t\t\t\t}\n//\t\t\t\tif(map[ny+my[i]][nx+mx[i]]=='@'){\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n//\t\t\t\tif(map[ny][nx]!=map[ny+my[i]][nx+mx[i]]){\n//\t\t\t\t\tq.offer(new P(nx+mx[i],ny+my[i],now.d+1));\n//\t\t\t\t}\n//\t\t\t\telse{\n//\t\t\t\t\tq.offer(new P(nx+mx[i],ny+my[i],now.d));\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t\treturn -1;\n//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int w, h;\n\tstatic int a[][];\n\tstatic int m[][];\n\tstatic int sx, sy;\n\tstatic int ans;\n\n\tpublic static void markh(int x, int y, int mark) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || a[y][x] == '#') {\n\t\t\treturn ;\n\t\t}\n\t\tif (0 <= m[y][x]) {\n\t\t\tif (x != sx || y != sy) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t\tm[y][x] = mark;\n\t\tmarkh(x + 1, y, mark);\n\t\tmarkh(x - 1, y, mark);\n\t\tmarkh(x, y + 1, mark);\n\t\tmarkh(x, y - 1, mark);\n\t}\n\n\tpublic static void markl (int x, int y, int mark) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || a[y][x] == '.' || 0 <= m[y][x]) {\n\t\t\treturn ;\n\t\t}\n\t\tm[y][x] = mark;\n\t\tmarkl(x + 1, y, mark);\n\t\tmarkl(x - 1, y, mark);\n\t\tmarkl(x, y + 1, mark);\n\t\tmarkl(x, y - 1, mark);\n\t}\n\n\tpublic static boolean check() {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tif (0 <= m[i][0]) {\n\t\t\t\tans = m[i][0];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (0 <= m[i][w - 1]) {\n\t\t\t\tans = m[i][w - 1];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (0 <= m[0][j]) {\n\t\t\t\tans = m[0][j];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (0 <= m[h - 1][j]) {\n\t\t\t\tans = m[h - 1][j];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta = new int[h][w];\n\t\t\tm = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tArrays.fill(m[i], -1);\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ta[i][j] = s.charAt(j);\n\t\t\t\t\tif (a[i][j] == '&') {\n\t\t\t\t\t\tm[i][j] = 0;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmarkh(sx, sy, 0);\n\n\t\t\twhile (!check()) {\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (0 <= m[i][j] && a[i][j] != '#') {\n\t\t\t\t\t\t\tmarkl(j + 1, i, m[i][j] + 1);\n\t\t\t\t\t\t\tmarkl(j - 1, i, m[i][j] + 1);\n\t\t\t\t\t\t\tmarkl(j, i + 1, m[i][j] + 1);\n\t\t\t\t\t\t\tmarkl(j, i - 1, m[i][j] + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (0 <= m[i][j] && a[i][j] != '.') {\n\t\t\t\t\t\t\tmarkh(j + 1, i, m[i][j]);\n\t\t\t\t\t\t\tmarkh(j - 1, i, m[i][j]);\n\t\t\t\t\t\t\tmarkh(j, i + 1, m[i][j]);\n\t\t\t\t\t\t\tmarkh(j, i - 1, m[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tstatic int n;\n\tstatic int m;\n\tstatic char[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tmap = new char[m][];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint gx = 0;\n\t\t\tint gy = 0;\n\t\t\tIN:for(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tif(map[i][j] == '&') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\tbreak IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsolv(gy,gx);\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tmin = Math.min(costMap[0][j], min);\n\t\t\t\t\tmin = Math.min(costMap[m-1][j], min);\n\t\t\t}\n\t\t\tfor(int j = 0; j < m; j++) {\n\t\t\t\tmin = Math.min(costMap[j][0], min);\n\t\t\t\tmin = Math.min(costMap[j][n-1], min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t\t\n\t\t}\n\t}\n\t\n\tstatic class Data {\n\t\tint x;\n\t\tint y;\n\t\tint c;\n\t\t\n\t\tData(int d, int e, int f) {\n\t\t\ty = d;\n\t\t\tx = e;\n\t\t\tc = f;\n\t\t}\n\t}\n\t\n\tstatic int[] vx = new int[] {1,0,-1,0};\n\tstatic int[] vy = new int[] {0,1,0,-1};\n\tstatic ArrayDeque<Data> queue = new ArrayDeque<Data>();\n\tstatic int[][] costMap = new int[m][n];\n\t\n\t\n\tstatic void solv(int gy, int gx) {\n\t\tcostMap = new int[m][n];\n\t\tcostMap[gy][gx] = 0;\n\t\t\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tArrays.fill(costMap[i], 2 << 27);\n\t\t}\n\t\tqueue.addLast(new Data(gy,gx,0));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tBFS(queue.pollFirst());\n\t\t}\n\t}\n\t\n\tstatic void BFS(Data a) {\n\t\tif(!rangeCheck(a.y,a.x)) return;\n\t\tif(costMap[a.y][a.x] <= a.c) return;\n\t\tcostMap[a.y][a.x] = a.c;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(!rangeCheck(a.y+ vy[i],a.x+ vx[i])) continue;\n\t\t\tif((map[a.y][a.x] == '.' || map[a.y][a.x] == '&') && map[a.y + vy[i]][a.x + vx[i]] == '#') {\n\t\t\t\tqueue.addLast(new Data(a.y + vy[i],a.x + vx[i], a.c+1));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tqueue.addLast(new Data(a.y + vy[i],a.x + vx[i], a.c));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic boolean rangeCheck(int a, int b) {\n\t\tif(a < 0 || b < 0 || a >= m || b >= n) return false;\n\t\treturn true;\n\t}\n\t\n\t\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int w,h,gx,gy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tstatic int[][] cost;\n\tstatic char[][] field;\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0) return false;\n\t\t\n\t\tfield = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) field[i] = sc.next().toCharArray();\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(field[i][j] == '&') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve() {\n\t\tint ans = Integer.MAX_VALUE;\n\t\tsearch();\n\t\tfor(int i = 0; i < w; i++) ans = min(ans, min(cost[0][i], cost[h-1][i]));\n\t\tfor(int i = 0; i < h; i++) ans = min(ans, min(cost[i][0], cost[i][w-1]));\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic int search() {\n\t\tcost = new int[h][w];\n\t\tfor(int i = 0; i < h; i++) fill(cost[i], -1);\n\t\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\t\tpq.offer(new State(gx, gy, 0));\n\t\t\n\t\tState s = null;\n\t\twhile(!pq.isEmpty()) {\n\t\t\ts = pq.poll();\n\t\t\tcost[s.y][s.x] = s.step;\n\t\t\t\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint x = s.x + dx[k], y = s.y + dy[k];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h || cost[y][x] != -1) continue;\n\t\t\t\tswitch(field[y][x]) {\n\t\t\t\tcase '.':\n\t\t\t\t\tpq.offer(new State(x, y, s.step));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tpq.offer(new State(x, y, s.step + 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) solve();\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint x,y,step;\n\tState(int x, int y, int step) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.step = step;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.step - s.step;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int w,h,gx,gy;\n\tstatic int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};\n\tstatic int[][] cost;\n\tstatic char[][] field;\n\t\n\tstatic boolean read() {\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tif(w == 0) return false;\n\t\t\n\t\tfield = new char[h][w];\n\t\tfor(int i = 0; i < h; i++) field[i] = sc.next().toCharArray();\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif(field[i][j] == '&') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic void solve() {\n\t\tint ans = Integer.MAX_VALUE;\n\t\tsearch();\n\n\t\tfor(int i = 0; i < w; i++) ans = min(ans, min(cost[0][i], cost[h-1][i]));\n\t\tfor(int i = 0; i < h; i++) ans = min(ans, min(cost[i][0], cost[i][w-1]));\n\t\tSystem.out.println(ans);\n\t}\n\t\n\tstatic int search() {\n\t\tcost = new int[h][w];\n\t\tfor(int i = 0; i < h; i++) fill(cost[i], Integer.MAX_VALUE);\n\t\tQueue<State> pq = new LinkedList<State>();\n\t\tpq.offer(new State(gx, gy, 0));\n\t\t\n\t\tState s = null;\n\t\twhile(!pq.isEmpty()) {\n\t\t\ts = pq.poll();\n\t\t\tif(cost[s.y][s.x] <= s.step) continue;\n\t\t\tcost[s.y][s.x] = s.step;\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint x = s.x + dx[k], y = s.y + dy[k];\n\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h) continue;\n\t\t\t\tswitch(field[y][x]) {\n\t\t\t\tcase '.':\n\t\t\t\t\tpq.offer(new State(x, y, s.step));\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tpq.offer(new State(x, y, s.step + 1));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Integer.MAX_VALUE;\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) solve();\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint x,y,step;\n\tState(int x, int y, int step) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.step = step;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.step - s.step;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h;\n\tstatic int[][] field;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tlabel:while(true){\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0)break;\n\t\t\tfield=new int[h][w];\n\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] s=cin.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(s[j]=='.'){\n\t\t\t\t\t\tfield[i][j]=-1;\t\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j]=='&'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t\tq.add(new int[]{i,j});\n\t\t\t\t\t}\n\t\t\t\t\telse if(s[j]=='#'){\n\t\t\t\t\t\tfield[i][j]=-2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a=q.poll();\n\t\t\t\tint x=a[0];\n\t\t\t\tint y=a[1];\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+v1[i];\n\t\t\t\t\tint yy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\t\tSystem.out.println(0);\n\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t}\n\t\t\t\t\tif(field[xx][yy]==-1){\n\t\t\t\t\t\tfield[xx][yy]=0;\n\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n//\t\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tfor(int cnt=0;;cnt++){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tif(field[i][j]==cnt){\n\t\t\t\t\t\t\tq.add(new int[]{i,j});\n\t\t\t\t\t\t\tif(a(q,cnt)){\n\t\t\t\t\t\t\t\tSystem.out.println(cnt+1);\n\t\t\t\t\t\t\t\tcontinue label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq=new LinkedList<int[]>();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic boolean a(Queue<int[]> q,int cnt){\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] a=q.poll();\n\t\t\tint x=a[0];\n\t\t\tint y=a[1];\n\t\t\tif(field[x][y]==-1){\n\t\t\t\tfield[x][y]=cnt+1;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+v1[i];\n\t\t\t\tint yy=y+v2[i];\n\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif(field[xx][yy]==cnt){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field[xx][yy]==-1){\n\t\t\t\t\tfield[xx][yy]=cnt+1;\n\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t}\n\t\t\t\tif(field[xx][yy]==-2&&field[x][y]==cnt){\n\t\t\t\t\txx=x+v1[i];\n\t\t\t\t\tyy=y+v2[i];\n\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tfield[xx][yy]=cnt+1;\n\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Moats around the Castle\npublic class Main{\n\n\tstatic int N, M;\n\tstatic boolean safe(int i, int j){\n\t\treturn 0<=i&&i<M&&0<=j&&j<N;\n\t}\n\tstatic int[][] d;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] move = {{0,1},{0,-1},{1,0},{-1,0}};\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tN = n+2;\n\t\t\tM = m+2;\n\t\t\tchar[][] map = new char[M][N];\n\t\t\tfor(int i=0;i<M;i++)map[i][0]=map[i][N-1]='.';\n\t\t\tfor(int j=0;j<N;j++)map[0][j]=map[M-1][j]='.';\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<n;j++)map[i][j+1]=s[j];\n\t\t\t}\n\t\t\td = new int[M][N];\n\t\t\tfor(int i=0;i<M;i++)Arrays.fill(d[i], Integer.MAX_VALUE);\n\t\t\td[0][0] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(M, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn d[o1[0]][o1[1]]-d[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{0,0});\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] a = q.poll();\n\t\t\t\tint i = a[0];\n\t\t\t\tint j = a[1];\n\t\t\t\tif(map[i][j]=='&'){\n\t\t\t\t\tans = Math.min(ans, d[i][j]);\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = i+move[k][0];\n\t\t\t\t\tint nj = j+move[k][1];\n\t\t\t\t\tif(safe(ni,nj)){\n\t\t\t\t\t\tint cost = d[i][j] + (map[i][j]=='#'&&map[ni][nj]=='.'?1:0);\n\t\t\t\t\t\tif(cost < d[ni][nj]){\n\t\t\t\t\t\t\td[ni][nj] = cost;\n\t\t\t\t\t\t\tq.add(new int[]{ni,nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\t\n\t\t\tint[][] map = new int[h][w];\n\t\t\tint gx = -1;\n\t\t\tint gy = -1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] c = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(c[j]=='#') map[i][j] = 1;\n\t\t\t\t\telse if(c[j]=='&'){\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cnt = new int[h][w];\n\t\t\tfor(int i=0;i<h;i++) Arrays.fill(cnt[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tLinkedList<Integer> sxlist = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> sylist = new LinkedList<Integer>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tsxlist.add(0);\n\t\t\t\tsxlist.add(w-1);\n\t\t\t\tsylist.add(i);\n\t\t\t\tsylist.add(i);\n\t\t\t}\n\t\t\tfor(int i=1;i<w-1;i++){\n\t\t\t\tsxlist.add(i);\n\t\t\t\tsxlist.add(i);\n\t\t\t\tsylist.add(0);\n\t\t\t\tsylist.add(h-1);\n\t\t\t}\n\t\t\t\n\t\t\tint[] a = new int[]{0,0,1,-1};\n\t\t\tint[] b = new int[]{1,-1,0,0};\n\t\t\twhile(sxlist.size()!=0){\n\t\t\t\tboolean[][] vst = new boolean[h][w];\n\t\t\t\tint p = sxlist.pollLast();\n\t\t\t\tint q = sylist.pollLast();\n\t\t\t\tArrayDeque<Integer> x = new ArrayDeque<Integer>();\n\t\t\t\tArrayDeque<Integer> y = new ArrayDeque<Integer>();\n\t\t\t\tx.offer(p);\n\t\t\t\ty.offer(q);\n\t\t\t\tcnt[q][p] = map[q][p];\n\t\t\t\twhile(x.size()!=0){\n\t\t\t\t\tp = x.poll();\n\t\t\t\t\tq = y.poll();\n\t\t\t\t\tif(p==gx && q==gy) break;\n\t\t\t\t\tvst[q][p] = true;\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint u = p+a[i];\n\t\t\t\t\t\tint v = q+b[i];\n\t\t\t\t\t\tif(0<=u && u<w && 0<=v && v<h){\n\t\t\t\t\t\t\tif(vst[v][u]==false && cnt[v][u] > cnt[q][p] + map[v][u]){\n\t\t\t\t\t\t\t\tx.offer(u);\n\t\t\t\t\t\t\t\ty.offer(v);\n\t\t\t\t\t\t\t\tcnt[v][u] = cnt[q][p] + map[v][u];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt[gy][gx]);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tchar [][] data;\n\tint w,h;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass State implements Comparable<State>{\n\t\tint nowx,nowy, cost;\n\n\t\tpublic State(int nowx, int nowy, int cost) {\n\t\t\tthis.nowx = nowx;\n\t\t\tthis.nowy = nowy;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"State [nowx=\" + nowx + \", nowy=\" + nowy + \", cost=\" + cost\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tdata = new char[h][w];\n\t\t\tint sx = -1, sy = -1;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\tdata[i] = s.toCharArray();\n\t\t\t\tint res = s.indexOf('&');\n\t\t\t\tif(res >= 0){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = solve(sx,sy);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate int solve(int sx, int sy) {\n\t\tint INF = 1 << 24;\n\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\topen.add(new State(sx, sy, 0));\n\t\tint[][] close = new int[h][w];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tArrays.fill(close[i], INF);\n\t\t}\n\t\tclose[sy][sx] = 0;\n\t\tint ans = INF;\n\t\twhile(! open.isEmpty()){\n\t\t\tState now = open.poll();\n\t\t\tif(isGoal(now)){\n\t\t\t\tans = now.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = now.nowx + vx[i];\n\t\t\t\tint yy = now.nowy + vy[i];\n\t\t\t\tint nextcost = now.cost;\n\t\t\t\tif(data[now.nowy][now.nowx] != '#' && data[yy][xx] == '#'){\n\t\t\t\t\tnextcost++;\n\t\t\t\t}\n\t\t\t\tif(close[yy][xx] <= nextcost) continue;\n\t\t\t\topen.add(new State(xx, yy, nextcost));\n\t\t\t\tclose[yy][xx] = nextcost;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tprivate boolean isGoal(State now) {\n\t\tif(now.nowx == 0 || now.nowy == 0 || now.nowx == w-1 || now.nowy == h-1) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n\n    int[] vy = new int[] { 1, 0, -1, 0 };\n    int[] vx = new int[] { 0, 1, 0, -1 };\n    int h, w;\n\n    void run()\n    {\n        Scanner cin = new Scanner();\n        while (true)\n        {\n            w = cin.nextInt() + 2;\n            h = cin.nextInt() + 2;\n            int[,] flag = new int[h, w];\n            if (h == 2) break;\n\n            for (int i = 0; i < h - 2; i++)\n            {\n                string s = Console.ReadLine();\n                for (int j = 0; j < w - 2; j++)\n                {\n                    if (s[j] == '#') flag[i + 1, j + 1] = 1;\n                    else if (s[j] == '&') flag[i + 1, j + 1] = 2;\n                }\n            }\n            Queue<int> now = new Queue<int>();\n            Queue<int> next = new Queue<int>();\n            int[,] dist = new int[h, w];\n            int MAX = 99999;\n            \n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    dist[i, j] = MAX;\n                }\n            }\n            now.Enqueue(0);\n            dist[0, 0] = 0;\n\n            int ret = MAX;\n            while (ret == MAX)\n            {\n                while (now.Count != 0)\n                {\n                    int nowp = now.Dequeue();\n                    int y = nowp / w;\n                    int x = nowp % w;\n                    //Console.WriteLine(\"now: \" + y + \" \" + x);\n                    for (int k = 0; k < 4; k++)\n                    {\n                        int ny = y + vy[k];\n                        int nx = x + vx[k];\n                        if (!ok(ny, nx)) continue;\n                        if (dist[ny, nx] != MAX) continue;\n                        if ((flag[ny, nx] ^ flag[y, x]) % 2 == 1)\n                        {\n                            dist[ny, nx] = dist[y, x] + 1;\n                            if (flag[ny, nx] == 2) ret = dist[ny, nx];\n                            next.Enqueue(ny * w + nx);\n                        }\n                        else\n                        {\n                            dist[ny, nx] = dist[y, x];\n                            if (flag[ny, nx] == 2) ret = dist[ny, nx];\n                            now.Enqueue(ny * w + nx);\n                        }\n                    }\n\n                }\n                now = next;\n                next = new Queue<int>();\n            }\n            Console.WriteLine(ret / 2);\n        }\n\n    }\n\n    bool ok(int y, int x)\n    {\n        return y >= 0 && y < h && x >= 0 && x < w;\n    }\n\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, memo;\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            memo = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                memo[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (memo[nextY, nextX] > tempCnt && tempCnt < minCnt)\n                        {\n                            stk.Push(new State(nextX, nextY, tempCnt));\n                        }\n                    }\n                    else minCnt = Math.Min(minCnt, cur.cnt);\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w || y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    memo[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0156\n{\n    public class Program\n\n    {\n        public static int[] di = new int[] { 0, -1, 0, 1 };\n        public static int[] dj = new int[] { -1, 0, 1, 0 };\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n\n                int[] nm = RIntAr();\n                if (nm.Sum() == 0) break;\n\n                int n = nm[0];\n                int m = nm[1];\n\n                Tuple<int, int> castleTower = new Tuple<int, int>(0, 0);\n                int[,] map = new int[m + 2, n + 2];\n                for (int i = 1 ; i < m + 1 ; i++)\n                {\n                    string line = RSt();\n                    for (int j = 1 ; j < n + 1 ; j++)\n                    {\n                        map[i, j] = line[j - 1] == '#' ? 1 : 0;\n                        if (line[j - 1] == '&') castleTower = new Tuple<int, int>(i, j);\n                    }\n                }\n\n                int[,] distance = new int[m + 2, n + 2];\n                for (int i = 0 ; i < distance.GetLength(0) ; i++)\n                {\n                    for (int j = 0 ; j < distance.GetLength(1) ; j++)\n                    {\n                        distance[i, j] = int.MaxValue;\n                    }\n                }\n\n                Queue<Tuple<int, int>> q = new Queue<Tuple<int, int>>();\n                distance[0, 0] = 0;\n                q.Enqueue(new Tuple<int, int>(0, 0));\n\n                while (q.Count > 0)\n                {\n                    Tuple<int, int> pos = q.Dequeue();\n\n                    for (int i = 0 ; i < di.Length ; i++)\n                    {\n                        if (!IsInRange(pos.Item1 + di[i], pos.Item2 + dj[i], map)) continue;\n                        int nextCost = distance[pos.Item1, pos.Item2];\n                        nextCost += (map[pos.Item1, pos.Item2] == 1 && map[pos.Item1 + di[i], pos.Item2 + dj[i]] == 0) ? 1 : 0;\n\n                        if (distance[pos.Item1 + di[i], pos.Item2 + dj[i]] > nextCost)\n                        {\n                            distance[pos.Item1 + di[i], pos.Item2 + dj[i]] = nextCost;\n                            q.Enqueue(new Tuple<int, int>(pos.Item1 + di[i], pos.Item2 + dj[i]));\n                        }\n                    }\n                }\n                Console.WriteLine(distance[castleTower.Item1, castleTower.Item2]);\n            }\n        }\n\n        public static bool IsInRange(int i , int j, int[,] map)\n        {\n            if (i < 0 || i > map.GetLength(0) - 1 || j < 0 || j > map.GetLength(1) - 1) return false;\n            else return true;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, counts;\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            counts = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                counts[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (counts[nextY, nextX] <= tempCnt) continue;\n\n                        if (tempCnt < minCnt) stk.Push(new State(nextX, nextY, tempCnt));\n                    }\n                    else minCnt = Math.Min(minCnt, cur.cnt);\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    counts[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, counts;\n\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            counts = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                counts[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        if (counts[nextY, nextX] <= cur.cnt) continue;\n\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (tempCnt < minCnt)\n                        {\n                            stk.Push(new State(nextX, nextY, tempCnt));\n                        }\n                    }\n                    else\n                    {\n                        minCnt = Math.Min(minCnt, cur.cnt);\n                    }\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    counts[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State : IComparable\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n\n        public int CompareTo(object obj)\n        {\n            State other = (State)obj;\n            return other.cnt - cnt;         //rev\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n\n        readonly int w, h;\n\n        int[,] map;\n        bool[,] visited;\n\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            visited = new bool[h, w];\n            minCnt = int.MaxValue;\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n\n            PriorityQueue<State> PQ = new PriorityQueue<State>();\n            PQ.Enqueue(new State(sx, sy, 0));\n\n            while (PQ.Count > 0)\n            {\n                State cur = PQ.Dequeue();\n                visited[cur.y, cur.x] = true;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        if (visited[nextY, nextX]) continue;\n\n                        int tempCnt = cur.cnt + map[nextY, nextX];\n\n                        if (tempCnt < minCnt)\n                        {\n                            PQ.Enqueue(new State(nextX, nextY, tempCnt));\n                        }\n                    }\n                    else\n                    {\n                        minCnt = Math.Min(minCnt, cur.cnt);\n                    }\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public int Count { get { return size; } }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, memo;\n        int sx, sy;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            memo = new int[h, w];\n            MakeMap();\n        }\n\n        public int Solve()\n        {\n            int ret = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                memo[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (memo[nextY, nextX] > tempCnt && tempCnt < ret)\n                        {\n                            stk.Push(new State(nextX, nextY, tempCnt));\n                        }\n                    }\n                    else ret = Math.Min(ret, cur.cnt);\n                }\n            }\n            return ret;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w || y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    memo[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State : IComparable\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n\n        public int CompareTo(object obj)\n        {\n            State other = (State)obj;\n            return other.cnt - cnt;         //rev\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n\n        readonly int w, h;\n\n        int[,] map;\n        bool[,] visited;\n\n        int sx, sy;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            visited = new bool[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n\n            PriorityQueue<State> PQ = new PriorityQueue<State>();\n            PQ.Enqueue(new State(sx, sy, 0));\n\n            while (PQ.Count > 0)\n            {\n                State cur = PQ.Dequeue();\n                visited[cur.y, cur.x] = true;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        if (visited[nextY, nextX]) continue;\n\n                        int tempCnt = cur.cnt + map[nextY, nextX];\n\n                        PQ.Enqueue(new State(nextX, nextY, tempCnt));\n\n                    }\n                    else\n                    {\n                        return cur.cnt;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public int Count { get { return size; } }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, counts;\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            counts = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                counts[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n                        \n                        if (counts[nextY, nextX] > tempCnt) stk.Push(new State(nextX, nextY, tempCnt));\n                    }\n                    else minCnt = Math.Min(minCnt, cur.cnt);\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    counts[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, counts;\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            counts = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                counts[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (tempCnt < minCnt && counts[nextY, nextX] > tempCnt)\n                        {\n                            stk.Push(new State(nextX, nextY, tempCnt));\n                        }\n                    }\n                    else minCnt = Math.Min(minCnt, cur.cnt);\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    counts[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n\n    int[] vy = new int[] { 1, 0, -1, 0 };\n    int[] vx = new int[] { 0, 1, 0, -1 };\n    int h, w;\n\n    void run()\n    {\n        Scanner cin = new Scanner();\n        while (true)\n        {\n            w = cin.nextInt() + 2;\n            h = cin.nextInt() + 2;\n            int[,] flag = new int[h, w];\n            if (h == 2) break;\n\n            for (int i = 0; i < h - 2; i++)\n            {\n                string s = Console.ReadLine();\n                for (int j = 0; j < w - 2; j++)\n                {\n                    if (s[j] == '#') flag[i + 1, j + 1] = 1;\n                    else if (s[j] == '&') flag[i + 1, j + 1] = 2;\n                }\n            }\n            Queue<int> now = new Queue<int>();\n            Queue<int> next = new Queue<int>();\n            int[,] dist = new int[h, w];\n            int MAX = 99999;\n            \n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    dist[i, j] = MAX;\n                }\n            }\n            now.Enqueue(0);\n            dist[0, 0] = 0;\n\n            int ret = MAX;\n            while (ret == MAX)\n            {\n                while (now.Count != 0)\n                {\n                    int nowp = now.Dequeue();\n                    int y = nowp / w;\n                    int x = nowp % w;\n                    //Console.WriteLine(\"now: \" + y + \" \" + x);\n                    for (int k = 0; k < 4; k++)\n                    {\n                        int ny = y + vy[k];\n                        int nx = x + vx[k];\n                        if (!ok(ny, nx)) continue;\n                        if (dist[ny, nx] != MAX) continue;\n                        if ((flag[ny, nx] ^ flag[y, x]) % 2 == 1)\n                        {\n                            dist[ny, nx] = dist[y, x] + 1;\n                            if (flag[ny, nx] == 2) ret = dist[ny, nx];\n                            next.Enqueue(ny * w + nx);\n                        }\n                        else\n                        {\n                            dist[ny, nx] = dist[y, x];\n                            if (flag[ny, nx] == 2) ret = dist[ny, nx];\n                            now.Enqueue(ny * w + nx);\n                        }\n                    }\n\n                }\n                now = next;\n                next = new Queue<int>();\n            }\n            Console.WriteLine(ret);\n        }\n\n    }\n\n    bool ok(int y, int x)\n    {\n        return y >= 0 && y < h && x >= 0 && x < w;\n    }\n\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, counts;\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            counts = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                counts[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (counts[nextY, nextX] > tempCnt && tempCnt < minCnt)\n                        {\n                            stk.Push(new State(nextX, nextY, tempCnt));\n                        }\n                    }\n                    else minCnt = Math.Min(minCnt, cur.cnt);\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    counts[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().run();\n        return 0;\n    }\n\n\n    int[] vy = new int[] { 1, 0, -1, 0 };\n    int[] vx = new int[] { 0, 1, 0, -1 };\n    int h, w;\n\n    void run()\n    {\n        Scanner cin = new Scanner();\n        while (true)\n        {\n            w = cin.nextInt() + 2;\n            h = cin.nextInt() + 2;\n            int[,] flag = new int[h, w];\n            if (h == 2) break;\n\n            for (int i = 0; i < h - 2; i++)\n            {\n                string s = Console.ReadLine();\n                for (int j = 0; j < w - 2; j++)\n                {\n                    if (s[j] == '#') flag[i + 1, j + 1] = 1;\n                    else if (s[j] == '&') flag[i + 1, j + 1] = 2;\n                }\n            }\n            Queue<int> now = new Queue<int>();\n            Queue<int> next = new Queue<int>();\n            int[,] dist = new int[h, w];\n            int MAX = 99999;\n            \n            for (int i = 0; i < h; i++)\n            {\n                for (int j = 0; j < w; j++)\n                {\n                    dist[i, j] = MAX;\n                }\n            }\n            now.Enqueue(0);\n            dist[0, 0] = 0;\n\n            int ret = MAX;\n            while (ret == MAX)\n            {\n                while (now.Count != 0)\n                {\n                    int nowp = now.Dequeue();\n                    int y = nowp / w;\n                    int x = nowp % w;\n                    //Console.WriteLine(\"now: \" + y + \" \" + x);\n                    for (int k = 0; k < 4; k++)\n                    {\n                        int ny = y + vy[k];\n                        int nx = x + vx[k];\n                        if (!ok(ny, nx)) continue;\n                        if (dist[ny, nx] != MAX) continue;\n                        if (flag[ny, nx] == 1)\n                        {\n                            dist[ny, nx] = dist[y, x] + 1;\n                            next.Enqueue(ny * w + nx);\n                        }\n                        else\n                        {\n                            dist[ny, nx] = dist[y, x];\n                            if (flag[ny, nx] == 2) ret = dist[ny, nx];\n                            now.Enqueue(ny * w + nx);\n                        }\n                    }\n\n                }\n                now = next;\n                next = new Queue<int>();\n            }\n            Console.WriteLine(ret);\n        }\n\n    }\n\n    bool ok(int y, int x)\n    {\n        return y >= 0 && y < h && x >= 0 && x < w;\n    }\n\n}\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State : IComparable\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n\n        public int CompareTo(object obj)\n        {\n            State other = (State)obj;\n            return other.cnt - cnt;         //rev\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n\n        readonly int w, h;\n\n        int[,] map;\n        bool[,] visited;\n\n        int sx, sy;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            visited = new bool[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n\n            PriorityQueue<State> PQ = new PriorityQueue<State>();\n            PQ.Enqueue(new State(sx, sy, 0));\n\n            while (PQ.Count > 0)\n            {\n                State cur = PQ.Dequeue();\n                visited[cur.y, cur.x] = true;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        if (visited[nextY, nextX]) continue;\n\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        PQ.Enqueue(new State(nextX, nextY, tempCnt));\n                    }\n                    else\n                    {\n                        return cur.cnt;\n                    }\n                }\n            }\n            return -1;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n\n    class PriorityQueue<T> where T : IComparable\n    {\n        List<T> heap;\n        int size;\n\n        public PriorityQueue()\n        {\n            heap = new List<T>();\n        }\n\n        public int Count { get { return size; } }\n\n        public void Enqueue(T x)\n        {\n            heap.Add(x);\n            int i = size++;\n\n            while (i > 0)\n            {\n                int p = (i - 1) / 2;\n\n                if (Compare(heap[p], x) <= 0) break;\n\n                heap[i] = heap[p];\n                i = p;\n            }\n            heap[i] = x;\n        }\n\n        public T Dequeue()\n        {\n            T ret = heap[0];\n            T x = heap[--size];\n\n            int i = 0;\n            while (i * 2 + 1 < size)\n            {\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < size && Compare(heap[b], heap[a]) < 0)\n                    a = b;\n                if (Compare(heap[a], x) >= 0)\n                    break;\n\n                heap[i] = heap[a];\n                i = a;\n            }\n            heap[i] = x;\n            heap.RemoveAt(size);\n            return ret;\n        }\n\n        private int Compare(T x, T y)\n        {\n            return y.CompareTo(x);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, counts;\n        int sx, sy, minCnt;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            counts = new int[h, w];\n        }\n\n        public int Solve()\n        {\n            MakeMap();\n            minCnt = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                counts[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nextX = cur.x + moveX[i];\n                    int nextY = cur.y + moveY[i];\n\n                    if (IsValid(nextX, nextY))\n                    {\n                        if (counts[nextY, nextX] <= cur.cnt) continue;\n\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[nextY, nextX]);\n\n                        if (tempCnt < minCnt) stk.Push(new State(nextX, nextY, tempCnt));\n                    }\n                    else minCnt = Math.Min(minCnt, cur.cnt);\n                }\n            }\n            return minCnt;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0 || x >= w) return false;\n            if (y < 0 || y >= h) return false;\n            return true;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    counts[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct State\n    {\n        internal int x, y, cnt;\n\n        public State(int x, int y, int cnt)\n        {\n            this.x = x;\n            this.y = y;\n            this.cnt = cnt;\n        }\n    }\n\n    class Problem\n    {\n        readonly int[] moveX = new int[] { -1, 0, 1, 0 };\n        readonly int[] moveY = new int[] { 0, -1, 0, 1 };\n        readonly int INF = 1 << 20;\n        readonly int w, h;\n\n        int[,] map, memo;\n        int sx, sy;\n\n        public Problem(int w, int h)\n        {\n            this.w = w;\n            this.h = h;\n            map = new int[h, w];\n            memo = new int[h, w];\n            MakeMap();\n        }\n\n        public int Solve()\n        {\n            int ret = INF;\n\n            Stack<State> stk = new Stack<State>();\n            stk.Push(new State(sx, sy, 0));\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n                memo[cur.y, cur.x] = cur.cnt;\n\n                for (int i = 0; i < 4; i++)\n                {\n                    int nx = cur.x + moveX[i];\n                    int ny = cur.y + moveY[i];\n\n                    if (IsValid(nx, ny))\n                    {\n                        int tempCnt = cur.cnt + (map[cur.y, cur.x] == 1 ? 0 : map[ny, nx]);\n\n                        if (tempCnt < memo[ny, nx] && tempCnt < ret)\n                        {\n                            stk.Push(new State(nx, ny, tempCnt));\n                        }\n                    }\n                    else ret = Math.Min(ret, cur.cnt);\n                }\n            }\n            return ret;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x >= 0 && x < w && y >= 0 && y < h) return true;\n            return false;\n        }\n\n        private void MakeMap()\n        {\n            for (int i = 0; i < h; i++)\n            {\n                string input = Console.ReadLine();\n\n                for (int j = 0; j < w; j++)\n                {\n                    switch (input[j])\n                    {\n                        case '#':\n                            map[i, j] = 1;\n                            break;\n                        case '&':\n                            sx = j;\n                            sy = i;\n                            break;\n                    }\n                    memo[i, j] = INF;\n                }\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                int w = int.Parse(input[0]);\n                int h = int.Parse(input[1]);\n\n                if (w == 0 && h == 0) break;\n\n                Problem pb = new Problem(w, h);\n                sb.AppendLine(pb.Solve().ToString());\n            }\n            Console.Write(sb);\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "## constant\n\nMAX_DIST = 1 << 30\n\n### subroutines\n\ndef paint(x, y, n, m, chmap, armap, aid)\n  ch = chmap[y][x]\n  area = [aid, ch, false]\n  armap[y][x] = area\n\n  queue = [[x, y]]\n  while ! queue.empty?\n    x0, y0 = queue.shift\n    cands = []\n    if x0 > 0\n      cands << [x0 - 1, y0]\n    else\n      area[2] = true\n    end\n    if x0 < n - 1\n      cands << [x0 + 1, y0]\n    else\n      area[2] = true\n    end\n    if y0 > 0\n      cands << [x0, y0 - 1]\n    else\n      area[2] = true\n    end\n    if y0 < m - 1\n      cands << [x0, y0 + 1]\n    else\n      area[2] = true\n    end\n\n    for c in cands\n      nx, ny = c\n      if armap[ny][nx].nil? && chmap[ny][nx] == ch\n        armap[ny][nx] = area\n        queue << [nx, ny]\n      end\n    end\n  end\n\n  area\nend\n\ndef gen_areas(n, m, chmap, armap)\n  areas = []\n  aid = 0\n\n  for y in (0...m)\n    for x in (0...n)\n      if armap[y][x].nil?\n        area = paint(x, y, n, m, chmap, armap, aid)\n        areas << area\n        aid += 1\n      end\n    end\n  end\n\n  areas\nend\n\ndef gen_nbrs(n, m, armap, areas)\n  nbrs = (0...areas.length).map{[]}\n\n  for y in (0...m)\n    for x in (0...n)\n      aid, ach = armap[y][x]\n      cands = []\n      cands << armap[y][x - 1] if x > 0\n      cands << armap[y][x + 1] if x < n - 1\n      cands << armap[y - 1][x] if y > 0\n      cands << armap[y + 1][x] if y < m - 1\n\n      for ar0 in cands\n        nbrs[aid] << ar0[0] if ! nbrs[aid].include? ar0[0]\n      end\n    end\n  end\n\n  nbrs\nend\n\n### main\n\nwhile true\n  n, m = gets.strip.split(' ').map{|s| s.to_i}\n  break if n == 0 && m == 0\n\n  chmap = []\n  armap = []\n\n  m.times.each do\n    hl = gets.strip\n    chmap << hl\n    armap << ([nil] * n)\n  end\n\n  areas = gen_areas(n, m, chmap, armap)\n  an = areas.length\n  nbrs = gen_nbrs(n, m, armap, areas)\n\n  st = nil\n  for area in areas\n    if area[1] == '&'\n      st = area[0]\n      break\n    end\n  end\n\n  dist = areas.map{MAX_DIST}\n  dist[st] = 0\n  prev = areas.map{nil}\n  queue = areas.map{|ar| ar[0]}\n\n  while ! queue.empty?\n    u = queue.min{|a, b| dist[a] <=> dist[b]}\n    queue.delete u\n\n    for v in nbrs[u]\n      ndist = dist[u] + ((areas[v][1] == '#') ? 2 : 1)\n      if dist[v] > ndist\n        dist[v] = ndist\n        prev[v] = u\n      end\n    end\n  end\n\n  gl = (0...an).select{|i| areas[i][2]}.min{|a, b| dist[a] <=> dist[b]}\n\n  count = 0\n  v = gl\n  while v != st\n    if areas[v][1] == '#'\n      count += 1\n    end\n    v = prev[v]\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=gets.split.map &:to_i)[0]>0\na=(b=[?.*(n+2)])+(1..m).map{?.+gets.tr(?\\n,?.)}+b\nq=[[c=0,0]]\nr=[]\n(q[0]||(q=r.uniq;r=[];c+=1)\nx,y=q.shift\n[[x,y+1],[x,y-1],[x+1,y],[x-1,y]].map{|i,j|d=a[i][j];d==?.?(a[i][j]=?a;q<<[i,j]):d==?#?(r<<[i,j]):d==?&?(q=r=[];break):0})while q[0]||r[0]\np c\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_DIST = 1 << 30\n\n### subroutines\n\ndef paint(x, y, n, m, chmap, armap, aid)\n  ch = chmap[y][x]\n  area = [aid, ch, false]\n  armap[y][x] = area\n\n  queue = [[x, y]]\n  while ! queue.empty?\n    x0, y0 = queue.shift\n    cands = []\n    if x0 > 0\n      cands << [x0 - 1, y0]\n    else\n      area[2] = true\n    end\n    if x0 < n - 1\n      cands << [x0 + 1, y0]\n    else\n      area[2] = true\n    end\n    if y0 > 0\n      cands << [x0, y0 - 1]\n    else\n      area[2] = true\n    end\n    if y0 < m - 1\n      cands << [x0, y0 + 1]\n    else\n      area[2] = true\n    end\n\n    for c in cands\n      nx, ny = c\n      if armap[ny][nx].nil? && chmap[ny][nx] == ch\n        armap[ny][nx] = area\n        queue << [nx, ny]\n      end\n    end\n  end\n\n  area\nend\n\ndef gen_areas(n, m, chmap, armap)\n  areas = []\n  aid = 0\n\n  for y in (0...m)\n    for x in (0...n)\n      if armap[y][x].nil?\n        area = paint(x, y, n, m, chmap, armap, aid)\n        areas << area\n        aid += 1\n      end\n    end\n  end\n\n  areas\nend\n\ndef gen_nbrs(n, m, armap, areas)\n  nbrs = (0...areas.length).map{[]}\n\n  for y in (0...m)\n    for x in (0...n)\n      aid, ach = armap[y][x]\n      cands = []\n      cands << armap[y][x - 1] if x > 0\n      cands << armap[y][x + 1] if x < n - 1\n      cands << armap[y - 1][x] if y > 0\n      cands << armap[y + 1][x] if y < m - 1\n\n      for ar0 in cands\n        nbrs[aid] << ar0[0] if ! nbrs[aid].include? ar0[0]\n      end\n    end\n  end\n\n  nbrs\nend\n\n### main\n\nwhile true\n  n, m = gets.strip.split(' ').map{|s| s.to_i}\n  break if n == 0 && m == 0\n\n  chmap = []\n  armap = []\n\n  m.times.each do\n    hl = gets.strip\n    chmap << hl\n    armap << ([nil] * n)\n  end\n\n  areas = gen_areas(n, m, chmap, armap)\n  an = areas.length\n  nbrs = gen_nbrs(n, m, armap, areas)\n\n  edges = an.times.map{an.times.map{nil}}\n  for i in (0...an)\n    for j in nbrs[i]\n      edges[i][j] = (areas[j][1] == '#') ? 2 : 1\n    end\n  end\n\n  st = nil\n  for area in areas\n    if area[1] == '&'\n      st = area[0]\n      break\n    end\n  end\n\n  dist = areas.map{MAX_DIST}\n  dist[st] = 0\n  prev = areas.map{nil}\n  queue = areas.map{|ar| ar[0]}\n\n  while ! queue.empty?\n    u = queue.min{|a, b| dist[a] <=> dist[b]}\n    queue.delete u\n\n    for v in nbrs[u]\n      ndist = dist[u] + edges[u][v]\n      if dist[v] > ndist\n        dist[v] = ndist\n        prev[v] = u\n      end\n    end\n  end\n\n  gl = (0...an).select{|i| areas[i][2]}.min{|a, b| dist[a] <=> dist[b]}\n\n  count = 0\n  i = gl\n  while i != st\n    if areas[i][1] == '#'\n      count += 1\n    end\n    i = prev[i]\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=gets.split.map &:to_i)[0]>0\na=(b=[?.*(n+2)])+(1..m).map{?.+gets.tr(?\\n,?.)}+b\nq=[[c=0,0]]\nr=[]\n(q[0]||(q=r.uniq;r=[];c+=1;puts a)\nx,y=q.shift\n[[x,y+1],[x,y-1],[x+1,y],[x-1,y]].map{|i,j|d=a[i][j]\nd==?.?(a[i][j]=?-;q<<[i,j]):\nd==?#?(a[i][j]=?o;r<<[i,j]):\nd==?&?(q=r=[];break):0})while q[0]||r[0]\np c\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=gets.split.map &:to_i)[0]>0\na=(b=[?.*(n+2)])+(1..m).map{?.+gets.tr(?\\n,?.)}+b\nq=[[c=0,0]]\nr=[]\n(q[0]||(q=r;r=[];c+=1)\nx,y=q.shift\n[[x,y+1],[x,y-1],[x+1,y],[x-1,y]].map{|i,j|d=a[i][j];d==?.?(a[i][j]=?a;q<<[i,j]):d==?#?(r<<[i,j]):d==?&?(q=r=[];break):0})while q[0]||r[0]\np c\nend"
  },
  {
    "language": "Ruby",
    "code": "def f(field, n, m, level=0)\n  field[0][0] = \"#\"\n  que = [[0,0]]\n  until que.empty?\n    y, x = que.shift\n    [[-1,0],[1,0],[0,-1],[0,1]].each{|dy,dx|\n      ny, nx = y+dy, x+dx\n      if ny>=0 && ny<=m+1 && nx>=0 && nx<=n+1\n        return level if field[ny][nx]==\"&\"\n        if field[ny][nx]==\".\"\n          field[ny][nx] = \"#\"\n          que << [ny,nx]\n        end\n      end\n    }\n  end\n  field[0][0] = \".\"\n  que = [[0,0]]\n  until que.empty?\n    y, x = que.shift\n    [[-1,0],[1,0],[0,-1],[0,1]].each{|dy,dx|\n      ny, nx = y+dy, x+dx\n      if ny>=0 && ny<=m+1 && nx>=0 && nx<=n+1\n        if field[ny][nx]==\"#\"\n          field[ny][nx] = \".\"\n          que << [ny,nx]\n        end\n      end\n    }\n  end\n  f(field, n, m, level+1)\nend\n\nrequire \"pp\"\n\nloop{\n  n, m = gets.split.map(&:to_i)\n  break if n==0 and m==0\n  field = [\".\"*(n+2)] + m.times.map{\".\" + gets.chomp + \".\"} + [\".\"*(n+2)]\n  puts f(field, n, m)\n}\n"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=gets.split.map &:to_i)[0]>0\na=(1..m).map{gets.tr ?\\n,?.}<<?.*n*2\nq=[[c=-1]*2]\nr=[]\n(x,y=q.shift\n[[x,y+1],[x,y-1],[x+1,y],[x-1,y]].map{|i,j|i=(i+t=m+1)%t;j=(j+u=n+1)%u\nd=a[i][j]\nd==?.?(a[i][j]=?-;q<<[i,j]):d==?#?(a[i][j]=?o;r<<[i,j]):d==?&?(q=r=[];break):0})while q[0]||(q=r.uniq;c+=1;r=[];q)[0]\np c\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n,m=l=gets.split.map(&:to_i))[0]>c=0\na=(1..m).map{gets.tr ?\\n,?.}<<?.*n*2\nq=[l]\nr=[]\n(x,y=q.shift\n[[x,y+1],[x,y-1],[x+1,y],[x-1,y]].map{|i,j|i%=n+1;j%=m+1\nd=a[j][i]\nk=\".#\".index d\nk&&(a[j][i]=?a;[q,r][k-c%2]<<[i,j])\nd==?&&&(q=r=[];break)})while q[0]||(q,r=r.uniq,[];c+=1;q)[0]\np c/2\nend"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nbool canGoal(bool[][] checked, ref char[][] c, int x, int y) {\n    if(checked[x][y]) {\n        return false;\n    }\n    checked[x][y] = true;\n    if(x == 0 || y == 0 || x == c.length-1 || y == c[0].length-1) {\n        return true;\n    }\n\n    auto dx = [1, 0, -1, 0];\n    auto dy = [0, 1, 0, -1];\n    foreach(i; iota(4)) {\n        auto nx = x + dx[i];\n        auto ny = y + dy[i];\n        if(c[nx][ny] == '#') {\n            continue;\n        }\n        if(canGoal(checked, c, nx, ny)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid goOver(ref char[][] c, int x, int y) {\n    auto dx = [1, 0, -1, 0];\n    auto dy = [0, 1, 0, -1];\n\n    c[x][y] = 'g';\n\n    void fill(int x, int y) {\n        if(c[x][y] != '#') {\n            return;\n        }\n\n        c[x][y] = 'g';\n\n        foreach(i; iota(4)) {\n            auto nx = x + dx[i];\n            auto ny = y + dy[i];\n            if(nx < 0 || ny < 0 || nx >= c.length || ny >= c[0].length) {\n                continue;\n            }\n            fill(nx, ny);\n        }\n    }\n\n    foreach(i; iota(4)) {\n        auto nx = x + dx[i];\n        auto ny = y + dy[i];\n        if(nx < 0 || ny < 0 || nx >= c.length || ny >= c[0].length) {\n            continue;\n        }\n        if(c[nx][ny] == '#') {\n            fill(nx, ny);\n        }\n        if(c[nx][ny] == '.') {\n            goOver(c, nx, ny);\n        }\n    }\n}\n\nvoid recover(ref char[][] c) {\n    foreach(ref ci; c) {\n        foreach(ref cii; ci) {\n            if(cii == 'g') {\n                cii = '.';\n            }\n        }\n    }\n}\n\nvoid main(){\n    while(true) {\n        int n, m;\n        readlnTo(n, m);\n        if(n == 0) {\n            return;\n        }\n        char[][] c;\n        foreach(i; iota(m)) {\n            c ~= readln().chomp().to!(char[]);\n        }\n        int sx, sy;\n        foreach(i; iota(m)) {\n            foreach(j; iota(n)) {\n                if(c[i][j] == '&') {\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n        int ans;\n        while(!canGoal(new bool[][](m, n), c, sx, sy)){\n            ++ans;\n            goOver(c, sx, sy);\n            recover(c);\n        }\n        writeln(ans);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm;\n\nstruct Point {int x, y;}\n\nstring[111] s;\nPoint[] q;\nint[] dx = [0, 1, 0, -1];\nint[] dy = [-1, 0, 1, 0];\nint[111][111] cost; \n\nvoid main(){\n\tPoint p;\n\tint n, m, tx, ty, newCost, ans;\n\twhile (readf(\"%d %d\\n\", &n, &m), n || m) {\n\t\tforeach (y; 0..m) {\n\t\t\ts[y] = readln.chomp;\n\t\t\tcost[y] = 999999;\n\t\t\tforeach (x; 0..n) if (s[y][x] == '&') p = Point(x, y);\n\t\t}\n\n\t\tcost[p.y][p.x] = 0;\n\t\tq ~= p;\n\t\twhile (!q.empty) {\n\t\t\tp = q.front; q.popFront();\n\t\t\tforeach (i; 0..4) {\n\t\t\t\ttx = dx[i] + p.x;\n\t\t\t\tty = dy[i] + p.y;\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;\n\t\t\t\tnewCost = cost[p.y][p.x] + (s[ty][tx] == '#' ? 1 : 0);\n\t\t\t\tif (cost[ty][tx] > newCost){\n\t\t\t\t\tcost[ty][tx] = newCost;\n\t\t\t\t\tq ~= Point(tx, ty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 999999;\n\t\tforeach (x; 0..n) foreach (i; [0, m-1]) if (s[i][x] != '#') ans = min(ans, cost[i][x]);\n\t\tforeach (y; 0..m) foreach (i; [0, n-1]) if (s[y][i] != '#') ans = min(ans, cost[y][i]);\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.array;\n\nstruct Point {int x,y;}\n\nstring[111] s;\nPoint[] q;\nint[] dx = [0, 1, 0, -1];\nint[] dy = [-1, 0, 1, 0];\nint[111][111] cost; \n\nvoid main(){\n\tPoint p;\n\tint n, m, sx, sy, tx, ty, newCost;\n\twhile (readf(\"%d %d\\n\", &n, &m), n + m > 0) {\n\t\tn += 2;\n\t\tm += 2;\n\t\ts[0] = s[m-1] = [];\n\t\tforeach (x; 0..n) s[0] ~= '.';\n\t\ts[m-1] = s[0];\n\t\tcost[0] = cost[m-1] = 99999999;\n\t\tforeach (y; 1..m-1) {\n\t\t\ts[y] = '.' ~ readln.chomp ~ '.';\n\t\t\tcost[y] = 99999999;\n\t\t\tforeach (x; 1..n-1) {\n\t\t\t\tif (s[y][x] == '&') {\n\t\t\t\t\tsx = x;\n\t\t\t\t\tsy = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// solve by BFS\n\t\tcost[sy][sx] = 0;\n\t\tq ~= Point(sx, sy);\n\t\twhile (!q.empty) {\n\t\t\tp = q.front;\n\t\t\tq.popFront();\n\t\t\tforeach (i; 0..4) {\n\t\t\t\ttx = dx[i] + p.x;\n\t\t\t\tty = dy[i] + p.y;\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;\n\t\t\t\tnewCost = cost[p.y][p.x] + (s[ty][tx] == '#' ? 1 : 0);\n\t\t\t\tif (cost[ty][tx] > newCost){\n\t\t\t\t\tcost[ty][tx] = newCost;\n\t\t\t\t\tq ~= Point(tx, ty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(cost[0][0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm;\n\nstruct Point {int x, y;}\n\nstring[111] s;\nPoint[] q;\nint[] dx = [0, 1, 0, -1];\nint[] dy = [-1, 0, 1, 0];\nint[111][111] cost; \n\nvoid main(){\n\tPoint p;\n\tint n, m, tx, ty, newCost, ans;\n\twhile (readf(\"%d %d\\n\", &n, &m), n || m) {\n\t\tforeach (y; 0..m) {\n\t\t\ts[y] = readln.chomp;\n\t\t\tcost[y] = 999999;\n\t\t\tforeach (x; 0..n) if (s[y][x] == '&') p = Point(x, y);\n\t\t}\n\n\t\tcost[p.y][p.x] = 0;\n\t\tq ~= p;\n\t\twhile (!q.empty) {\n\t\t\tp = q.front; q.popFront();\n\t\t\tforeach (i; 0..4) {\n\t\t\t\ttx = dx[i] + p.x;\n\t\t\t\tty = dy[i] + p.y;\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;\n\t\t\t\tnewCost = cost[p.y][p.x] + (s[ty][tx] == '#' ? 1 : 0);\n\t\t\t\tif (cost[ty][tx] > newCost){\n\t\t\t\t\tcost[ty][tx] = newCost;\n\t\t\t\t\tq ~= Point(tx, ty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 999999;\n\t\tforeach (x; 0..n) foreach (i; [0, m-1]) if (s[i][x] == '.') ans = min(ans, cost[i][x]);\n\t\tforeach (y; 0..m) foreach (i; [0, n-1]) if (s[y][i] == '.') ans = min(ans, cost[y][i]);\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm;\n\nstruct Point {int x, y;}\n\nstring[111] s;\nPoint[] q;\nint[] dx = [0, 1, 0, -1];\nint[] dy = [-1, 0, 1, 0];\nint[111][111] cost; \n\nvoid main(){\n\tPoint p;\n\tint n, m, tx, ty, newCost, ans;\n\twhile (readf(\"%d %d\\n\", &n, &m), n + m > 0) {\n\t\tforeach (y; 0..m) {\n\t\t\ts[y] = readln.chomp;\n\t\t\tcost[y] = 99999999;\n\t\t\tforeach (x; 0..n) {\n\t\t\t\tif (s[y][x] == '&') {\n\t\t\t\t\ttx = x;\n\t\t\t\t\tty = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[ty][tx] = 0;\n\t\tq ~= Point(tx, ty);\n\t\twhile (!q.empty) {\n\t\t\tp = q.front;\n\t\t\tq.popFront();\n\t\t\tforeach (i; 0..4) {\n\t\t\t\ttx = dx[i] + p.x;\n\t\t\t\tty = dy[i] + p.y;\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;\n\t\t\t\tnewCost = cost[p.y][p.x] + (s[ty][tx] == '#' ? 1 : 0);\n\t\t\t\tif (cost[ty][tx] > newCost){\n\t\t\t\t\tcost[ty][tx] = newCost;\n\t\t\t\t\tq ~= Point(tx, ty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 9999999;\n\t\tforeach (y; 0..m) ans = min(ans, min(cost[y][0], cost[y][n-1]));\n\t\tforeach (x; 0..n) ans = min(ans, min(cost[0][x], cost[m-1][x]));\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.array, std.algorithm;\n\nstruct Point {int x,y;}\n\nstring[111] s;\nPoint[] q;\nint[] dx = [0, 1, 0, -1];\nint[] dy = [-1, 0, 1, 0];\nint[111][111] cost; \n\nvoid main(){\n\tPoint p;\n\tint n, m, tx, ty, newCost, ans;\n\twhile (readf(\"%d %d\\n\", &n, &m), n || m) {\n\t\tforeach (y; 0..m) {\n\t\t\ts[y] = readln.chomp;\n\t\t\tcost[y] = 999999;\n\t\t\tforeach (x; 0..n) if (s[y][x] == '&') p = Point(x, y);\n\t\t}\n\t\t// solve by BFS\n\t\tcost[p.y][p.x] = 0;\n\t\tq ~= p;\n\t\twhile (!q.empty) {\n\t\t\tp = q.front; q.popFront();\n\t\t\tforeach (i; 0..4) {\n\t\t\t\ttx = dx[i] + p.x;\n\t\t\t\tty = dy[i] + p.y;\n\t\t\t\tif (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;\n\t\t\t\tnewCost = cost[p.y][p.x] + ((s[ty][tx] == '#' && s[p.y][p.x] != '#')  ? 1 : 0);\n\t\t\t\tif (cost[ty][tx] > newCost){\n\t\t\t\t\tcost[ty][tx] = newCost;\n\t\t\t\t\tq ~= Point(tx, ty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 999999;\n\t\tforeach (x; 0..n) foreach (i; [0, m-1]) ans = min(ans, cost[i][x]);\n\t\tforeach (y; 0..m) foreach (i; [0, n-1]) ans = min(ans, cost[y][i]);\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom itertools import product\n\ndef solve():\n    hq = [(0, y, x) for y, x in product(xrange(m), xrange(n)) \n          if not(0 < y < m - 1 and 0 < x < n - 1)]\n    heapify(hq)\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        if field[cy][cx] == \"&\":\n            return cost\n        if memo[cy][cx] <= cost:\n            continue\n        memo[cy][cx] = cost\n        for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < m and 0 <= nx < n:\n                if field[ny][nx] == \".\" and field[cy][cx] == \"#\":\n                    heappush(hq, (cost + 1, ny, nx))\n                else:\n                    heappush(hq, (cost, ny, nx))\n    return None\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n | m == 0:\n        break\n    memo = [[1 << 20] * n for _ in xrange(m)]\n    field = [raw_input() for _ in xrange(m)]    \n    print solve()"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[m][i] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (i, 1)))\n    heappush(que, (c2, s2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (1, i)))\n    heappush(que, (c2, s2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  \"\"\"\n  到達コストの低い順で、堀の中にいるものを優先に幅優先探索\n  \"\"\"\n  while que and not reached:\n    cost, status, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        sym = mp[newy][newx]\n        if sym == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif sym == \"#\":\n          if status == 1:\n            heappush(que, (cost + 1, 0, (newx, newy)))\n          else:\n            heappush(que, (cost, 0, (newx, newy)))\n        elif sym == \".\":\n          heappush(que,(cost, 1, (newx, newy)))\n"
  },
  {
    "language": "Python",
    "code": "def ReadMap(n, m):\n  Map = [0] * m\n  for i in range(m):\n    a = raw_input()\n    b = list(a)\n    if a.count('&')>0:\n      j = a.index('&')\n      PosCas = [j, i]\n      b[j] = '.'\n    Map[i] = b\n  return Map, PosCas\n\ndef fill(SP, c1, c2):\n  for x, y in SP:\n    try:\n      if Map[y][x] != c1: continue\n    except: continue\n    if x in [0, n-1] or y in [0, m-1]: return 1\n    Map[y][x] = c2\n    SP += [[x+1, y], [x-1, y], [x, y+1], [x, y-1]]\n  return 0\n\nwhile 1:\n  n, m = map(int, raw_input().split())\n  if n == m == 0: break\n  Map, PosCas = ReadMap(n, m)\n  c = 0\n  while 1:\n    SP = [PosCas]\n    if fill(SP, '.', '#'): break\n    c += 1\n    if fill(SP, '#', '.'): break\n  print c"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[1][i] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[m][i] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (i, 1)))\n    heappush(que, (c2, s2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1, s1 = (1, 0) if mp[i][1] == \"#\" else (0, 1)\n    c2, s2 = (1, 0) if mp[i][n] == \"#\" else (0, 1)\n    heappush(que, (c1, s1, (1, i)))\n    heappush(que, (c2, s2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, status, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif mp[newy][newx] == \"#\":\n          if status == 1:\n            heappush(que, (cost + 1, 0, (newx, newy)))\n          else:\n            heappush(que, (cost, 0, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que,(cost, 1, (newx, newy)))\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom itertools import product\n\ndef solve():\n    hq = [(0, y, x) for y, x in product(xrange(m), xrange(n)) \n          if not(0 < y < m - 1 and 0 < x < n - 1)]\n    heapify(hq)\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        if field[cy][cx] == \"&\":\n            return cost\n        if memo[cy][cx] <= cost:\n            continue\n        memo[cy][cx] = cost\n        for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < m and 0 <= nx < n:\n                if field[ny][nx] != \"#\" and field[cy][cx] == \"#\": \n                    heappush(hq, (cost + 1, ny, nx))\n                else:\n                    heappush(hq, (cost, ny, nx))\n    return None\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n | m == 0:\n        break\n    memo = [[1 << 20] * n for _ in xrange(m)]\n    field = [raw_input() for _ in xrange(m)]    \n    print solve()"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  for i in range(1, n + 1):\n    c1 = 1 if mp[1][i] == \"#\" else 0\n    c2 = 1 if mp[m][i] == \"#\" else 0\n    heappush(que, (c1, (i, 1)))\n    heappush(que, (c2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  for i in range(1, m + 1):\n    c1 = 1 if mp[i][1] == \"#\" else 0\n    c2 = 1 if mp[i][n] == \"#\" else 0\n    heappush(que, (c1, (1, i)))\n    heappush(que, (c2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        if mp[newy][newx] == \"#\":\n          heappush(que, (cost + 1, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que, (cost, (newx, newy)))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0156\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\n\ndef bfs(field, sx, sy, d=None, q=[]):\n    \"\"\"\n    ??????????????°???????????°??????????????§??????????????????\n    :param field:\n    :param sx: ??????????????°????????§?¨?\n    :param sy:\n    :return: ????????????????????´???????????§????????¢\n    \"\"\"\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    if d == None:\n        d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    moats = set()                   # ????????§???????????????????????§?¨?\n\n    # ???????????????????????????????????°???????????´????????°????????§????????¢????±???????\n    Q = deque()\n    if q == []:\n        Q.append((sx, sy))\n        d[sy][sx] = 0               #  ??????????????°??????????????????0\n    else:\n        Q.extend(q)\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y):\n                return True, moats, d\n            elif d[ny][nx] == float('inf'):\n                if field[ny][nx] == '#':\n                    moats.add((nx, ny))\n                else:\n                    Q.append((nx, ny))\n                    d[ny][nx] = d[cy][cx] + 1\n    return False, moats, d\n\n\ndef fill_moat(field, moats):\n    # ??¢??\\???????????¨????????????????????£??????????????????'^'??§?????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n\n    while moats:\n        cx, cy = moats.pop()        #  ?????¨??°?????§?¨?\n        field[cy][cx] = '^'\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if (0 <= nx < X) and (0 <= ny < Y):\n                if field[ny][nx] == '#':\n                    moats.add((nx, ny))\n\n\ndef solve(field):\n    # ??????????????°???(????????£: &)?????????\n    start = (0, 0)\n    for y, row in enumerate(field):\n        if '&' in row:\n            start = (row.index('&'), y)\n\n    sx, sy = start\n    climb = 0                   #  ???????????????????????° = ??????????????????????????°\n    d = None\n    q = []\n    while True:\n        res, moats, d = bfs(field, sx, sy, d, q) #  ????????£????????°?????????????????????????¢????\n        q = list(moats)\n        if res is False:\n            climb += 1\n            fill_moat(field, moats) #  ??¢??\\?????????????????????\n        else:\n            break\n    return climb\n\n\ndef main(args):\n    while True:\n        n, m = map(int, input().split())\n        if n == 0 and m == 0:\n            break\n\n#        data = [\n#         '.###.',\n#         '#...#',\n#         '#.&.#',\n#         '#...#',\n#         '.###.'\n#        ]\n\n        data = [input().strip('\\n') for _ in range(m)]\n        field = [list(x) for x in data] #  data????????????????????????????????????????????????\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  for i in range(1, n + 1):\n    c1 = 1 if mp[1][i] == \"#\" else 0\n    c2 = 1 if mp[m][i] == \"#\" else 0\n    heappush(que, (c1, (i, 1)))\n    heappush(que, (c2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  for i in range(1, m + 1):\n    c1 = 1 if mp[i][1] == \"#\" else 0\n    c2 = 1 if mp[i][n] == \"#\" else 0\n    heappush(que, (c1, (1, i)))\n    heappush(que, (c2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, point = heappop(que)\n    x, y = point\n    if mp[y][x] == \"&\":\n      print(cost)\n      break\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        if mp[newy][newx] == \"#\":\n          heappush(que, (cost + 1, (newx, newy)))\n        elif mp[newy][newx] == \".\":\n          heappush(que, (cost, (newx, newy)))\n"
  },
  {
    "language": "Python",
    "code": "def ReadMap(n, m):\n  Map = {}\n  for i in range(m):\n    a = raw_input()\n    b = list(a)\n    if a.count('&')>0:\n      j = a.index('&')\n      PosCas = [j, i]\n      b[j] = '.'\n    Map[i] = b\n  return Map, PosCas\n\ndef fill(SP, c1, c2):\n  for x, y in SP:\n    try:\n      if Map[y][x] != c1: continue\n    except: continue\n    if x in [0, n-1] or y in [0, m-1]: return 1\n    Map[y][x] = c2\n    SP += [[x+1, y], [x-1, y], [x, y+1], [x, y-1]]\n  return 0\n\nwhile 1:\n  n, m = map(int, raw_input().split())\n  if n == m == 0: break\n  Map, PosCas = ReadMap(n, m)\n  c = 0\n  while 1:\n    SP = [PosCas]\n    if fill(SP, '.', '#'): break\n    c += 1\n    if fill(SP, '#', '.'): break\n  print c"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0156\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\n\ndef bfs(field, sx, sy):\n    \"\"\"\n    ??????????????°???????????°??????????????§??????????????????\n    :param field:\n    :param sx: ??????????????°????????§?¨?\n    :param sy:\n    :return: ????????????????????´???????????§????????¢\n    \"\"\"\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    moats = set()                   # ????????§???????????????????????§?¨?\n\n    # ???????????????????????????????????°???????????´????????°????????§????????¢????±???????\n    Q = deque()\n    Q.append((sx, sy))\n    d[sy][sx] = 0               #  ??????????????°??????????????????0\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y):\n                return True, moats\n            elif d[ny][nx] == float('inf'):\n                if field[ny][nx] == '#':\n                    moats.add((nx, ny))\n                else:\n                    Q.append((nx, ny))\n                    d[ny][nx] = d[cy][cx] + 1\n    return False, moats\n\n\ndef fill_moat(field, moats):\n    # ??¢??\\???????????¨????????????????????£??????????????????'^'??§?????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    # d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n\n    while moats:\n        cx, cy = moats.pop()        #  ?????¨??°?????§?¨?\n        field[cy][cx] = '^'\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if (0 <= nx < X) and (0 <= ny < Y):\n                if field[ny][nx] == '#':\n                    moats.add((nx, ny))\n                    # d[ny][nx] = d[cy][cx] + 1\n\n\ndef solve(field):\n    # ??????????????°???(????????£: &)?????????\n    start = (0, 0)\n    for y, row in enumerate(field):\n        if '&' in row:\n            start = (row.index('&'), y)\n\n    sx, sy = start\n    climb = 0                   #  ???????????????????????° = ??????????????????????????°\n    while True:\n        res, moats = bfs(field, sx, sy) #  ????????£????????°?????????????????????????¢????\n        if res is False:\n            climb += 1\n            fill_moat(field, moats) #  ??¢??\\?????????????????????\n        else:\n            break\n    return climb\n\n\ndef main(args):\n    while True:\n        n, m = map(int, input().split())\n        if n == 0 and m == 0:\n            break\n\n#        data = [\n#         '.###.',\n#         '#...#',\n#         '#.&.#',\n#         '#...#',\n#         '.###.'\n#        ]\n\n        data = [input().strip('\\n') for _ in range(m)]\n        field = [list(x) for x in data] #  data????????????????????????????????????????????????\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom itertools import product\n\ndef solve():\n    hq = [(0, y, x) for y, x in product(xrange(m), xrange(n)) \n          if not(0 < y < m - 1 and 0 < x < n - 1)]\n    heapify(hq)\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        if field[cy][cx] == \"&\":\n            return cost\n        if memo[cy][cx] <= cost:\n            continue\n        memo[cy][cx] = cost\n        for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < m and 0 <= nx < n:\n                if field[ny][nx] != \"#\" and field[cy][cx] == \"#\": \n                    heappush(hq, (cost + 1, ny, nx))\n                else:\n                    heappush(hq, (cost, ny, nx))\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n | m == 0:\n        break\n    memo = [[1 << 20] * n for _ in xrange(m)]\n    field = [raw_input() for _ in xrange(m)]    \n    print solve()"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom itertools import product\n\ndef solve():\n    hq = [(0, y, x) for y, x in product(xrange(m), xrange(n)) \n          if not(0 < y < m - 1 and 0 < x < n - 1)]\n    heapify(hq)\n    while True:\n        cost, cy, cx = heappop(hq)\n        if field[cy][cx] == \"&\":\n            return cost\n        if memo[cy][cx] <= cost:\n            continue\n        memo[cy][cx] = cost\n        for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < m and 0 <= nx < n:\n                if field[ny][nx] != \"#\" and field[cy][cx] == \"#\": \n                    heappush(hq, (cost + 1, ny, nx))\n                else:\n                    heappush(hq, (cost, ny, nx))\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n | m == 0:\n        break\n    memo = [[1 << 20] * n for _ in xrange(m)]\n    field = [raw_input() for _ in xrange(m)]    \n    print solve()"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nwhile True:\n  n, m = map(int, input().split())\n  if n == 0: break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(m)]\n  mp.insert(0, \"X\" * (n + 2))\n  mp.append(\"X\" * (n + 2))\n  \n  que = []\n  visited = [[False] * (n + 2) for _ in range(m + 2)]\n  sur_flag = False\n  for i in range(1, n + 1):\n    if mp[1][i] ==\"&\" or mp[m][i] == \"&\":\n      sur_flag = True\n      break\n    c1 = 1 if mp[1][i] == \"#\" else 0\n    c2 = 1 if mp[m][i] == \"#\" else 0\n    heappush(que, (c1, (i, 1)))\n    heappush(que, (c2, (i, m)))\n    visited[1][i] = True\n    visited[m][i] = True\n  \n  for i in range(1, m + 1):\n    if mp[i][1] == \"&\" or mp[i][n] == \"&\":\n      sur_flag = True\n      break\n    c1 = 1 if mp[i][1] == \"#\" else 0\n    c2 = 1 if mp[i][n] == \"#\" else 0\n    heappush(que, (c1, (1, i)))\n    heappush(que, (c2, (n, i)))\n    visited[i][1] = True\n    visited[i][n] = True\n  \n  if sur_flag:\n    print(0)\n    continue\n  \n  direct = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  reached = False\n  \n  while que and not reached:\n    cost, point = heappop(que)\n    x, y = point\n    for dx, dy in direct:\n      newx, newy = x + dx, y + dy\n      if not visited[newy][newx]:\n        visited[newy][newx] = True\n        if mp[newy][newx] == \"&\":\n          print(cost)\n          reached = True\n          break\n        elif mp[newy][newx] == \"#\":\n          heappush(que, (cost + 1, (newx, newy)))\n        elif mp[newy][newx] in (\".\", \"&\"):\n          heappush(que, (cost, (newx, newy)))\n"
  },
  {
    "language": "Python",
    "code": "def ReadMap(n, m):\n  Map = [0] * m\n  for i in range(m):\n    a = raw_input()\n    b = list(a)\n    if a.count('&')>0:\n      j = a.index('&')\n      PosCas = [j, i]\n      b[j] = '.'\n    Map[i] = b\n  return Map, PosCas\n\ndef fill(SP, c1, c2):\n  for x, y in SP:\n    try:\n      if Map[y][x]!=c1:continue\n    except: continue\n    if x in [0, n-1] or y in [0, m-1]:\n      return 1\n    Map[y][x] = c2\n    SP += ([[x+1, y] , [x-1, y], [x, y+1], [x, y-1]])\n    \n  return 0\n\ndef PrintMap():\n  for e in Map:\n    print \"\".join(e)\n  print\n  return\n\nwhile 1:\n  n, m = map(int,raw_input().split())\n  if n == m == 0: break\n  Map, PosCas = ReadMap(n, m)\n  c = 0\n#  PrintMap()\n  while 1:\n    SP = [PosCas]\n    if fill(SP, '.', '#'): break\n#    PrintMap()\n    c += 1\n    if fill(SP, '#', '.'): break\n#    PrintMap()\n  print c"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\nwhile 1:\n    N, M = map(int, input().split())\n    if N == M == 0:\n        break\n    MP = [input() for i in range(M)]\n    cost = [[-1]*N for i in range(M)]\n    cur = 0\n    que = deque()\n    for i in range(M):\n        for j in range(N):\n            if MP[i][j] == '&':\n                que.append((i, j))\n                cost[i][j] = 0\n\n    while que:\n        r, c = que.popleft()\n        s = cost[r][c]\n        a = MP[r][c]\n        for dr, dc in dd:\n            nr = r + dr; nc = c + dc\n            if not 0 <= nr < M or not 0 <= nc < N or cost[nr][nc] != -1:\n                continue\n            b = MP[nr][nc]\n            t = s + (a != '#' and b == '#')\n            cost[nr][nc] = t\n            if s == t:\n                que.appendleft((nr, nc))\n            else:\n                que.append((nr, nc))\n\n    ans = N*M\n    for i in range(M):\n        ans = min(ans, cost[i][0], cost[i][-1])\n    for i in range(N):\n        ans = min(ans, cost[0][i], cost[-1][i])\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def ReadMap(n, m):\n  Map = [0] * m\n  for i in range(m):\n    a = raw_input()\n    b = map(int,list(a.replace('.','0').replace('#','1').replace('&','2')))\n    if a.count('&')>0:\n      j = a.index('&')\n      PosCas = [j, i]\n      b[j] = 0\n    Map[i] = b\n  return Map, PosCas\n\ndef fill(SP, c1, c2):\n  for x, y in SP:\n    try:\n      if Map[y][x]!=c1:continue\n    except: continue\n    if x in [0, n-1] or y in [0, m-1]: return 1\n    Map[y][x] = c2\n    SP += ([[x+1, y] , [x-1, y], [x, y+1], [x, y-1]])\n  return 0\n\nwhile 1:\n  n, m = map(int, raw_input().split())\n  if n == m == 0: break\n  Map, PosCas = ReadMap(n, m)\n  c = 0\n  while 1:\n    SP = [PosCas]\n    if fill(SP, 0, 1): break\n    c += 1\n    if fill(SP, 1, 0): break\n  print c"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0156\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\n\ndef bfs(field, sx, sy):\n    \"\"\"\n    ??????????????°???????????°??????????????§??????????????????\n    :param field:\n    :param sx: ??????????????°????????§?¨?\n    :param sy:\n    :return: ????????????????????´???????????§????????¢\n    \"\"\"\n    # ????????????????§????????????´????????§?¨?????????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n    moats = set()                   # ????????§???????????????????????§?¨?\n\n    # ???????????????????????????????????°???????????´????????°????????§????????¢????±???????\n    Q = deque()\n    Q.append((sx, sy))\n    d[sy][sx] = 0               #  ??????????????°??????????????????0\n    while Q:\n        cx, cy = Q.popleft()        #  ?????¨??°?????§?¨?\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            # ?§?????????? ??°????????????????????????????????? and ?£?????????£???????????? and ??¢?????¢?´¢?????§?????? ??´???\n            if (not 0 <= nx < X) or (not 0 <= ny < Y):\n                return True, moats\n            elif d[ny][nx] == float('inf'):\n                if field[ny][nx] == '#':\n                    moats.add((nx, ny))\n                else:\n                    Q.append((nx, ny))\n                    d[ny][nx] = d[cy][cx] + 1\n    return False, moats\n\n\ndef fill_moat(field, moats):\n    # ??¢??\\???????????¨????????????????????£??????????????????'^'??§?????????\n    dy = [-1, 1, 0, 0]\n    dx = [0, 0, -1, 1]\n    # ??°???????????????(?§????????????£????????????????????????????????§??????????????¨)\n    Y = len(field)\n    X = len(field[0])\n    d = [[float('inf')] * X for _ in range(Y)] #  ??????????????°?????????????????¢???INF??§?????????\n\n    while moats:\n        cx, cy = moats.pop()        #  ?????¨??°?????§?¨?\n        field[cy][cx] = '^'\n        for i in range(4):\n            nx = cx + dx[i]\n            ny = cy + dy[i]\n            if (0 <= nx < X) and (0 <= ny < Y) and d[ny][nx] == float('inf'):\n                if field[ny][nx] == '#':\n                    moats.add((nx, ny))\n                    d[ny][nx] = d[cy][cx] + 1\n\n\ndef solve(field):\n    # ??????????????°???(S)??¨??´????????°???(N)?????????\n    start = (0, 0)\n    for y, row in enumerate(field):\n        if '&' in row:\n            start = (row.index('&'), y)\n\n    sx, sy = start\n    climb = 0\n    while True:\n        res, moats = bfs(field, sx, sy)\n        if res is False:\n            climb += 1\n            fill_moat(field, moats)\n        else:\n            break\n    return climb\n\n\ndef main(args):\n    while True:\n        n, m = map(int, input().split())\n        if n == 0 and m == 0:\n            break\n\n#        data = [\n#         '.###.',\n#         '#...#',\n#         '#.&.#',\n#         '#...#',\n#         '.###.'\n#        ]\n\n        data = [input().strip('\\n') for _ in range(m)]\n        field = [list(x) for x in data] #  data????????????????????????????????????????????????\n        result = solve(field)\n        print(result)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n    "
  },
  {
    "language": "Python",
    "code": "def ReadMap(n, m):\n  Map = [0] * m\n  for i in range(m):\n    a = raw_input()\n    b = list(a)\n    if a.count('&')>0:\n      j = a.index('&')\n      PosCas = [j, i]\n      b[j] = '.'\n    Map[i] = b\n  return Map, PosCas\n\ndef fill(SP, c1, c2):\n  for x, y in SP:\n    if not (0 <= x < n and 0 <= y < m):\n      continue\n    if Map[y][x]!=c1:\n      continue\n    if x in [0, n-1] or y in [0, m-1]:\n      return 1\n    Map[y][x] = c2\n    SP += ([[x+1, y] , [x-1, y], [x, y+1], [x, y-1]])\n  return 0\n\ndef PrintMap():\n  for e in Map:\n    print \"\".join(e)\n  print\n  return\n\nwhile 1:\n  n, m = map(int,raw_input().split())\n  if n == m == 0: break\n  Map, PosCas = ReadMap(n, m)\n  c = 0\n#  PrintMap()\n  while 1:\n    SP = [PosCas]\n    if fill(SP, '.', '#'): break\n#    PrintMap()\n    c += 1\n    if fill(SP, '#', '.'): break\n#    PrintMap()\n  print c"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop, heapify\nfrom itertools import product\n\ndef solve():\n    hq = [(0, y, x) for y, x in product(xrange(m), xrange(n)) \n          if not(0 < y < m - 1 and 0 < x < n - 1)]\n    heapify(hq)\n    while len(hq) != 0:\n        cost, cy, cx = heappop(hq)\n        if field[cy][cx] == \"&\":\n            return cost\n        if memo[cy][cx] <= cost:\n            continue\n        memo[cy][cx] = cost\n        for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            ny, nx = cy + dy, cx + dx\n            if 0 <= ny < m and 0 <= nx < n:\n                if field[ny][nx] == \".\" and field[cy][cx] != \".\":\n                    heappush(hq, (cost + 1, ny, nx))\n                else:\n                    heappush(hq, (cost, ny, nx))\n    return None\n\nwhile True:\n    n, m = map(int, raw_input().split())\n    if n | m == 0:\n        break\n    memo = [[1 << 20] * n for _ in xrange(m)]\n    field = [raw_input() for _ in xrange(m)]    \n    print solve()"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn main(){\n  loop {\n    let nm: Vec<usize> = read_vec();\n    let n = nm[0];\n    let m = nm[1];\n\n    if n == 0 && m == 0 { break; }\n\n    let mut mp: Vec<Vec<char>> = vec![vec!['.'; n+2]; m+2];\n    let mut dv: Vec<Vec<usize>> = vec![vec![10000; n+2]; m+2];\n    \n    let mut si: usize = 0;\n    let mut sj: usize = 0;\n    \n    for i in 1 .. m+1 {\n      let ts: String = read();\n      let tl: Vec<char> = ts.chars().collect();\n      for j in 1 .. n+1 {\n        mp[i][j] = tl[j-1];\n        if mp[i][j] == '&' { si = i; sj = j; }\n      }\n    }\n    \n    dv[si][sj] = 0;\n    \n    let mut que: VecDeque<(usize, usize)> = VecDeque::new();\n    que.push_back((si, sj));\n    \n    let d: Vec<(isize, isize)> = vec![(1,0),(-1, 0), (0, 1), (0, -1)];\n    \n    loop {\n      match que.pop_front() {\n        None => { break; },\n        Some((i, j)) => {\n          for &(di, dj) in &d {\n            let ti = (i as isize) + di;\n            let tj = (j as isize) + dj;\n            if ti < 0 || tj < 0 || ti > (m as isize)+1 || tj > (n as isize)+1 { continue; }\n            let ni: usize = ti as usize;\n            let nj: usize = tj as usize;\n            let tc: usize =  dv[i][j] + if mp[i][j] != '#' && mp[ni][nj] == '#' {1} else {0};\n            if tc < dv[ni][nj] {\n              dv[ni][nj] = tc;\n              que.push_back((ni, nj));\n            }\n          }\n        },\n      }\n    }\n    println!(\"{}\", dv[0][0]);\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n"
  }
]