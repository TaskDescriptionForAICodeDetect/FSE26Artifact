[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point point;\n    int climb;\n} Node;\n\nint W, H;\nchar grid[100][100];\nint dist[100][100];\nPoint start, goal;\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nint min_climbs() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n    \n    Node queue[10000];\n    int front = 0, rear = 0;\n    \n    queue[rear].point = start;\n    queue[rear].climb = 0;\n    rear++;\n    dist[start.y][start.x] = 0;\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        Point p = current.point;\n        \n        if (p.x == goal.x && p.y == goal.y) {\n            return current.climb;\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            \n            if (nx >= 0 && nx < W && ny >= 0 && ny < H) {\n                int new_climb = current.climb;\n                if (grid[ny][nx] == '#') {\n                    new_climb++;\n                }\n                \n                if (new_climb < dist[ny][nx]) {\n                    dist[ny][nx] = new_climb;\n                    Node next;\n                    next.point.x = nx;\n                    next.point.y = ny;\n                    next.climb = new_climb;\n                    queue[rear++] = next;\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &W, &H);\n        if (W == 0 && H == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '&') {\n                    goal.x = j;\n                    goal.y = i;\n                }\n            }\n        }\n        \n        start.x = 0;\n        start.y = 0;\n        \n        int result = min_climbs();\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:32:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class NinjaPath {\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n    \n    public static int findMinMoatCrossings(char[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        \n        // Find start and tower positions\n        int startX = -1, startY = -1, towerX = -1, towerY = -1;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '&') {\n                    towerX = i;\n                    towerY = j;\n                }\n                if (grid[i][j] == '.') {\n                    startX = i;\n                    startY = j;\n                }\n            }\n        }\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{startX, startY, 0});\n        visited[startX][startY] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1], moatCrossings = curr[2];\n            \n            if (x == towerX && y == towerY) {\n                return moatCrossings;\n            }\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                \n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny]) {\n                    if (grid[nx][ny] != '#') {\n                        queue.offer(new int[]{nx, ny, moatCrossings});\n                        visited[nx][ny] = true;\n                    } else {\n                        queue.offer(new int[]{nx, ny, moatCrossings + 1});\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int rows = scanner.nextInt();\n            int cols = scanner.nextInt();\n            \n            if (rows == 0 && cols == 0) break;\n            \n            char[][] grid = new char[rows][cols];\n            scanner.nextLine();\n            \n            for (int i = 0; i < rows; i++) {\n                grid[i] = scanner.nextLine().toCharArray();\n            }\n            \n            int result = findMinMoatCrossings(grid);\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:33:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nstruct Point {\n    int x, y, cost;\n    Point(int x, int y, int c) : x(x), y(y), cost(c) {}\n};\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w || h) {\n        vector<string> grid(h);\n        int start_x = -1, start_y = -1;\n        int end_x = -1, end_y = -1;\n        for (int i = 0; i < h; ++i) {\n            cin >> grid[i];\n            for (int j = 0; j < w; ++j) {\n                if (grid[i][j] == '&') {\n                    end_x = i;\n                    end_y = j;\n                }\n            }\n        }\n\n        // Find the border positions as starting points\n        vector<Point> starts;\n        for (int i = 0; i < h; ++i) {\n            if (grid[i][0] != '#') {\n                starts.emplace_back(i, 0, 0);\n            }\n            if (grid[i][w-1] != '#') {\n                starts.emplace_back(i, w-1, 0);\n            }\n        }\n        for (int j = 0; j < w; ++j) {\n            if (grid[0][j] != '#') {\n                starts.emplace_back(0, j, 0);\n            }\n            if (grid[h-1][j] != '#') {\n                starts.emplace_back(h-1, j, 0);\n            }\n        }\n\n        int min_climbs = INT_MAX;\n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (auto& start : starts) {\n            vector<vector<int>> dist(h, vector<int>(w, INT_MAX));\n            priority_queue<pair<int, Point>, vector<pair<int, Point>>, greater<pair<int, Point>>> pq;\n            pq.push({0, start});\n            dist[start.x][start.y] = 0;\n            bool found = false;\n\n            while (!pq.empty()) {\n                auto current = pq.top().second;\n                int current_cost = pq.top().first;\n                pq.pop();\n                if (current.x == end_x && current.y == end_y) {\n                    min_climbs = min(min_climbs, current_cost);\n                    found = true;\n                    break;\n                }\n                if (current_cost > dist[current.x][current.y]) continue;\n\n                for (auto& dir : dirs) {\n                    int nx = current.x + dir[0];\n                    int ny = current.y + dir[1];\n                    if (nx >= 0 && nx < h && ny >= 0 && ny < w) {\n                        int new_cost = current_cost;\n                        if (grid[current.x][current.y] != '#' && grid[nx][ny] == '#') {\n                            new_cost++;\n                        }\n                        if (new_cost < dist[nx][ny]) {\n                            dist[nx][ny] = new_cost;\n                            pq.push({new_cost, Point(nx, ny, new_cost)});\n                        }\n                    }\n                }\n            }\n        }\n        cout << min_climbs << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 50\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\ntypedef struct {\n    int x, y, depth, moats;\n} State;\n\nint bfs(char grid[MAX_SIZE][MAX_SIZE], int H, int W) {\n    int visited[MAX_SIZE][MAX_SIZE][MAX_SIZE * MAX_SIZE] = {0};\n    State queue[MAX_SIZE * MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    int tx, ty;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '&') {\n                tx = i;\n                ty = j;\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] != '#') {\n                State start = {i, j, 0, 0};\n                queue[rear++] = start;\n                visited[i][j][0] = 1;\n            }\n        }\n    }\n\n    while (front < rear) {\n        State current = queue[front++];\n\n        if (current.x == tx && current.y == ty) {\n            return current.moats;\n        }\n\n        for (int k = 0; k < 4; k++) {\n            int nx = current.x + dx[k];\n            int ny = current.y + dy[k];\n\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n\n            int new_moats = current.moats;\n            if (grid[current.x][current.y] == '#' && grid[nx][ny] != '#') {\n                new_moats++;\n            }\n\n            if (!visited[nx][ny][new_moats]) {\n                State next = {nx, ny, current.depth + 1, new_moats};\n                queue[rear++] = next;\n                visited[nx][ny][new_moats] = 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int H, W;\n    char grid[MAX_SIZE][MAX_SIZE];\n\n    while (scanf(\"%d %d\", &H, &W) && H && W) {\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n\n        int result = bfs(grid, H, W);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nint solve(vector<string>& grid) {\n    int rows = grid.size();\n    int cols = grid[0].length();\n    vector<vector<vector<int>>> dist(rows, vector<vector<int>>(cols, vector<int>(2, INT_MAX)));\n    \n    int start_x = -1, start_y = -1, end_x = -1, end_y = -1;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n            }\n            if (grid[i][j] == '&') {\n                end_x = i;\n                end_y = j;\n            }\n        }\n    }\n    \n    queue<pair<pair<int, int>, int>> q;\n    q.push({{start_x, start_y}, 0});\n    dist[start_x][start_y][0] = 0;\n    \n    while (!q.empty()) {\n        int x = q.front().first.first;\n        int y = q.front().first.second;\n        int climbs = q.front().second;\n        q.pop();\n        \n        if (x == end_x && y == end_y) {\n            return dist[x][y][climbs];\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            \n            if (nx < 0 || nx >= rows || ny < 0 || ny >= cols) continue;\n            \n            if (grid[nx][ny] == '#') {\n                if (climbs == 1) continue;\n                \n                if (dist[nx][ny][1] > dist[x][y][climbs] + 1) {\n                    dist[nx][ny][1] = dist[x][y][climbs] + 1;\n                    q.push({{nx, ny}, 1});\n                }\n            } else {\n                if (dist[nx][ny][climbs] > dist[x][y][climbs] + 1) {\n                    dist[nx][ny][climbs] = dist[x][y][climbs] + 1;\n                    q.push({{nx, ny}, climbs});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int R, C;\n    while (cin >> R >> C && R != 0 && C != 0) {\n        vector<string> grid(R);\n        for (int i = 0; i < R; i++) {\n            cin >> grid[i];\n        }\n        \n        int result = solve(grid);\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class State {\n        int x, y, cost;\n        State(int x, int y, int cost) {\n            this.x = x;\n            this.y = y;\n            this.cost = cost;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int W = sc.nextInt();\n            int H = sc.nextInt();\n            if (W == 0 && H == 0) break;\n            sc.nextLine();\n            char[][] grid = new char[H][W];\n            int startX = -1, startY = -1;\n            for (int i = 0; i < H; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                    if (grid[i][j] == '&') {\n                        startX = i;\n                        startY = j;\n                    }\n                }\n            }\n            int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n            PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> a.cost - b.cost);\n            pq.add(new State(startX, startY, 0));\n            int[][] minCost = new int[H][W];\n            for (int[] row : minCost) Arrays.fill(row, Integer.MAX_VALUE);\n            minCost[startX][startY] = 0;\n            int result = -1;\n            while (!pq.isEmpty()) {\n                State current = pq.poll();\n                if (current.x == 0 || current.x == H - 1 || current.y == 0 || current.y == W - 1) {\n                    result = current.cost;\n                    break;\n                }\n                if (current.cost > minCost[current.x][current.y]) continue;\n                for (int[] dir : dirs) {\n                    int nx = current.x + dir[0];\n                    int ny = current.y + dir[1];\n                    if (nx >= 0 && nx < H && ny >= 0 && ny < W) {\n                        int newCost = current.cost + (grid[current.x][current.y] == '#' && grid[nx][ny] != '#' ? 1 : 0);\n                        if (newCost < minCost[nx][ny]) {\n                            minCost[nx][ny] = newCost;\n                            pq.add(new State(nx, ny, newCost));\n                        }\n                    }\n                }\n            }\n            System.out.println(result);\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:34:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef minimum_moat_crossings(grid):\n    if not grid or not grid[0]:\n        return -1\n\n    def find_start_end():\n        start, end = None, None\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == '&':\n                    end = (r, c)\n                elif start is None and grid[r][c] == '.':\n                    start = (r, c)\n        return start, end\n    \n    start, end = find_start_end()\n    if not start or not end:\n        return -1\n\n    rows, cols = len(grid), len(grid[0])\n    deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # BFS to calculate minimum moat crossings\n    def bfs():\n        queue = deque()\n        # Store (row, col, moat_count, in_moat)\n        queue.append((*start, 0, False))\n        visited = set()\n        visited.add((start[0], start[1], False))\n\n        while queue:\n            r, c, moats, in_moat = queue.popleft()\n\n            if (r, c) == end:\n                return moats\n            \n            for dr, dc in deltas:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < rows and 0 <= nc < cols:\n                    if grid[nr][nc] == '#':  # Move into moat\n                        if not in_moat and (nr, nc, True) not in visited:\n                            visited.add((nr, nc, True))\n                            queue.append((nr, nc, moats, True))\n                    elif grid[nr][nc] == '.':  # Move onto land\n                        if in_moat and (nr, nc, False) not in visited:\n                            visited.add((nr, nc, False))\n                            queue.append((nr, nc, moats + 1, False))\n                        elif not in_moat and (nr, nc, False) not in visited:\n                            visited.add((nr, nc, False))\n                            queue.append((nr, nc, moats, False))\n\n        return -1\n\n    # Get the minimum moat crossings\n    return bfs()\n\n# Main function to read input and provide output\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n\n    i = 0\n    while i < len(data):\n        cols, rows = map(int, data[i].split())\n        if cols == 0 and rows == 0:\n            break\n        i += 1\n\n        grid = []\n        for _ in range(rows):\n            grid.append(list(data[i]))\n            i += 1\n\n        print(minimum_moat_crossings(grid))\n\n# Uncomment this line when running interactively\n# main()",
    "timestamp": "2025-08-12 23:43:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class NinjaMoat {\n\n    static class Point {\n        int x, y, climbs;\n        \n        Point(int x, int y, int climbs) {\n            this.x = x;\n            this.y = y;\n            this.climbs = climbs;\n        }\n    }\n\n    private static final int[] dx = {0, 0, 1, -1};\n    private static final int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            if (n == 0 && m == 0) break;\n            scanner.nextLine(); // Consume remainder of line\n            \n            char[][] grid = new char[n][m];\n            int startX = 0, startY = 0;\n\n            for (int i = 0; i < n; i++) {\n                String line = scanner.nextLine();\n                grid[i] = line.toCharArray();\n                if (line.contains(\"&\")) {\n                    startX = i;\n                    startY = line.indexOf('&');\n                }\n            }\n\n            System.out.println(minClimbs(grid, n, m, startX, startY));\n        }\n        scanner.close();\n    }\n\n    private static int minClimbs(char[][] grid, int n, int m, int startX, int startY) {\n        boolean[][][] visited = new boolean[n][m][2];\n        Queue<Point> queue = new LinkedList<>();\n        \n        queue.offer(new Point(startX, startY, 0));\n        visited[startX][startY][0] = true;\n        \n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n            if (grid[current.x][current.y] == '&') return current.climbs;\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = current.x + dx[i];\n                int ny = current.y + dy[i];\n                \n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    if (grid[nx][ny] == '#' && !visited[nx][ny][1]) {\n                        visited[nx][ny][1] = true;\n                        queue.offer(new Point(nx, ny, current.climbs + 1));\n                    } else if (grid[nx][ny] == '.' || grid[nx][ny] == '&') {\n                        int moatPenalty = grid[current.x][current.y] == '#' ? 1 : 0;\n                        if (!visited[nx][ny][moatPenalty]) {\n                            visited[nx][ny][moatPenalty] = true;\n                            queue.offer(new Point(nx, ny, current.climbs));\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-12 23:43:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX 100\n\n// Directions for movements: right, left, down, up\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\ntypedef struct {\n    int x, y, moats;\n} Node;\n\nNode queue[MAX * MAX];\nint front, rear;\n\nvoid enqueue(int x, int y, int moats) {\n    queue[rear].x = x;\n    queue[rear].y = y;\n    queue[rear].moats = moats;\n    rear++;\n}\n\nNode dequeue() {\n    return queue[front++];\n}\n\nint isEmpty() {\n    return front == rear;\n}\n\nint main() {\n    int n, m;\n    char grid[MAX][MAX];\n    \n    while (scanf(\"%d %d\", &n, &m) == 2 && (n != 0 || m != 0)) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n\n        int start_x = -1, start_y = -1;\n        int tower_x = -1, tower_y = -1;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'S') {\n                    start_x = i;\n                    start_y = j;\n                }\n                if (grid[i][j] == '&') {\n                    tower_x = i;\n                    tower_y = j;\n                }\n            }\n        }\n        \n        int moats_count[MAX][MAX];\n        for(int i = 0; i < n; i++) \n            for(int j = 0; j < m; j++)\n                moats_count[i][j] = INT_MAX;\n        \n        front = rear = 0;\n        enqueue(start_x, start_y, grid[start_x][start_y] == '#' ? 1 : 0);\n        moats_count[start_x][start_y] = grid[start_x][start_y] == '#' ? 1 : 0;\n\n        while (!isEmpty()) {\n            Node node = dequeue();\n            \n            for (int dir = 0; dir < 4; dir++) {\n                int nx = node.x + dx[dir];\n                int ny = node.y + dy[dir];\n                \n                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                    \n                    int new_moats = node.moats;\n                    if (grid[nx][ny] == '#' && grid[node.x][node.y] != '#') {\n                        new_moats++;\n                    }\n                    \n                    if (new_moats < moats_count[nx][ny]) {\n                        moats_count[nx][ny] = new_moats;\n                        enqueue(nx, ny, new_moats);\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", moats_count[tower_x][tower_y]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-12 23:43:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve_ninja_path(grid):\n    rows, cols = len(grid), len(grid[0])\n    start = None\n    tower = None\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'S':\n                start = (r, c)\n            elif grid[r][c] == '&':\n                tower = (r, c)\n    \n    if not start or not tower:\n        return -1\n    \n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n    \n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    \n    queue = deque([(start[0], start[1], 0, False)])\n    visited = set([(start[0], start[1], False)])\n    \n    while queue:\n        r, c, climbs, in_moat = queue.popleft()\n        \n        if (r, c) == tower:\n            return climbs\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            if not is_valid(nr, nc):\n                continue\n            \n            if grid[nr][nc] == '#':\n                if not in_moat and (nr, nc, True) not in visited:\n                    queue.append((nr, nc, climbs + 1, True))\n                    visited.add((nr, nc, True))\n            else:\n                if in_moat and (nr, nc, False) not in visited:\n                    queue.append((nr, nc, climbs, False))\n                    visited.add((nr, nc, False))\n                elif not in_moat and (nr, nc, in_moat) not in visited:\n                    queue.append((nr, nc, climbs, in_moat))\n                    visited.add((nr, nc, in_moat))\n    \n    return -1\n\ndef main():\n    while True:\n        cols, rows = map(int, input().split())\n        if cols == 0 and rows == 0:\n            break\n        \n        grid = []\n        for _ in range(rows):\n            grid.append(list(input().strip()))\n        \n        result = solve_ninja_path(grid)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:43:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while True:\n        w, h = map(int, sys.stdin.readline().split())\n        if w == 0 and h == 0:\n            break\n        grid = []\n        start = None\n        goal = None\n        for i in range(h):\n            line = sys.stdin.readline().strip()\n            grid.append(line)\n            if '&' in line:\n                goal = (i, line.index('&'))\n        \n        # Directions: north, south, east, west\n        directions = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n        \n        # Initialize distances with infinity\n        INF = float('inf')\n        dist = [[INF for _ in range(w)] for _ in range(h)]\n        q = deque()\n        \n        # The ninja starts from all border positions\n        for i in range(h):\n            for j in range(w):\n                if i == 0 or i == h-1 or j == 0 or j == w-1:\n                    if grid[i][j] != '#':\n                        dist[i][j] = 0\n                        q.append((i, j))\n        \n        while q:\n            i, j = q.popleft()\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < h and 0 <= nj < w:\n                    new_dist = dist[i][j]\n                    if grid[ni][nj] == '#':\n                        new_dist += 1\n                    if new_dist < dist[ni][nj]:\n                        dist[ni][nj] = new_dist\n                        q.append((ni, nj))\n        \n        print(dist[goal[0]][goal[1]])\n\nsolve()",
    "timestamp": "2025-08-12 23:44:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint minMoatCrossings(vector<string>& grid, pair<int, int> start, pair<int, int> end) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    vector<vector<int>> dir{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    vector<vector<int>> visited(rows, vector<int>(cols, -1));\n\n    queue<pair<int, int>> q;\n    q.push(start);\n    visited[start.first][start.second] = 0;\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        for (auto& d : dir) {\n            int nx = x + d[0];\n            int ny = y + d[1];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols) {\n                int add = (grid[x][y] == '#' && grid[nx][ny] != '#') ? 1 : 0;\n                if (visited[nx][ny] == -1 || visited[nx][ny] > visited[x][y] + add) {\n                    visited[nx][ny] = visited[x][y] + add;\n                    q.emplace(nx, ny);\n                }\n            }\n        }\n    }\n    return visited[end.first][end.second];\n}\n\nint main() {\n    int r, c;\n    while (cin >> r >> c, r || c) {\n        vector<string> grid(r);\n        pair<int, int> start, end;\n        for (int i = 0; i < r; ++i) {\n            cin >> grid[i];\n            for (int j = 0; j < c; ++j) {\n                if (grid[i][j] == '&') {\n                    end = {i, j};\n                } else if (grid[i][j] == '.') {\n                    start = {i, j};\n                }\n            }\n        }\n        \n        int result = minMoatCrossings(grid, start, end);\n        cout << result << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 10:51:01"
  }
]