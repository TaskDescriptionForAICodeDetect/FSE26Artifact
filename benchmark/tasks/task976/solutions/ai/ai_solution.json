[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n\nint n, k;\nint values[MAX_N];\nbool filled[MAX_N];\nbool graph[MAX_N][MAX_N];\nint degree[MAX_N];\n\nbool dfs(int node) {\n    filled[node] = true;\n    \n    for (int neighbor = 1; neighbor <= n; neighbor++) {\n        if (!graph[node][neighbor]) continue;\n        \n        if (filled[neighbor]) {\n            if (abs(values[node] - values[neighbor]) != 1) \n                return false;\n        } else {\n            if (values[node] != 0) {\n                values[neighbor] = values[node] + (degree[neighbor] > degree[node] ? 1 : -1);\n            } else {\n                bool found = false;\n                for (int val = -1000; val <= 1000; val++) {\n                    bool valid = true;\n                    for (int adj = 1; adj <= n; adj++) {\n                        if (!graph[neighbor][adj] || !filled[adj]) continue;\n                        if (abs(val - values[adj]) != 1) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        values[neighbor] = val;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) return false;\n            }\n            \n            if (!dfs(neighbor)) return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &k);\n    \n    memset(values, 0, sizeof(values));\n    memset(filled, 0, sizeof(filled));\n    memset(graph, 0, sizeof(graph));\n    memset(degree, 0, sizeof(degree));\n    \n    for (int i = 0; i < k; i++) {\n        int vertex, val;\n        scanf(\"%d %d\", &vertex, &val);\n        values[vertex] = val;\n        filled[vertex] = true;\n    }\n    \n    int m;\n    scanf(\"%d\", &m);\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = graph[v][u] = true;\n        degree[u]++;\n        degree[v]++;\n    }\n    \n    bool possible = false;\n    for (int start = 1; start <= n; start++) {\n        if (!filled[start]) {\n            for (int val = -1000; val <= 1000; val++) {\n                values[start] = val;\n                memset(filled, 0, sizeof(filled));\n                \n                if (dfs(start)) {\n                    possible = true;\n                    break;\n                }\n            }\n            \n            if (possible) break;\n        }\n    }\n    \n    if (possible) {\n        printf(\"Possible\\n\");\n        for (int i = 1; i <= n; i++) {\n            printf(\"%d \", values[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"Impossible\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    int value;\n    int filled;\n    int visited;\n    struct Node** neighbors;\n    int neighbor_count;\n} Node;\n\nNode* create_node(int value, int filled) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->value = value;\n    node->filled = filled;\n    node->visited = 0;\n    node->neighbors = NULL;\n    node->neighbor_count = 0;\n    return node;\n}\n\nvoid add_neighbor(Node* node, Node* neighbor) {\n    node->neighbors = (Node**)realloc(node->neighbors, (node->neighbor_count + 1) * sizeof(Node*));\n    node->neighbors[node->neighbor_count++] = neighbor;\n}\n\nint dfs(Node* node) {\n    node->visited = 1;\n    for (int i = 0; i < node->neighbor_count; ++i) {\n        Node* neighbor = node->neighbors[i];\n        if (neighbor->filled) {\n            if (abs(node->value - neighbor->value) != 1) {\n                return 0;\n            }\n        } else {\n            if (!neighbor->visited) {\n                neighbor->value = node->value + 1;\n                if (!dfs(neighbor)) {\n                    return 0;\n                }\n            } else {\n                if (abs(node->value - neighbor->value) != 1) {\n                    return 0;\n                }\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n\n    Node** nodes = (Node**)malloc((N + 1) * sizeof(Node*));\n    for (int i = 1; i <= N; ++i) {\n        nodes[i] = create_node(0, 0);\n    }\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_neighbor(nodes[u], nodes[v]);\n        add_neighbor(nodes[v], nodes[u]);\n    }\n\n    for (int i = 0; i < K; ++i) {\n        int p, x;\n        scanf(\"%d %d\", &p, &x);\n        nodes[p]->value = x;\n        nodes[p]->filled = 1;\n    }\n\n    int possible = 1;\n    for (int i = 1; i <= N; ++i) {\n        if (nodes[i]->filled && !nodes[i]->visited) {\n            if (!dfs(nodes[i])) {\n                possible = 0;\n                break;\n            }\n        }\n    }\n\n    if (!possible) {\n        printf(\"No\\n\");\n    } else {\n        printf(\"Yes\\n\");\n        for (int i = 1; i <= N; ++i) {\n            printf(\"%d \", nodes[i]->value);\n        }\n        printf(\"\\n\");\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        free(nodes[i]->neighbors);\n        free(nodes[i]);\n    }\n    free(nodes);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:32:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<vector<int>> adj(N + 1);\n    vector<int> value(N + 1, -1);\n    queue<int> q;\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for (int i = 0; i < K; ++i) {\n        int p, x;\n        cin >> p >> x;\n        value[p] = x;\n        q.push(p);\n    }\n\n    bool possible = true;\n    while (!q.empty() && possible) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (value[v] == -1) {\n                value[v] = value[u] + 1;\n                q.push(v);\n            } else if (abs(value[v] - value[u]) != 1) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    if (possible) {\n        cout << \"Yes\" << endl;\n        for (int i = 1; i <= N; ++i) {\n            cout << value[i] << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:33:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeFill {\n    static class Pair {\n        int node, value;\n        Pair(int node, int value) {\n            this.node = node;\n            this.value = value;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        int[] values = new int[N + 1];\n        Arrays.fill(values, -1);\n        Queue<Pair> queue = new LinkedList<>();\n\n        for (int i = 0; i < K; i++) {\n            int node = scanner.nextInt();\n            int value = scanner.nextInt();\n            values[node] = value;\n            queue.add(new Pair(node, value));\n        }\n\n        boolean possible = true;\n        while (!queue.isEmpty() && possible) {\n            Pair current = queue.poll();\n            int node = current.node;\n            int value = current.value;\n\n            for (int neighbor : adj.get(node)) {\n                if (values[neighbor] == -1) {\n                    values[neighbor] = value + 1;\n                    queue.add(new Pair(neighbor, values[neighbor]));\n                } else if (Math.abs(values[neighbor] - value) != 1) {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n\n        if (!possible) {\n            System.out.println(\"No\");\n        } else {\n            System.out.println(\"Yes\");\n            for (int i = 1; i <= N; i++) {\n                System.out.print(values[i] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:33:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeIntegerFilling {\n    public static void solve(int N, int K, int[] vertices, int[] labels) {\n        List<List<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < K; i++) {\n            graph.get(vertices[i]).add(labels[i]);\n        }\n        \n        int[] result = new int[N + 1];\n        for (int i = 0; i < K; i++) {\n            result[vertices[i]] = labels[i];\n        }\n        \n        if (dfs(graph, result, 1, 0)) {\n            for (int i = 1; i <= N; i++) {\n                System.out.println(\"Vertex \" + i + \": \" + result[i]);\n            }\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n    \n    private static boolean dfs(List<List<Integer>> graph, int[] result, int vertex, int parent) {\n        for (int neighbor : graph.get(vertex)) {\n            if (neighbor == parent) continue;\n            \n            if (result[neighbor] != 0) {\n                if (Math.abs(result[vertex] - result[neighbor]) != 1) {\n                    return false;\n                }\n            } else {\n                if (result[vertex] == 0) {\n                    return false;\n                }\n                \n                result[neighbor] = result[vertex] > 0 ? result[vertex] - 1 : result[vertex] + 1;\n            }\n            \n            if (!dfs(graph, result, neighbor, vertex)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        int N = 5;  // number of vertices\n        int K = 2;  // number of pre-filled vertices\n        int[] vertices = {1, 3};  // vertices with pre-filled labels\n        int[] labels = {5, 4};   // labels for pre-filled vertices\n        \n        solve(N, K, vertices, labels);\n    }\n}",
    "timestamp": "2025-08-05 23:34:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <climits>\n\nusing namespace std;\n\nbool solve(int N, vector<pair<int, int>>& edges, vector<int>& initial_values) {\n    vector<vector<int>> graph(N + 1);\n    for (auto& edge : edges) {\n        graph[edge.first].push_back(edge.second);\n        graph[edge.second].push_back(edge.first);\n    }\n\n    vector<int> values(N + 1, INT_MIN);\n    for (int i = 0; i < initial_values.size(); i++) {\n        values[initial_values[i]] = i;\n    }\n\n    queue<int> q;\n    for (int i = 1; i <= N; i++) {\n        if (values[i] != INT_MIN) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : graph[node]) {\n            if (values[neighbor] == INT_MIN) {\n                if (values[node] == 0) {\n                    values[neighbor] = 1;\n                } else if (values[node] == initial_values.size() - 1) {\n                    values[neighbor] = initial_values.size() - 2;\n                } else {\n                    values[neighbor] = values[node] - 1;\n                }\n                q.push(neighbor);\n            } else if (abs(values[node] - values[neighbor]) != 1) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int N, K, M;\n    cin >> N >> K >> M;\n\n    vector<int> initial_values(K);\n    for (int i = 0; i < K; i++) {\n        cin >> initial_values[i];\n    }\n\n    vector<pair<int, int>> edges(M);\n    for (int i = 0; i < M; i++) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    bool possible = solve(N, edges, initial_values);\n    \n    if (possible) {\n        cout << \"Possible\" << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:34:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_possible_fill_tree(N, K, vertex_values):\n    from collections import defaultdict, deque\n\n    tree = defaultdict(list)\n    values = [None] * (N + 1)\n\n    for u, v in vertex_values:\n        values[u] = v\n\n    edges = [tuple(map(int, input().split())) for _ in range(N-1)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def bfs(start):\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            current_value = values[node]\n            for neighbor in tree[node]:\n                neighbor_value = values[neighbor]\n                if neighbor_value is None:\n                    values[neighbor] = current_value + 1\n                    queue.append(neighbor)\n                elif abs(neighbor_value - current_value) != 1:\n                    return False\n        return True\n\n    for i in range(1, N+1):\n        if values[i] is not None:\n            if not bfs(i):\n                return \"No\"\n\n    for i in range(1, N+1):\n        if values[i] is None:\n            return \"No\"\n\n    return \"Yes\\n\" + \" \".join(map(str, values[1:]))\n\nN = int(input())\nK = int(input())\nvertex_values = [tuple(map(int, input().split())) for _ in range(K)]\n\nprint(is_possible_fill_tree(N, K, vertex_values))",
    "timestamp": "2025-08-13 15:50:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeAndIntegers {\n    \n    static boolean isPossible = true;\n    static Map<Integer, List<Integer>> tree = new HashMap<>();\n    static Map<Integer, Integer> values = new HashMap<>();\n    static int[] result;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        result = new int[n + 1];\n        \n        for (int i = 0; i < n - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            tree.computeIfAbsent(u, x -> new ArrayList<>()).add(v);\n            tree.computeIfAbsent(v, x -> new ArrayList<>()).add(u);\n        }\n        \n        for (int i = 0; i < k; i++) {\n            int vertex = sc.nextInt();\n            int value = sc.nextInt();\n            values.put(vertex, value);\n            result[vertex] = value;\n        }\n        \n        boolean[] visited = new boolean[n + 1];\n        for (int vertex : values.keySet()) {\n            if (!visited[vertex]) {\n                dfs(vertex, visited);\n            }\n        }\n\n        if (isPossible) {\n            for (int i = 1; i <= n; i++) {\n                System.out.print(result[i] + \" \");\n            }\n        } else {\n            System.out.println(\"No solution\");\n        }\n\n        sc.close();\n    }\n\n    public static void dfs(int node, boolean[] visited) {\n        visited[node] = true;\n        \n        for (int neighbor : tree.getOrDefault(node, Collections.emptyList())) {\n            if (visited[neighbor]) continue;\n            \n            if (values.containsKey(neighbor)) {\n                if (Math.abs(result[node] - result[neighbor]) != 1) {\n                    isPossible = false;\n                    return;\n                }\n            } else {\n                result[neighbor] = result[node] + 1;\n                if (tree.containsKey(neighbor)) {\n                    dfs(neighbor, visited);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 15:51:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAXN 100005\n\ntypedef struct {\n    int vertex, weight;\n} Edge;\n\nEdge edges[2 * MAXN];\nint head[MAXN], next[2 * MAXN], edgeCount = 0;\nint value[MAXN], visited[MAXN];\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount] = (Edge){v, 0};\n    next[edgeCount] = head[u];\n    head[u] = edgeCount++;\n}\n\nbool dfs(int node, int parent, int currentValue) {\n    visited[node] = 1;\n    value[node] = currentValue;\n    for (int i = head[node]; i != -1; i = next[i]) {\n        int v = edges[i].vertex;\n        if (v == parent) continue;\n        if (visited[v]) {\n            if (abs(value[v] - currentValue) != 1) return false;\n        } else {\n            if (!dfs(v, node, currentValue + 1) && !dfs(v, node, currentValue - 1)) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n    }\n    \n    for (int i = 1; i <= n; i++) head[i] = -1;\n\n    for (int i = 0; i < k; i++) {\n        int vertex, val;\n        scanf(\"%d %d\", &vertex, &val);\n        value[vertex] = val;\n        visited[vertex] = 1;\n    }\n\n    bool possible = true;\n    for (int i = 1; i <= n; i++) {\n        if (!visited[i]) {\n            possible = dfs(i, -1, value[i] ? value[i] : 0);\n            break;\n        }\n    }\n    \n    if (possible) {\n        printf(\"YES\\n\");\n        for (int i = 1; i <= n; i++) printf(\"%d \", value[i]);\n    } else {\n        printf(\"NO\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:51:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct Node {\n    int index;\n    int value;\n};\n\nbool bfs(const vector<vector<int>>& graph, vector<int>& values) {\n    int n = values.size();\n    queue<Node> q;\n    unordered_set<int> visited;\n\n    for(int i = 1; i < n; i++) {\n        if(values[i] != -1) {\n            q.push({i, values[i]});\n            visited.insert(i);\n        }\n    }\n\n    while(!q.empty()) {\n        Node node = q.front(); q.pop();\n        int currIndex = node.index;\n        int currValue = node.value;\n        \n        for(int neighbor : graph[currIndex]) {\n            if(visited.count(neighbor)) {\n                if(abs(values[neighbor] - currValue) != 1)\n                    return false;\n            } else {\n                values[neighbor] = currValue + (values[neighbor] == -1 ? 1 : -1);\n                q.push({neighbor, values[neighbor]});\n                visited.insert(neighbor);\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<vector<int>> graph(N + 1);\n    vector<int> values(N + 1, -1);\n\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    for (int i = 0; i < K; i++) {\n        int v, c;\n        cin >> v >> c;\n        values[v] = c;\n    }\n\n    if (bfs(graph, values)) {\n        cout << \"YES\" << endl;\n        for (int i = 1; i <= N; i++) {\n            cout << values[i] << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:51:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_tree_labeling(N, K, labeled_vertices):\n    # Create an adjacency list representation of the tree\n    graph = [[] for _ in range(N+1)]\n    degree = [0] * (N+1)\n\n    # Read input edges and build graph\n    for _ in range(N-1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n\n    # Initialize values for labeled vertices\n    values = [0] * (N+1)\n    for vertex, val in labeled_vertices:\n        values[vertex] = val\n    \n    # DFS to propagate and validate labeling\n    def dfs(vertex, parent):\n        for neighbor in graph[vertex]:\n            if neighbor == parent:\n                continue\n            \n            # If neighbor is unlabeled\n            if values[neighbor] == 0:\n                # Try to label neighbor\n                if values[vertex] > 0:\n                    # Label with +1 or -1 of parent's value\n                    if values[vertex] > 1:\n                        values[neighbor] = values[vertex] - 1\n                    else:\n                        values[neighbor] = values[vertex] + 1\n                else:\n                    # Find a valid value by checking neighbors\n                    possible_values = set()\n                    for adj in graph[neighbor]:\n                        if values[adj] != 0:\n                            possible_values.update([values[adj]-1, values[adj]+1])\n                    \n                    # If no valid value found, return False\n                    if not possible_values:\n                        return False\n                    \n                    values[neighbor] = min(possible_values)\n            \n            # Validate labeling constraint\n            elif abs(values[vertex] - values[neighbor]) != 1:\n                return False\n            \n            # Continue DFS\n            if not dfs(neighbor, vertex):\n                return False\n        \n        return True\n\n    # Start DFS from an arbitrary vertex\n    start_vertex = labeled_vertices[0][0] if labeled_vertices else 1\n    if not dfs(start_vertex, 0):\n        return None\n    \n    # Check if all vertices are labeled\n    if 0 in values[1:]:\n        return None\n    \n    return values[1:]\n\n# Input parsing and solution calling\ndef main():\n    N, K = map(int, input().split())\n    labeled_vertices = []\n    for _ in range(K):\n        vertex, value = map(int, input().split())\n        labeled_vertices.append((vertex, value))\n    \n    result = solve_tree_labeling(N, K, labeled_vertices)\n    \n    if result is None:\n        print(\"Impossible\")\n    else:\n        print(\"Possible\")\n        print(*result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 15:51:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        ptr += 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    value = [None] * (N+1)\n    q = deque()\n    \n    for _ in range(K):\n        v = int(input[ptr])\n        x = int(input[ptr+1])\n        ptr += 2\n        value[v] = x\n        q.append(v)\n    \n    possible = True\n    while q and possible:\n        u = q.popleft()\n        for v in adj[u]:\n            if value[v] is None:\n                value[v] = value[u] + 1 if (value[u] % 2 == 0) else value[u] - 1\n                q.append(v)\n            else:\n                if abs(value[u] - value[v]) != 1:\n                    possible = False\n                    break\n        if not possible:\n            break\n    \n    if possible:\n        print(\"Yes\")\n        print(' '.join(map(str, value[1:])))\n    else:\n        print(\"No\")\n\nsolve()",
    "timestamp": "2025-08-13 15:51:48"
  }
]