[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_FILES 1000\n#define MAX_SECTORS 1000000\n\ntypedef struct {\n    int id;\n    int start;\n    int length;\n    int deleted;\n} File;\n\nFile files[MAX_FILES];\nint storage[MAX_SECTORS];\nint next_free = 0;\nint file_count = 0;\n\nvoid write_data(int id, int length) {\n    if (next_free + length > MAX_SECTORS) {\n        return;\n    }\n    files[file_count].id = id;\n    files[file_count].start = next_free;\n    files[file_count].length = length;\n    files[file_count].deleted = 0;\n    for (int i = 0; i < length; i++) {\n        storage[next_free + i] = id;\n    }\n    next_free += length;\n    file_count++;\n}\n\nvoid delete_data(int id) {\n    for (int i = 0; i < file_count; i++) {\n        if (files[i].id == id && !files[i].deleted) {\n            files[i].deleted = 1;\n            for (int j = files[i].start; j < files[i].start + files[i].length; j++) {\n                storage[j] = 0;\n            }\n        }\n    }\n}\n\nint reference_sector(int sector) {\n    if (sector < 0 || sector >= next_free) {\n        return 0;\n    }\n    return storage[sector];\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    while (n--) {\n        char cmd[10];\n        scanf(\"%s\", cmd);\n        if (strcmp(cmd, \"write\") == 0) {\n            int id, length;\n            scanf(\"%d %d\", &id, &length);\n            write_data(id, length);\n        } else if (strcmp(cmd, \"delete\") == 0) {\n            int id;\n            scanf(\"%d\", &id);\n            delete_data(id);\n        } else if (strcmp(cmd, \"reference\") == 0) {\n            int sector;\n            scanf(\"%d\", &sector);\n            printf(\"%d\\n\", reference_sector(sector));\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nstruct File {\n    int id;\n    int start;\n    int size;\n};\n\nclass StorageMedium {\nprivate:\n    vector<int> sectors;\n    unordered_map<int, File> files;\n    priority_queue<int, vector<int>, greater<int>> freeSectors;\n\npublic:\n    StorageMedium(int numSectors) : sectors(numSectors, 0) {\n        for (int i = 0; i < numSectors; ++i) {\n            freeSectors.push(i);\n        }\n    }\n\n    void write(int fileId, int size) {\n        if (freeSectors.size() < size) {\n            return; // Not enough space\n        }\n\n        int start = freeSectors.top();\n        vector<int> usedSectors;\n        for (int i = 0; i < size; ++i) {\n            if (freeSectors.empty() || sectors[freeSectors.top()] != 0) {\n                // No contiguous space available\n                for (int sector : usedSectors) {\n                    sectors[sector] = 0;\n                    freeSectors.push(sector);\n                }\n                return;\n            }\n            int sector = freeSectors.top();\n            sectors[sector] = fileId;\n            usedSectors.push_back(sector);\n            freeSectors.pop();\n        }\n\n        files[fileId] = {fileId, start, size};\n    }\n\n    void deleteFile(int fileId) {\n        if (files.find(fileId) == files.end()) {\n            return;\n        }\n\n        File file = files[fileId];\n        for (int i = 0; i < file.size; ++i) {\n            int sector = file.start + i;\n            if (sector < sectors.size() && sectors[sector] == fileId) {\n                sectors[sector] = 0;\n                freeSectors.push(sector);\n            }\n        }\n\n        files.erase(fileId);\n    }\n\n    int reference(int sector) {\n        if (sector < 0 || sector >= sectors.size()) {\n            return 0;\n        }\n        return sectors[sector];\n    }\n};\n\nint main() {\n    int numSectors, numCommands;\n    cin >> numSectors >> numCommands;\n\n    StorageMedium storage(numSectors);\n\n    while (numCommands--) {\n        char command;\n        cin >> command;\n\n        if (command == 'W') {\n            int fileId, size;\n            cin >> fileId >> size;\n            storage.write(fileId, size);\n        } else if (command == 'D') {\n            int fileId;\n            cin >> fileId;\n            storage.deleteFile(fileId);\n        } else if (command == 'R') {\n            int sector;\n            cin >> sector;\n            cout << storage.reference(sector) << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FileSystem {\n    private int[] storage;\n    private Map<Integer, List<Integer>> fileToSectors;\n    private PriorityQueue<Integer> freeSectors;\n    private int nextFileId;\n\n    public FileSystem(int size) {\n        storage = new int[size];\n        Arrays.fill(storage, -1); // -1 indicates free sector\n        fileToSectors = new HashMap<>();\n        freeSectors = new PriorityQueue<>();\n        for (int i = 0; i < size; i++) {\n            freeSectors.add(i);\n        }\n        nextFileId = 0;\n    }\n\n    public int write(int size) {\n        if (freeSectors.size() < size) {\n            return -1;\n        }\n        int fileId = nextFileId++;\n        List<Integer> sectors = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            int sector = freeSectors.poll();\n            storage[sector] = fileId;\n            sectors.add(sector);\n        }\n        fileToSectors.put(fileId, sectors);\n        return fileId;\n    }\n\n    public boolean delete(int fileId) {\n        if (!fileToSectors.containsKey(fileId)) {\n            return false;\n        }\n        List<Integer> sectors = fileToSectors.get(fileId);\n        for (int sector : sectors) {\n            storage[sector] = -1;\n            freeSectors.add(sector);\n        }\n        fileToSectors.remove(fileId);\n        return true;\n    }\n\n    public int reference(int sector) {\n        if (sector < 0 || sector >= storage.length) {\n            return -1;\n        }\n        return storage[sector];\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int size = scanner.nextInt();\n        FileSystem fs = new FileSystem(size);\n        int commands = scanner.nextInt();\n        for (int i = 0; i < commands; i++) {\n            String command = scanner.next();\n            if (command.equals(\"write\")) {\n                int writeSize = scanner.nextInt();\n                int fileId = fs.write(writeSize);\n                System.out.println(fileId);\n            } else if (command.equals(\"delete\")) {\n                int fileId = scanner.nextInt();\n                boolean success = fs.delete(fileId);\n                System.out.println(success);\n            } else if (command.equals(\"reference\")) {\n                int sector = scanner.nextInt();\n                int fileId = fs.reference(sector);\n                System.out.println(fileId);\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:11:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StorageMediumFileSystem {\n    private static final int TOTAL_SECTORS = 1000;\n    private int[] sectors = new int[TOTAL_SECTORS];\n    private Map<Integer, Integer> fileMap = new HashMap<>();\n    private int nextWritePosition = 0;\n\n    public void write(int fileId, int sectorCount) {\n        if (nextWritePosition + sectorCount > TOTAL_SECTORS) {\n            System.out.println(\"Not enough space\");\n            return;\n        }\n\n        for (int i = 0; i < sectorCount; i++) {\n            sectors[nextWritePosition + i] = fileId;\n            fileMap.put(nextWritePosition + i, fileId);\n        }\n        nextWritePosition += sectorCount;\n    }\n\n    public void delete(int fileId) {\n        for (int i = 0; i < TOTAL_SECTORS; i++) {\n            if (sectors[i] == fileId) {\n                sectors[i] = 0;\n                fileMap.remove(i);\n            }\n        }\n    }\n\n    public void reference(int sectorIndex) {\n        if (sectorIndex < 0 || sectorIndex >= TOTAL_SECTORS) {\n            System.out.println(\"Invalid sector\");\n            return;\n        }\n\n        int fileId = fileMap.getOrDefault(sectorIndex, 0);\n        System.out.println(fileId);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        StorageMediumFileSystem fileSystem = new StorageMediumFileSystem();\n\n        while (scanner.hasNext()) {\n            String command = scanner.next();\n            switch (command) {\n                case \"write\":\n                    int fileId = scanner.nextInt();\n                    int sectorCount = scanner.nextInt();\n                    fileSystem.write(fileId, sectorCount);\n                    break;\n                case \"delete\":\n                    fileId = scanner.nextInt();\n                    fileSystem.delete(fileId);\n                    break;\n                case \"reference\":\n                    int sectorIndex = scanner.nextInt();\n                    fileSystem.reference(sectorIndex);\n                    break;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:11:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SECTORS 1000\n#define MAX_FILENAME 50\n\ntypedef struct {\n    int start_sector;\n    int length;\n    char filename[MAX_FILENAME];\n} FileEntry;\n\nint sectors[MAX_SECTORS];\nFileEntry files[MAX_SECTORS];\nint file_count = 0;\nint next_free_sector = 0;\n\nvoid write_file(char* filename, int size) {\n    if (next_free_sector + size > MAX_SECTORS) {\n        printf(\"Not enough space\\n\");\n        return;\n    }\n\n    FileEntry new_file;\n    strcpy(new_file.filename, filename);\n    new_file.start_sector = next_free_sector;\n    new_file.length = size;\n\n    for (int i = 0; i < size; i++) {\n        sectors[next_free_sector + i] = file_count + 1;\n    }\n\n    files[file_count++] = new_file;\n    next_free_sector += size;\n    printf(\"OK\\n\");\n}\n\nvoid delete_file(char* filename) {\n    for (int i = 0; i < file_count; i++) {\n        if (strcmp(files[i].filename, filename) == 0) {\n            for (int j = files[i].start_sector; j < files[i].start_sector + files[i].length; j++) {\n                sectors[j] = 0;\n            }\n\n            for (int j = i; j < file_count - 1; j++) {\n                files[j] = files[j + 1];\n            }\n            file_count--;\n            printf(\"OK\\n\");\n            return;\n        }\n    }\n    printf(\"ERROR\\n\");\n}\n\nvoid reference_sector(int sector) {\n    if (sector >= 0 && sector < MAX_SECTORS) {\n        if (sectors[sector] > 0) {\n            printf(\"%s\\n\", files[sectors[sector] - 1].filename);\n        } else {\n            printf(\"FREE\\n\");\n        }\n    } else {\n        printf(\"ERROR\\n\");\n    }\n}\n\nint main() {\n    char command[10];\n    char filename[MAX_FILENAME];\n    int size, sector;\n\n    while (1) {\n        scanf(\"%s\", command);\n\n        if (strcmp(command, \"WRITE\") == 0) {\n            scanf(\"%s %d\", filename, &size);\n            write_file(filename, size);\n        } else if (strcmp(command, \"DELETE\") == 0) {\n            scanf(\"%s\", filename);\n            delete_file(filename);\n        } else if (strcmp(command, \"REFERENCE\") == 0) {\n            scanf(\"%d\", &sector);\n            reference_sector(sector);\n        } else if (strcmp(command, \"EXIT\") == 0) {\n            break;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass StorageMedium {\nprivate:\n    vector<int> sectors;\n    map<int, int> fileAllocations;\n    int totalSectors;\n\npublic:\n    StorageMedium(int size) : totalSectors(size) {\n        sectors.resize(size, -1);\n    }\n\n    void write(int fileId) {\n        for (int i = 0; i < totalSectors; ++i) {\n            if (sectors[i] == -1) {\n                sectors[i] = fileId;\n                fileAllocations[fileId] = i;\n                break;\n            }\n        }\n    }\n\n    void deleteSector(int fileId) {\n        if (fileAllocations.count(fileId)) {\n            int sectorIndex = fileAllocations[fileId];\n            sectors[sectorIndex] = -1;\n            fileAllocations.erase(fileId);\n        }\n    }\n\n    void reference(int sectorIndex) {\n        if (sectorIndex >= 0 && sectorIndex < totalSectors) {\n            cout << sectors[sectorIndex] << endl;\n        }\n    }\n};\n\nint main() {\n    int storageSize, commandCount;\n    cin >> storageSize >> commandCount;\n\n    StorageMedium storage(storageSize);\n\n    for (int i = 0; i < commandCount; ++i) {\n        string command;\n        cin >> command;\n\n        if (command == \"write\") {\n            int fileId;\n            cin >> fileId;\n            storage.write(fileId);\n        }\n        else if (command == \"delete\") {\n            int fileId;\n            cin >> fileId;\n            storage.deleteSector(fileId);\n        }\n        else if (command == \"reference\") {\n            int sectorIndex;\n            cin >> sectorIndex;\n            storage.reference(sectorIndex);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class FileSystem:\n    def __init__(self, size):\n        self.size = size\n        self.sectors = [None] * size\n    \n    def write(self, file_id, length):\n        start = None\n        current_length = 0\n        for i in range(self.size):\n            if self.sectors[i] is None:\n                if start is None:\n                    start = i\n                current_length += 1\n                if current_length == length:\n                    for j in range(start, start + length):\n                        self.sectors[j] = file_id\n                    return start\n            else:\n                start = None\n                current_length = 0\n        return -1\n    \n    def delete(self, file_id):\n        for i in range(self.size):\n            if self.sectors[i] == file_id:\n                self.sectors[i] = None\n        \n    def reference(self, sector):\n        if 0 <= sector < self.size:\n            return self.sectors[sector]\n        return None\n\n\ndef main(commands, size):\n    fs = FileSystem(size)\n    for command in commands:\n        cmd_split = command.split()\n        cmd_type = cmd_split[0]\n        \n        if cmd_type == \"write\":\n            file_id = cmd_split[1]\n            length = int(cmd_split[2])\n            fs.write(file_id, length)\n        \n        elif cmd_type == \"delete\":\n            file_id = cmd_split[1]\n            fs.delete(file_id)\n        \n        elif cmd_type == \"reference\":\n            sector = int(cmd_split[1])\n            file_id = fs.reference(sector)\n            if file_id is not None:\n                print(file_id)\n\n# Example usage:\n# commands = [\"write file1 3\", \"write file2 2\", \"reference 0\", \"reference 4\", \"delete file1\", \"reference 0\"]\n# main(commands, 10)",
    "timestamp": "2025-08-13 05:15:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class StorageMediumFileSystem {\n    private static final int STORAGE_SIZE = 1000;\n    private String[] storage = new String[STORAGE_SIZE];\n    private Map<String, List<Integer>> fileMap = new HashMap<>();\n    private int nextFreeSpace = 0;\n\n    // Write a file to the storage\n    public void write(String fileId, int size) {\n        List<Integer> sectors = new ArrayList<>();\n        int written = 0;\n\n        for (int i = nextFreeSpace; i < STORAGE_SIZE && written < size; i++) {\n            if (storage[i] == null) {\n                storage[i] = fileId;\n                sectors.add(i);\n                written++;\n            }\n        }\n\n        if (written == size) {\n            fileMap.put(fileId, sectors);\n            updateNextFreeSpace();\n        }\n    }\n\n    // Delete a file from the storage\n    public void delete(String fileId) {\n        if (fileMap.containsKey(fileId)) {\n            for (int sector : fileMap.get(fileId)) {\n                storage[sector] = null;\n            }\n            fileMap.remove(fileId);\n            updateNextFreeSpace();\n        }\n    }\n\n    // Reference a sector in the storage\n    public String reference(int sector) {\n        if (sector < 0 || sector >= STORAGE_SIZE) {\n            throw new IllegalArgumentException(\"Sector out of bounds\");\n        }\n        return storage[sector] != null ? storage[sector] : \"Empty\";\n    }\n\n    // Update next free space pointer\n    private void updateNextFreeSpace() {\n        for (int i = nextFreeSpace; i < STORAGE_SIZE; i++) {\n            if (storage[i] == null) {\n                nextFreeSpace = i;\n                return;\n            }\n        }\n        nextFreeSpace = STORAGE_SIZE;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        StorageMediumFileSystem fileSystem = new StorageMediumFileSystem();\n        fileSystem.write(\"file1\", 10);\n        fileSystem.write(\"file2\", 5);\n        System.out.println(fileSystem.reference(0)); // Output: file1\n        System.out.println(fileSystem.reference(15)); // Output: Empty\n        fileSystem.delete(\"file1\");\n        System.out.println(fileSystem.reference(0)); // Output: Empty\n    }\n}",
    "timestamp": "2025-08-13 05:15:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SECTORS 1000\n#define MAX_FILES 1000\n\ntypedef struct {\n    int start;\n    int length;\n    int id;\n} File;\n\nint storage[MAX_SECTORS];\nFile files[MAX_FILES];\nint fileCount = 0;\n\nvoid writeData(int id, int length) {\n    int i;\n    int start = -1;\n    for (i = 0; i <= MAX_SECTORS - length; i++) {\n        int j;\n        for (j = i; j < i + length; j++) {\n            if (storage[j] != 0) break;\n        }\n        if (j == i + length) {\n            start = i;\n            break;\n        }\n    }\n    \n    if (start != -1) {\n        for (i = start; i < start + length; i++) {\n            storage[i] = id;\n        }\n        files[fileCount].start = start;\n        files[fileCount].length = length;\n        files[fileCount].id = id;\n        fileCount++;\n    }\n}\n\nvoid deleteData(int id) {\n    int i;\n    for (i = 0; i < fileCount; i++) {\n        if (files[i].id == id) {\n            int j;\n            for (j = files[i].start; j < files[i].start + files[i].length; j++) {\n                storage[j] = 0;\n            }\n            files[i] = files[fileCount - 1];\n            fileCount--;\n            break;\n        }\n    }\n}\n\nint referenceSector(int sector) {\n    return storage[sector];\n}\n\nint main() {\n    char command[20];\n    int id, length, sector;\n    \n    while (scanf(\"%s\", command) != EOF) {\n        if (strcmp(command, \"write\") == 0) {\n            scanf(\"%d %d\", &id, &length);\n            writeData(id, length);\n        } else if (strcmp(command, \"delete\") == 0) {\n            scanf(\"%d\", &id);\n            deleteData(id);\n        } else if (strcmp(command, \"reference\") == 0) {\n            scanf(\"%d\", &sector);\n            printf(\"%d\\n\", referenceSector(sector));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:16:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class StorageMedium:\n    def __init__(self, total_sectors=100):\n        self.sectors = [None] * total_sectors\n        self.next_file_id = 1\n\n    def write(self, data):\n        for i in range(len(self.sectors)):\n            if self.sectors[i] is None:\n                file_id = self.next_file_id\n                self.sectors[i] = file_id\n                self.next_file_id += 1\n                print(f\"File {file_id} written to sector {i}\")\n                return file_id\n        print(\"Storage medium is full\")\n        return None\n\n    def delete(self, file_id):\n        for i in range(len(self.sectors)):\n            if self.sectors[i] == file_id:\n                self.sectors[i] = None\n                print(f\"File {file_id} deleted from sector {i}\")\n                return True\n        print(f\"File {file_id} not found\")\n        return False\n\n    def reference(self, sector):\n        if 0 <= sector < len(self.sectors):\n            file_id = self.sectors[sector]\n            print(f\"Sector {sector} contains file {file_id}\" if file_id is not None else f\"Sector {sector} is empty\")\n            return file_id\n        print(\"Invalid sector\")\n        return None\n\ndef main():\n    storage = StorageMedium()\n    while True:\n        command = input().split()\n        if command[0] == 'W':\n            storage.write(None)\n        elif command[0] == 'D':\n            storage.delete(int(command[1]))\n        elif command[0] == 'R':\n            storage.reference(int(command[1]))\n        elif command[0] == 'Q':\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:16:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class FileSystem:\n    def __init__(self):\n        self.storage = {}\n        self.free_sectors = []\n        self.next_file_id = 1\n        self.used_sectors = set()\n\n    def write(self, size):\n        file_id = self.next_file_id\n        self.next_file_id += 1\n        allocated_sectors = []\n        \n        # Find contiguous free sectors\n        contiguous = []\n        for sector in sorted(self.free_sectors):\n            if not contiguous or sector == contiguous[-1] + 1:\n                contiguous.append(sector)\n                if len(contiguous) == size:\n                    break\n            else:\n                contiguous = [sector]\n        \n        if len(contiguous) >= size:\n            allocated_sectors = contiguous[:size]\n            for sector in allocated_sectors:\n                self.free_sectors.remove(sector)\n                self.storage[sector] = file_id\n                self.used_sectors.add(sector)\n        else:\n            # Allocate sequentially from the beginning\n            next_sector = 0\n            allocated_sectors = []\n            while len(allocated_sectors) < size:\n                while next_sector in self.used_sectors:\n                    next_sector += 1\n                allocated_sectors.append(next_sector)\n                self.storage[next_sector] = file_id\n                self.used_sectors.add(next_sector)\n                next_sector += 1\n        \n        return file_id\n\n    def delete(self, file_id):\n        sectors_to_delete = [sector for sector, fid in self.storage.items() if fid == file_id]\n        for sector in sectors_to_delete:\n            del self.storage[sector]\n            self.used_sectors.remove(sector)\n            self.free_sectors.append(sector)\n        self.free_sectors.sort()\n\n    def reference(self, sector):\n        return self.storage.get(sector, 0)\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    q = int(input[ptr])\n    ptr += 1\n    fs = FileSystem()\n    for _ in range(q):\n        cmd = input[ptr]\n        ptr += 1\n        if cmd == 'write':\n            size = int(input[ptr])\n            ptr += 1\n            print(fs.write(size))\n        elif cmd == 'delete':\n            file_id = int(input[ptr])\n            ptr += 1\n            fs.delete(file_id)\n        elif cmd == 'reference':\n            sector = int(input[ptr])\n            ptr += 1\n            print(fs.reference(sector))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:16:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nclass FileSystem {\n    std::vector<int> storage;\n    int sectorSize;\n    std::unordered_map<int, int> fileMap;\n    int nextFileId;\n\npublic:\n    FileSystem(int sectors) : storage(sectors, -1), sectorSize(sectors), nextFileId(1) {}\n\n    int write(int dataSize) {\n        int fileId = nextFileId++;\n        int required = dataSize;\n        for (int i = 0; i < sectorSize && required > 0; ++i) {\n            if (storage[i] == -1) {\n                storage[i] = fileId;\n                --required;\n            }\n        }\n        if (required > 0) return -1; // Not enough space\n        fileMap[fileId] = dataSize;\n        return fileId;\n    }\n\n    void deleteFile(int fileId) {\n        for (int i = 0; i < sectorSize; ++i) {\n            if (storage[i] == fileId) {\n                storage[i] = -1;\n            }\n        }\n        fileMap.erase(fileId);\n    }\n\n    int reference(int sector) {\n        if (sector < 0 || sector >= sectorSize) return -1;\n        return storage[sector];\n    }\n};\n\nint main() {\n    int n, q;\n    std::cin >> n >> q;\n    FileSystem fs(n);\n\n    for (int i = 0; i < q; ++i) {\n        std::string command;\n        std::cin >> command;\n        if (command == \"write\") {\n            int size;\n            std::cin >> size;\n            int fileId = fs.write(size);\n            if (fileId == -1) {\n                std::cout << \"Error: Not enough space\\n\";\n            } else {\n                std::cout << \"File ID: \" << fileId << '\\n';\n            }\n        } else if (command == \"delete\") {\n            int fileId;\n            std::cin >> fileId;\n            fs.deleteFile(fileId);\n        } else if (command == \"reference\") {\n            int sector;\n            std::cin >> sector;\n            int fileId = fs.reference(sector);\n            std::cout << fileId << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:06"
  }
]