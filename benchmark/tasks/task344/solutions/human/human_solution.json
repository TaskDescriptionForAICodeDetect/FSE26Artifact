[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nstruct data{\n\tdata(int a,int b){\n\t\tlength=a;\n\t\tid=b;\n\t}\n\tint length;\n\tint id;\n};\n\nvector<data> sys;\n\nvoid write(int id,int len){\n\tif(sys.size()==0){\n\t\tsys.push_back(data(len,id));\n\t}else{\n\t\tint n=sys.size();\n\t\trep(i,n){\n\t\t\tif(len<=0) return;\n\t\t\tif(sys.size()-1 == i && sys[i].id != -1){//????????????????´???????????????§????????¨??????????????????????????????\n\t\t\t\tsys.push_back(data(len,id));\t\n\t\t\t}else if(sys[i].id==-1){\n\t\t\t\tif(len-sys[i].length==0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}else if(len-sys[i].length<0){ //length???????????§??????\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tsys.insert(sys.begin()+i,data(len-sys[i].length,-1));\n\t\t\t\t\treturn;\n\t\t\t\t}else if(len-sys[i].length>0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid read(int id){\n\tint len=0;\n\trep(i,sys.size()){\n\t\tlen+=sys[i].length;\n\t\tif(len>=id){\n\t\t\tcout << sys[i].id << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nvoid del(int id){\n\trep(i,sys.size()){\n\t\tif(sys[i].id==id){\n\t\t\tsys[i].id=-1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tint I,S;\n\t\t\tcin >> c;\n\t\t\n\t\t\t\n//\t\t\tcout << c << endl;\n\t\t\tif(c=='D'){\n\t\t\t\tcin >> I;\n\t\t\t\tdel(I);\n\t\t\t}else if(c=='W'){\n\t\t\t\tcin >> I >> S;\n\t\t\t\twrite(I,S);\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin >> I;\n\t\t\t\tread(I);\n\t\t\t}\t\t\n\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define vecsize 170000000\nint vec[vecsize];\nvoid W(int x,int y){\n    for(int i=0;i<vecsize;++i){\n        if(y>0)if(vec[i]==-1)vec[i]=x,--y;\n    }\n}\nvoid D(int x){\n    int size=vecsize-1;\n    if(x<=size)for(int i=vecsize-1;i>=0;--i){\n        if(vec[i]==x){\n            vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vecsize;\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    for(int i=0;i<vecsize;++i){\n        vec[i]=-1;\n    }\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n        }\n        b=false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tmap<int, vector<P>> v;\n\t\tpriority_queue<P, vector<P>, greater<P>> Q;\n\t\tQ.push(P(0, 1000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring command;\n\t\t\tcin >> command;\n\t\t\tif (command == \"W\") {\n\t\t\t\tint l, S;\n\t\t\t\tcin >> l >> S;\n\t\t\t\tint sum = 0;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tP p = Q.top(); Q.pop();\n\t\t\t\t\tint len = p.second - p.first + 1;\n\t\t\t\t\tif (sum + len < S) {\n\t\t\t\t\t\tsum += len;\n\t\t\t\t\t\tv[l].push_back(p);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tv[l].push_back(P(p.first, p.first + (S - sum) - 1));\n\t\t\t\t\tQ.push(P(p.first + (S - sum), p.second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (command == \"D\") {\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor (P p : v[l]) {\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t\tv[l].clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tbool ok = 0;\n\t\t\t\tfor (auto &itr : v) {\n\t\t\t\t\tfor (P p : itr.second) {\n\t\t\t\t\t\tif (p.first <= l && l <= p.second) {\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\tcout << itr.first << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) break;\n\t\t\t\t}\n\t\t\t\tif (!ok) cout << -1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\n#include<list>\nusing namespace std;\n\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n\nstruct Packet {\n    int id, pos, len;\n};\n\nbool solve() {\n    int N; cin >> N;\n    if(N == 0) return false;\n    list<Packet> memory;\n    rep(i, N) {\n        char c; cin >> c;\n        if(c == 'W') {\n            int len, id; cin >> id >> len;\n            int pos = 0;\n            for(auto itr = memory.begin(); itr != memory.end(); itr++) {\n                if(itr->pos > pos) {\n                    int blank = itr->pos - pos;\n                    Packet p = {id, pos, min(blank, len)};\n                    memory.insert(itr, p);\n                    len -= p.len;\n                    if(len == 0) break;\n                }\n                pos = itr->pos + itr->len;\n            }\n            if(len > 0) {\n                Packet p = {id, pos, len};\n                memory.push_back(p);\n            }\n        } else if(c == 'D') {\n            int id; cin >> id;\n            for(auto itr = memory.begin(); itr != memory.end();) {\n                if(itr->id == id) itr = memory.erase(itr);\n                else itr++;\n            }\n        } else if(c == 'R') {\n            int num; cin >> num;\n            for(auto itr = memory.begin(); itr != memory.end(); itr++) {\n                if(itr->pos <= num and num < itr->pos + itr->len){\n                    cout << itr->id << endl;\n                    goto END_R;\n                }\n            }\n            cout << -1 << endl;\n      END_R:;\n        }\n    }\n    cout << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstatic const ll MAX = 1e10;\n\nenum Data {Space, File};\n\nstruct Range {\n  Data d;\n  int id;\n  ll start;\n  ll end;\n  ll size() const {\n    return end - start;\n  }\n  bool operator<(const Range& rhs) const {\n    return start < rhs.start;\n  }\n  void print() const {\n    printf(\"%c %d %lld %lld\\n\", (d == Space) ? 'S' : 'F', id, start, end);\n  }\n  Range(Data d, int id, ll start, ll end) : d(d), id(id), start(start), end(end) {}\n};\n\nint N;\nlist<Range> sector;\ntypedef list<Range> L;\n\nvoid solve() {\n  for (int i = 0; i < N; i++) {\n    char cmd;\n    cin >> cmd;\n    switch (cmd) {\n    case 'W': {\n      ll id, size;\n      cin >> id >> size;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == Space) {\n          if (it->size() >= size) {\n            Range file(File, id, it->start, it->start + size);\n            sector.insert(it, file);\n            it->start += size;\n          } else {\n            it->d = File;\n            it->id = id;\n          }\n        }\n      }\n      break;\n    }\n    case 'D': {\n      ll id;\n      cin >> id;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == File && it->id == id) {\n          L::iterator prev_it = it;\n          prev_it--;\n          \n          if (it != sector.begin() &&\n              prev_it->end == it->start && prev_it->d == Space) {\n            prev_it->end += it->size();\n            sector.erase(it);\n            break;\n          } else {\n            L::iterator next_it = it;\n            next_it++;\n            if (it != sector.end() && \n                next_it->start == it->end && next_it->d == Space) {\n              next_it->start -= it->size();\n              sector.erase(it);\n              break;\n            }\n          }\n          it->d = Space;\n        }\n      }\n      break;\n    }\n    case 'R': {\n      ll sec;\n      cin >> sec;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->start <= sec && sec < it-> end) {\n          if (it->d == Space) {\n            cout << -1 << endl;\n          } else {\n            cout << it->id << endl;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    }\n    /*\n    cout << \"debug\" << endl;\n    for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n      it->print();\n    }\n    cout << endl;\n    */\n  }\n}\n\nvoid init() {\n  sector.clear();\n  sector.push_back(Range(Space, -1, 0, MAX));\n}\n\nint main() {\n  while (true) {\n    cin >> N;\n    if (N == 0) {\n      return 0;\n    }\n    init();\n    solve();\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <map>\nusing namespace std;\nconst int INF = (int)1e9 + 7;\ntemplate <class T=int> inline T in() { T x; cin >> x; return (x); }\n\nusing pii = pair<int, int>;\nlist<pair<pii, int>> data;\nmap<int, bool> deleted;     // default = false;\n\nvoid init() {\n    data.clear();\n    data.emplace_back(pii(0, INF), -1);\n    deleted.clear();\n    deleted[-1] = true;\n}\n\nvoid write() {\n    int l = in();       // 書き込むファイルの識別子\n    int s = in();       // ファイルを記憶するのに必要とするセクタの数\n    for (auto it = data.begin(); it != data.end(); it++) {\n        pii& range = it->first;     // half-open\n        int& id = (*it).second;\n        if (!deleted[id]) continue;\n        int h = range.first, t = range.second;\n        if (t - h <= s) {\n            id = l;\n            s -= t - h;\n        } else {\n            int sep = h + s;\n            range = pii(sep, t);\n            data.insert(it, make_pair(pii(h, sep), l));\n            break;\n        }\n    }\n}\n\nvoid del() {\n    int l = in();       // 削除するファイルの識別子\n    deleted[l] = true;\n}\n\nint read() {\n    int p = in();       // 参照するセクタの番号\n    for (auto it = data.begin(); it != data.end(); it++) {\n        pii& range = it->first;     // half-open\n        int& id = (*it).second;\n        int h = range.first, t = range.second;\n        if (h <= p && p < t) {\n            return deleted[id] ? -1 : id;\n        }\n    }\n    return -1;\n}\n\nvoid print() {\n    cout << \"----- head ------\" << endl;\n    for (auto it = data.begin(); it != data.end(); it++) {\n        pii& range = it->first; int id = it->second;\n        int s = range.first, t = range.second;\n        cout << \"[\" << s << \", \" << t << \"): \" << id << endl;\n    }\n    cout << \"----- tail ------\" << endl;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        init();\n        while (n--) {\n            char com; cin >> com;\n            if (com == 'W') write();\n            if (com == 'D') del();\n            if (com == 'R') cout << read() << endl;\n        }\n        //print();\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> File;\n\nvoid debug(const vector<File>& v){\n\tcout << \"[debug]\" << endl;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint id = v[i].first;\n\t\tint L = v[i].second.first;\n\t\tint R = v[i].second.second;\n\t\tcout << \"[\" << L << \" , \" << R << \"] : \" << id << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint n;\n\tbool ini_flag = true;\n\t\n\twhile( cin >> n , n ){\n\t\t// 改行の出力\n\t\tif( ini_flag ){\n\t\t\tini_flag = false;\n\t\t}else{\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\t// [0,10^9] が 空(-1)\n\t\tFile ini( -1 , P(0,1e+9) );\n\t\tvector<File> v;\n\t\tv.push_back( ini );\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tchar command;\n\t\t\tcin >> command;\n\t\t\t\n\t\t\tif( command == 'W' ){ // 書き込み\n\t\t\t\tint l, s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\t\n\t\t\t\t// ファイル番号が小さい方(-1)でさらにセクタの番号が小さい順にソート\n\t\t\t\tsort( v.begin() , v.end() );\n\t\t\t\t// 全部書き込みが終わるまで走査\n\t\t\t\tfor(vector<File>::iterator it = v.begin() ; it != v.end() ; ++it){\n\t\t\t\t\tif( s == 0 ) break;\n\t\t\t\t\t\n\t\t\t\t\tint id = it->first;\n\t\t\t\t\tint L = it->second.first;\n\t\t\t\t\tint R = it->second.second;\n\t\t\t\t\tint width = R - L + 1;\n\t\t\t\t\tif( id != -1 ) continue;\n\t\t\t\t\t\n\t\t\t\t\t// 書き込める十分なスペースがあるとき\n\t\t\t\t\tif( s <= width ){\n\t\t\t\t\t\tv.erase( it );\n\t\t\t\t\t\tint L1 = L;\n\t\t\t\t\t\tint R1 = L + s - 1;\n\t\t\t\t\t\tint id1 = l;\n\t\t\t\t\t\tFile f1( id1 , P(L1,R1) );\n\t\t\t\t\t\tv.push_back( f1 );\n\t\t\t\t\t\tif( s != width ){\n\t\t\t\t\t\t\tint L2 = L + s;\n\t\t\t\t\t\t\tint R2 = R;\n\t\t\t\t\t\t\tint id2 = -1;\n\t\t\t\t\t\t\tFile f2( id2 , P(L2,R2) );\n\t\t\t\t\t\t\tv.push_back( f2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t}else{ // スペースが足りないときは全部埋めて次へ\n\t\t\t\t\t\tit->first = l;\n\t\t\t\t\t\ts -= width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( command == 'D' ){ // 削除\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor(vector<File>::iterator it = v.begin() ; it != v.end() ; ++it){\n\t\t\t\t\tif( it->first == l ){\n\t\t\t\t\t\tit->first = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( command == 'R' ){ // 参照\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\t\t\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\t\t\tint id = v[i].first;\n\t\t\t\t\tint L = v[i].second.first;\n\t\t\t\t\tint R = v[i].second.second;\n\t\t\t\t\tif( L <= p && p <= R ){\n\t\t\t\t\t\tcout << id << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort( v.begin() , v.end() );\n\t\t\t//debug( v );\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define ALL(a) a.begin(),a.end()\n#define EACH(it,a) for(auto it=a.begin();it!=a.end();it++)\n\n\nint main() {\n\t\n\twhile(true){\n\t\tint n;cin >> n;if(n==0)break;\n\t\tvector<pair<int,int>> segs;//right,c\n\n\t\tsegs.push_back(make_pair(0,-1));segs.push_back(make_pair(1e9+50,-1));\n\t\tvector<int> ls;\n\t\tls.push_back(0);ls.push_back(1e9+50);\n\n\t\tREP(i,n){\n\t\t\tstring s;cin >> s;\n\t\t\tif(s==\"W\"){\n\t\t\t\tint l,s;cin >> l >> s;\n\t\t\t\t\n\t\t\t\tfor(int j=1;j<segs.size();j++)if(segs[j].second==-1){\n\t\t\t\t\tif(s<segs[j].first-segs[j-1].first){//set\n\t\t\t\t\t\tpair<int,int> p=make_pair(segs[j-1].first+s,l);\n\t\t\t\t\t\tsegs.push_back(p);\n\t\t\t\t\t\tls.push_back(p.first);\n\t\t\t\t\t\tsort(ALL(segs));sort(ALL(ls));break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ts-=segs[j].first;\n\t\t\t\t\t\tsegs[j].second=l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s==\"D\"){\n\t\t\t\tint l;cin >> l;\n\t\t\t\tfor(int j=1;j<segs.size();j++)if(segs[j].second==l){\n\t\t\t\t\tsegs[j].second=-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint p;cin >> p;\n\t\t\t\t\n\t\t\t\tint vi=upper_bound(ALL(ls),p)-ls.begin();\n\t\t\t\tcout << segs[vi].second <<endl;\n\t\t\t}\n\t\t}\n\t\tcout <<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\n// const int inf = 1e9;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\n\nstruct Range {\n    int l, r; // [l, r)\n    int no;\n    Range(){}\n    Range(int _l, int _r, int _no) : l(_l), r(_r), no(_no) {}\n    bool operator<( const Range& right ) const {\n        if (l != right.l) return l < right.l;\n        if (r != right.r) return r < right.r;\n        return no < right.no;\n    }\n    void print() {\n        cout << l << \" \" << r << \" \" << no << endl;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        set<Range> st;\n        st.insert(Range(-inf, 0, -1));\n        st.insert(Range(inf - 1, inf, -1));\n\n        rep(i, n) {\n            char mode;\n            cin >> mode;\n            if (mode == 'W') {\n                int no, len;\n                cin >> no >> len;\n                for (auto it = st.begin(); next(it) != st.end() && len > 0; it++) {\n                    int len_here = min(len, next(it)->l - it->r);\n                    if (len_here > 0) {\n                        it = st.insert(Range(it->r, it->r + len_here, no)).first;\n                        len -= len_here;\n                    }\n                }\n            } else if (mode == 'D') {\n                int no;\n                cin >> no;\n                for (auto it = st.begin(); it != st.end(); ) {\n                    if (it->no == no) {\n                        it = st.erase(it);\n                    } else {\n                        it++;\n                    }\n                }\n            } else if (mode == 'R') {\n                int pos;\n                cin >> pos;\n                auto it = st.upper_bound(Range(pos, inf, inf));\n                it--;\n                cout << (pos < it->r ? it->no : -1) << endl;\n            }\n\n        }\n\n        // end of data\n        cout << endl;\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.*;\n\nclass Main\n{\n\n  \n\n    public static void main(String args[])\n    {\n\tScanner in = new Scanner(System.in);\n\tint N;\n\twhile(true)\n\t    {\n\t\tN = in.nextInt();\n\t\tif(N == 0)break;\n\t\tLinkedList<P> list = new LinkedList<P>();\n\t\tlist.add(new P(0,0,-1));\n\n\t\tString c;\n\t\tint I,S;\n\t\tfor(int i=0;i<N;i++)\n\t\t    {\n\t\t\tc = in.next();\n\t\t\tif(c.equals(\"W\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tS = in.nextInt();\n\t\t\t\tfor(int j=0;j<list.size()-1;j++)\n\t\t\t\t    {\t\n\t\t\t\t\tint v1 = list.get(j).r;\n\t\t\t\t\tint v2 = list.get(j+1).l;\n\t\t\t\t\tif(v1 == v2)continue;\n\t\t\t\t\t//System.out.println(\"add ! \" + j + \" \" + v1 + \" \" + v2);\n\t\t\t\t\tlist.add(j+1,new P(v1,Math.min((v2-v1)+v1,v1+S),I) ); \n\t\t\t\t\tS -= (v2-v1);\n\t\t\t\t\tif(S < 0)S = 0;\n\n\t\t\t\t\tif(S == 0)break;\n\t\t\t\t    }\n\t\t\t\tif(S != 0)\n\t\t\t\t    {\n\n\t\t\t\t\t\tint lass = (list.size()-1 >= 0?list.get(list.size()-1).r:0);\n\t\t\t\t\t\tlist.add(new P(lass,lass+S,I));\n\n\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t    }\n\t\t\telse if(c.equals(\"D\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tint v = list.get(j).id;\n\t\t\t\t\tif(v == I)\n\t\t\t\t\t    {\n\t\t\t\t\t\tP p = list.remove(j);\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tboolean found = false;\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tP p = list.get(j);\n\t\t\t\t\tif(p.l <= I && I < p.r)\n\t\t\t\t\t    {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tSystem.out.println(p.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\tif(!found)System.out.println(-1);\n\t\t\t    }\n\t\t\t/*\n\t\t\tSystem.out.println(\"------------\");\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tSystem.out.println(list.get(j).l + \" - \" +list.get(j).r + \" : \" + list.get(j).id);\n\t\t\t    }\n\t\t\tSystem.out.println(\"------------\");\n\t\t\t*/\n\t\t    }\n\t    }\n    }\n}\n\nclass P\n{\n    public int r,l,id;\n    P(int rl,int rr,int rid)\n    {\n\tr = rr;\n\tl = rl;\n\tid = rid;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing P=pair<int,int>;\nusing PP=pair<P,int>;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<PP>data;\n        for(int j=0;j<n;++j){\n            char c;cin>>c;\n            if(c=='W'){\n                int l,s;cin>>l>>s;\n                int siz=data.size();\n                for(int i=0;i<siz;++i){\n                    if(data[i].second==-1){\n                        if(s>=data[i].first.second-data[i].first.first){\n                            s-=(data[i].first.second-data[i].first.first);\n                            data[i].second=l;\n                            if(!s)break;\n                        }else{\n                            data.push_back(PP(P(data[i].first.first,data[i].first.first+s),l));\n                            data[i].first.first+=s;\n                            break;\n                        }\n                    }\n                    else if(i==(siz-1)){\n                        data.push_back(PP(P(data[i].first.second,data[i].first.second+s),l));\n                        s=0;\n                    }\n                }\n                if(s>0)data.push_back(PP(P(0,s),l));\n                sort(data.begin(),data.end());\n            }else if(c=='D'){\n                int l;cin>>l;\n                for(int i=0;i<data.size();++i){\n                    if(data[i].second==l){\n                        data[i].second=-1;\n                    }\n                }\n            }else{\n                int p,ans=-1;cin>>p;\n                for(int i=0;i<data.size();++i){\n                    if(data[i].first.first<=p && data[i].first.second>p){\n                        ans=data[i].second;\n                    }\n                }\n                cout<<ans<<endl;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\n\nstruct Point {\n\tint first;\n\tint len;\n\tint sikibetu_id;\n};\nvector<Point> sys;\n\nint read_sys(int real_i) {\n\trep(i,sys.size()) {\n\t\tint first = sys[i].first;\n\t\tint last = first + sys[i].len;\n\t\tif (first <= real_i && real_i < last) {\n\t\t\treturn sys[i].sikibetu_id;\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid delete_sys(int siki) {\n\trep(i,sys.size()) {\n\t\tif (sys[i].sikibetu_id == siki) {\n\t\t\tsys.erase(sys.begin() + i); //i???????´??????????\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid write_sys(int siki, int len) {\n\tint tune_index = 0;\n\trep(i,sys.size()) {\n\t\tif (tune_index != sys[i].first) {\n\t\t\t//tune_index <= hoge <= sys[i].first??????????????£???\n\t\t\tint between = (sys[i].first - tune_index);\n\n\t\t\tif (between >= len) {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=len;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen=0; //0\n\t\t\t}\n\t\t\telse {\n\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=between;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen-=between;\n\t\t\t}\n\t\t}\n\t\ttune_index += sys[i].len;\n\t}\n\n\tif (len > 0) {\n\t\tPoint p;\n\t\tp.first=tune_index;\n\t\tp.len=len;\n\t\tp.sikibetu_id=siki;\n\t\tsys.push_back(p);\n\t}\n\n}\n\nvoid show() {\n\tdump(\"-------\");\n\trep(i,sys.size()) {\n\t\tdump(sys[i].first);\n\t\tdump(sys[i].len);\n\t\tdump(sys[i].sikibetu_id);\n\t}\n}\n\nint main() {\n\tint N;\n\tchar command;\n\tint arg1,arg2;\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tsys.clear();\n\t\trep(i,N) {\n\t\t\tcin >> command;\n\t\t\t//dump(command);\n\t\t\tif (command == 'R') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tcout << read_sys(arg1) << endl;\n\t\t\t}\n\t\t\telse if (command == 'D') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tdelete_sys(arg1);\n\t\t\t}\n\t\t\telse if (command == 'W') {\n\t\t\t\tcin >> arg1 >> arg2;\n\t\t\t\twrite_sys(arg1,arg2);\n\t\t\t}\n\t\t\tshow();\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#define LL long long\nusing namespace std;\nstruct R{\n\tLL cost;\n\tLL st;\n\tLL id;\n};\n\nint main(){\n\twhile (true){\n\t\tLL n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tlist<R> storage;\n\t\tstorage.emplace_back(R{1ll << 60, 0, -1});\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tchar command;\n\t\t\tcin >> command;\n\t\t\tif ('W' == command){\n\t\t\t\tLL l,s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\tfor (auto it = storage.begin(); it != storage.end(); ++it){\n\t\t\t\t\tif (it->id != -1) continue;\n\t\t\t\t\tif(it->cost - s > 0){\n\t\t\t\t\t\tauto cost = it->cost;\n\t\t\t\t\t\tauto st = it->st;\n\n\t\t\t\t\t\tit->cost = s;\n\t\t\t\t\t\tit->id = l;\n\n\t\t\t\t\t\t++it;\n\t\t\t\t\t\tstorage.insert(it, R{ cost - s, st + s, -1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts -= it->cost;\n\t\t\t\t\t\tit->id = l;\n\t\t\t\t\t\tif (s == 0) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ('R' == command){\n\t\t\t\tLL p;\n\t\t\t\tcin >> p;\n\n\t\t\t\tfor (auto it = storage.begin(); it != storage.end(); ++it){\n\t\t\t\t\tif (it->st <= p && it->st + it->cost > p){\n\t\t\t\t\t\tcout << it->id << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL l;\n\t\t\t\tcin >> l;\n\n\t\t\t\tfor (auto it = storage.begin(); it != storage.end(); ++it){\n\t\t\t\t\tif(it->id==l) it->id = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint N, I, S, P;\n\tchar com;\n\tmap<int, int>::iterator it;\n\t\n\twhile(cin >> N, N){\n\t\tmap<int,int> data;\n\t\tdata.insert( make_pair(0, -1) );\n\t\tdata.insert( make_pair(1000000001, -2) );\n\t\twhile(N--){\n\t\t\tcin >> com;\n\t\t\tswitch( com ){\n\t\t\t\tcase 'W':\n\t\t\t\t\tcin >> I >> S;\n\t\t\t\t\tfor(it = data.begin(); it!=data.end();){\n\t\t\t\t\t\tif( it->second == -1 ){\n\t\t\t\t\t\t\tint b = it->first;\n\t\t\t\t\t\t\tit->second = I;\n\t\t\t\t\t\t\tit++;\n\t\t\t\t\t\t\tif( it->first - b > S ){\n\t\t\t\t\t\t\t\tdata.insert( make_pair(b+S, -1) );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if( it->first - b == S ){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tS -= it->first - b;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else it++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tcin >> I;\n\t\t\t\t\tfor(it = data.begin(); it!=data.end(); it++){\n\t\t\t\t\t\tif( it->second == I )\n\t\t\t\t\t\t\tit->second = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tcin >> P;\n\t\t\t\t\tint ans = -1;\n\t\t\t\t\tfor(it = data.begin(); it!=data.end(); it++){\n\t\t\t\t\t\tif( it->first <= P )\n\t\t\t\t\t\t\tans = it->second;\n\t\t\t\t\t}\n\t\t\t\t\tcout << ans << endl;\n\t\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tcout << \"command comp\" << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint N;\n //<(????§???????????????????(0~), ????????????????????????), ???>\npair< pair<int, int>, int > disk[20005];\n\nint main() {\n  bool first = true;\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    if(!first){\n      cout<<endl;\n    }else{\n      first = false;\n    }\n    REP(i,0,20005) disk[i] = make_pair(make_pair(INF,INF), INF);\n    disk[0] = make_pair(make_pair(0,1000000001), -1);  //-1:empty\n    REP(i,0,N){\n      string com, inp1, inp2;\n      int num, len, ind;\n      cin>>com;\n      if(com==\"W\"){ /*?????????*/\n        cin>>inp1>>inp2;\n        num = stoi(inp1);\n        len = stoi(inp2);\n        REP(k,0,20005){\n          if(len==0) break;\n          if(disk[k].S == -1){\n            int tl = disk[k].F.S-disk[k].F.F+1;\n            if(len >= tl){\n              disk[k].S = num;\n              len -= tl;\n            }else{\n              //??°????´???????\n              int tmp = disk[k].F.F;\n              disk[k].F.F = disk[k].F.F+len;\n              RREP(l,k+1,20005){\n                disk[l] = disk[l-1];\n              }\n              disk[k] = make_pair(make_pair(tmp, tmp+len-1), num);\n              len = 0;\n            }\n          }\n        }\n      }else if(com==\"D\"){ /*??????*/\n        cin>>inp1;\n        num = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].S==num) disk[k].S = -1;\n        }\n      }else{ /*????????????*/\n        cin>>inp1;\n        ind = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].F.F <= ind && ind <= disk[k].F.S){\n            cout<<disk[k].S<<endl;\n            break;\n          }\n        }\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n        if(n == 0)break;\n        \n        set<P1> S1;\n        set<P1> S2;\n        S1.insert(mp1(0,-1,1000000001));\n        S2.insert(mp1(-1,0,1000000001));\n        \n        for(int i = 0 ; i < n ; i ++){\n            char c;\n            scanf(\"\\n%c\",&c);\n            if(c == 'W'){\n                int l,s;\n                scanf(\"%d%d\",&l,&s);\n                set<P1>::iterator itr = S2.lower_bound(mp1(-1,0,0));\n                while(1){\n                    if(itr->sc.sc > s){\n                        S1.insert(mp1(itr->sc.fr,l,s));\n                        S1.insert(mp1(itr->sc.fr+s,itr->fr,itr->sc.sc-s));\n                        S1.erase(mp1(itr->sc.fr,itr->fr,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,s));\n                        S2.insert(mp1(itr->fr,itr->sc.fr+s,itr->sc.sc-s));\n                        S2.erase(itr);\n                        break;\n                    }\n                    else {\n                        S1.insert(mp1(itr->sc.fr,l,itr->sc.sc));\n                        S1.erase(mp1(itr->sc.fr,-1,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,itr->sc.sc));\n                        S2.erase(itr++);\n                        s -= itr->sc.sc;\n                    }\n                    if(s == 0)break;\n                }\n            }\n            else if(c == 'D'){\n                int l;\n                scanf(\"%d\",&l);\n                set<P1>::iterator itr = S2.lower_bound(mp1(l,0,0));\n                while(1){\n                    S1.insert(mp1(itr->sc.fr,-1,itr->sc.sc));\n                    S1.erase(mp1(itr->sc.fr,l,itr->sc.sc));\n                    S2.insert(mp1(-1,itr->sc.fr,itr->sc.sc));\n                    S2.erase(itr++);\n                    if(itr->fr != l)break;\n                }\n            }\n            else {\n                int p;\n                scanf(\"%d\",&p);\n                set<P1>::iterator itr = S1.upper_bound(mp1(p,-1,0));\n                printf(\"%d\",(--itr)->sc.fr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli pos, size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    v.push_back((Data){0,1,-99});\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i+1 < v.size(); ++i) {\n          lli t = min(S, v[i+1].pos - (v[i].pos + v[i].size));\n          S -= t;\n          v.insert(v.begin()+i+1, (Data){v[i].pos + v[i].size, t, l});\n          ++i;\n        }\n        if(S) {\n          v.push_back((Data){v.back().pos + v.back().size, S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(vector<Data>::iterator it = v.begin();\n            it != v.end(); ++it) {\n          if(it->id == l) {\n            it = v.erase(it);\n            --it;\n          }\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        bool flag = false;\n        for(int i = 0; i < v.size(); ++i) {\n          if(v[i].pos <= P && P < v[i].pos + v[i].size) {\n            flag = true;\n            cout << v[i].id << endl;\n          }\n        }\n        if(!flag) cout << -1 << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].pos << \" \" << v[i].size << \" \" << v[i].id << endl;\n      }\n      cout << \"------------------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<int,lli> P;\n\nconst lli INF = (1LL<<49);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int a;\n    lli b,cnt;\n    char c;\n    vector<P> v;\n    v.push_back(P(-1,INF));\n    for(int i=0;i<n;i++){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[j].first == -1){\n\t    if(b >= v[j].second){\n\t      v[j].first = a;\n\t      b -= v[j].second;\n\t      if(b == 0) break;\n\t    } else {\n\t      v.insert(v.begin()+j,P(a,b));\n\t      v[j+1].second -= b;\n\t      break;\n\t    }\n\t  }\n\t}\n      } else if(c == 'D'){\n\tcin >> a;\n\tfor(int j=0;j<v.size();j++) if(v[j].first == a) v[j].first = -1;\n      } else if(c == 'R'){\n\t//for(int j=0;j<v.size();j++) cout << v[j].first << ' ' << v[j].second << endl;\n\tcin >> b;\n\tcnt = 0;\n\tfor(int j=0;j<v.size();j++){\n\t  cnt += v[j].second;\n\t  if(cnt > b){\n\t    cout << v[j].first << endl;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<pair<int,int> ,int> M;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='W'){\n\t\t\t\tint b,c;\n\t\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\t\tfor(map<pair<int,int>,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif(c<=0)break;\n\t\t\t\t\tpair<pair<int,int>,int> dat=*it;\n\t\t\t\t\tif((*it).second==-1){\n\t\t\t\t\t\tif(c>=(*it).first.second-(*it).first.first){\n\t\t\t\t\t\t\tc-=(*it).first.second-(*it).first.first;\n\t\t\t\t\t\t\tM[(*it).first]=b;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tM[make_pair((*it).first.first,(*it).first.first+c)]=b;\n\t\t\t\t\t\t\tM[make_pair((*it).first.first+c,(*it).first.second)]=-1;\n\t\t\t\t\t\t\tM.erase((*it).first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c>0){\n\t\t\t\t\tif(M.size()==0)M[make_pair(0,c)]=b;\n\t\t\t\t\telse{\n\t\t\t\t\t\tint p=((*(M.rbegin())).first.second);\n\t\t\t\t\t\tM[make_pair(p,p+c)]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='D'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tfor(map<pair<int,int>,int>::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif((*it).second==b){\n\t\t\t\t\t\tM[(*it).first]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='R'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tbool found=false;\n\t\t\t\tfor(map<pair<int,int> ,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tpair<int,int> q=(*it).first;\n\t\t\t\t\tif(q.first<b&&b<=q.second){\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).second);\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found)printf(\"%d\\n\",-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n\nvector<tuple<int, int, int> > fs;\n\nvoid writefs(int I, int S){\n    for(int i=1; i<(int)fs.size(); ++i){\n        if(1 < get<0>(fs[i]) - get<1>(fs[i-1])){\n            int fw = get<1>(fs[i-1]) + 1, sp = get<0>(fs[i]) - get<1>(fs[i-1]) - 1;\n            fs.insert(fs.begin() + i, make_tuple(fw, fw + min(sp, S) - 1, I));\n            S -= sp;\n            if(S <= 0)return;\n        }\n    }\n    int fw = get<1>(fs.back()) + 1;\n    fs.push_back(make_tuple(fw, fw + S - 1, I));\n}\n\nvoid deletefs(int I){\n    fs.erase(remove_if(all(fs), [&](tuple<int, int, int> &t){return get<2>(t) == I;}), fs.end());\n}\n\nvoid readfs(int P){\n    for(int i=1; i<(int)fs.size(); ++i){\n        if(get<0>(fs[i]) <= P && P <= get<1>(fs[i])){\n            cout << get<2>(fs[i]) << '\\n';\n            return;\n        }\n    }\n    cout << \"-1\\n\";\n}\n\nint main(){\n    for(int N; cin >> N, N; cout << '\\n'){\n        cin.ignore();\n        fs.clear();\n        fs.push_back(make_tuple(-1, -1, -1));\n        while(N--){\n            char c;\n            cin >> c;\n            if(c == 'W'){\n                int I, S;\n                cin >> I >> S;\n                writefs(I, S);\n            }\n            if(c == 'D'){\n                int I;\n                cin >> I;\n                deletefs(I);\n            }\n            if(c == 'R'){\n                int P;\n                cin >> P;\n                readfs(P);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1<<60\n\ntypedef pair<long long int, long long int> PII;\ntypedef vector<PII> VPII;\n\nint main() {\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tmap<long long int, VPII> M;\n\t\t//priority_queue<PII, VPII, greater<PII>>que;\n\t\t//que.push( make_pair( 0, 1LL << INF ) );\n\t\tVPII vque;\n\t\tvque.push_back( make_pair( 0, 1LL << INF ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif( c == 'W' ) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\twhile( b ) {\n\t\t\t\t\t//PII now = que.top(); que.pop();\n\t\t\t\t\tPII vnow = *vque.rbegin(); vque.pop_back();\n\t\t\t\t\tif( b < vnow.second - vnow.first ) {\n\t\t\t\t\t\tvque.push_back( make_pair( vnow.first + b, vnow.second ) );\n\t\t\t\t\t\tM[a].push_back( make_pair( vnow.first, vnow.first + b - 1 ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else if( b == vnow.second - vnow.first ) {\n\t\t\t\t\t\tM[a].push_back( make_pair( vnow.first, vnow.second ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM[a].push_back( make_pair( vnow.first, vnow.second ) );\n\t\t\t\t\t\tb -= vnow.second - vnow.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if( c == 'D' ) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor( auto x : M[a] ) {\n\t\t\t\t\t//que.push( x );\n\t\t\t\t\tvque.push_back( x );\n\t\t\t\t}\n\t\t\t\tM[a].clear();\n\t\t\t} else {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tbool f = 0;\n\t\t\t\tfor( auto x : M ) {\n\t\t\t\t\tfor( auto y : x.second ) {\n\t\t\t\t\t\tif( y.first <= a &&a <= y.second ) {\n\t\t\t\t\t\t\tcout << x.first << endl;\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( f ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !f ) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<ll, ll>;\n\nconstexpr ll inf = 1e18;\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<char> com(n);\n    vector<ll> id(n, -1), S(n, -1), p(n, -1);\n    set<pii> pool = { make_pair(0, inf) };\n    for(int i = 0; i < n; ++i) {\n      cin >> com[i];\n      if(com[i] == 'W') {\n        cin >> id[i] >> S[i];\n      } else if(com[i] == 'D') {\n        cin >> id[i];\n      } else {\n        cin >> p[i];\n      }\n    }\n    map<pii, int> seg_to_id;\n    map<int, vector<pii>> segs; // id -> seg\n    for(int i = 0; i < n; ++i) {\n      if(com[i] == 'W') {\n        vector<pii> erased;\n        for(auto s : pool) {\n          if(s.second - s.first > S[i]) {\n            pool.emplace(s.first + S[i], s.second);\n            segs[id[i]].emplace_back(s.first, s.first + S[i]);\n            seg_to_id[segs[id[i]].back()] = id[i];\n            S[i] = 0;\n          } else {\n            S[i] -= s.second - s.first;\n            segs[id[i]].push_back(s);\n            seg_to_id[s] = id[i];\n          }\n          erased.push_back(s);\n          if(S[i] == 0) break;\n        }\n        for(auto e : erased) {\n          pool.erase(e);\n        }\n      } else if(com[i] == 'D') {\n        for(auto x : segs[id[i]]) {\n          seg_to_id.erase(x);\n        }\n        pool.insert(begin(segs[id[i]]), end(segs[id[i]]));\n        segs[id[i]].clear();\n      } else {\n        auto it = seg_to_id.lower_bound(make_pair(p[i], -1));\n        if(it != end(seg_to_id) && it->first.first == p[i]) {\n          cout << it->second << endl;\n        } else if(it != begin(seg_to_id)) {\n          it--;\n          if(it->first.first <= p[i] && p[i] < it->first.second) {\n            cout << it->second << endl;\n          } else {\n            cout << -1 << endl;\n          }\n        } else {\n          cout << -1 << endl;\n        }\n      }\n      //cout << \"debug seg_to_id: \" << endl;\n      //for(auto& p : seg_to_id) {\n      //  cout << p.first.first << ' ' << p.first.second << ' ' << p.second << endl;\n      //}\n      //cout << \"debug pool: \" << endl;\n      //for(auto& s : pool) {\n      //  cout << s.first << ' ' << s.second << endl;\n      //}\n      //cout << \"segs: \" << endl;\n      //for(auto& p : segs) {\n      //  cout << p.first << \" -> \" << endl;\n      //}\n    }\n    cout << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define V vector<pair<pair<int,int>,int> >\nusing namespace std;\nint main(){\n  int n;\n  while(cin >>n,n){\n    V code;\n    code.push_back(make_pair(make_pair(0,1000000000),-1));\n    for(int i=0; i<n; i++){\n      string s;\n      int a,b;\n      cin >>s>>a;\n      if(s == \"W\"){\n\tcin >>b;\n\tfor(int i=0; i<code.size(); i++){\n\t  if(code[i].second == -1){\n\t    int start = code[i].first.first;\n\t    int size = code[i].first.second-start+1;\n\t    if(size>b){\n\t      code[i].first.first = start+b;\n\t      code.push_back(make_pair(make_pair(start,start+b-1),a));\n\t      sort(code.begin(),code.end());\n\t      break;\n\t    }\n\t    else{\n\t      code[i].second = a;\n\t      b-=size;\n\t      if(b == 0) break;\n\t    }\n\t  }\n\t}\n      }\n      if(s == \"D\") for(int i=0; i<code.size(); i++) if(code[i].second == a) code[i].second = -1;\n      if(s == \"R\") for(int i=0; i<code.size(); i++) if(code[i].first.first<=a && code[i].first.second>=a){cout <<code[i].second<<endl;}\n    }\n    cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef vector<P>::iterator ITE;\nstruct data{\n  ll num;\n  vector<P> MEM;\n  data(){}\n  data(int n,vector<P> m):num(n),MEM(m){}\n  bool operator < (const data& d) const {return num < d.num;}\n};\n\nconst ll MAX = 10000000000000LL;\nvector<P> Free;\nvector<data> V;\n\nvoid init(){\n\n  Free.clear();\n  Free.push_back(P(0,MAX));\n  V.clear();\n\n}\n\nvoid write(ll a, ll b){\n  sort(Free.begin(),Free.end());\n  vector<P> tmp;\n\n  for(int i = 0; i < (int)Free.size(); i++){\n    if(Free[i].second-Free[i].first+1 > b){\n      tmp.push_back(P(Free[i].first, Free[i].first+b-1));\n      Free[i].first += b;\n      break;\n    }else{\n      tmp.push_back(Free[i]);\n      b -= Free[i].second-Free[i].first+1;\n      vector<P>::iterator ite = (ITE)&Free[i];\n      Free.erase(ite);\n      i--;\n    }\n  }\n  V.push_back(data(a,tmp));\n}\n\nvoid del(ll num){\n\n  sort(V.begin(),V.end());\n  vector<data>::iterator ite = lower_bound(V.begin(),V.end(),data(num,vector<P>()));\n  if(ite->num != num) assert(false);\n\n  for(int i = 0; i < (int)ite->MEM.size(); i++)\n    Free.push_back(ite->MEM[i]);\n\n  V.erase(ite);\n\n}\n\nvoid ref(ll num){\n  for(int i = 0; i < (int)V.size(); i++){\n    vector<P> tmp = V[i].MEM;\n    for(int j = 0; j < (int)tmp.size(); j++){\n      if(tmp[j].first <= num && num <= tmp[j].second){\n\tcout << V[i].num << endl;\n\treturn;\n      }\n    }\n  }\n  \n  cout << \"-1\" << endl;\n}\n\nint main(){\n  int n;\n\n  while(cin >> n && n){\n  \n    init();\n    while(n--){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n\tll a,b;\n\tcin >> a >> b;\n\twrite(a,b);\n      }\n\n      if(c == 'D'){\n\tll a;\n\tcin >> a;\n\tdel(a);\n      }\n\n      if(c == 'R'){\n\tll a;\n\tcin >> a;\n\tref(a);\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nmap<pair<int, int>, int> reserved;\nset<pair<int, int> > open;\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    reserved.clear();\n    open.clear();\n    open.insert(make_pair(0, 1000000000));\n    REP(iter, n) {\n      char c;\n      scanf(\" %c \", &c);\n      if (c == 'W') {\n        int id, s;\n        scanf(\"%d %d\", &id, &s);\n        set<pair<int, int> >::iterator it = open.begin();\n        while (s > 0) {\n          int u = min(s, it->second);\n          reserved[make_pair(it->first, u)] = id;\n          s -= u;\n          if (u < it->second) {\n            int nstart = it->first + u;\n            int width = it->second - u;\n            open.erase(it++);\n            open.insert(make_pair(nstart, width));\n          } else {\n            open.erase(it++);\n          }\n        }\n      } else if (c == 'D') {\n        int id;\n        scanf(\"%d\", &id);\n        map<pair<int, int>, int>::iterator it = reserved.begin();\n        while (it!= reserved.end()) {\n          if (it->second == id) {\n            open.insert(make_pair(it->first.first, it->first.second));\n            reserved.erase(it++);\n          } else {\n            it++;\n          }\n        }\n      } else {\n        int p;\n        scanf(\"%d\", &p);\n        FORIT(it, reserved) {\n          int s = it->first.first;\n          int l = it->first.second;\n          if (s <= p && p < s + l) {\n            printf(\"%d\\n\", it->second);\n            goto next;\n          }\n        }\n        puts(\"-1\");\nnext:;\n      }\n    }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/04 12:38:03\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    for (int N;;) {\n        cin >> N;\n        if (N == 0) { break; }\n        using P = pair<int, int>;\n        map<int, vector<P>> reg;\n        set<P> empty;\n        constexpr int INF = 1000000000;\n        empty.insert({0, INF});\n        auto sz = [](const P& p) { return p.second - p.first+1; };\n        for (int i = 0; i < N; i++) {\n            char c;\n            cin >> c;\n            if (c == 'W') {\n                int l, s;\n                cin >> l >> s;\n                vector<P> rem;\n                for (const auto& p : empty) {\n                    if (sz(p) <= s) {\n                        s -= sz(p), rem.push_back(p), reg[l].push_back(p);\n                    } else {\n                        rem.push_back(p), empty.insert({p.first + s, p.second}), reg[l].push_back({p.first, p.first + s - 1}), s = 0;\n                    }\n                    if (s == 0) { break; }\n                }\n                for (const auto& r : rem) { empty.erase(r); }\n            } else if (c == 'D') {\n                int l;\n                cin >> l;\n                for (const auto& r : reg[l]) { empty.insert(r); }\n                reg.erase(l);\n            } else {\n                int P;\n                cin >> P;\n                bool found = false;\n                for (const auto& vs : reg) {\n                    if (found) { break; }\n                    const int r = vs.first;\n                    const auto& v = vs.second;\n                    for (const auto& p : v) {\n                        if (p.first <= P and P <= p.second) {\n                            found = true, cout << r << endl;\n                            break;\n                        }\n                    }\n                }\n                if (not found) { cout << -1 << endl; }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                    if(len == 0) break;\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(list<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.push_front({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.push_back({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.push_front({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert(it,{prev->l,prev->l+t,id});\n            \n            cnt-=t;\n        }\n        if(cnt<=0) return;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.push_back({it->r,it->r+cnt,id});\n    \n}\ntemplate<class T>\nvoid dump(T range) {\n    for(auto &e : range) {\n        cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n    }\n}\nvoid solve() {\n    list<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                else it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint Q;\ntypedef pair<i_i, int> iii;\nvector<iii> V;\n\nvoid f() {\n    int l, p;\n    cin >> p >> l;\n    vector<iii> W;\n    W.push_back({{-1, -1}, -1});\n    for(int i = 1; i < V.size(); i++) {\n        int delta = V[i].first.first - V[i-1].first.second - 1;\n        chmin(delta, l);\n        if(delta > 0) {\n            l -= delta;\n            W.push_back({{V[i-1].first.second + 1, V[i-1].first.second + delta}, p});\n        }\n        W.push_back(V[i]);\n    }\n    if(l != 0) {\n        W.push_back({{V.back().first.second + 1, V.back().first.second + l}, p});\n    }\n    swap(W, V);\n}\n\nvoid g() {\n    vector<iii> W;\n    int idx;\n    cin >> idx;\n    for(auto tmp : V) {\n        if(tmp.second != idx) {\n            W.push_back(tmp);\n        }\n    }\n    swap(W, V);\n}\n\nvoid h() {\n    int ans = -1;\n    int idx;\n    cin >> idx;\n    for(auto tmp : V) {\n        if(tmp.first.first <= idx and idx <= tmp.first.second) {\n            ans = tmp.second;\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        V.clear();\n        V.push_back({{-1, -1}, -1});\n        cin >> Q;\n        if(Q == 0) break;\n        while(Q--) {\n            char a;\n            cin >> a;\n            if(a == 'W') f();\n            if(a == 'D') g();\n            if(a == 'R') h();\n            /*\n            cerr << \"---------\" << endl;\n            for(auto tmp : V) {\n                cerr << tmp.second << \"[\" << tmp.first.first << \", \" << tmp.first.second << \"]\" << endl;\n            }\n            */\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tk&&m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 100100\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    { \n\t\t      assert(false);\n\t\t      cerr << c << \" \" << l << \" \" << s << endl; \n\t\t    }\n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstatic const ll MAX = 1e10;\n\nenum Data {Space, File};\n\nstruct Range {\n  Data d;\n  int id;\n  ll start;\n  ll end;\n  ll size() const {\n    return end - start;\n  }\n  bool operator<(const Range& rhs) const {\n    return start < rhs.start;\n  }\n  void print() const {\n    printf(\"%c %d %lld %lld\\n\", (d == Space) ? 'S' : 'F', id, start, end);\n  }\n  Range(Data d, int id, ll start, ll end) : d(d), id(id), start(start), end(end) {}\n};\n\nint N;\nlist<Range> sector;\ntypedef list<Range> L;\n\nvoid solve() {\n  for (int i = 0; i < N; i++) {\n    char cmd;\n    cin >> cmd;\n    switch (cmd) {\n    case 'W': {\n      ll id, size;\n      cin >> id >> size;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == Space) {\n          if (it->size() >= size) {\n            Range file(File, id, it->start, it->start + size);\n            sector.insert(it, file);\n            it->start += size;\n          } else {\n            it->d = File;\n            it->id = id;\n            size -= it->size();\n          }\n        }\n      }\n      break;\n    }\n    case 'D': {\n      ll id;\n      cin >> id;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == File && it->id == id) {\n          L::iterator prev_it = it;\n          prev_it--;\n          \n          if (it != sector.begin() &&\n              prev_it->end == it->start && prev_it->d == Space) {\n            prev_it->end += it->size();\n            it = sector.erase(it);\n            goto next;\n          } else {\n            L::iterator next_it = it;\n            next_it++;\n            if (it != sector.end() && \n                next_it->start == it->end && next_it->d == Space) {\n              next_it->start -= it->size();\n              it = sector.erase(it);\n              goto next;\n            }\n          }\n          it->d = Space;\n        next:;\n        }\n      }\n      break;\n    }\n    case 'R': {\n      ll sec;\n      cin >> sec;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->start <= sec && sec < it-> end) {\n          if (it->d == Space) {\n            cout << -1 << endl;\n          } else {\n            cout << it->id << endl;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    }\n    /*\n    cout << \"debug\" << endl;\n    for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n      it->print();\n    }\n    cout << endl;\n    */\n  }\n}\n\nvoid init() {\n  sector.clear();\n  sector.push_back(Range(Space, -1, 0, MAX));\n}\n\nint main() {\n  while (true) {\n    cin >> N;\n    if (N == 0) {\n      return 0;\n    }\n    init();\n    solve();\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define ALL(a) a.begin(),a.end()\n#define EACH(it,a) for(auto it=a.begin();it!=a.end();it++)\n\n\nint main() {\n\t\n\twhile(true){\n\t\tint n;cin >> n;if(n==0)break;\n\t\tvector<pair<int,int>> segs;//right,c\n\n\t\tsegs.push_back(make_pair(0,-1));segs.push_back(make_pair(1e9+50,-1));\n\t\tvector<int> ls;\n\t\tls.push_back(0);ls.push_back(1e9+50);\n\n\t\tREP(i,n){\n\t\t\tstring s;cin >> s;\n\t\t\tif(s==\"W\"){\n\t\t\t\tint l,s;cin >> l >> s;\n\t\t\t\t\n\t\t\t\tfor(int j=1;j<segs.size();j++)if(segs[j].second==-1){\n\t\t\t\t\tif(s<segs[j].first-segs[j-1].first){//set\n\t\t\t\t\t\tpair<int,int> p=make_pair(segs[j-1].first+s,l);\n\t\t\t\t\t\tsegs.push_back(p);\n\t\t\t\t\t\tcout <<\"l\"<< l;\n\t\t\t\t\t\tls.push_back(p.first);\n\t\t\t\t\t\tsort(ALL(segs));sort(ALL(ls));break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ts-=segs[j].first;\n\t\t\t\t\t\tsegs[j].second=l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s==\"D\"){\n\t\t\t\tint l;cin >> l;\n\t\t\t\tfor(int j=1;j<segs.size();j++)if(segs[j].second==l){\n\t\t\t\t\tsegs[j].second=-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint p;cin >> p;\n\t\t\t\tfor(int i=0;i<ls.size();i++)cout << ls[i]<<\" \";\n\t\t\t\t\n\t\t\t\tint vi=upper_bound(ALL(ls),p)-ls.begin();\n\t\t\t\tcout << segs[vi].second <<endl;\n\t\t\t}\n\t\t}\n\t\tcout <<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        lli output = -1;\n        for(lli i = 0, sum = 0; i < v.size(); sum += v[i++].size) {\n          if(P < sum+v[i].size) {\n            if(v[i].id >= 0) output = v[i].id;\n            break;\n          }\n        }\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 100100\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cerr << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cerr << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cerr << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    {\n\t\t      cerr << \"index = \" << index << endl;\n\t\t      print();\n\t\t      cerr << \"input = \"<< c << \" \" << l << \" \" << s << endl; \n\t\t      assert(false);\n\t\t      \n\t\t    }\n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\ntemplate <typename T> constexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity() : numeric_limits<T>::max() / 4;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(10); } } initCpp;\n\nstruct Fragment {\n  i64 from;\n  i64 to;\n  i64 id;\n};\n\nsigned main() {\n  while (true) {\n    i64 n;\n    cin >> n;\n    if (n == 0) break;\n    list<Fragment> mem;\n    mem.push_back({0, inf<i64>, -1});\n    REP(_, n) {\n      char c;\n      cin >> c;\n      if (c == 'W') {\n        i64 i, s;\n        cin >> i >> s;\n        for (auto iter = mem.begin(); iter != mem.end(); ++iter) {\n          Fragment f = *iter;\n          if (f.id == -1) {\n            if (f.to - f.from > s) {\n              Fragment g = *mem.insert(iter, {f.from, f.from + s, i});\n              iter->from = g.to;\n              // f.from = g.to;\n              // *iter = f;\n              break;\n            } else {\n              s -= f.to - f.from;\n              iter->id = i;\n              // f.id = i;\n              // *iter = f;\n              if (s == 0) break;\n            }\n          }\n        }\n      }\n      if (c == 'D') {\n        i64 i;\n        cin >> i;\n        for (auto& f : mem) {\n          if (f.id == i) {\n            f.id = -1;\n          }\n        }\n      }\n      if (c == 'R') {\n        i64 p;\n        cin >> p;\n        for (auto f : mem) {\n          if (f.from <= p && p < f.to) {\n            cout << f.id << endl;\n            goto read;\n          }\n        }\n        cout << -1 << endl;\n        read:;\n        // for (auto f : mem) {\n        //   cerr << f.from << \" \" << f.to << \" \" << f.id << \"; \";\n        // }\n        // cerr << endl;\n      }\n    }\n    cout << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        list<pair<int,pair<int, int>>> ls;\n        ls.push_back(make_pair(-1,make_pair(-1,-1)));\n\n        rep(i,n){\n            char com;\n            cin >> com;\n            if(com == 'W'){\n                int a, b;\n                cin >> a >> b;\n                auto cur = ls.begin();\n                auto bef = ls.begin();\n                cur++;\n                while(b > 0){\n                    int tmp = bef->second.second + 1;\n                    if(cur == ls.end()){\n                        ls.push_back(make_pair(a,make_pair(tmp, tmp + b - 1)));\n                        b = 0;\n                    }else if(bef->second.second + 1 != cur->second.first){\n                        int dif = cur->second.first - bef->second.second - 1;\n                        if(b <= dif){\n                            ls.insert(cur,make_pair(a,make_pair(tmp,tmp + b - 1)));\n                            b = 0;\n                        }else{\n                            ls.insert(cur,make_pair(a,make_pair(tmp,cur->second.first - 1)));\n                            b -= dif;\n                        }\n                        cur--;\n                        bef = cur;\n                        bef--;\n                    }\n                    cur++;\n                    bef++;\n                }\n            }else if(com == 'D'){\n                int a;\n                cin >> a;\n                for(auto it = ls.begin(); it != ls.end(); it++){\n                    if(it->first == a){\n                        it = ls.erase(it);\n                    }\n                }\n            }else{\n                int a;\n                cin >> a;\n\n                bool f = false;\n                for(auto it:ls){\n                    if(it.second.first <= a && a <= it.second.second){\n                        cout << it.first << endl;\n                        f = true;\n                        break;\n                    }\n                }\n                if(not f) cout << -1 << endl;\n            }\n            //for(auto it : ls){ cout << it.second.first << ' ' << it.second.second << endl; }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\ntypedef pair<int, int> Range;\ntypedef pair<Range, int> Record;\n\nstruct Comp {\n\tbool operator() (Range a, Range b) {\n\t\treturn a.first > b.first;\n\t}\n};\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n; cin >> n;\n\t\tif (n == 0) return 0;\n\n\t\tpriority_queue<Range, vector<Range>, Comp> empty;\n\t\tempty.push(Range(0, INF));\n\n\t\tset<Record> used;\n\n\t\trep(i, 0, n)\n\t\t{\n\t\t\tchar c; cin >> c;\n\t\t\tint l, S, P;\n\t\t\tset<Record> eraselist;\n\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t\tcin >> l >> S;\n\t\t\t\twhile (0 < S)\n\t\t\t\t{\n\t\t\t\t\tRange r = empty.top(); empty.pop();\n\t\t\t\t\tint range_len = r.second - r.first + 1;\n\t\t\t\t\tif (S < range_len)\n\t\t\t\t\t{\n\t\t\t\t\t\tempty.push(Range(r.first + S, r.second));\n\t\t\t\t\t\tused.insert(Record(Range(r.first, r.first + S - 1), l));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tused.insert(Record(Range(r.first, r.second), l));\n\t\t\t\t\t}\n\t\t\t\t\tS -= range_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'D':\n\t\t\t\tcin >> l;\n\t\t\t\teraselist.clear();\n\t\t\t\tfor (auto p : used)\n\t\t\t\t{\n\t\t\t\t\tif (p.second == l)\n\t\t\t\t\t{\n\t\t\t\t\t\tempty.push(p.first);\n\t\t\t\t\t\teraselist.insert(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto p : eraselist) used.erase(p);\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\tcin >> P;\n\t\t\t\tint ret = -1;\n\t\t\t\tfor (auto p : used)\n\t\t\t\t{\n\t\t\t\t\tif (p.first.first <= P && P <= p.first.second) ret = p.second;\n\t\t\t\t}\n\t\t\t\tcout << ret << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//printf(\"w\");\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nconst long long INF = (1e18);\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    map< pair<long long, long long>, long long > F;\n    map< long long, vector< pair<long long, long long> > > M;\n    F[{-1,0}] = -1;\n    for(int i = 0; i < N; ++i){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n        long long l, s, r = 0;\n        cin >> l >> s;\n        vector< pair<long long, long long> > V;\n        for(auto itr = F.begin(); itr != F.end(); ++itr){\n          r = max(r, itr->first.second);\n          if(itr == F.end()) continue;\n          auto itr_ = itr;\n          ++itr_;\n          if(itr_->first.first != itr->first.second){\n            long long n = min(s, itr_->first.first - itr->first.second);\n            s -= n;\n            V.emplace_back(itr->first.second,itr->first.second+n);\n            if(!s) break;\n          }\n        }\n        if(s){\n          V.emplace_back(r,r+s);\n        }\n        for(int j = 0; j < (int)V.size(); ++j){\n          F[V[j]] = l;\n          M[l].push_back(V[j]);\n        }\n      }else if(c == 'D'){\n        long long l;\n        cin >> l;\n        for(int j = 0; j < (int)M[l].size(); ++j) F.erase(F.find(M[l][j]));\n        M[l] = {};\n      }else{\n        long long p;\n        cin >> p;\n        auto itr = F.upper_bound({p,INF});\n        //cout << itr->first.first << \" \" << itr->first.second << \" \" << itr->second << endl;\n        --itr;\n        if(itr->first.second <= p) cout << -1 << endl;\n        else cout << itr->second << endl;\n      }\n      //for(auto itr = F.begin(); itr != F.end(); ++itr) cout << itr->first.first << \" \" << itr->first.second << \" \" << itr->second << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    set<P> st;\n    st.insert({0, INF});\n    map<int, vector<P>> mp;\n    while(n > 0) {\n      n--;\n      char q; cin >> q;\n      if(q == 'W') {\n        int idx, sz; cin >> idx >> sz;\n        vector<P> ers;\n        for(auto &e: st) {\n          int l = e.first, r = e.second;\n          if(r - l > sz) {\n            mp[idx].push_back({l, l+sz});\n            ers.push_back(e);\n            st.insert({l+sz, r});\n            break;\n          } else if(r - l == sz || r == INF) {\n            mp[idx].push_back({l, r});\n            ers.push_back(e);\n            break;\n          } else {\n            mp[idx].push_back({l, r});\n            ers.push_back(e);\n            sz -= r - l;\n          }\n        }\n        for(auto &e: ers) {\n          st.erase(e);\n        }\n      } else if(q == 'D') {\n        int idx; cin >> idx;\n        for(auto &e: mp[idx]) {\n          st.insert(e);\n        }\n        mp[idx].clear();\n      } else if(q == 'R') {\n        int pos; cin >> pos;\n        int ans = -1;\n        for(auto &e: mp) {\n          auto it = upper_bound(e.second.begin(), e.second.end(), make_pair(pos, INF));\n          if(it == e.second.begin()) continue;\n          it--;\n          if((*it).first <= pos && pos < (*it).second) {\n            ans = e.first;\n            break;\n          }\n        }\n        cout << ans << endl;\n      }\n    }\n    cout << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n */\n#include <iostream>\n#include <algorithm>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n// init\n\n// input\nint iN;\nchar cC; // 0 <= N <= 100,000\nint iI; // 1 <= P <= 100\nint iS; // 1 <= P <= 100\nint iP; // 1 <= P <= 100\n\n// manage\n\n// ú»\nvoid init() {\n}\n\n// üÍ\nbool input() {\n  scanf(\"%d\", &iN);\n  if (iN == 0)\n    return false;\n  return true;\n}\n\n// \nvoid manage() {\n  int i;\n  list<P> lis;\n  list<P>::iterator it; // Ce[^\n  P p;\n  for (i = 0; i < iN; i++) {\n    it = lis.begin();\n/*\n    while (it != lis.end()) { // listÌöÜÅ\n      printf(\"(%d, %d) \", it->first, it->second); // vfðoÍ\n      ++it; // Ce[^ðPÂißé\n    }\n    printf(\"\\n\"); // vfðoÍ\n*/\n    scanf(\" %c\", &cC);\n\n    if (cC == 'W') {\n      scanf(\"%d %d\", &iI, &iS);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == -1) {\n          it->first = iI;\n          if (iS >= it->second) {\n            iS -= it->second;\n          } else {\n            int d = it->second - iS;\n            it->second = iS;\n            iS = 0;\n            it++;\n            lis.insert(it, P(-1, d));\n          }\n          if (iS == 0) break;\n        }\n        it++;\n      }\n      if (it == lis.end()) {\n        lis.push_back(P(iI, iS));\n      }\n      continue;\n    }\n\n    if (cC == 'D') {\n      scanf(\"%d\", &iI);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == iI) {\n          it->first = -1;\n        }\n        it++;\n      }\n\n      continue;\n    }\n\n    if (cC == 'R') {\n      scanf(\"%d\", &iP);\n      it = lis.begin();\n      int sum = 0;\n      while (it != lis.end()) { // listÌöÜÅ\n        //printf(\"(%d, %d) %d %d %d\\n\", it->first, it->second, sum + it->second, iP, sum + it->second > iP); // vfðoÍ\n        if (sum + it->second > iP)\n          break;\n        sum += it->second;\n        it++;\n      }\n      if (it != lis.end()) {\n        printf(\"%d\\n\", it->first);\n      } else {\n        printf(\"-1\\n\");\n      }\n      continue;\n    }\n\n  }\n\n}\n\n// oÍ\nvoid output() {\n  printf(\"\\n\");\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while (1) {\n    if (!input())\n      break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<int> xs;\n    vector<char> com(n);\n    vector<int> id(n, -1), S(n, -1), p(n, -1);\n    xs.push_back(0);\n    map<int, int> lens;\n    int sum = 0;\n    for(int i = 0; i < n; ++i) {\n      cin >> com[i];\n      if(com[i] == 'W') {\n        cin >> id[i] >> S[i];\n        sum += S[i];\n        lens[id[i]] = S[i];\n        xs.push_back(sum);\n      } else if(com[i] == 'D') {\n        cin >> id[i];\n        sum -= lens[id[i]];\n        xs.push_back(sum);\n      } else {\n        cin >> p[i];\n      }\n    }\n    sort(begin(xs), end(xs));\n    xs.erase(unique(begin(xs), end(xs)), end(xs));\n\n    map<int, vector<int>> ls;\n    vector<int> ref_id(xs.size(), -1);\n    for(int i = 0; i < n; ++i) {\n      if(com[i] == 'W') {\n        int idx = 0, remain = S[i];\n        while(remain > 0) {\n          if(ref_id[idx] == -1) {\n            ref_id[idx] = id[i];\n            assert(idx + 1 < xs.size());\n            remain -= xs[idx + 1] - xs[idx];\n            ls[id[i]].push_back(idx);\n          }\n          idx++;\n        }\n      } else if(com[i] == 'D') {\n        for(auto r : ls[id[i]]) {\n          ref_id[r] = -1;\n        }\n        ls[id[i]].clear();\n      } else {\n        auto pos = lower_bound(begin(xs), end(xs), p[i]) - begin(xs);\n        if(pos == (int)xs.size()) {\n          cout << -1 << endl;\n          continue;\n        }\n        if(xs[pos] > p[i]) pos--;\n        cout << ref_id[pos] << endl;\n      }\n    }\n    cout << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 10010\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    assert(false);\n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<list>\nstruct S{int s,e,i;}s;\ntypedef std::list<S>L;\nint main()\n{\n\tint n,x,y,z;\n\tchar c;\n\tL l;\n\tL::iterator i;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tl.clear();\n\t\ts.s=s.e=s.i=INT_MAX;\n\t\tl.push_back(s);\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\" %c%d\",&c,&x);\n\t\t\tif(c=='W')\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&y);\n\t\t\t\tfor(i=l.begin(),z=0;y>0;)\n\t\t\t\t{\n\t\t\t\t\tif(z>=i->s)z=i->e+1,++i;else\n\t\t\t\t\t{\n\t\t\t\t\t\ts.s=z;\n\t\t\t\t\t\ts.i=x;\n\t\t\t\t\t\tif(y <= i->s-z)\t\t\t\t\t\ts.e=z+y-1,y=0;\n\t\t\t\t\t\telse s.e=i->s-1,y-=s.e-s.s+1;\n\t\t\t\t\t\ti=l.insert(i,s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c=='D')\n\t\t\t{\n\t\t\t\tfor(i=l.begin();i!=l.end();)\n\t\t\t\t\tif(i->i==x)i=l.erase(i);\n\t\t\t\t\telse++i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(i=l.begin();i!=l.end();++i)\n\t\t\t\t\tif(i->s<=x&&x<=i->e){printf(\"%d\\n\",i->i);goto E;}\n\t\t\t\tputs(\"-1\");\nE:;\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n; vector<tuple<int, int, int>>vec;\nvoid Write(int a, int b) {\n\tint R = vec.size();\n\tint E = -1; if (vec.size() >= 1)E = get<0>(vec[0]) - 1;\n\tif (E >= 0) {\n\t\tif (b < E + 1) { vec.push_back(make_tuple(0, b - 1, a)); sort(vec.begin(), vec.end()); return; }\n\t\tif (b >= E + 1) { vec.push_back(make_tuple(0, E, a)); sort(vec.begin(), vec.end()); b -= (E + 1); }\n\t}\n\tR = vec.size();\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tif (b == 0)break;\n\t\tint E = get<1>(vec[i]) + 1;\n\t\tint F = get<0>(vec[i + 1]) - 1;\n\t\tint SS = F - E + 1;\n\t\tif (SS >= 1) {\n\t\t\tif (b >= SS) { vec.push_back(make_tuple(E, F, a)); b -= SS; }\n\t\t\tif (b < SS) { vec.push_back(make_tuple(E, E + b - 1, a)); b = 0; }\n\t\t}\n\t}\n\n\tsort(vec.begin(), vec.end());\n\tif (b >= 1) {\n\t\tint E = 0; if (vec.size() >= 1) E = get<1>(vec[vec.size() - 1]) + 1;\n\t\tvec.push_back(make_tuple(E, E + b - 1, a));\n\t}\n\treturn;\n}\nvoid Delete(int a) {\n\tvector<tuple<int, int, int>>vec2;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<2>(vec[i]) != a)vec2.push_back(vec[i]);\n\t}\n\tvec = vec2;\n\treturn;\n}\nint Read(int a) {\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<0>(vec[i]) <= a && a <= get<1>(vec[i])) {\n\t\t\treturn get<2>(vec[i]);\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; vec.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'W') { int l, s; cin >> l >> s; Write(l, s); }\n\t\t\tif (p == 'D') { int l; cin >> l; Delete(l); }\n\t\t\tif (p == 'R') { int l; cin >> l; cout << Read(l) << endl; }\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int MAXL = 1000000001;\ntypedef pair<int, int> SEG;\ntypedef pair<SEG, int> S;\n//int data[MAXL];\nint main(){\n  int N;\n  while(cin>>N && N){\n    //memset(data, -1, sizeof(data));\n    vector<S> data;\n    data.push_back(S(SEG(-1, 0), -1));\n    REP(time, N){\n      string cmd; cin>>cmd;\n      if(cmd == \"W\"){\n        int l, s; cin>>l>>s;\n        vector<S> add;\n        REP(i, data.size()-1){\n          if(s == 0) break;\n          if(data[i].first.second < data[i+1].first.first){\n            int fst = data[i].first.second;\n            int len = min(s, data[i+1].first.first - fst);\n            add.push_back(S(SEG(fst, fst + len), l));\n            s -= len;\n          }\n        }\n        if(s > 0){\n          int fst = data.back().first.second;\n          int len = s;\n          add.push_back(S(SEG(fst, fst + len), l));\n        }\n        REP(i, add.size()) data.push_back(add[i]);\n        sort(data.begin(), data.end());\n        /*\n        REP(i, MAXL){\n          if(S == 0) break;\n          if(data[i] == -1){\n            data[i] = l;\n            S --;\n          }\n        }\n        */\n      }else if(cmd == \"D\"){\n        int l; cin>>l;\n        //REP(i, MAXL)if(data[i] == l)data[i] = -1;\n        vector<S>::iterator it = data.begin();\n        while(it != data.end()){\n          if(it->second == l){\n            it = data.erase(it);\n          }else{\n            it++;\n          }\n        }\n      }else if(cmd == \"R\"){\n        int P; cin>>P;\n        int res = -1;\n        REP(i, data.size())if(data[i].first.first <= P && P < data[i].first.second){\n          res = data[i].second;\n          break;\n        }\n        cout<< res << endl;\n        //cout<<data[P]<<endl;\n      }else{\n        assert(false);\n      }\n      //REP(i, data.size())printf(\"%d:(%d, %d) \", data[i].second, data[i].first.first, data[i].first.second); cout<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int> m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tauto it2=it++;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll n;\n\n    while (cin >> n, n) {\n\n        vector<tuple<ll, ll, ll>> files; // (l, r, i) means [l, r) is a part of the file i\n        \n        REP(i, n) {\n\n            char cmd; cin >> cmd;\n\n            if (cmd == 'R') {\n\n                ll p; cin >> p;\n                bool found = false;\n                for (auto &f : files) {\n                    if (get<0>(f) <= p && p < get<1>(f)) {\n                        cout << get<2>(f) << endl;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) cout << \"-1\" << endl;\n\n            } else if (cmd == 'D') {\n\n                ll i; cin >> i;\n                files.erase(remove_if(ALL_OF(files), [&i](auto f) -> bool { return get<2>(f) == i; }), files.end());\n\n            } else if (cmd == 'W') {\n\n                ll i, s; cin >> i >> s;\n\n                if (!files.empty()) {\n                    if (get<0>(files.front()) > 0) {\n                        ll gap = min(get<0>(files.front()), s);\n                        s -= gap;\n                        files.insert(files.begin(), make_tuple(0LL, gap, i));\n                    }\n                    if (s >= 0) REP(j, files.size() - 1) {\n                        ll gap = get<0>(files[j+1]) - get<1>(files[j]);\n                        if (gap > 0) {\n                            chmin(gap, s);\n                            s -= gap;\n                            ll bk = get<1>(files[i]);\n                            files.emplace_back(bk, bk + gap, i);\n                            if (s <= 0) break;\n                        }\n                    }\n                }\n\n                if (s > 0) {\n                    ll bk = files.empty() ? 0 : get<1>(files.back());\n                    files.emplace_back(bk, bk + s, i);\n                }\n\n                sort(ALL_OF(files));\n\n            }\n\n        }\n\n        cout << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    for(unsigned long n; cin >> n && n; cout << endl){\n        map<pair<unsigned long, unsigned long>, unsigned long> rlc;\n        set<unsigned long> del;\n        rlc.emplace(pair<unsigned long, unsigned long>(0, 100000000000), ~0);\n        del.insert(~0);\n        for(unsigned long iter = 0, A, B; iter < n; ++iter){\n            char c;\n            cin >> c >> A;\n            if(c == 'W'){\n                cin >> B;\n                for(auto it = rlc.begin(), en = rlc.end(); it != en; ++it)if(del.count(it -> second))if(B + it -> first.first < it -> first.second){\n                    auto i = *it;\n                    rlc.erase(it);\n                    rlc.emplace(pair<unsigned long, unsigned long>(i.first.first, i.first.first + B), A);\n                    rlc.emplace(pair<unsigned long, unsigned long>(i.first.first + B, i.first.second), i.second);\n                    break;\n                }else{\n                    it -> second = A;\n                    B -= it -> first.second - it -> first.first;\n                }\n            }else if(c == 'D') del.insert(A);\n            else for(const auto& i : rlc)if(i.first.first < A && A <= i.first.second)cout << static_cast<long>(del.count(i.second) ? -1 : i.second) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].second == -1) {\n            if(idx + cnt - 1 <= dp[idx].first) {\n              dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx].second = l;\n              dp[idx].first = idx+cnt-1;\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].second - dp[idx].first + 1;\n              idx = dp[idx].first + 1;\n            }\n          } else {\n            idx = dp[idx].first + 1;\n          }\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          } else {\n            idx = dp[idx].first + 1;\n          }\n        }\n      }\n      // for(auto& j: dp) cout << j.first << \" \" << j.second << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\n#define first start \n#define second goal \n\nusing namespace std;\n\nconst int NONE = -1;\nconst int MAX = 1000000000;\n\nstruct sector {\n\tint length, id;\t\n\tsector(int id_, int length_): id(id_), length(length_) {}\n};\n\nvector<sector> sys;\nint pos;\n\n\nvoid read(int pos) {\n\tint idx = 0;\n\t//rep(i, sys.size()) { cout << sys[i].id << \",\" << sys[i].length << \" \";} cout << endl;\n\trep(i, sys.size()) {\n\t\tidx += sys[i].length;\n\t\tif(idx > pos) {\n\t\t\tcout << sys[i].id << endl;\t\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nvoid write(int id, int size) {\n\n\tif(sys.size() == 0) {\n\t\tsys.push_back(sector(id, size));\t\n\t\treturn;\n\t}\n\n\tint n = sys.size();\n\trep(i, n) {\n\t\tif(sys[i].id != -1) continue;\n\t\t\n\t\tvector<sector>::iterator it = sys.begin()+i;\n\t\tif(sys[i].length == size) {\n\t\t\tsys[i].id = id;\t\n\t\t\treturn;\n\t\t}\n\t\telse if(sys[i].length - size > 0){\n\t\t\tsys.insert(it+1, sector(-1, sys[i].length - size));\n\t\t\tsys[i].id = id;\n\t\t\tsys[i].length = size;\n\t\t\treturn;\n\t\t}\n\t\telse if(sys[i].length - size < 0) {\n\t\t\tsys[i].id = id;\n\t\t\tsize -= sys[i].length;\n\t\t}\n\t\tif(size <= 0) return;\n\t}\n\tsys.push_back(sector(id, size));\n\n\treturn;\n}\n\nvoid del(int id) {\n\trep(i, sys.size()) {\n\t\tif(sys[i].id == id) sys[i].id = -1;\t\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\t\n\t\tsys.clear();\n\n\t\tchar cmd;\n\t\trep(i, n) {\n\t\t\tcin >> cmd;\t\n\t\t\tif(cmd == 'W') {\n\t\t\t\tint id, size;\n\t\t\t\tcin >> id >> size;\n\t\t\t\twrite(id, size);\n\t\t\t}\n\t\t\telse if(cmd == 'D') {\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\tdel(id);\n\t\t\t}\n\t\t\telse if(cmd == 'R') {\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tread(pos);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int> m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*cmd=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\\n\",(--it)->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n#define int ll\nstruct st{\n    int first,second,ident;\n    bool operator < (st obj) const{\n        return this->second < obj.second;\n    }\n};\n\nsigned main(){\n    int n;\n    while(cin>>n&&n){\n        set<pii> free;\n        set<st> used;\n        free.insert(pii(0,1e9+1));\n        rep(i,n){\n            char ch;\n            cin>>ch;\n            if(ch=='W'){\n                int num,len;\n                cin>>num>>len;\n                while(len>0){\n                    pii tmp = *(free.begin());\n                    free.erase(free.begin());\n                    if(tmp.second-tmp.first<=len){  //????????????\n                        len -= tmp.second-tmp.first;\n                        used.insert(st{tmp.first,tmp.second,num});\n                    }\n                    else{                           //????????????????????????\n                        used.insert(st{tmp.first,tmp.first+len,num});\n                        free.insert(pii(tmp.first+len,tmp.second));\n                        len = 0;\n                    }\n                }\n            }\n            if(ch=='D'){\n                int num;\n                cin>>num;\n                auto itr = used.begin();\n                while (itr != used.end()) {\n                    if (itr->ident==num) {\n                        st tmp = *itr;\n                        free.insert(pii(tmp.first,tmp.second)); //??????????£?\n                        used.erase(itr++);\n                    }\n                    else {\n                        itr++;\n                    }\n                }\n            }\n            if(ch=='R'){\n                int pos;\n                cin>>pos;\n                auto res = used.upper_bound(st{0,pos,0});\n                if(res==used.end())cout<<\"-1\"<<endl;\n                else{\n                    if(res->first>pos)cout<<\"-1\"<<endl;\n                    else{\n                        st tmp = *(res);\n                        cout<<tmp.ident<<endl;\n                    }\n                }\n            }\n        }\n        cout<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main(){\n\twhile(1){\n\t\tstd::vector<int> v(1,-1);\n\t\tint a;\n\t\tstd::cin>>a;\n\t\tif(a==0)break;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tchar x;\n\t\t\tint p,q;\n\t\t\tstd::cin>>x;\n\t\t\tif(x=='W'){\n\t\t\t\tstd::cin>>p>>q;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==-1)v[j]=p,q--;\n\t\t\t\t\tif(q==0)break;\n\t\t\t\t\twhile(j==v.size()-1&&q!=0)v.push_back(p),q--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x=='D'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==p)v[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(x=='R'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tif(p-1>v.size()||p>=1000000000)std::cout<<\"-1\"<<std::endl;\n\t\t\t\telse std::cout<<v[p-1]<<std::endl;\n\t\t\t}\n\t\t}\n\t\tstd::cout<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <cstdio>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#define llint long long\n#define inf 1e9+7\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nset<P> S;\npriority_queue<P, vector<P>, greater<P> > Q;\nmap<int, vector<P> > mp;\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tS.clear(), mp.clear();\n\t\twhile(Q.size()) Q.pop();\n\t\t\n\t\tS.insert(P(0, -1));\n\t\tQ.push(P(0, inf));\n\t\t\n\t\tchar c;\n\t\tllint id, len, pos;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> c;\n\t\t\t//cout << c << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tcin >> id >> len;\n\t\t\t\twhile(len > 0){\n\t\t\t\t\tllint l = Q.top().first, r = Q.top().second;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tS.erase(P(l, -1));\n\t\t\t\t\tS.insert(P(l, id));\n\t\t\t\t\tif(r-l+1 > len){\n\t\t\t\t\t\tS.insert(P(l+len, -1));\n\t\t\t\t\t\tmp[id].push_back(P(l, l+len-1));\n\t\t\t\t\t\tQ.push(P(l+len, r));\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlen -= r-l+1;\n\t\t\t\t\t\tmp[id].push_back(P(l, r));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c == 'D'){\n\t\t\t\tcin >> id;\n\t\t\t\tvector<P> &vec = mp[id];\n\t\t\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\t\t\tS.erase(P(vec[i].first, id));\n\t\t\t\t\tS.insert(P(vec[i].first, -1));\n\t\t\t\t\tQ.push(vec[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcin >> pos;\n\t\t\t\tauto it = S.upper_bound(P(pos, 2*inf));\n\t\t\t\tit--;\n\t\t\t\tcout << it->second << endl;\n\t\t\t}\n\t\t\t\n\t\t\t/*for(auto it = S.begin(); it != S.end(); it++){\n\t\t\t\tcout << \"[\" << it->first << \" \" << it->second << \"]\"<< endl;\n\t\t\t}*/\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    char c;\n    int x,s;\n    map<int,pair<int,int>> mp;\n    map<int,bool> us;\n    int now;\n    for(int t=0;t<n;t++){\n      cin >> c;\n      if(c=='W'){\n        cin >> x >> s;\n        us[x]=true;\n        now=0;\n        while(1){\n          auto itr=mp.lower_bound(now);\n          if(itr==mp.end()){\n            mp[now]={now+s,x};\n            break;\n          }else{\n            if(now+s<=itr->first){\n              mp[now]={now+s,x};\n              break;\n            }else{\n              if(now<itr->first){\n                mp[now]={itr->first,x};\n                s-=itr->first-now;\n              }\n              if(!us[itr->second.second]){\n                now=itr->first;\n                if(now+s<=itr->second.first){\n                  mp[now]={now+s,x};\n                  break;\n                }else{\n                  mp[now]={itr->second.first,x};\n                  s-=itr->second.first-now;\n                }\n              }\n              now=itr->second.first;\n            }\n          }\n          if(s==0) break;\n        }\n      }else if(c=='D'){\n        cin >> x;\n        us[x]=false;\n      }else{\n        cin >> x;\n        auto itr=mp.upper_bound(x);\n        if(itr==mp.begin()){\n          cout << -1 << endl;\n        }else{\n          itr--;\n          if(itr->second.first<=x){\n            cout << -1 << endl;\n          }else{\n            if(us[itr->second.second]) cout << itr->second.second << endl;\n            else cout << -1 << endl;\n          }\n        }\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<pair<int,int>,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint N;\ninline int len(P x){\n\treturn x.sec-x.fi+1;\n}\npriority_queue<P,vector<P>,greater<P> > ep;\nset<T> s;\nvector<P> vec[10010];\nint idnum;\nmap<int,int> id;\nint rev[10010];\nvoid debug(){\n\tvector<P> tmp;\n\twhile(!ep.empty()){\n\t\ttmp.pb(ep.top());\n\t\tep.pop();\n\t}\n\tfor(int i=0;i<tmp.size();i++){\n\t\tprintf(\"[%d %d]\\n\",tmp[i].fi,tmp[i].sec);\n\t\tep.push(tmp[i]);\n\t}\n\tset<T>::iterator it;\n\tfor(it=s.begin();it!=s.end();++it){\n\t\tprintf(\"%d %d %d\\n\",(it->fi).sec,(it->fi).fi,it->sec);\n\t}\n\treturn;\n}\nint solve(){\n\twhile(!ep.empty())ep.pop();\n\ts.clear();\n\tfor(int i=0;i<10010;i++)vec[i].clear();\n\tidnum=0;\n\tid.clear();\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tep.push(P(0,1000000100));\n\tfor(int i=0;i<N;i++){\n\t\tchar type;\n\t\tscanf(\" %c\",&type);\n\t\tif(type=='W'){\n\t\t\tint l,S;\n\t\t\tscanf(\"%d %d\",&l,&S);\n\t\t\tid[l]=idnum;\n\t\t\trev[idnum]=l;\n\t\t\tl = idnum++;\n\t\t\twhile(S>0){\n\t\t\t\tP nxt = ep.top();\n\t\t\t\tep.pop();\n\t\t\t\tif(len(nxt)>S){\n\t\t\t\t\tvec[l].pb(P(nxt.fi,nxt.fi+S-1));\n\t\t\t\t\ts.insert(T(P(nxt.fi+S-1,nxt.fi),rev[l])); // s?????????????????¢\n\t\t\t\t\tep.push(P(nxt.fi+S,nxt.sec));\n\t\t\t\t\tS=0;\n\t\t\t\t}else{\n\t\t\t\t\tvec[l].pb(nxt);\n\t\t\t\t\ts.insert(T(P(nxt.sec,nxt.fi),rev[l])); \n\t\t\t\t\tS -= len(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug();\n\t\t}else if(type=='D'){\n\t\t\tint l;\n\t\t\tscanf(\"%d\",&l);\n\t\t\tl = id[l];\n\t\t\tfor(int i=0;i<vec[l].size();i++){\n\t\t\t\tP tmp = vec[l][i];\n\t\t\t\tep.push(tmp);\n\t\t\t\ts.erase(T(P(tmp.sec,tmp.fi),rev[l]));\n\t\t\t}\n\t\t\t//debug();\n\t\t}else{\n\t\t\tint p;\n\t\t\tscanf(\"%d\",&p);\n\t\t\tset<T>::iterator it = s.lower_bound(T(P(p,-1),-1));\n\t\t\tif(it==s.end()){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t}else{\n\t\t\t\tint L=(it->fi).sec,R=(it->fi).fi,ID=it->sec;\n\t\t\t\tif(L<=p&&p<=R)printf(\"%d\\n\",ID);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tif(id[l]>=10002)return 0;\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nbool check(){\n  for(int i = 0 ; i < (int)vec.size() ; i++){\n    if(vec[i].first != -1) return true;\n  }\n\n  vec.clear();\n  return false;\n}\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0 || !check()){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  int cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n\tcout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long long ll; \ntypedef map<ll,int>::iterator M;\nmap <ll,int> r;\n \nvoid W(){\n  ll a,b,pre=0;\n  cin>>a>>b;\n  M it=r.begin();\n  \n  while(it!=r.end()){\n    if(it->s==-1){\n      if((it->f)-pre>=b){\n\tr[pre+b]=a;\n\treturn;\n      }\n      it->s=a;\n      b-=((it->f)-pre);\n    }\n    pre=it->f;\n    it++;\n  }\n}\n \nvoid D(){\n  int a;\n  cin>>a;\n  M it=r.begin();\n  while(it!=r.end()){\n    if(it->s==a)it->s=-1;\n    it++;\n  }\n}\n \nint R(){\n  ll a;\n  cin>>a;a++;\n  M it=r.begin();\n  while(it!=r.end()){\n    if((it->f)>=a)return it->s;\n    it++;\n  }\n  return -1;\n}\n \nint main(){\n  int n;\n  while(cin>>n,n){\n    r.clear();\n    r[1000000000000000LL]=-1;\n    \n    while(n--){\n      char c;\n      cin>>c;\n      if(c=='W')W();\n      else if(c=='D')D();\n      else if(c=='R')cout<<R()<<endl;\n    }\n    cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<PPI> v;\n\nvoid write() {\n  int num, times;\n  cin >> num >> times;\n\n  int before = 0, i = 0;\n  if(v.empty()) v.pb(PPI(P(0, times - 1), num));\n  else {\n    while(i < v.size()) {\n      if (v[i].fi.fi - before >= times) {\n        v.insert(v.begin() + i, PPI(P(before, before + times - 1), num));\n        return;\n      } else {\n        PPI tmp = v[i];\n        if (tmp.fi.fi - before > 1) v.insert(v.begin() + i, PPI(P(before, tmp.fi.fi - 1), num));\n        times -= (tmp.fi.fi - before);\n        before = tmp.fi.se + 1;\n        i += 2;\n      }\n    }\n    v.insert(v.end(), PPI(P(before, before + times - 1), num));\n  }\n}\n\nvoid remove() {\n  int num;\n  cin >> num;\n  repr(i, v.size()) {\n    if (v[i].se == num) v.erase(v.begin() + i);\n  }\n  // rep(i, v.size()) cout << v[i].se << \" [\" << v[i].fi.fi << \", \" << v[i].fi.se << \"]\" << endl;\n}\n\nvoid read() {\n  int j;\n  cin >> j;\n  rep(i, v.size()) {\n    if (v[i].fi.fi <= j && j <= v[i].fi.se) {\n      cout << v[i].se << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n  while(cin >> n, n) {\n    v.clear();\n    rep(i, n) {\n      char cmd;\n      cin >> cmd;\n      switch(cmd) {\n        case 'W':\n        write(); break;\n        case 'D':\n        remove(); break;\n        case 'R':\n        read(); break;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int MAXL = 1000000001;\ntypedef pair<int, int> SEG;\ntypedef pair<SEG, int> S;\n//int data[MAXL];\nint main(){\n  int N;\n  while(cin>>N && N){\n    //memset(data, -1, sizeof(data));\n    vector<S> data;\n    data.push_back(S(SEG(-1, 0), -1));\n    REP(time, N){\n      string cmd; cin>>cmd;\n      if(cmd == \"W\"){\n        int l, s; cin>>l>>s;\n        vector<S> add;\n        REP(i, data.size()-1){\n          if(s == 0) break;\n          if(data[i].first.second < data[i+1].first.first){\n            int fst = data[i].first.second;\n            int len = min(s, data[i+1].first.first - fst);\n            add.push_back(S(SEG(fst, fst + len), l));\n            s -= len;\n          }\n        }\n        if(s > 0){\n          int fst = data.back().first.second;\n          int len = s;\n          add.push_back(S(SEG(fst, fst + len), l));\n        }\n        REP(i, add.size()) data.push_back(add[i]);\n        sort(data.begin(), data.end());\n        /*\n        REP(i, MAXL){\n          if(S == 0) break;\n          if(data[i] == -1){\n            data[i] = l;\n            S --;\n          }\n        }\n        */\n      }else if(cmd == \"D\"){\n        int l; cin>>l;\n        //REP(i, MAXL)if(data[i] == l)data[i] = -1;\n        vector<S>::iterator it = data.begin();\n        while(it != data.end()){\n          if(it->second == l){\n            it = data.erase(it);\n          }else{\n            it++;\n          }\n        }\n      }else if(cmd == \"R\"){\n        int P; cin>>P;\n        int res = -1;\n        REP(i, data.size())if(data[i].first.first <= P && P < data[i].first.second){\n          res = data[i].second;\n        }\n        cout<< res <<endl;\n        //cout<<data[P]<<endl;\n      }else{\n        assert(false);\n      }\n      //REP(i, data.size())printf(\"%d:(%d, %d) \", data[i].second, data[i].first.first, data[i].first.second); cout<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//25min\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    vector<int> M;\n    int max;\n    for(int j=0;j<N;j++){\n      char command;\n      int i,s,p;\n      int index;\n      cin >> command;\n      switch(command){\n      case 'W':\n\tcin >> i >> s;\n\tindex=0;\n\twhile(s>0){\n\t  if(index>=M.size()){\n\t    M[index]=i;\n\t    s--;\n\t  }else if(M[index]==-1){\n\t    M[index]=i;\n\t    s--;\n\t  }\n\t  index++;\n\t}\n\tbreak;\n      case 'D':\n\tcin >> i;\n\tfor(int k=0;k<M.size();k++){\n\t  if(M[k]==i) M[k]=(-1);\n\t}\n\tbreak;\n      case 'R':\n\tcin >> p;\n\tif(p<M.size()) cout << M[p] << endl;\n\telse cout << \"-1\" << endl;\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        typedef tuple<int,int,int> triple;\n        set<triple> intervals;\n        intervals.insert(triple(0,0,-inf));\n        rep(i,0,n){\n            /*\n            for(const auto& interval:intervals){\n                cout << get<0>(interval) << \" \" << get<1>(interval) << \" \" << get<2>(interval) << endl;\n            }\n            */\n            char command;\n            cin >> command;\n            if(command=='W'){\n                int id,len;\n                cin >> id >> len;\n                auto a=intervals.begin();\n                auto b=intervals.begin();\n                ++b;\n                while(len>0){\n                    int l=get<1>(*a);\n                    if(b==intervals.end()){\n                        intervals.insert(triple(l,l+len,id));\n                        break;\n                    }\n                    auto r=get<0>(*b);\n                    if(r==l){\n                        a=b;\n                        ++b;\n                        continue;\n                    }\n                    b=intervals.insert(triple(l,r,id)).first;\n                    ++b;\n                    a=b;\n                    ++b;\n                    len-=r-l;\n                }\n            }else if(command=='D'){\n                int id;\n                cin >> id;\n                for(auto it=intervals.begin();it!=intervals.end();){\n                    if(get<2>(*it)==id) it=intervals.erase(it);\n                    else ++it;\n                }\n            }else{\n                int index;\n                cin >> index;\n                bool ok=false;\n                for(const auto& interval:intervals) if(get<0>(interval)<=index and index<get<1>(interval)){\n                    cout << get<2>(interval) << endl;\n                    ok=true;\n                    break;\n                }\n                if(!ok) cout << -1 << endl;\n            }\n        }\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(ll i=n; i<N; i++)\n#define p(s) cout<<(s)<<endl\n#define p2(a,b) cout<<(a)<<\" \"<<(b)<<endl\nusing namespace std;\ntypedef long long ll;\nll inf=1e18;\n\nint main() {\n\tll N;\n\twhile(cin>>N && N > 0){\n\t\tvector<pair<pair<ll, ll>, ll>> vt;\n\t\tvt.push_back({{0, inf}, -1});\n\t\tREP(i,0,N){\n\t\t\tchar command;\n\t\t\tcin >> command;\n\t\t\tif(command == 'W'){\n\t\t\t\tll a , left;\n\t\t\t\tcin >> a >> left;\n\t\t\t\tfor(int i=0; i< vt.size(); i++){\n\t\t\t\t\tif(vt[i].second == -1){\n\t\t\t\t\t\tif(left >= vt[i].first.second - vt[i].first.first){\n\t\t\t\t\t\t\tleft -= vt[i].first.second - vt[i].first.first;\n\t\t\t\t\t\t\tvt[i].second = a;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tvt[i].first.first = vt[i].first.first + left;\n\t\t\t\t\t\t\tvt.push_back({{vt[i].first.first-left, vt[i].first.first}, a});\n\t\t\t\t\t\t\tleft = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(left == 0) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(vt.begin(), vt.end());\n\n\t\t\t}else if(command == 'D'){\n\t\t\t\tll a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor(int i=0; i< vt.size(); i++){\n\t\t\t\t\tif(vt[i].second == a){\n\t\t\t\t\t\tvt[i].second = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tll idx;\n\t\t\t\tcin >> idx;\n\t\t\t\tfor(auto v: vt){\n\t\t\t\t\tif(v.first.first <= idx && idx < v.first.second){\n\t\t\t\t\t\tp(v.second);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(auto v:vt){\n//\t\t\t\tp2(v.first.first, v.first.second);\n//\t\t\t\tp(v.second);\n//\t\t\t}\n\n\t\t}\n\t\tp(\"\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    set<tuple<int,int,int> >f;\n    //r,l,id\n    map<int,vector<tuple<int,int,int> > > pos;\n    REP(i,n){\n      string c;\n      cin >> c;\n      if(c==\"W\"){\n\tint id,se;\n\tcin >> id >> se;\n\tint tmp=0;\n\tfor(;;){\n\t  auto ite=(f.lower_bound(make_tuple(tmp+1,0,0)));\n\t  if(ite==f.end()){\n\t    auto ma=make_tuple(tmp+se,tmp,id);\n\t    f.insert(ma);\n\t    pos[id].push_back(ma);\n\t    break;\n\t  }\n\t  int sup,suc;\n\t  tie(suc,sup,ignore)=*ite;\n\t  if(tmp<sup){\n\t    if(tmp+se<=sup){\n\t      auto ma=make_tuple(tmp+se,tmp,id);\n\t      f.insert(ma);\n\t      pos[id].push_back(ma);\n\t      break;\n\t    }else{\n\t      auto ma=make_tuple(sup,tmp,id);\n\t      f.insert(ma);\n\t      pos[id].push_back(ma);\n\t      se-=sup-tmp;\n\t    }\n\t  }\n\t  tmp=suc;\n\t}\n      }else if(c==\"D\"){\n\tint id;\n\tcin >> id;\n\tfor(auto x:pos[id]) f.erase(x);\n\tpos[id].clear();\n      }else if(c==\"R\"){\n\tint p;\n\tcin >> p;\n\tauto x=f.lower_bound(make_tuple(p+1,0,0));\n\tif(x==f.end()){\n\t  cout << -1 << endl;\n\t}else{\n\t  int l,id;\n\t  tie(ignore,l,id)=*x;\n\t  if(l<=p) cout << id << endl;\n\t  else cout << -1 << endl;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    vector<pair<pair<int, int>, int> > files;\n    rep (iii, n) {\n      string str;\n      cin >> str;\n      if (str == \"W\") {\n\tvector<pair<pair<int, int>, int> > next;\n\tint num, sz, pre = -1;\n\tcin >> num >> sz;\n\trep (i, files.size()) {\n\t  if (pre + 1 != files[i].first.first && sz > 0) {\n\t    int fsz = min(sz, files[i].first.first - pre - 1);\n\t    next.push_back(make_pair(make_pair(pre + 1, pre + fsz), num));\n\t    sz -= fsz;\n\t  }\n\t  next.push_back(files[i]);\n\t  pre = files[i].first.second;\n\t}\n\tif (sz > 0) {\n\t  next.push_back(make_pair(make_pair(pre + 1, pre + sz), num));\n\t}\n\tfiles = next;\n      } else if (str == \"D\") {\n\tvector<pair<pair<int, int>, int> > next;\n\tint num;\n\tcin >> num;\n\trep (i, files.size()) {\n\t  if (num == files[i].second) continue;\n\t  next.push_back(files[i]);\n\t}\n\tfiles = next;\n      } else if (str == \"R\") {\n\tint pos;\n\tcin >> pos;\n\tint res = -1;\n\trep (i, files.size()) {\n\t  if (files[i].first.first <= pos && pos <= files[i].first.second) {\n\t    res = files[i].second;\n\t  }\n\t}\n\tcout << res << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\nint main(void){\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(n == 0) break;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tq.push(make_pair(0, INF));\n\t\tmap<int, vpint> m;\n\t\trep(i, n){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c == 'W'){\n\t\t\t\tint num, size; cin >> num >> size;\n\t\t\t\twhile(size > 0){\n\t\t\t\t\tint l = q.top().fi, r = q.top().se;\n\t\t\t\t\t// printf(\"l %d r %d\\n\", l, r);\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(r - l + 1 >= size){//??????\n\t\t\t\t\t\t// printf(\"push %d %d\\n\", l + size, r);\n\t\t\t\t\t\tq.push(make_pair(l + size, r));\n\t\t\t\t\t\tm[num].push_back(make_pair(l, l + size - 1));\n\t\t\t\t\t\tsize = 0;\n\t\t\t\t\t}else{//?¶??????????\n\t\t\t\t\t\tm[num].push_back(make_pair(l, r));\n\t\t\t\t\t\tsize -= (r - l + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint num; cin >> num;\n\t\t\t\tfor(auto u : m[num]){\n\t\t\t\t\t// printf(\"delete %d %d\\n\", u.fi, u.se);\n\t\t\t\t\tq.push(make_pair(u.fi, u.se));\n\t\t\t\t}\n\t\t\t\tm[num].erase(all(m[num]));\n\t\t\t}else{\n\t\t\t\tint idx; cin >> idx;\n\t\t\t\tbool flag = false;\n\t\t\t\teach(it, m){\n\t\t\t\t\tauto key = it->fi;\n\t\t\t\t\tauto v = it->se;\n\t\t\t\t\t// printf(\"key %d vsize %d\\n\", key, (int)v.size());\n\t\t\t\t\tfor (int i = 0; i < v.size(); ++i){\n\t\t\t\t\t\tif(v[i].fi <= idx && idx <= v[i].se){\n\t\t\t\t\t\t\tprintf(\"%d\\n\", key);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) break;\n\t\t\t\t}\n\t\t\t\tif(!flag){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll n;\n\n    while (cin >> n, n) {\n\n        vector<tuple<ll, ll, ll>> files; // (l, r, i) means [l, r) is a part of the file i\n        \n        REP(i, n) {\n\n            char cmd; cin >> cmd;\n\n            if (cmd == 'R') {\n\n                ll p; cin >> p;\n                bool found = false;\n                for (auto &f : files) {\n                    if (get<0>(f) <= p && p < get<1>(f)) {\n                        cout << get<2>(f) << endl;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) cout << \"-1\" << endl;\n\n            } else if (cmd == 'D') {\n\n                ll i; cin >> i;\n                files.erase(remove_if(ALL_OF(files), [&i](auto f) -> bool { return get<2>(f) == i; }), files.end());\n\n            } else if (cmd == 'W') {\n\n                ll i, s; cin >> i >> s;\n\n                if (!files.empty()) {\n                    if (get<0>(files.front()) > 0) {\n                        ll gap = min(get<0>(files.front()), s);\n                        s -= gap;\n                        files.insert(files.begin(), {0, gap, i});\n                    }\n                    if (s >= 0) REP(j, files.size() - 1) {\n                        ll gap = get<0>(files[j+1]) - get<1>(files[j]);\n                        if (gap > 0) {\n                            chmin(gap, s);\n                            s -= gap;\n                            ll bk = get<1>(files[i]);\n                            files.emplace_back(bk, bk + gap, i);\n                            if (s <= 0) break;\n                        }\n                    }\n                }\n\n                if (s > 0) {\n                    ll bk = files.empty() ? 0 : get<1>(files.back());\n                    files.emplace_back(bk, bk + s, i);\n                }\n\n                sort(ALL_OF(files));\n\n            }\n\n        }\n\n        cout << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n      prev=pres;\n      pres=pres->next;\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp-1<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=sinki->start+s-1;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    }\n  }\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  //cout<<\"read!\\n\";\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i)\n      prev->next=pres->next;\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm* next;\n  if(begin==NULL) return;\n  next=begin->next;\n  delete begin;\n  reset(next);\n}\nvoid debug(newrm* begin){\n  while(begin!=NULL){\n    cout<<begin->start<<\" \"<<begin->end<<endl;\n    begin=begin->next;\n  }\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    if(N==0) break;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      else if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      else if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      else if(com=='B')\n\tdebug(begin);\n    }\n    //  reset(begin);\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <list>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nstruct Data {\n    int id, L, R;\n    Data(int id, int L, int R) : id(id), L(L), R(R) {}\n};\n\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    list<Data> li;\n    for (int i = 0; i < N; ++i) {\n        char Q;\n        cin >> Q;\n\n        if (Q == 'W') {\n            int id, l;\n            cin >> id >> l;\n\n            int pre = 0;\n            for (auto itr = li.begin(); itr != li.end() && l > 0; ++itr) {\n                if (itr->L > pre) {\n                    int len = min(l, itr->L - pre);\n                    li.emplace(itr, id, pre, pre + len);\n                    l -= len;\n                }\n                pre = itr->R;\n            }\n\n            if (l > 0) li.emplace_back(id, pre, pre + l);\n        } else if (Q == 'D') {\n            int id;\n            cin >> id;\n            for (auto itr = li.begin(); itr != li.end();) {\n                if (itr->id == id) {\n                    itr = li.erase(itr);\n                } else {\n                    ++itr;\n                }\n            }\n        } else {\n            int pos;\n            cin >> pos;\n\n            bool judge = false;\n            for (auto itr = li.begin(); itr != li.end(); ++itr) {\n                if (itr->L <= pos && pos < itr->R) {\n                    cout << itr->id << endl;\n                    judge = true;\n                    break;\n                }\n            }\n\n            if (!judge) cout << -1 << endl;\n        }\n    }\n    cout << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20000];\nsegment *head, *blank;\n\nsegment* newseg(){\n    blank->next=NULL;\n    blank->file=NULL;\n    blank->id=-1;\n    blank->head=-1;\n    blank->length=-1;\n    return blank++;\n}\n\nvoid W(int I, int S){\n    segment *p=head, *last;\n    while(p->id!=-1) p=p->next;\n    while(S){\n        if(p->length>S){\n            p->id=I;\n            segment *b=newseg();\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        p=p->file;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20000;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\n#include <list>\nusing namespace std;\n\n\n\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tlist< pair< pair<int,int> , int> > se;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"D\" ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tfor( list< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( it->second == v ){\n\t\t\t\t\t\tit = se.erase(it);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( s == \"W\" ){\n\t\t\t\tint l,sec;\n\t\t\t\tcin >> l >> sec;\n\t\t\t\tint prev = 0;\n\t\t\t\tfor( list< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( sec == 0 ) break;\n\t\t\t\t\tint width = it->first.first - prev;\n\t\t\t\t\tint use = min(sec,width);\n\t\t\t\t\tint tmp = it->first.second;\n\t\t\t\t\tif( use != 0 ) {\n\t\t\t\t\t\tsec -= use;\n\t\t\t\t\t\tse.insert(it,make_pair(make_pair(prev,prev+use),l));\t\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t\tprev = tmp;\n\t\t\t\t}\n\t\t\t\tif( sec != 0 ){\n\t\t\t\t\tse.push_back(make_pair(make_pair(prev,prev+sec),l));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor( list< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->first.first <= pos && pos < it->first.second ){\n\t\t\t\t\t\tcout << it->second << endl;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !flag ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\n#include <list>\nusing namespace std;\n\n\n\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tlist< pair< pair<int,int> , int> > se;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"D\" ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tfor( list< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( it->second == v ){\n\t\t\t\t\t\tit = se.erase(it);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( s == \"W\" ){\n\t\t\t\tint l,sec;\n\t\t\t\tcin >> l >> sec;\n\t\t\t\tint prev = 0;\n\t\t\t\tfor( list< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( sec == 0 ) break;\n\t\t\t\t\tint width = it->first.first - prev;\n\t\t\t\t\tint use = min(sec,width);\n\t\t\t\t\tint tmp = it->first.second;\n\t\t\t\t\tit++;\n\t\t\t\t\tif( use != 0 ) {\n\t\t\t\t\t\tsec -= use;\n\t\t\t\t\t\tse.insert(it,make_pair(make_pair(prev,prev+use),l));\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tprev = tmp;\n\t\t\t\t}\n\t\t\t\tif( sec != 0 ){\n\t\t\t\t\tse.push_back(make_pair(make_pair(prev,prev+sec),l));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor( list< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->first.first <= pos && pos < it->first.second ){\n\t\t\t\t\t\tcout << it->second << endl;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !flag ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<list>\n#define LL long long\nusing namespace std;\nstruct R{\n\tLL cost;\n\tLL st;\n\tLL id;\n};\n\nint main(){\n\twhile (true){\n\t\tLL n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tlist<R> storage;\n\t\tstorage.emplace_back(R{1ll << 60, 0, -1});\n\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tchar command;\n\t\t\tcin >> command;\n\t\t\tif ('W' == command){\n\t\t\t\tLL l,s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\tfor (auto it = storage.begin(); it != storage.end(); ++it){\n\t\t\t\t\tif (it->id != -1) continue;\n\t\t\t\t\tif(it->cost - s > 0){\n\t\t\t\t\t\tauto cost = it->cost;\n\t\t\t\t\t\tauto st = it->st;\n\n\t\t\t\t\t\tit->cost = s;\n\t\t\t\t\t\tit->id = l;\n\n\t\t\t\t\t\t++it;\n\t\t\t\t\t\tstorage.insert(it, R{ cost - s, st + s, -1 });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ts -= it->cost;\n\t\t\t\t\t\tit->id = l;\n\t\t\t\t\t\tif (s == 0) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ('R' == command){\n\t\t\t\tLL p;\n\t\t\t\tcin >> p;\n\n\t\t\t\tfor (auto it = storage.begin(); it != storage.end(); ++it){\n\t\t\t\t\tif (it->st <= p && it->st + it->cost >= p){\n\t\t\t\t\t\tcout << it->id << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLL l;\n\t\t\t\tcin >> l;\n\n\t\t\t\tfor (auto it = storage.begin(); it != storage.end(); ++it){\n\t\t\t\t\tif(it->id==l) it->id = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 10010\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index == s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else if(file[j+1].first.first-index > s)\n\t\t\t{\n\t\t\t  file[j] = p2(index,index+s,l);\n\t\t\t  if(file[j+1] == p2(-2,-2,-2) || file[j+1] == p2(-1,-1,-1))\n\t\t\t    break;\n\t\t\t  P2 tmp = file[j+1];\n\t\t\t  file[j+1] = p2(-1,-1,-1);\n\t\t\t  s = 0;\n\t\t\t  for(int k=j+2;file[k-1] != p2(-2,-2,-2);k++)\n\t\t\t    {\n\t\t\t      P2 tmp2 = file[k];\t\t\t\n\t\t\t      file[k] = tmp;\n\t\t\t      tmp = tmp2;\n\t\t\t    }\n\t\t\t}\t\t      \n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    assert(false);\n\t\t  \n\t\t}\n\t   \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n;\n\tchar c;\n\tbool flag = true;\n\t\n\twhile( cin >> n , n ){\n\t\tvector<int> vc;\n\t\tif( flag ){\n\t\t\tflag = false;\n\t\t}else{\n\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i<n ; i++ ){\t\n\t\t\tint i,p,s;\n\t\t\t\n\t\t\tcin >> c;\n\t\t\tif( c == 'W' ){\t\n\t\t\t\tcin >> i >> s;\n\t\t\t\tfor(int j=0 ; s ;  ){\n\t\t\t\t\tif( j >= (int)vc.size() ){\n\t\t\t\t\t\tvc.push_back(i);\n\t\t\t\t\t\ts--;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif( vc[j] == -1 ){\n\t\t\t\t\t\t\tvc[j] = i;\n\t\t\t\t\t\t\ts--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( c == 'D' ){\n\t\t\t\tcin >> i;\n\t\t\t\tfor(int j=0 ; j < (int)vc.size() ; j++ ){\n\t\t\t\t\tif( vc[j] == i )\n\t\t\t\t\t\tvc[j] = -1;\n\t\t\t\t}\n\t\t\t}else if( c == 'R' ){\n\t\t\t\tcin >> p;\n\t\t\t\tif( p >= (int)vc.size() ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}else{\n\t\t\t\t\tcout << vc[p] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size <= S) {\n              S -= v[i].size;\n            } else if(v[i].size > S) {\n              v.insert(v.begin()+i+1, (Data){v[i].size - S, -2});\n              v[i].size = S;\n              S = 0;\n            }\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(int i = 0, sum = 0; output == -1 && i < v.size();\n            sum += v[i].size, ++i) {\n          if(sum <= P && P < sum+v[i].size) {\n            output = v[i].id;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint N;\n //<(????§???????????????????(0~), ????????????????????????), ???>\npair< pair<int, int>, int > disk[20005];\n\nint main() {\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    REP(i,0,20005) disk[i] = make_pair(make_pair(INF,INF), INF);\n    disk[0] = make_pair(make_pair(0,1000000001), -1);  //-1:empty\n    REP(i,0,N){\n      string com, inp1, inp2;\n      int num, len, ind;\n      cin>>com;\n      if(com==\"W\"){ /*?????????*/\n        cin>>inp1>>inp2;\n        num = stoi(inp1);\n        len = stoi(inp2);\n        REP(k,0,20005){\n          if(len==0) break;\n          if(disk[k].S == -1){\n            int tl = disk[k].F.S-disk[k].F.F+1;\n            if(len >= tl){\n              disk[k].S = num;\n              len -= tl;\n            }else{\n              //??°????´???????\n              int tmp = disk[k].F.F;\n              disk[k].F.F = disk[k].F.F+len;\n              RREP(l,k+1,20005){\n                disk[l] = disk[l-1];\n              }\n              disk[k] = make_pair(make_pair(tmp, tmp+len-1), num);\n              len = 0;\n            }\n          }\n        }\n      }else if(com==\"D\"){ /*??????*/\n        cin>>inp1;\n        num = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].S==num) disk[k].S = -1;\n        }\n      }else{ /*????????????*/\n        cin>>inp1;\n        ind = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].F.F <= ind && ind <= disk[k].F.S){\n            cout<<disk[k].S<<endl;\n            break;\n          }\n        }\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152&lang=jp\nusing namespace std;\ntypedef pair<int,int> pii;\n#define MAX 1000000000\n\npriority_queue<pii, vector<pii>, greater<pii>> emp_secta;\nmap<int, vector<pii>> sectas;\nvoid Write(int l,int S) {\n\twhile (S) {\n\t\tauto q = emp_secta.top(); emp_secta.pop();\n\t\tint lx = q.first, rx = q.second;\n\t\tif (rx - lx + 1 == S ) {\n\t\t\tsectas[l].push_back(pii(lx, rx));\n\t\t\tS = 0;\n\t\t}\n\t\telse if(rx - lx + 1 > S) {\n\t\t\tsectas[l].push_back(pii(lx, lx + S - 1));\n\t\t\temp_secta.push(pii(lx + S, rx));\n\t\t\tS = 0;\n\t\t}\n\t\telse {\n\t\t\tsectas[l].push_back(pii(lx, rx));\n\t\t\tS -= (rx - lx + 1);\n\t\t}\n\t}\n}\n\nvoid Delete(int l) {\n\tfor (auto e : sectas[l]) {\n\t\temp_secta.push(pii(e.first, e.second));\n\t}\n\tsectas[l].clear();\n}\n\nvoid Refer(int P) {\n\tfor (auto it = sectas.begin(); it != sectas.end(); it++) {\n\t\tint val = it->first;\n\t\tvector<pii> sec = it->second;\n\t\tfor (int i = 0; i < sec.size();i++) {\n\t\t\tif (sec[i].first <= P && P <= sec[i].second) {\n\t\t\t\tcout << val << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tsectas.clear();\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> temp;\n\t\tswap(emp_secta, temp);\n\t\temp_secta.push(pii(0,MAX));\n\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tchar command; cin >> command;\n\t\t\tif (command == 'W') {\n\t\t\t\tint l, S; cin >> l >> S;\n\t\t\t\tWrite(l, S);\n\t\t\t}\n\t\t\tif (command == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tDelete(l);\n\t\t\t}\n\t\t\tif (command == 'R') {\n\t\t\t\tint P; cin >> P;\n\t\t\t\tRefer(P);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\nusing namespace std;\n\nstruct List\n{\n  int identifier;\n  int range[2];// [range[0],range[1]]\n  bool hasNext,hasPrev;\n  List *prev;\n  List *next;\n  List(int identifier=inf,int r1=inf,int r2=inf):identifier(identifier)\n  {\n    range[0] = r1, range[1] = r2;\n    hasNext = hasPrev = false;\n  }\n};\n\nint N,I,S,P;\nchar c;\nList list;\n\nvoid list_walk(List *l)\n{\n  cout << '[' << l->range[0] << \",\" << l->range[1] << \" : \" << l->identifier << \"]\";\n  if(l->hasNext)list_walk(l->next);\n}\n\n\nvoid ddfs(List *l)\n{\n  if(l->hasNext)ddfs(l->next);\n  if(l->hasPrev)delete l;\n    \n}\n\nvoid init()\n{\n  if(list.hasNext)ddfs(&list);\n  list.hasNext = true;\n  list.hasPrev = false;\n  list.range[0] = list.range[1] = -1;\n  list.identifier = -1;\n  list.next = new List;\n  list.next->hasNext = false;\n  list.next->hasPrev = true;\n  list.next->range[0] = list.next->range[1] = inf;\n  list.next->identifier = inf;\n  list.next->prev = &list;\n  //cout << \"test : \" << list.next->prev->identifier << endl;\n  //cout << \"test : \" << list.next->identifier << endl;\n}\n\nvoid dfsW(List *l)\n{\n  if(!l->hasNext)\n    {\n      assert(false);\n      return;\n    }\n\n  int v1 = l->range[1];\n  int v2 = l->next->range[0];\n  //cout << \"v1 = \" << v1 << \" v2 = \" << v2 << endl;\n  int diff = v2-v1-1;\n  //cout << \"diff = \" << diff << endl;\n  assert(diff >= 0);\n  if(diff)\n    {\n      List *node = new List;\n      node->identifier = I;\n      node->hasNext = node->hasPrev = true;\n      node->next = l->next;\n      node->prev = l;\n      l->next->prev = node;\n      l->next = node;\n\n      node->range[0] = v1+1;\n      if(S <= diff)\n\t{\n\t  node->range[1] = node->range[0] + S - 1;\n\t  S = 0;\n\t}\n      else if(S > diff)\n\t{\n\t  node->range[1] = node->range[0] + diff - 1;\n\t  S -= diff;\n\t}\n    \n    }  \n\n  if(S > 0)dfsW(l->next);\n}\n\nvoid compute_W()\n{\n  dfsW(&list);\n}\n\nvoid dfsD(List *l)\n{\n  if(l->identifier == I)\n    {\n      l->next->prev = l->prev;\n      l->prev->next = l->next;\n      delete l;\n    }\n  if(l->hasNext)dfsD(l->next);\n}\n\nvoid compute_D()\n{\n  dfsD(&list);\n}\n\nvoid dfsR(List *l)\n{\n  if(l->range[0] <= P && P <= l->range[1])\n    {\n      cout << l->identifier << endl;\n    }\n  else\n    {\n      if(l->hasNext)dfsR(l->next);\n      else cout << -1 << endl;\n    }\n}\n\nvoid compute_R()\n{\n  dfsR(&list);\n}\n\n\nint main()\n{\n  bool f = true;\n  while(cin >> N,N)\n    {\n      if(!f)cout << endl;\n      f = false;\n      init();\n      rep(_,N)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')cin >> I >> S,compute_W();\n\t  if(c == 'D')cin >> I,compute_D();\n\t  if(c == 'R')cin >> P,compute_R();\n\t  //list_walk(&list);cout << endl;\n\t}\n      //list_walk(&list);cout << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct Data{\n  int start;\n  int end;\n  int data;\n  Data *next;\n  Data *prev;\n};\n\nData buff[100000];\nint  _pos;\n\nData *alloc(){\n  if(_pos == 100000) _pos = 0;\n  return &buff[_pos++];\n}\n\nvoid write(Data *d, int size, int data){\n  if(d == NULL) return;\n  if(d->data != -1){\n    write(d->next, size, data);\n  }else{\n    int sz = d->end - d->start + 1;\n    if(sz > size){\n      //puts(\"test1\");\n      Data *next = alloc();\n      next->end   = d->end;\n      d->end      = d->start + size - 1;\n      next->start = d->end + 1;\n      next->data  = -1;\n      next->prev  = d;\n      next->next  = d->next;\n      d->next     = next;\n      d->data     = data;\n    }else if(sz == size){\n      //puts(\"test2\");\n      d->data = data;\n    }else{\n      //puts(\"test3\");\n      d->data = data;\n      write(d->next, size-sz, data);\n    }\n  }\n}\n\nData *merge(Data *d1, Data *d2){\n  if(d1 == NULL || d2 == NULL) return d2;\n  if(d1->data != d2->data) return d2;\n  d1->end  = d2->end;\n  d1->next = d2->next;\n  return d1;\n}\n\nvoid del(Data *d, int data){\n  while(d != NULL){\n    if(d->data == data){\n      d->data = -1;\n      merge(d->prev, d);\n      merge(d->next, d);\n    }\n    d = d->next;\n  }\n}\n\nint ref(Data *d, int pos){\n  while(d != NULL){\n    if(d->start <= pos && pos <= d->end){\n      return d->data;\n    }\n    d = d->next;\n  }\n  return 0;\n}\n\nvoid print(Data *d){\n  while(d != NULL){\n    printf(\"[%d,%d]: %d\\n\",d->start,d->end,d->data);\n    d = d->next;\n  }\n}\n\nint main(){\n  int n;\n  int cc = 0;\n  while(cin>>n, n){\n    Data *d = alloc();\n    d->start = 0;\n    d->end   = 1e9 + 10;\n    d->prev  = NULL;\n    d->next  = NULL;\n    d->data  = -1;\n\n    if(cc++ != 0) cout << endl;\n\n    while(n --> 0){\n      char c;\n      cin>>c;\n      if(c == 'W'){\n        int l,data;\n        cin>>data>>l;\n        write(d, l, data);\n      }else if(c == 'R'){\n        int pos;\n        cin>>pos;\n        cout << ref(d, pos) << endl;\n      }else{\n        int data;\n        cin>>data;\n        del(d, data);\n      }\n\n      //print(d);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<cstring>\n#include<map>\n \nusing namespace std;\n \n\nint main(void)\n{\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t//????????????,?????\\\n\t\tmap<int,int> sec;\n\t\t\n\t\t//-1(???)???0???????§???????\n\t\tsec[0]=-1;\n\t\tsec[1000000000]=-1;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\t\n\t\t\tif(s==\"W\"){\n\t\t\t\tint a,len;\n\t\t\t\tcin>>a>>len;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second==-1){\n\t\t\t\t\t\tit->second=a;\n\t\t\t\t\t\tauto it2=it;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2->first - it->first >= len){\n\t\t\t\t\t\t\tif(it2->first - it->first == len) break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tsec[it->first+len]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse len-=(it2)->first - it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(s==\"D\"){\n\t\t\t\t\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second == a) it->second=-1;\n\t\t\t\t}\n\t\t\t}else if(s==\"R\"){\n\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\tit2++;\n\t\t\t\t\tif(it->first<=a && a<it2->first){\n\t\t\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\twhile(nv!=-1 && dat[nv].r<=p)nv=dat[nv].rid;\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vector<pii>> v(1);\n\t\tv[0].push_back(pii(0, INF));\n\t\tvi index;\n\t\tindex.push_back(-1);\n\t\tREP(i, n)\n\t\t{\n\t\t\tchar c; int q;\n\t\t\tcin >> c >> q;\n\t\t\tif (c == 'W')\n\t\t\t{\n\t\t\t\tindex.push_back(q);\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tvector<pii> emp;\n\t\t\t\tv.push_back(emp);\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int j = 0;; j++)\n\t\t\t\t{\n\t\t\t\t\tif (v[0][j].second - v[0][j].first >= t)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(pii(v[0][j].first,v[0][j].first+t));\n\t\t\t\t\t\tif (v[0][j].second - v[0][j].first == t) cnt++;\n\t\t\t\t\t\telse v[0][j].first += t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(v[0][j]);\n\t\t\t\t\t\tt -= v[0][j].first - v[0][j].second;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[0].erase(v[0].begin(), v[0].begin() + cnt);\n\t\t\t}\n\t\t\telse if (c == 'D')\n\t\t\t{\n\t\t\t\tint p = find(ALL(index), q)-index.begin();\n\t\t\t\tv[0].insert(v[0].end(),ALL(v[p]));\n\t\t\t\tv[p].erase(ALL(v[p]));\n\t\t\t\tsort(ALL(v[0]));\n\t\t\t\tREP(i, v[0].size() - 1)\n\t\t\t\t{\n\t\t\t\t\tif (v[0][i].second == v[0][i + 1].first)\n\t\t\t\t\t{\n\t\t\t\t\t\tv[0][i] = v[0][i + 1] = pii(v[0][i].first, v[0][i + 1].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tauto a = unique(ALL(v[0]));\n\t\t\t\tv[0].erase(a, v[0].end());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, v.size())\n\t\t\t\t{\n\t\t\t\t\tREP(j, v[i].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (q >= v[i][j].first&&q < v[i][j].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (i == 0) puts(\"-1\");\n\t\t\t\t\t\t\telse cout << index[i] << endl;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tint back = 0;\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(len && !del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tif(len){\n\t\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\t\tback += len;\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second > id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg.erase(seg.begin()+t, seg.end());\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1<<60\n\ntypedef pair<long long int, long long int> PII;\ntypedef vector<PII> VPII;\n\nint main() {\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tmap<long long int, VPII> M;\n\t\tpriority_queue<PII, VPII, greater<PII>>que;\n\t\tque.push( make_pair( 0, 1LL << INF ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif( c == 'W' ) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\twhile( b ) {\n\t\t\t\t\tPII now = que.top(); que.pop();\n\t\t\t\t\tif( b < now.second - now.first ) {\n\t\t\t\t\t\tque.push( make_pair( now.first + b, now.second ) );\n\t\t\t\t\t\tM[a].push_back( make_pair( now.first, now.first + b - 1 ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else if( b == now.second - now.first ) {\n\t\t\t\t\t\tM[a].push_back( make_pair( now.first, now.second ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM[a].push_back( make_pair( now.first, now.second ) );\n\t\t\t\t\t\tb -= now.second - now.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if( c == 'D' ) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor( auto x : M[a] ) {\n\t\t\t\t\tque.push( x );\n\t\t\t\t}\n\t\t\t\tM[a].clear();\n\t\t\t} else {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tbool f = 0;\n\t\t\t\tfor( auto x : M ) {\n\t\t\t\t\tfor( auto y : x.second ) {\n\t\t\t\t\t\tif( y.first <= a &&a <= y.second ) {\n\t\t\t\t\t\t\tcout << x.first << endl;\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( f ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !f ) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nstruct newrm{\n  ll start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,ll i,ll s){\n  ll tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp-1<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=sinki->start+s-1;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    }\n    prev=prev->next;\n    pres=prev->next;\n  }\n  //  cout<<\"test\"<<endl;\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,ll p){\n  //cout<<\"read!\\n\";\n  \n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\n\nvoid del(newrm* begin,ll i){\n  newrm *prev,*pres,*tmp;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i){\n      tmp=pres;\n      prev->next=pres->next;\n      pres=prev->next;\n      //      cout<<\"debug\"<<tmp->start<<endl;\n      delete tmp;\n      continue;\n    }\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next; \n  while(pres!=NULL){\n    delete prev;\n    prev=pres;\n    pres=pres->next;\n  }\n  delete prev;\n  return;\n}\nvoid debug(newrm* begin){\n  ll i;\n  while(begin!=NULL){\n    for(i=begin->start;i<=begin->end;i++)\n      cout<<\" \"<<begin->dot<<\" \";\n    if(begin->next==NULL) break;\n    for(;i<begin->next->start;i++)\n      cout<<\" \"<<'x'<<\" \";\n    begin=begin->next;\n  }\n  cout<<endl;\n}\nint main(){\n  ll N,i,p,s;\n  char com;\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    \n    if(N==0) return 0;\n    for(ll i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      else if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      else if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      //      else if(com=='B')\n      //debug(begin);\n    }\n    //     reset(begin);\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\nstruct Data {\n    int start,end,id;\n    Data* next;\n    Data *prev;\n    Data(int s,int e,int i) : start(s), end(e), id(i) {;}\n};\n\nvoid insert(int id,int size,Data *d) {\n    if(size == 0) return;\n    if(d->id != -1) {\n        insert(id,size,d->next);\n        return;\n    }\n    int use = min(size, (d->end) - (d->start) + 1);\n    if(use == size) {\n        int remain = (d->end)-(d->start)+1 - size;\n        if(remain == 0) d->id = id;\n        else{\n            Data* nd = new Data(d->start+size,d->end,-1);\n            nd->prev = d;\n            nd->next = d->next;\n            d->next = nd;\n            d->end = d->start+size-1;\n            d->id = id;\n        }\n    }else{\n        int remain = size - ((d->end)-(d->start)+1);\n        d->id = id;\n        insert(id,remain,d->next);\n    }\n}\n\nint lookup(Data *n,ll p) {\n    if(n == NULL) return -1;\n    if(n->start <= p && n->end >= p) return n->id;\n    lookup(n->next,p);\n}\n\nvoid remove(int id,Data *n) {\n    if(n == NULL) return;\n    if((n->id) != id) {\n        remove(id,n->next);\n        return;\n    }\n    n->id = -1;\n    if(n->prev != n && n->prev->id == -1) {\n        n->prev->next = n->next;\n        n->prev->end = n->end;\n        Data *ne = n->next;\n        delete n;\n        remove(id,ne);\n    }\n}\n\nint main() {\n    int n;\n    string op;\n    while(cin>>n, n) {\n        Data root(0, 1<<30, -1);\n        Data *rp = &root;\n        root.prev = &root;\n        root.next = NULL;\n\n        int id,size;\n        for(int i=0; i<n; ++i) {\n            cin>>op;\n            if(op == \"W\") {\n                cin>>id>>size;\n                insert(id,size,rp);\n            }else if(op == \"D\") {\n                cin>>id;\n                remove(id,rp);\n            }else if(op == \"R\") {\n                cin>>size;\n                cout<<lookup(rp,size)<<endl;\n            }\n        }\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n#define MX 1000000001\nint N,d1,d2,cnt;\nchar c;\n\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tpriority_queue<int>Q;\n\t\tmap<int,vector<int> >M;\n\t\tcnt=0;\n\t\tfor(;N--;)\n\t\t{\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W')\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\\n\",&d1,&d2);\n\t\t\t\tfor(int i=0;i<d2;i++)\n\t\t\t\t{\n\t\t\t\t\tif(Q.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tM[d1].push_back(cnt++);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tM[d1].push_back(Q.top());\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c=='D')\n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1);\n\t\t\t\tfor(int i=0;i<M[d1].size();i++)\n\t\t\t\t\tQ.push(M[d1][i]);\n\t\t\t\tM[d1].clear();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1);\n\t\t\t\tif(d1>=cnt)\n\t\t\t\t{\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t\tgoto e;\n\t\t\t\t}\n\t\t\t\tfor(map<int,vector<int> >::iterator it=M.begin();it!=M.end();it++)\n\t\t\t\t\tfor(int i=0;i<it->second.size();i++)\n\t\t\t\t\t\tif(it->second[i]==d1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tprintf(\"%d\\n\",it->first);\n\t\t\t\t\t\t\tgoto e;\n\t\t\t\t\t\t}\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t\te:;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass E{\npublic:\n  char c;\n  int a,b;\n  E(char c,int a,int b):c(c),a(a),b(b){}\n};\n\nint n;\nvector<E> in;\n\nbool input(){\n  cin>>n;\n  if(n==0)return false;\n\n  in.clear();\n  rep(i,n){\n    char c;\n    int a,b;\n    cin>>c;\n    if(c=='W')cin>>a>>b;\n    else cin>>a;\n    in.push_back(E(c,a,b));\n  }\n  return true;\n}\n\nclass D{\npublic:\n  int prev;\n  int next;\n  int num;\n  int len;\n  D(int prev, int next,int num,int len):prev(prev),next(next),num(num),len(len){}\n};\n\n\nvector<D> data;\n\nvoid calc_write(int num,int len){\n  int now = 0;\n  while(1){\n    int prev = data[now].prev;\n    int next = data[now].next;\n\n    if(data[now].num==-1){\n      if(len<=data[now].len){\n\tdata[now].len -= len;\n\n\tD ad = D(prev, now, num, len);\n\tdata[now].prev = data.size();\n\tdata[prev].next = data.size();\n\n\tdata.push_back(ad);\n\tbreak;\n      }else{\n\tdata[now].num = num;\n\tlen-=data[now].len;\n      }\n    }\n    if(data[now].next==-1)break;\n    now = next;\n  }\n}\n\nvoid calc_del(int num){\n  int now = 0;\n  while(1){\n    int next = data[now].next;\n    if(data[now].num==num)data[now].num=-1;\n    if(next==-1)break;\n    now = next;\n  }\n}\n\nint  calc_read(int len){\n  int now = 0;\n  int sum = 0;\n  while(1){\n    int next = data[now].next;\n    sum += data[now].len;\n    if(sum  > len)return data[now].num;\n    if(next==-1)break;\n    now = next;\n  }\n  return -1;\n}\n\nvoid print(){\n  int now=0;\n  while(1){\n    int next = data[now].next;\n    printf(\"num=%d len=%d  (now=%d)\\n\",data[now].num,data[now].len,now);\n    if(data[now].next==-1)break;\n    now=next;\n  }\n}\n\nvoid solve(){\n  data.clear();\n  data.push_back(D(-1,1,-2,0));\n  data.push_back(D(0,-1,-1,1100000000));\n\n  //int();\n\n  rep(i,in.size()){\n    //printf(\"%c  %d %d\\n\",in[i].c,in[i].a,in[i].b);\n    if(in[i].c=='W')calc_write(in[i].a,in[i].b);\n    if(in[i].c=='R')printf(\"%d\\n\",calc_read(in[i].a));\n    if(in[i].c=='D')calc_del(in[i].a);\n    //print();\n  }\n  puts(\"\");\n}\n\nint main(){\n  while(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nstruct data{\n\tdata(int a,int b){\n\t\tlength=a;\n\t\tid=b;\n\t}\n\tint length;\n\tint id;\n};\n\nvector<data> sys;\n\nvoid write(int id,int len){\n\tif(sys.size()==0){\n\t\tsys.push_back(data(len,id));\n\t}else{\n\t\tint n=sys.size();\n\t\trep(i,n){\n\t\t\tif(len<=0) return;\n\t\t\tif(sys.size()-1 == i && sys[i].id != -1){//????????????????´???????????????§????????¨??????????????????????????????\n\t\t\t\tsys.push_back(data(len,id));\t\n\t\t\t}else if(sys[i].id==-1){\n\t\t\t\tif(len-sys[i].length==0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}else if(len-sys[i].length<0){ //length???????????§??????\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tsys.insert(sys.begin()+i,data(len-sys[i].length,-1));\n\t\t\t\t\treturn;\n\t\t\t\t}else if(len-sys[i].length>0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid read(int id){\n\tint len=0;\n\trep(i,sys.size()){\n\t\tlen+=sys[i].length;\n\t\tif(len>=id){\n\t\t\tcout << sys[i].id << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nvoid del(int id){\n\trep(i,sys.size()){\n\t\tif(sys[i].id==id){\n\t\t\tsys[i].id=-1;\n\t\t}else if(sys[i].id > id) break;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tint I,S;\n\t\t\tcin >> c;\n\t\t\n\t\t\t\n//\t\t\tcout << c << endl;\n\t\t\tif(c=='D'){\n\t\t\t\tcin >> I;\n\t\t\t\tdel(I);\n\t\t\t}else if(c=='W'){\n\t\t\t\tcin >> I >> S;\n\t\t\t\twrite(I,S);\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin >> I;\n\t\t\t\tread(I);\n\t\t\t}\t\t\n\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint T;\nint L[111111],R[111111],C[111111],nex[111111];\n\nint N;\nvoid solve(){\n    T=1;\n    L[0]=0;R[0]=1111111111;\n    nex[0]=-1;C[0]=-1;\n    rep(i,N){\n        char c;cin>>c;\n        if(c=='W'){\n            int t=0;\n            int l,s;\n            cin>>l>>s;\n            for(;s;t=nex[t]){\n                if(C[t]!=-1)continue;\n                if(R[t]-L[t]<=s){\n                    C[t]=l;\n                    s-=R[t]-L[t];\n                }\n                else{\n                    L[T]=L[t]+s;\n                    R[T]=R[t];\n                    C[T]=-1;\n                    nex[T]=nex[t];\n\n                    R[t]=L[t]+s;\n                    C[t]=l;\n                    nex[t]=T;\n                    s=0;\n                    T++;\n                }\n            }\n        }\n        else if(c=='D'){\n            int t=0;\n            int l;cin>>l;\n            for(;t>=0;t=nex[t])if(C[t]==l)C[t]=-1;\n        }\n        else{\n            int s;cin>>s;\n            int t=0;\n            for(;;t=nex[t]){\n                if(L[t]<=s&&s<R[t]){\n                    cout<<C[t]<<endl;\n                    break;\n                }\n            }\n        }\n    }\n    cout<<endl;\n}\nsigned main(){\n    while(cin>>N,N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<stdint.h>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\nusing namespace std;\n\nconst uint64_t INF = 100000000000010;\n\nstruct List\n{\n  int identifier;\n  uint64_t range[2];// [range[0],range[1]]\n  bool hasNext,hasPrev;\n  List *prev;\n  List *next;\n  List(int identifier=inf,uint64_t r1=INF,uint64_t r2=INF):identifier(identifier)\n  {\n    range[0] = r1, range[1] = r2;\n    hasNext = hasPrev = false;\n  }\n};\n\nint N,I,S,P;\nchar c;\nList list;\n\nvoid list_walk(List *l)\n{\n  cout << '[' << l->range[0] << \",\" << l->range[1] << \" : \" << l->identifier << \"]\";\n  if(l->hasNext)list_walk(l->next);\n}\n\n\nvoid ddfs(List *l)\n{\n  if(l->hasNext)ddfs(l->next);\n  if(l->hasPrev)delete l;\n    \n}\n\nvoid init()\n{\n  if(list.hasNext)ddfs(&list);\n  list.hasNext = true;\n  list.hasPrev = false;\n  list.range[0] = list.range[1] = -1;\n  list.identifier = -1;\n  list.next = new List;\n  list.next->hasNext = false;\n  list.next->hasPrev = true;\n  list.next->range[0] = list.next->range[1] = INF;\n  list.next->identifier = inf;\n  list.next->prev = &list;\n  //cout << \"test : \" << list.next->prev->identifier << endl;\n  //cout << \"test : \" << list.next->identifier << endl;\n}\n\nvoid dfsW(List *l)\n{\n  if(!l->hasNext)\n    {\n      cout << \"S = \" << S << endl;\n      list_walk(&list);\n      assert(false);\n      return;\n    }\n\n  uint64_t v1 = l->range[1];\n  uint64_t v2 = l->next->range[0];\n  //cout << \"v1 = \" << v1 << \" v2 = \" << v2 << endl;\n  uint64_t diff = v2-v1-1;\n  //cout << \"diff = \" << diff << endl;\n  //assert(diff >= 0);\n  if(diff)\n    {\n      List *node = new List;\n      node->identifier = I;\n      node->hasNext = node->hasPrev = true;\n      node->next = l->next;\n      node->prev = l;\n      l->next->prev = node;\n      l->next = node;\n\n      node->range[0] = v1+1;\n      if(S <= diff)\n\t{\n\t  node->range[1] = node->range[0] + S - 1;\n\t  S = 0;\n\t}\n      else if(S > diff)\n\t{\n\t  node->range[1] = node->range[0] + diff - 1;\n\t  S -= diff;\n\t}\n    \n    }  \n\n  if(S > 0)dfsW(l->next);\n}\n\nvoid compute_W()\n{\n  dfsW(&list);\n}\n\nvoid dfsD(List *l)\n{\n  if(l->identifier == I)\n    {\n      l->next->prev = l->prev;\n      l->prev->next = l->next;\n      delete l;\n    }\n  if(l->hasNext)dfsD(l->next);\n}\n\nvoid compute_D()\n{\n  dfsD(&list);\n}\n\nvoid dfsR(List *l)\n{\n  if(l->range[0] <= P && P <= l->range[1])\n    {\n      cout << l->identifier << endl;\n    }\n  else\n    {\n      if(l->hasNext)dfsR(l->next);\n      else cout << -1 << endl;\n    }\n}\n\nvoid compute_R()\n{\n  dfsR(&list);\n}\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n\n      init();\n      rep(_,N)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')cin >> I >> S,compute_W();\n\t  if(c == 'D')cin >> I,compute_D();\n\t  if(c == 'R')cin >> P,compute_R();\n\t  //list_walk(&list);cout << endl;\n\t}\n      //list_walk(&list);cout << endl;\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef pair<int,int> P;\nvector<P> vec;\n \nvoid change(int p, int S, int l){\n  vector<P> tmp;\n  int Next = vec[p].second - S;\n \n  for(int i = 0 ; i < p ; i++){\n    tmp.push_back(vec[i]);\n  }\n \n  tmp.push_back(P(l, S));\n  tmp.push_back(P(-1,Next));\n \n  for(int i = p+1 ; i < vec.size() ; i++){\n    tmp.push_back(vec[i]);\n  }\n \n  vec = tmp;\n}\n \nvoid Wri(){\n  int len = vec.size(), l, S;\n \n  cin >> l >> S;\n \n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n \n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }else{\n        change(i, S, l);\n        return;\n      }\n    }\n  }\n \n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n \nvoid Del(){\n  int len = vec.size(), l;\n \n  cin >> l;\n  if(len == 0){\n    return;\n  }\n \n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n \nint Ref(){\n  long long cnt = 0;\n  int len = vec.size(), l, num = vec[0].first;\n \n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n \n  for(int i = 0 ; i < len ; i++){\n    cnt += vec[i].second;\n    num = vec[i].first;\n     \n    if(cnt > l){\n      return num;\n    }\n  }\n \n  if(cnt <= l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n \nint main(){\n  int N;\n  char ch;\n \n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n \n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        cout << Ref() << endl;\n        break;\n      }\n    }\n \n    cout << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll inf =1LL << 62;\n\nint main(void){\n\tint n;\n\twhile ( cin >> n,n){\n\t\tdeque <pii> memory; //識別子　セクタ\n\t\trep(i,n){\n\t\t\tchar com;\n\t\t\tcin >> com;\n\t\t\tif(com=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\tint mn=memory.size();\n\t\t\t\tif(mn){\n\t\t\t\t\trep(j,mn){\n\t\t\t\t\t\tif(memory[j].first==-1){\n\t\t\t\t\t\t\tif(s>memory[j].second){\n\t\t\t\t\t\t\t\tmemory[j].first=l;\n\t\t\t\t\t\t\t\ts-=memory[j].second;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmemory[j].second-=s;\n\t\t\t\t\t\t\t\tpii tmp;\n\t\t\t\t\t\t\t\ttmp.first=l;tmp.second=s;\n\t\t\t\t\t\t\t\tmemory.insert(memory.begin()+j-1,tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s){\n\t\t\t\t\t\t\tpii tmp;\n\t\t\t\t\t\t\ttmp.first=l;tmp.second=s;\n\t\t\t\t\t\t\tmemory.push_back(tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tpii tmp;\n\t\t\t\t\ttmp.first=l;tmp.second=s;\n\t\t\t\t\tmemory.push_back(tmp);\n\t\t\t\t}\n\t\t\t}else if(com=='D'){\n\t\t\t\tint mn=memory.size();\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\trep(j,mn){\n\t\t\t\t\tif(memory[j].first==l){\n\t\t\t\t\t\tmemory[j].first=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\t\t\t\tint mn=memory.size();\n\t\t\t\tint cur=0;\n\t\t\t\tbool out=false;\n\t\t\t\tif(mn){\n\t\t\t\t\trep(j,mn){\n\t\t\t\t\t\tcur+=memory[j].second;\n\t\t\t\t\t\tif(cur>p){\n\t\t\t\t\t\t\tout=true;\n\t\t\t\t\t\t\tcout << memory[j].first << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!out)\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 10010\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i-1] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nvoid check()\n{\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    {\n      if(file[i] == p2(-1,-1,-1))\n\t{\n\t  for(int j=i+1;file[j] == p2(-1,-1,-1);j++)\n\t    file[j] = p2(-3,-3,-3);\n\t}\n    }\n\n  for(int i=0;file[i-1] != p2(-2,-2,-2);i++)\n    {\n      if(file[i] == p2(-3,-3,-3))\n\t{\n\t  while(file[i] == p2(-3,-3,-3))\n\t    for(int j=i;file[j] != p2(-2,-2,-2);j++)\n\t      file[j] = file[j+1];\n\t}\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      cerr << N << endl;\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  cerr << c << \" \";\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      cerr << l << \" \" << s << endl;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index == s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else if(file[j+1].first.first-index > s)\n\t\t\t{\n\t\t\t  file[j] = p2(index,index+s,l);\n\t\t\t  if(file[j+1] == p2(-2,-2,-2) || file[j+1] == p2(-1,-1,-1))\n\t\t\t  break;\n\t\t\t  P2 tmp = file[j+1];\n\t\t\t  file[j+1] = p2(-1,-1,-1);\n\t\t\t  s = 0;\n\t\t\t  for(int k=j+2;file[k-1] != p2(-2,-2,-2);k++)\n\t\t\t    {\n\t\t\t      P2 tmp2 = file[k];\t\t\t\n\t\t\t      file[k] = tmp;\n\t\t\t      tmp = tmp2;\n\t\t\t    }\n\t\t\t}\t\t      \n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    assert(false);\n\t\t  \n\t\t}\n\t   \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      cerr << ident << endl;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      cerr << p << endl;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t  check();\n\t  //print();\n\t  //cout << endl;\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nvector<vector<pii>> v;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tv.clear();\n\t\tv.resize(1);\n\t\tv[0].push_back(pii(0, INF));\n\t\tvi index;\n\t\tindex.push_back(-1);\n\t\tREP(i, n)\n\t\t{\n\t\t\tchar c; int q;\n\t\t\tcin >> c >> q;\n\t\t\tif (c == 'W')\n\t\t\t{\n\t\t\t\tindex.push_back(q);\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tvector<pii> emp;\n\t\t\t\tv.push_back(emp);\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int j = 0;; j++)\n\t\t\t\t{\n\t\t\t\t\tif (v[0][j].second - v[0][j].first >= t)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(pii(v[0][j].first,v[0][j].first+t));\n\t\t\t\t\t\tif (v[0][j].second - v[0][j].first == t) cnt++;\n\t\t\t\t\t\telse v[0][j].first += t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(v[0][j]);\n\t\t\t\t\t\tt -= v[0][j].first - v[0][j].second;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[0].erase(v[0].begin(), v[0].begin() + cnt);\n\t\t\t}\n\t\t\telse if (c == 'D')\n\t\t\t{\n\t\t\t\tint p = find(ALL(index), q)-index.begin();\n\t\t\t\tv[0].insert(v[0].end(),ALL(v[p]));\n\t\t\t\tv[p].erase(ALL(v[p]));\n\t\t\t\tsort(ALL(v[0]));\n\t\t\t\tREP(i, v[0].size() - 1)\n\t\t\t\t{\n\t\t\t\t\tif (v[0][i].second == v[0][i + 1].first)\n\t\t\t\t\t{\n\t\t\t\t\t\tv[0][i] = v[0][i + 1] = pii(v[0][i].first, v[0][i + 1].second);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tauto a = unique(ALL(v[0]));\n\t\t\t\tv[0].erase(a, v[0].end());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, v.size())\n\t\t\t\t{\n\t\t\t\t\tREP(j, v[i].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (q >= v[i][j].first&&q < v[i][j].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (i == 0) puts(\"-1\");\n\t\t\t\t\t\t\telse cout << index[i] << endl;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<cstring>\n#include<map>\n \nusing namespace std;\n \n\nint main(void)\n{\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t//????????????,?????\\\n\t\tmap<int,int> sec;\n\t\t\n\t\t//-1(???)???0???????§???????\n\t\tsec[0]=-1;\n\t\tsec[1000000000]=-1;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\t\n\t\t\tif(s==\"W\"){\n\t\t\t\tint a,len;\n\t\t\t\tcin>>a>>len;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second==-1){\n\t\t\t\t\t\tit->second=a;\n\t\t\t\t\t\tauto it2=it;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2->first - it->first >= len){\n\t\t\t\t\t\t\tif(it2->first - it->first) break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tsec[it->first+len-1]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse len-=(it2)->first - it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(s==\"D\"){\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second == a) it->second=-1;\n\t\t\t\t}\n\t\t\t}else if(s==\"R\"){\n\t\t\t\t/*\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tcout<<\"map[\"<<it->first<<\"]=\"<<it->second<<endl;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\tit2++;\n\t\t\t\t\tif(it->first<=a && a<=it2->first){\n\t\t\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tint back = 0;\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(len && !del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tif(len){\n\t\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\t\tback += len;\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second >= id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg.resize(t);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<pi,int>;\n\nconst int INF = 1000000001;\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        map<int,vector<int>> m;\n\n        // empty, filled\n        set<pi> e;\n        set<P> f;\n        e.insert({0,INF});\n\n        rep(i,n){\n            char c;\n            int x;\n            cin >>c >>x;\n\n            if(c == 'D'){\n                for(int j:m[x]){\n                    auto itr = f.lower_bound({{j,j},-1});\n                    pi range = itr->fi;\n                    e.insert(range);\n                    f.erase(itr);\n                }\n                m[x].clear();\n            }\n            else if(c == 'R'){\n                if(f.empty()) cout << -1 << endl;\n                else{\n                    auto itr = f.upper_bound({{x,INF},INF});\n                    --itr;\n                    pi range = itr->fi;\n\n                    if(range.fi<=x && x<range.se) cout << itr->se << endl;\n                    else cout << -1 << endl;\n                }\n            }\n            else if(c == 'W'){\n                int y;\n                cin >>y;\n                while(y){\n                    auto itr = e.begin();\n                    int l = itr->fi, r = itr->se;\n                    int SZ = r-l;\n                    e.erase(itr);\n                    if(SZ<y){\n                        m[x].pb(l);\n                        f.insert({{l,r},x});\n                        y -= SZ;\n                    }\n                    else{\n                        m[x].pb(l);\n                        f.insert({{l,l+y},x});\n                        e.insert({l+y,r});\n                        y = 0;\n                   }\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, PP> PPP;\ntypedef pair<double, Point> P2;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF= 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\n\ndouble dis(Point p1, Point p2){\n\treturn sqrt((p1.real() - p2.real())*(p1.real()-p2.real()) + (p1.imag() - p2.imag())*(p1.imag() - p2.imag()));\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmap<int, vector<P> > mp;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\t\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tint id, num;\n\t\t\tif(c == 'R'){\n\t\t\t\tcin >> num;\n\t\t\t\tbool ok = false;\n\t\t\t\tfor(map<int, vector<P> >::iterator iter = mp.begin(); iter != mp.end(); iter++){\n\t\t\t\t\tfor(int j = 0; j < (int)(*iter).second.size(); j++){\n\t\t\t\t\t\tif((*iter).second[j].first <= num && num < (*iter).second[j].second){\n\t\t\t\t\t\t\tcout << (*iter).first << endl;\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ok) break;\n\t\t\t\t}\n\t\t\t\tif(!ok) cout << -1 << endl;\n\t\t\t}else if(c == 'D'){\n\t\t\t\tcin >> id;\n\t\t\t\tmp[id].clear();\n\t\t\t}else{\n\t\t\t\tcin >> id >> num;\n\t\t\t\tvector<P> vp;\n\t\t\t\tfor(map<int, vector<P> >::iterator iter = mp.begin(); iter != mp.end(); iter++){\n\t\t\t\t\tfor(int i = 0; i < (int)(*iter).second.size(); i++){\n\t\t\t\t\t\tvp.push_back((*iter).second[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvp.push_back(P(0, 0));\n\t\t\t\tsort(vp.begin(), vp.end());\n\t\t\t\tvp.push_back(P(1000000001, 1000000001));\n\t\t\t\tfor(int j = 0; j < (int)vp.size() - 1; j++){\n\t\t\t\t\t\n\t\t\t\t\tif(vp[j].second < vp[j+1].first){\n\t\t\t\t\t\tif(num >= vp[j+1].first - vp[j].second){\n\t\t\t\t\t\t\tnum-=vp[j+1].first - vp[j].second;\n\t\t\t\t\t\t\tmp[id].push_back(P(vp[j].second, vp[j+1].first));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(num > 0){\n\t\t\t\t\t\t\t\tmp[id].push_back(P(vp[j].second, vp[j].second + num));\n\t\t\t\t\t\t\t\tnum = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(num == 0) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii, int> piii;\n\nint main() {\n  int n;\n  int hoho = 0;\n  while(cin>>n,n) {\n    if (hoho) cout << endl;\n    else hoho = 1;\n    set<piii> se;               // piii(pii(a, b), c) -> [a,b) É c ªÍ¢ÁÄéB\n    REP(i,n) {\n      char c;\n      cin >> c;\n      if (c=='W') {\n        int a,m;\n        cin>>a>>m;\n        int now = 0;\n        vector<piii> tmp;\n        int last = 0;\n        FOR(it, se) {\n          if (m == 0) break;\n          pii p=it->first;\n          if (p.first > now) {\n            int hoge = min(m, p.first-now);\n            tmp.push_back(piii(pii(now, now+hoge), a));\n            m -= hoge;\n          }\n          last = p.second;\n        }\n        if (m) {\n          tmp.push_back(piii(pii(last, last+m), a));\n        }\n        se.insert(ALL(tmp));\n      } else if (c == 'D') {\n        int a;\n        cin >> a;\n        set<piii> tmp;\n        FOR(it, se) {\n          if(it->second != a)\n            tmp.insert(*it);\n        }\n        se = tmp;\n      } else {\n        int m;\n        cin >> m;\n        int ans = -1;\n        FOR(it, se) {\n          pii p = it->first;\n          if (p.first<=m && m<p.second) {\n            ans = it->second;\n            break;\n          }\n        }\n        cout << ans << endl;\n      }\n      // cout << \"i = \" << i << endl;\n      // FOR(it, se) {\n      //   pii p =  it->first;\n      //   printf(\"(%d,%d),%d \", p.first,p.second,it->second);\n      // }\n      // cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n#define INF 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\tstd::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t\tstatic void print(std::ostream &os, const Tuple &t) {\n\t\t\t__TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t\t\tos << \", \" << std::get<N - 1>(t);\n\t\t}\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t\tstatic void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t\tos << '(';\n\t\t__TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t\tos << ')';\n\t\treturn os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t\treturn os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\tos << '[';                                \\\n\tfor (auto it = begin(c); it != end(c);) { \\\n\t\tos << *it;                            \\\n\t\tos << (++it != end(c) ? \", \" : \"\");   \\\n\t}                                         \\\n\treturn os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t\t__INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\t__INNER__                                               \\\n\t}\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t\t__INNER__                                                  \\\n\t}\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\tstd::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t\tstd::deque<T> v;                                        \\\n\t\tfor (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t\t\treturn os << v;                                         \\\n\t}\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int &operator+=(const mod_int &rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator-=(const mod_int &rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int &operator*=(const mod_int &rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int &operator/=(const mod_int &rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t} else {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * int(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\nconst ll mod = 1000000007;\nconst int MAX_N = 10000;  // 400MB\n// const int MAX_N = 1024; // 4MB\n// nCr % mod\n\n//#define int long long\n#define double long double \n\ninline ll gcds(ll a, ll b) { return b ? gcds(b, a % b) : a; }\ninline ll lcms(ll a, ll b) { return a / gcd(a, b) * b; }\n\n#define RK 200000000000\n#define LK 300000000000\n#define PL 400000000000\n#define MI 500000000000\n#define KA 600000000000\n\nstruct node{\n\tint name,size;\n\tstruct node *prev,*next;\n};\n\nnode head;\nnode h[1000000];\nset<int> deleted;\nint used=0;\n\nvoid node_insert(int x,int s){\n\tnode* now=&head;\n\twhile(1){\n\t\tif(deleted.find(now->name)!=deleted.end()){\n\t\t\tnow->name=-1;\n\t\t}\n\t\tif(now->name==-1){\n\t\t\tif(now->size<s){\n\t\t\t\ts-=now->size;\n\t\t\t\tnow->name=x;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode* before=now->prev;\n\t\t\t\tbefore->next=&h[used];\n\t\t\t\tnow->prev=&h[used];\n\t\t\t\th[used].name=x;\n\t\t\t\th[used].next=now;\n\t\t\t\th[used].prev=before;\n\t\t\t\tnow->size-=s;\n\t\t\t\th[used].size=s;\n\t\t\t\tused++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(now->next==NULL){\n\t\t\th[used].prev=now;\n\t\t\th[used].name=x;\n\t\t\th[used].size=s;\n\t\t\th[used].next=NULL;\n\t\t\tnow->next=&h[used];\n\t\t\tused++;\n\t\t\tbreak;\n\t\t}\n\t\tnow=now->next;\n\t}\n}\n\nvoid node_del(int x){\n\tdeleted.insert(x);\n\t/*\n\tnode* now=&head;\n\twhile(1){\n\t\tnow=now->next;\n\t\tif(now->name == x){\n\t\t\tnow->name=-1;\n\t\t}\n\t\tif(now->next==NULL)break;\n\t}\n\t*/\n}\n\nint get_val(int x){\n\tnode* now=&head;\n\tif(now->next==NULL){\n\t\treturn -1;\n\t}\n\tif(deleted.find(now->name)!=deleted.end()){\n\t\tnow->name=-1;\n\t}\n\twhile(1){\n\t\tnow=now->next;\n\t\tif(deleted.find(now->name)!=deleted.end()){\n\t\t\tnow->name=-1;\n\t\t}\n\t\tx-=now->size;\n\t\tif(x<=0){\n\t\t\treturn now->name;\n\t\t}\n\t\tif(now->next==NULL){\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n\nsigned main(){\n\twhile(1){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\thead.prev=NULL,head.next=NULL;\n\t\thead.name=-2;\n\t\thead.size=0;\n\t\tused=0;\n\t\tdeleted.clear();\n\t\tlp(i,n){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tint x,s;\n\t\t\t\tcin>>x>>s;\n\t\t\t\tnode_insert(x,s);\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tnode_del(x);\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tcout<<get_val(x+1)<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nstruct data{\n\tdata(int a,int b){\n\t\tlength=a;\n\t\tid=b;\n\t}\n\tint length;\n\tint id;\n};\n\nvector<data> sys;\n\nvoid write(int id,int len){\n\tif(sys.size()==0){\n\t\tsys.push_back(data(len,id));\n\t}else{\n\t\tint n=sys.size();\n\t\trep(i,n){\n\t\t\tif(len<=0) return;\n\t\t\tif(sys.size()-1 == i && sys[i].id != -1){//????????????????´???????????????§????????¨??????????????????????????????\n\t\t\t\tsys.push_back(data(len,id));\t\n\t\t\t}else if(sys[i].id==-1){\n\t\t\t\tif(len-sys[i].length==0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}else if(len-sys[i].length<0){ //length???????????§??????\n\t\t\t\t\tsys.insert(sys.begin()+i+1,data(sys[i].length-len,-1));\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tsys[i].length=len;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(len-sys[i].length>0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid read(int id){\n\tint len=0;\n//\trep(i,sys.size()){\n//\t\tcout << sys[i].id << \":\" << sys[i].length << \" \";\n//\t}\n//\tcout << endl;\n\n\trep(i,sys.size()){\n\t\tlen+=sys[i].length;\n\t\tif(len>id){\n\t\t\tcout <<  sys[i].id << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nvoid del(int id){\n\trep(i,sys.size()){\n\t\tif(sys[i].id==id){\n\t\t\tsys[i].id=-1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tsys.clear();\n\t\t\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tint I,S;\n\t\t\tcin >> c;\n\t\t\n\t\t\tif(c=='D'){\n\t\t\t\tcin >> I;\n\t\t\t\tdel(I);\n\t\t\t}else if(c=='W'){\n\t\t\t\tcin >> I >> S;\n\t\t\t\twrite(I,S);\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin >> I;\n\t\t\t\tread(I);\n\t\t\t}\t\t\n\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// input\ntemplate<typename T>\nvoid input(T& a) { cin >> a; }\ntemplate<typename T,typename... Ts>\nvoid input(T& a,Ts&... ts) {\n    input<T>(a);\n    input<T>(ts...);\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Input parallel\ntemplate<typename T>\nvoid input_at(size_t idx, T& a) {\n    cin >> a[idx];\n}\ntemplate<typename T, typename... Ts>\nvoid input_at(size_t idx, T& a, Ts&... ts) {\n    input_at<T>(idx, a);\n    input_at<T>(idx, ts...);\n}\ntemplate<typename T>\nvoid input_parallel(T& a) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<T>(idx, a);\n    }\n}\ntemplate<typename T, typename...Ts>\nvoid input_parallel(T& a, Ts&... ts) {\n    for (size_t idx = 0; idx < (size_t)a.size(); ++idx) {\n        input_at<Ts...>(idx, a, ts...);\n    }\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\nstruct segment {\n    // [l, r)\n    int l, r, file;\n    friend ostream& operator<<(ostream& os, const segment& s) {\n        return os << \"[\" << s.l << \",\" << s.r << \"):\" << s.file;\n    }\n};\n\nint main()\n{\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) {\n            break;\n        }\n        vector<char> type(n);\n        vector<int> d(n), r(n);\n        vector<array<int,2>> w(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> type[i];\n            if (type[i] == 'W') {\n                cin >> w[i][0] >> w[i][1];\n            } else if (type[i] == 'D') {\n                cin >> d[i];\n            } else {\n                cin >> r[i];\n            }\n        }\n\n        const int INF = numeric_limits<int>::max();\n        vector<segment> s;\n        s.push_back(segment{0, INF, -1});\n\n        for (int t = 0; t < n; ++t) {\n            if (type[t] == 'W') {\n                int file = w[t][0];\n                int len = w[t][1];\n                for (int i = 0; i < s.size(); ++i) {\n                    if (s[i].file != -1) continue;\n                    int l = s[i].l, r = s[i].r;\n                    if (len <= r - l) {\n                        s[i].l = l + len;\n                        s.insert(s.begin()+i, segment{l, l+len, file});\n                        break;\n                    } else {\n                        len -= r - l;\n                        s[i].file = file;\n                    }\n                }\n            }\n            else if (type[t] == 'D') {\n                for (int i = 0; i < s.size(); ++i) {\n                    if (s[i].file == d[t]) {\n                        s[i].file = -1;\n                    }\n                }\n            }\n            else {\n                for (int i = 0; i < s.size(); ++i) {\n                    if (s[i].l <= r[t] && r[t] < s[i].r) {\n                        cout << s[i].file << endl;\n                        break;\n                    }\n                }\n            }\n        }\n        putchar('\\n');\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> elem;\n\nint main(){\n\t\n\tint N;\n\t\n\twhile(true){\n\t\t\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tlist<elem> lst;\n\t\telem e;\n\t\te.first.first = 1500000000;\n\t\te.first.second = 1;\n\t\te.second = 1500000000;\n\t\t\n\t\tlst.push_back(e);\n\t\t\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\t\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tlist<elem>::iterator itr = lst.begin();\n\t\t\t\n\t\t\tif(c == 'W'){\n\t\t\t\tint num, count;\n\t\t\t\tcin >> num >> count;\n\t\t\t\tint pos = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\telem e_cur = *itr;\n\t\t\t\t\tif(e_cur.first.first > pos){\n\t\t\t\t\t\telem e1;\n\t\t\t\t\t\te1.first.first = pos;\n\t\t\t\t\t\te1.first.second = min(count, e_cur.first.first- pos);\n\t\t\t\t\t\te1.second = num;\n\t\t\t\t\t\tlst.insert(itr, e1);\n\t\t\t\t\t\tcount -= e_cur.first.first - pos;\n\t\t\t\t\t\tif(count <= 0){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos = e_cur.first.first + e_cur.first.second;\n\t\t\t\t\t++itr;\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\twhile(itr != lst.end()){\n\t\t\t\t\tif(((elem)*itr).second == num){\n\t\t\t\t\t\titr = lst.erase(itr);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++itr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint ans = -1;\n\t\t\t\twhile(itr != lst.end()){\n\t\t\t\t\telem e_cur = *itr;\n\t\t\t\t\tif(e_cur.first.first + e_cur.first.second >= pos){\n\t\t\t\t\t\tif(e_cur.first.first <= pos){\n\t\t\t\t\t\t\tans = e_cur.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(list<elem>::iterator itr = lst.begin(); itr != lst.end(); itr++){\n\t\t\telem e = *itr;\n\t\t\tcout << e.first.first << \" \" << e.first.second << \" \" << e.second << endl;\n\t\t}\n\t\t*/\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint Q, x, y; char b[4];\nint main() {\n\twhile (scanf(\"%d\", &Q), Q) {\n\t\tvector<vector<int> > v;\n\t\twhile (Q--) {\n\t\t\tscanf(\"%s\", b);\n\t\t\tif (b[0] == 'W') {\n\t\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\t\tfor (int i = -1; i + 1 < v.size() && y > 0; i++) {\n\t\t\t\t\tint r1 = (i != -1 ? v[i][1] : 0), r2 = v[i + 1][0];\n\t\t\t\t\tif (r1 == r2) continue;\n\t\t\t\t\tif (r2 - r1 < y) {\n\t\t\t\t\t\tv.insert(v.begin() + 1 + i, { r1, r2, x });\n\t\t\t\t\t\ty -= r2 - r1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tv.insert(v.begin() + 1 + i, { r1, r1 + y, x });\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (y > 0) {\n\t\t\t\t\tif (v.size() == 0) v.push_back({ 0, y, x });\n\t\t\t\t\telse v.push_back({ v.back()[1], v.back()[1] + y, x });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (b[0] == 'D') {\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tvector<vector<int> > w;\n\t\t\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\t\t\tif (v[i][2] != x) w.push_back(v[i]);\n\t\t\t\t}\n\t\t\t\tv = w;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscanf(\"%d\", &x);\n\t\t\t\tint ret = -1;\n\t\t\t\tfor (int i = 0; i < v.size(); i++) {\n\t\t\t\t\tif (v[i][0] <= x && x < v[i][1]) ret = v[i][2];\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", ret);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int> m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<cstring>\n#include<map>\n \nusing namespace std;\n \n\nint main(void)\n{\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t//????????????,?????\\\n\t\tmap<int,int> sec;\n\t\t\n\t\t//-1(???)???0???????§???????\n\t\tsec[0]=-1;\n\t\tsec[1000000000]=-1;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\t\n\t\t\tif(s==\"W\"){\n\t\t\t\tint a,len;\n\t\t\t\tcin>>a>>len;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second==-1){\n\t\t\t\t\t\tit->second=a;\n\t\t\t\t\t\tauto it2=it;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2->first - it->first >= len){\n\t\t\t\t\t\t\tif(it2->first - it->first == len) break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tsec[it->first+len]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse len-=it2->first - it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(s==\"D\"){\n\t\t\t\t\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second == a) it->second=-1;\n\t\t\t\t}\n\t\t\t}else if(s==\"R\"){\n\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\tit2++;\n\t\t\t\t\tif(it2==sec.end()){cout<<-1<<endl; break;}\n\t\t\t\t\tif(it->first<=a && a<it2->first){\n\t\t\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n// #define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e9 + 7;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(len == 0) break;                    \n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                            len = 0;\n                            break;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    idx--;\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          // cout << idx << \" \" << cnt << endl;\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].second == -1) {\n            if(idx + cnt - 1 <= dp[idx].first) {\n              dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx] = {idx+cnt-1, l};\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].first - idx + 1;\n            }\n          }\n          assert(idx < dp[idx].first + 1);\n          idx = dp[idx].first + 1;\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          }\n          assert(idx < dp[idx].first + 1);\n          idx = dp[idx].first + 1;\n        }\n      }\n      // for(auto& j: dp) cout << j.first << \" \" << j.second << \" \"; cout << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n; cin >> n&&n;) {\n\t\tset<T> st;\n\t\tst.emplace(-INF, 0, -1);\n\t\twhile (n--) {\n\t\t\tchar com; cin >> com;\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s; cin >> l >> s;\n\t\t\t\tfor (auto c = st.begin(); c != st.end(); c++) {\n\t\t\t\t\tint ca, cb, cc, na, nb, nc;\n\t\t\t\t\ttie(ca, cb, cc) = *c;\n\t\t\t\t\tif (next(c) == st.end()) {\n\t\t\t\t\t\tst.emplace(cb, cb + s, l);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttie(na, nb, nc) = *next(c);\n\t\t\t\t\tif (cb == na)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint d = min(s, na - cb);\n\t\t\t\t\tc = st.emplace(cb, cb + d, l).first;\n\t\t\t\t\ts -= d;\n\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tfor (auto it = st.begin(); it != st.end();) {\n\t\t\t\t\tif (get<2>(*it) == l)\n\t\t\t\t\t\tit = st.erase(it);\n\t\t\t\t\telse\n\t\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'R') {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tauto upper = st.upper_bound(T(p, 0, 0));\n\t\t\t\tint a, b, c;\n\t\t\t\ttie(a, b, c) = *prev(upper);\n\t\t\t\tif (b <= p)\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << c << endl;\n\t\t\t}\n\t\t\tdump(st);\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nstruct Sectors{\n  int start;\n  int end;\n  int id;\n  Sectors() : start(0), end(1000000010), id(-1){}\n  Sectors(int s, int e, int i) : start(s), end(e), id(i){}\n\n  int size(){ return end - start + 1; }\n  bool isEmpty(){ return id == -1; }\n  bool isIn(int sec){ return start <= sec && sec <= end; }\n};\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    list<Sectors> ss;\n    int emp = 0;\n\n    ss.push_back(Sectors());\n \n    REP(cc, n){\n      char buff[2];\n      scanf(\"%s\", buff);\n      if(buff[0] == 'W'){\n\tint l, s;\n\tscanf(\"%d%d\", &l, &s);\n\n\tif(emp == 0){\n\t  list<Sectors>::iterator it = ss.end(); --it;\n\t  int start = it->start;\n\t  int end   = start + s - 1;\n\t  it->start = end + 1;\n\t  it = ss.insert(it, Sectors(start, end, l));\n\t}else{\n\t  list<Sectors>::iterator it = ss.begin();\n\t  while(s > 0){\n\t    if(it->isEmpty()){\n\t      int sz = it->size();\n\t      if(sz > s){\n\t\tint start = it->start;\n\t\tint end   = start + s - 1;\n\t\tit->start = end + 1;\n\t\tit = ss.insert(it, Sectors(start, end, l));\n\t\tbreak;\n\t      }else{\n\t\ts -= sz;\n\t\tit->id = l;\n\t\temp--;\n\t      }\n\t    }\n\n\t    assert(it != ss.end());\n\t    ++it;\n\t  }\n\t}\n      }else if(buff[0] == 'D'){\n\tint l;\n\tscanf(\"%d\", &l);\n\tFOR(it, ss){\n\t  if(it->id == l){\n\t    it->id = -1;\n\t    emp++;\n\t  }\n\t}\n      }else{\n\tint sec;\n\tscanf(\"%d\", &sec);\n\n\tFOR(it, ss){\n\t  if(it->isIn(sec)){\n\t    printf(\"%d\\n\", it->id);\n\t    break;\n\t  }\n\t}\n      }\n\n      // FOR(it, ss)printf(\"[%d,%d]:%d \", it->start, it->end, it->id);puts(\"\");\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\nusing namespace std;\nconst int inf = 1e9+7;\n\nstruct info{\n    int color;\n    int b,e;\n    info(int c, int b, int e):color(c), b(b), e(e){}\n    bool operator < (const info &right) const {\n        return (color==right.color)? b<right.b : color<right.color;\n    }\n};\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        \n        set<info> table;      \n        set<int> ep;        \n        map<int, int> epcolor;\n        table.insert(info(-1, 0, inf));\n        ep.insert(inf);\n        epcolor[inf] = -1;\n        for(int i=0; i<n; i++){\n            char op;\n            cin >> op;\n            if(op=='W'){\n                int c, size;\n                cin >> c >> size;\n                set<info>::iterator itr = table.lower_bound(info(-1, -1, -1));\n                vector<info> writelist;\n                int total=0;\n                for(;; itr++){\n                    int start=itr->b, end=itr->e;\n                    if(end -start +1 +total < size){\n                        writelist.push_back(*itr);\n                        total += end -start +1;\n                    }else{\n                        int lim = start + (size-total);\n                        table.erase(*itr);\n                        table.insert(info(c, start, lim-1));\n                        ep.insert(lim-1);\n                        epcolor[lim-1] = c;\n                        if(lim <= end) table.insert(info(-1, lim, end));\n                        break;\n                    }\n                }\n                for(int i=0; i<(int)writelist.size(); i++){\n                    info rewrite = writelist[i];\n                    rewrite.color = c;\n                    table.erase(writelist[i]);\n                    table.insert(rewrite);\n                    epcolor[writelist[i].e] = c;\n                }\n            }\n            if(op=='D'){\n                int c;\n                cin >> c;\n                set<info>::iterator itr = table.lower_bound(info(c, -1, -1));\n                vector<info> deletelist;\n                for(;itr->color == c; itr++){\n                    deletelist.push_back(*itr);\n                }\n                for(int i=0; i<(int)deletelist.size(); i++){\n                    info rewrite = deletelist[i];\n                    rewrite.color = -1;\n                    table.erase(deletelist[i]);\n                    table.insert(rewrite);\n                    epcolor[deletelist[i].e] = -1;\n                }\n            }\n            if(op=='R'){\n                int pos;\n                cin >> pos;\n                cout << epcolor[*(ep.lower_bound(pos))] << endl;\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n    \nusing namespace std;\n  \nconst int LIMIT = 1000000000;\n  \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n    \nint N;\nvector<Data> storage;\n   \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n  \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n        \n      if(st > LIMIT) return;\n    }\n    \n    if(num == -1) {\n      // insert data back\n      num = remain;\n      into = storage.size();\n    }\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n  \nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n\nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n    \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef int ll;\ntypedef pair<int,int>P;\n#define MX 1000000001\nint N,d1[10005],d2[10005],cnt,SEQ[10005];\nchar c[10005];\n\n\n\n\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tvector<P>T;\n\t\tmap<int,vector<int> >D;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%c\",&c[i]);\n\t\t\tif(c[i]=='W')scanf(\"%d%d\\n\",&d1[i],&d2[i]);\n\t\t\telse \n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1[i]);\n\t\t\t\tif(c[i]=='R')\n\t\t\t\t\tT.push_back(make_pair(d1[i],-1));\n\t\t\t}\n\t\t}\n\t\tsort(T.begin(),T.end());\n\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(c[i]=='R')\n\t\t\t{\n\t\t\t\tfor(int j=0;j<T.size();j++)\n\t\t\t\t\tif(T[j].first==d1[i])\n\t\t\t\t\t\tprintf(\"%d\\n\",T[j].second);\n\t\t\t}\n\t\t\telse if(c[i]=='D')\n\t\t\t{\n\t\t\t\tfor(int j=0;j<D[d1[i]].size();j++)\n\t\t\t\t\tSEQ[j]-=D[d1[i]][j];\n\t\t\t\tfor(int j=0;j<T.size();j++)\n\t\t\t\t\tif(T[j].second==d1[i])\n\t\t\t\t\t\tT[j].second=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j=0,s=d2[i];j<T.size();j++)\n\t\t\t\t{\n\t\t\t\t\tint ins=0,emp=T[j].first-SEQ[j]+1;\n\t\t\t\t\tif(emp>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s>=emp)T[j].second=d1[i];\n\t\t\t\t\t\tins=min(s,emp);\n\t\t\t\t\t\ts-=min(s,emp);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=j;k<T.size();k++)\n\t\t\t\t\t\tSEQ[k]+=ins;\n\t\t\t\t\tD[d1[i]].push_back(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          // cout << idx << \" \" << cnt << endl;\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].second == -1) {\n            if(idx + cnt - 1 <= dp[idx].first) {\n              if(dp.find(idx+cnt) == dp.end()) dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx] = {idx+cnt-1, l};\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].first - idx + 1;\n            }\n          }\n          assert(idx < dp[idx].first + 1);\n          idx = dp[idx].first + 1;\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          }\n          assert(idx < dp[idx].first + 1);\n          idx = dp[idx].first + 1;\n        }\n      }\n      for(auto& j: dp) cout << j.first << \" \" << j.second << \" \"; cout << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#define SC unsigned long long\n#define ID int\n#define PP pair<SC,ID> // セクタ数、識別子\n#define P pair<SC,PP > // セクタ開始、セクタ数、識別子\n#define DEBUG false\nusing namespace std;\n\nP makeP(SC s,SC n,ID id){ return P( s,PP(n,id) ); }\n\nint main(){\n  int n;\n  char cmd;\n  SC sc, inf = (SC)(1<<31) * (SC)(1<<20);;\n  ID id;\n  vector<P> v; // 使用中\n  priority_queue< P,vector<P>, greater<P> > q; // 空き領域\n\n  while( cin>>n && n ){\n    v.clear();\n    while( !q.empty() ) q.pop();\n    q.push( makeP(0,inf,-1) );\n\n    //    cout << \"N=\" << n << \"*************\" << endl;    \n    while( n-- ){\n      cin >> cmd;\n      if( DEBUG ){\n      cout << \" CMD=\"<< cmd << \" vlen=\"<<v.size()\n\t   << \" qlen=\"<<q.size() << endl;\n      for( unsigned int i=0;i<v.size();i++ )\n\tcout << \"  \"<< v[i].first << \" \" << v[i].second.first\n\t     << \" |\" << v[i].second.second << endl;\n      cout << \"  q.f \" << q.top().first \n\t   << \" q.sf \"<< q.top().second.first << endl;\n    }\n      switch( cmd ){\n      case 'W':\n\tcin >> id >> sc;\n\twhile( sc>0 ){\n\t  P p=q.top(); q.pop();\n\t  SC bgn = p.first, len = p.second.first;\n\t  if( sc<len ){\n\t    v.push_back( makeP(bgn,sc,id) );\n\t    q.push( makeP(bgn+sc,len-sc,-1) );\n\t    sc=0;\n\t  }else{\n\t    v.push_back( makeP(bgn,len,id) );\n\t    sc -= len;\n\t  }\n\t}\n\tbreak;\n      case 'D':\n\tcin >> id;\n\tfor( unsigned int i=0;i<v.size(); ){\n\t  if( v[i].second.second == id ){\n\t    q.push( v[i] );\n\t    v.erase( v.begin()+i );\n\t  }else\n\t    i++;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> sc;\n\tunsigned int i=0;\n\twhile( i<v.size() ){\n\t  if( v[i].first <= sc && \n\t      sc < v[i].first+v[i].second.first ){\n\t    cout << v[i].second.second << endl;\n\t    break;\n\t  }\n\t  i++;\n\t}\n\tif( i==v.size() )\n\t    cout << \"-1\" << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint N;\n //<(????§???????????????????(1~), ????????????????????????), ???>\npair< pair<int, int>, int > disk[20005];\n\nint main() {\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    REP(i,0,20005) disk[i] = make_pair(make_pair(INF,INF), INF);\n    disk[0] = make_pair(make_pair(1,1000000001), -1);  //-1:empty\n    REP(i,0,N){\n      string com, inp1, inp2;\n      int num, len, ind;\n      cin>>com;\n      if(com==\"W\"){ /*?????????*/\n        cin>>inp1>>inp2;\n        num = stoi(inp1);\n        len = stoi(inp2);\n        REP(k,0,20005){\n          if(len==0) break;\n          if(disk[k].S == -1){\n            int tl = disk[k].F.S-disk[k].F.F+1;\n            if(len >= tl){\n              disk[k].S = num;\n              len -= tl;\n            }else{\n              //??°????´???????\n              int tmp = disk[k].F.F;\n              disk[k].F.F = disk[k].F.F+len;\n              RREP(l,k+1,20005){\n                disk[l] = disk[l-1];\n              }\n              disk[k] = make_pair(make_pair(tmp, tmp+len-1), num);\n              len = 0;\n            }\n          }\n        }\n      }else if(com==\"D\"){ /*??????*/\n        cin>>inp1;\n        num = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].S==num) disk[k].S = -1;\n        }\n      }else{ /*????????????*/\n        cin>>inp1;\n        ind = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].F.F <= ind && ind <= disk[k].F.S){\n            cout<<disk[k].S<<endl;\n            break;\n          }\n        }\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1000000001;\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int a,b,cnt;\n    char c;\n    vector<P> v;\n    v.push_back(P(-1,INF));\n    for(int i=0;i<n;i++){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[j].first == -1 && v[j].second > b){\n\t    v.insert(v.begin()+j, P(a,b));\n\t    break;\n\t  }\n\t}\n      } else if(c == 'D'){\n\tcin >> a;\n\tfor(int j=0;j<v.size();j++) if(v[j].first == a) v[j].first = -1;\n      } else if(c == 'R'){\n\tcin >> a;\n\tcnt = 0;\n\tfor(int j=0;j<v.size();j++){\n\t  cnt += v[j].second;\n\t  if(cnt > a){\n\t    cout << v[j].first << endl;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <algorithm>\n#include <set>\n#include <vector>\n\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\n\nstruct range {\n  int beg, ed;\n  int num;\n};\n\nint main()\n{\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    list<range> s;\n    REP(i,n){\n      string c;\n      cin>>c;\n      if(c==\"W\"){\n        int l,S;\n        cin >> l >> S;\n        int old = 0;\n        for(auto itr=begin(s);itr!=end(s);++itr){\n          auto r = *itr;\n          if(old < r.beg) {\n            int len = min(r.beg-old, S);\n            s.insert(itr, {old, old + len, l});\n            S -= len;\n            if (S <= 0) break;\n          }\n          old  = r.ed;\n        }\n        if(S > 0) {\n          s.push_back({old, old + S, l});\n        }\n      } else if (c == \"D\") {\n        int l;\n        cin>>l;\n        auto itr = remove_if(begin(s),end(s),[=](const range& r){return r.num == l;});\n        s.erase(itr, end(s));\n      } else {\n        int p;\n        cin>>p;\n        auto itr = find_if(begin(s),end(s),[=](const range& r){return r.beg <= p && p < r.ed;});\n        if (itr != end(s))\n          cout<<itr->num<<endl;\n        else\n          cout<<-1<<endl;\n      }\n      //for(auto r:s)cout<<\"(\"<<r.beg<<\",\"<<r.ed<<\"):\"<<r.num<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define V vector<pair<pair<int,int>,int> >\nusing namespace std;\nint main(){\n  int n;\n  while(cin >>n,n){\n    V code;\n    code.push_back(make_pair(make_pair(0,1000000000),-1));\n    for(int i=0; i<n; i++){\n      string s;\n      int a,b;\n      cin >>s;\n      if(s == \"W\"){\n\tcin >>a>>b;\n\tfor(int i=0; i<code.size(); i++){\n\t  if(code[i].second == -1){\n\t    int start = code[i].first.first;\n\t    int goal = code[i].first.second;\n\t    int size = goal-start+1;\n\t    if(size>b){\n\t      code[i].first.first = start+b;\n\t      code.push_back(make_pair(make_pair(start,start+b-1),a));\n\t      sort(code.begin(),code.end());\n\t      break;\n\t    }\n\t    else{\n\t      code[i].second = a;\n\t      b-=size;\n\t      if(b == 0) break;\n\t    }\n\t  }\n\t}\n      }\n      if(s == \"D\"){\n\tcin >>a;\n\tfor(int i=0; i<code.size(); i++){\n\t  if(code[i].second == a) code[i].second = -1;\n\t}\n      }\n      if(s == \"R\"){\n\tcin >>a;\n\tfor(int i=0; i<code.size(); i++) if(code[i].first.first<=a && code[i].first.second>=a){cout <<code[i].second<<endl;}\n      }\n    }\n    cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\ntypedef pair<int, ll_ll> P;\n\nint main() {\n\tfor (;;) {\n\t\tint N; cin >> N;\n\t\tif (N == 0) break;\n\t\tlist<P> l;\n\t\tl.push_back(P(-1, ll_ll(0, LLONG_MAX)));\n\t\twhile (N--) {\n\t\t\t/*for (list<P>::iterator it = l.begin(); it != l.end(); it++) {\n\t\t\t\tint& i = it->first;\n\t\t\t\tll& a = it->second.first, b = it->second.second;\n\t\t\t\tcout << i << ' ' << a << ' ' << b << endl;\n\t\t\t}*/\n\t\t\tstring s; cin >> s;\n\t\t\tif (s == \"W\") {\n\t\t\t\tint I, S; cin >> I >> S;\n\t\t\t\tfor (list<P>::iterator it = l.begin(); S > 0; it++) {\n\t\t\t\t\tint& i = it->first;\n\t\t\t\t\tll& a = it->second.first, b = it->second.second;\n\t\t\t\t\tif (i >= 0) continue;\n\t\t\t\t\tif (b - a <= S) {\n\t\t\t\t\t\ti = I;\n\t\t\t\t\t\tS -= b - a;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tl.insert(it, P(I, ll_ll(a, a + S)));\n\t\t\t\t\t\ta += S;\n\t\t\t\t\t\tS = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (s == \"D\") {\n\t\t\t\tint I; cin >> I;\n\t\t\t\tfor (list<P>::iterator it = l.begin(); it != l.end(); it++) {\n\t\t\t\t\tint& i = it->first;\n\t\t\t\t\tll& a = it->second.first, b = it->second.second;\n\t\t\t\t\tif (i == I) i = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (s == \"R\") {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tfor (list<P>::iterator it = l.begin(); it != l.end(); it++) {\n\t\t\t\t\tint& i = it->first;\n\t\t\t\t\tll& a = it->second.first, b = it->second.second;\n\t\t\t\t\tif (p >= a && p < b) {\n\t\t\t\t\t\tcout << (i >= 0 ? i : -1) << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S != 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  int cnt = 0, len = (int)vec.size(), l, num = vec[0].first;\n\n  scanf(\"%d\" ,&l);\n\n  if(len == 0){\n    return -1;\n  }\n  \n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }\n  }\n\n  if(cnt <= l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s - 1));\n                        endtoi[x.first + s - 1] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second));\n                        endtoi[x.second] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(mp[i][j]);\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                if(it == endtoi.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n            if(c == 'X'){\n                \n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size < S) {\n              S -= v[i].size;\n            } else if(v[i].size > S) {\n              S = 0;\n              v.insert(v.begin()+i, (Data){v[i].size - S, -2});\n            }\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(int i = 0, sum = 0; output == -1 && i < v.size();\n            sum += v[i].size, ++i) {\n          if(sum <= P && P < sum+v[i].size) {\n            output = v[i].id;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\n\nint main(){\n\tint N;\n\twhile(cin >> N && N){\n\t\tset< pair< pair<int,int> , int> > se;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"D\" ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tvector< pair< pair<int,int>,int> > del;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( it->second == v ){\n\t\t\t\t\t\tse.erase(it++);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( s == \"W\" ){\n\t\t\t\tint l,sec;\n\t\t\t\tcin >> l >> sec;\n\t\t\t\tint prev = 0;\n\t\t\t\tvector< pair<int,int> > ad;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( sec == 0 ) break;\n\t\t\t\t\tint width = it->first.first - prev;\n\t\t\t\t\tint use = min(sec,width);\n\t\t\t\t\tif( use != 0 ) {\n\t\t\t\t\t\tsec -= use;\n\t\t\t\t\t\tad.push_back(make_pair(prev,prev+use));\n\t\t\t\t\t}\n\t\t\t\t\tprev = it->first.second;\n\t\t\t\t}\n\t\t\t\tif( sec != 0 ){\n\t\t\t\t\tad.push_back(make_pair(prev,prev+sec));\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < ad.size() ; i++)\n\t\t\t\t\tse.insert(make_pair(ad[i],l));\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->first.first <= pos && pos < it->first.second ){\n\t\t\t\t\t\tcout << it->second << endl;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !flag ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef vector<P>::iterator ITE;\nstruct data{\n  ll num;\n  vector<P> MEM;\n  data(){}\n  data(int n,vector<P> m):num(n),MEM(m){}\n  bool operator < (const data& d) const {return num < d.num;}\n};\n\nconst ll MAX = 10000000000000LL;\nvector<P> Free;\nvector<data> V;\n\nvoid init(){\n\n  Free.clear();\n  Free.push_back(P(0,MAX));\n\n}\n\nvoid write(ll a, ll b){\n  sort(Free.begin(),Free.end());\n  vector<P> tmp;\n\n  for(int i = 0; i < (int)Free.size(); i++){\n    if(Free[i].second-Free[i].first+1 > b){\n      tmp.push_back(P(Free[i].first, Free[i].first+b-1));\n      //     cout << \"push \" << Free[i].first << \" \" << Free[i].first+b-1 << \" \" << a << endl;\n      Free[i].first += b;\n      break;\n    }else{\n      tmp.push_back(Free[i]);\n      b -= Free[i].second-Free[i].first+1;\n      //  cout << \"push \" << Free[i].first << \" \" << Free[i].second << \" \" << a << endl;\n      vector<P>::iterator ite = (ITE)&Free[i];\n      Free.erase(ite);\n      i--;\n    }\n  }\n  V.push_back(data(a,tmp));\n}\n\nvoid del(ll num){\n\n  sort(V.begin(),V.end());\n  vector<data>::iterator ite = lower_bound(V.begin(),V.end(),data(num,vector<P>()));\n  if(ite->num != num) assert(false);\n\n  for(int i = 0; i < (int)ite->MEM.size(); i++)\n    Free.push_back(ite->MEM[i]);\n\n  V.erase(ite);\n\n}\n\nvoid ref(ll num){\n  for(int i = 0; i < (int)V.size(); i++){\n    vector<P> tmp = V[i].MEM;\n    for(int j = 0; j < (int)tmp.size(); j++){\n      if(tmp[j].first <= num && num <= tmp[j].second){\n\tcout << V[i].num << endl;\n\treturn;\n      }\n    }\n  }\n  \n  cout << \"-1\" << endl;\n}\n\nint main(){\n  int n;\n  bool f = false;\n\n  while(cin >> n && n){\n    if(f) cout << endl;\n    f = true;\n    init();\n    while(n--){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n\tll a,b;\n\tcin >> a >> b;\n\twrite(a,b);\n      }\n\n      if(c == 'D'){\n\tll a;\n\tcin >> a;\n\tdel(a);\n      }\n\n      if(c == 'R'){\n\tll a;\n\tcin >> a;\n\tref(a);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        typedef tuple<int,int,int> triple;\n        set<triple> intervals;\n        intervals.insert(triple(0,0,-inf));\n        rep(i,0,n){\n            /*\n            for(const auto& interval:intervals){\n                cout << get<0>(interval) << \" \" << get<1>(interval) << \" \" << get<2>(interval) << endl;\n            }\n            */\n            char command;\n            cin >> command;\n            if(command=='W'){\n                int id,len;\n                cin >> id >> len;\n                auto a=intervals.begin();\n                auto b=intervals.begin();\n                ++b;\n                while(len>0){\n                    int l=get<1>(*a);\n                    if(b==intervals.end()){\n                        intervals.insert(triple(l,l+len,id));\n                        break;\n                    }\n                    auto r=get<0>(*b);\n                    if(l==r){\n                        a=b;\n                        ++b;\n                        continue;\n                    }\n                    if(r-l>len) r=l+len;\n                    b=intervals.insert(triple(l,r,id)).first;\n                    a=b;\n                    ++b;\n                    len-=r-l;\n                }\n            }else if(command=='D'){\n                int id;\n                cin >> id;\n                for(auto it=intervals.begin();it!=intervals.end();){\n                    if(get<2>(*it)==id) it=intervals.erase(it);\n                    else ++it;\n                }\n            }else{\n                int addr;\n                cin >> addr;\n                bool ok=false;\n                for(const auto& interval:intervals) if(get<0>(interval)<=addr and addr<get<1>(interval)){\n                    cout << get<2>(interval) << endl;\n                    ok=true;\n                    break;\n                }\n                if(!ok) cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\nint main() {\n\tint N;\n\tbool head = 1;\n\twhile (cin >> N, N) {\n\t\tif (!head) cout << endl;\n\t\thead = 0;\n\t\tmap<int, vector<P>> v;\n\t\tpriority_queue<P, vector<P>, greater<P>> Q;\n\t\tQ.push(P(0, 1000000000));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring command;\n\t\t\tcin >> command;\n\t\t\tif (command == \"W\") {\n\t\t\t\tint l, S;\n\t\t\t\tcin >> l >> S;\n\t\t\t\tint sum = 0;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tP p = Q.top(); Q.pop();\n\t\t\t\t\tint len = p.second - p.first + 1;\n\t\t\t\t\tif (sum + len < S) {\n\t\t\t\t\t\tsum += len;\n\t\t\t\t\t\tv[l].push_back(p);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tv[l].push_back(P(p.first, p.first + (S - sum) - 1));\n\t\t\t\t\tQ.push(P(p.first + (S - sum), p.second));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (command == \"D\") {\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor (P p : v[l]) {\n\t\t\t\t\tQ.push(p);\n\t\t\t\t}\n\t\t\t\tv[l].clear();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tbool ok = 0;\n\t\t\t\tfor (auto &itr : v) {\n\t\t\t\t\tfor (P p : itr.second) {\n\t\t\t\t\t\tif (p.first <= l && l <= p.second) {\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\tcout << itr.first << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ok) break;\n\t\t\t\t}\n\t\t\t\tif (!ok) cout << -1 << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\nint main(void){\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(n == 0) break;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tq.push(make_pair(0, INF));\n\t\tmap<int, vpint> m;\n\t\trep(i, n){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c == 'W'){\n\t\t\t\tint num, size; cin >> num >> size;\n\t\t\t\twhile(size > 0){\n\t\t\t\t\tint l = q.top().fi, r = q.top().se;\n\t\t\t\t\t// printf(\"l %d r %d\\n\", l, r);\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(r - l + 1 >= size){//??????\n\t\t\t\t\t\t// printf(\"push %d %d\\n\", l + size, r);\n\t\t\t\t\t\tq.push(make_pair(l + size, r));\n\t\t\t\t\t\tm[num].push_back(make_pair(l, l + size - 1));\n\t\t\t\t\t\tsize = 0;\n\t\t\t\t\t}else{//?¶??????????\n\t\t\t\t\t\tm[num].push_back(make_pair(l, r));\n\t\t\t\t\t\tsize -= (r - l + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint num; cin >> num;\n\t\t\t\tfor(auto u : m[num]){\n\t\t\t\t\t// printf(\"delete %d %d\\n\", u.fi, u.se);\n\t\t\t\t\tq.push(make_pair(u.fi, u.se));\n\t\t\t\t}\n\t\t\t\tm[num].erase(all(m[num]));\n\t\t\t}else{\n\t\t\t\tint idx; cin >> idx;\n\t\t\t\tbool flag = false;\n\t\t\t\teach(it, m){\n\t\t\t\t\tauto key = it->fi;\n\t\t\t\t\tauto v = it->se;\n\t\t\t\t\t// printf(\"key %d vsize %d\\n\", key, (int)v.size());\n\t\t\t\t\tfor (int i = 0; i < v.size(); ++i){\n\t\t\t\t\t\tif(v[i].fi <= idx && idx <= v[i].se){\n\t\t\t\t\t\t\tprintf(\"%d\\n\", key);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) break;\n\t\t\t\t}\n\t\t\t\tif(!flag){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n              break;\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        lli output = -1;\n        for(lli i = 0, sum = 0; i < v.size(); sum += v[i++].size) {\n          if(P < sum+v[i].size) {\n            if(v[i].id >= 0) output = v[i].id;\n            break;\n          }\n        }\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvoid qwrite(int a, int b, queue<P>& que){\n  int size = que.size();\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.first != -1 || b == 0){\n      que.push(p);\n      continue;\n    }\n    if(p.first == -1){\n      if(p.second == -1){\n        que.push(P(a, b));\n        que.push(P(-1, -1));\n        b = 0;\n      }else if(p.second > b){\n        que.push(P(a, b));\n        que.push(P(-1, p.second - b));\n        b = 0;\n      }else if(p.second <= b){\n        que.push(P(a, p.second));\n        b -= p.second;\n      }\n    }\n  }\n}\n\nvoid qdelete(int a, queue<P>& que){\n  int size = que.size();\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.first == a){\n      que.push(P(-1, p.second));\n    }else{\n      que.push(p);\n    }\n  }\n}\n\nvoid qread(int a, queue<P>& que){\n  long long cnt = 0LL;\n  int size = que.size();\n  bool f = false;\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.second != -1) cnt += p.second;\n    if(f || a >= cnt){\n      que.push(p);\n      continue;\n    }\n    if(a < cnt){\n      cout << p.first << endl;\n      f = true;\n    }\n  }\n  if(!f) cout << -1 << endl;\n}\n\nmain(){\n  int n;\n  while(cin >> n && n){\n    queue<P> que;\n    que.push(P(-1, 1000000000));\n    for(int i=0;i<n;i++){\n      char c;\n      int a, b;\n      cin >> c;\n      if(c == 'W'){\n        cin >> a >> b;\n        qwrite(a, b, que);\n      }\n      if(c == 'D'){\n        cin >> a;\n        qdelete(a, que);\n      }\n      if(c == 'R'){\n        cin >> a;\n        qread(a, que);\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef long long ll;\n\nstruct sector { ll l, r, f; };\n\nll N, I, S, P;\nchar C;\nsector a[1000];\nint k;\n\nvoid write() {\n  cin >> I >> S;\n  REP(i, 0, k) if(a[i].f == -1 && S > 0) {\n    if(S >= a[i].r - a[i].l) {\n      a[i].f = I;\n      S -= a[i].r - a[i].l;\n    } else {\n      for(int j = k; j > i; j--) {\n        a[j + 1].l = a[j].l;\n        a[j + 1].r = a[j].r;\n        a[j + 1].f = a[j].f;\n      }\n      a[i + 1].r = a[i].r;\n      a[i + 1].f = -1;\n      a[i].f = I;\n      a[i].r = a[i].l + S;\n      a[i + 1].l = a[i].r;\n      S = 0;\n      k++;\n      break;\n    }\n  }\n  if(S > 0) {\n    int l = k > 0 ? a[k - 1].r : 0;\n    a[k++] = (sector) { l, l + S, I };\n  }\n}\n\nvoid destroy() {\n  cin >> I;\n  REP(i, 0, k) if(a[i].f == I) a[i].f = -1;\n}\n\nll read() {\n  cin >> P;\n  REP(i, 0, k) if(a[i].l <= P && P < a[i].r) return a[i].f;\n  return -1;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    k = 0;\n    REP(i, 0, N) {\n      cin >> C;\n      if(C == 'W') write();\n      if(C == 'D') destroy();\n      if(C == 'R') cout << read() << endl;\n\n      // cout << i << \": \" << C << \" \" << k << endl;\n      // REP(i, 0, k) {\n      //   cout << a[i].l << \" - \" << a[i].r << \": \" << a[i].f << endl;\n      // }\n      // cout << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing P=pair<int,int>;\nusing PP=pair<P,int>;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<PP>data;\n        for(int j=0;j<n;++j){\n            char c;cin>>c;\n            if(c=='W'){\n                int l,s;cin>>l>>s;\n                int siz=data.size();\n                if(siz==0)data.push_back(PP(P(0,s),l));\n                for(int i=0;i<siz;++i){\n                    if(data[i].second==-1){\n                        if(s>=data[i].first.second-data[i].first.first){\n                            s-=(data[i].first.second-data[i].first.first);\n                            data[i].second=l;\n                            if(!s)break;\n                        }else{\n                            data.push_back(PP(P(data[i].first.first,data[i].first.first+s),l));\n                            data[i].first.first+=s;\n                            s=0;\n                            break;\n                        }\n                    }\n                    if(i==(siz-1)){\n                        data.push_back(PP(P(data[i].first.second,data[i].first.second+s),l));\n                        s=0;\n                    }\n                }\n                sort(data.begin(),data.end());\n            }else if(c=='D'){\n                int l;cin>>l;\n                for(int i=0;i<data.size();++i){\n                    if(data[i].second==l){\n                        data[i].second=-1;\n                    }\n                }\n            }else{\n                int p,ans=-1;cin>>p;\n                for(int i=0;i<data.size();++i){\n                    if(data[i].first.first<=p && data[i].first.second>p){\n                        ans=data[i].second;\n                        break;\n                    }\n                }\n                cout<<ans<<endl;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\t!!k&&m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n#define NON -1\ntypedef pair < int , int > Pi;\ntypedef pair < Pi , int > Pii;\nvector< Pii > memory; //セクタの状態\nvoid write( int l, int sum){ //書き込む\n  for(int i = 0; sum > 0 ; i++){\n    if(memory[i].sc != NON) continue;\n    int kazu = memory[i].fr.sc - memory[i].fr.fr + 1;\n    if(kazu <= sum){\n      memory[i].sc = l, sum -= kazu;\n    }else{\n      memory.insert( memory.begin() + i, Pii( Pi( memory[i].fr.fr, memory[i].fr.fr + sum - 1), l));\n      memory[++i].fr.fr = memory[i - 1].fr.sc + 1;\n      sum = 0;\n    }\n  }\n}\nvoid erase( int idx){ //消す\n  for(int i = 0; i < memory.size() ; i++){\n    if(memory[i].sc == idx) memory[i].sc = NON;\n  }\n}\nvoid read( int idx){ //読み込む\n  cout << (upper_bound(memory.begin(),memory.end(),Pii(Pi(idx,-1),-1))-1) -> sc << endl;\n  // while(memory[pos].fr.sc < idx) pos++;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    memory.clear();\n    memory.push_back( Pii( Pi( 0, 1000000001), NON));\n    while(n--){\n      char buff;\n      cin >> buff;\n      if(buff == 'W'){ //write\n        int a, b;\n        cin >> a >> b;\n        write(a,b);\n      }else if(buff == 'D'){ //delete\n        int a;\n        cin >> a;\n        erase(a);\n      }else{ //read\n        int a;\n        cin >> a;\n        read(a);\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n// disk[i] = (id, width)\nvector<PII> disk;\n\nvoid Write(){\n  int id, sz; cin >> id >> sz;\n  for(auto it=disk.begin();sz>0;++it){\n\tif(it->first != -1) continue;\n\tif(sz < it->second){\n\t  it->second -= sz;\n\t  disk.insert(it, MP(id,sz));\n\t  return;\n\t}\n\telse{\n\t  it->first = id;\n\t  sz -= it->second;\n\t}\n  }\n}\n\nvoid Del(){\n  int id; cin >> id;\n  for(auto& pii: disk)\n\tif(pii.first == id)\n\t  pii.first = -1;\n}\n\nvoid Read(){\n  int a; cin >> a;\n  int p = 0;\n  for(auto& pii: disk){\n\tif(a < p + pii.second){\n\t  cout << pii.first << endl;\n\t  return;\n\t}\n\tp += pii.second;\n  }\n  cout << -1 << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  \n  int N;\n  while(cin >> N, N){\n\tdisk.assign(1, MP(-1, 1000000000+100));\n\tREP(i,N){\n\t  char q;\n\t  cin >> q;\n\t  switch(q){\n\t  case 'W':\n\t\tWrite();\n\t\tbreak;\n\t  case 'D':\n\t\tDel();\n\t\tbreak;\n\t  case 'R':\n\t\tRead();\n\t\tbreak;\t\t\n\t  }\n\t}\n\tcout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define EB emplace_back\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Cmd {\n    char c;\n    int a, b;\n};\n\nstruct Sector {\n    Sector(){}\n    Sector(int _b, int _e, int _l) : b(_b), e(_e), l(_l) {}\n    int b, e, l;\n    bool operator < (const Sector &s) const {\n        return b < s.b;\n    }\n};\n\nint N;\n\nvector<Cmd> cmds;\n\nvoid dump(vector<Sector> &ss) {\n    VI ts(10, -1);\n    cout << \"---\" << endl;\n    for (auto &s : ss) {\n        cout << s.b << \" \" << s.e << \" \" << s.l << endl;\n        for (int i = s.b; i < s.e; i++) {\n            ts[i] = s.l;\n        }\n    }\n    for (auto t : ts) cout << t << \" \";\n    cout << endl;\n    cout << \"/---\" << endl;\n}\n\nvoid cmd_write(vector<Sector> &ss, int l, int size) {\n    int begin = 0;\n    \n    for (auto &s : ss) {\n        if (begin < s.b) {\n            int end = min(s.b, begin + size);\n            ss.EB(begin, end, l);\n\n            size -= end - begin;\n\n            if (size == 0) {\n                break;\n            }\n        }\n\n        begin = s.e;\n    }\n\n    if (size) {\n        int end = begin + size;\n        ss.EB(begin, end, l);\n    }\n\n    sort(ALL(ss));\n\n}\n\nvoid cmd_delete(vector<Sector> &ss, int l) {\n    for (int i = 0; i < (int)ss.size(); i++) {\n        if (ss[i].l == l) {\n            ss.erase(ss.begin() + i);\n            --i; // ???????????????????????´\n        }\n    }\n}\n\nint cmd_reference(vector<Sector> &ss, int p) {\n    for (auto &s : ss) {\n        if (s.b <= p && p < s.e) {\n            return s.l;\n        } else if (p < s.b) {\n            return -1;\n        }\n    }\n\n    return -1;\n}\n\nvoid solve() {\n    vector<Sector> ss;\n\n    for (int i = 0; i < N; i++) {\n        if (cmds[i].c == 'W') {\n            cmd_write(ss, cmds[i].a, cmds[i].b);\n        } else if (cmds[i].c == 'D') {\n            cmd_delete(ss, cmds[i].a);\n        } else if (cmds[i].c == 'R') {\n            cout << cmd_reference(ss, cmds[i].a) << endl;\n        }\n//        dump(ss);\n    }\n\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        cmds.clear();\n        cmds.resize(N);\n\n        for (int i = 0; i < N; i++) {\n            cin >> cmds[i].c;\n\n            if (cmds[i].c == 'W') {\n                cin >> cmds[i].a >> cmds[i].b;\n            } else {\n                cin >> cmds[i].a;\n            }\n        }\n\n        solve();\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s));\n                        endtoi[x.first + s] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second));\n                        endtoi[x.second] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(mp[i][j]);\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                if(it == endtoi.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = i64(1e18)+MOD;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int n;\n    input(n);\n    if(!n)\n        return false;\n    set<tuple<int,int,int>> s;\n    for(int _ = 0; _ < n; ++_){\n        char c;\n        input(c);\n        if(c == 'W'){\n            int x, len;\n            input(x, len);\n            int p = 0;\n            while(len){\n                auto it = s.upper_bound(make_tuple(p, MOD, MOD));\n                if(it == s.begin()){\n                    int st = p;\n                    int en = get<0>(*it);\n                    chmin(en, st + len);\n                    s.emplace(st, en, x);\n                    len -= en - st;\n                    p = en;\n                    continue;\n                }\n                --it;\n                if(p < get<1>(*it)){\n                    p = get<1>(*it);\n                    continue;\n                }\n                int st = p;\n                int en = next(it) == s.end() ? MOD : get<0>(*next(it));\n                chmin(en, st + len);\n                s.emplace(st, en, x);\n                len -= en - st;\n                p = en;\n            }\n        }else if(c == 'D'){\n            int l;\n            input(l);\n            for(auto it = s.begin(); it != s.end();){\n                if(get<2>(*it) == l)\n                    it = s.erase(it);\n                else\n                    ++it;\n            }\n        }else{\n            int p;\n            input(p);\n            auto it = s.upper_bound(make_tuple(p, MOD, MOD));\n            if(it == s.begin()){\n                cout << -1 << endl;\n                continue;\n            }\n            --it;\n            if(p < get<1>(*it)){\n                cout << get<2>(*it) << endl;\n            }else\n                cout << -1 << endl;\n        }\n    }\n\n    cout << endl;\n    return true;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nint main(){\n    int N;\n    while(1){\n        cin >> N;\n        if(!N) return 0;\n        vector<char> c;\n        vector<P> v;\n        for (int i = 0; i < N; i++) {\n            char C;cin >> C;\n            c.pb(C);\n            if(C=='W'){\n                LL x,y;cin >> x >> y;\n                v.pb(mp(x,y));\n            }\n            else if(C=='D'){\n                LL x;cin >> x;\n                v.pb(mp(x,-1));\n            }\n            else if(C=='R'){\n                LL x;cin >> x;\n                v.pb(mp(-1,-1));\n                x++;\n                LL ans = -1;\n                LL t = 0;\n                map<LL,LL> ma;\n                for (int j = 0; j < c.size(); j++) {\n                    if(c[j]=='W'){\n                        if(t+v[j].sc<=x){\n                            t+=v[j].sc;\n                            ma[v[j].fs]+=v[j].sc;\n                        }\n                        else{\n                            ma[v[j].fs]+=x-t;\n                            t=x;\n                        }\n                        if(t==x&&ans==-1){\n                            ans=v[j].fs;\n                        }\n                    }\n                    else if(c[j]=='D'){\n                        t-=ma[v[j].fs];\n                        if(v[j].fs==ans) ans=-1;\n                    }\n                }\n                cout << ans << endl;\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 1000000001;\nint main(){\n  while (1){\n    int N;\n    cin >> N;\n    if (N == 0){\n      break;\n    }\n    vector<pair<int, int>> L;\n    L.push_back(make_pair(-1, INF));\n    for (int i = 0; i < N; i++){\n      char c;\n      cin >> c;\n      if (c == 'W'){\n        int l, S;\n        cin >> l >> S;\n        vector<pair<int, int>> L2;\n        for (auto R : L){\n          if (R.first == -1){\n            if (S >= R.second){\n              L2.push_back(make_pair(l, R.second));\n              S -= R.second;\n            } else if (S > 0){\n              L2.push_back(make_pair(l, S));\n              L2.push_back(make_pair(-1, R.second - S));\n              S = 0;\n            } else {\n              L2.push_back(R);\n            }\n          } else {\n            L2.push_back(R);\n          }\n        }\n        swap(L, L2);\n      }\n      if (c == 'D'){\n        int l;\n        cin >> l;\n        vector<pair<int, int>> L2;\n        for (auto R : L){\n          if (R.first == l){\n            L2.push_back(make_pair(-1, R.second));\n          } else {\n            L2.push_back(R);\n          }\n        }\n        swap(L, L2);\n      }\n      if (c == 'R'){\n        int P;\n        cin >> P;\n        for (auto R : L){\n          if (P >= R.second){\n            P -= R.second;\n          } else {\n            cout << R.first << endl;\n            break;\n          }\n        }\n      }\n    }\n    cout << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Section {\n    int contents;\n    ll start,end;\n    Section(int s,int e,int c) : start(s), end(e), contents(c) {;}\n\n    ll size() { return end - start + 1; }\n};\n\nclass Disk {\nprivate:\n    int _size;\n    vector<Section> sv;\n\npublic:\n    Disk () {\n        sv.clear();\n        sv.push_back(Section(0,1000000000ll,-1));\n    }\n\n    typedef vector<Section>::iterator itr;\n\n    int getSize() { return _size; }\n\n    void write(ll file_id,ll size) {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            if(it->contents == -1) {\n//                cout<<\"write file\"<<endl;\n                it->contents = file_id;\n                if(it->size() > size) {\n                    ll e = it->end;\n                    it->end = it->start + size -1;\n                    ll nexts = (it->end)+1;\n                    it++;\n                    sv.insert(it, 1, Section( nexts, e, -1));\n                    return;\n                }else{\n                    size -= it->size();\n                }\n            }\n        }\n//        cout<<\"write successful\"<<endl;\n    }\n\n    void dump() {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            cout<<\"from \"<<it->start<<\" to \"<<it->end<<\" : file_id \"<<it->contents<<endl;\n        }\n    }\n\n    void delete_file(ll file_id) {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            if(it->contents == file_id) {\n                it->contents = -1;\n                break;\n            }\n        }\n        return;\n    }\n\n    int reference(ll ptr) {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            if(it->start <= ptr && it->end >= ptr) return it->contents;\n        }\n        return -1;\n    }\n\n    void reconstruction() {\n        for(itr it = sv.begin(); it+1 != sv.end(); ++it) {\n            if(it->contents == -1 && (it+1)->contents == -1) {\n                it->end = (it+1)->end;\n                it = sv.erase((it+1));\n                it--;\n            }\n        }\n    }\n};\n\nint main() {\n    int N;\n    ll rs,rt;\n    string op;\n    while(cin>>N, N) {\n        Disk disk;\n        for(int i=0; i<N; ++i) {\n            cin>>op;\n            if(op == \"W\") {\n                cin>>rs>>rt;\n                disk.write(rs,rt);\n            }else if(op == \"D\") {\n                cin>>rs;\n                disk.delete_file(rs);\n            }else{\n                cin>>rs;\n                cout<<disk.reference(rs)<<endl;\n            }\n//            disk.dump();\n        }\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Data{\n\tint id,pos,len;\n\tData(){}\n\tData(int I,int P,int L):id(I),pos(P),len(L){}\n};\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tlist<Data> L;\n\t\twhile(n--){\n\t\t\tchar type; scanf(\" %c\",&type);\n\t\t\tif(type=='W'){\n\t\t\t\tint id,len; scanf(\"%d%d\",&id,&len);\n\t\t\t\tint pos=0;\n\t\t\t\tlist<Data>::iterator it;\n\t\t\t\tfor(it=L.begin();it!=L.end();++it){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(pos<a.pos){\n\t\t\t\t\t\tint d=min(a.pos-pos,len);\n\t\t\t\t\t\tlen-=d;\n\t\t\t\t\t\tL.insert(it,Data(id,pos,d));\n\t\t\t\t\t}\n\t\t\t\t\tif(len==0) break;\n\t\t\t\t\tpos=a.pos+a.len;\n\t\t\t\t}\n\t\t\t\tif(len>0){\n\t\t\t\t\tL.insert(it,Data(id,pos,len));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(type=='D'){\n\t\t\t\tint id; scanf(\"%d\",&id);\n\t\t\t\tlist<Data>::iterator it;\n\t\t\t\tfor(it=L.begin();it!=L.end();){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(id==a.id) it=L.erase(it);\n\t\t\t\t\telse ++it;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{ // type=='R'\n\t\t\t\tint pos; scanf(\"%d\",&pos);\n\t\t\t\tint ans=-1;\n\t\t\t\tlist<Data>::iterator it;\n\t\t\t\tfor(it=L.begin();it!=L.end();++it){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(a.pos<=pos && pos<a.pos+a.len){\n\t\t\t\t\t\tans=a.id;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos<a.pos) break;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n \nint N;\nvector<Data> storage;\n\nvoid dump() {\n  #ifdef DEBUG\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n  #endif\n}\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n\tinto = i;\n\tbreak;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      /*\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      */\n      num = remain;\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nvoid del(int id) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n      #ifdef DEBUG\n      cout << \"Deleted: \" << id << endl;\n      dump();\n      #endif\n    }\n  }\n}\n \nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n\t//dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        list<pair<int,pair<int, int>>> ls;\n        ls.push_back(make_pair(-1,make_pair(-1,-1)));\n\n        rep(i,n){\n            char com;\n            cin >> com;\n            if(com == 'W'){\n                int a, b;\n                cin >> a >> b;\n                auto cur = ls.begin();\n                auto bef = ls.begin();\n                cur++;\n                while(b > 0){\n                    int tmp = bef->second.second + 1;\n                    if(cur == ls.end()){\n                        ls.push_back(make_pair(a,make_pair(tmp, tmp + b - 1)));\n                        b = 0;\n                    }else if(bef->second.second + 1 != cur->second.first){\n                        int dif = cur->second.first - bef->second.second - 1;\n                        if(b <= dif){\n                            ls.insert(cur,make_pair(a,make_pair(tmp,tmp + b - 1)));\n                            b = 0;\n                        }else{\n                            ls.insert(cur,make_pair(a,make_pair(tmp,cur->second.first - 1)));\n                            b -= dif;\n                        }\n                        cur--;\n                        bef = cur;\n                        bef--;\n                    }\n                    cur++;\n                    bef++;\n                }\n            }else if(com == 'D'){\n                int a;\n                cin >> a;\n                for(auto it = ls.begin(); it != ls.end();){\n                    if(it->first == a){\n                        it = ls.erase(it);\n                    }else{\n                        it++;\n                    }\n                }\n            }else{\n                int a;\n                cin >> a;\n\n                bool f = false;\n                for(auto it:ls){\n                    if(it.second.first <= a && a <= it.second.second){\n                        cout << it.first << endl;\n                        f = true;\n                        break;\n                    }\n                }\n                if(not f) cout << -1 << endl;\n            }\n            //for(auto it : ls){ cout << it.second.first << ' ' << it.second.second << endl; }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iterator>\n#define vecsize 200000000\nint vec[vecsize];\nvoid W(int x,int y){\n    for(int i=0;i<vecsize;++i){\n        if(y>0)if(vec[i]==-1)vec[i]=x,--y;\n    }\n}\nvoid D(int x){\n    int size=vecsize-1;\n    if(x<=size)for(int i=vecsize-1;i>=0;--i){\n        if(vec[i]==x){\n            vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vecsize;\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    for(int i=0;i<vecsize;++i){\n        vec[i]=-1;\n    }\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n        }\n        b=false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n\nusing namespace std;\n\n#define REP(i, n) for(long i=0; i<n; i++)\n\ntypedef pair<long, long> pii;\n\nconst long max_n = 10e5;\nconst long max_i = 10e9;\nlong n;\nchar com;\nmap<long, long> f2i;\nmap<long, long> i2f;\n\ndeque<pii> empty;\nvector<pii> used[max_n];\n\nvoid writef(long f, long c, long idx){\n    f2i[f] = idx;\n    i2f[idx] = f;\n\n    while(1){\n        if(c==0) break;\n\n        pii e = empty.front();\n        empty.pop_front();\n        if(e.second-e.first>c){\n            used[f2i[f]].push_back(make_pair(e.first, e.first+c));\n            empty.push_front(make_pair(e.first+c, e.second));\n            c = 0;\n        } else {\n            c -= e.second - e.first;\n            used[f2i[f]].push_back(e);\n        }\n    }\n}\n\nvoid delf(long f){\n    REP(i, used[f2i[f]].size()){\n        deque<pii> tmp;\n        pii u = used[f2i[f]][i];\n        REP(j, empty.size()){\n            pii e = empty.front();\n            empty.pop_front();\n            if(u.second<=e.first){\n                tmp.push_back(u);\n                empty.push_front(e);\n            } else {\n                tmp.push_back(e);\n                tmp.push_back(u);\n            }\n        }\n\n        REP(j, tmp.size()){\n            pii t = tmp.back();\n            tmp.pop_back();\n            empty.push_front(t);\n        }\n    }\n    used[f2i[f]].clear();\n}\n\nvoid readf(long s){\n    REP(i, n){\n        REP(j, used[i].size()){\n            pii u = used[i][j];\n            if(u.first<=s && s<u.second){\n                cout << i2f[i] << endl;\n                return;\n            }\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        empty.push_back(make_pair(0, max_i));\n        REP(i, n){\n            cin >> com;\n\n            if(com=='W'){\n                long f, c; // file, count\n                cin >> f >> c;\n                writef(f, c, i);\n            } else if(com=='D'){\n                long f;\n                cin >> f;\n                delf(f);\n            } else if(com=='R'){\n                long s;\n                cin >> s;\n                readf(s-1);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lidl,ridl;\n\tint idl;\n\tint l,r;\n\tdata(){}\n\tdata(int iidl,int ll,int rr,int lll,int rrr){\n\t\tidl=iidl;\n\t\tlidl=ll;\n\t\tridl=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> idl;\nvector<int> idldata;\nvector<int> placee[10001];\nint n;\nint st,en;\n\nint main(voidl){\n\twhile(1){\n\t\tdat.clear();\n\t\tidl.clear();\n\t\tidldata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(idl.find(l)==idl.end()){\n\t\t\t\t\tidl[l]=idldata.size();\n\t\t\t\t\tidldata.push_back(l);\n\t\t\t\t\tplacee[idl[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(idl[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lidl=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lidl].r){\n\t\t\t\t\t\t\tdat.push_back(data(idl[l],dat[nv].lidl,nv,dat[dat[nv].lidl].r,dat[dat[nv].lidl].r+min(s,dat[nv].l-dat[dat[nv].lidl].r)));\n\t\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lidl].r);\n\t\t\t\t\t\t\tdat[dat[nv].lidl].ridl=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lidl=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].ridl=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(idl.find(l)==idl.end())continue;\n\t\t\t\tfor(int i=0;i<placee[idl[l]].size();i++){\n\t\t\t\t\tdata d=dat[placee[idl[l]][i]];\n\t\t\t\t\tif(d.lidl==-1)st=d.ridl;\n\t\t\t\t\tif(d.ridl==-1)en=d.lidl;\n\t\t\t\t\tdat[d.ridl].lidl=d.lidl;\n\t\t\t\t\tdat[d.lidl].ridl=d.ridl;\n\t\t\t\t}\n\t\t\t\tplacee[idl[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?idldata[dat[nv].idl]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].ridl){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].idl,dat[i].lidl,dat[i].ridl,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S != 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  scanf(\"%d\" ,&l);\n\n  if(len == 0){\n    return -1;\n  }\n  \n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n; cin >> n&&n;) {\n\t\tset<T> st;\n\t\tst.emplace(-INF, 0, -1);\n\t\twhile (n--) {\n\t\t\tchar com; cin >> com;\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s; cin >> l >> s;\n\t\t\t\tfor (auto c = st.begin(); c != st.end(); c++) {\n\t\t\t\t\tauto n = c; n++;\n\t\t\t\t\tint ca, cb, cc, na, nb, nc;\n\t\t\t\t\ttie(ca, cb, cc) = *c;\n\t\t\t\t\tif (n == st.end()) {\n\t\t\t\t\t\tst.emplace(cb, cb + s, l);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttie(na, nb, nc) = *n;\n\t\t\t\t\tif (cb == na)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint d = min(s, na - ca);\n\t\t\t\t\tst.emplace(cb, cb + d, l);\n\t\t\t\t\ts -= d;\n\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tfor (auto it = st.begin(); it != st.end();) {\n\t\t\t\t\tif (get<2>(*it) == l)\n\t\t\t\t\t\tit = st.erase(it);\n\t\t\t\t\telse\n\t\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'R') {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tauto upper = st.upper_bound(T(p, 0, 0));\n\t\t\t\tif (upper != st.begin()) {\n\t\t\t\t\tupper--;\n\t\t\t\t\tint a, b, c;\n\t\t\t\t\ttie(a, b, c) = *upper;\n\t\t\t\t\tif (b <= p)\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << c << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdump(st);\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> File;\n\nvoid debug(const vector<File>& v){\n\tcout << \"[debug]\" << endl;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint id = v[i].first;\n\t\tint L = v[i].second.first;\n\t\tint R = v[i].second.second;\n\t\tcout << \"[\" << L << \" , \" << R << \"] : \" << id << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint n;\n\t\n\twhile( cin >> n , n ){\n\t\t// [0,10^9] が 空(-1)\n\t\tFile ini( -1 , P(0,1e+9) );\n\t\tvector<File> v;\n\t\tv.push_back( ini );\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tchar command;\n\t\t\tcin >> command;\n\t\t\t\n\t\t\tif( command == 'W' ){ // 書き込み\n\t\t\t\tint l, s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\t\n\t\t\t\t// ファイル番号が小さい方(-1)でさらにセクタの番号が小さい順にソート\n\t\t\t\tsort( v.begin() , v.end() );\n\t\t\t\t// 全部書き込みが終わるまで走査\n\t\t\t\tfor(vector<File>::iterator it = v.begin() ; it != v.end() ; ++it){\n\t\t\t\t\tif( s == 0 ) break;\n\t\t\t\t\t\n\t\t\t\t\tint id = it->first;\n\t\t\t\t\tint L = it->second.first;\n\t\t\t\t\tint R = it->second.second;\n\t\t\t\t\tint width = R - L + 1;\n\t\t\t\t\tif( id != -1 ) continue;\n\t\t\t\t\t\n\t\t\t\t\t// 書き込める十分なスペースがあるとき\n\t\t\t\t\tif( s <= width ){\n\t\t\t\t\t\tv.erase( it );\n\t\t\t\t\t\tint L1 = L;\n\t\t\t\t\t\tint R1 = L + s - 1;\n\t\t\t\t\t\tint id1 = l;\n\t\t\t\t\t\tFile f1( id1 , P(L1,R1) );\n\t\t\t\t\t\tv.push_back( f1 );\n\t\t\t\t\t\tif( s != width ){\n\t\t\t\t\t\t\tint L2 = L + s;\n\t\t\t\t\t\t\tint R2 = R;\n\t\t\t\t\t\t\tint id2 = -1;\n\t\t\t\t\t\t\tFile f2( id2 , P(L2,R2) );\n\t\t\t\t\t\t\tv.push_back( f2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t}else{ // スペースが足りないときは全部埋めて次へ\n\t\t\t\t\t\tit->first = l;\n\t\t\t\t\t\ts -= width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( command == 'D' ){ // 削除\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor(vector<File>::iterator it = v.begin() ; it != v.end() ; ++it){\n\t\t\t\t\tif( it->first == l ){\n\t\t\t\t\t\tit->first = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( command == 'R' ){ // 参照\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\t\t\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\t\t\tint id = v[i].first;\n\t\t\t\t\tint L = v[i].second.first;\n\t\t\t\t\tint R = v[i].second.second;\n\t\t\t\t\tif( L <= p && p <= R ){\n\t\t\t\t\t\tcout << id << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort( v.begin() , v.end() );\n\t\t\t//debug( v );\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<pair<int,int>,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint N;\ninline int len(P x){\n\treturn x.sec-x.fi+1;\n}\npriority_queue<P,vector<P>,greater<P> > ep;\nset<T> s;\nvector<P> vec[10010];\nint idnum;\nmap<int,int> id;\nint rev[10010];\nvoid debug(){\n\tvector<P> tmp;\n\twhile(!ep.empty()){\n\t\ttmp.pb(ep.top());\n\t\tep.pop();\n\t}\n\tfor(int i=0;i<tmp.size();i++){\n\t\tprintf(\"[%d %d]\\n\",tmp[i].fi,tmp[i].sec);\n\t\tep.push(tmp[i]);\n\t}\n\tset<T>::iterator it;\n\tfor(it=s.begin();it!=s.end();++it){\n\t\tprintf(\"%d %d %d\\n\",(it->fi).sec,(it->fi).fi,it->sec);\n\t}\n\treturn;\n}\nint solve(){\n\twhile(!ep.empty())ep.pop();\n\ts.clear();\n\tfor(int i=0;i<10010;i++)vec[i].clear();\n\tidnum=0;\n\tid.clear();\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tep.push(P(0,1000000100));\n\tfor(int i=0;i<N;i++){\n\t\tchar type;\n\t\tscanf(\" %c\",&type);\n\t\tif(type=='W'){\n\t\t\tint l,S;\n\t\t\tscanf(\"%d %d\",&l,&S);\n\t\t\tid[l]=idnum;\n\t\t\trev[idnum]=l;\n\t\t\tl = idnum++;\n\t\t\twhile(S>0){\n\t\t\t\tP nxt = ep.top();\n\t\t\t\tep.pop();\n\t\t\t\tif(len(nxt)>S){\n\t\t\t\t\tvec[l].pb(P(nxt.fi,nxt.fi+S-1));\n\t\t\t\t\ts.insert(T(P(nxt.fi+S-1,nxt.fi),rev[l])); // s?????????????????¢\n\t\t\t\t\tep.push(P(nxt.fi+S,nxt.sec));\n\t\t\t\t\tS=0;\n\t\t\t\t}else{\n\t\t\t\t\tvec[l].pb(nxt);\n\t\t\t\t\ts.insert(T(P(nxt.sec,nxt.fi),rev[l])); \n\t\t\t\t\tS -= len(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//debug();\n\t\t}else if(type=='D'){\n\t\t\tint l;\n\t\t\tscanf(\"%d\",&l);\n\t\t\tl = id[l];\n\t\t\tfor(int i=0;i<vec[l].size();i++){\n\t\t\t\tP tmp = vec[l][i];\n\t\t\t\tep.push(tmp);\n\t\t\t\ts.erase(T(P(tmp.sec,tmp.fi),rev[l]));\n\t\t\t}\n\t\t\t//debug();\n\t\t}else{\n\t\t\tint p;\n\t\t\tscanf(\"%d\",&p);\n\t\t\tset<T>::iterator it = s.lower_bound(T(P(p,-1),-1));\n\t\t\tint L=(it->fi).sec,R=(it->fi).fi,ID=it->sec;\n\t\t\tif(L<=p&&p<=R)printf(\"%d\\n\",ID);\n\t\t\telse printf(\"-1\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n        if(n == 0)break;\n        \n        set<P1> S1;\n        set<P1> S2;\n        S1.insert(mp1(0,-1,1000000001));\n        S2.insert(mp1(-1,0,1000000001));\n        \n        for(int i = 0 ; i < n ; i ++){\n            char c;\n            cin >> c;\n            //scanf(\"\\n%c\",&c);\n            if(c == 'W'){\n                int l,s;\n                scanf(\"%d%d\",&l,&s);\n                set<P1>::iterator itr = S2.lower_bound(mp1(-1,0,0));\n                while(1){\n                    if(itr->sc.sc > s){\n                        S1.insert(mp1(itr->sc.fr,l,s));\n                        S1.insert(mp1(itr->sc.fr+s,itr->fr,itr->sc.sc-s));\n                        S1.erase(mp1(itr->sc.fr,itr->fr,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,s));\n                        S2.insert(mp1(itr->fr,itr->sc.fr+s,itr->sc.sc-s));\n                        S2.erase(itr);\n                        break;\n                    }\n                    else {\n                        S1.insert(mp1(itr->sc.fr,l,itr->sc.sc));\n                        S1.erase(mp1(itr->sc.fr,-1,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,itr->sc.sc));\n                        S2.erase(itr++);\n                        s -= itr->sc.sc;\n                    }\n                    if(s == 0)break;\n                }\n            }\n            else if(c == 'D'){\n                int l;\n                scanf(\"%d\",&l);\n                set<P1>::iterator itr = S2.lower_bound(mp1(l,0,0));\n                while(1){\n                    S1.insert(mp1(itr->sc.fr,-1,itr->sc.sc));\n                    S1.erase(mp1(itr->sc.fr,l,itr->sc.sc));\n                    S2.insert(mp1(-1,itr->sc.fr,itr->sc.sc));\n                    S2.erase(itr++);\n                    if(itr->fr != l)break;\n                }\n            }\n            else {\n                int p;\n                scanf(\"%d\",&p);\n                set<P1>::iterator itr = S1.upper_bound(mp1(p,-1,0));\n                printf(\"%d%c\",(--itr)->sc.fr,10);\n            }\n        }\n        printf(\"%c\",10);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tlist<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((*v.begin()).p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min((*v.begin()).p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= (*v.begin()).p.second + 1;\n\t\t\t\t}\n\t\t\t\tfor (auto it = v.begin(); it != --v.end(); it++) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tauto d = (*it), c = (*++it);\n\t\t\t\t\tif (d.p.second + 1 < c.p.first) {\n\t\t\t\t\t\tit = v.insert(++it, { P(d.p.second + 1, min(c.p.second - 1, d.p.first + b - 1)),a });\n\t\t\t\t\t\tb -= c.p.second - d.p.first + 1;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P((*v.rbegin()).p.second + 1, b + (*v.rbegin()).p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tfor (auto it = v.begin(); it != v.end(); it++) {\n\t\t\t\t\tif ((*it).id == a) {\n\t\t\t\t\t\tit = v.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tauto it = v.begin();\n\t\t\t\tfor (; it != v.end() && (*it).p.second < a; it++);\n\t\t\t\tif (it == v.end())puts(\"-1\");\n\t\t\t\telse if ((*it).p.first <= a&&a <= (*it).p.second)printf(\"%d\\n\", (*it).id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(int i = 0, sum = 0; output == -1 && i < v.size();\n            sum += v[i++].size) {\n          if(sum <= P && P < sum+v[i].size) {\n            output = v[i].id;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define ALL(a) a.begin(),a.end()\n#define EACH(it,a) for(auto it=a.begin();it!=a.end();it++)\n\n\nint main() {\n\t\n\twhile(true){\n\t\tint n;cin >> n;if(n==0)break;\n\t\tvector<pair<int,int>> segs;//right,c\n\n\t\tsegs.push_back(make_pair(0,-1));segs.push_back(make_pair(1e9+50,-1));\n\t\tvector<int> ls;\n\t\tls.push_back(0);ls.push_back(1e9+50);\n\n\t\tREP(i,n){\n\t\t\tstring s;cin >> s;\n\t\t\tif(s==\"W\"){\n\t\t\t\tint l,s;cin >> l >> s;\n\t\t\t\t\n\t\t\t\tfor(int j=1;j<segs.size();j++)if(segs[j].second==-1){\n\t\t\t\t\tif(s<segs[j].first-segs[j-1].first){//set\n\t\t\t\t\t\tpair<int,int> p=make_pair(segs[j-1].first+s,l);\n\t\t\t\t\t\tsegs.push_back(p);\n\t\t\t\t\t\tls.push_back(p.first);\n\t\t\t\t\t\tsort(ALL(segs));sort(ALL(ls));break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ts-=segs[j].first-segs[j-1].first;\n\t\t\t\t\t\tsegs[j].second=l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s==\"D\"){\n\t\t\t\tint l;cin >> l;\n\t\t\t\tREP(j,segs.size())if(segs[j].second==l){\n\t\t\t\t\tsegs[j].second=-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint p;cin >> p;\n\t\t\t\t\n\t\t\t\tint vi=upper_bound(ALL(ls),p)-ls.begin();\n\t\t\t\tcout << segs[vi].second <<endl;\n\t\t\t}\n\t\t}\n\t\tcout <<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n; cin >> n&&n;) {\n\t\tset<T> st;\n\t\tst.emplace(-INF, 0, -1);\n\t\twhile (n--) {\n\t\t\tchar com; cin >> com;\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s; cin >> l >> s;\n\t\t\t\tfor (auto c = st.begin(); c != st.end(); c++) {\n\t\t\t\t\tint ca, cb, cc, na, nb, nc;\n\t\t\t\t\ttie(ca, cb, cc) = *c;\n\t\t\t\t\tif (next(c) == st.end()) {\n\t\t\t\t\t\tst.emplace(cb, cb + s, l);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttie(na, nb, nc) = *next(c);\n\t\t\t\t\tif (cb == na)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint d = min(s, na - ca);\n\t\t\t\t\tst.emplace(cb, cb + d, l);\n\t\t\t\t\ts -= d;\n\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tfor (auto it = st.begin(); it != st.end();) {\n\t\t\t\t\tif (get<2>(*it) == l)\n\t\t\t\t\t\tit = st.erase(it);\n\t\t\t\t\telse\n\t\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'R') {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tauto upper = st.upper_bound(T(p, 0, 0));\n\t\t\t\tif (upper != st.begin()) {\n\t\t\t\t\tupper--;\n\t\t\t\t\tint a, b, c;\n\t\t\t\t\ttie(a, b, c) = *upper;\n\t\t\t\t\tif (b <= p)\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << c << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\ntypedef pair<int,pair<int,int> > Sit;\n\nvoid solve(){\n\tint N;\n\twhile(cin>>N&&N){\n\t\tset<Sit> s;\n\t\ts.insert(make_pair(0,pii(1000000001,-1)));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tif(ch=='W'){\n\t\t\t\tint id,secSize;\n\t\t\t\tcin>>id>>secSize;\n\t\t\t\tvector<Sit> addList;\n\t\t\t\tvector<Sit> delList;\n\t\t\t\tfor(set<Sit>::iterator it=s.begin();it!=s.end();it++){\n\t\t\t\t\tif(it->second.second==-1){\n\t\t\t\t\t\tint curSize=it->second.first;\n\t\t\t\t\t\tif(curSize>=secSize){\n\t\t\t\t\t\t\tSit s1=make_pair(it->first,pii(secSize,id));\n\t\t\t\t\t\t\t// ツつ?づ慊づィツ閉板閉ェ\n\t\t\t\t\t\t\tSit s2=make_pair(it->first+secSize,pii(curSize-secSize,-1));\n\t\t\t\t\t\t\t// ツサツイツズツつェツ０ツづ按づァツ登ツ録ツつオツづ按つ「\n\t\t\t\t\t\t\tif(s2.second.first!=0){\n\t\t\t\t\t\t\t\taddList.push_back(s2);\n\t\t\t\t\t\t\t\t//s.insert(s2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddList.push_back(s1);\n\t\t\t\t\t\t\t\t//s.insert(s1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdelList.push_back(*it);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// ツ渉堕つォツ債楪づ敖終ツ猟ケ\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// ツ渉堕つォツ債楪づ淞づゥツつセツつッツ渉堕つォツ債楪づ?\n\t\t\t\t\t\t\tSit st=make_pair(it->first,pii(curSize,id));\n\t\t\t\t\t\t\tsecSize-=curSize;\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddList.push_back(st);\n\t\t\t\t\t\t\t\t//s.insert(st);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdelList.push_back(*it);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<addList.size();i++)\n\t\t\t\t\ts.insert(addList[i]);\n\t\t\t\tfor(int i=0;i<delList.size();i++)\n\t\t\t\t\ts.erase(delList[i]);\n\t\t\t}\n\t\t\telse if(ch=='R'){\n\t\t\t\tint secter;\n\t\t\t\tcin>>secter;\n\t\t\t\tset<Sit>::iterator it=--s.upper_bound(make_pair(secter,pii(1000000010,1000000010)));\n\t\t\t\tcout<<it->second.second<<endl;\n\t\t\t}\n\t\t\telse if(ch=='D'){\n\t\t\t\tint id;\n\t\t\t\tcin>>id;\n\t\t\t\tvector<Sit> addList;\n\t\t\t\tvector<Sit> delList;\n\t\t\t\tfor(set<Sit>::iterator it=s.begin();it!=s.end();it++){\n\t\t\t\t\tif(it->second.second==id){\n\t\t\t\t\t\tSit add=*it;\n\t\t\t\t\t\tadd.second.second=-1;\n\t\t\t\t\t\taddList.push_back(add);\n\t\t\t\t\t\tdelList.push_back(*it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<addList.size();i++)\n\t\t\t\t\ts.insert(addList[i]);\n\t\t\t\tfor(int i=0;i<delList.size();i++)\n\t\t\t\t\ts.erase(delList[i]);\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iomanip>\n#include<map>\n#include<stack>\n#include<queue>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\nstruct S {\n\tint id, lb, ub,nxt,prv;\n};\n\nS s[112345];\nstack<int> pool;\nconst int ED = -2;\nconst int BG = -3;\nvoid is(int i,int rest,int new_id) {\n\tif (rest <= 0)return;\n\tS& now = s[i];\n\tif (now.id != -1) {\n\t\tis(now.nxt, rest, new_id);\n\t\treturn;\n\t}\n\tint n = now.ub - now.lb;\n\tif (n <= rest) {\n\t\tnow.id = new_id;\n\t\tis(now.nxt, rest - n, new_id);\n\t}\n\telse {\n\t\tint p = pool.top(); pool.pop();\n\t\tS& x = s[p];\n\t\tS& y = now;\n\t\tx.prv = y.prv;\n\t\tx.nxt = i;\n\t\tx.id = new_id;\n\t\tx.lb = y.lb;\n\t\tx.ub = x.lb + rest;\n\t\ty.prv = p;\n\t\ts[x.prv].nxt = p;\n\t\ty.lb += rest;\n\t}\n}\nvoid dl(int i, int id) {\n\tS& now = s[i];\n\tif (now.id == ED)return;\n\tif (now.id == id)now.id = -1;\n\tdl(now.nxt, id);\n}\nint get(int i, int pos) {\n\tS& now = s[i];\n\tif (now.lb <= pos&&pos < now.ub)return now.id;\n\treturn get(now.nxt,pos);\n}\nvoid clear(int i) {\n\tS& now = s[i];\n\tif (now.id != ED)clear(now.nxt);\n\tpool.push(i);\n}\n\n\n\nint main() {\n\tREP(i, 112345) {\n\t\tpool.push(i);\n\t}\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint a,b,c;\n\t\ta = pool.top(); pool.pop();\n\t\tb = pool.top(); pool.pop();\n\t\tc = pool.top(); pool.pop();\n\t\ts[a].nxt = b;\n\t\ts[b].prv = a;\n\t\ts[b].nxt = c;\n\t\ts[c].prv = b;\n\t\ts[a].id = BG;\n\t\ts[b].id = -1;\n\t\ts[c].id = ED;\n\t\ts[b].lb = 0;\n\t\ts[b].ub = 1e9 + 10;\n\t\tREP(i, n) {\n\t\t\tstring x;\n\t\t\tcin >> x;\n\t\t\tif (x == \"W\") {\n\t\t\t\tint id, need;\n\t\t\t\tcin >> id >> need;\n\t\t\t\tis(s[a].nxt, need, id);\n\t\t\t}\n\t\t\tif (x == \"D\") {\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\tdl (s[a].nxt, id);\n\t\t\t}\n\t\t\tif (x == \"R\") {\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << get(s[a].nxt,pos) << endl;\n\t\t\t}\n\n\t\t}\n\t\tclear(a);\n\t\tcout << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint n;\nvector<PP> v;\n\nvoid solve(){\n\tv.clear();\n\trep(i,n){\n\t\tchar x; cin >> x;\n\t\tif(x == 'D'){\n\t\t\tint l; cin >> l;\n\t\t\trep(j,v.size()) if(v[j].second == l){\n\t\t\t\tv[j].first.first = INF;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\twhile(true){\n\t\t\t\tif(v.size() == 0) break;\n\t\t\t\tif(v[v.size()-1].first.first != INF) break;\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t} else if(x == 'R'){\n\t\t\tint p; cin >> p;\n\t\t\tbool ok = false;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first <= p && p <= v[j].first.second){\n\t\t\t\t\tcout << v[j].second << endl;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) puts(\"-1\");\n\t\t} else{\n\t\t\tint l, s; cin >> s >> l;\n\t\t\tint st = 0;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first > st){\n\t\t\t\t\tif(l <= v[j].first.first-st){\n\t\t\t\t\t\tv.push_back(PP(P(st,st+l-1),s));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tv.push_back(PP(P(st,v[j].first.first-1),s));\n\t\t\t\t\t\tl -= v[j].first.first-st;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tst = v[j].first.second+1;\n\t\t\t\tif(st > INF){\n\t\t\t\t\tl = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l > 0) v.push_back(PP(P(st,st+l-1),s));\n\t\t\tsort(v.begin(),v.end());\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nstruct I\n{\n    int l, r, id; // [l, r)\n    I(int l, int r, int id)\n        : l(l), r(r), id(id) {}\n    bool operator<(const I& a) const\n    {\n        return l < a.l;\n    }\n};\nint main()\n{\n    fast_io();\n\n    int n;\n    while (cin >> n, n)\n    {\n        static vector<I> cur, next;\n        cur.clear();\n        cur.pb(I(-100, 0, -1));\n        cur.pb(I(ten(9) + 100, -1, -1));\n        \n        while (n--)\n        {\n            char op;\n            cin >> op;\n            if (op == 'W')\n            {\n                int id, len;\n                cin >> id >> len;\n\n                next.clear();\n                rep(i, cur.size() - 1)\n                {\n                    next.pb(cur[i]);\n                    int space = cur[i + 1].l - cur[i].r;\n                    if (len > 0 && space > 0)\n                    {\n                        int size = min(len, space);\n                        len -= size;\n                        next.pb(I(cur[i].r, cur[i].r + size, id));\n                    }\n                }\n                next.pb(cur.back());\n\n                swap(cur, next);\n            }\n            else if (op == 'D')\n            {\n                int id;\n                cin >> id;\n\n                next.clear();\n                rep(i, cur.size())\n                    if (cur[i].id != id)\n                        next.pb(cur[i]);\n\n                swap(cur, next);\n            }\n            else if (op == 'R')\n            {\n                int pos;\n                cin >> pos;\n\n                int k = upper_bound(all(cur), I(pos, -1, -1)) - cur.begin() - 1;\n                int res = -1;\n                if (in_seg(pos, cur[k].l, cur[k].r - 1))\n                    res = cur[k].id;\n                cout << res << endl;\n            }\n            else\n                assert(false);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define INF 2e9\nvector<tuple<int, int ,int>> vec;\nvoid Write(int obj, int len){\n    for(int i = 0; i < vec.size(); i++){\n        tuple<int, int, int> t = vec[i];\n        if(get<2>(t) == INF){\n            if(get<1>(t) - get<0>(t) + 1 > len){\n                vec.insert(vec.begin() + i, make_tuple(get<0>(t), get<0>(t) + len - 1, obj));\n                vec[i + 1] = make_tuple(get<0>(t) + len, get<1>(t), INF);\n                break;\n            }\n            else{\n                vec[i] = make_tuple(get<0>(t), get<1>(t), obj);\n                len -= get<1>(t) - get<0>(t) + 1;\n            }\n        }\n    }\n}\nvoid Delete(int obj){\n     for(int i = 0; i < vec.size(); i++){\n        tuple<int, int, int> t = vec[i];\n        if(get<2>(t) == obj){\n            vec[i] = make_tuple(get<0>(t), get<1>(t), INF);\n        }\n     }\n}\nint Read(int index){\n     for(int i = 0; i < vec.size(); i++){\n        tuple<int, int, int> t = vec[i];\n        if(get<0>(t) <= index && get<1>(t) >= index){\n            return get<2>(t) != INF ? get<2>(t) : -1;\n        }\n     }\n}\nint main(){\n    int n;\n    char com;\n    int arg, arg2;\n    while(cin >> n && n){\n        vec.clear();\n        vec.push_back(make_tuple(0, INF, INF));\n        for(int i = 0; i < n; i++){\n            cin >> com;\n            if(com == 'W'){\n                cin >> arg >> arg2;\n                Write(arg, arg2);\n            }\n            else if(com == 'D'){\n                cin >> arg;\n                Delete(arg);\n            }\n            else{\n                cin >> arg;\n                cout << Read(arg) << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s - 1));\n                        endtoi[x.first + s - 1] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second - 1));\n                        endtoi[x.second - 1] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(make_pair(mp[i][j].first,mp[i][j].second+1));\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                if(it == endtoi.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <set>\nusing namespace std;\n\nconst int INF = INT_MAX;\nstruct Elem {\n    int l, r, val;\n    Elem(int a, int b, int x) : l(a), r(b), val(x) {}\n    bool operator<(const Elem &e) const {\n        return l < e.l;\n    }\n};\n\nint main() {\n    while(1) {\n        int N; scanf(\"%d\", &N);\n        if(!N) break;\n\n        set<Elem> S;\n        S.insert(Elem(INF, INF, -1));\n        while(N--) {\n            char c; scanf(\" %c\", &c);\n            if(c == 'W') {\n                int val, width; scanf(\" %d%d\", &val, &width);\n                int prev = 0;\n                for(auto it=S.begin(); it!=S.end(); it++) {\n                    Elem e = *it;\n                    int diff = e.l - prev;\n                    if(diff == 0) {\n                        prev = e.r;\n                    }\n                    else {\n                        int nwid = min(diff, width);\n                        int nl = prev, nr = prev + nwid;\n                        S.insert(Elem(nl, nr, val));\n                        width -= nwid;\n                        if(width == 0) break;\n                        prev = e.r;\n                    }\n                }\n            }\n            if(c == 'D') {\n                int id; scanf(\" %d\", &id);\n                for(auto it=S.begin(); it!=S.end(); it++) {\n                    Elem e = *it;\n                    if(e.val == id) S.erase(it);\n                }\n            }\n            if(c == 'R') {\n                int idx; scanf(\" %d\", &idx);\n                bool found_val = false;\n                for(auto it=S.begin(); it!=S.end(); it++) {\n                    Elem e = *it;\n                    if(e.l <= idx && idx < e.r) {\n                        printf(\"%d\\n\", e.val);\n                        found_val = true;\n                    }\n                }\n                if(!found_val) printf(\"-1\\n\");\n            }\n\n            /*\n            printf(\"operate end\\n\");\n            for(auto it=S.begin(); it!=S.end(); it++) {\n                Elem e = *it;\n                printf(\"l = %d, r = %d, val = %d\\n\", e.l, e.r, e.val);\n            }\n            */\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nconst int INF = 1000000010;\n\nstruct Segment{\n    int pos, size, id;\n    Segment(int pos, int size, int id): pos(pos), size(size), id(id) {}\n    bool operator<(const Segment& right ) const {\n        return pos == right.pos ? size < right.size : pos < right.pos;\n    }\n};\n\nint main(){\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n\n        set<Segment> empty;\n        empty.emplace(0, INF, -1);\n        set<Segment> occupied;\n        \n        for(int i=0;i<N;i++){\n            char cmd;\n            cin >> cmd;\n            if(cmd == 'W'){\n                int id, size;\n                cin >> id >> size;\n                while(true){\n                    Segment u = *empty.begin();\n                    empty.erase(empty.begin());\n                    if(u.size < size){\n                        size -= u.size;\n                        u.id = id;\n                        occupied.insert(u);\n                    }else{\n                        empty.emplace(u.pos + size, u.size - size, -1);                    \n                        occupied.emplace(u.pos, size, id);\n                        break;\n                    }\n                }\n            }else if(cmd == 'D'){\n                int id;\n                cin >> id;\n                for(auto it=occupied.begin();it!=occupied.end();){\n                    if(it->id == id){\n                        empty.insert(*it);\n                        occupied.erase(it++);\n                    }else{\n                        it++;\n                    }\n                }\n            }else{\n                int pos;\n                cin >> pos;\n                auto it = occupied.lower_bound(Segment(pos, INF, INF));\n                bool found = false;\n                if(it != occupied.begin()){\n                    auto prev = next(it, -1);\n                    if(prev->pos <= pos && pos < prev->pos + prev->size){\n                        cout << prev->id << endl;\n                        found = true;\n                    }\n                }\n                if(!found){\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(list<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.push_front({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.push_back({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.push_front({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert(it,{prev->l,t,id});\n            \n            cnt-=t;\n        }\n        if(cnt<=0) break;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.push_back({it->r,it->r+cnt,id});\n    \n}\nvoid solve() {\n    list<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n            //for(auto &e : range) {\n            //    cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n            //}\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(set<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.insert({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.insert({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.insert({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert({prev->l,t,id});\n            \n            cnt-=t;\n        }\n        if(cnt==0) break;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.insert({it->r,it->r+cnt,id});\n    \n}\nvoid solve() {\n    set<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n            //for(auto &e : range) {\n            //    cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n            //}\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t2152: Restrictive Filesystem\n*/\n#include\t<iostream>\n#include\t<vector>\n#include\t<utility>\n#include\t<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P_ii;\n\nclass datlst {\nprivate:\n\tvector<P_ii> lst;\n\tint\t\tendOfSect = -1;\npublic:\n\tvoid push_file(int, int);\n\tvoid erase_file(int);\n\tvoid clear_list(void);\n\tint show_file(int);\n};\n\nvoid datlst::push_file(int ident, int count) {\n\tint\t\tctSector;\n\tbool\tflagHit;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (lst.empty()) {\n\t\t\tlst.push_back(P_ii(0, ident));\n\t\t\tendOfSect++;\n\t\t} else {\n\t\t\tvector<P_ii>::iterator it = lst.begin();\n\t\t\tctSector = 0;\n\t\t\tflagHit = true;\n\t\t\twhile (it != lst.end()) {\n\t\t\t\tif (it->second == -1) {\n\t\t\t\t\tit->first = ctSector;\n\t\t\t\t\tit->second = ident;\n\t\t\t\t\tflagHit = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctSector++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tif (flagHit) {\n\t\t\t\tlst.push_back(P_ii(++ctSector, ident));\n\t\t\t\tendOfSect++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid datlst::erase_file(int ident) {\n\tvector<P_ii>::iterator it = lst.begin();\n\twhile (it != lst.end()) {\n\t\tif (it->second == ident) {\n\t\t\tit->second = -1;\n\t\t}\n\t\tit++;\n\t}\n}\n\nvoid datlst::clear_list(void) {\n\tlst.clear();\n\tendOfSect = -1;\n}\n\nint datlst::show_file(int sector) {\n\tif (sector >= endOfSect) { return -1; }\n\treturn lst[sector].second;\n\t/*\n\tvector<P_ii>::iterator it = lst.begin();\n\twhile (it != lst.end()) {\n\t\tif (it->first == sector) {\n\t\t\treturn it->second;\n\t\t\tbreak;\n\t\t}\n\t\tit++;\n\t}\n\t*/\n\treturn -1;\n}\n\nint main(void) {\n\tint\t\tN, f, s;\n\tchar\tc;\n\tdatlst DataList;\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> c;\n\t\t\tswitch (c) {\n\t\t\tcase 'W':\n\t\t\t\tcin >> f >> s;\n\t\t\t\tDataList.push_file(f, s);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> f;\n\t\t\t\tDataList.erase_file(f);\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> f;\n\t\t\t\tcout << DataList.show_file(f) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tDataList.clear_list();\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct data{\n  int l,r,id;\n};\n\nvector< data > t;\nint n;\n\nvoid funcW(int,int);\nvoid funcD(int);\nint funcR(int);\n\nint main(){\n  char ch;\n  int a,b;\n  while(cin>>n&&n){\n    t.clear();\n    t.push_back( (data){-1,-1,-1} );\n    t.push_back( (data){1e9+1,1e9+1,-1});\n    for(int i=0;i<n;i++){\n\n      cin>>ch;\n      if(ch=='W'){\n\tcin>>a>>b;\n\tfuncW(a,b);\n      }else if(ch=='D'){\n\tcin>>a;\n\tfuncD(a);\n      }else{\n\tcin>>a;\n\tcout<<funcR(a)<<endl;\n      }\n    }\n\n    cout<<endl;\n  }\n  return 0;\n}\n\nvoid funcW(int id,int size){\n  for(int i=1;i<(int)t.size();i++){\n    int d=min(t[i].l-t[i-1].r-1 ,size);\n    if(d==0)continue;\n    size-=d;\n    t.insert(t.begin()+i ,(data){t[i-1].r+1,t[i-1].r+d,id});\n    if(size==0)break;\n  }\n}\n\nvoid funcD(int id){\n\n  for(int i=t.size()-1;i>=0;i--){\n    if(t[i].id!=id)continue;\n    t.erase(t.begin()+i);\n  }\n}\n\nint funcR(int pos){\n  for(int i=0;i<(int)t.size();i++){\n    if(t[i].l<=pos&&pos<=t[i].r)return t[i].id;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tfor(int i=0;i<=10000;i++)place[i].clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000010;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nifstream ifs(\"2152_input.txt\");\nofstream ofs(\"op.txt\");\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w; bool accessed = false;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            accessed = true;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            auto it = disk.begin();\n            while(it != disk.end()){\n                if(it->second == t) disk.erase(it++);\n                else it++;\n            }\n        }else{\n            auto lb = disk.upper_bound(pint(t, INF));\n            if(lb != disk.begin()) lb--;\n            pint temp = lb->first;\n            if(temp.first <= t && t < temp.second && accessed)\n              cout << lb->second << endl;\n            else\n              cout << \"-1\" << endl;\n        }\n        \n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Section {\n    int contents;\n    ll start,end;\n    Section(int s,int e,int c) : start(s), end(e), contents(c) {;}\n\n    ll size() { return end - start + 1; }\n};\n\nclass Disk {\nprivate:\n    int _size;\n    vector<Section> sv;\n\npublic:\n    Disk () {\n        sv.clear();\n        sv.push_back(Section(0,1000000000ll,-1));\n    }\n\n    typedef vector<Section>::iterator itr;\n\n    int getSize() { return _size; }\n\n    void write(ll file_id,ll size) {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            if(it->contents == -1) {\n                it->contents = file_id;\n                if(it->size() > size) {\n                    ll e = it->end;\n                    it->end = it->start + size -1;\n                    ll nexts = (it->end)+1;\n                    it++;\n                    sv.insert(it, 1, Section( nexts, e, -1));\n                    break;\n                }else{\n                    size -= it->size();\n                }\n            }\n        }\n    }\n\n    void dump() {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            cout<<\"from \"<<it->start<<\" to \"<<it->end<<\" : file_id \"<<it->contents<<endl;\n        }\n    }\n\n    void delete_file(ll file_id) {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            if(it->contents == file_id) {\n                it->contents = -1;\n            }\n        }\n        return;\n    }\n\n    int reference(ll ptr) {\n        for(itr it = sv.begin(); it != sv.end(); ++it) {\n            if(it->start <= ptr && it->end >= ptr) return it->contents;\n        }\n        return -1;\n    }\n};\n\nint main() {\n    int N;\n    ll rs,rt;\n    string op;\n    while(cin>>N, N) {\n        Disk disk;\n        for(int i=0; i<N; ++i) {\n            cin>>op;\n            if(op == \"W\") {\n                cin>>rs>>rt;\n                disk.write(rs,rt);\n            }else if(op == \"D\") {\n                cin>>rs;\n                disk.delete_file(rs);\n            }else{\n                cin>>rs;\n                cout<<disk.reference(rs)<<endl;\n            }\n        }\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          // cout << idx << \" \" << cnt << endl;\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].second == -1) {\n            if(idx + cnt - 1 <= dp[idx].first) {\n              dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx].second = l;\n              dp[idx].first = idx+cnt-1;\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].first - idx + 1;\n              idx = dp[idx].first + 1;\n            }\n          } else {\n            idx = dp[idx].first + 1;\n          }\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          } else {\n            idx = dp[idx].first + 1;\n          }\n        }\n      }\n      // for(auto& j: dp) cout << j.first << \" \" << j.second << \" \"; cout << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//25min\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    vector<int> M;\n    int max;\n    for(int j=0;j<N;j++){\n      char command;\n      int i,s,p;\n      cin >> command;\n      switch(command){\n      case 'W':\n\tcin >> i >> s;\n\tint index=0;\n\twhile(s>0){\n\t  if(index>=M.size()){\n\t    M[index]=i;\n\t    s--;\n\t  }else if(M[index]==-1){\n\t    M[index]=i;\n\t    s--;\n\t  }\n\t  index++;\n\t}\n\tbreak;\n      case 'D':\n\tcin >> i;\n\tfor(int k=0;k<M.size();k++){\n\t  if(M[k]==i) M[k]=(-1);\n\t}\n\tbreak;\n      case 'R':\n\tcin >> p;\n\tif(p<M.size()) cout << M[p] << endl;\n\telse cout << \"-1\" << endl;\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(c,c+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[{c,c+k-1}]=n;\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<int, int> SEG;\ntypedef pair<SEG, int> S;\nint main(){\n  int N;\n  while(cin>>N && N){\n    vector<S> data;\n    data.push_back(S(SEG(-1, 0), -1));\n    REP(time, N){\n      string cmd; cin>>cmd;\n      if(cmd == \"W\"){\n        int l, s; cin>>l>>s;\n        vector<S> add;\n        REP(i, data.size()-1){\n          if(s == 0) break;\n          if(data[i].first.second < data[i+1].first.first){\n            int fst = data[i].first.second;\n            int len = min(s, data[i+1].first.first - fst);\n            add.push_back(S(SEG(fst, fst + len), l));\n            s -= len;\n          }\n        }\n        if(s > 0){\n          int fst = data.back().first.second;\n          int len = s;\n          add.push_back(S(SEG(fst, fst + len), l));\n        }\n        REP(i, add.size()) data.push_back(add[i]);\n        sort(data.begin(), data.end());\n      }else if(cmd == \"D\"){\n        int l; cin>>l;\n        vector<S>::iterator it = data.begin();\n        while(it != data.end()){\n          if(it->second == l){\n            it = data.erase(it);\n          }else{\n            it++;\n          }\n        }\n      }else if(cmd == \"R\"){\n        int P; cin>>P;\n        int res = -1;\n        REP(i, data.size())if(data[i].first.first <= P && P < data[i].first.second){\n          res = data[i].second;\n          break;\n        }\n        cout<< res << endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\nint main() {\n\twhile (1) {\n\t\tvector<pair<int, int>>ps;\n\t\tps.emplace_back(-1, 1000000007);\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'W') {\n\t\t\t\tint a, b; cin >> a >> b;\n\t\t\t\tint rest = b;\n\t\t\t\tfor (auto pt = ps.begin(); pt != ps.end(); ++pt) {\n\t\t\t\t\tif (pt->first == -1) {\n\t\t\t\t\t\tif (pt->second> rest) {\n\t\t\t\t\t\t\tpt->second -= rest;\n\t\t\t\t\t\t\tps.insert(pt, make_pair(a, rest));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (pt->second == rest) {\n\t\t\t\t\t\t\tpt->first = a;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tpt->first = a;\n\t\t\t\t\t\t\trest -= pt->second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (c == 'D') {\n\t\t\t\tint b; cin >> b;\n\t\t\t\tfor (auto pt = ps.begin(); pt != ps.end(); ++pt) {\n\t\t\t\t\tif (pt->first == b) {\n\t\t\t\t\t\tpt->first = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c=='R') {\n\t\t\t\tint b; cin >> b;\n\t\t\t\tint rest = b;\n\t\t\t\tfor (auto&& pt = ps.cbegin(); pt != ps.cend(); ++pt) {\n\t\t\t\t\tif (pt->second > rest) {\n\t\t\t\t\t\tcout << pt->first << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\trest -= pt->second;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  scanf(\"%d\" ,&l);\n\n  if(len == 0){\n    return -1;\n  }\n  \n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n; vector<tuple<int, int, int>>vec;\nvector<int>res;\nvoid Write(int a, int b) {\n\tint L = -1;\n\tint R = vec.size();\n\tfor (int i = L; i < R; i++) {\n\t\tif (b == 0)continue;\n\t\tint SL = 0; if (i >= 0)SL = get<1>(vec[i]) + 1;\n\t\tint SR = 1999999999; if (i < R - 1)SR = get<0>(vec[i + 1]) - 1;\n\t\tint SZ = SR - SL + 1;\n\t\tif (SZ >= 1) {\n\t\t\tif (b < SZ) { vec.push_back(make_tuple(SL, SL + b - 1, a)); b = 0; }\n\t\t\telse { vec.push_back(make_tuple(SL, SR, a)); b -= SZ; }\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\treturn;\n}\nvoid Delete(int a) {\n\tvector<tuple<int, int, int>>vec2;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<2>(vec[i]) != a)vec2.push_back(vec[i]);\n\t}\n\tvec = vec2;\n\treturn;\n}\nint Read(int a) {\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<0>(vec[i]) <= a && a <= get<1>(vec[i])) {\n\t\t\treturn get<2>(vec[i]);\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; vec.clear(); res.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'W') { int l, s; cin >> l >> s; Write(l, s); }\n\t\t\tif (p == 'D') { int l; cin >> l; Delete(l); }\n\t\t\tif (p == 'R') { int l; cin >> l; res.push_back(Read(l)); }\n\t\t}\n\t\tfor (int i = 0; i < res.size(); i++)cout << res[i] << endl;\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tint back = 0;\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(len && !del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tif(len){\n\t\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\t\tback += len;\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second > id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg.erase(seg.begin()+t, seg.end());\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tlist<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ((*v.begin()).p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min((*v.begin()).p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= (*v.begin()).p.second + 1;\n\t\t\t\t}\n\t\t\t\tfor (auto it = v.begin(); it != --v.end(); it++) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tauto d = (*it), c = (*++it); it--;\n\t\t\t\t\tif (d.p.second + 1 < c.p.first) {\n\t\t\t\t\t\tit = v.insert(++it, { P(d.p.second + 1, min(c.p.second - 1, d.p.first + b - 1)),a });\n\t\t\t\t\t\tb -= c.p.second - d.p.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P((*v.rbegin()).p.second + 1, b + (*v.rbegin()).p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tfor (auto it = v.begin(); it != v.end(); it++) {\n\t\t\t\t\tif ((*it).id == a) {\n\t\t\t\t\t\tit = v.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tauto it = v.begin();\n\t\t\t\tfor (; it != v.end() && (*it).p.second < a; it++);\n\t\t\t\tif (it == v.end())puts(\"-1\");\n\t\t\t\telse if ((*it).p.first <= a&&a <= (*it).p.second)printf(\"%d\\n\", (*it).id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct List{\n\tint id, cnt;\n\tList *nxt;\n};\n\nvoid _delete(List *p){\n\tif (p == nullptr) return;\n\t_delete(p->nxt);\n\tdelete p;\n}\n\nvoid erase(List *p, int id){\n\tif (p == nullptr) return;\n\tif (p->id == id) p->id = -1;\n\terase(p->nxt, id);\n}\n\nint find(List *p, int pos){\n\tif (p == nullptr) return -1;\n\tif (p->cnt > pos) return p->id;\n\treturn find(p->nxt, pos - p->cnt);\n}\n\nList* add(List *p, int id, int cnt){\n\tif (!cnt) return p;\n\tif (p == nullptr)return new List{id, cnt, nullptr};\n\tif (p->id < 0){\n\t\tp->id = id;\n\t\tif (p->cnt > cnt){\n\t\t\tList *nl = new List{ -1, p->cnt - cnt, p->nxt };\n\t\t\tp->cnt = cnt;\n\t\t\tp->nxt = nl;\n\t\t\treturn p;\n\t\t}\n\t\tcnt -= p->cnt;\n\t}\n\tp->nxt = add(p->nxt, id, cnt);\n\treturn p;\n}\n\nint main(){\n\tList *head = new List();\n\tint n;\n\twhile (cin >> n, n){\n\t\twhile (n--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint id, cnt;\n\t\t\t\tcin >> id >> cnt;\n\t\t\t\thead->nxt = add(head->nxt, id, cnt);\n\t\t\t}\n\t\t\telse if (c == 'D'){\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\terase(head->nxt, id);\n\t\t\t}\n\t\t\telse if (c == 'R'){\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << find(head->nxt, pos) << '\\n';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t\t_delete(head->nxt);\n\t\thead->nxt = nullptr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Data\n{\n  int id, st, num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n\nint N;\nvector<Data> storage;\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st; break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      num = remain;\n    }\n    storage.push_back(Data(id, st, num));\n    remain -= num;\n  }\n}\n\n//struct EqualsID {int id;EqualsID(int id) : id(id) {}bool operator() (const Data &d) { return d.id == id; }};\nvoid del(int id) {\n  //storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n  for(int i=0; i<storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n    }\n  }\n}\n\nint refer(int sect) {\n  for(int i=0; i<storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n        /*\n        for(int i=0; i<storage.size(); i++) {\n          cout << \"storage[\"<<i<<\"]:\" << endl;\n          cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n        }\n        */\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct sector{\n\tint begin,end,label;\n\tsector(int begin,int end,int label):begin(begin),end(end),label(label){}\n};\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tlist<sector> sectors;\n\t\tREP(i,n){\n\t\t\tchar command;\n\t\t\tcin>>command;\n\t\t\tint l,s;\n\t\t\tswitch(command){\n\t\t\tcase 'W':\n\t\t\t\t{\n\t\t\t\t\tcin>>l>>s;\n\t\t\t\t\tint left=0;\n\t\t\t\t\tint total=0;\n\t\t\t\t\tif(sectors.size()==0){\n\t\t\t\t\t\tsectors.push_back(sector(0,s-1,l));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\t\tif(left<it->begin){\n\t\t\t\t\t\t\t\tif(total+it->begin-left>=s){\n\t\t\t\t\t\t\t\t\tit=sectors.insert(it,sector(left,s-total+left-1,l));\n\t\t\t\t\t\t\t\t\ttotal+=s-total+left;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tint right=it->begin-1;\n\t\t\t\t\t\t\t\t\tit=sectors.insert(it,sector(left,right,l));\n\t\t\t\t\t\t\t\t\ttotal+=right-left+1;\n\t\t\t\t\t\t\t\t\tleft=it->end+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(it->end>=left){\n\t\t\t\t\t\t\t\t\tleft=it->end+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(total<s){\n\t\t\t\t\t\t\tsectors.push_back(sector(left,left+s-total-1,l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t{\n\t\t\t\t\tcin>>l;\n\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();){\n\t\t\t\t\t\tif(it->label==l){\n\t\t\t\t\t\t\tit=sectors.erase(it);\n\t\t\t\t\t\t\tif(it==sectors.end())break;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tit++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t{\n\t\t\t\t\tcin>>l;\n\t\t\t\t\tint label=-1;\n\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\tif(it->begin<=l&&l<=it->end){\n\t\t\t\t\t\t\tlabel=it->label;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcout<<label<<endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;scanf(\"%d\",&T),T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--&&scanf(\"%s%d\",C,&n);){\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else ++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n?-1:it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll n;\n\n    while (cin >> n, n) {\n\n        vector<tuple<ll, ll, ll>> files; // (l, r, i) means [l, r) is a part of the file i\n        \n        REP(i, n) {\n\n            char cmd; cin >> cmd;\n\n            if (cmd == 'R') {\n\n                ll p; cin >> p;\n                bool found = false;\n                for (auto &f : files) {\n                    if (get<0>(f) <= p && p < get<1>(f)) {\n                        cout << get<2>(f) << endl;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) cout << \"-1\" << endl;\n\n            } else if (cmd == 'D') {\n\n                ll i; cin >> i;\n                files.erase(remove_if(ALL_OF(files), [&i](auto f) -> bool { return get<2>(f) == i; }), files.end());\n\n            } else if (cmd == 'W') {\n\n                ll i, s; cin >> i >> s;\n\n                if (!files.empty()) {\n                    if (get<0>(files.front()) > 0) {\n                        ll gap = min(get<0>(files.front()), s);\n                        s -= gap;\n                        files.insert(files.begin(), make_tuple(0LL, gap, i));\n                    }\n                    if (s >= 0) REP(j, files.size() - 1) {\n                        ll gap = get<0>(files[j+1]) - get<1>(files[j]);\n                        if (gap > 0) {\n                            chmin(gap, s);\n                            s -= gap;\n                            ll bk = get<1>(files[j]);\n                            files.emplace_back(bk, bk + gap, i);\n                            if (s <= 0) break;\n                        }\n                    }\n                }\n\n                if (s > 0) {\n                    ll bk = files.empty() ? 0 : get<1>(files.back());\n                    files.emplace_back(bk, bk + s, i);\n                }\n\n                sort(ALL_OF(files));\n\n            }\n\n        }\n\n        cout << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nstruct list{\n\tint data;\n\tstruct list *next;\n};\n\nlist* make_list(int a, list *l) {\n\tlist *z = (list*)malloc(sizeof(list));\n\tz->data = a;\n\tz->next = l;\n\treturn z;\n}\n\nlist* insert_list(int a, list *l) {\n\tlist** x = &l;\n\tbool hantei = true;\n\twhile ((*x)->next != NULL) {\n\t\tif ((*x)->data == -1) {\n\t\t\t(*x)->data = a;\n\t\t\thantei = false;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tx = &((*x)->next);\n\t\t}\n\t}\n\tif (hantei) {\n\t\t(*x)->next = make_list(a, NULL);\n\t}\n\treturn l;\n}\n\nlist* delete_list(int a, list *l) {\n\tlist** x = &l;\n\twhile ((*x)->next != NULL) {\n\t\tif ((*x)->data == a) {\n\t\t\t(*x)->data = -1;\n\t\t}\n\t\tx = &((*x)->next);\n\t}\n\treturn l;\n}\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tchar c;\n\t\tlist *z = NULL;\n\t\tint a, b;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c;\n\t\t\tint d = 0;\n\t\t\tif(c == 'W') {\n\t\t\t\tcin >> a >> b;\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\tif (z == NULL) {\n\t\t\t\t\t\tz = make_list(a, NULL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz = insert_list(a, z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c == 'D') {\n\t\t\t\tcin >> a;\n\t\t\t\tz = delete_list(a, z);\n\t\t\t} else {\n\t\t\t\tcin >> a;\n\t\t\t\tlist** x = &z;\n\t\t\t\tbool hantei = true;\n\t\t\t\tfor (int j = 0; j < a; j++) {\n\t\t\t\t\tif ((*x) == NULL || (*x)->next == NULL) {\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\thantei = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = &((*x)->next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hantei) {\n\t\t\t\t\tcout << (*x)->data << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef int ll;\ntypedef pair<int,int>P;\n#define MX 1000000001\nint N,d1[10005],d2[10005],cnt;\nchar c[10005];\n \nstruct BIT\n{\n\tvector<ll>T;\n\tint n;\n\tBIT( int n):n(n+1),T(n+1,0){}\n\tll _sum( int p){ll res=0;for (;p>0;p-=p&-p)res+=T[p];return res;}\n\tll sum( int r,int l){return _sum(l)-_sum(r);};\n\tvoid add(int i,int x){ for(;i<n;i+=i&-i)T[i]+=x;}\n};\n\n\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tmap<int,int>T;\n\t\tT[-10000]=-1;\n\t\tmap<int,vector<int> >D;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%c\",&c[i]);\n\t\t\tif(c[i]=='W')scanf(\"%d%d\\n\",&d1[i],&d2[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1[i]);\n\t\t\t\tif(c[i]=='R')\n\t\t\t\t\tT[d1[i]]=-1;\n\t\t\t}\n\t\t}\n\n\t\tBIT SEQ(T.size());\n \n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(c[i]=='R')\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",T[d1[i]]);\n\t\t\t}\n\t\t\telse if(c[i]=='D')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<D[d1[i]].size();j++)\n\t\t\t\t\tSEQ.add(j,-D[d1[i]][j]);\n\t\t\t\tfor(map<int,int>::iterator it=T.begin();it!=T.end();it++)\n\t\t\t\t\tif(it->second==d1[i])\n\t\t\t\t\t\tit->second=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[d1[i]].push_back(0);\n\t\t\t\tint j=1,s=d2[i];\n\t\t\t\tfor(map<int,int>::iterator it=T.begin();it!=T.end();it++,j++)\n\t\t\t\t{\n\t\t\t\t\tint ins=0,emp=it->first-SEQ._sum(j)+1;\n\t\t\t\t\tif(emp>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s>=emp)it->second=d1[i];\n\t\t\t\t\t\tins=min(s,emp);\n\t\t\t\t\t\ts-=min(s,emp);\n\t\t\t\t\t}\n\t\t\t\t\tSEQ.add(j,ins);\n\t\t\t\t\tD[d1[i]].push_back(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cassert>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i, n)     reps(i, 0, n)\n#define reps(i, f, n) for (int i = (f); i < (int)(n); ++i)\n\nstruct Data {\n    int id;\n    int len;\n    Data(int id, int len) : id(id), len(len) {}\n    Data(){}\n};\n\nvector<Data> hdd;\nvector<int> deleted;\n\nvoid W(int id, int s)\n{\n    rep(i, hdd.size()){\n        if(deleted[hdd[i].id]){\n            if(hdd[i].len <= s){\n                s -= hdd[i].len;\n                hdd[i].id = id;\n            }\n            else{\n                int remain = hdd[i].len - s;\n                hdd[i].id = id;\n                hdd[i].len = s;\n                hdd.insert(hdd.begin()+i+1, Data(0, remain));\n                s = 0;\n            }\n        }\n        if(s == 0)\n            return;\n    }\n    //assert(1==0);\n}\n\nvoid D(int id)\n{\n    deleted[id] = 1;\n}\n\nint R(int p)\n{\n    int pos = 0;\n    rep(i, hdd.size()){\n        if(pos<=p && p<pos+hdd[i].len){\n            return hdd[i].id;\n        }\n        pos += hdd[i].len;\n    }\n    //assert(0);\n}\n\nvoid dump()\n{\n    puts(\"===\");\n    rep(i, hdd.size()){\n        printf(\"%d, len=%d\\n\", hdd[i].id, hdd[i].len);\n    }\n    puts(\"\");\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\", &n), n){\n        // initialize\n        hdd.assign(1, Data(0, 1000000010));\n        deleted.assign(n+1, 0);\n        deleted[0] = 1;\n        map<int, int> dict;\n        vector<int> inv(n+1, -1);\n        \n        rep(i, n){\n            char cmd[10];\n            scanf(\"%s\", cmd);\n            if(cmd[0] == 'W'){\n                int id, s;\n                scanf(\"%d%d\", &id, &s);\n                \n                int tmp = dict.size() + 1;\n                dict[id] = tmp;\n                inv[tmp] = id;\n                W(tmp, s);\n            }\n            else{\n                int id;\n                scanf(\"%d\", &id);\n                if(cmd[0] == 'D')\n                    D(dict[id]);\n                else{\n                    int ret = R(id);\n                    if(deleted[ret])\n                        puts(\"-1\");\n                    else\n                        printf(\"%d\\n\", inv[ret]);\n                }\n            }\n        }\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<P>::iterator ITE;\nstruct data{\n  int num;\n  vector<P> MEM;\n  data(){}\n  data(int n,vector<P> m):num(n),MEM(m){}\n  bool operator < (const data& d) const {return num < d.num;}\n};\n\nconst int MAX = 1000000001;\nvector<P> Free;\nvector<data> V;\n\nvoid init(){\n\n  Free.clear();\n  Free.push_back(P(0,MAX));\n\n}\n\nvoid write(int a, int b){\n  sort(Free.begin(),Free.end());\n  vector<P> tmp;\n\n  for(int i = 0; i < (int)Free.size(); i++){\n    if(Free[i].second-Free[i].first+1 > b){\n      tmp.push_back(P(Free[i].first, Free[i].first+b-1));\n      //     cout << \"push \" << Free[i].first << \" \" << Free[i].first+b-1 << \" \" << a << endl;\n      Free[i].first += b;\n      break;\n    }else{\n      tmp.push_back(Free[i]);\n      b -= Free[i].second-Free[i].first+1;\n      //  cout << \"push \" << Free[i].first << \" \" << Free[i].second << \" \" << a << endl;\n      vector<P>::iterator ite = (ITE)&Free[i];\n      Free.erase(ite);\n      i--;\n    }\n  }\n  V.push_back(data(a,tmp));\n}\n\nvoid del(int num){\n\n  sort(V.begin(),V.end());\n  vector<data>::iterator ite = lower_bound(V.begin(),V.end(),data(num,vector<P>()));\n  if(ite->num != num) assert(false);\n\n  for(int i = 0; i < (int)ite->MEM.size(); i++)\n    Free.push_back(ite->MEM[i]);\n\n  V.erase(ite);\n\n}\n\nvoid ref(int num){\n  for(int i = 0; i < (int)V.size(); i++){\n    vector<P> tmp = V[i].MEM;\n    for(int j = 0; j < (int)tmp.size(); j++){\n      if(tmp[j].first <= num && num <= tmp[j].second){\n\tcout << V[i].num << endl;\n\treturn;\n      }\n    }\n  }\n  \n  cout << \"-1\" << endl;\n}\n\nint main(){\n  int n;\n  bool f = false;\n\n  while(cin >> n && n){\n    if(f) cout << endl;\n    f = true;\n    init();\n    while(n--){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n\tint a,b;\n\tcin >> a >> b;\n\twrite(a,b);\n      }\n\n      if(c == 'D'){\n\tint a;\n\tcin >> a;\n\tdel(a);\n      }\n\n      if(c == 'R'){\n\tint a;\n\tcin >> a;\n\tref(a);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\ntypedef tuple<int,int,int> triple;\nset<triple> intervals;\n\nvoid write(){\n    int id,len;\n    cin >> id >> len;\n    auto a=intervals.begin();\n    auto b=intervals.begin();\n    ++b;\n    while(len>0){\n        int l=get<1>(*a);\n        if(b==intervals.end()){\n            intervals.insert(triple(l,l+len,id));\n            break;\n        }\n        int r=get<0>(*b);\n        if(l==r){\n            a=b;\n            ++b;\n            continue;\n        }\n        if(r-l>len) r=l+len;\n        b=intervals.insert(triple(l,r,id)).first;\n        a=b;\n        ++b;\n        len-=r-l;\n    }\n}\n\nvoid del(){\n    int id;\n    cin >> id;\n    for(auto it=intervals.begin();it!=intervals.end();){\n        if(get<2>(*it)==id) it=intervals.erase(it);\n        else ++it;\n    }\n}\n\nvoid read(){\n    int addr;\n    cin >> addr;\n    bool ok=false;\n    for(const auto& interval:intervals) if(get<0>(interval)<=addr and addr<get<1>(interval)){\n        cout << get<2>(interval) << endl;\n        ok=true;\n        break;\n    }\n    if(!ok) cout << -1 << endl;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        intervals.clear();\n        intervals.insert(triple(0,0,-inf));\n        rep(i,0,n){\n            char command;\n            cin >> command;\n            if(command=='W') write();\n            else if(command=='D') del();\n            else read();\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<list>\nusing namespace std;\nint n;\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tlist<pair<int,int> >L;\n\t\tL.push_back(make_pair(-1,2e9));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tchar c;cin>>c;\n\t\t\tif(c=='W')\n\t\t\t{\n\t\t\t\tint s,l;cin>>s>>l;\n\t\t\t\tfor(auto it=L.begin();l>0&&it!=L.end();it++)\n\t\t\t\t{\n\t\t\t\t\tif(it->first==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(it->second>l)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tit->second-=l;\n\t\t\t\t\t\t\tL.insert(it,make_pair(s,l));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tl-=it->second;\n\t\t\t\t\t\t\tit->first=s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c=='R')\n\t\t\t{\n\t\t\t\tint l;cin>>l;\n\t\t\t\tfor(auto it=L.begin();l>0&&it!=L.end();it++)\n\t\t\t\t{\n\t\t\t\t\tl-=it->second;\n\t\t\t\t\tif(l<=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<it->first<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint l;cin>>l;\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++)\n\t\t\t\t{\n\t\t\t\t\tif(it->first==l)it->first=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tif(id[l]>=10001)return 0;\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20000];\nsegment *head, *blank;\n\nsegment* newseg(){\n    blank->next=NULL;\n    blank->file=NULL;\n    blank->id=-1;\n    blank->head=-1;\n    blank->length=-1;\n    return blank++;\n}\n\nvoid W(int I, int S){\n    segment *p=head, *last;\n    while(S){\n        while(p->id!=-1) p=p->next;\n        if(p->length>S){\n            p->id=I;\n            segment *b=newseg();\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n            p=p->next;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head,*next;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        next=p->file;\n        p->file=NULL;\n        p=next;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20000;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n){\n\n\t\tmap<P, int> mp;\n\n\t\t//??????\n\t\tmp[P(-1, -1)] = -1;\n\t\tmp[P(INF + 1, INF + 1)] = -1;\n\n\t\trep(i, n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint l, s;\n\t\t\t\tcin >> l >> s;\n\n\t\t\t\tauto bg = mp.begin();\n\t\t\t\twhile (s){\n\t\t\t\t\tauto nx = next(bg);\n\t\t\t\t\tint ri = bg->first.second;\n\t\t\t\t\tint le = nx->first.first;\n\t\t\t\t\tif (ri + 1 < le){\n\t\t\t\t\t\tint ad = min(s, le - ri - 1);\n\t\t\t\t\t\tmp[P(ri + 1, ri + ad)] = l;\n\t\t\t\t\t\ts -= ad;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s)\n\t\t\t\t\t\tif (next(next(bg))->second != -1)bg = nx;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tint st = nx->first.second + 1;\n\t\t\t\t\t\t\tmp[P(st, st + s)] = l;\n\t\t\t\t\t\t\ts = 0; break;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c == 'D'){\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor (auto j = mp.begin(); j != mp.end(); j = next(j)){\n\t\t\t\t\tif (j->second == l){\n\t\t\t\t\t\tj = prev(j);\n\t\t\t\t\t\tmp.erase(next(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c == 'R'){\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto j : mp){\n\t\t\t\t\tif (j.first.first <= l && l <= j.first.second){\n\t\t\t\t\t\tcout << j.second << endl; f = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(list<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.push_front({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.push_back({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.push_front({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert(it,{prev->l,t,id});\n            \n            cnt-=t;\n        }\n        if(cnt==0) break;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.push_back({it->r,it->r+cnt,id});\n    \n}\nvoid solve() {\n    list<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n            //for(auto &e : range) {\n            //    cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n            //}\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct List{\n\tint id, cnt;\n\tList *nxt;\n};\n\nvoid _delete(List *p){\n\tif (p == nullptr) return;\n\t_delete(p->nxt);\n\tdelete p;\n}\n\nvoid erase(List *p, int id){\n\tif (p == nullptr) return;\n\tif (p->id == id) p->id = -1;\n\terase(p->nxt, id);\n}\n\nint find(List *p, int pos){\n\tif (p == nullptr) return -1;\n\tif (p->cnt > pos) return p->id;\n\treturn find(p->nxt, pos - p->cnt);\n}\n\nList* add(List *p, int id, int cnt){\n\tif (!cnt || p == nullptr)return new List{id, cnt, nullptr};\n\tif (p->id < 0){\n\t\tp->id = id;\n\t\tif (p->cnt > cnt){\n\t\t\tList *nl = new List{ -1, p->cnt - cnt, p->nxt };\n\t\t\tp->nxt = nl;\n\t\t\treturn p;\n\t\t}\n\t\tcnt -= p->cnt;\n\t}\n\tp->nxt = add(p->nxt, id, cnt);\n\treturn p;\n}\n\nint main(){\n\tList *head = new List();\n\tint n;\n\twhile (cin >> n, n){\n\t\twhile (n--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint id, cnt;\n\t\t\t\tcin >> id >> cnt;\n\t\t\t\thead->nxt = add(head->nxt, id, cnt);\n\t\t\t}\n\t\t\telse if (c == 'D'){\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\terase(head->nxt, id);\n\t\t\t}\n\t\t\telse if (c == 'R'){\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << find(head->nxt, pos) << '\\n';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t\t_delete(head->nxt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint N;\n //<(????§???????????????????(1~), ????????????????????????), ???>\npair< pair<int, int>, int > disk[20005];\n\nint main() {\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    REP(i,0,20005) disk[i] = make_pair(make_pair(INF,INF), INF);\n    disk[0] = make_pair(make_pair(1,1000000000), -1);  //-1:empty\n    REP(i,0,N){\n      string com, inp1, inp2;\n      int num, len, ind;\n      cin>>com;\n      if(com==\"W\"){ /*?????????*/\n        cin>>inp1>>inp2;\n        num = stoi(inp1);\n        len = stoi(inp2);\n        REP(k,0,20005){\n          if(len==0) break;\n          if(disk[k].S == -1){\n            int tl = disk[k].F.S-disk[k].F.F+1;\n            if(len >= tl){\n              disk[k].S = num;\n              len -= tl;\n            }else{\n              //??°????´???????\n              int tmp = disk[k].F.F;\n              disk[k].F.F = disk[k].F.F+len;\n              RREP(l,k+1,20005){\n                disk[l] = disk[l-1];\n              }\n              disk[k] = make_pair(make_pair(tmp, tmp+len-1), num);\n              len = 0;\n            }\n          }\n        }\n      }else if(com==\"D\"){ /*??????*/\n        cin>>inp1;\n        num = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].S==num) disk[k].S = -1;\n        }\n      }else{ /*????????????*/\n        cin>>inp1;\n        ind = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].F.F <= ind && ind <= disk[k].F.S){\n            cout<<disk[k].S<<endl;\n            break;\n          }\n        }\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n */\n#include <iostream>\n#include <algorithm>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n// init\n\n// input\nint iN;\nchar cC; // 0 <= N <= 100,000\nint iI; // 1 <= P <= 100\nint iS; // 1 <= P <= 100\nint iP; // 1 <= P <= 100\n\n// manage\n\n// ú»\nvoid init() {\n}\n\n// üÍ\nbool input() {\n  scanf(\"%d\", &iN);\n  if (iN == 0)\n    return false;\n  return true;\n}\n\n// \nvoid manage() {\n  int i;\n  list<P> lis;\n  list<P>::iterator it; // Ce[^\n  P p;\n  for (i = 0; i < iN; i++) {\n    it = lis.begin();\n\n    while (it != lis.end()) { // listÌöÜÅ\n      printf(\"(%d, %d) \", it->first, it->second); // vfðoÍ\n      ++it; // Ce[^ðPÂißé\n    }\n    printf(\"\\n\"); // vfðoÍ\n\n    scanf(\" %c\", &cC);\n\n    if (cC == 'W') {\n      scanf(\"%d %d\", &iI, &iS);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == -1) {\n          it->first = iI;\n          if (iS >= it->second) {\n            iS -= it->second;\n          } else {\n            int d = it->second - iS;\n            it->second = iS;\n            iS = 0;\n            it++;\n            lis.insert(it, P(-1, d));\n          }\n          if (iS == 0) break;\n        }\n        it++;\n      }\n      if (it == lis.end()) {\n        lis.push_back(P(iI, iS));\n      }\n      continue;\n    }\n\n    if (cC == 'D') {\n      scanf(\"%d\", &iI);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == iI) {\n          it->first = -1;\n        }\n        it++;\n      }\n\n      continue;\n    }\n\n    if (cC == 'R') {\n      scanf(\"%d\", &iP);\n      it = lis.begin();\n      int sum = 0;\n      while (it != lis.end()) { // listÌöÜÅ\n        //printf(\"(%d, %d) %d %d %d\\n\", it->first, it->second, sum + it->second, iP, sum + it->second > iP); // vfðoÍ\n        if (sum + it->second > iP)\n          break;\n        sum += it->second;\n        it++;\n      }\n      if (it != lis.end()) {\n        printf(\"%d\\n\", it->first);\n      } else {\n        printf(\"-1\\n\");\n      }\n      continue;\n    }\n\n  }\n\n}\n\n// oÍ\nvoid output() {\n  printf(\"\\n\");\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while (1) {\n    if (!input())\n      break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n <= r; } // n in [l, r]?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n \n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nstruct I\n{\n    int l, r, id; // [l, r)\n    I(int l, int r, int id)\n        : l(l), r(r), id(id) {}\n    bool operator<(const I& a) const\n    {\n        return l < a.l;\n    }\n};\nint main()\n{\n    fast_io();\n\n    int n;\n    while (cin >> n, n)\n    {\n        static vector<I> cur, next;\n        cur.clear();\n        cur.pb(I(-100, 0, -1));\n        cur.pb(I(ten(9) + 100, -1, -1));\n        \n        while (n--)\n        {\n            char op;\n            cin >> op;\n            if (op == 'W')\n            {\n                int id, len;\n                cin >> id >> len;\n\n                next.clear();\n                rep(i, cur.size() - 1)\n                {\n                    next.pb(cur[i]);\n                    int space = cur[i + 1].l - cur[i].r;\n                    if (len > 0 && space > 0)\n                    {\n                        int size = min(len, space);\n                        len -= size;\n                        next.pb(I(cur[i].r, cur[i].r + size, id));\n                    }\n                }\n                next.pb(cur.back());\n\n                swap(cur, next);\n            }\n            else if (op == 'D')\n            {\n                int id;\n                cin >> id;\n\n                next.clear();\n                rep(i, cur.size())\n                    if (cur[i].id != id)\n                        next.pb(cur[i]);\n\n                swap(cur, next);\n            }\n            else if (op == 'R')\n            {\n                int pos;\n                cin >> pos;\n\n                int k = lower_bound(all(cur), I(pos, -1, -1)) - cur.begin() - 1;\n                int res = -1;\n                if (in_seg(pos, cur[k].l, cur[k].r - 1))\n                    res = cur[k].id;\n                cout << res << endl;\n            }\n            else\n                assert(false);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing pii = std::pair<int, int>;\n\tstd::map<int, int> placeEmptySize;\n\tstd::map<int, std::pair<int, int>> placeIdSize;\n\tstd::map<int, std::vector<std::pair<int, int>>> idPlace;\n\n\tvoid writeCom()\n\t{\n\t\tint I, S;\n\t\tscanf(\"%d%d\", &I, &S);\n\t\tidPlace[I];\n\t\tauto& vec{idPlace.find(I)->second};\n\t\twhile (S)\n\t\t{\n\t\t\tif (S >= placeEmptySize.begin()->second)\n\t\t\t{\n\t\t\t\tvec.push_back({*placeEmptySize.begin()});\n\t\t\t\tS -= placeEmptySize.begin()->second;\n\t\t\t\tplaceIdSize[placeEmptySize.begin()->first] = {I, placeEmptySize.begin()->second};\n\t\t\t\tplaceEmptySize.erase(placeEmptySize.begin());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpii tmp{placeEmptySize.begin()->first, placeEmptySize.begin()->second};\n\t\t\t\tvec.push_back({tmp.first, S});\n\t\t\t\tplaceEmptySize.erase(placeEmptySize.begin());\n\t\t\t\tplaceIdSize[tmp.first] = {I, S};\n\t\t\t\ttmp.first += S;\n\t\t\t\ttmp.second -= S;\n\t\t\t\tplaceEmptySize.insert(tmp);\n\t\t\t\tS = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tvoid deleteCom()\n\t{\n\t\tint I;\n\t\tscanf(\"%d\", &I);\n\t\tauto it{idPlace.find(I)};\n\t\tfor (auto& e: it->second)\n\t\t{\n\t\t\tplaceEmptySize[e.first] = e.second;\n\t\t\tplaceIdSize.erase(e.first);\n\t\t}\n\t\tidPlace.erase(it);\n\t\treturn;\n\t}\n\n\tvoid readCom()\n\t{\n\t\tint P;\n\t\tscanf(\"%d\", &P);\n\t\tauto tmp{placeEmptySize.upper_bound(P)};\n\t\ttmp--;\n\t\tif (tmp->first <= P && P < tmp->first + tmp->second)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tauto tmp2{placeIdSize.upper_bound(P)};\n\t\t\ttmp2--;\n\t\t\tstd::cout << tmp2->second.first << std::endl;\n\t\t}\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint N;\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tplaceEmptySize[0] = 1 << 30;\n\t\tfor (int i{}; i < N; i++)\n\t\t{\n\t\t\tchar com;\n\t\t\tscanf(\" %c\", &com);\n\t\t\tif (com == 'W')\n\t\t\t\twriteCom();\n\t\t\telse if (com == 'R')\n\t\t\t\treadCom();\n\t\t\telse\n\t\t\t\tdeleteCom();\n\t\t}\n\t\tputs(\"\");\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\n#define first start \n#define second goal \n\nusing namespace std;\n\nconst int NONE = -1;\nconst int MAX = 1000000000;\n\nstruct sector {\n\tint length, id;\t\n\tsector(int id_, int length_): id(id_), length(length_) {}\n};\n\nvector<sector> sys;\nint pos;\n\n\nvoid read(int pos) {\n\tint idx = 0;\n\t//rep(i, sys.size()) { cout << sys[i].id << \",\" << sys[i].length << \" \";} cout << endl;\n\trep(i, sys.size()) {\n\t\tidx += sys[i].length;\n\t\tif(idx >= pos) {\n\t\t\tcout << sys[i].id << endl;\t\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nvoid write(int id, int size) {\n\n\tif(sys.size() == 0) {\n\t\tsys.push_back(sector(id, size));\t\n\t\treturn;\n\t}\n\n\tint n = sys.size();\n\trep(i, n) {\n\t\tif(sys[i].id != -1) continue;\n\t\t\n\t\tvector<sector>::iterator it = sys.begin()+i;\n\t\tif(sys[i].length == size) {\n\t\t\tsys[i].id = id;\t\n\t\t\treturn;\n\t\t}\n\t\telse if(sys[i].length - size > 0){\n\t\t\tsys.insert(it+1, sector(-1, sys[i].length - size));\n\t\t\tsys[i].id = id;\n\t\t\tsys[i].length = size;\n\t\t\treturn;\n\t\t}\n\t\telse if(sys[i].length - size < 0) {\n\t\t\tsys[i].id = id;\n\t\t\tsize -= sys[i].length;\n\t\t}\n\t\tif(size <= 0) return;\n\t}\n\tsys.push_back(sector(id, size));\n\n\treturn;\n}\n\nvoid del(int id) {\n\trep(i, sys.size()) {\n\t\tif(sys[i].id == id) sys[i].id = -1;\t\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\t\n\t\tsys.clear();\n\n\t\tchar cmd;\n\t\trep(i, n) {\n\t\t\tcin >> cmd;\t\n\t\t\tif(cmd == 'W') {\n\t\t\t\tint id, size;\n\t\t\t\tcin >> id >> size;\n\t\t\t\twrite(id, size);\n\t\t\t}\n\t\t\telse if(cmd == 'D') {\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\tdel(id);\n\t\t\t}\n\t\t\telse if(cmd == 'R') {\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tread(pos);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n#define NON -1\ntypedef pair < int , int > Pi;\ntypedef pair < Pi , int > Pii;\nvector< Pii > memory; //セクタの状態\nvoid write( int l, int sum){ //書き込む\n  for(int i = 0; sum > 0 ; i++){\n    if(memory[i].sc != NON) continue;\n    int kazu = memory[i].fr.sc - memory[i].fr.fr + 1;\n    if(kazu <= sum){\n      memory[i].sc = l, sum -= kazu;\n    }else{\n      memory.insert( memory.begin() + i, Pii( Pi( memory[i].fr.fr, memory[i].fr.fr + sum - 1), l));\n      memory[++i].fr.fr = memory[i - 1].fr.sc + 1;\n      sum = 0;\n    }\n  }\n}\nvoid erase( int idx){ //消す\n  for(int i = 0; i < memory.size() ; i++){\n    if(memory[i].sc == idx) memory[i].sc = NON;\n  }\n}\nvoid read( int idx){ //読み込む\n  cout << (lower_bound(memory.begin(),memory.end(),Pii(Pi(idx,-1),-1))-1) -> sc << endl;\n  // while(memory[pos].fr.sc < idx) pos++;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    memory.clear();\n    memory.push_back( Pii( Pi( 0, 1000000001), NON));\n    while(n--){\n      char buff;\n      cin >> buff;\n      if(buff == 'W'){ //write\n        int a, b;\n        cin >> a >> b;\n        write(a,b);\n      }else if(buff == 'D'){ //delete\n        int a;\n        cin >> a;\n        erase(a);\n      }else{ //read\n        int a;\n        cin >> a;\n        read(a);\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\nstruct Data {\n    ll start,end,id;\n    Data* next;\n    Data *prev;\n    Data(ll s,ll e,int i) : start(s), end(e), id(i) {;}\n};\n\nvoid insert(int id,ll size,Data *d) {\n    while(true) {\n        //cout<<(d->start)<<\",\"<<(d->end)<<\":\"<<(d->id)<<endl;\n        if(size == 0) return;\n        if(d->id != -1) {\n            d = d->next;\n            continue;\n        }\n        ll use = min(size, (d->end) - (d->start) + 1);\n        if(use == size) {\n            ll remain = (d->end)-(d->start)+1 - size;\n            if(remain == 0) d->id = id;\n            else{\n                Data* nd = new Data(d->start+size,d->end,-1);\n                nd->prev = d;\n                nd->next = d->next;\n                d->next = nd;\n                d->end = d->start+size-1;\n                d->id = id;\n            }\n            break;\n        }else{\n            ll remain = size - ((d->end)-(d->start)+1);\n            d->id = id;\n            size = remain;\n            d = d->next;\n        }\n    }\n}\n\nint lookup(Data *n,ll p) {\n    while(true) {\n        if(n == NULL) return -1;\n        if(n->start <= p && n->end >= p) return n->id;\n        n = n->next;\n    }\n}\n\nvoid remove(int id,Data *n) {\n    while(n != NULL) {\n        if(n == NULL) return;\n        if((n->id) != id) {\n            n = n->next;\n            continue;\n        }\n\n        n->id = -1;\n        n = n->next;\n    }\n}\n\nvoid dump(Data *n) {\n    while(true) {\n        if(n == NULL) return;\n        //cout<<(n->start)<<\" \"<<(n->end)<<\" \"<<(n->id)<<endl;\n        n = n->next;\n    }\n}\n\nint main() {\n    int n;\n    string op;\n    while(cin>>n, n) {\n        Data root(0, 1ll<<60, -1);\n        Data *rp = &root;\n        root.prev = &root;\n        root.next = NULL;\n\n        ll id,size;\n        for(int i=0; i<n; ++i) {\n            cin>>op;\n            if(op == \"W\") {\n                cin>>id>>size;\n                //cout<<\"W \"<<id<<\" \"<<size<<endl;\n                insert(id,size,rp);\n                //dump(rp);\n                //cout<<endl;\n            }else if(op == \"D\") {\n                cin>>id;\n                //cout<<\"D \"<<id<<endl;\n                remove(id,rp);\n                //dump(rp);\n                //cout<<endl;\n            }else if(op == \"R\") {\n                cin>>size;\n                cout<<lookup(rp,size)<<endl;\n            }\n        }\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int ll\ntypedef long long ll;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\nsigned main(void){\n    for(int n; cin >> n, n;){\n        vector<pii> s_empty;\n        s_empty.pb(mp(0, INF));\n\n        vector<vector<pii>> s_used(10001);\n        map<int, int> dic_o2i, dic_i2o;\n        int cnt_idx = 0;\n\n        while(n--){\n            char op; cin >> op;\n\n            switch(op){\n                case 'W':{\n                    int idx, len; cin >> idx >> len;\n\n                    dic_i2o[cnt_idx] = idx;\n                    dic_o2i[idx] = cnt_idx;\n                    idx = cnt_idx++;\n\n                    int cnt = 0;\n                    for(auto && sec : s_empty){\n                        if(len == 0) break;\n\n                        if(sec.S - sec.F <= len){\n                            s_used[idx].pb(sec);\n                            len -= (sec.S - sec.F);\n                            cnt++;\n                        }\n                        else{\n                            s_used[idx].pb(mp(sec.F, sec.F + len));\n                            sec = mp(sec.F + len, sec.S);\n\n                            break;\n                        }\n                    }\n\n                    s_empty.erase(s_empty.begin(), s_empty.begin() + cnt);\n                    range(i, 1, s_used[idx].size()){\n                        if(s_used[idx][i].F != s_used[idx][i - 1].S) continue;\n\n                        s_used[idx][i - 1].S = s_used[idx][i].S;\n                        s_used[idx].erase(s_used[idx].begin() + i);\n                        i--;\n                    }\n\n                    break;\n                }\n                case 'R':{\n                    int p; cin >> p;\n                    int res = -1;\n\n                    rep(i, cnt_idx){\n                        for(auto && sec : s_used[i]){\n                            if(p < sec.F || sec.S <= p) continue;\n\n                            res = dic_i2o[i];\n                        }\n                        \n                        if(res != -1) break;\n                    }\n\n                    cout << res << endl;\n\n                    break;\n                }\n                case 'D':{\n                    int idx; cin >> idx;\n                    idx = dic_o2i[idx];\n\n                    for(auto && sec : s_used[idx]){\n                        s_empty.pb(sec);\n                    }\n                    s_used[idx].clear();\n\n                    sort(all(s_empty));\n                    \n                    break;\n                }\n                \n                default: break;\n            }\n        }\n\n        cout << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/04 12:38:03\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    for (int N;;) {\n        cin >> N;\n        if (N == 0) { break; }\n        using P = pair<int, int>;\n        map<int, vector<P>> reg;\n        set<P> empty;\n        constexpr int INF = 1000000000;\n        empty.insert({0, INF});\n        auto sz = [](const P& p) { return p.second - p.first; };\n        for (int i = 0; i < N; i++) {\n            char c;\n            cin >> c;\n            if (c == 'W') {\n                int l, s;\n                cin >> l >> s;\n                vector<P> rem;\n                for (const auto& p : empty) {\n                    if (sz(p) <= s) {\n                        s -= sz(p), rem.push_back(p), reg[l].push_back(p);\n                    } else {\n                        rem.push_back(p), empty.insert({p.first + s, p.second}), reg[l].push_back({p.first, p.first + s - 1}), s = 0;\n                    }\n                    if (s == 0) { break; }\n                }\n                for (const auto& r : rem) { empty.erase(r); }\n            } else if (c == 'D') {\n                int l;\n                cin >> l;\n                for (const auto& r : reg[l]) { empty.insert(r); }\n                reg.erase(l);\n            } else {\n                int P;\n                cin >> P;\n                bool found = false;\n                for (const auto& vs : reg) {\n                    if (found) { break; }\n                    const int r = vs.first;\n                    const auto& v = vs.second;\n                    for (const auto& p : v) {\n                        if (p.first <= P and P <= p.second) {\n                            found = true, cout << r << endl;\n                            break;\n                        }\n                    }\n                }\n                if (not found) { cout << -1 << endl; }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const list<T>& a){\n\tos<<'[';\n\tforeach(i,a) os<<(i==a.begin()?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int q;cin>>q,q;){\n\t\tlist<pair<int,pii>> allocated;\n\t\tallocated.emplace_back(-1,pii(1e9,1e9+1));\n\t\trep(_,q){\n\t\t\tchar type; cin>>type;\n\t\t\tif(type=='W'){\n\t\t\t\tint label,len; cin>>label>>len;\n\t\t\t\tint pos=0;\n\t\t\t\tforeach(i,allocated){\n\t\t\t\t\tif(len==0) break;\n\t\t\t\t\tint first=i->second.first,last=i->second.second;\n\t\t\t\t\tif(first>pos){\n\t\t\t\t\t\tint block=min(first-pos,len);\n\t\t\t\t\t\tallocated.emplace(i,label,mp(pos,pos+block));\n\t\t\t\t\t\tlen-=block;\n\t\t\t\t\t}\n\t\t\t\t\tpos=last;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type=='D'){\n\t\t\t\tint label; cin>>label;\n\t\t\t\tfor(auto i=allocated.begin();i!=allocated.end();){\n\t\t\t\t\tif(i->first==label)\n\t\t\t\t\t\ti=allocated.erase(i);\n\t\t\t\t\telse\n\t\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type=='R'){\n\t\t\t\tint idx; cin>>idx;\n\t\t\t\tint label=-1;\n\t\t\t\tforeach(i,allocated){\n\t\t\t\t\tint first=i->second.first,last=i->second.second;\n\t\t\t\t\tif(first<=idx && idx<last){\n\t\t\t\t\t\tlabel=i->first;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<label<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N=1e4+10,INF=1e9;\n\nint N;\nchar C[MAX_N];\nint id[MAX_N],S[MAX_N],P[MAX_N];\n\nvoid solve(){\n    map<int,pair<int,int>> m;\n    m[0]={INF,-1};\n    for (int i=0;i<N;++i){\n        if (C[i]=='W'){\n            for (auto &p:m){\n                if (p.second.second==-1){\n                    int use=min(S[i],p.second.first-p.first+1);\n                    p.second.second=id[i];\n                    if (use<p.second.first-p.first+1){\n                        m[p.first+use]={p.second.first,-1};\n                        p.second.first=p.first+use-1;\n                    }\n                    S[i]-=use;\n                    if (!S[i]) break;\n                }\n            }\n        } else if (C[i]=='D'){\n            for (auto &p:m){\n                if (p.second.second==id[i]){\n                    p.second.second=-1;\n                }\n            }\n        } else {\n            int now=0;\n            for (auto p:m){\n                if (P[i]<=p.second.first){\n                    cout << p.second.second << '\\n';\n                    break;\n                }\n            }\n        }\n    }\n    cout << '\\n';\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N,N){\n        for (int i=0;i<N;++i){\n            cin >> C[i];\n            if (C[i]=='W') cin >> id[i] >> S[i];\n            if (C[i]=='D') cin >> id[i];\n            if (C[i]=='R') cin >> P[i];\n        }\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<pair<int,int> ,int> M;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='W'){\n\t\t\t\tint b,c;\n\t\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\t\tfor(map<pair<int,int>,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif(c<=0)break;\n\t\t\t\t\tpair<pair<int,int>,int> dat=*it;\n\t\t\t\t\tif((*it).second==-1){\n\t\t\t\t\t\tif(c>=(*it).first.second-(*it).first.first){\n\t\t\t\t\t\t\tc-=(*it).first.second-(*it).first.first;\n\t\t\t\t\t\t\tM[(*it).first]=b;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tM[make_pair((*it).first.first,(*it).first.first+c)]=b;\n\t\t\t\t\t\t\tM[make_pair((*it).first.first+c,(*it).first.second)]=-1;\n\t\t\t\t\t\t\tM.erase((*it).first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c>0){\n\t\t\t\t\tif(M.size()==0)M[make_pair(0,c)]=b;\n\t\t\t\t\telse{\n\t\t\t\t\t\tint p=((*(M.rbegin())).first.second);\n\t\t\t\t\t\tM[make_pair(p,p+c)]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='D'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tfor(map<pair<int,int>,int>::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif((*it).second==b){\n\t\t\t\t\t\tM[(*it).first]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='R'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tbool found=false;\n\t\t\t\tfor(map<pair<int,int> ,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tpair<int,int> q=(*it).first;\n\t\t\t\t\tif(q.first<b&&b<=q.second){\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).second);\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found)printf(\"%d\\n\",-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<set>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i;\n  int n,p,q;\n  char c;\n  list<pair<int,int> > a;\n  list<pair<int,int> >::iterator it;\n  while(cin>>n&&n){\n    a.clear();\n    a.push_back(make_pair(-1,1000000000));\n    for(i=0;i<n;i++){\n      cin>>c;\n      if(0){\n      }else if(c=='W'){\n\tcin>>p>>q;\n\tfor(it=a.begin();q;it++){\n\t  if((*it).first==-1){\n\t    if(0){\n\t    }else if((*it).second<q){\n\t      (*it).first=p;\n\t      q-=(*it).second;\n\t    }else if((*it).second>q){\n\t      (*it).second-=q;\n\t      a.insert(it,make_pair(p,q));\n\t      q=0;\n\t    }else{\n\t      (*it).first=p;\n\t      q=0;\n\t    }\n\t  }\n\t}\n      }else if(c=='D'){\n\tcin>>p;\n\tfor(it=a.begin();it!=a.end();it++){\n\t  if((*it).first==p)\n\t    (*it).first=-1;\n\t}\n      }else if(c=='R'){\n\tcin>>p;\n\ti=1;\n\tfor(it=a.begin();;it++){\n\t  if(i<=p&&p<i+(*it).second){\n\t    cout<<(*it).first<<endl;\n\t    break;\n\t  }\n\t  i+=(*it).second;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct Sector {\n  int file_id;\n  int first;\n  int last;\n  Sector(int _f,int _s,int _l) : file_id(_f), first(_s), last(_l) {}\n  int size() {return last - first + 1;}\n};\n\nclass FileSystem {\nprivate:\n  vector<Sector> sectors;\npublic:\n  FileSystem(){\n    sectors.clear();\n    sectors.push_back(Sector(-1,0,1000000007));\n  }\n  void write_sectors(int file_id,int required_sectors){\n    for(vector<Sector>::iterator it = sectors.begin();\n\tit != sectors.end();\n\tit++){\n      if(it->file_id == -1){\n\tit->file_id = file_id;\n\tif(required_sectors < it->size()){\n\t  int l = it->last;\n\t  it->last = it->first + required_sectors - 1;\n\t  int f = it->last + 1;\n\t  it++;\n\t  sectors.insert(it,1,Sector(-1,f,l));\n\t  break;\n\t}\n\telse {\n\t  required_sectors -= it->size();\n\t}\n      }\n    }\n  }\n\n  void delete_sectors(int file_id){\n    for(vector<Sector>::iterator it = sectors.begin();\n\tit != sectors.end();\n\tit++){\n      if(it->file_id == file_id){\n\tit->file_id = -1;\n      }\n    }\n  }\n\n  int refer_file_id(int sector_id){\n    for(vector<Sector>::iterator it = sectors.begin();\n\tit != sectors.end();\n\tit++){\n      if(it->first <= sector_id\n\t && sector_id <= it->last){\n\treturn it->file_id;\n      }\n    }\n    return -1;\n  }\n};\n\nint main(){\n  int total_commands;\n  while(~scanf(\"%d\",&total_commands)){\n    FileSystem fs;\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      char operation[2];\n      scanf(\"%s\",operation);\n      if(operation[0] == 'W'){\n\tint file_id,required_sectors;\n\tscanf(\"%d %d\",&file_id,&required_sectors);\n\tfs.write_sectors(file_id,required_sectors);\n      }\n      else if(operation[0] == 'D'){\n\tint file_id;\n\tscanf(\"%d\",&file_id);\n\tfs.delete_sectors(file_id);\n      }\n      else if(operation[0] == 'R'){\n\tint sector_id;\n\tscanf(\"%d\",&sector_id);\n\tcout << fs.refer_file_id(sector_id) << endl;\n      }\n    }\n    if(total_commands !=0) cout << \"\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\n#define first start \n#define second goal \n\nusing namespace std;\n\nconst int NONE = -1;\nconst int MAX = 1000000000;\n\nstruct sector {\n\tint length, id;\t\n\tsector(int id_, int length_): id(id_), length(length_) {}\n};\n\nvector<sector> sys;\nint pos;\n\n\nvoid read(int pos) {\n\tint idx = 0;\n\t//rep(i, sys.size()) { cout << sys[i].id << \",\" << sys[i].length << \" \";} cout << endl;\n\trep(i, sys.size()) {\n\t\tidx += sys[i].length;\n\t\tif(idx >= pos) {\n\t\t\tcout << sys[i].id << endl;\t\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nvoid write(int id, int size) {\n\n\tif(sys.size() == 0) {\n\t\tsys.push_back(sector(id, size));\t\n\t\treturn;\n\t}\n\n\tint n = sys.size();\n\trep(i, n) {\n\t\tif(sys[i].id != -1) continue;\n\t\t\n\t\tvector<sector>::iterator it = sys.begin()+i;\n\t\tif(sys[i].length == size) {\n\t\t\tsys[i].id = id;\t\n\t\t\treturn;\n\t\t}\n\t\telse if(sys[i].length - size > 0){\n\t\t\tsys.insert(it+1, sector(-1, sys[i].length - size));\n\t\t\tsys[i].id = id;\n\t\t\tsys[i].length = size;\n\t\t}\n\t\telse if(sys[i].length - size < 0) {\n\t\t\tsys[i].id = id;\n\t\t\tsize -= sys[i].length;\n\t\t}\n\t\tif(size <= 0) return;\n\t}\n\tsys.push_back(sector(id, size));\n\n\treturn;\n}\n\nvoid del(int id) {\n\trep(i, sys.size()) {\n\t\tif(sys[i].id == id) sys[i].id = -1;\t\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\t\n\t\tsys.clear();\n\n\t\tchar cmd;\n\t\trep(i, n) {\n\t\t\tcin >> cmd;\t\n\t\t\tif(cmd == 'W') {\n\t\t\t\tint id, size;\n\t\t\t\tcin >> id >> size;\n\t\t\t\twrite(id, size);\n\t\t\t}\n\t\t\telse if(cmd == 'D') {\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\tdel(id);\n\t\t\t}\n\t\t\telse if(cmd == 'R') {\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tread(pos);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(int i = 0, sum = 0; output == -1 && i < v.size();\n            sum += v[i].size, ++i) {\n          if(sum <= P && P < sum+v[i].size) {\n            output = v[i].id;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef long long ll;\n\nstruct sector { ll l, r, f; };\n\nll N, I, S, P;\nchar C;\nsector a[20000];\nint k;\n\nvoid write() {\n  cin >> I >> S;\n  REP(i, 0, k) if(a[i].f == -1 && S > 0) {\n    if(S >= a[i].r - a[i].l) {\n      a[i].f = I;\n      S -= a[i].r - a[i].l;\n    } else {\n      for(int j = k; j > i; j--) {\n        a[j + 1].l = a[j].l;\n        a[j + 1].r = a[j].r;\n        a[j + 1].f = a[j].f;\n      }\n      a[i + 1].r = a[i].r;\n      a[i + 1].f = -1;\n      a[i].f = I;\n      a[i].r = a[i].l + S;\n      a[i + 1].l = a[i].r;\n      S = 0;\n      k++;\n      break;\n    }\n  }\n  if(S > 0) {\n    int l = k > 0 ? a[k - 1].r : 0;\n    a[k++] = (sector) { l, l + S, I };\n  }\n}\n\nvoid destroy() {\n  cin >> I;\n  REP(i, 0, k) if(a[i].f == I) a[i].f = -1;\n}\n\nll read() {\n  cin >> P;\n  REP(i, 0, k) if(a[i].l <= P && P < a[i].r) return a[i].f;\n  return -1;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    k = 0;\n    REP(i, 0, N) {\n      cin >> C;\n      if(C == 'W') write();\n      if(C == 'D') destroy();\n      if(C == 'R') cout << read() << endl;\n\n      // cout << i << \": \" << C << \" \" << k << endl;\n      // REP(i, 0, k) {\n      //   cout << a[i].l << \" - \" << a[i].r << \": \" << a[i].f << endl;\n      // }\n      // cout << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  \n  int N;\n  while(cin >> N, N){\n\t// nuse[left] = width\n\tmap<int,int> nuse;\n\tnuse.insert(MP(0,1000000100));\n\t// use[left] = (width, id)\n\tmap<int,PII> use;\n\t// idx[id] = {left_1, left_2, ...}\n\tmap<int, VI> idx;\n\tREP(i,N){\n\t  char q; int a, b;\n\t  cin >> q;\n\t  switch(q){\n\t  case 'W':\n\t\tcin >> a >> b;\n\t\twhile(b > 0){\n\t\t  auto it = nuse.begin();\n\t\t  int w = min(b, it->second);\n\t\t  use[it->first] = MP(w, a);\n\t\t  idx[a].PB(it->first);\n\t\t  if(it->second > b)\n\t\t\tnuse[it->first+b] =  it->second - b;\n\t\t  nuse.erase(it);\n\t\t  b -= w;\n\t\t}\n\t\tbreak;\n\t  case 'D':\n\t\tcin >> a;\n\t\tfor(int left: idx[a]){\n\t\t  auto it = use.find(left);\n\t\t  nuse[left] = it->second.first;\n\t\t  use.erase(it);\n\t\t}\n\t\tidx[a].clear();\n\t\tbreak;\n\t  case 'R':\n\t\tcin >> a;\n\t\tauto up = use.upper_bound(a);\n\t\tif(up != use.begin()) --up;\n\t\tif(up->first <= a && a < up->first + up->second.first)\n\t\t  cout << up->second.second << endl;\n\t\telse\n\t\t  cout << -1 << endl;\n\t\t  \n\t\tbreak;\t\t\n\t  }\n\t}\n\tcout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nstruct data{\n\tdata(int a,int b){\n\t\tlength=a;\n\t\tid=b;\n\t}\n\tint length;\n\tint id;\n};\n\nvector<data> sys;\n\nvoid write(int id,int len){\n\tif(sys.size()==0){\n\t\tsys.push_back(data(len,id));\n\t}else{\n\t\tint n=sys.size();\n\t\trep(i,n){\n\t\t\tif(len<=0) return;\n\t\t\tif(sys.size()-1 == i && sys[i].id != -1){//????????????????´???????????????§????????¨??????????????????????????????\n\t\t\t\tsys.push_back(data(len,id));\t\n\t\t\t}else if(sys[i].id==-1){\n\t\t\t\tif(len-sys[i].length==0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}else if(len-sys[i].length<0){ //length???????????§??????\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tsys.insert(sys.begin()+i,data(len-sys[i].length,-1));\n\t\t\t\t\treturn;\n\t\t\t\t}else if(len-sys[i].length>0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid read(int id){\n\tint len=0;\n\trep(i,sys.size()){\n\t\tlen+=sys[i].length;\n\t\tif(len>=id){\n\t\t\tcout << sys[i].id << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nvoid del(int id){\n\trep(i,sys.size()){\n\t\tif(sys[i].id==id){\n\t\t\tsys[i].id=-1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tsys.clear();\n\t\t\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tint I,S;\n\t\t\tcin >> c;\n\t\t\n\t\t\t\n//\t\t\tcout << c << endl;\n\t\t\tif(c=='D'){\n\t\t\t\tcin >> I;\n\t\t\t\tdel(I);\n\t\t\t}else if(c=='W'){\n\t\t\t\tcin >> I >> S;\n\t\t\t\twrite(I,S);\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin >> I;\n\t\t\t\tread(I);\n\t\t\t}\t\t\n\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int> m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tm.erase(it++);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tset<pii> empty({ {0,INF} });\n\t\tmap<int, vector<pii>> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == 'W')\n\t\t\t{\n\t\t\t\tint a, b; cin >> a >> b;\n\t\t\t\tvector<pii> v;\n\t\t\t\tvector<pii> era;\n\t\t\t\tfor (auto it = empty.begin(); b > 0; it++)\n\t\t\t\t{\n\t\t\t\t\tif (it->second - it->first > b)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.emplace_back(it->first, it->first + b);\n\t\t\t\t\t\tera.push_back(*it);\n\t\t\t\t\t\tempty.insert(pii(it->first + b, it->second));\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tv.emplace_back(*it);\n\t\t\t\t\t\tb -= it->second - it->first;\n\t\t\t\t\t\tera.push_back(*it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tREP(i, era.size()) empty.erase(era[i]);\n\t\t\t\tmp[a] = v;\n\t\t\t}\n\t\t\telse if (c == 'D')\n\t\t\t{\n\t\t\t\tint a; cin >> a;\n\t\t\t\tvector<pii> v = mp[a];\n\t\t\t\tmp.erase(a);\n\t\t\t\tREP(i, v.size()) empty.insert(v[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint a; cin >> a;\n\t\t\t\tint res;\n\t\t\t\tfor (auto j : empty)\n\t\t\t\t{\n\t\t\t\t\tif (a >= j.first&&a < j.second)\n\t\t\t\t\t{\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (auto j : mp)\n\t\t\t\t{\n\t\t\t\t\tvector<pii> tmp = j.second;\n\t\t\t\t\tREP(k, tmp.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (a >= tmp[k].first&&a < tmp[k].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tres = j.first;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tend:;\n\t\t\t\tcout << res << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <list>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\n\n// [a,b)の区間ごとにデータを保持する -1:=そこにデータはない\nstruct FileSystem{\n  list<pair<pair<int, int>, int> >se;\n  list<pair<pair<int, int>, int> >::iterator it, insertit;\n  FileSystem(){\n    se.push_back(make_pair(make_pair(0, 1000000005), -1));\n  }\n  void write(int id, int size){\n    it = se.begin();\n    while(it != se.end() && size > 0){\n      if(it->second == -1){\n\tint sectorSize = it->first.second-it->first.first;\n\tif(sectorSize < size){\n\t  it->second = id;\n\t  size -= sectorSize;\n\t}else{\n\t  insertit = it; insertit++;\n\t  if(sectorSize > size) se.insert(insertit,make_pair(make_pair(it->first.first+size, it->first.second), -1));\n\t  it->second = id;\n\t  it->first.second = it->first.first + size;\n\t  size = 0;\n\t}\n      }\n      it++;\n    }\n  }\n  void erase(int id){\n    it = se.begin();\n    while(it != se.end()){\n      if(it->second == id) it->second = -1;\n      it++;\n    }\n  }\n  int ref(int adress){\n    it = se.begin();\n    while(it != se.end()){\n      if(it->first.first <= adress && adress < it->first.second) return it->second;\n      it++;\n    }\n    return -1;\n  }\n};\n\nint main(){\n  int N;\n  while(scanf(\"%d\",&N) && N){\n    FileSystem fs;\n    rep(i,N){\n      char cmd[2];\n      scanf(\"%s\", cmd);\n      if(cmd[0]=='W'){\n\tint l,s; scanf(\"%d%d\",&l,&s);\n\tfs.write(l,s);\n      }else if(cmd[0]=='D'){\n\tint l; scanf(\"%d\",&l);\n\tfs.erase(l);\n      }else if(cmd[0]=='R'){\n\tint p; scanf(\"%d\", &p);\n\tprintf(\"%d\\n\", fs.ref(p));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int>P;\nint main(){\n  string st;\n  vector<P>v;\n  int n,x,y;\n  while(cin>>n,n){\n    v.clear();\n    while(n--){\n      cin>>st;\n      if(st==\"W\"){\n        cin>>x>>y;\n        r(i,v.size()+1){\n          if(i==v.size()){\n            v.push_back(P(x,y));\n            break;\n          }\n          else if(v[i].f==-1){\n            if(v[i].s-y>0)v[i].f=x,y-=v[i].s;\n            else{\n              v[i].s-=y;\n              v.insert(v.begin()+i+1,P(x,y));\n              break;\n            }\n          }\n        }\n      }\n      else if(st==\"D\"){\n        cin>>x;\n        r(i,v.size())if(v[i].f==x)v[i].f=-1;\n      }\n      else{\n        int p=0,fl=0;\n        cin>>x;\n        r(i,v.size()){\n          if(p<=x&&x<=p+v[i].s){\n            cout<<v[i].f<<endl;\n            fl++;\n            break;\n          }\n          p+=v[i].s;\n        }\n        if(!fl)cout<<-1<<endl;\n      }\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n      prev=pres;\n      pres=pres->next;\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp<s){\n\tsinki->end=prev->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=prev->end+tmp;\n\ts=0;\n\treturn;\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n    } \n  }  \n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  if(pres->start <= p&& pres->end >= p)\n    cout<<pres->dot<<endl; \n  else if(pres->end < p){\n    prev=pres;\n    pres=pres->next;}\n  else cout<<-1<<endl;\n  return ;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i)\n      prev->next=pres->next;\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm* next;\n  if(begin==NULL) return;\n  next=begin->next;\n  delete begin;\n  reset(next);\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    if(N==0) break;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>i>>s;\n\twrite(begin,i,s);\n      }\n      if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      if(com=='R'){\n\tcin>>i;\n\tread(begin,i);\n      }\n    }\n    reset(begin);\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#define F first\n#define S second\n#define MAX 10010\n#define all(n) n.begin(),n.end()\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\nstruct P\n{\n  int id,l,r;\n  P(int l = -1,int r = -1,int id = -1):l(l),r(r),id(id){}\n};\n\nbool cmp(const P& p,const P& q)\n{\n  return p.l < q.l;\n}\n\nvoid print(const vector<P>& v)\n{\n  cout << \"print\" << endl;\n  for(int i=0;i<v.size();i++)\n    cout << v[i].id << \" \" << v[i].l << \" \" << v[i].r << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      vector<P> vec;    \n      for(int ww = 0;ww<N;ww++)\n\t{\n\t  char c;\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      int index = 0;\n\t      int id,s,size;\n\t      size = vec.size();\n\t      cin >> id >> s;\n\t      if(vec.empty())\n\t\t{\n\t\t  vec.push_back(P(0,s,id));//[l,r)\n\t\t  continue;\n\t\t}\n\t      for(int i=0;i<size && s;i++)\n\t\t{\n\t\t  if(index != vec[i].l)\n\t\t    {\n\t\t      if(vec[i].l-index >= s)\n\t\t\t{\n\t\t\t  vec.push_back(P(index,index+s,id));\n\t\t\t  break;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  vec.push_back(P(index,vec[i].l,id));\n\t\t\t  s -= (vec[i].l-index);\n\t\t\t  index = vec[i].r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      if(s)\n\t\t{\n\t\t  sort(all(vec),cmp);\n\t\t  int nl = vec[vec.size()-1].r;\n\t\t  vec.push_back(P(nl,nl+s,id));\n\t\t}\n\t    }\n\t  else if(c == 'R')\n\t    {\n\t      int pos;\n\t      cin >> pos;\n\t      bool found = false;\n\t      for(int i=0;i<vec.size();i++)\n\t\t{\n\t\t  if(vec[i].l <= pos && pos < vec[i].r)\n\t\t    {\n\t\t      found = true;\n\t\t      cout << vec[i].id << endl;\n\t\t      goto next;\n\t\t    }\n\t\t}\n\t    next:;\n\t      if(!found)\n\t\tcout << -1 << endl;\n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int id;\n\t      cin >> id;\n\t      bool ToBeContinued = true;\n\t      while(ToBeContinued)\n\t\t{\n\t\t  ToBeContinued = false;\n\t\t  for(vector<P>::iterator it = vec.begin();it != vec.end();it++)\n\t\t    {\n\t\t      if(it->id == id)\n\t\t\t{\n\t\t\t  ToBeContinued = true;\n\t\t\t  vec.erase(it);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  else\n\t    assert(false);\n\t  sort(all(vec),cmp);\n\t  //print(vec);\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20000];\nsegment *head, *blank;\n\nsegment* newseg(){\n    blank->next=NULL;\n    blank->file=NULL;\n    blank->id=-1;\n    blank->head=-1;\n    blank->length=-1;\n    return blank++;\n}\n\nvoid W(int I, int S){\n    segment *p=head, *last;\n    while(S){\n        while(p->id!=-1) p=p->next;\n        if(p->length>S){\n            p->id=I;\n            segment *b=newseg();\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n            p=p->next;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head,*next;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        next=p->file;\n        p->file=NULL;\n        p=next;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20000;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nstruct file { ll sta, end, id; };\nint main(){\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<file> v;\n\t\trep(aa, n) {\n\t\t\tchar t; cin >> t;\n\t\t\tint len = v.size();\n\t\t\tif (t == 'W') {\n\t\t\t\tll x, y; cin >> x >> y;\n\t\t\t\tll now = 0;\n\t\t\t\trep(j, len) {\n\t\t\t\t\tif (y == 0)break;\n\t\t\t\t\tll dif = v[j].sta - now;\n\t\t\t\t\tif (y <= dif) {\n\t\t\t\t\t\tv.insert(v.begin() + j, { now,now + y,x }); len++; j++;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(dif>0){\n\t\t\t\t\t\tv.insert(v.begin() + j, { now,v[j].sta,x }); len++; j++;\n\t\t\t\t\t\ty -= dif;\n\t\t\t\t\t}\n\t\t\t\t\tnow = v[j].end;\n\t\t\t\t}\n\t\t\t\tif (y > 0) {\n\t\t\t\t\tv.push_back({ now,now + y,x });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == 'D') {\n\t\t\t\tll x; cin >> x;\n\t\t\t\tper(j, len) {\n\t\t\t\t\tif (v[j].id == x) {\n\t\t\t\t\t\tv.erase(v.begin() + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t == 'R') {\n\t\t\t\tll x; cin >> x;\n\t\t\t\tbool ansed = false;\n\t\t\t\trep(j, len) {\n\t\t\t\t\tif (x < v[j].sta) {\n\t\t\t\t\t\tcout << -1 << endl; ansed = true; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (v[j].sta <= x && x < v[j].end) {\n\t\t\t\t\t\tcout << v[j].id << endl; ansed = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!ansed)cout << -1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  files[make_pair(h,e-1)]=I;\n\t  S-=e-h;\n\t}else{\n\t  files[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tif(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 100100\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index == s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else if(file[j+1].first.first-index > s)\n\t\t\t{\n\t\t\t  file[j] = p2(index,index+s,l);\n\t\t\t  if(file[j+1] == p2(-2,-2,-2) || file[j+1] == p2(-1,-1,-1))\n\t\t\t    break;\n\t\t\t  P2 tmp = file[j+1];\n\t\t\t  file[j+1] = p2(-1,-1,-1);\n\t\t\t  s = 0;\n\t\t\t  for(int k=j+2;file[k-1] != p2(-2,-2,-2);k++)\n\t\t\t    {\n\t\t\t      P2 tmp2 = file[k];\t\t\t\n\t\t\t      file[k] = tmp;\n\t\t\t      tmp = tmp2;\n\t\t\t    }\n\t\t\t}\t\t      \n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    assert(false);\n\t\t  \n\t\t}\n\t   \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        lli output = -1;\n        for(lli i = 0, sum = 0; i < v.size(); sum += v[i++].size) {\n          if(P < sum+v[i].size) {\n            if(v[i].id >= 0) output = v[i].id;\n            break;\n          }\n        }\n        cout << output << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int>m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(typeof(m.begin()) it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\ttypeof(m.begin()) it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tpair<int,int> f=make_pair(n,2000000000);\n\t\t\ttypeof(m.begin()) it=m.lower_bound(f);\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(typeof(m.begin()) it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[make_pair(cur,cur+z-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\nstruct DATA{\n\tint l,r,num;\n};\nvector<DATA>v;\n\nvoid WRITE(int a,int b){\n\trep(i,1,v.size()){\n\t\tint haba = min(b,v[i].l-v[i-1].r);\n\t\tif(haba==0)continue;\n\t\tb-=haba;\n\t\tv.insert(v.begin()+i,{v[i-1].r,v[i-1].r+haba,a});\n\t\tif(b==0)break;\n\t}\n}\n\nvoid DELETE(int a){\n\tfor(auto itr = v.begin();itr != v.end();){\n\t\tif(itr->num==a)v.erase(itr);\n\t\telse itr++;\n\t}\n}\nint READ(int a){\n\trep(i,0,v.size()){\n\t\tif(v[i].l<=a&&a<v[i].r){\n\t\t\treturn v[i].num;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint N;\nvoid solve(vector<int>&ans){\n\tv.clear();\n\tv.push_back({-1,0,-1});\n\tv.push_back({1000000001,1000000002,-1});\n\trep(i,0,N){\n\t\tchar c;\n\t\tcin>>c;\n\t\tif(c=='W'){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tWRITE(a,b);\n\t\t}else if(c=='D'){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tDELETE(a);\n\t\t}else{\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tans.push_back(READ(a));\n\t\t}\n\t}\n}\n \nsigned main(){\n\tIOS();\n\tvector<int>ans;\n\twhile(cin>>N,N){\n\t\tsolve(ans);\n\t\tans.push_back(-INF);\n\t}\n\tfor(auto e:ans){\n\t\tif(e==-INF)cout<<endl;\n\t\telse cout<<e<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tlist<pii> ls;\n\t\tlist<pii>::iterator it;\n\t\tset<int> st;\n\n\t\tchar ch;\n\t\tint L, S;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\" %c\", &ch);\n\t\t\tif(ch == 'W'){\n\t\t\t\tscanf(\"%d%d\", &L, &S);\n\t\t\t\tst.insert(L);\n\t\t\t\tfor(it = ls.begin(); S > 0 && it != ls.end(); ++it){\n\t\t\t\t\tif(!st.count(it->first)){\n\t\t\t\t\t\tif(S < it->second){\n\t\t\t\t\t\t\tit->second -= S;\n\t\t\t\t\t\t\tls.insert(it, pii(L, S));\n\t\t\t\t\t\t\tS = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tit->first = L;\n\t\t\t\t\t\t\tS -= it->second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(S > 0){\n\t\t\t\t\tls.push_back(pii(L, S));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch == 'D'){\n\t\t\t\tscanf(\"%d\", &L);\n\t\t\t\tst.erase(L);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tscanf(\"%d\", &S);\n\t\t\t\tint sum = 0;\n\t\t\t\tint res = -1;\n\t\t\t\tfor(it = ls.begin(); it != ls.end(); ++it){\n\t\t\t\t\tif(sum + it->second > S){\n\t\t\t\t\t\tif(st.count(it->first)){ res = it->first; }\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsum += it->second;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\", res);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iterator>\nstd::vector<int> vec;\nvoid W(int x,int y){\n    for(int i=0;i<vec.size();++i){\n        if(y>=0)\n            if(vec[i]==-1)vec[i]=x,--y;\n    }\n    while(y>0){\n        if(vec.size()>1000000000)break;\n        vec.push_back(x);\n        --y;\n    }\n}\nvoid D(int x){\n    for(int i=vec.size()-1;i>=0;--i){\n        if(vec[i]==x){\n            if(vec.size()-1==i){\n                std::vector<int>::iterator it=vec.end();\n                vec.erase(it);\n            }else vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vec.size();\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n        }\n        b=false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        typedef tuple<int,int,int> triple;\n        set<triple> intervals;\n        intervals.insert(triple(0,0,-inf));\n        rep(i,0,n){\n            /*\n            for(const auto& interval:intervals){\n                cout << get<0>(interval) << \" \" << get<1>(interval) << \" \" << get<2>(interval) << endl;\n            }\n            */\n            char command;\n            cin >> command;\n            if(command=='W'){\n                int id,len;\n                cin >> id >> len;\n                auto a=intervals.begin();\n                auto b=intervals.begin();\n                ++b;\n                while(len>0){\n                    int l=get<1>(*a);\n                    if(b==intervals.end()){\n                        intervals.insert(triple(l,l+len,id));\n                        break;\n                    }\n                    auto r=get<0>(*b);\n                    if(l==r){\n                        a=b;\n                        ++b;\n                        continue;\n                    }\n                    b=intervals.insert(triple(l,r,id)).first;\n                    a=b;\n                    ++b;\n                    len-=r-l;\n                }\n            }else if(command=='D'){\n                int id;\n                cin >> id;\n                for(auto it=intervals.begin();it!=intervals.end();){\n                    if(get<2>(*it)==id) it=intervals.erase(it);\n                    else ++it;\n                }\n            }else{\n                int index;\n                cin >> index;\n                bool ok=false;\n                for(const auto& interval:intervals) if(get<0>(interval)<=index and index<get<1>(interval)){\n                    cout << get<2>(interval) << endl;\n                    ok=true;\n                    break;\n                }\n                if(!ok) cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef pair<int,int> P;\nvector<P> vec;\n  \nvoid change(int p, int S, int l){\n    vector<P> tmp;\n    int Next = vec[p].second - S;\n  \n    for(int i = 0 ; i < p ; i++){\n\ttmp.push_back(vec[i]);\n    }\n  \n    tmp.push_back(P(l, S));\n    tmp.push_back(P(-1,Next));\n  \n    for(int i = p+1 ; i < vec.size() ; i++){\n\ttmp.push_back(vec[i]);\n    }\n    vec = tmp;\n}\n  \nvoid Wri(){\n    int len = vec.size(), l, S;\n  \n    cin >> l >> S;\n  \n    if(len == 0){\n\tvec.push_back(P(l,S));\n\treturn;\n    }\n  \n    for(int i = 0 ; i < len ; i++){\n\tif(vec[i].first == -1){\n\t    if(S - vec[i].second >= 0){\n\t\tvec[i].first = l;\n\t\tS -= vec[i].second;\n\t    }else{\n\t\tchange(i, S, l);\n\t\treturn;\n\t    }\n\t}\n    }\n  \n    if(S > 0){\n\tvec.push_back(P(l,S));\n    }\n}\n  \nvoid Del(){\n    int len = vec.size(), l;\n  \n    cin >> l;\n    if(len == 0){\n\treturn;\n    }\n  \n    for(int i = 0 ; i < len ; i++){\n\tif(vec[i].first == l){\n\t    vec[i].first = -1;\n\t}\n    }\n}\n  \nint Ref(){\n    long long cnt = 0;\n    int len = vec.size(), l, num = vec[0].first;\n  \n    cin >> l;\n    if(len == 0){\n\treturn -1;\n    }\n  \n    for(int i = 0 ; i < len ; i++){\n\tcnt += vec[i].second;\n\tnum = vec[i].first;\n      \n\tif(cnt > l){\n\t    return num;\n\t}\n    }\n  \n    if(cnt <= l){\n\treturn -1;\n    }else{\n\treturn vec[len-1].first;\n    }\n}\n  \nint main(){\n    int N;\n    char ch;\n  \n    while(cin >> N, N){\n\tvec.clear();\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> ch;\n  \n\t    switch(ch){\n\t    case 'W':\n\t\tWri();\n\t\tbreak;\n\t    case 'D':\n\t\tDel();\n\t\tbreak;\n\t    default:\n\t\tcout << Ref() << endl;\n\t\tbreak;\n\t    }\n\t}\n\tcout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n \nconst long INF = (1l << 30);\nconst long LINF = (1l << 60);\n\ntypedef std::pair<long, long> P;\n\nlong n;\nstd::map<P, long> mp;\nstd::string s;\n\nvoid write(){\n\tlong a, b;\n\tscanf(\"%ld%ld\", &a, &b);\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second == -1){\n\t\t\tlong l = it->first.first;\n\t\t\tlong r = std::min(it->first.second, l + b);\n\t\t\tlong rr = it->first.second;\n\t\t\tif(b > rr - l){\n\t\t\t\tit->second = a;\n\t\t\t\tb -= r - l;\n\t\t\t}else{\n\t\t\t\tmp.erase(it);\n\t\t\t\tmp[P(l, r)] = a;\n\t\t\t\tif(r < rr){\n\t\t\t\t\tmp[P(r, rr)] = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid del(){\n\tlong a;\n\tscanf(\"%ld\", &a);\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second == a){\n\t\t\tit->second = -1;\n\t\t}\n\t}\n}\n\nvoid ref(){\n\tlong a;\n\tscanf(\"%ld\", &a);\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->first.first <= a && a < it->first.second){\n\t\t\tprintf(\"%ld\\n\", it->second);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%ld\", &n);\n\t\tif(n == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tmp.clear();\n\t\tmp[P(0, 1000000009)] = -1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts.clear();\n\t\t\tstd::cin >> s;\n\t\t\tif(s[0] == 'W'){\n\t\t\t\twrite();\n\t\t\t}else if(s[0] == 'D'){\n\t\t\t\tdel();\n\t\t\t}else{\n\t\t\t\tref();\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\t\t\tprintf(\"[%ld, %ld)  %ld\\n\", it->first.first, it->first.second, it->second);\n\t\t\t}\n\t\t\tprintf(\"--------\\n\");\n\t\t\t//*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(list<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.push_front({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.push_back({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.push_front({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert(prev,{prev->l,prev->l+t,id});\n            \n            cnt-=t;\n        }\n        if(cnt<=0) return;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.push_back({it->r,it->r+cnt,id});\n    \n}\ntemplate<class T>\nvoid dump(T range) {\n    for(auto &e : range) {\n        cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n    }\n}\nvoid solve() {\n    list<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                else it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<pair<int,int> ,int> M;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='W'){\n\t\t\t\tint b,c;\n\t\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\t\tfor(map<pair<int,int>,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif(c<=0)break;\n\t\t\t\t\tpair<pair<int,int>,int> dat=*it;\n\t\t\t\t\tif(dat.second==-1){\n\t\t\t\t\t\tif(c>=dat.first.second-dat.first.first){\n\t\t\t\t\t\t\tc-=dat.first.second-dat.first.first;\n\t\t\t\t\t\t\tM[dat.first]=b;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tM[make_pair(dat.first.first,dat.first.first+c)]=b;\n\t\t\t\t\t\t\tM[make_pair(dat.first.first+c,dat.first.second)]=-1;\n\t\t\t\t\t\t\tM.erase(dat.first);\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(c>0){\n\t\t\t\t\tif(M.size()==0)M[make_pair(0,c)]=b;\n\t\t\t\t\telse{\n\t\t\t\t\t\tint p=((*(M.rbegin())).first.second);\n\t\t\t\t\t\tM[make_pair(p,p+c)]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='D'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tfor(map<pair<int,int>,int>::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif((*it).second==b){\n\t\t\t\t\t\tM[(*it).first]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='R'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tbool found=false;\n\t\t\t\tfor(map<pair<int,int> ,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tpair<int,int> q=(*it).first;\n\t\t\t\t\tif(q.first<b&&b<=q.second){\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).second);\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found)printf(\"%d\\n\",-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef int ll;\ntypedef pair<int,int>P;\n#define MX 1000000001\nint N,d1[10005],d2[10005],cnt;\nchar c[10005];\n\nstruct BIT\n{\n\tvector<ll>T;\n\tint n;\n\tBIT( int n):n(n+1),T(n+1,0){}\n\tll _sum( int p){ll res=0;for (;p>0;p-=p&-p)res+=T[p];return res;}\n\tll sum( int r,int l){return _sum(l)-_sum(r);};\n\tvoid add(int i,int x){ for(;i<n;i+=i&-i)T[i]+=x;}\n\tvoid finit(){T.clear();}\n};\n\n\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tvector<P>T;\n\t\tT.push_back(make_pair(-10000,0));\n\t\tmap<int,vector<int> >D;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%c\",&c[i]);\n\t\t\tif(c[i]=='W')scanf(\"%d%d\\n\",&d1[i],&d2[i]);\n\t\t\telse \n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1[i]);\n\t\t\t\tif(c[i]=='R')\n\t\t\t\t\tT.push_back(make_pair(d1[i],-1));\n\t\t\t}\n\t\t}\n\t\tsort(T.begin(),T.end());\n\t\tBIT SEQ(T.size());\n\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(c[i]=='R')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<T.size();j++)\n\t\t\t\t\tif(T[j].first==d1[i])\n\t\t\t\t\t\tprintf(\"%d\\n\",T[j].second);\n\t\t\t}\n\t\t\telse if(c[i]=='D')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<D[d1[i]].size();j++)\n\t\t\t\t\tSEQ.add(j,-D[d1[i]][j]);\n\t\t\t\tfor(int j=0;j<T.size();j++)\n\t\t\t\t\tif(T[i].first==d1[i])\n\t\t\t\t\t\tT[i].first=-1;\n\t\t\t\tD[d1[i]].clear();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[d1[i]].push_back(0);\n\t\t\t\tfor(int j=1,s=d2[i];j<T.size();j++)\n\t\t\t\t{\n\t\t\t\t\tint ins=0,emp=T[j].first-SEQ._sum(j)+1;\n\t\t\t\t\tif(emp>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s>=emp)T[j].second=d1[i];\n\t\t\t\t\t\tins=min(s,emp);\n\t\t\t\t\t\ts-=min(s,emp);\n\t\t\t\t\t}\n\t\t\t\t\tSEQ.add(j,ins);\n\t\t\t\t\tD[d1[i]].push_back(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSEQ.finit();\n\t\tT.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <algorithm>\n#include <set>\n#include <vector>\n\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\n\nstruct range {\n  int beg, ed;\n  int num;\n};\nbool operator<(const range& l, const range& r){\n  return l.beg < r.beg;\n}\n\nint main()\n{\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    list<range> s;\n    REP(i,n){\n      string c;\n      cin>>c;\n      if(c==\"W\"){\n        int l,S;\n        cin >> l >> S;\n        int old = 0;\n        for(auto itr=begin(s);itr!=end(s);++itr){\n          auto r = *itr;\n          if(old < r.beg) {\n            int len = min(r.beg-old, S);\n            s.insert(itr, {old, r.beg, l});\n            S -= len;\n            if (S <= 0) break;\n          }\n          old  = r.ed;\n        }\n        if(S > 0) {\n          s.push_back({old, old + S, l});\n        }\n      } else if (c == \"D\") {\n        int l;\n        cin>>l;\n        auto itr = remove_if(begin(s),end(s),[=](const range& r){return r.num == l;});\n        s.erase(itr, end(s));\n      } else {\n        int p;\n        cin>>p;\n        auto itr = find_if(begin(s),end(s),[=](const range& r){return r.beg <= p && p < r.ed;});\n        if (itr != end(s))\n          cout<<itr->num<<endl;\n        else\n          cout<<-1<<endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<cstdio>\n\nusing namespace std;\n\nstruct Data{\n\tint id,pos,len;\n\tData(){}\n\tData(int I,int P,int L):id(I),pos(P),len(L){}\n};\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tlist<Data> L;\n\t\tlist<Data>::iterator it;\n\t\twhile(n--){\n\t\t\tchar type; scanf(\" %c\",&type);\n\t\t\tif(type=='W'){\n\t\t\t\tint id,len; scanf(\"%d%d\",&id,&len);\n\t\t\t\tint pos=0;\n\t\t\t\tfor(it=L.begin();it!=L.end();++it){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(pos<a.pos){\n\t\t\t\t\t\tint d=min(a.pos-pos,len);\n\t\t\t\t\t\tlen-=d;\n\t\t\t\t\t\tL.insert(it,Data(id,pos,d));\n\t\t\t\t\t}\n\t\t\t\t\tif(len==0) break;\n\t\t\t\t\tpos=a.pos+a.len;\n\t\t\t\t}\n\t\t\t\tif(len>0){\n\t\t\t\t\tL.insert(it,Data(id,pos,len));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(type=='D'){\n\t\t\t\tint id; scanf(\"%d\",&id);\n\t\t\t\tfor(it=L.begin();it!=L.end();){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(id==a.id) it=L.erase(it);\n\t\t\t\t\telse ++it;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint pos; scanf(\"%d\",&pos);\n\t\t\t\tint ans=-1;\n\t\t\t\tfor(it=L.begin();it!=L.end();++it){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(a.pos<=pos && pos<a.pos+a.len){\n\t\t\t\t\t\tans=a.id;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos<a.pos) break;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int,int>\nusing namespace std;\nint main(){\n    int n;\n    while(cin >> n,n){\n        vector<pii> v;\n        v.emplace_back(make_pair(-1,1000000000));\n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;cin >> i >> s;\n                for(auto it=v.begin();it!=v.end();it++){\n                    if(it->first == -1){\n                        if(s <= it->second){\n                        \tit->second -= s;\n                            v.insert(it,make_pair(i,s));\n                            break;\n                        } else {\n                            it->first=i;\n                            s -= it->second;\n                        }\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;cin >> i;\n                for(auto it=v.begin();it!=v.end();it++){\n                    if(it->first == i) it->first = -1;\n                }\n            }\n            if(c == 'R'){\n                int p;cin >> p;\n                int i=0;\n                auto it=v.begin();\n                for(;it!=v.end();it++){\n                    i += it->second;\n                    if(p < i){\n                        cout << it->first << endl;\n                        break;\n                    }\n                }\n                if(it == v.end()) cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lidl,ridl;\n\tint idl;\n\tint l,r;\n\tdata(){}\n\tdata(int iidl,int ll,int rr,int lll,int rrr){\n\t\tidl=iidl;\n\t\tlidl=ll;\n\t\tridl=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> idl;\nvector<int> idldata;\nvector<int> placee[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tidl.clear();\n\t\tidldata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(idl.find(l)==idl.end()){\n\t\t\t\t\tidl[l]=idldata.size();\n\t\t\t\t\tidldata.push_back(l);\n\t\t\t\t\tplacee[idl[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(idl[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lidl=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lidl].r){\n\t\t\t\t\t\t\tdat.push_back(data(idl[l],dat[nv].lidl,nv,dat[dat[nv].lidl].r,dat[dat[nv].lidl].r+min(s,dat[nv].l-dat[dat[nv].lidl].r)));\n\t\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lidl].r);\n\t\t\t\t\t\t\tdat[dat[nv].lidl].ridl=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lidl=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].ridl=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(idl.find(l)==idl.end())continue;\n\t\t\t\tfor(int i=0;i<placee[idl[l]].size();i++){\n\t\t\t\t\tdata d=dat[placee[idl[l]][i]];\n\t\t\t\t\tif(d.lidl==-1)st=d.ridl;\n\t\t\t\t\tif(d.ridl==-1)en=d.lidl;\n\t\t\t\t\tdat[d.ridl].lidl=d.lidl;\n\t\t\t\t\tdat[d.lidl].ridl=d.ridl;\n\t\t\t\t}\n\t\t\t\tplacee[idl[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?idldata[dat[nv].idl]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].ridl){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].idl,dat[i].lidl,dat[i].ridl,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\" \\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T,n,k,c,d,C;scanf(\"%d\",&T),T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tfor(;T--&&scanf(\"%s%d\",&C,&n);){\n\t\tif(C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else ++it;\n\t\t}else if(C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n?-1:it->second);\n\t\t}else if(C=='W'){\n\t\t\tc=!scanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tvector<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v[0].p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min(v[0].p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= v[0].p.second + 1;\n\t\t\t\t}\n\t\t\t\trep(i, v.size() - 1) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tif (v[i].p.second + 1 < v[i + 1].p.first) {\n\t\t\t\t\t\tv.insert(v.begin() + i + 1, { P(v[i].p.second + 1, min(v[i + 1].p.second - 1, v[i].p.first + b - 1)),a });\n\t\t\t\t\t\tb -= v[i + 1].p.second - v[i + 1].p.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P(v[v.size() - 1].p.second + 1, b + v[v.size() - 1].p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\trep(i, v.size()) {\n\t\t\t\t\tif (v[i].p.first == a) {\n\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < v.size() && v[i].p.second < a; i++);\n\t\t\t\tif (i == v.size())puts(\"-1\");\n\t\t\t\telse if (v[i].p.first <= a&&a <= v[i].p.second)printf(\"%d\\n\", v[i].id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000010\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint n;\nvector<PP> v;\n\nvoid solve(){\n\tv.clear();\n\trep(i,n){\n\t\tchar x; cin >> x;\n\t\tif(x == 'D'){\n\t\t\tint l; cin >> l;\n\t\t\trep(j,v.size()) if(v[j].second == l){\n\t\t\t\tv[j].first.first = INF;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\twhile(true){\n\t\t\t\tif(v.size() == 0) break;\n\t\t\t\tif(v[v.size()-1].first.first != INF) break;\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t} else if(x == 'R'){\n\t\t\tint p; cin >> p;\n\t\t\tbool ok = false;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first <= p && p <= v[j].first.second){\n\t\t\t\t\tcout << v[j].second << endl;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) puts(\"-1\");\n\t\t} else{\n\t\t\tint l, s; cin >> s >> l;\n\t\t\tint st = 0;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first > st){\n\t\t\t\t\tif(l <= v[j].first.first-st){\n\t\t\t\t\t\tv.push_back(PP(P(st,st+l-1),s));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tv.push_back(PP(P(st,v[j].first.first-1),s));\n\t\t\t\t\t\tl -= v[j].first.first-st;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tst = v[j].first.second+1;\n\t\t\t\tif(st > INF){\n\t\t\t\t\tl = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l > 0) v.push_back(PP(P(st,st+l-1),s));\n\t\t\tsort(v.begin(),v.end());\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nstruct DATA{\n\tint start;\n\tint end;\n\tint fileID;\n\tDATA(int start, int end, int fileID){\n\t\tthis->start = start, this->end = end, this->fileID = fileID;\n\t}\n};\n\nvector<DATA> data;\n\nvoid Write(int fileID, int file_length)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(file_length <= data[i].end - data[i].start + 1){\n\t\t\t\tdata.insert(data.begin() + i, DATA(data[i].start, data[i].start + file_length - 1, fileID));\n\t\t\t\tdata[i+1].start = data[i+1].start + file_length;\n\t\t\t}else{\n\t\t\t\tdata[i].fileID = fileID;\n\t\t\t\tfile_length -= data[i].end - data[i].start + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Arrange()\n{\n\tfor(int i = 0; i < (int)data.size()-1; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(data[i+1].fileID == -1){\n\t\t\t\tdata[i].end = data[i+1].end;\n\t\t\t\tdata.erase(data.begin() + (i+1));\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Delete(int fileID)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == fileID) data[i].fileID = -1;\n\t}\n\tArrange();\n}\n\nvoid Reference(int pos)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].end >= pos){\n\t\t\tprintf(\"%d\\n\", data[i].fileID);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint N;\n\tchar com[5];\n\tint op1, op2;\n\t\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdata.push_back( DATA(0, 1000000001, -1) );\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\t\n\t\t\tscanf(\"%s\", com);\n\t\t\tif(strcmp(com, \"W\") == 0){\n\t\t\t\tscanf(\"%d %d\", &op1, &op2);\n\t\t\t\tWrite(op1, op2);\n\t\t\t}else if(strcmp(com, \"D\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tDelete(op1);\n\t\t\t}else if(strcmp(com, \"R\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tReference(op1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nlist<pair<int, int> > L;\n\nvoid Write(){\n\n    int l, s; cin >> l >> s;\n    for(auto itr = L.begin();;itr++){\n        if(itr->first != -1) continue;\n\n        if(itr->second <= s){\n            itr->first = l;\n            s -= itr->second;\n            if(s == 0) return;\n        }else{\n            itr->second -= s;\n            itr = L.insert(itr, {l, s});\n            return;\n        }\n    }\n\n}\n\nvoid Read(){\n    int p; cin >> p;\n    p++;\n    for(auto itr : L){\n        p -= itr.second;\n        if(p <= 0){\n            cout << itr.first << endl;\n            break;\n        }\n    }\n\n\n\n}\n\nvoid Delete(){\n\n    int l; cin >> l;\n    for(auto &itr : L){\n        if(itr.first == l){\n            itr.first = -1;\n        }\n    }\n\n}\n\n\nsigned main(){\n\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        L.clear();\n        L.push_back({-1, 10000000000});\n\n        for(int i = 0; i < n; i++){\n            char op; cin >> op;\n            if(op == 'W') Write();\n            else if(op == 'R') Read();\n            else Delete();\n                \n            //for(auto x : L) cerr << \"(\" << x.first << \", \" << x.second << \") \";\n            //cerr << endl;\n\n\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<functional>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nvector<pair<int, int>> vp; // identifier, size\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvp.clear();\n\t\tvp.push_back(make_pair(-1, 1000000001));\n\n\t\tchar com;\n\t\tREP(i, 0, N) {\n\t\t\tcin >> com;\n\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s;\n\t\t\t\tcin >> l >> s;\n\n\t\t\t\tfor (auto itr = vp.begin(); itr != vp.end(); itr++){\n\t\t\t\t\tif (itr->first == -1) {\n\t\t\t\t\t\tif (itr->second >= s) {\n\t\t\t\t\t\t\titr->second -= s;\n\t\t\t\t\t\t\tvp.insert(itr, make_pair(l, s));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\titr->first = l;\n\t\t\t\t\t\t\ts -= itr->second;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\n\t\t\t\tfor (auto itr = vp.begin(); itr != vp.end(); itr++){\n\t\t\t\t\tif (itr->first == l) itr->first = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\n\t\t\t\tfor (auto itr = vp.begin(); itr != vp.end(); itr++) {\n\t\t\t\t\tif (itr->second > p) {\n\t\t\t\t\t\tcout << itr->first << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp -= itr->second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nstruct Data {\n    int id, l, r;\n    Data *pre;\n    Data *nxt;\n    Data(int id, int l, int r) : id(id), l(l), r(r), pre(NULL), nxt(NULL) {}\n};\nvoid show(Data *fir) {\n    Data *now = fir;\n    while (now != NULL) {\n        cout << now->id << \" \" << now->l << \" \" << now->r << endl;\n        now = now->nxt;\n    }\n}\nbool solve() {\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    Data fir(-1, 0, 0), las(-1, 1e18, 1e18);\n    fir.nxt = &las;\n    las.pre = &fir;\n    // vector<Data> v;\n    // v.emplace_back(-1, 0, 0);\n    // v.emplace_back(-1, (int)1e18, (int)1e18);\n\n    REP(_, N) {\n        // show(&fir);\n        char sign;\n        cin >> sign;\n        if (sign == 'W') {\n            int id, siz;\n            cin >> id >> siz;\n            Data *now = &fir;\n            while (now->nxt != NULL) {\n                int d = now->nxt->l - now->r;\n                if (d > 0) {\n                    if (d >= siz) {\n                        Data *tmp;\n                        tmp = new Data(id, now->r, (now->r) + siz);\n                        // Data tmp(id, now->r, (now->r) + siz);\n                        tmp->nxt = now->nxt;\n                        tmp->pre = now;\n                        now->nxt->pre = tmp;\n                        now->nxt = tmp;\n                        break;\n                    } else {\n                        Data *tmp;\n                        tmp = new Data(id, now->r, (now->r) + d);\n                        tmp->nxt = now->nxt;\n                        tmp->pre = now;\n                        now->nxt->pre = tmp;\n                        now->nxt = tmp;\n                        siz -= d;\n                    }\n                }\n                now = now->nxt;\n            }\n        } else if (sign == 'D') {\n            Data *now = &fir;\n            int id;\n            cin >> id;\n            while (now->nxt != NULL) {\n                // cout << now->id << endl;\n                if (now->id == id) {\n                    now->nxt->pre = now->pre;\n                    now->pre->nxt = now->nxt;\n                }\n                now = now->nxt;\n            }\n        } else if (sign == 'R') {\n            int pos;\n            cin >> pos;\n            Data *now = &fir;\n            bool found = false;\n            while (now != NULL) {\n                // cout << now->id << \" \" << now->l << \" \" << now->r << endl;\n                if (now->l <= pos && now->r > pos) {\n                    found = true;\n                    cout << now->id << endl;\n                    break;\n                }\n                now = now->nxt;\n            }\n            if (!found) cout << -1 << endl;\n        }\n    }\n    cout << endl;\n    return true;\n}\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nstruct data{\n\tdata(int a,int b){\n\t\tlength=a;\n\t\tid=b;\n\t}\n\tint length;\n\tint id;\n};\n\nvector<data> sys;\n\nvoid write(int id,int len){\n\tif(sys.size()==0){\n\t\tsys.push_back(data(len,id));\n\t}else{\n\t\tint n=sys.size();\n\t\trep(i,n){\n\t\t\tif(len<=0) return;\n\t\t\tif(sys.size()-1 == i && sys[i].id != -1){//????????????????´???????????????§????????¨??????????????????????????????\n\t\t\t\tsys.push_back(data(len,id));\t\n\t\t\t}else if(sys[i].id==-1){\n\t\t\t\tif(len-sys[i].length==0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}else if(len-sys[i].length<0){ //length???????????§??????\n\t\t\t\t\tsys.insert(sys.begin()+i+1,data(sys[i].length-len,-1));\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tsys[i].length=len;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(len-sys[i].length>0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid read(int id){\n\tint len=0;\n\t/*rep(i,sys.size()){\n\t\tcout << sys[i].id << \":\" << sys[i].length << \" \";\n\t}\n\tcout << endl;\n*/\n\trep(i,sys.size()){\n\t\tlen+=sys[i].length;\n\t\tif(len>id){\n\t\t\tcout << sys[i].id << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nvoid del(int id){\n\trep(i,sys.size()){\n\t\tif(sys[i].id==id){\n\t\t\tsys[i].id=-1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tsys.clear();\n\t\t\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tint I,S;\n\t\t\tcin >> c;\n\t\t\n\t\t\t\n//\t\t\tcout << c << endl;\n\t\t\tif(c=='D'){\n\t\t\t\tcin >> I;\n\t\t\t\tdel(I);\n\t\t\t}else if(c=='W'){\n\t\t\t\tcin >> I >> S;\n\t\t\t\twrite(I,S);\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin >> I;\n\t\t\t\tread(I);\n\t\t\t}\t\t\n\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//:55-40 tle\n#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n      cout << \"d\";\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  files[make_pair(h,e-1)]=I;\n\t  S-=e-h;\n\t}else{\n\t  files[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tif(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\nstruct data {\n    int l, r, id;\n    bool operator<(data const& other) const {\n        return l < other.l;\n    }\n};\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<data> v = {data{-1, -1, -1}};\n        for(int i=0; i<N; ++i) {\n            char c;\n            cin >> c;\n            if(c == 'W') {\n                int l, S;\n                cin >> l >> S;\n                vector<data> app;\n                for(int j=0; j<v.size()-1; ++j) {\n                    int w = v[j+1].l - v[j].r - 1;\n                    if(w > 0) {\n                        app.push_back(data{v[j].r+1, v[j].r+min(w, S), l});\n                        S -= min(w, S);\n                        if(S == 0) {\n                            break;\n                        }\n                    }\n                }\n                if(S > 0) {\n                    app.push_back(data{v[v.size()-1].r+1, v[v.size()-1].r+S, l});\n                }\n                v.insert(v.end(), app.begin(), app.end());\n                sort(v.begin(), v.end());\n            } else if(c == 'D') {\n                int l;\n                cin >> l;\n                v.erase(remove_if(v.begin(), v.end(), [l](data const& d) {\n                    return d.id == l;\n                }), v.end());\n            } else if(c == 'R') {\n                int P;\n                cin >> P;\n                bool f = true;\n                for(int j=0; j<v.size(); ++j) {\n                    if(v[j].l <= P && P <= v[j].r) {\n                        cout << v[j].id << endl;\n                        f = false;\n                    }\n                }\n                if(f) {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n; vector<tuple<int, int, int>>vec;\nvector<int>res;\nvoid Write(int a, int b) {\n\tint L = -1;\n\tint R = vec.size();\n\tfor (int i = L; i < R; i++) {\n\t\tif (b == 0)continue;\n\t\tint SL = 0; if (i >= 0)SL = get<1>(vec[i]) + 1;\n\t\tint SR = 199999999; if (i < R - 1)SR = get<0>(vec[i + 1]) - 1;\n\t\tint SZ = SR - SL + 1;\n\t\tif (SZ >= 1) {\n\t\t\tif (b < SZ) { vec.push_back(make_tuple(SL, SL + b - 1, a)); b = 0; }\n\t\t\telse { vec.push_back(make_tuple(SL, SR, a)); b -= SZ; }\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\treturn;\n}\nvoid Delete(int a) {\n\tvector<tuple<int, int, int>>vec2;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<2>(vec[i]) != a)vec2.push_back(vec[i]);\n\t}\n\tvec = vec2;\n\treturn;\n}\nint Read(int a) {\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<0>(vec[i]) <= a && a <= get<1>(vec[i])) {\n\t\t\treturn get<2>(vec[i]);\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; vec.clear(); res.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'W') { int l, s; cin >> l >> s; Write(l, s); }\n\t\t\tif (p == 'D') { int l; cin >> l; Delete(l); }\n\t\t\tif (p == 'R') { int l; cin >> l; res.push_back(Read(l)); }\n\t\t}\n\t\tfor (int i = 0; i < res.size(); i++)cout << res[i] << endl;\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20000];\nsegment *head, *blank;\n\nsegment* newseg(){\n    blank->next=NULL;\n    blank->file=NULL;\n    blank->id=-1;\n    blank->head=-1;\n    blank->length=-1;\n    return blank++;\n}\n\nvoid W(int I, int S){\n    segment *p=head, *last;\n    while(S){\n        while(p->id!=-1) p=p->next;\n        if(p->length>S){\n            p->id=I;\n            segment *b=newseg();\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n            p=p->next;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head,*next;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        next=p->file;\n        p->file=NULL;\n        p=next;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20000;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll n;\n\n    while (cin >> n, n) {\n\n        vector<tuple<ll, ll, ll>> files; // (l, r, i) means [l, r) is a part of the file i\n        \n        REP(i, n) {\n\n            char cmd; cin >> cmd;\n\n            if (cmd == 'R') {\n\n                ll p; cin >> p;\n                bool found = false;\n                for (auto &f : files) {\n                    if (get<0>(f) <= p && p < get<1>(f)) {\n                        cout << get<2>(f) << endl;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) cout << \"-1\" << endl;\n\n            } else if (cmd == 'D') {\n\n                ll i; cin >> i;\n                files.erase(remove_if(ALL_OF(files), [&i](auto f) -> bool { return get<2>(f) == i; }), files.end());\n\n            } else if (cmd == 'W') {\n\n                ll i, s; cin >> i >> s;\n\n                if (!files.empty()) {\n                    if (get<0>(files.front()) > 0) {\n                        ll gap = min(get<0>(files.front()), s);\n                        s -= gap;\n                        files.insert(files.begin(), {0, gap, i});\n                    }\n                    if (s >= 0) REP(j, files.size() - 1) {\n                        ll gap = get<0>(files[j+1]) - get<1>(files[j]);\n                        if (gap > 0) {\n                            chmin(gap, s);\n                            s -= gap;\n                            ll bk = get<1>(files[i]);\n                            files.emplace_back(bk, bk + gap, i);\n                            if (s <= 0) break;\n                        }\n                    }\n                }\n\n                if (s > 0) {\n                    ll bk = files.empty() ? 0 : get<1>(files.back());\n                    files.emplace_back(bk, bk + s, i);\n                }\n\n                sort(ALL_OF(files));\n\n            }\n\n        }\n\n        cout << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t2152: Restrictive Filesystem\n*/\n#include\t<iostream>\n#include\t<queue>\n#include\t<utility>\n#include\t<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P_ii;\n\nclass datlst {\nprivate:\n\tpriority_queue<P_ii> lst;\npublic:\n\tvoid push_file(int, int);\n\tvoid erase_file(int);\n};\n\nvoid datlst::push_file(int ident, int count) {\n\tfor (int i = 0; i < count; i++) {\n\t\tif (lst.empty()) {\n\t\t\tlst.push(P_ii(0, ident));\n\t\t}\n\t\tpriority_queue<P_ii>::iterator it = lst.begin();\n\t}\n}\n\nint main(void) {\n\tint\t\tN, f, s;\n\tchar\tc;\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (N == 0) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> c;\n\t\t\tswitch (c) {\n\t\t\tcase 'W':\n\t\t\t\tcin >> f >> s;\n\t\t\t\tfor (int j = 0; j < s; j++) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n  \nint N;\nvector<Data> storage;\n \nvoid dump() {\n#ifdef DEBUG\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n  cout << \"storage[\"<<i<<\"]:\" << endl;\n  cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n}\n  cout << \"-----------------------------\" << endl;\n#endif\n}\n \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      /*\n        if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n        }\n        else { st = 0; }\n      */\n      num = remain;\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n\nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  \n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n  \n#ifdef DEBUG\n  cout << \"Deleted: \" << id << endl;\n  dump();\n#endif\n  \n}\n\nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n  \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst int INF = 1 << 28;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        PQ que;\n        que.push(P(0,INF));\n        map<P,int> m;\n        while (n--) {\n            char c;\n            cin >> c;\n            if (c == 'W') {\n                int t, l;\n                cin >> t >> l;\n                P p;\n                while (true) {\n                    p = que.top(); que.pop();\n                    int s = p.first, g = p.second;\n                    if (s + l - 1 <= g) {\n                        if (s + l - 1 < g)\n                            que.push(P(s + l, g));\n                        m[P(s, s + l - 1)] = t;\n                        break;\n                    } else {\n                        m[P(s, g)] = t;\n                        l -= g - s + 1;\n                    }\n                }\n            } else if (c == 'D') {\n                int t; cin >> t;\n                for (auto i : m) {\n                    if (i.second == t) {\n                        que.push(i.first);\n                        m.erase(m.find(i.first));\n                    }\n                }\n            } else {\n                int x; cin >> x;\n                bool flag = true;\n                for (auto i : m) {\n                    if (i.first.first <= x && x <= i.first.second) {\n                        cout << i.second << endl;\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag)\n                    cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\nstruct Data {\n    ll start,end,id;\n    Data* next;\n    Data *prev;\n    Data(ll s,ll e,ll i) : start(s), end(e), id(i) {;}\n};\n\nvoid insert(int id,ll size,Data *d) {\n    //cout<<id<<\",,\"<<(d->start)<<\",\"<<(d->end)<<\" :: \"<<(d->id)<<endl;\n    if(size == 0) return;\n    if(d->id != -1) {\n        insert(id,size,d->next);\n        return;\n    }\n    ll use = min(size, (d->end) - (d->start) + 1);\n    if(use == size) {\n        ll remain = (d->end)-(d->start)+1 - size;\n        if(remain == 0) d->id = id;\n        else{\n            Data* nd = new Data(d->start,d->start+size-1,id);\n            if(d->prev == d) nd->prev = nd;\n            else {\n                d->prev->next = nd;\n                nd->prev = d->prev;\n            }\n            nd->next = d;\n            d->prev = nd;\n            d->start = nd->start+size;\n        }\n    }else{\n        ll remain = size - ((d->end)-(d->start)+1);\n        d->id = id;\n        insert(id,remain,d->next);\n    }\n}\n\nint lookup(Data *n,ll p) {\n    if(n == NULL) return -1;\n    //cout<<\"lookup \"<<(n->start)<<\" , \"<<(n->end)<<\" : \"<<n->id<<endl;\n    if(n->start <= p && n->end >= p) return n->id;\n    lookup(n->next,p);\n}\n\nvoid remove(ll id,Data *n) {\n    if(n == NULL) return;\n    if((n->id) != id) {\n        remove(id,n->next);\n        return;\n    }\n    //cout<<\"rem \"<<(n->id)<<\" \"<<id<<endl;\n    n->id = -1;\n    if(n->prev != n && n->prev->id == -1) {\n        n->prev->next = n->next;\n        n->prev->end = n->end;\n        Data *ne = n->next;\n        delete n;\n        remove(id,ne);\n    }\n}\n\nint main() {\n    int n;\n    string op;\n    while(cin>>n, n) {\n        Data root(0, 1ll<<60, -1);\n        Data *rp = &root;\n        root.prev = &root;\n        root.next = NULL;\n\n        int id,size;\n        for(int i=0; i<n; ++i) {\n            cin>>op;\n            if(op == \"W\") {\n                cin>>id>>size;\n                insert(id,size,rp);\n                while(rp->prev != rp)\n                    rp = rp->prev;\n            }else if(op == \"D\") {\n                cin>>id;\n                remove(id,rp);\n            }else if(op == \"R\") {\n                cin>>size;\n                cout<<lookup(rp,size)<<endl;\n            }\n        }\n        cout<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 問題名: The Number of Inversions\n// URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_5_D&lang=jp\n// 所要時間: 20分\n// --感想--\n// 転倒数の計算は平衡二分木やセグメント木を使った実装しかしたことがなかったため、マージソートを用いた実装が\n// 経験できて勉強になった。\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0)\n            break;\n        char c;\n        set<pair<pair<int, int>, int>> secs; // <<始点, 長さ>, 識別子>\n        secs.insert(make_pair(make_pair(0, 2e9), -1));\n        for (int i = 0; i < n; i++){\n            cin >> c;\n            if(c=='W'){\n                int l, s;\n                cin >> l >> s;\n                for (auto itr = secs.begin(); itr!=secs.end(); itr++){\n                    auto sec = *itr;\n                    int st = sec.first.first, le = sec.first.second, nu = sec.second;\n                    if(nu==-1){\n                        if (s < le){ // 現在見ている区間に収まる\n                            secs.erase(sec);\n                            secs.insert(make_pair(make_pair(st, s), l));\n                            itr = secs.insert(make_pair(make_pair(st + s, le - s), nu)).first;\n                            s = 0;\n                        }\n                        else{ // 収まらない\n                            secs.erase(sec);\n                            itr = secs.insert(make_pair(make_pair(st, le), l)).first;\n                            s -= le;\n                        }\n                    }\n                    if(s==0)\n                        break;\n                }\n            }\n            else if(c=='D'){\n                int l;\n                cin >> l;\n                for (auto itr = secs.begin(); itr != secs.end(); itr++){\n                    auto sec = *itr;\n                    int st = sec.first.first, le = sec.first.second, nu = sec.second;\n                    if(nu==l){\n                        secs.erase(sec);\n                        itr = secs.insert(make_pair(make_pair(st, le), -1)).first;\n                    }\n                }\n            }\n            else{\n                int p;\n                cin >> p;\n                int ans;\n                for (auto itr = secs.begin(); itr != secs.end(); itr++){\n                    auto sec = *itr;\n                    if (sec.first.first <= p)\n                        ans = sec.second;\n                    else\n                        break;\n                }\n                cout << ans << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\n\nstruct Point {\n\tint first;\n\tint len;\n\tint sikibetu_id;\n};\nvector<Point> sys;\n\nint read_sys(int real_i) {\n\trep(i,sys.size()) {\n\t\tint first = sys[i].first;\n\t\tint last = first + sys[i].len;\n\t\t/*\n\t\tdump(first);\n\t\tdump(last);\n\t\tdump(real_i);\n\t\t*/\n\t\tif (first <= real_i && real_i < last) {\n\t\t\treturn sys[i].sikibetu_id;\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid delete_sys(int siki) {\n\trep(i,sys.size()) {\n\t\tif (sys[i].sikibetu_id == siki) {\n\t\t\tsys.erase(sys.begin() + i); //i???????´??????????\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid write_sys(int siki, int len) {\n\tint tune_index = 0;\n\n\trep(i,sys.size()) {\n\t\tif (tune_index != sys[i].first) {\n\t\t\t//tune_index <= hoge <= sys[i].first??????????????£???\n\t\t\tint between = (sys[i].first - tune_index);\n\n\t\t\tif (len == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (between > len) {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=len;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen=0; //0\n\t\t\t\t/*\n\t\t\t\tdump(len);\n\t\t\t\tdump(sys[i].first);\n\t\t\t\tdump(tune_index);\n\t\t\t\tdump(between);\n\t\t\t\t*/\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=between;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen-=between;\n\t\t\t}\n\t\t}\n\t\ttune_index += sys[i].len;\n\t}\n\n\tif (len > 0) {\n\t\tPoint p;\n\t\tp.first=tune_index;\n\t\tp.len=len;\n\t\tp.sikibetu_id=siki;\n\t\tsys.push_back(p);\n\t}\n\n}\n\nvoid show() {\n\tdump(\"-------\");\n\trep(i,sys.size()) {\n\t\tdump(sys[i].first);\n\t\tdump(sys[i].len);\n\t\tdump(sys[i].sikibetu_id);\n\t}\n}\n\nint main() {\n\tint N;\n\tchar command;\n\tint arg1,arg2;\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tsys.clear();\n\t\trep(i,N) {\n\t\t\tcin >> command;\n\n\t\t\tif (command == 'R') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tcout << read_sys(arg1) << endl;\n\t\t\t}\n\t\t\telse if (command == 'D') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tdelete_sys(arg1);\n\t\t\t}\n\t\t\telse if (command == 'W') {\n\t\t\t\tcin >> arg1 >> arg2;\n\t\t\t\tcout << command << \" \" << arg1 << \" \" << arg2 << endl;\n\t\t\t\twrite_sys(arg1,arg2);\n\t\t\t}\n\t\t\t//show();\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000010;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nifstream ifs(\"2152_input.txt\");\nofstream ofs(\"op.txt\");\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w; bool accessed = false;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            accessed = true;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            auto it = disk.begin();\n            while(it != disk.end()){\n                if(it->second == t) disk.erase(it++);\n                else it++;\n            }\n        }else{\n            auto lb = disk.upper_bound(pint(t, INF));\n            if(lb != disk.begin()) lb--;\n            pint temp = lb->first;\n            cout << temp.first << ' ' << temp.second << endl;\n            if(temp.first <= t && t < temp.second && accessed)\n              cout << lb->second << endl;\n            else\n              cout << \"-1\" << endl;\n        }\n        \n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<cstring>\n#include<map>\n \nusing namespace std;\n \n\nint main(void)\n{\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t//????????????,?????\\\n\t\tmap<int,int> sec;\n\t\t\n\t\t//-1(???)???0???????§???????\n\t\tsec[0]=-1;\n\t\tsec[1000000000]=-1;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\t\n\t\t\tif(s==\"W\"){\n\t\t\t\tint a,len;\n\t\t\t\tcin>>a>>len;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second==-1){\n\t\t\t\t\t\tit->second=a;\n\t\t\t\t\t\tauto it2=it;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2->first - it->first >= len){\n\t\t\t\t\t\t\tif(it2->first - it->first == len) break;\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tsec[it->first+len]=-1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse len-=(it2)->first - it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(s==\"D\"){\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second == a) it->second=-1;\n\t\t\t\t}\n\t\t\t}else if(s==\"R\"){\n\t\t\t\t/*\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tcout<<\"map[\"<<it->first<<\"]=\"<<it->second<<endl;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\tit2++;\n\t\t\t\t\tif(it->first<=a && a<=it2->first){\n\t\t\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tvector<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v[0].p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min(v[0].p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= v[0].p.second + 1;\n\t\t\t\t}\n\t\t\t\trep(i, v.size() - 1) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tif (v[i].p.second + 1 < v[i + 1].p.first) {\n\t\t\t\t\t\tv.insert(v.begin() + i + 1, { P(v[i].p.second + 1, min(v[i + 1].p.second - 1, v[i].p.first + b - 1)),a });\n\t\t\t\t\t\tb -= v[i + 1].p.second - v[i + 1].p.first + 1;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P(v[v.size() - 1].p.second + 1, b + v[v.size() - 1].p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\trep(i, v.size()) {\n\t\t\t\t\tif (v[i].id == a) {\n\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < v.size() && v[i].p.second < a; i++);\n\t\t\t\tif (i == v.size())puts(\"-1\");\n\t\t\t\telse if (v[i].p.first <= a&&a <= v[i].p.second)printf(\"%d\\n\", v[i].id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass writeInfo{\npublic:\n\tint from;\n\tint to;\n\tint discripter;\n};\n\nint main(){\n\tint N;\n\tbool fst=false;\n\twhile(cin>>N&&N!=0){\n\t\tvector<writeInfo> info;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tchar order;\n\t\t\tcin>>order;\n\t\t\tif(order=='W'){\n\t\t\t\tint discripter;\n\t\t\t\tint leftWritingSize=0;\n\t\t\t\tint finTo=0;\n\t\t\t\tcin>>discripter>>leftWritingSize;\n\t\t\t\tint prvPlace=0;\n\t\t\t\tfor(int j = 0; j < info.size(); j++){\n\t\t\t\t\tif(leftWritingSize==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// àµó«Xy[Xª³©Á½ç\n\t\t\t\t\tif(prvPlace==info[j].from){\n\t\t\t\t\t\tprvPlace=info[j].to+1;\n\t\t\t\t\t\tfinTo=info[j].to+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// ó«Xy[Xª Á½êA«ßé¾¯«Þ\n\t\t\t\t\telse{\n\t\t\t\t\t\tint to=min(leftWritingSize,info[j].from-prvPlace);\n\t\t\t\t\t\tleftWritingSize-=to;\n\t\t\t\t\t\twriteInfo wi;\n\t\t\t\t\t\twi.discripter=discripter;\n\t\t\t\t\t\twi.from=prvPlace;\n\t\t\t\t\t\twi.to=prvPlace+to-1;\n\t\t\t\t\t\t//info.push_back(wi);\n\t\t\t\t\t\tinfo.insert(info.begin()+j,wi);\n\t\t\t\t\t\tif(leftWritingSize==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfinTo=info[j].to+1;\n\t\t\t\t\t\tprvPlace=info[j].to+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftWritingSize>0){\n\t\t\t\t\twriteInfo wi;\n\t\t\t\t\twi.discripter=discripter;\n\t\t\t\t\twi.from=finTo;\n\t\t\t\t\twi.to=finTo+leftWritingSize-1;\n\t\t\t\t\tinfo.push_back(wi);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(order=='R'){\n\t\t\t\tint secter;\n\t\t\t\tcin>>secter;\n\t\t\t\tbool isFind=false;\n\t\t\t\t// from-toÌÔÉsecterª é©²×é\n\t\t\t\tfor(int j = 0; j < info.size(); j++){\n\t\t\t\t\tif(info[j].from<=secter&&info[j].to>=secter){\n\t\t\t\t\t\tcout<<info[j].discripter<<endl;\n\t\t\t\t\t\tisFind=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!isFind)\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t}\n\t\t\telse if(order=='D'){\n\t\t\t\tint discrepter;\n\t\t\t\tcin>>discrepter;\n\t\t\t\t// fBXNv^ªêv·éàÌð·×Äí\n\t\t\t\tfor(int j = info.size()-1; j>=0; j--){\n\t\t\t\t\tif(info[j].discripter==discrepter){\n\t\t\t\t\t\tinfo.erase(info.begin()+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll inf =1LL << 62;\n\nint main(void){\n\tint n;\n\twhile ( cin >> n,n){\n\t\tdeque <pii> memory; //識別子　セクタ\n\t\trep(i,n){\n\t\t\tchar com;\n\t\t\tcin >> com;\n\t\t\tif(com=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\tint mn=memory.size();\n\t\t\t\tif(mn){\n\t\t\t\t\trep(j,mn){\n\t\t\t\t\t\tif(memory[j].first==-1){\n\t\t\t\t\t\t\tif(s>memory[j].second){\n\t\t\t\t\t\t\t\tmemory[j].first=l;\n\t\t\t\t\t\t\t\ts-=memory[j].second;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tmemory[j].second-=s;\n\t\t\t\t\t\t\t\tpii tmp;\n\t\t\t\t\t\t\t\ttmp.first=l;tmp.second=s;\n\t\t\t\t\t\t\t\tmemory.insert(memory.begin()+j-1,tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s){\n\t\t\t\t\t\t\tpii tmp;\n\t\t\t\t\t\t\ttmp.first=l;tmp.second=s;\n\t\t\t\t\t\t\tmemory.push_back(tmp);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tpii tmp;\n\t\t\t\t\ttmp.first=l;tmp.second=s;\n\t\t\t\t\tmemory.push_back(tmp);\n\t\t\t\t}\n\t\t\t}else if(com=='D'){\n\t\t\t\tint mn=memory.size();\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\trep(j,mn)\n\t\t\t\t\tif(memory[j].first==l)\n\t\t\t\t\t\tmemory[j].first=-1;\n\t\t\t}else{\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\t\t\t\tint mn=memory.size();\n\t\t\t\tint cur=0;\n\t\t\t\tbool out=false;\n\t\t\t\tif(mn){\n\t\t\t\t\trep(j,mn){\n\t\t\t\t\t\tcur+=memory[j].second;\n\t\t\t\t\t\tif(cur>p){\n\t\t\t\t\t\t\tout=true;\n\t\t\t\t\t\t\tcout << memory[j].first << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!out)\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct Data{\n\tchar com;\n\tint idx;\n\tint len;\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<Data> d(n);\n\t\tvector<int> r;\n\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\n\t\t\tint a, b = -1;\n\t\t\tif(c == 'W'){\n\t\t\t\tcin >> a >> b;\n\t\t\t}else{\n\t\t\t\tcin >> a;\n\t\t\t}\n\n\t\t\td[i] = Data{c,a,b};\n\t\t\tif(c == 'R') r.emplace_back(i);\n\t\t}\n\n\t\trep(i,r.size()){\n\t\t\tint cnt = 0;\n\t\t\tint p = -1;\n\t\t\tint idx = d[r[i]].idx + 1;\n\t\t\tmap<int,int> ma;\n\t\t\trep(j,r[i]){\n\t\t\t\t//cout << cnt << ' ' << p << endl;\n\t\t\t\tif(d[j].com == 'W'){\n\t\t\t\t\tint add = min(idx - cnt, d[j].len);\n\t\t\t\t\tma[d[j].idx] = add;\n\n\t\t\t\t\tif(p == -1 and cnt + add == idx){\n\t\t\t\t\t\tp = d[j].idx;\n\t\t\t\t\t}\n\n\t\t\t\t\tcnt += add;\n\t\t\t\t}else if(d[j].com == 'D'){\n\t\t\t\t\tif(p == d[j].idx) p = -1;\n\t\t\t\t\tcnt -= ma[d[j].idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << p << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef pair<P, long long int> elem;\n\nint main(){\n\t\n\tlong long int N;\n\t\n\twhile(true){\n\t\t\n\t\tcin >> N;\n\t\tif(N == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tlist<elem> lst;\n\t\telem e;\n\t\te.first.first = 1500000000;\n\t\te.first.second = 1;\n\t\te.second = 1500000000;\n\t\t\n\t\tlst.push_back(e);\n\t\t\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\t\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tlist<elem>::iterator itr = lst.begin();\n\t\t\t\n\t\t\tif(c == 'W'){\n\t\t\t\tlong long int num, count;\n\t\t\t\tcin >> num >> count;\n\t\t\t\tlong long int pos = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\telem e_cur = *itr;\n\t\t\t\t\tif(e_cur.first.first > pos){\n\t\t\t\t\t\telem e1;\n\t\t\t\t\t\te1.first.first = pos;\n\t\t\t\t\t\te1.first.second = min(count, e_cur.first.first- pos);\n\t\t\t\t\t\te1.second = num;\n\t\t\t\t\t\tlst.insert(itr, e1);\n\t\t\t\t\t\tcount -= e_cur.first.first - pos;\n\t\t\t\t\t\tif(count <= 0){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos = e_cur.first.first + e_cur.first.second;\n\t\t\t\t\t++itr;\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tlong long int num;\n\t\t\t\tcin >> num;\n\t\t\t\twhile(itr != lst.end()){\n\t\t\t\t\tif(((elem)*itr).second == num){\n\t\t\t\t\t\titr = lst.erase(itr);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++itr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlong long int pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tlong long int ans = -1;\n\t\t\t\twhile(itr != lst.end()){\n\t\t\t\t\telem e_cur = *itr;\n\t\t\t\t\tif(e_cur.first.first + e_cur.first.second > pos){\n\t\t\t\t\t\tif(e_cur.first.first <= pos){\n\t\t\t\t\t\t\tans = e_cur.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\titr++;\n\t\t\t\t}\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(list<elem>::iterator itr = lst.begin(); itr != lst.end(); itr++){\n\t\t\telem e = *itr;\n\t\t\tcout << e.first.first << \" \" << e.first.second << \" \" << e.second << endl;\n\t\t}\n\t\t*/\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tmap<ll,ll> mp;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0) break;\n\t\tlist<pll> lt;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\t\tauto it=lt.begin();\n\t\t\t\tmp[x]=y;\n\t\t\t\twhile(it!=lt.end()){\n\t\t\t\t\tif(it->first==-1){\n\t\t\t\t\t\tint t=it->second;\n\t\t\t\t\t\tif(y>=t){\n\t\t\t\t\t\t\tit->first=x;\n\t\t\t\t\t\t\ty-=t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tit=lt.insert(it,make_pair(x,y));\n\t\t\t\t\t\t\tit++;\n\t\t\t\t\t\t\tit->second=t-y;\n\t\t\t\t\t\t\ty=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(y==0) break;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tif(y) lt.push_back(make_pair(x,y));\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tauto it=lt.begin();\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tint t=mp[x];\n\t\t\t\twhile(it!=lt.end()){\n\t\t\t\t\tif(it->first==x){\n\t\t\t\t\t\tit->first=-1;\n\t\t\t\t\t\tt-=it->second;\n\t\t\t\t\t\tif(t==0) break;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint x;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tauto it=lt.begin();\n\t\t\t\tbool B=0;\n\t\t\t\twhile(it!=lt.end()){\n\t\t\t\t\tint t=it->second,y=it->first;\n\t\t\t\t\tif(t<=x) x-=t;\n\t\t\t\t\telse{\n\t\t\t\t\t\tprintf(\"%d\\n\",y);\n\t\t\t\t\t\tB=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tif(!B) printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct sector{\n\tint begin,end,label;\n\tsector(int begin,int end,int label):begin(begin),end(end),label(label){}\n};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tlist<sector> sectors;\n\t\tREP(i,n){\n\t\t\tchar command;\n\t\t\tcin>>command;\n\t\t\tint l,s;\n\t\t\tswitch(command){\n\t\t\tcase 'W':\n\t\t\t\t{\n\t\t\t\t\tcin>>l>>s;\n\t\t\t\t\tint left=0;\n\t\t\t\t\tint total=0;\n\t\t\t\t\tif(sectors.size()==0){\n\t\t\t\t\t\tsectors.push_back(sector(0,s,l));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\t\tif(left<it->begin){\n\t\t\t\t\t\t\t\tif(total+it->begin-left>=s){\n\t\t\t\t\t\t\t\t\tit=sectors.insert(it,sector(left,s-total+left-1,l));\n\t\t\t\t\t\t\t\t\ttotal+=s-total+left;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tint right=it->begin-1;\n\t\t\t\t\t\t\t\t\tit=sectors.insert(it,sector(left,right,l));\n\t\t\t\t\t\t\t\t\ttotal+=right-left+1;\n\t\t\t\t\t\t\t\t\tleft=it->end;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(it->end>left){\n\t\t\t\t\t\t\t\t\tleft=it->end+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(total<s){\n\t\t\t\t\t\t\tsectors.push_back(sector(left,left+s-total-1,l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t{\n\t\t\t\t\tcin>>l;\n\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\tif(it->label==l){\n\t\t\t\t\t\t\tit=sectors.erase(it);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t{\n\t\t\t\t\tcin>>l;\n\t\t\t\t\tint label=-1;\n\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\tif(it->begin<=l&&l<=it->end){\n\t\t\t\t\t\t\tlabel=it->label;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcout<<label<<endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst ll INF = 1LL << 60;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        PQ que;\n        que.push(P(0LL,INF));\n        map<P,ll> m;\n        while (n--) {\n            char c;\n            cin >> c;\n            if (c == 'W') {\n                ll t, l;\n                cin >> t >> l;\n                P p;\n                while (true) {\n                    p = que.top(); que.pop();\n                    ll s = p.first, g = p.second;\n                    if (s + l - 1 <= g) {\n                        if (s + l - 1 < g)\n                            que.push(P(s + l, g));\n                        m[P(s, s + l - 1)] = t;\n                        break;\n                    } else {\n                        m[P(s, g)] = t;\n                        l -= g - s + 1;\n                    }\n                }\n            } else if (c == 'D') {\n                ll t; cin >> t;\n                auto tmp(m);\n                for (auto i : tmp) {\n                    if (i.second == t) {\n                        que.push(i.first);\n                        m.erase(m.find(i.first));\n                    }\n                }\n            } else {\n                ll x; cin >> x;\n                bool flag = true;\n                for (auto i : m) {\n                    if (i.first.first <= x && x <= i.first.second) {\n                        cout << i.second << endl;\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag)\n                    cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define INF 1000000001\nusing namespace std;\n\nint main()\n{\n  int N,I,S,P;\n  char c;\n  vector<pair<int,pair<int,int> > > V;\n\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    V.clear();\n    V.push_back(make_pair(-1,make_pair(-1,-1)));\n    V.push_back(make_pair(INF,make_pair(INF,INF)));\n    for(int i=0;i<N;i++){\n      cin>>c;\n      if(c=='W'){\n\tcin>>I>>S;\n        for(int i=1;i<V.size();i++){\n\t  int a=V[i-1].second.second,b=V[i].second.first;\n\t  if(a+1!=b){\n\t    int c=min(a+S,b-1);\n\t    V.insert(V.begin()+i,make_pair(I,make_pair(a+1,c)));\n\t    S-=b-(a+1);\n\t    if(S<=0)break;\n\t  }\n\t}\n      }\n      else if(c=='D'){\n\tcin>>I;\n        for(int i=0;i<V.size();i++){\n\t  if(V[i].first==I){\n\t    V.erase(V.begin()+i);\n\t    i--;\n\t  }\n\t}/*\n\tfor(int i=0;i<V.size();i++)cout<<V[i].first<<\" \"<<V[i].second.first<<\" \"<<V[i].second.second<<endl;\n\tcout<<endl;*/\n      }\n      else {\n\tcin>>P;\n\tfor(int i=1;i<V.size();i++){\n\t  if(V[i].second.first<=P && P<=V[i].second.second){\n\t    cout<<V[i].first<<endl;\n\t    break;\n\t  }\n\t  if(i==V.size()-1)cout<<\"-1\"<<endl;\n\t}\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define foreach(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define mp make_pair\nusing namespace std;\ntypedef map<pair<int,int>,int> S;\nint main(){\n\tint n,t1,t2; char c;\n\twhile(cin>>n,n){\n\t\tS s;\n\t\trep(i,n){\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tcin>>t1>>t2;\n\t\t\t\tint p=0,q;\n\t\t\t\tif(s.empty())s.insert(mp(mp(0,t2),t1)),t2=0;\n\t\t\t\telse{\n\t\t\t\t\tforeach(j,s){\n\t\t\t\t\t\tif(j->first.first>p){\n\t\t\t\t\t\t\tq=min(p+t2,j->first.first);\n\t\t\t\t\t\t\ts.insert(mp(mp(p,q),t1));\n\t\t\t\t\t\t\tt2-=q-p; p=q;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}else p=j->first.second;\n\t\t\t\t\t}\n\t\t\t\t\tif(t2>0)s.insert(mp(mp(p,p+t2),t1));\n\t\t\t\t}\n\t\t\t}else if(c=='D'){\n\t\t\t\tcin>>t1;\n\t\t\t\tforeach(j,s)if(j->second==t1)s.erase(j);\n\t\t\t}else{\n\t\t\t\tcin>>t1;\n\t\t\t\tforeach(j,s)if(j->first.first<=t1&&t1<j->first.second){\n\t\t\t\t\tcout<<j->second<<endl;\n\t\t\t\t\tgoto END;\n\t\t\t\t}\n\t\t\t\tcout<<-1<<endl; END:;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <list>\n#include <algorithm>\nusing namespace std;\n\nclass File\n{\npublic:\n  int index, left, right;\n  File (int i, int l, int r)\n    :index(i), left(l), right(r) {}\n};\n\nint main()\n{\n  int N;\n  while (~scanf(\"%d\\n\", &N)) {\n    if (N == 0)\n      break;\n\n    list<File> disk(1, File(-1, -1, -1));\n    for (int i = 0; i < N; ++i) {\n      char op;\n      scanf(\"%c\", &op);\n      if (op == 'W') {\n\tint I, S;\n\tscanf(\"%d %d\\n\", &I, &S);\n\n\tint last = 0;\n\tfor (list<File>::iterator it = disk.begin(); it != disk.end(); ) {\n\t  list<File>::iterator next = it;\n\t  ++next;\n\t  if (next == disk.end()) {\n\t    last = it->right+1;\n\t    break;\n\t  }\n\n\t  int left  = it->right+1;\n\t  int right = next->left-1;\n\t  int cap = right - left + 1;\n\t  if (cap >= 1) {\n\t    if (cap > S) {\n\t      disk.insert(next, File(I, left, left+S-1));\n\t      S = 0;\n\t      break;\n\t    } else {\n\t      disk.insert(next, File(I, left, right));\n\t      S -= cap;\n\t    }\n\t  } else {\n\t    ++it;\n\t  }\n\t}\n\n\tif (S > 0)\n\t  disk.push_back(File(I, last, last+S-1));\n      } else if (op == 'D') {\n\tint I;\n\tscanf(\"%d\\n\", &I);\n\tfor (list<File>::iterator it = disk.begin(); it != disk.end(); ) {\n\t  if (it->index == I)\n\t    it = disk.erase(it);\n\t  else\n\t    ++it;\n\t}\n\n      } else {\n\tint P, ans = -1;\n\tscanf(\"%d\\n\", &P);\n\tfor (list<File>::iterator it = disk.begin(); it != disk.end(); ++it) {\n\t  if (it->left <= P && P <= it->right) {\n\t    ans = it->index;\n\t    break;\n\t  }\n\t}\n\tprintf(\"%d\\n\", ans);\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tint back = 0;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(!del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tauto it = upper_bound(seg.begin(), seg.end(), ppiii(pii(s.first, 0), 0));\n\t\t\t\t\tseg.insert(it, ppiii(pii(s.first, l), id));\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\tback += len;\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second >= id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nclass E{\npublic:\n  char c;\n  int a,b;\n  E(char c,int a,int b):c(c),a(a),b(b){}\n};\n\nint n;\nvector<E> in;\n\nbool input(){\n  cin>>n;\n  if(n==0)return false;\n\n  in.clear();\n  rep(i,n){\n    char c;\n    int a,b;\n    cin>>c;\n    if(c=='W')cin>>a>>b;\n    else cin>>a;\n    in.push_back(E(c,a,b));\n  }\n  return true;\n}\n\nclass D{\npublic:\n  int prev;\n  int next;\n  int num;\n  int len;\n  D(int prev, int next,int num,int len):prev(prev),next(next),num(num),len(len){}\n};\n\n\nvector<D> data;\n\nvoid calc_write(int num,int len){\n  int now = 0;\n  while(1){\n    int prev = data[now].prev;\n    int next = data[now].next;\n\n    if(data[now].num==-1){\n      if(len<=data[now].len){\n\tdata[now].len -= len;\n\n\tD ad = D(prev, now, num, len);\n\tdata[now].prev = data.size();\n\tdata[prev].next = data.size();\n\n\tdata.push_back(ad);\n\tbreak;\n      }else{\n\tdata[now].num = num;\n\tlen-=data[now].len;\n      }\n    }\n    if(data[now].next==-1)break;\n    now = next;\n  }\n}\n\nvoid calc_del(int num){\n  int now = 0;\n  while(1){\n    int next = data[now].next;\n    if(data[now].num==num)data[now].num=-1;\n    if(next==-1)break;\n    now = next;\n  }\n}\n\nint  calc_read(int len){\n  int now = 0;\n  int sum = 0;\n  while(1){\n    int next = data[now].next;\n    sum += data[now].len;\n    if(sum  >= len)return data[now].num;\n    if(next==-1)break;\n    now = next;\n  }\n  return -1;\n}\n\nvoid print(){\n  int now=0;\n  while(1){\n    int next = data[now].next;\n    printf(\"num=%d len=%d  (now=%d)\\n\",data[now].num,data[now].len,now);\n    if(data[now].next==-1)break;\n    now=next;\n  }\n}\n\nvoid solve(){\n  data.clear();\n  data.push_back(D(-1,1,-2,0));\n  data.push_back(D(0,-1,-1,1100000000));\n\n  //int();\n\n  rep(i,in.size()){\n    //printf(\"%c  %d %d\\n\",in[i].c,in[i].a,in[i].b);\n    if(in[i].c=='W')calc_write(in[i].a,in[i].b);\n    if(in[i].c=='R')printf(\"%d\\n\",calc_read(in[i].a));\n    if(in[i].c=='D')calc_del(in[i].a);\n    //print();\n  }\n  puts(\"\");\n}\n\nint main(){\n  while(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 10010\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i-1] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nvoid check()\n{\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    {\n      if(file[i] == p2(-1,-1,-1))\n\t{\n\t  for(int j=i+1;file[j] == p2(-1,-1,-1);j++)\n\t    file[j] = p2(-3,-3,-3);\n\t}\n    }\n\n  for(int i=0;file[i-1] != p2(-2,-2,-2);i++)\n    {\n      if(file[i] == p2(-3,-3,-3))\n\t{\n\t  while(file[i] == p2(-3,-3,-3))\n\t    for(int j=i;file[j] != p2(-2,-2,-2);j++)\n\t      file[j] = file[j+1];\n\t}\n    }\n\n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index == s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else if(file[j+1].first.first-index > s)\n\t\t\t{\n\t\t\t  file[j] = p2(index,index+s,l);\n\t\t\t  if(file[j+1] == p2(-2,-2,-2) || file[j+1] == p2(-1,-1,-1))\n\t\t\t  break;\n\t\t\t  P2 tmp = file[j+1];\n\t\t\t  file[j+1] = p2(-1,-1,-1);\n\t\t\t  s = 0;\n\t\t\t  for(int k=j+2;file[k-1] != p2(-2,-2,-2);k++)\n\t\t\t    {\n\t\t\t      P2 tmp2 = file[k];\t\t\t\n\t\t\t      file[k] = tmp;\n\t\t\t      tmp = tmp2;\n\t\t\t    }\n\t\t\t}\t\t      \n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    assert(false);\n\t\t  \n\t\t}\n\t   \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t  check();\n\t  //print();\n\t  //cout << endl;\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin>>N, N){\n\t\tmap<int, int> m;\n\t\tmap<int, int>::iterator it;\n\t\tm.insert( make_pair(0, -1) );\n\t\tm.insert( make_pair(1000000001, -2) );\n\t\twhile(N--){\n\t\t\tchar com;\n\t\t\tint I, S, P, ans=-1;\n\t\t\tcin >> com;\n\t\t\tswitch(com){\n\t\t\tcase 'W':\n\t\t\t\tcin >> I >> S;\n\t\t\t\tfor(it = m.begin(); it!=m.end();){\n\t\t\t\t\tif(it->second == -1){\n\t\t\t\t\t\tit->second = I;\n\t\t\t\t\t\tint st = it->first;\n\t\t\t\t\t\tit++;\n\t\t\t\t\t\tint ls = it->first;\n\t\t\t\t\t\tif( ls-st > S ){\n\t\t\t\t\t\t\tm.insert( make_pair(st+S, -1) );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tS -= ls-st;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else it++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> I;\n\t\t\t\tfor(it = m.begin(); it!=m.end(); it++){\n\t\t\t\t\tif( it->second == I ){\n\t\t\t\t\t\tit->second = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> P;\n\t\t\t\tfor(it = m.begin(); it!=m.end(); it++){\n\t\t\t\t\tif( it->first > P ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = it->second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << ans << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n \nint N;\nvector<Data> storage;\n\nvoid dump() {\n  #ifdef DEBUG\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n  #endif\n}\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n\tinto = i;\n\tbreak;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      /*\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      */\n      num = remain;\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nvoid del(int id) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n      #ifdef DEBUG\n      cout << \"Deleted: \" << id << endl;\n      dump();\n      #endif\n    }\n  }\n}\n \nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n\tdump();\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nint main(){\n\tint N;\n\twhile(cin>>N, N){\n\t\tmap<int, int> m;\n\t\tmap<int, int>::iterator it;\n\t\tm.insert( make_pair(0, -1) );\n\t\tm.insert( make_pair(1000000001, -2) );\n\t\twhile(N--){\n\t\t\tchar com;\n\t\t\tint I, S, P, ans=-1;\n\t\t\tcin >> com;\n\t\t\tswitch(com){\n\t\t\tcase 'W':\n\t\t\t\tcin >> I >> S;\n\t\t\t\tfor(it = m.begin(); it!=m.end() && S;){\n\t\t\t\t\tif(it->second == -1){\n\t\t\t\t\t\tit->second = I;\n\t\t\t\t\t\tint st = it->first;\n\t\t\t\t\t\tit++;\n\t\t\t\t\t\tint ls = it->first;\n\t\t\t\t\t\tif( ls-st > S ){\n\t\t\t\t\t\t\tm.insert( make_pair(st+S, -1) );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tS -= ls-st;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else it++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> I;\n\t\t\t\tfor(it = m.begin(); it!=m.end(); it++){\n\t\t\t\t\tif( it->second == I ){\n\t\t\t\t\t\tit->second = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> P;\n\t\t\t\tfor(it = m.begin(); it!=m.end(); it++){\n\t\t\t\t\tif( it->first > P ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans = it->second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << ans << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iterator>\nstd::vector<int> vec;\nvoid W(int x,int y){\n    for(int i=0;i<vec.size();++i){\n        if(y>0)\n            if(vec[i]==-1)vec[i]=x,--y;\n    }\n    while(y>0){\n        if(vec.size()>1000000000)break;\n        vec.push_back(x);\n        --y;\n    }\n}\nvoid D(int x){\n    int size=vec.size()-1;\n    if(x<=size)for(int i=vec.size()-1;i>=0;--i){\n        if(vec[i]==x){\n            if(vec.size()-1==i){\n                std::vector<int>::iterator it=vec.end();\n                vec.erase(it);\n            }else vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vec.size();\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n            for(int i=0;i<vec.size();++i){\n                std::cout<<vec[i]<<\":\";\n            }\n            std::cout<<std::endl;\n        }\n        b=false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nclass zone{\npublic:\n\tint s,t,id;\n\tzone(int s,int t,int id):s(s),t(t),id(id){}\n};\n\n\nint main()\n{\n\tint n;\n\twhile(cin>>n && n!=0){\n\t\tlist<zone> L;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint count=0;\n\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tint id,length;\n\t\t\t\tcin>>id>>length;\n\t\t\t\tint now=0;\n\t\t\t\tfor(list<zone>::iterator it=L.begin();it!=L.end();){\n\t\t\t\t\tzone look=*it;\n\t\t\t\t\tif(now<look.s){\n\t\t\t\t\t\tit=L.insert(it,zone(now,now+min(length,look.s-now),id));\n\t\t\t\t\t\tlength=length-min(length,look.s-now);\n\t\t\t\t\t\tif(length==0) break;\n\t\t\t\t\t\tnow=look.t;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnow=look.t;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tif(length!=0)\n\t\t\t\t\tL.push_back(zone(now,now+length,id));\n\t\t\t}\n\t\t\telse if(c=='D'){\n\t\t\t\tint id; cin>>id;\n\t\t\t\tfor(list<zone>::iterator it=L.begin();it!=L.end();){\n\t\t\t\t\tzone look=*it;\n\t\t\t\t\tif(look.id==id){\n\t\t\t\t\t\tit=L.erase(it);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint id;cin>>id;\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(list<zone>::iterator it=L.begin();it!=L.end();){\n\t\t\t\t\tzone look=*it;\n\t\t\t\t\tif(look.s>id){break;}\n\t\t\t\t\tif(look.s<=id && id<=look.t){ok=true;cout<<look.id<<endl;break;}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tif(!ok) cout<<-1<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tdel.push(pii(0, 1000000000));\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(len && !del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\ts.first  += l;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\tif(it == seg.begin()) puts(\"-1\");\n\t\t\t\t\telse{\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tif(it->first.first <= id && id < it->first.first + it->first.second) printf(\"%d\\n\", it->second);\n\t\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg.resize(t);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\nusing namespace std;\n\nstruct List\n{\n  int identifier;\n  int range[2];// [range[0],range[1]]\n  bool hasNext,hasPrev;\n  List *prev;\n  List *next;\n  List(int identifier=inf,int r1=inf,int r2=inf):identifier(identifier)\n  {\n    range[0] = r1, range[1] = r2;\n    hasNext = hasPrev = false;\n  }\n};\n\nint N,I,S,P;\nchar c;\nList list;\n\nvoid list_walk(List *l)\n{\n  cout << '[' << l->range[0] << \",\" << l->range[1] << \" : \" << l->identifier << \"]\";\n  if(l->hasNext)list_walk(l->next);\n}\n\n\nvoid ddfs(List *l)\n{\n  if(l->hasNext)ddfs(l->next);\n  if(l->hasPrev)delete l;\n    \n}\n\nvoid init()\n{\n  if(list.hasNext)ddfs(&list);\n  list.hasNext = true;\n  list.hasPrev = false;\n  list.range[0] = list.range[1] = -1;\n  list.identifier = -1;\n  list.next = new List;\n  list.next->hasNext = false;\n  list.next->hasPrev = true;\n  list.next->range[0] = list.next->range[1] = inf;\n  list.next->identifier = inf;\n  list.next->prev = &list;\n  //cout << \"test : \" << list.next->prev->identifier << endl;\n  //cout << \"test : \" << list.next->identifier << endl;\n}\n\nvoid dfsW(List *l)\n{\n  if(!l->hasNext)\n    {\n      //assert(false);\n      return;\n    }\n\n  int v1 = l->range[1];\n  int v2 = l->next->range[0];\n  //cout << \"v1 = \" << v1 << \" v2 = \" << v2 << endl;\n  int diff = v2-v1-1;\n  //cout << \"diff = \" << diff << endl;\n  //assert(diff >= 0);\n  if(diff)\n    {\n      List *node = new List;\n      node->identifier = I;\n      node->hasNext = node->hasPrev = true;\n      node->next = l->next;\n      node->prev = l;\n      l->next->prev = node;\n      l->next = node;\n\n      node->range[0] = v1+1;\n      if(S <= diff)\n\t{\n\t  node->range[1] = node->range[0] + S - 1;\n\t  S = 0;\n\t}\n      else if(S > diff)\n\t{\n\t  node->range[1] = node->range[0] + diff - 1;\n\t  S -= diff;\n\t}\n    \n    }  \n\n  if(S > 0)dfsW(l->next);\n}\n\nvoid compute_W()\n{\n  dfsW(&list);\n}\n\nvoid dfsD(List *l)\n{\n  if(l->identifier == I)\n    {\n      l->next->prev = l->prev;\n      l->prev->next = l->next;\n      delete l;\n    }\n  if(l->hasNext)dfsD(l->next);\n}\n\nvoid compute_D()\n{\n  dfsD(&list);\n}\n\nvoid dfsR(List *l)\n{\n  if(l->range[0] <= P && P <= l->range[1])\n    {\n      cout << l->identifier << endl;\n    }\n  else\n    {\n      if(l->hasNext)dfsR(l->next);\n      else cout << -1 << endl;\n    }\n}\n\nvoid compute_R()\n{\n  dfsR(&list);\n}\n\n\nint main()\n{\n  bool f = true;\n  while(cin >> N,N)\n    {\n      if(!f)cout << endl;\n      f = false;\n      init();\n      rep(_,N)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')cin >> I >> S,compute_W();\n\t  if(c == 'D')cin >> I,compute_D();\n\t  if(c == 'R')cin >> P,compute_R();\n\t  //list_walk(&list);cout << endl;\n\t}\n      //list_walk(&list);cout << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int ll\ntypedef long long ll;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n#define F first\n#define S second\n\nsigned main(void){\n    for(int n; cin >> n, n;){\n        vector<pii> s_empty;\n        s_empty.pb(mp(0, INF));\n\n        vector<vector<pii>> s_used(10001);\n        map<int, int> dic;\n        int cnt_idx = 0;\n\n        while(n--){\n            char op; cin >> op;\n\n            switch(op){\n                case 'W':{\n                    int idx, len; cin >> idx >> len;\n\n                    dic[cnt_idx] = idx;\n                    idx = cnt_idx++;\n\n                    int cnt = 0;\n                    for(auto && sec : s_empty){\n                        if(sec.S - sec.F < len){\n                            s_used[idx].pb(sec);\n                            len -= (sec.S - sec.F);\n                            cnt++;\n                        }\n                        else{\n                            s_used[idx].pb(mp(sec.F, sec.F + len));\n                            sec = mp(sec.F + len, sec.S);\n\n                            break;\n                        }\n                    }\n\n                    s_empty.erase(s_empty.begin(), s_empty.begin() + cnt);\n                    range(i, 1, s_used[idx].size()){\n                        if(s_used[idx][i].F != s_used[idx][i - 1].S) continue;\n\n                        s_used[idx][i - 1].S = s_used[idx][i].S;\n                        s_used[idx].erase(s_used[idx].begin() + i);\n                        i--;\n                    }\n\n                    break;\n                }\n                case 'R':{\n                    int p; cin >> p;\n                    int res = -1;\n\n                    rep(i, cnt_idx){\n                        for(auto && sec : s_used[i]){\n                            if(p < sec.F || sec.S <= p) continue;\n\n                            res = dic[i];\n                        }\n                        \n                        if(res != -1) break;\n                    }\n\n                    cout << res << endl;\n\n                    break;\n                }\n                case 'D':{\n                    int idx; cin >> idx;\n                    idx = dic[idx];\n\n                    for(auto && sec : s_used[idx]){\n                        s_empty.pb(sec);\n                    }\n                    s_used[idx].clear();\n\n                    sort(all(s_empty));\n                    \n                    break;\n                }\n                \n                default: break;\n            }\n        }\n\n        //rep(i, cnt_idx){\n        //    for(auto && sec : s_used[i]){\n        //        cout << sec.F << \" \" << sec.S << \"/\";\n        //    }\n        //    cout << endl;\n        //}\n\n        cout << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\nint n;\nvector<P> vc;\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tvc.clear();\n\t\trep(i,n){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='W'){\n\t\t\t\tint id,x;\n\t\t\t\tcin>>id>>x;\n\t\t\t\trep(k,vc.size()){\n\t\t\t\t\tif(vc[k].fs==-1){\n\t\t\t\t\t\tif(x<vc[k].sc){\n\t\t\t\t\t\t\tvc[k].sc-=x;\n\t\t\t\t\t\t\tvc.insert(vc.begin()+k,P(id,x));\n\t\t\t\t\t\t\tx=0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tvc[k].fs=id;\n\t\t\t\t\t\t\tx-=vc[k].sc;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(x==0) break;\n\t\t\t\t}\n\t\t\t\tif(x>0){\n\t\t\t\t\tvc.pb(P(id,x));\n\t\t\t\t}\n\t\t\t}else if(t=='D'){\n\t\t\t\tint id;\n\t\t\t\tcin>>id;\n\t\t\t\trep(k,vc.size()){\n\t\t\t\t\tif(vc[k].fs==id) vc[k].fs=-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tint now=0;\n\t\t\t\tbool done=false;\n\t\t\t\trep(k,vc.size()){\n\t\t\t\t\tnow+=vc[k].sc;\n\t\t\t\t\tif(x<now){\n\t\t\t\t\t\tcout<<vc[k].fs<<endl;\n\t\t\t\t\t\tdone=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!done){\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n; cin >> n&&n;) {\n\t\tset<T> st;\n\t\tst.emplace(-INF, 0, -1);\n\t\twhile (n--) {\n\t\t\tchar com; cin >> com;\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s; cin >> l >> s;\n\t\t\t\tint ca, cb, cc, na, nb, nc;\n\t\t\t\tfor (auto c = st.begin(); c != st.end(); c++) {\n\t\t\t\t\ttie(ca, cb, cc) = *c;\n\t\t\t\t\tif (next(c) == st.end()) {\n\t\t\t\t\t\tst.emplace(cb, cb + s, l);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttie(na, nb, nc) = *next(c);\n\t\t\t\t\tif (cb == na)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint d = min(s, na - ca);\n\t\t\t\t\tst.emplace(cb, cb + d, l);\n\t\t\t\t\ts -= d;\n\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tfor (auto it = st.begin(); it != st.end();) {\n\t\t\t\t\tif (get<2>(*it) == l)\n\t\t\t\t\t\tit = st.erase(it);\n\t\t\t\t\telse\n\t\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'R') {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tauto upper = st.upper_bound(T(p, 0, 0));\n\t\t\t\tif (upper != st.begin()) {\n\t\t\t\t\tupper--;\n\t\t\t\t\tint a, b, c;\n\t\t\t\t\ttie(a, b, c) = *upper;\n\t\t\t\t\tif (b <= p)\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << c << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  cin >> l;\n\n  if(len == 0){\n    return -1;\n  }\n\n  if(l == 0){\n    return num;\n  }  \n\n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n\tcout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nbool check(){\n  for(int i = 0 ; i < (int)vec.size() ; i++){\n    if(vec[i].first != -1) return true;\n  }\n\n  vec.clear();\n  return false;\n}\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0 || !check()){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n    if(cnt >= l+1){\n      return num;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n\tcout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint main(){\n  int n;\n  while (cin >> n, n){\n    list<pair<int, int>> l{{-1, inf}};\n    rep(i, n){\n      string c;\n      cin >> c;\n      if (c == \"W\"){\n        int a, b;\n        cin >> a >> b;\n        auto it = l.begin();\n        while (b > 0){\n          if (it->first == -1){\n            if (b >= it->second){\n              it->first = a;\n              b -= it->second;\n            }\n            else {\n              l.insert(next(it), {-1, it->second - b});\n              *it = {a, b};\n              b = 0;\n            }\n          }\n          ++it;\n        }\n      }\n      else if (c == \"D\"){\n        int a;\n        cin >> a;\n        auto it = l.begin();\n        while (it != l.end()){\n          if (it->first == a) it->first = -1;\n          ++it;\n        }\n        it = l.begin();\n        while (next(it) != l.end()){\n          if (it->first == -1 && next(it)->first == -1){\n            it->second += next(it)->second;\n            l.erase(next(it));\n          }\n          ++it;\n        }\n      }\n      else if (c == \"R\"){\n        int a;\n        cin >> a;\n        auto it = l.begin();\n        while (a >= it->second){\n          a -= it->second;\n          ++it;\n        }\n        cout << it->first << endl;\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        set<pair<int,pair<int,int>>> s;\n        for(int i = 0; i < n; i++){\n            char c; cin >> c;\n            if(c == 'W'){\n                int id, t;\n                cin >> id >> t;\n                auto it = s.begin();\n                int next = 0;\n                while(t > 0){\n                    if(it == s.end()){\n                        s.insert({next, {id, t}});\n                        break;\n                    }\n                    if(next < it->first){\n                        s.insert({next, {id, min(it->first-next, t)}});\n                        t -= min(it->first-next, t);\n                    }\n                    next = it->first + it->second.second;\n                    it++;\n                }\n            }else if(c == 'D'){\n                int id;\n                cin >> id;\n                auto it = s.begin();\n                while(it != s.end()){\n                    if(it->second.first == id) it = s.erase(it);\n                    else                       it++;\n                }\n            }else if(c == 'R'){\n                int pos;\n                cin >> pos;\n                auto it = s.lower_bound({pos, {0, 0}});\n                if(it != s.end() && it->first == pos){\n                    cout << it->second.first << endl;\n                }else if(it != s.begin()){\n                    it--;\n                    if(it->first+it->second.second > pos){\n                        cout << it->second.first << endl;\n                    }else{\n                        cout << -1 << endl;\n                    }\n                }else{\n                    cout << -1 << endl;\n                }\n            }\n            // cout << \"[\" << i << \"]\" << endl;\n            // for(auto p : s) cout << \"(\" << p.first << \",\" << p.second.first << \" \" << p.second.second << \") \";\n            // cout << endl;\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//:55-\n#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  files[make_pair(h,e-1)]=I;\n\t  S-=h-e;\n\t}else{\n\t  files[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tif(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\n\nint main(){\n\t#define int long long\n\tset< pair< pair<int,int> , int> > se;\n\tint N;\n\twhile(cin >> N && N){\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"D\" ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( it->second == v ){\n\t\t\t\t\t\tse.erase(it++);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( s == \"W\" ){\n\t\t\t\tint l,sec;\n\t\t\t\tcin >> l >> sec;\n\t\t\t\tint prev = 0;\n\t\t\t\tvector< pair<int,int> > ad;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( sec == 0 ) break;\n\t\t\t\t\tint width = it->first.first - prev;\n\t\t\t\t\tint use = min(sec,width);\n\t\t\t\t\tif( use != 0 ) {\n\t\t\t\t\t\tsec -= use;\n\t\t\t\t\t\tad.push_back(make_pair(prev,prev+use));\n\t\t\t\t\t}\n\t\t\t\t\tprev = it->first.second;\n\t\t\t\t}\n\t\t\t\tif( sec != 0 ){\n\t\t\t\t\tad.push_back(make_pair(prev,prev+sec));\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < ad.size() ; i++)\n\t\t\t\t\tse.insert(make_pair(ad[i],l));\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->first.first <= pos && pos < it->first.second ){\n\t\t\t\t\t\tcout << it->second << endl;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !flag ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\ntemplate <typename T> constexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity() : numeric_limits<T>::max() / 4;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(10); } } initCpp;\n\nstruct Fragment {\n  i64 from;\n  i64 to;\n  i64 id;\n};\n\nsigned main() {\n  while (true) {\n    i64 n;\n    cin >> n;\n    if (n == 0) break;\n    list<Fragment> mem;\n    mem.push_back({0, inf<i64>, -1});\n    REP(_, n) {\n      char c;\n      cin >> c;\n      if (c == 'W') {\n        i64 i, s;\n        cin >> i >> s;\n        for (auto iter = mem.begin(); iter != mem.end(); ++iter) {\n          Fragment f = *iter;\n          if (f.id == -1) {\n            if (f.to - f.from > s) {\n              Fragment g = *mem.insert(iter, {f.from, f.from + s, i});\n              iter->from = g.to;\n              // f.from = g.to;\n              // *iter = f;\n              break;\n            } else {\n              s -= f.to - f.from;\n              iter->id = i;\n              // f.id = i;\n              // *iter = f;\n              if (s == 0) break;\n            }\n          }\n        }\n      }\n      if (c == 'D') {\n        i64 i;\n        cin >> i;\n        for (auto& f : mem) {\n          if (f.id == i) {\n            f.id = -1;\n          }\n        }\n      }\n      if (c == 'R') {\n        i64 p;\n        cin >> p;\n        for (auto f : mem) {\n          if (f.from <= p && p < f.to) {\n            cout << f.id << endl;\n            goto read;\n          }\n        }\n        cout << -1 << endl;\n        read:;\n        // for (auto f : mem) {\n        //   cerr << f.from << \" \" << f.to << \" \" << f.id << \"; \";\n        // }\n        // cerr << endl;\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nvector<PPI> v;\n\nvoid write() {\n  int num, times;\n  cin >> num >> times;\n\n  int before = 0, i = 0;\n  if(v.empty()) v.pb(PPI(P(0, times - 1), num));\n  else {\n    while(i < v.size()) {\n      if (v[i].fi.fi - before >= times) {\n        v.insert(v.begin() + i, PPI(P(before, before + times - 1), num));\n        // rep(i, v.size()) cout << v[i].se << \" [\" << v[i].fi.fi << \", \" << v[i].fi.se << \"]\" << endl;\n        return;\n      } else {\n        PPI tmp = v[i];\n        times -= (tmp.fi.fi - before);\n        if (tmp.fi.fi - before > 0) {\n          v.insert(v.begin() + i, PPI(P(before, tmp.fi.fi - 1), num));\n          i += 2;\n        } else {\n          i++;\n        }\n        before = tmp.fi.se + 1;\n      }\n    }\n    v.insert(v.end(), PPI(P(before, before + times - 1), num));\n  }\n  // rep(i, v.size()) cout << v[i].se << \" [\" << v[i].fi.fi << \", \" << v[i].fi.se << \"]\" << endl;\n}\n\nvoid remove() {\n  int num;\n  cin >> num;\n  repr(i, v.size()) {\n    if (v[i].se == num) v.erase(v.begin() + i);\n  }\n  // rep(i, v.size()) cout << v[i].se << \" [\" << v[i].fi.fi << \", \" << v[i].fi.se << \"]\" << endl;\n}\n\nvoid read() {\n  int j;\n  cin >> j;\n  rep(i, v.size()) {\n    if (v[i].fi.fi <= j && j <= v[i].fi.se) {\n      cout << v[i].se << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n  while(cin >> n, n) {\n    v.clear();\n    rep(i, n) {\n      char cmd;\n      cin >> cmd;\n      switch(cmd) {\n        case 'W':\n        write(); break;\n        case 'D':\n        remove(); break;\n        case 'R':\n        read(); break;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n// #define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e9 + 7;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                    if(len == 0) break;\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nint n; vector<tuple<int, int, int>>vec;\nvoid Write(int a, int b) {\n\tint R = vec.size();\n\tint E = -1; if (vec.size() >= 1)E = get<0>(vec[0]) - 1;\n\tif (E >= 0) {\n\t\tif (b < E + 1) { vec.push_back(make_tuple(0, b - 1, a)); sort(vec.begin(), vec.end()); return; }\n\t\tif (b >= E + 1) { vec.push_back(make_tuple(0, E, a)); sort(vec.begin(), vec.end()); b -= (E + 1); }\n\t}\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tif (b == 0)break;\n\t\tint E = get<1>(vec[i]) + 1;\n\t\tint F = get<0>(vec[i + 1]) - 1;\n\t\tint SS = F - E + 1;\n\t\tif (b >= SS) { vec.push_back(make_tuple(E, F, a)); b -= SS; }\n\t\tif (b < SS) { vec.push_back(make_tuple(E, E + b - 1, a)); b = 0; }\n\t}\n\tsort(vec.begin(), vec.end());\n\tif (b >= 1) {\n\t\tint E = 0; if (vec.size() >= 1) E = get<1>(vec[vec.size() - 1]) + 1;\n\t\tvec.push_back(make_tuple(E, E + b - 1, a));\n\t}\n\treturn;\n}\nvoid Delete(int a) {\n\tvector<tuple<int, int, int>>vec2;\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<2>(vec[i]) != a)vec2.push_back(vec[i]);\n\t}\n\tvec = vec2;\n\treturn;\n}\nint Read(int a) {\n\tfor (int i = 0; i < vec.size(); i++) {\n\t\tif (get<0>(vec[i]) <= a && a <= get<1>(vec[i])) {\n\t\t\treturn get<2>(vec[i]);\n\t\t}\n\t}\n\treturn -1;\n}\nint main() {\n\twhile (true) {\n\t\tcin >> n; vec.clear(); if (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'W') { int l, s; cin >> l >> s; Write(l, s); }\n\t\t\tif (p == 'D') { int l; cin >> l; Delete(l); }\n\t\t\tif (p == 'R') { int l; cin >> l; cout << Read(l) << endl; }\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> File;\n\nvoid debug(const vector<File>& v){\n\tcout << \"[debug]\" << endl;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint id = v[i].first;\n\t\tint L = v[i].second.first;\n\t\tint R = v[i].second.second;\n\t\tcout << \"[\" << L << \" , \" << R << \"] : \" << id << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\tint n;\n\t\n\twhile( cin >> n , n ){\n\t\t// [0,10^9] が 空(-1)\n\t\tFile ini( -1 , P(0,1e+9) );\n\t\tvector<File> v;\n\t\tv.push_back( ini );\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tchar command;\n\t\t\tcin >> command;\n\t\t\t\n\t\t\tif( command == 'W' ){ // 書き込み\n\t\t\t\tint l, s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\t\n\t\t\t\t// ファイル番号が小さい方(-1)でさらにセクタの番号が小さい順にソート\n\t\t\t\tsort( v.begin() , v.end() );\n\t\t\t\t// 全部書き込みが終わるまで走査\n\t\t\t\tfor(vector<File>::iterator it = v.begin() ; it != v.end() ; ++it){\n\t\t\t\t\tif( s == 0 ) break;\n\t\t\t\t\t\n\t\t\t\t\tint id = it->first;\n\t\t\t\t\tint L = it->second.first;\n\t\t\t\t\tint R = it->second.second;\n\t\t\t\t\tint width = R - L + 1;\n\t\t\t\t\tif( id != -1 ) continue;\n\t\t\t\t\t\n\t\t\t\t\t// 書き込める十分なスペースがあるとき\n\t\t\t\t\tif( s <= width ){\n\t\t\t\t\t\tv.erase( it );\n\t\t\t\t\t\tint L1 = L;\n\t\t\t\t\t\tint R1 = L + s - 1;\n\t\t\t\t\t\tint id1 = l;\n\t\t\t\t\t\tFile f1( id1 , P(L1,R1) );\n\t\t\t\t\t\tv.push_back( f1 );\n\t\t\t\t\t\tif( s != width ){\n\t\t\t\t\t\t\tint L2 = L + s;\n\t\t\t\t\t\t\tint R2 = R;\n\t\t\t\t\t\t\tint id2 = -1;\n\t\t\t\t\t\t\tFile f2( id2 , P(L2,R2) );\n\t\t\t\t\t\t\tv.push_back( f2 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = 0;\n\t\t\t\t\t}else{ // スペースが足りないときは全部埋めて次へ\n\t\t\t\t\t\tit->first = l;\n\t\t\t\t\t\ts -= width;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( command == 'D' ){ // 削除\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor(vector<File>::iterator it = v.begin() ; it != v.end() ; ++it){\n\t\t\t\t\tif( it->first == l ){\n\t\t\t\t\t\tit->first = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( command == 'R' ){ // 参照\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\t\t\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\t\t\tint id = v[i].first;\n\t\t\t\t\tint L = v[i].second.first;\n\t\t\t\t\tint R = v[i].second.second;\n\t\t\t\t\tif( L <= p && p <= R ){\n\t\t\t\t\t\tcout << id << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort( v.begin() , v.end() );\n\t\t\t//debug( v );\n\t\t\t\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                            break;\n                        }\n                    }\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                id--;\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    idx--;\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<cstring>\n#include<map>\n \nusing namespace std;\n \n\nint main(void)\n{\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t//????????????,?????\\\n\t\tmap<int,int> sec;\n\t\t\n\t\t//-1(???)???0???????§???????\n\t\tsec[0]=-1;\n\t\tsec[1000000000]=-1;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\t\n\t\t\tif(s==\"W\"){\n\t\t\t\tint a,len;\n\t\t\t\tcin>>a>>len;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second==-1){\n\t\t\t\t\t\tit->second=a;\n\t\t\t\t\t\tauto it2=it;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif((it2)->first - it->first >= len){\n\t\t\t\t\t\t\tsec[it->first+len]=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse len-=(it2)->first - it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(s==\"D\"){\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second == a) it->second=-1;\n\t\t\t\t}\n\t\t\t}else if(s==\"R\"){\n\t\t\t\t/*\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tcout<<\"map[\"<<it->first<<\"]=\"<<it->second<<endl;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\tit2++;\n\t\t\t\t\tif(it->first<=a && a<=it2->first){\n\t\t\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\n\nint main(){\n\t#define int long long\n\tset< pair< pair<int,int> , int> > se;\n\tint N;\n\twhile(cin >> N && N){\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"D\" ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tvector< pair< pair<int,int>,int> > del;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->second == v ){\n\t\t\t\t\t\tdel.push_back(*it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < del.size() ; i++)\n\t\t\t\t\tse.erase(del[i]);\n\t\t\t}else if( s == \"W\" ){\n\t\t\t\tint l,sec;\n\t\t\t\tcin >> l >> sec;\n\t\t\t\tint prev = 0;\n\t\t\t\tvector< pair<int,int> > ad;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( sec == 0 ) break;\n\t\t\t\t\tint width = it->first.first - prev;\n\t\t\t\t\tint use = min(sec,width);\n\t\t\t\t\tif( use != 0 ) {\n\t\t\t\t\t\tsec -= use;\n\t\t\t\t\t\tad.push_back(make_pair(prev,prev+use));\n\t\t\t\t\t}\n\t\t\t\t\tprev = it->first.second;\n\t\t\t\t}\n\t\t\t\tif( sec != 0 ){\n\t\t\t\t\tad.push_back(make_pair(prev,prev+sec));\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < ad.size() ; i++)\n\t\t\t\t\tse.insert(make_pair(ad[i],l));\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->first.first <= pos && pos < it->first.second ){\n\t\t\t\t\t\tcout << it->second << endl;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !flag ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n        if(n == 0)break;\n        \n        set<P1> S1;\n        set<P1> S2;\n        S1.insert(mp1(0,-1,1000000001));\n        S2.insert(mp1(-1,0,1000000001));\n        \n        for(int i = 0 ; i < n ; i ++){\n            char c;\n            cin >> c;\n            //scanf(\"\\n%c\",&c);\n            if(c == 'W'){\n                int l,s;\n                scanf(\"%d%d\",&l,&s);\n                set<P1>::iterator itr = S2.lower_bound(mp1(-1,0,0));\n                while(1){\n                    if(itr->sc.sc > s){\n                        S1.insert(mp1(itr->sc.fr,l,s));\n                        S1.insert(mp1(itr->sc.fr+s,itr->fr,itr->sc.sc-s));\n                        S1.erase(mp1(itr->sc.fr,itr->fr,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,s));\n                        S2.insert(mp1(itr->fr,itr->sc.fr+s,itr->sc.sc-s));\n                        S2.erase(itr);\n                        break;\n                    }\n                    else {\n                        S1.insert(mp1(itr->sc.fr,l,itr->sc.sc));\n                        S1.erase(mp1(itr->sc.fr,-1,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,itr->sc.sc));\n                        S2.erase(itr++);\n                        s -= itr->sc.sc;\n                    }\n                    if(s == 0)break;\n                }\n            }\n            else if(c == 'D'){\n                int l;\n                scanf(\"%d\",&l);\n                set<P1>::iterator itr = S2.lower_bound(mp1(l,0,0));\n                while(1){\n                    S1.insert(mp1(itr->sc.fr,-1,itr->sc.sc));\n                    S1.erase(mp1(itr->sc.fr,l,itr->sc.sc));\n                    S2.insert(mp1(-1,itr->sc.fr,itr->sc.sc));\n                    S2.erase(itr++);\n                    if(itr->fr != l)break;\n                }\n            }\n            else {\n                int p;\n                scanf(\"%d\",&p);\n                set<P1>::iterator itr = S1.upper_bound(mp1(p,-1,0));\n                printf(\"%d\",(--itr)->sc.fr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\nconst long long INF = (1e18);\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    map< pair<long long, long long>, long long > F;\n    map< long long, vector< pair<long long, long long> > > M;\n    F[{-INF,0}] = -1;\n    for(int i = 0; i < N; ++i){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n        long long l, s, r = 0;\n        cin >> l >> s;\n        vector< pair<long long, long long> > V;\n        for(auto itr = F.begin(); itr != F.end(); ++itr){\n          r = max(r, itr->first.second);\n          auto itr_ = itr;\n          ++itr_;\n          if(itr_ == F.end()) continue;\n          if(itr_->first.first != itr->first.second){\n            long long n = min(s, itr_->first.first - itr->first.second);\n            s -= n;\n            V.emplace_back(itr->first.second,itr->first.second+n);\n            if(!s) break;\n          }\n        }\n        if(s){\n          V.emplace_back(r,r+s);\n        }\n        for(int j = 0; j < (int)V.size(); ++j){\n          F[V.at(j)] = l;\n          M[l].push_back(V.at(j));\n        }\n\n        sort(M[l].begin(), M[l].end());\n        V = {};\n        long long x = -2, y = -1;\n        for(int j = 0; j < (int)M[l].size(); ++j){\n          if(y == M[l].at(j).first){\n            F.erase(F.find({x,y}));\n            F.erase(F.find(M[l].at(j)));\n            y = M[l].at(j).second;\n            F[{x,y}] = l;\n            V.pop_back();\n            V.emplace_back(x,y);\n          }else{\n            x = M[l].at(j).first;\n            y = M[l].at(j).second;\n            V.emplace_back(x,y);\n          }\n        }\n        M[l] = V;\n        \n      }else if(c == 'D'){\n        long long l;\n        cin >> l;\n        for(int j = 0; j < (int)M[l].size(); ++j) F.erase(F.find(M[l].at(j)));\n        M[l] = {};\n      }else{\n        long long p;\n        cin >> p;\n        auto itr = F.upper_bound({p,INF});\n        //cout << itr->first.first << \" \" << itr->first.second << \" \" << itr->second << endl;\n        assert(itr != F.begin());\n        --itr;\n        if(itr->first.second <= p) cout << -1 << endl;\n        else cout << itr->second << endl;\n      }\n      //for(auto itr = F.begin(); itr != F.end(); ++itr) cout << \"[\" << itr->first.first << \", \" << itr->first.second << \") =  \" << itr->second << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#define F first\n#define S second\n#define MAX 10010\n#define all(n) n.begin(),n.end()\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\nstruct P\n{\n  int id,l,r;\n  P(int l = -1,int r = -1,int id = -1):l(l),r(r),id(id){}\n};\n\nbool cmp(const P& p,const P& q)\n{\n  return p.l < q.l;\n}\n\nvoid print(const vector<P>& v)\n{\n  cout << \"print\" << endl;\n  for(int i=0;i<v.size();i++)\n    cout << v[i].id << \" \" << v[i].l << \" \" << v[i].r << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      vector<P> vec;    \n      for(int ww = 0;ww<N;ww++)\n\t{\n\t  char c;\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      int index = 0;\n\t      int id,s,size;\n\t      size = vec.size();\n\t      cin >> id >> s;\n\t      if(vec.empty())\n\t\t{\n\t\t  vec.push_back(P(0,s,id));//[l,r)\n\t\t  continue;\n\t\t}\n\t      for(int i=0;i<size && s;i++)\n\t\t{\n\t\t  if(index != vec[i].l)\n\t\t    {\n\t\t      if(vec[i].l-index >= s)\n\t\t\t{\n\t\t\t  vec.push_back(P(index,index+s,id));\n\t\t\t  break;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  vec.push_back(P(index,vec[i].l,id));\n\t\t\t  s -= (vec[i].l-index);\n\t\t\t  index = vec[i].r;\n\t\t\t}\n\t\t    }\n\t\t}\n\t      if(s)\n\t\t{\n\t\t  int nl = vec[size-1].r;\n\t\t  vec.push_back(P(nl,nl+s,id));\n\t\t}\n\t      sort(all(vec),cmp);\n\t    }\n\t  else if(c == 'R')\n\t    {\n\t      int pos;\n\t      cin >> pos;\n\t      bool found = false;\n\t      for(int i=0;i<vec.size();i++)\n\t\t{\n\t\t  if(vec[i].l <= pos && pos < vec[i].r)\n\t\t    {\n\t\t      found = true;\n\t\t      cout << vec[i].id << endl;\n\t\t      goto next;\n\t\t    }\n\t\t}\n\t    next:;\n\t      if(!found)\n\t\tcout << -1 << endl;\n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int id;\n\t      cin >> id;\n\t      //bool ToBeContinued = true;\n\t      //while(ToBeContinued)\n\t      //{\n\t      //ToBeContinued = false;\n\t\t  for(vector<P>::iterator it = vec.begin();it != vec.end();it++)\n\t\t    {\n\t\t      if(it->id == id)\n\t\t\t{\n\t\t\t  //ToBeContinued = true;\n\t\t\t  it = vec.erase(it);\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  //}\n\t    }\n\t  else\n\t    assert(false);\n\t  \n\t  //print(vec);\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ALL(x) (x).begin(), (x).end()\n#define EB emplace_back\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int, int> PII;\n\nconst int INF = 0x3f3f3f3f;\n\nstruct Cmd {\n    char c;\n    int a, b;\n};\n\nstruct Sector {\n    Sector(){}\n    Sector(int _b, int _e, int _l) : b(_b), e(_e), l(_l) {}\n    int b, e, l;\n    bool operator < (const Sector &s) const {\n        return b < s.b;\n    }\n};\n\nint N;\n\nvector<Cmd> cmds;\n\nvoid dump(vector<Sector> &ss) {\n    VI ts(10, -1);\n    cout << \"---\" << endl;\n    for (auto &s : ss) {\n        cout << s.b << \" \" << s.e << \" \" << s.l << endl;\n        for (int i = s.b; i < s.e; i++) {\n            ts[i] = s.l;\n        }\n    }\n    for (auto t : ts) cout << t << \" \";\n    cout << endl;\n    cout << \"/---\" << endl;\n}\n\nvoid cmd_write(vector<Sector> &ss, int l, int size) {\n    int begin = 0;\n    \n    for (auto &s : ss) {\n        if (begin < s.b) {\n            int end = min(s.b, begin + size);\n            ss.EB(begin, end, l);\n\n            size -= end - begin;\n\n            if (size == 0) {\n                break;\n            }\n        }\n\n        begin = s.e;\n    }\n\n    if (size) {\n        int end = begin + size;\n        ss.EB(begin, end, l);\n    }\n\n    sort(ALL(ss));\n\n}\n\nvoid cmd_delete(vector<Sector> &ss, int l) {\n    for (int i = 0; i < (int)ss.size(); i++) {\n        if (ss[i].l == l) {\n            ss.erase(ss.begin() + l);\n            --l; // ???????????????????????´\n        }\n    }\n}\n\nint cmd_reference(vector<Sector> &ss, int p) {\n    for (auto &s : ss) {\n        if (s.b <= p && p < s.e) {\n            return s.l;\n        } else if (p < s.b) {\n            return -1;\n        }\n    }\n\n    return -1;\n}\n\nvoid solve() {\n    vector<Sector> ss;\n\n    for (int i = 0; i < N; i++) {\n        if (cmds[i].c == 'W') {\n            cmd_write(ss, cmds[i].a, cmds[i].b);\n        } else if (cmds[i].c == 'D') {\n            cmd_delete(ss, cmds[i].a);\n        } else if (cmds[i].c == 'R') {\n            cout << cmd_reference(ss, cmds[i].a) << endl;\n        }\n//        dump(ss);\n    }\n\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        cmds.clear();\n        cmds.resize(N);\n\n        for (int i = 0; i < N; i++) {\n            cin >> cmds[i].c;\n\n            if (cmds[i].c == 'W') {\n                cin >> cmds[i].a >> cmds[i].b;\n            } else {\n                cin >> cmds[i].a;\n            }\n        }\n\n        solve();\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct data{\n\tint no;\n\tint front;\n\tint size;\n\tbool operator<(const data &right){\n\t\treturn front < right.front;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile (cin>>n,n){\n\t\tvector<data> file;\n\t\tfile.push_back({ -1, 1, 1000000000 });\n\t\tREP(i,n){\n\t\t\tint a, b;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t\tcin >> a >> b;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].no == -1){\n\t\t\t\t\t\tif (file[i].size > b){\n\t\t\t\t\t\t\tfile.push_back({a,file[i].front,b});\n\t\t\t\t\t\t\tfile[i].front += b;\n\t\t\t\t\t\t\tfile[i].size -= b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(file[i].size==b){\n\t\t\t\t\t\t\tfile[i].no = a;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfile[i].no = a;\n\t\t\t\t\t\t\tb -= file[i].size;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> a;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].no == a)\n\t\t\t\t\t\tfile[i].no = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> a;\n\t\t\t\ta++;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (a <= file[i].size){\n\t\t\t\t\t\tcout << file[i].no << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ta -= file[i].size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSORT(file);\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tvector<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v[0].p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min(v[0].p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= v[0].p.second + 1;\n\t\t\t\t}\n\t\t\t\trep(i, v.size() - 1) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tif (v[i].p.second < v[i + 1].p.first) {\n\t\t\t\t\t\tv.insert(v.begin() + i + 1, { P(v[i].p.second + 1, min(v[i + 1].p.second - 1, v[i].p.first + b - 1)),a });\n\t\t\t\t\t\tb -= v[i + 1].p.second - v[i + 1].p.first + 1;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P(v[v.size() - 1].p.second + 1, b + v[v.size() - 1].p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\trep(i, v.size()) {\n\t\t\t\t\tif (v[i].p.first == a) {\n\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < v.size() && v[i].p.second < a; i++);\n\t\t\t\tif (i == v.size())puts(\"-1\");\n\t\t\t\telse if (v[i].p.first <= a&&a <= v[i].p.second)printf(\"%d\\n\", v[i].id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<int> xs;\n    vector<char> com(n);\n    vector<int> id(n, -1), S(n, -1), p(n, -1);\n    xs.push_back(0);\n    map<int, int> lens;\n    int sum = 0;\n    for(int i = 0; i < n; ++i) {\n      cin >> com[i];\n      if(com[i] == 'W') {\n        cin >> id[i] >> S[i];\n        sum += S[i];\n        lens[id[i]] = S[i];\n        xs.push_back(sum);\n      } else if(com[i] == 'D') {\n        cin >> id[i];\n        sum -= lens[id[i]];\n      } else {\n        cin >> p[i];\n      }\n    }\n    sort(begin(xs), end(xs));\n    xs.erase(unique(begin(xs), end(xs)), end(xs));\n\n    map<int, vector<int>> ls;\n    vector<int> ref_id(xs.size(), -1);\n    for(int i = 0; i < n; ++i) {\n      if(com[i] == 'W') {\n        int idx = 0, remain = S[i];\n        while(remain > 0) {\n          if(ref_id[idx] == -1) {\n            ref_id[idx] = id[i];\n            assert(idx + 1 < xs.size());\n            remain -= xs[idx + 1] - xs[idx];\n            ls[id[i]].push_back(idx);\n          }\n          idx++;\n        }\n      } else if(com[i] == 'D') {\n        for(auto r : ls[id[i]]) {\n          ref_id[r] = -1;\n        }\n      } else {\n        auto pos = lower_bound(begin(xs), end(xs), p[i]) - begin(xs);\n        if(pos == (int)xs.size()) {\n          cout << -1 << endl;\n          continue;\n        }\n        if(xs[pos] > p[i]) pos--;\n        cout << ref_id[pos] << endl;\n      }\n    }\n    cout << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  cin >> l;\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n    if(cnt >= l+1){\n      return num;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n\tcout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> plll;\nlist<plll> li;\n\nll distplll(plll a){\n\treturn a.F.S-a.F.F+1;\n}\n\nvoid w_list(ll a,ll b){\n\tlist<plll>::iterator it=li.begin();\n\twhile(1){\n\t\tif(b==0) break;\n\t\tif(it==li.end()){\n\t\t\tif(it==li.begin()){\n\t\t\t\tli.PB(mkp(mkp(0,b-1),a));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t--it;\n\t\t\t\tli.PB(mkp(mkp((*it).F.S+1,(*it).F.S+b),a));\n\t\t\t\t++it;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif((*it).S==-1){\n\t\t\t\tif(distplll(*it)<=b){\n\t\t\t\t\t(*it).S=a;\n\t\t\t\t\tb-=distplll(*it);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tplll tmp;\n\t\t\t\t\ttmp.S=a;\n\t\t\t\t\ttmp.F.S=(*it).F.F+b-1;\n\t\t\t\t\ttmp.F.F=(*it).F.F;\n\t\t\t\t\t(*it).F.F=tmp.F.S+1;\n\t\t\t\t\tit=li.insert(it,tmp);\n\t\t\t\t\t++it;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++it;\n\t}\n}\n\n\nvoid d_list(ll a){\n\tlist<plll>::iterator it=li.begin();\n\twhile(it!=li.end()){\n\t\tif((*it).S==a){\n\t\t\t(*it).S=-1;\n\t\t}\n\t\t++it;\n\t}\n}\n\nvoid r_list(ll a){\n\tlist<plll>::iterator it=li.begin();\n\twhile(it!=li.end()){\n\t\tif(a<=(*it).F.S){\n\t\t\tcout<<(*it).S<<endl;\n\t\t\treturn;\n\t\t}\n\t\t++it;\n\t}\n\tcout<<\"-1\"<<endl;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tlist<plll> ttt;\n\t\tli=ttt;\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tll a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tw_list(a,b);\t\n\t\n\t\t\t}\n\t\t\telse if(c=='D'){\n\t\t\t\tll a;\n\t\t\t\tcin>>a;\n\t\t\t\td_list(a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll a;\n\t\t\t\tcin>>a;\n\t\t\t\tr_list(a);\n\t\t\t}\n\t\t\tlist<plll>::iterator it=li.begin();\n\t\t\t\n\t\t\t// for(;it!=li.end();++it){\n\t\t\t\t// cout<<(*it).F.F<<\" \"<<(*it).F.S<<\" \"<<(*it).S<<endl;\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Data\n{\n  int id, st, num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n\nint N;\nvector<Data> storage;\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st; break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      num = remain;\n    }\n    storage.push_back(Data(id, st, num));\n    remain -= num;\n  }\n}\n\nvoid del(int id) {\n  for(int i=0; i<storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n    }\n  }\n}\n\nint refer(int sect) {\n  for(int i=0; i<storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n        /*\n        for(int i=0; i<storage.size(); i++) {\n          cout << \"storage[\"<<i<<\"]:\" << endl;\n          cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n        }\n        */\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct sector{\n\tint begin,end,label;\n\tsector(int begin,int end,int label):begin(begin),end(end),label(label){}\n};\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tlist<sector> sectors;\n\t\tREP(i,n){\n\t\t\tchar command;\n\t\t\tcin>>command;\n\t\t\tint l,s;\n\t\t\tswitch(command){\n\t\t\tcase 'W':\n\t\t\t\t{\n\t\t\t\t\tcin>>l>>s;\n\t\t\t\t\tint left=0;\n\t\t\t\t\tint total=0;\n\t\t\t\t\tif(sectors.size()==0){\n\t\t\t\t\t\tsectors.push_back(sector(0,s-1,l));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\t\tif(left<it->begin){\n\t\t\t\t\t\t\t\tif(total+it->begin-left>=s){\n\t\t\t\t\t\t\t\t\tit=sectors.insert(it,sector(left,s-total+left-1,l));\n\t\t\t\t\t\t\t\t\ttotal+=s-total+left;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tint right=it->begin-1;\n\t\t\t\t\t\t\t\t\tit=sectors.insert(it,sector(left,right,l));\n\t\t\t\t\t\t\t\t\ttotal+=right-left+1;\n\t\t\t\t\t\t\t\t\tleft=it->end+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tif(it->end>left){\n\t\t\t\t\t\t\t\t\tleft=it->end+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(total<s){\n\t\t\t\t\t\t\tsectors.push_back(sector(left,left+s-total-1,l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t{\n\t\t\t\t\tcin>>l;\n\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();){\n\t\t\t\t\t\tif(it->label==l){\n\t\t\t\t\t\t\tit=sectors.erase(it);\n\t\t\t\t\t\t\tif(it==sectors.end())break;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tit++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t{\n\t\t\t\t\tcin>>l;\n\t\t\t\t\tint label=-1;\n\t\t\t\t\tfor(list<sector>::iterator it=sectors.begin();it!=sectors.end();it++){\n\t\t\t\t\t\tif(it->begin<=l&&l<=it->end){\n\t\t\t\t\t\t\tlabel=it->label;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcout<<label<<endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nbool check(){\n  for(int i = 0 ; i < (int)vec.size() ; i++){\n    if(vec[i].first != -1) return true;\n  }\n\n  vec.clear();\n  return false;\n}\n\nvoid change(int p, int S, int l){\n  vector<P> tmp;\n  int Next = vec[p].second - S;\n\n  for(int i = 0 ; i < p ; i++){\n    tmp.push_back(vec[i]);\n  }\n\n  tmp.push_back(P(l, S));\n  tmp.push_back(P(-1,Next));\n\n  for(int i = p+1 ; i < (int)vec.size() ; i++){\n    tmp.push_back(vec[i]);\n  }\n\n  vec = tmp;\n}\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0 || !check()){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }else{\n        change(i, S, l);\n        return;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n\n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    cnt += vec[i].second;\n    num = vec[i].first;\n    \n    if(cnt > l){\n      return num;\n    }\n  }\n\n  if(cnt <= l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        cout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PPI;\ntypedef pair<ll, P> IPP;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nset<PPI> mem;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tmem.clear();\n\t\tmem.insert(PPI(P(0,1e9),-1));\n\t\trep(i,n){\n\t\t\tchar op;\n\t\t\tcin>>op;\n\t\t\tif(op=='W'){\n\t\t\t\tll file,sizes;\n\t\t\t\tcin>>file>>sizes;\n\t\t\t\tbool end=false;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.se==-1){\n\t\t\t\t\t\tint idx=it.fi.fi,maxsize=it.fi.se;\n\t\t\t\t\t\tif(maxsize>sizes){\n\t\t\t\t\t\t\tmem.insert(PPI(P(idx,sizes),file));\n\t\t\t\t\t\t\tmem.insert(PPI(P(idx+sizes,maxsize-sizes),-1));\n\t\t\t\t\t\t\tend=true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmem.insert(PPI(P(idx,maxsize),file));\n\t\t\t\t\t\t\tsizes-=maxsize;\n\t\t\t\t\t\t\tif(sizes==0)end=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmem.erase(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(end)break;\n\t\t\t\t}\n\t\t\t}else if(op=='D'){\n\t\t\t\tll file;\n\t\t\t\tcin>>file;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.se==file){\n\t\t\t\t\t\tmem.insert(PPI(P(it.fi.fi,it.fi.se),-1));\n\t\t\t\t\t\tmem.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(op=='R'){\n\t\t\t\tll sec;\n\t\t\t\tcin>>sec;\n\t\t\t\tsec--;\n\t\t\t\teach(it,mem){\n\t\t\t\t\t//dbg(it.fi.fi); dbg(it.fi.fi+it.fi.se);\n\t\t\t\t\tif(it.fi.fi<=sec&&sec<it.fi.fi+it.fi.se){\n\t\t\t\t\t\tcout<<it.se<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct data{\n    int d,end,ind;//識別子、長さ、最初のセクタ番号\n};\n\nvector<data> v;\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        v.clear();\n        data t;\n        t.ind = 0;\n        t.end = INF+10;\n        t.d = -1;\n        v.push_back(t);\n\n        rep(i,n){\n            string s;\n            cin >> s;\n            if(s == \"W\"){\n                int l,s;\n                cin >> l >> s;\n                for(j = 0; s > 0; j++){\n                    if(v[j].d != -1)continue;\n                    int tmp = v[j].end - v[j].ind + 1;\n                    if(tmp <= s){\n                        v[j].d = l;\n                        s -= tmp;\n                    }else{\n                        data t;\n                        t.ind = v[j].ind;\n                        t.d = l;\n                        t.end = v[j].ind + s - 1;\n                        v.insert(v.begin()+j,t);\n                        v[++j].ind = v[j-1].end + 1;\n                        s = 0;\n                    }\n                }\n            }\n            if(s == \"D\"){\n                int l;\n                cin >> l;\n                rep(j,v.size()){\n                    if(v[j].d == l)v[j].d = -1;\n                }\n            }\n            if(s == \"R\"){\n                int p;\n                cin >> p;\n                j = 0;\n                while(v[j].ind < p)j++;\n                cout << v[j].d << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nusing namespace std;\n\nint inf = 1e8;\n\nint minimum_steiner_tree(const vector<int>& T, const vector<vector<int> > &g) {\n  const int n = g.size();\n  const int numT = T.size();\n  if (numT <= 1) return 0;\n\n  vector<vector<int> > d(g); // all-pair shortest\n  for (int k = 0; k < n; ++k)\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        d[i][j] = min( d[i][j], d[i][k] + d[k][j] );\n\n  int OPT[(1 << numT)][n];\n  for (int S = 0; S < (1 << numT); ++S)\n    for (int x = 0; x < n; ++x)\n      OPT[S][x] = inf;\n\n  for (int p = 0; p < numT; ++p) // trivial case\n    for (int q = 0; q < n; ++q)\n      OPT[1 << p][q] = d[T[p]][q];\n\n  for (int S = 1; S < (1 << numT); ++S) { // DP step\n    if (!(S & (S-1))) continue;\n    for (int p = 0; p < n; ++p)\n      for (int E = 0; E < S; ++E)\n        if ((E | S) == S)\n          OPT[S][p] = min( OPT[S][p], OPT[E][p] + OPT[S-E][p] );\n    for (int p = 0; p < n; ++p)\n      for (int q = 0; q < n; ++q)\n        OPT[S][p] = min( OPT[S][p], OPT[S][q] + d[p][q] );\n  }\n  int ans = inf;\n  for (int S = 0; S < (1 << numT); ++S)\n    for (int q = 0; q < n; ++q)\n      ans = min(ans, OPT[S][q] + OPT[((1 << numT)-1)-S][q]);\n\n  return ans;\n}\n\nint main(){\n  while(true){\n    vector<int> v;\n    int h = getInt();\n    int w = getInt();\n\n    if(h + w == 0) break;\n\n    REP(i,h) REP(j,w){\n      if(getInt() == 1){\n\tv.push_back(i * w + j);\n      }\n    }\n\n    vector<vector<int> > g(h * w, vector<int>(h * w, inf));\n    \n    REP(i,h) REP(j,w){\n      g[i * w + j][i * w + j] = 0;\n      if(i != h - 1){\n\tg[i * w + j][(i + 1) * w + j] = g[(i + 1) * w + j][i * w + j] = 1;\n      }\n      if(j != w - 1){\n\tg[i * w + j][i * w + j + 1] = g[i * w + j + 1][i * w + j] = 1;\n      }\n    }\n\n    int ans = w * h - (minimum_steiner_tree(v, g) + 1);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) { return (c - rhs.c).length() - (r + rhs.r) < EPS; } // 接してても真。\n};\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile\n\t\t(true)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tstruct F { int ln, fn; };\n\t\tdeque<F> fs;\n\t\tfs.push_back({ INF + 1, -1 });\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tREAD(char, c);\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t{\n\t\t\t\tREAD(int, fn, ln);\n\t\t\t\tauto it = fs.begin();\n\t\t\t\twhile (ln > 0)\n\t\t\t\t{\n\t\t\t\t\tif (it->fn == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint n = min(it->ln, ln);\n\t\t\t\t\t\tit->fn = fn;\n\t\t\t\t\t\tif (n < it->ln) { it = fs.insert(it + 1, { it->ln - n, -1 }) - 1; }\n\t\t\t\t\t\tit->ln = n;\n\t\t\t\t\t\tln -= n;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t{\n\t\t\t\t\tREAD(int, fn);\n\t\t\t\t\tfor (auto &f : fs){ if (f.fn == fn) { f.fn = -1; } }\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\t{\n\t\t\t\t\tREAD(int, p);\n\t\t\t\t\tfor (auto &f : fs) { if (p - f.ln < 0) { write(f.fn); break; } p -= f.ln; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twrite(\"\");\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n\nstruct node { int size, id; };\n\n\nint main()\n{\n\twhile(true) {\n\n\t\tmap<int, node> frags;\n\t\tint n;\n\t\tconst int init_size = 2000000000;\n\n\t\tfrags.insert({0, {init_size, -1}});\n\t\tscanf(\"%d\", &n);\n\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tfor(int command_index = 0; command_index < n; ++command_index) {\n\n\t\t\tchar cmd;\n\t\t\tscanf(\" %c\", &cmd);\n\n\t\t\tif(cmd == 'W') {\n\n\t\t\t\tint id, size;\n\t\t\t\tscanf(\"%d%d\", &id, &size);\n\n\t\t\t\tauto it = frags.begin();\n\n\t\t\t\twhile(true) {\n\t\t\t\t\tauto &v = it->second;\n\t\t\t\t\tif(v.id != -1) {\n\t\t\t\t\t\t++it;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(v.size > size)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tv.id = id;\n\t\t\t\t\tsize -= v.size;\n\t\t\t\t\t++it;\n\t\t\t\t}\n\n\t\t\t\tif(size > 0) {\n\t\t\t\t\tconst int pos = it->first;\n\t\t\t\t\tauto &v = it->second;\n\t\t\t\t\tconst int space = v.size - size;\n\t\t\t\t\tv.id = id;\n\t\t\t\t\tv.size = size;\n\t\t\t\t\tfrags.insert({pos + size, {space, -1}});\n\t\t\t\t}\n\n\t\t\t} else if(cmd == 'R') {\n\n\t\t\t\tint seg;\n\t\t\t\tscanf(\"%d\", &seg);\n\n\t\t\t\tauto it = frags.begin();\n\n\t\t\t\twhile(true) {\n\t\t\t\t\tconst int pos = it->first;\n\t\t\t\t\tconst int size = it->second.size;\n\t\t\t\t\tif(pos <= seg && seg < pos + size)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t++it;\n\t\t\t\t}\n\n\t\t\t\tint ans = it->second.id;\n\n\t\t\t\tprintf(\"%d\\n\", ans);\n\n\t\t\t} else {\n\n\t\t\t\tint target;\n\t\t\t\tscanf(\"%d\", &target);\n\n\t\t\t\tfor(auto it = frags.begin(); it != frags.end(); ++it) {\n\t\t\t\t\tif(it->second.id == target)\n\t\t\t\t\t\tit->second.id = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*for(auto it = frags.begin(); it != frags.end(); ++it) {\n\t\t\t\tconst int pos = it->first;\n\t\t\t\tconst int size = it->second.size;\n\t\t\t\tconst int id = it->second.id;\n\t\t\t\tprintf(\"frag: %d %d - %d\\n\", pos, size, id);\n\t\t\t}\n\t\t\tprintf(\"\\n\");*/\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cstdio>\n#include <list>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstatic const ll MAX = 1e10;\n\nenum Data {Space, File};\n\nstruct Range {\n  Data d;\n  int id;\n  ll start;\n  ll end;\n  ll size() const {\n    return end - start;\n  }\n  bool operator<(const Range& rhs) const {\n    return start < rhs.start;\n  }\n  void print() const {\n    printf(\"%c %d %lld %lld\\n\", (d == Space) ? 'S' : 'F', id, start, end);\n  }\n  Range(Data d, int id, ll start, ll end) : d(d), id(id), start(start), end(end) {}\n};\n\nint N;\nlist<Range> sector;\ntypedef list<Range> L;\n\nvoid solve() {\n  for (int i = 0; i < N; i++) {\n    char cmd;\n    cin >> cmd;\n    switch (cmd) {\n    case 'W': {\n      ll id, size;\n      cin >> id >> size;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == Space) {\n          if (it->size() >= size) {\n            Range file(File, id, it->start, it->start + size);\n            sector.insert(it, file);\n            it->start += size;\n            break;\n          } else {\n            it->d = File;\n            it->id = id;\n            size -= it->size();\n          }\n        }\n      }\n      break;\n    }\n    case 'D': {\n      ll id;\n      cin >> id;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->d == File && it->id == id) {\n          L::iterator prev_it = it;\n          prev_it--;\n          \n          if (it != sector.begin() &&\n              prev_it->end == it->start && prev_it->d == Space) {\n            prev_it->end += it->size();\n            it = sector.erase(it);\n            goto next;\n          } else {\n            L::iterator next_it = it;\n            next_it++;\n            if (it != sector.end() && \n                next_it->start == it->end && next_it->d == Space) {\n              next_it->start -= it->size();\n              it = sector.erase(it);\n              goto next;\n            }\n          }\n          it->d = Space;\n        next:;\n        }\n      }\n      break;\n    }\n    case 'R': {\n      ll sec;\n      cin >> sec;\n      for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n        if (it->start <= sec && sec < it-> end) {\n          if (it->d == Space) {\n            cout << -1 << endl;\n          } else {\n            cout << it->id << endl;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    }\n    /*\n    cout << \"debug\" << endl;\n    for (L::iterator it = sector.begin(); it != sector.end(); it++) {\n      it->print();\n    }\n    cout << endl;\n    */\n    //cout << \"debug\" << endl;\n    //cout << sector.size() << endl;\n  }\n}\n\nvoid init() {\n  sector.clear();\n  sector.push_back(Range(Space, -1, 0, MAX));\n}\n\nint main() {\n  while (true) {\n    cin >> N;\n    if (N == 0) {\n      return 0;\n    }\n    init();\n    solve();\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct data{\n    int d,len,ind;//識別子、長さ、最初のセクタ番号\n};\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        vector<data> v;\n        data t;\n        t.ind = 0;\n        t.len = INF;\n        t.d = -1;\n        v.push_back(t);\n\n        rep(i,n){\n            string s;\n            cin >> s;\n            if(s == \"W\"){\n                int l,s;\n                cin >> l >> s;\n                rep(j,v.size()){\n                    if(v[j].d == -1){\n                        if(v[j].len == s){\n                            v[j].d = l;\n                            break;\n                        }else if(v[j].len < s){\n                            v[j].d = l;\n                            s -= v[j].len;\n                        }else{\n                            data t;\n                            t.ind = v[j].ind + s;\n                            t.d = -1;\n                            t.len = v[j].len - s;\n                            v[j].d = l;\n                            v[j].len = s;\n                            v.insert(v.begin()+j+1,t);\n                            break;\n                        }\n                    }\n                }\n            }\n            if(s == \"D\"){\n                int l;\n                cin >> l;\n                rep(j,v.size()){\n                    if(v[j].d == l)v[j].d = -1;\n                }\n            }\n            if(s == \"R\"){\n                int p;\n                cin >> p;\n                rep(j,v.size()){\n                    //cout << v[j].ind << \" \" << v[j].d << \" \" << v[j].len << endl;\n                    if(v[j].ind >= p){\n                        break;\n                    }\n                }\n                cout << v[j-1].d << endl;\n\n            }\n        }\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  scanf(\"%d\" ,&l);\n\n  if(len == 0){\n    return -1;\n  }\n  \n  for(int i = 0 ; i < len ; i++){\n    if(cnt >= l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<map>\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> pi4;\n\nint dist[55][55][55][55],dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate<typename T> ostream& operator<<(ostream& os, vector<T> &v){\n  cout<<\"{\";\n  rep(i,v.size())os<<v[i]<<\",\"<<endl;cout<<\"}\"<<endl;\n  return os;\n}\ntemplate<typename T,typename S> ostream& operator<<(ostream& os, pair<T,S> &v){\n  os<<\"(\"<<v.X<<\",\"<<v.Y<<\")\";\n  return os;\n}\n\nint main(){\n  int n;\n  while(cin>>n){//cout<<\"[\"<<n<<\"]\"<<endl;\n    if(!n)break;\n    map<int,pii> mp;\n    rep(i,n){\n      string str;\n      cin>>str;\n      char c=str[0];\n      if(c=='W'){\n\tint m,l,pre=0;\n\tcin>>m>>l;\n\t//cout<<m<<\",\"<<l;\n\tvector<pii> ad;\n\tfor(auto it=mp.begin(); it!=mp.end(); ++it){\n\t  if(pre!=it->X){\n\t    int d=min(l,it->X-pre);\n\t    ad.eb(pre,pre+d);\n\t    l-=d;\n\t  }\n\t  pre=it->Y.X;\n\t}\n\tif(l)\n\t  ad.eb(pre,pre+l);\n\t//cout<<ad;\n\trep(i,ad.size())\n\t  mp[ad[i].X]=pii(ad[i].Y,m);\n      }else if(c=='D'){\n\tint m;\n\tcin>>m;\n\t//cout<<m<<endl;\n\tmap<int,pii> tmp=mp;\n\tmp.clear();\n\tfor(auto it=tmp.begin();it!=tmp.end();++it){\n\t  if(it->Y.Y!=m)\n\t    mp[it->X]=it->Y;\n\t}\n      }else{\n\tint m;\n\tcin>>m;\n\tauto it=mp.upper_bound(m);\n\tif(it==mp.begin()){\n\t  cout<<-1<<endl;\n\t}else{\n\t  --it;\n\t  //cout<<*it<<endl;\n\t  if(it->X <= m && m < it->Y.X){\n\t    cout<<it->Y.Y<<endl;\n\t  }else{\n\t    cout<<-1<<endl;\n\t  }\n\t}\n      }\n      //for(auto it=mp.begin();it!=mp.end();++it)cout<<*it;    cout<<endl;\n    }cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nclass Range{\n    public:\n        int s,t;    // [s,t)\n        int id;\n        Range(){}\n        Range(int s,int t,int id) : s(s),t(t),id(id){}\n\n        inline int length() const{\n            return t-s;\n        }\n};\n\nostream& operator<<(ostream& os ,const Range& r){\n    os << \"(\" << r.s << \",\" << r.t << \",\" << r.id << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, const list<T> lst){\n    os << \"{\";\n    for(auto l : lst) os << l << \",\";\n    os << \"}\";\n    return os;\n}\n\nvoid solve(int N){\n    list<Range> table;\n    table.insert(table.begin(),Range(0,1000000009,-1));\n    rep(i,N){\n        string com; cin >> com;\n        if(com == \"W\"){\n            int id,len;\n            cin >> id >> len;\n            for(auto itr = table.begin();itr != table.end(); itr++){\n                if(len == 0) break;\n                if(itr->id == -1){\n                    if(itr->length() >= len){\n                        int ns = itr->s + len;\n                        int nt = itr->t; \n                        table.insert(next(itr),Range(ns,nt,-1));\n                        itr->t = ns;\n                        itr->id = id;\n                        break;\n                    }else{\n                        itr->id = id;\n                        len -= itr->length();\n                    }\n                }\n            }\n        }else if(com == \"D\"){\n            int id; cin >> id;\n            //cerr << \"D \" << id << endl;\n            for(auto& r : table){\n                //cout << r.id << \" \" << id << endl;\n                if(r.id == id) r.id = -1;\n            }\n        }else if(com == \"R\"){\n            int p; cin >> p;\n            for(auto r : table){\n                if(r.s <= p and p < r.t){\n                    cout << r.id << endl;\n                    break;\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n        solve(n);\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<set>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i,j;\n  int n,p,q;\n  char c;\n  list<pair<int,int> > a;\n  list<pair<int,int> >::iterator it;\n  h=0;\n  while(cin>>n&&n){\n    if(h)\n      cout<<endl;\n    else\n      h=1;\n    a.clear();\n    a.push_back(make_pair(-1,1000000000));\n    for(i=0;i<n;i++){\n      cin>>c;\n      if(0){\n      }else if(c=='W'){\n\tcin>>p>>q;\n\tfor(it=a.begin();q;it++){\n\t  if((*it).first==-1){\n\t    if(0){\n\t    }else if((*it).second<q){\n\t      (*it).first=p;\n\t      q-=(*it).second;\n\t    }else if((*it).second>q){\n\t      (*it).second-=q;\n\t      a.insert(it,make_pair(p,q));\n\t      q=0;\n\t    }else{\n\t      (*it).first=p;\n\t      q=0;\n\t    }\n\t  }\n\t}\n      }else if(c=='D'){\n\tcin>>p;\n\tfor(it=a.begin();it!=a.end();it++){\n\t  if((*it).first==p)\n\t    (*it).first=-1;\n\t}\n      }else if(c=='R'){\n\tcin>>p;\n\tj=1;\n\tfor(it=a.begin();;it++){\n\t  if(j<=p&&p<j+(*it).second){\n\t    cout<<(*it).first<<endl;\n\t    break;\n\t  }\n\t  j+=(*it).second;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int>m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tpair<int,int> f={n,2000000000};\n\t\t\tauto it=m.lower_bound(f);\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[{cur,cur+d-1}]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[{cur,cur+z-1}]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s));\n                        endtoi[x.first + s] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second));\n                        endtoi[x.second] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(make_pair(mp[i][j].first,mp[i][j].second));\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.upper_bound(p);\n                if(it == endtoi.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp-1<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=sinki->start+s-1;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    }\n    prev=prev->next;\n    pres=prev->next;\n  }\n  cout<<\"test\"<<endl;\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  //cout<<\"read!\\n\";\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres,*tmp;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i){\n      tmp=pres;\n      prev->next=pres->next;\n      pres=prev->next;\n      //      cout<<\"debug\"<<tmp->start<<endl;\n      delete tmp;\n      continue;\n    }\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next; \n  while(pres!=NULL){\n    delete prev;\n    prev=pres;\n    pres=pres->next;\n  }\n  delete prev;\n  return;\n}\nvoid debug(newrm* begin){\n  while(begin!=NULL){\n    cout<<begin->start<<\" \"<<begin->end<<endl;\n    begin=begin->next;\n  }\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    \n    if(N==0) return 0;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      else if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      else if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      else if(com=='B')\n\tdebug(begin);\n    }\n    reset(begin);\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main(){\n\twhile(1){\n\t\tstd::vector<int>v(1,-1);\n\t\tint a;\n\t\tstd::cin>>a;\n\t\tif(a==0)break;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tchar x;\n\t\t\tint p,q;\n\t\t\tstd::cin>>x;\n\t\t\tif(x=='W'){\n\t\t\t\tstd::cin>>p>>q;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==-1)v[j]=p,q--;\n\t\t\t\t\tif(q==0)break;\n\t\t\t\t\twhile(j==v.size()-1&&q!=0)v.push_back(p),q--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x=='D'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==p)v[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(x=='R'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tif(p-1>v.size())std::cout<<\"-1\"<<std::endl;\n\t\t\t\telse std::cout<<v[p-1]<<std::endl;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\n#define rep(i,n) for(i=0;i<n;i++)\n\n\n/*\nlist<from,n,len>\n\n*/\n\nstruct DATA {\n\tint f;\n\tint n;\n\tint l;\n};\nlist<DATA> L;\n\n\nint main(){\n\t\n\tint N;\n\tchar q[2];\n\tint n,i,j;\n\tint I,S,P;\n\tint b;\n\tbool f;\n\tint nf,nl;\n\t\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)return 0;\n\t\t\n\t\tL.clear();\n\t\t\n\t\t\n\t\trep(n,N){\n\t\t\tscanf(\"%s\",q);\n\t\t\tif(q[0]=='W'){\n\t\t\t\tscanf(\"%d %d\",&I,&S);\n\t\t\t\tP=0;\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\t\tif((*it).n==-1){\n\t\t\t\t\t\tif((*it).l>S){\n\t\t\t\t\t\t\t(*it).n=I;\n\t\t\t\t\t\t\tnf=(*it).f+S;\n\t\t\t\t\t\t\tnl=(*it).l-S;\n\t\t\t\t\t\t\t(*it).l=S;S=0;\n\t\t\t\t\t\t\tit++;\n\t\t\t\t\t\t\tL.insert(it,DATA({nf,-1,nl}));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if((*it).l==S){\n\t\t\t\t\t\t\t(*it).n=I;S=0;break;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t(*it).n=I;\n\t\t\t\t\t\t\tS-=(*it).l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tP=(*it).f+(*it).l;\n\t\t\t\t\tif(S<=0)break;\n\t\t\t\t}\n\t\t\t\tif(S>0){\n\t\t\t\t\tL.insert(L.end(),DATA({P,I,S}));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(q[0]=='D'){\n\t\t\t\tscanf(\"%d\",&I);\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\t\tif((*it).n==I){\n\t\t\t\t\t\t(*it).n=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}else if(q[0]=='R'){\n\t\t\t\tscanf(\"%d\",&P);\n\t\t\t\tf=true;\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\t\tif(((*it).f<=P)&&(P<((*it).f+(*it).l))){\n\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).n);\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(f){\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t}else{\n\t\t\t\tputs(\"Ereer!!!!\");return -1;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\tprintf(\"#    %2d %2d %2d\\n\",(*it).f,(*it).n,(*it).l);\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t}\n\t\tputs(\"\");\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nint N;\nmap<int, vector<P>> mp;\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N, N)\n    {\n        mp.clear();\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push(P(0, 1e9 + 10));\n        for(int i = 0; i < N; i++)\n        {\n            char ch; cin >> ch;\n            if(ch == 'W')\n            {\n                int l, s; cin >> l >> s;\n                P target = que.top(); que.pop();\n                int range = target.second - target.first;\n                while(range < s)\n                {\n                    mp[l].push_back(target);\n                    s -= range;\n                    target = que.top(); que.pop();\n                    range = target.second - target.first;\n                }\n                if(range == s) mp[l].push_back(P(target.first, target.first + s));\n                else\n                {\n                    mp[l].push_back(P(target.first, target.first + s));\n                    int left = target.first + s;\n                    int right = target.second;\n                    que.push(P(left, right));\n                }\n            }\n            else if(ch == 'D')\n            {\n                int l; cin >> l;\n                vector<P> buff = mp[l];\n                for(P range : buff) que.push(range);\n                mp[l].clear();\n            }\n            else\n            {\n                int s; cin >> s;\n                int res = -1;\n                for(auto x : mp)\n                {\n                    vector<P> tmp = x.second;\n                    for(int i = 0; i < tmp.size(); i++)\n                    {\n                        if(tmp[i].first <= s and s < tmp[i].second) res = x.first;\n                    }\n                }\n                cout << res << \"\\n\";\n            }\n        }\n        cout << \"\\n\";\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n */\n#include <iostream>\n#include <algorithm>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n// init\n\n// input\nint iN;\nchar cC; // 0 <= N <= 100,000\nint iI; // 1 <= P <= 100\nint iS; // 1 <= P <= 100\nint iP; // 1 <= P <= 100\n\n// manage\n\n// ú»\nvoid init() {\n}\n\n// üÍ\nbool input() {\n  scanf(\"%d\", &iN);\n  if (iN == 0)\n    return false;\n  return true;\n}\n\n// \nvoid manage() {\n  int i;\n  list<P> lis;\n  list<P>::iterator it; // Ce[^\n  P p;\n  for (i = 0; i < iN; i++) {\n    it = lis.begin();\n    /*\n    while (it != lis.end()) { // listÌöÜÅ\n      printf(\"(%d, %d) \", it->first, it->second); // vfðoÍ\n      ++it; // Ce[^ðPÂißé\n    }\n    printf(\"\\n\"); // vfðoÍ\n    */\n    scanf(\" %c\", &cC);\n\n    if (cC == 'W') {\n      scanf(\"%d %d\", &iI, &iS);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == -1) {\n          it->first = iI;\n          iS -= it->second;\n        }\n        it++;\n      }\n      lis.push_back(P(iI, iS));\n      continue;\n    }\n\n    if (cC == 'D') {\n      scanf(\"%d\", &iI);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == iI) {\n          it->first = -1;\n        }\n        it++;\n      }\n\n      continue;\n    }\n\n    if (cC == 'R') {\n      scanf(\"%d\", &iP);\n      it = lis.begin();\n      int sum = 0;\n      while (it != lis.end()) { // listÌöÜÅ\n        //printf(\"(%d, %d) %d %d %d\\n\", it->first, it->second, sum + it->second, iP, sum + it->second > iP); // vfðoÍ\n        if (sum + it->second > iP)\n          break;\n        sum += it->second;\n        it++;\n      }\n      if (it != lis.end()) {\n        printf(\"%d\\n\", it->first);\n      } else {\n        printf(\"-1\\n\");\n      }\n      continue;\n    }\n\n  }\n\n}\n\n// oÍ\nvoid output() {\n  printf(\"\\n\");\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while (1) {\n    if (!input())\n      break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define foreach(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define mp make_pair\nusing namespace std;\ntypedef map<pair<int,int>,int> S;\nint main(){\n\tint n,t1,t2; char c;\n\twhile(cin>>n,n){\n\t\tS s;\n\t\trep(i,n){\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tcin>>t1>>t2;\n\t\t\t\tint p=0,q;\n\t\t\t\tif(s.empty())s.insert(mp(mp(0,t2),t1)),t2=0;\n\t\t\t\telse{\n\t\t\t\t\tforeach(j,s){\n\t\t\t\t\t\tif(j->first.first>p){\n\t\t\t\t\t\t\tq=min(p+t2,j->first.first);\n\t\t\t\t\t\t\ts.insert(mp(mp(p,q),t1));\n\t\t\t\t\t\t\tt2-=q-p; p=q;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}else p=j->first.second;\n\t\t\t\t\t\tif(t2==0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(t2>0)s.insert(mp(mp(p,p+t2),t1));\n\t\t\t\t}\n\t\t\t}else if(c=='D'){\n\t\t\t\tcin>>t1;\n\t\t\t\tforeach(j,s)if(j->second==t1)s.erase(j);\n\t\t\t}else{\n\t\t\t\tcin>>t1;\n\t\t\t\tS::iterator p=s.lower_bound(mp(t1-1,0));\n\t\t\t\tif(p!=s.end()&&p->first.first<=t1&&t1<p->first.second)cout<<p->second<<endl;\n\t\t\t\telse cout<<-1<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          // cout << idx << \" \" << cnt << endl;\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].second == -1) {\n            if(idx + cnt - 1 <= dp[idx].first) {\n              dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx].second = l;\n              dp[idx].first = idx+cnt-1;\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].first - idx + 1;\n            }\n          }\n          idx = dp[idx].first + 1;\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          }\n          idx = dp[idx].first + 1;\n        }\n      }\n      // for(auto& j: dp) cout << j.first << \" \" << j.second << \" \"; cout << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(c,c+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(c,c+k-1)]=n;\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n;\n\nvoid solve(){\n  int sqn=sqrt(n)+2;\n  vector<pair<PI,int> > sec[sqn];\n  set<int> app;\n  sec[0].pb(mp(mp(0,1000000000+10),-1));\n  rep(iii,n){\n    char co;\n    int a,b;\n    cin >> co >> a;\n    if(iii%sqn==0){\n      \n    }\n    \n    if(co=='W'){\n      cin >> b;\n      app.insert(a);\n      rep(i,sqn){\n        FOR(it,sec[i]){\n          if(app.count(it->S)) continue;\n          if(it->F.S-it->F.F<=b){\n            it->S=a;\n            b -= it->F.S - it->F.F;\n          }else{\n            pair<PI,int> val(mp(it->F.F,it->F.F+b),a);\n            it->F.F=it->F.F+b;\n            it->S=-1;\n            sec[i].insert(it,val);\n            b=0;\n            break;\n          }\n          if(!b) break;\n        }\n        if(!b) break;\n      }\n    }else if(co=='R'){\n      int out=-1;\n      for(int i=sqn-1;i>=0;--i){\n        if(sec[i].empty()) continue;\n        if(sec[i][0].F.F>a) continue;\n        FOR(it,sec[i]) if(it->F.F<=a && a<it->F.S){\n          out=app.count(it->S)?it->S:-1;\n          break;\n        }\n        break;\n      }\n      cout << out << endl;\n    }else app.erase(a);\n  }\n  cout << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<map>\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define pb push_back\n#define eb emplace_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> pi4;\n\nint dist[55][55][55][55],dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate<typename T> ostream& operator<<(ostream& os, vector<T> &v){\n  cout<<\"{\";\n  rep(i,v.size())os<<v[i]<<\",\"<<endl;cout<<\"}\"<<endl;\n  return os;\n}\ntemplate<typename T,typename S> ostream& operator<<(ostream& os, pair<T,S> &v){\n  os<<\"(\"<<v.X<<\",\"<<v.Y<<\")\";\n  return os;\n}\n\nint main(){\n  int n;\n  while(cin>>n){\n    if(!n)break;\n    map<int,pii> mp;\n    rep(i,n){\n      string str;\n      cin>>str;\n      char c=str[0];\n      if(c=='W'){\n\tint m,l,pre=0;\n\tcin>>m>>l;\n\t//cout<<m<<\",\"<<l;\n\tvector<pii> ad;\n\tfor(auto it=mp.begin(); it!=mp.end(); ++it){\n\t  if(pre!=it->X){\n\t    int d=min(l,it->X-pre);\n\t    ad.eb(pre,pre+d);\n\t    l-=d;\n\t  }\n\t  pre=it->Y.X;\n\t}\n\tif(l)\n\t  ad.eb(pre,pre+l);\n\t//cout<<ad;\n\trep(i,ad.size())\n\t  mp[ad[i].X]=pii(ad[i].Y,m);\n      }else if(c=='D'){\n\tint m;\n\tcin>>m;\n\t//cout<<m<<endl;\n\tmap<int,pii> tmp=mp;\n\tmp.clear();\n\tfor(auto it=tmp.begin();it!=tmp.end();++it){\n\t  if(it->Y.Y!=m)\n\t    mp[it->X]=it->Y;\n\t}\n      }else{\n\tint m;\n\tcin>>m;\n\tauto it=mp.upper_bound(m);\n\tif(it==mp.begin()){\n\t  cout<<-1<<endl;\n\t}else{\n\t  --it;\n\t  //cout<<*it<<endl;\n\t  if(it->X < m && m <= it->Y.X){\n\t    cout<<it->Y.Y<<endl;\n\t  }else{\n\t    cout<<-1<<endl;\n\t  }\n\t}\n      }\n    }cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define MAX 100000000\nbool array[MAX];\n\nstruct Data{\n  int L;\n  vector<int> S, G;\n};\n\nmap<int, Data> file;\n\nvoid Write(int n, int l, int s){\n  memset(array, false, sizeof(array));\n  map<int, int> len;\n\n  for(map<int, Data>::iterator it = file.begin() ; it != file.end() ; it++){\n    for(int i = 0 ; i < it->second.S.size() ; i++){\n      array[it->second.S[i]] = true;\n      array[it->second.G[i]] = true;\n      len[it->second.S[i]] = it->second.G[i] - it->second.S[i];\n    }\n  }\n    \n  int _s, _g;\n  bool flag = false;\n  \n  vector<int> ss, gg;\n  \n  for(int i = 0 ; s >= 0 ; i++){\n    if(s == 0){\n      _g = i-1;\n      ss.push_back(_s);\n      gg.push_back(_g);\n      break;\n    }\n    else if(array[i] && flag){\n      _g = i;\n      flag = false;\n      ss.push_back(_s);\n      gg.push_back(_g);\n      i += len[i];\n    }\n    else if(array[i] && !flag){\n      i += len[i];\n    }\n    \n    else if(!array[i] && !flag){\n      _s = i;\n      s--;\n      flag = true;\n    }\n    else{\n      s--;\n    }\n  }\n      \n  Data tmp;\n  tmp.S = ss;\n  tmp.G = gg;\n  tmp.L = l;\n  \n  file[n] = tmp;\n  return;\n}\n\nvoid Deletion(int l){\n  file.erase(l);\n}\n\nvoid Ref(int p){\n  for(map<int, Data>::iterator it = file.begin() ; it != file.end() ; it++){\n    for(int i = 0 ; i < it->second.S.size() ; i++){\n      if(it->second.S[i] <= p && p <= it->second.G[i]){\n\tcout << it->second.L << endl;\n\treturn;\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\nvoid display(){\n  for(map<int, Data>::iterator it = file.begin() ; it != file.end() ; it++){\n    cout << it->first << endl;\n    for(int i = 0 ; i < it->second.S.size() ; i++){\n      cout << it->second.S[i] << ' ' << it->second.G[i] << endl;\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  int n, L, S, P;\n  char op;\n  \n  while(cin >> n, n){\n    int cnt = 0;\n    for(int i = 0 ; i < n ; i++){\n      cin >> op;\n      if(op == 'W'){\n\tcin >> L >> S;\n\tWrite(cnt, L, S);\n\tcnt++;\n      }\n      else if(op == 'D'){\n\tcin >> L;\n\tDeletion(L);\n      }\n      else if(op == 'R'){\n\tcin >> P;\n\tRef(P);\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n      prev=pres;\n      pres=pres->next;\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=prev->end+tmp;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    } \n  }\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  //cout<<\"read!\\n\";\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i)\n      prev->next=pres->next;\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm* next;\n  if(begin==NULL) return;\n  next=begin->next;\n  delete begin;\n  reset(next);\n}\nvoid debug(newrm* begin){\n  while(begin!=NULL){\n    cout<<begin->start<<\" \"<<begin->end<<endl;\n    begin=begin->next;\n  }\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    if(N==0) break;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      if(com=='B')\n\tdebug(begin);\n    }\n    //  reset(begin);\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <list>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nstruct T{\n\tint a, s, e;\n};\n\nint n;\nlist<T> f;\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tchar w;\n\t\t\tint a;\n\t\t\tscanf(\" %c%d\", &w, &a);\n\n\t\t\tif(w == 'W'){\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\n\t\t\t\tfor(auto it = f.begin(); it != f.end(); ++it){\n\t\t\t\t\tif(it->a == -1 && c > 0){\n\t\t\t\t\t\tc -= (it->e - it->s);\n\t\t\t\t\t\tif(c < 0){\n\t\t\t\t\t\t\tf.insert(it, T{a, it->s, it->e + c});\n\t\t\t\t\t\t\tit->s = it->e + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tit->a = a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c > 0){\n\t\t\t\t\tf.push_back(T{a, f.back().e, f.back().e + c});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(w == 'D'){\n\t\t\t\tfor(auto it = f.begin(); it != f.end(); ++it){\n\t\t\t\t\tif(it->a == a){\n\t\t\t\t\t\tit->a = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(w == 'R'){\n\t\t\t\tbool b = false;\n\t\t\t\tfor(auto it = f.begin(); it != f.end(); ++it){\n\t\t\t\t\tif(a < it->e){\n\t\t\t\t\t\tprintf(\"%d\\n\", it->a);\n\t\t\t\t\t\tb = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!b){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf.clear();\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size < S) {\n              S -= v[i].size;\n            } else if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v.insert(v.begin()+i, (Data){r, -2});\n            }\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(int i = 0, sum = 0; output == -1 && i < v.size();\n            sum += v[i].size, ++i) {\n          if(sum <= P && P < sum+v[i].size) {\n            output = v[i].id;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nvector<vector<pii>> v;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tv.clear();\n\t\tv.resize(1);\n\t\tv[0].push_back(pii(0, INF));\n\t\tvi index;\n\t\tindex.push_back(-1);\n\t\tREP(i, n)\n\t\t{\n\t\t\tchar c; int q;\n\t\t\tcin >> c >> q;\n\t\t\tif (c == 'W')\n\t\t\t{\n\t\t\t\tindex.push_back(q);\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tvector<pii> emp;\n\t\t\t\tv.push_back(emp);\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int j = 0;; j++)\n\t\t\t\t{\n\t\t\t\t\tif (v[0][j].second - v[0][j].first >= t)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(pii(v[0][j].first,v[0][j].first+t));\n\t\t\t\t\t\tif (v[0][j].second - v[0][j].first == t) cnt++;\n\t\t\t\t\t\telse v[0][j].first += t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(v[0][j]);\n\t\t\t\t\t\tt -= v[0][j].second - v[0][j].first;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[0].erase(v[0].begin(), v[0].begin() + cnt);\n\t\t\t}\n\t\t\telse if (c == 'D')\n\t\t\t{\n\t\t\t\tint p = find(ALL(index), q)-index.begin();\n\t\t\t\tv[0].insert(v[0].end(),ALL(v[p]));\n\t\t\t\tv[p].erase(ALL(v[p]));\n\t\t\t\tsort(ALL(v[0]));\n\t\t\t\tbool up = true;\n\t\t\t\twhile (up)\n\t\t\t\t{\n\t\t\t\t\tup = false;\n\t\t\t\t\tREP(i, v[0].size() - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (v[0][i].second == v[0][i + 1].first)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tup = true;\n\t\t\t\t\t\t\tv[0][i] = v[0][i + 1] = pii(v[0][i].first, v[0][i + 1].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tauto a = unique(ALL(v[0]));\n\t\t\t\tv[0].erase(a, v[0].end());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, v.size())\n\t\t\t\t{\n\t\t\t\t\tREP(j, v[i].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (q >= v[i][j].first&&q < v[i][j].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (i == 0) puts(\"-1\");\n\t\t\t\t\t\t\telse cout << index[i] << endl;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main(){\n\twhile(1){\n\t\tstd::vector<int>v(1,-1);\n\t\tint a;\n\t\tstd::cin>>a;\n\t\tif(a==0)break;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tchar x;\n\t\t\tint p,q;\n\t\t\tstd::cin>>x;\n\t\t\tif(x=='W'){\n\t\t\t\tstd::cin>>p>>q;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==-1)v[j]=p,q--;\n\t\t\t\t\tif(q==0)break;\n\t\t\t\t\twhile(j==v.size()-1&&q!=0)v.push_back(p),q--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x=='D'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==p)v[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(x=='R'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tif(p-1>v.size())std::cout<<\"-1\"<<std::endl;\n\t\t\t\telse std::cout<<v[p-1]<<std::endl;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define size_of(a) (int)a.size()\n\ntypedef pair< int, int > Seg;\n\nint N, n;\nmap< int, int > ftoi, itof;\nvector< Seg > segs, fseg[10010];\n\nvoid _write_() {\n\tint l, S; cin >> l >> S;\n\tftoi[l] = n;\n\titof[n] = l;\n\t\n\tvector< Seg > new_segs;\t\n\t\n\tfor_(i,0,size_of(segs)) {\n\t\tif (S) {\n\t\t\tint w = segs[i].second - segs[i].first;\n\t\t\n\t\t\tif (w <= S) {\n\t\t\t\tS -= w;\n\t\t\t\tfseg[n].push_back(segs[i]);\n\t\t\t} else {\n\t\t\t\tfseg[n].push_back(Seg(segs[i].first, segs[i].first + S - 1));\n\t\t\t\tnew_segs.push_back(Seg(segs[i].first + S, segs[i].second));\n\t\t\t\tS = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tnew_segs.push_back(segs[i]);\n\t\t}\n\t}\n\t\n\tsegs = new_segs;\n\t\n\t++n;\n}\n\nvoid _delete_() {\n\tint l; cin >> l;\n\tint f = ftoi[l];\n\t\n\tfor_(i,0,size_of(fseg[f])) {\n\t\tsegs.push_back(fseg[f][i]);\n\t}\n\t\n\tfseg[f].clear();\n\t\n\tsort(segs.begin(), segs.end());\n}\n\nvoid _read_() {\n\tint p; cin >> p;\n\t\n\tfor_(i,0,n) {\n\t\tfor_(j,0,size_of(fseg[i])) {\n\t\t\tif (fseg[i][j].first <= p && p <= fseg[i][j].second) {\n\t\t\t\tcout << itof[i] << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nint main() {\t\n\twhile (cin >> N, N) {\n\t\tn = 0;\n\t\tftoi.clear();\n\t\titof.clear();\n\t\t\n\t\tsegs.clear();\n\t\tsegs.push_back(Seg(0, (int)1e9));\n\t\t\n\t\tfor_(i,0,N) fseg[i].clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tchar c; cin >> c;\n\t\t\tswitch (c) {\n\t\t\tcase 'W':\n\t\t\t\t_write_();\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t_delete_();\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t_read_();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n    int N;\n    while(1){\n        cin >> N;\n        if(!N) return 0;\n        vector<char> c(N);\n        vector<P> v;\n        for (int i = 0; i < N; i++) {\n            cin >> c[i];\n            if(c[i]=='W'){\n                LL x,y;cin >> x >> y;\n                v.pb(mp(x,y));\n            }\n            else if(c[i]=='D'){\n                LL x;cin >> x;\n                v.pb(mp(x,-1));\n            }\n            else if(c[i]=='R'){\n                LL x;cin >> x;\n                x++;\n                v.pb(mp(-1,-1));\n                LL ans=-1,t=0;\n                map<LL,LL> ma;\n                for (int j = 0; j < i; j++) {\n                    if(c[j]=='W'){\n                        if(t+v[j].sc<=x){\n                            t+=v[j].sc;\n                            ma[v[j].fs]+=v[j].sc;\n                        }\n                        else{\n                            ma[v[j].fs]+=x-t;\n                            t=x;\n                        }\n                        if(ans==-1&&x==t){\n                            ans=v[j].fs;\n                        }\n                    }\n                    else if(c[j]=='D'){\n                        t-=ma[v[j].fs];\n                        ma[v[j].fs]=0;\n                        if(ans==v[j].fs){\n                            ans=-1;\n                        }\n                    }\n                }\n                cout << ans << endl;\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define B begin()\n#define Y second\n#define E end()\n#define X first\n#define M (1e9)\nusing namespace std;\nmap<int,int>::iterator p;\nmap<int,int> m;\n\nint Read(int x){\n  for(p=m.B;p!=m.E;p++)\n    if(x<=(*p).X)return (*p).Y;\n}\n\nvoid Del(int x){\n  for(p=m.B;p!=m.E;p++)\n    if((*p).Y==x)(*p).Y=-1;\n}\n\nvoid Write(int x,int y){\n  int s=-1;\n  for(p=m.B;p!=m.E;p++){\n    if(!y)return;\n    if((*p).Y!=-1){\n      s=(*p).X;\n      continue;\n    }\n    if((*p).X-s>=y)m[s+y]=x,y=0;\n    else y-=(*p).X-s,(*p).Y=x;\n    s=(*p).X;\n  }\n}\n\nint main(){\n  int n,a,b,f=0;\n  string s;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    if(f++)cout<<endl;\n    m.clear();\n    m[M]=-1;\n    while(n--){\n      cin>>s;\n      if(s==\"R\")cin>>a,cout<<Read(a)<<endl;\n      if(s==\"D\")cin>>a,Del(a);\n      if(s==\"W\")cin>>a>>b,Write(a,b);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp a;\n\t\tvip b;\n\t\ta.pb(pii(0,1000000007));\n\t\twhile(n--){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='R'){\n\t\t\t\tint r;cin>>r;\n\t\t\t\tbool h=false;\n\t\t\t\trep(i,b.size())if(b[i].second.first<=r&&r<b[i].second.second){\n\t\t\t\t\th=true;\n\t\t\t\t\tcout<<b[i].first<<endl;\n\t\t\t\t}\n\t\t\t\tif(!h)cout<<-1<<endl;\n\t\t\t}else if(c=='D'){\n\t\t\t\tint r;cin>>r;\n\t\t\t\trep(i,b.size())if(b[i].first==r){\n\t\t\t\t\ta.pb(b[i].second);\n\t\t\t\t\tb.erase(b.begin()+i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint s,t;\n\t\t\t\tcin>>s>>t;\n\t\t\t\trep(i,a.size()){\n\t\t\t\t\tif(t==0)break;\n\t\t\t\t\tint r=min(t,a[i].second-a[i].first);\n\t\t\t\t\tb.pb(pip(s,pii(a[i].first,a[i].first+r)));\n\t\t\t\t\tt-=r;\n\t\t\t\t\ta[i].first+=r;\n\t\t\t\t\tif(a[i].first==a[i].second){\n\t\t\t\t\t\ta.erase(a.begin()+i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(a));\n\t\t\tsort(all(b));\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.*;\n\npublic class Main\n{\n\n  \n\n    public static void main(String args[])\n    {\n\tScanner in = new Scanner(System.in);\n\tint N;\n\twhile(true)\n\t    {\n\t\tN = in.nextInt();\n\t\tif(N == 0)break;\n\t\tLinkedList<P> list = new LinkedList<P>();\n\t\tlist.add(new P(0,0,-1));\n\n\t\tString c;\n\t\tint I,S;\n\t\tfor(int i=0;i<N;i++)\n\t\t    {\n\t\t\tc = in.next();\n\t\t\tif(c.equals(\"W\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tS = in.nextInt();\n\t\t\t\tfor(int j=0;j<list.size()-1;j++)\n\t\t\t\t    {\t\n\t\t\t\t\tint v1 = list.get(j).r;\n\t\t\t\t\tint v2 = list.get(j+1).l;\n\t\t\t\t\tif(v1 == v2)continue;\n\t\t\t\t\t//System.out.println(\"add ! \" + j + \" \" + v1 + \" \" + v2);\n\t\t\t\t\tlist.add(j+1,new P(v1,Math.min((v2-v1)+v1,v1+S),I) ); \n\t\t\t\t\tS -= (v2-v1);\n\t\t\t\t\tif(S < 0)S = 0;\n\n\t\t\t\t\tif(S == 0)break;\n\t\t\t\t    }\n\t\t\t\tif(S != 0)\n\t\t\t\t    {\n\n\t\t\t\t\t\tint lass = (list.size()-1 >= 0?list.get(list.size()-1).r:0);\n\t\t\t\t\t\tlist.add(new P(lass,lass+S,I));\n\n\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t    }\n\t\t\telse if(c.equals(\"D\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tint v = list.get(j).id;\n\t\t\t\t\tif(v == I)\n\t\t\t\t\t    {\n\t\t\t\t\t\tP p = list.remove(j);\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tboolean found = false;\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tP p = list.get(j);\n\t\t\t\t\tif(p.l <= I && I < p.r)\n\t\t\t\t\t    {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tSystem.out.println(p.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\tif(!found)System.out.println(-1);\n\t\t\t    }\n\t\t\t/*\n\t\t\tSystem.out.println(\"------------\");\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tSystem.out.println(list.get(j).l + \" - \" +list.get(j).r + \" : \" + list.get(j).id);\n\t\t\t    }\n\t\t\tSystem.out.println(\"------------\");\n\t\t\t*/\n\t\t    }\n\t    }\n    }\n}\n\nclass P\n{\n    public int r,l,id;\n    P(int rl,int rr,int rid)\n    {\n\tr = rr;\n\tl = rl;\n\tid = rid;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nstruct Data {\n\tint  num, pos, len;\n};\ntypedef pair<int, int> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tmap<int, Data> datamap; //[pos]->Data\n\t\tmap<int, vector<Data> > nummap;  //[num]->vec<idx>\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P{ 0, int(1e9 + 1) });\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tchar op;\n\t\t\tcin >> op;\n\t\t\tif(op == 'W') {\n\t\t\t\tint num, len;\n\t\t\t\tcin >> num >> len;\n\t\t\t\twhile(len > 0) {\n\t\t\t\t\tP p = q.top();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tData d{ num, p.first, len };\n\t\t\t\t\tif(p.second >= len) {\n\t\t\t\t\t\tif(p.second > len)\n\t\t\t\t\t\t\tq.push(P(p.first + len, p.second - len));\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.second < len) {\n\t\t\t\t\t\td.len = p.second;\n\t\t\t\t\t\tlen -= p.second;\n\t\t\t\t\t}\n\t\t\t\t\tdatamap[d.pos] = d;\n\t\t\t\t\tnummap[num].push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op == 'D') {\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\tfor(const Data& d : nummap[num]) {\n\t\t\t\t\tdatamap.erase(d.pos);\n\t\t\t\t\tq.push(P(d.pos, d.len));\n\t\t\t\t}\n\t\t\t\tnummap[num].clear();\n\t\t\t}\n\t\t\telse {// 'R'\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tif(datamap.upper_bound(pos) == datamap.end()) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tauto it = datamap.upper_bound(pos);\n\t\t\t\t\t--it;\n\t\t\t\t\tData d = it->second;\n\t\t\t\t\tif(d.pos <= pos && pos < d.pos + d.len) {\n\t\t\t\t\t\tcout << d.num << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nstruct state{\n\tint b,e,t;\n\tstate(int _b,int _e,int _t){\n\t\tb=_b,e=_e,t=_t;\n\t}\n};\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<state> files;\n\t\tstate init(0,1000000000,-1);\n\t\tfiles.pb(init);\n\t\trep(i,n){\n\t\t\tchar mode;\n\t\t\tcin >> mode;\n\t\t\tif(mode=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tcin >> l >> s;\n\t\t\t\trep(i,files.size()){\n\t\t\t\t\tif(files[i].t==-1&&s>0){\n\t\t\t\t\t\tint fs=(files[i].e-files[i].b)+1;\n\t\t\t\t\t\tif(s>=fs)\n\t\t\t\t\t\t\tfiles[i].t=l,s-=fs;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tstate newfile(files[i].b+s,files[i].e,files[i].t);\n\t\t\t\t\t\t\tfiles[i].e=files[i].b+s-1,files[i].t=l,s=0;\n\t\t\t\t\t\t\tfiles.insert(files.begin()+i+1,newfile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(mode=='R'){\n\t\t\t\tint p;\n\t\t\t\tcin >> p;\n\t\t\t\tint ans=-1;\n\t\t\t\trep(i,files.size()) if(files[i].b<=p&&p<=files[i].e) ans=files[i].t;\n\t\t\t\tcout << ans << endl;\n\t\t\t}else{\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\trep(i,files.size()) if(files[i].t==l) files[i].t=-1;\n\t\t\t}\n\t\t\t//for(auto &i:files){\n\t\t\t//\tcout << i.b << \" \" << i.e << \" \" << i.t << endl;\n\t\t\t//}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define ll long long;\n\nconst int INF = 1e9;\nconst long long  LLINF = 1e15;\n\nusing namespace std;\n\nint N;\n //<(????§???????????????????(0~), ????????????????????????), ???>\npair< pair<int, int>, int > disk[20005];\n\nint main() {\n  while(1){\n    cin>>N;\n    if(N==0) break;\n    REP(i,0,20005) disk[i] = make_pair(make_pair(INF,INF), INF);\n    disk[0] = make_pair(make_pair(0,1000000001), -1);  //-1:empty\n    REP(i,0,N){\n      string com, inp1, inp2;\n      int num, len, ind;\n      cin>>com;\n      if(com==\"W\"){ /*?????????*/\n        cin>>inp1>>inp2;\n        num = stoi(inp1);\n        len = stoi(inp2);\n        REP(k,0,20005){\n          if(len==0) break;\n          if(disk[k].S == -1){\n            int tl = disk[k].F.S-disk[k].F.F+1;\n            if(len >= tl){\n              disk[k].S = num;\n              len -= tl;\n            }else{\n              //??°????´???????\n              int tmp = disk[k].F.F;\n              disk[k].F.F = disk[k].F.F+len;\n              RREP(l,k+1,20005){\n                disk[l] = disk[l-1];\n              }\n              disk[k] = make_pair(make_pair(tmp, tmp+len-1), num);\n              len = 0;\n            }\n          }\n        }\n      }else if(com==\"D\"){ /*??????*/\n        cin>>inp1;\n        num = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].S==num) disk[k].S = -1;\n        }\n      }else{ /*????????????*/\n        cin>>inp1;\n        ind = stoi(inp1);\n        REP(k,0,20005){\n          if(disk[k].F.F <= ind && ind <= disk[k].F.S){\n            cout<<disk[k].S<<endl;\n            break;\n          }\n        }\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tvector<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v[0].p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min(v[0].p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= v[0].p.second + 1;\n\t\t\t\t}\n\t\t\t\trep(i, v.size() - 1) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tif (v[i].p.second + 1 < v[i + 1].p.first) {\n\t\t\t\t\t\tv.insert(v.begin() + i + 1, { P(v[i].p.second + 1, min(v[i + 1].p.second - 1, v[i].p.first + b - 1)),a });\n\t\t\t\t\t\tb -= v[i + 1].p.second - v[i + 1].p.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P(v[v.size() - 1].p.second + 1, b + v[v.size() - 1].p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\trep(i, v.size()) {\n\t\t\t\t\tif (v[i].id == a) {\n\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < v.size() && v[i].p.second < a; i++);\n\t\t\t\tif (i == v.size())puts(\"-1\");\n\t\t\t\telse if (v[i].p.first <= a&&a <= v[i].p.second)printf(\"%d\\n\", v[i].id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nstruct DATA{\n\tint start;\n\tint end;\n\tint fileID;\n\tint next;\n\tDATA(int start, int end, int fileID){\n\t\tthis->start = start, this->end = end, this->fileID = fileID;\n\t}\n};\n\nvector<DATA> data;\n\nvoid Write(int fileID, int file_length)\n{\n\tint prev_i = -1;\n\tint size = (int)data.size();\n\t\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(file_length <= data[i].end - data[i].start + 1){\n\t\t\t\tdata.insert(data.begin() + i, DATA(data[i].start, data[i].start + file_length - 1, fileID));\n\t\t\t\tdata[i+1].start = data[i+1].start + file_length;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tdata[i].fileID = fileID;\n\t\t\t\tfile_length -= data[i].end - data[i].start + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Arrange()\n{\n\tfor(int i = 0; i < (int)data.size()-1; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(data[i+1].fileID == -1){\n\t\t\t\tdata[i].end = data[i+1].end;\n\t\t\t\tdata.erase(data.begin() + (i+1));\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Delete(int fileID)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == fileID) data[i].fileID = -1;\n\t}\n\tArrange();\n}\n\nvoid Reference(int pos)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].end >= pos){\n\t\t\tprintf(\"%d\\n\", data[i].fileID);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint N;\n\tchar com[5];\n\tint op1, op2;\n\t\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdata.push_back( DATA(0, 1000000001, -1) );\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\t\n\t\t\tscanf(\"%s\", com);\n\t\t\tif(strcmp(com, \"W\") == 0){\n\t\t\t\tscanf(\"%d %d\", &op1, &op2);\n\t\t\t\tWrite(op1, op2);\n\t\t\t}else if(strcmp(com, \"D\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tDelete(op1);\n\t\t\t}else if(strcmp(com, \"R\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tReference(op1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,a,b,cnt;\n  char c;\n  int inv[10010];\n  vector<P> v[10010];\n  map<int,int> m;\n\n  bool first = true;\n  while(cin >> n,n){\n    v[0].clear();\n    v[0].push_back(P(0,1000000001));\n    inv[0] = -1;\n    m.clear();\n    m[0] = 0;\n    cnt = 1;\n    \n    while(n--){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tint tmp = m[a] = cnt;\n\tinv[cnt] = a;\n\tcnt++;\n\twhile(b){\n\t  if(b<v[0][0].second){\n\t    v[tmp].push_back(P(v[0][0].first,b));\n\t    v[0][0].first += b;\n\t    v[0][0].second -= b;\n\t    b = 0;\n\t  }else{\n\t    v[tmp].push_back(v[0][0]);\n\t    b -= v[0][0].second;\n\t    v[0].erase(v[0].begin());\n\t  }\n\t} \n      }else if(c == 'D'){\n\tcin >> a;\n\tint tmp = m[a];\n\tfor(int i=0;i<(int)v[tmp].size();i++)v[0].push_back(v[tmp][i]);\n\tsort(v[0].begin(),v[0].end());\n\tv[tmp].clear();\n      }else{\n\tcin >> a;\n\tbool f = true;;\n\tfor(int i=0;i<cnt;i++){\n\t  for(int j=0;j<(int)v[i].size();j++){\n\t    if(v[i][j].first<= a && a<=v[i][j].first+v[i][j].second){\n\t      cout << inv[i] << endl;\n\t      f = false;\n\t      break;\n\t    }\n\t  }\n\n\t  if(!f)break;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//30min\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    vector<int> M(1,-1);\n    for(int j=0;j<N;j++){\n      char command;\n      int i,s,p;\n      int index;\n      cin >> command;\n      switch(command){\n      case 'W':\n\tcin >> i >> s;\n\tindex=0;\n\twhile(s>0){\n\t  if(index>=M.size()){\n\t    M[index]=i;\n\t    s--;\n\t  }else if(M[index]==-1){\n\t    M[index]=i;\n\t    s--;\n\t  }\n\t  index++;\n\t}\n\tbreak;\n      case 'D':\n\tcin >> i;\n\tfor(int k=0;k<M.size();k++){\n\t  if(M[k]==i) M[k]=(-1);\n\t}\n\tbreak;\n      case 'R':\n\tcin >> p;\n\tif(p<M.size()) cout << M[p] << endl;\n\telse cout << \"-1\" << endl;\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t2152: Restrictive Filesystem\n*/\n#include\t<iostream>\n#include\t<vector>\n#include\t<utility>\n#include\t<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P_ii;\n\nclass datlst {\nprivate:\n\tvector<P_ii> lst;\n\tint\t\tendOfSect;\npublic:\n\tvoid push_file(int, int);\n\tvoid erase_file(int);\n\tvoid initialing_list(void);\n\tint show_file(int);\n};\n\nvoid datlst::push_file(int ident, int count) {\n\tint\t\tctSector;\n\tbool\tflagHit;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (lst.empty()) {\n\t\t\tlst.push_back(P_ii(0, ident));\n\t\t\tendOfSect ;\n\t\t} else {\n\t\t\tvector<P_ii>::iterator it = lst.begin();\n\t\t\tctSector = 0;\n\t\t\tflagHit = true;\n\t\t\twhile (it != lst.end()) {\n\t\t\t\tif (it->second == -1) {\n\t\t\t\t\tit->first = ctSector;\n\t\t\t\t\tit->second = ident;\n\t\t\t\t\tflagHit = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctSector++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tif (flagHit) {\n\t\t\t\tlst.push_back(P_ii(++ctSector, ident));\n\t\t\t\tendOfSect++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid datlst::erase_file(int ident) {\n\tvector<P_ii>::iterator it = lst.begin();\n\twhile (it != lst.end()) {\n\t\tif (it->second == ident) {\n\t\t\tit->second = -1;\n\t\t}\n\t\tit++;\n\t}\n}\n\nvoid datlst::initialing_list(void) {\n\tlst.clear();\n\tendOfSect = -1;\n}\n\nint datlst::show_file(int sector) {\n\tif (sector >= endOfSect) { return -1; }\n\treturn lst[sector].second;\n\t/*\n\tvector<P_ii>::iterator it = lst.begin();\n\twhile (it != lst.end()) {\n\t\tif (it->first == sector) {\n\t\t\treturn it->second;\n\t\t\tbreak;\n\t\t}\n\t\tit++;\n\t}\n\t*/\n\treturn -1;\n}\n\nint main(void) {\n\tint\t\tN, f, s;\n\tchar\tc;\n\tdatlst DataList;\n\twhile (1) {\n\t\tDataList.initialing_list();\n\t\tcin >> N;\n\t\tif (N == 0) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> c;\n\t\t\tswitch (c) {\n\t\t\tcase 'W':\n\t\t\t\tcin >> f >> s;\n\t\t\t\tDataList.push_file(f, s);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> f;\n\t\t\t\tDataList.erase_file(f);\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> f;\n\t\t\t\tcout << DataList.show_file(f) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n  int num,n,s,p,r;\n  char c;\n  while(true){\n    cin >> num;\n    if (num == 0)\n      break;\n    vector<pair<int,int> >cut;\n    cut.push_back(make_pair((int) 1e9+1,-1));\n    for(int i=0;i<num;i++){\n      cin >> c;\n      switch(c){\n      case 'W':\n\tcin >> n >> s;\n\tfor(int j=0;s>0;j++){\n\t  if (cut[j].second == -1){\n\t    if (cut[j].first >= s){\n\t      cut[j].first -= s;\n\t      cut.insert(cut.begin()+j,make_pair(s,n));\n\t      s=0;\n\t    }\n\t    else if(j==cut.size()){\n\t      s=0;\n\t    }\n\t    else{\n\t      s -= cut[j].first;\n\t      cut[j].second = n;\n\t    }\n\t  }\n\t}\n\tbreak;\n\t\n      case 'D':\n\tcin >> p;\n\tfor(int a=0;a<cut.size();a++)\n\t  if(cut[a].second == p)\n\t    cut[a].second = -1;\n\tbreak;\n\t\n      case 'R':\n\tcin >> r;\n\tint sum = 0;\n\tfor(int a=0;a<cut.size();a++){\n\t  sum += cut[a].first;\n\t  if(sum > r){\n\t    cout << cut[a].second << endl;\n\t    break;\n\t  }\n\t}\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(c,c+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({c,c+k-1},n);\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tset<P> emp;\n\t\tset<pair<P,ll>> plt;\n\t\tmap<ll,vector<P>> buf;\n\t\temp.insert(P(0,INF+1));\n\t\tREP(roop,n) {\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W') {\n\t\t\t\tll idt,sec;\n\t\t\t\tcin>>idt>>sec;\n\t\t\t\tbuf[idt]=vector<P>();\n\t\t\t\twhile(sec>0) {\n\t\t\t\t\tP p=*(emp.begin());\n\t\t\t\t\temp.erase(emp.begin());\n\t\t\t\t\tif(p.second-p.first+1>sec) {\n\t\t\t\t\t\tbuf[idt].pb(P(p.first,p.first+sec-1));\n\t\t\t\t\t\tplt.insert(pair<P,ll>(P(p.first,p.first+sec-1),idt));\n\t\t\t\t\t\temp.insert(P(p.first+sec,p.second));\n\t\t\t\t\t\tsec=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf[idt].pb(p);\n\t\t\t\t\t\tplt.insert(pair<P,ll>(p,idt));\n\t\t\t\t\t\tsec-=(p.second-p.first+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D') {\n\t\t\t\tll dlt;\n\t\t\t\tcin>>dlt;\n\t\t\t\tvector<P> vec=buf[dlt];\n\t\t\t\tREP(i,(ll)vec.size()) {\n\t\t\t\t\temp.insert(vec[i]);\n\t\t\t\t\tplt.erase(pair<P,ll>(vec[i],dlt));\n\t\t\t\t}\n\t\t\t\tbuf.erase(dlt);\n\t\t\t}\n\t\t\tif(c=='R') {\n\t\t\t\tll ref;\n\t\t\t\tcin>>ref;\n\t\t\t\tif(plt.empty()) {\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tauto ite=upper_bound(ALL(plt),pair<P,ll>(P(ref,INF*INF),INF*INF));\n\t\t\t\tif(ite==plt.begin()) {\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tite--;\n\t\t\t\tif((*ite).first.first<=ref&&(*ite).first.second>=ref) cout<<(*ite).second<<endl;\n\t\t\t\telse cout<<-1<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int>m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(typeof(m.begin()) it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\ttypeof(m.begin()) it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tpair<int,int> f=make_pair(n,2000000000);\n\t\t\ttypeof(m.begin()) it=m.lower_bound(f);\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(typeof(m.begin()) it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[make_pair(cur,cur+z-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct Data{\n  int start;\n  int end;\n  int data;\n  Data *next;\n  Data *prev;\n};\n\nData buff[20000];\nint  _pos;\n\nData *alloc(){\n  if(_pos == 20000) _pos = 0;\n  return &buff[_pos++];\n}\n\nvoid write(Data *d, int size, int data){\n  if(d == NULL) return;\n  if(d->data != -1){\n    write(d->next, size, data);\n  }else{\n    int sz = d->end - d->start + 1;\n    if(sz > size){\n      //puts(\"test1\");\n      Data *next = alloc();\n      next->end   = d->end;\n      d->end      = d->start + size - 1;\n      next->start = d->end + 1;\n      next->data  = -1;\n      next->prev  = d;\n      next->next  = d->next;\n      d->next     = next;\n      d->data     = data;\n    }else if(sz == size){\n      //puts(\"test2\");\n      d->data = data;\n    }else{\n      //puts(\"test3\");\n      d->data = data;\n      write(d->next, size-sz, data);\n    }\n  }\n}\n\nData *merge(Data *d1, Data *d2){\n  if(d1 == NULL || d2 == NULL) return d2;\n  if(d1->data != d2->data) return d2;\n  d1->end  = d2->end;\n  d1->next = d2->next;\n  return d1;\n}\n\nvoid del(Data *d, int data){\n  while(d != NULL){\n    if(d->data == data){\n      d->data = -1;\n      merge(d->prev, d);\n      merge(d->next, d);\n    }\n    d = d->next;\n  }\n}\n\nint ref(Data *d, int pos){\n  while(d != NULL){\n    if(d->start <= pos && pos <= d->end){\n      return d->data;\n    }\n    d = d->next;\n  }\n  return 0;\n}\n\nvoid print(Data *d){\n  while(d != NULL){\n    printf(\"[%d,%d]: %d\\n\",d->start,d->end,d->data);\n    d = d->next;\n  }\n}\n\nint main(){\n  int n;\n  int cc = 0;\n  while(cin>>n, n){\n    Data *d = alloc();\n    d->start = 0;\n    d->end   = INT_MAX - 1;\n    d->prev  = NULL;\n    d->next  = NULL;\n    d->data  = -1;\n\n    if(cc++ != 0) cout << endl;\n\n    while(n --> 0){\n      char c;\n      cin>>c;\n      if(c == 'W'){\n        int l,data;\n        cin>>data>>l;\n        write(d, l, data);\n      }else if(c == 'R'){\n        int pos;\n        cin>>pos;\n        cout << ref(d, pos) << endl;\n      }else{\n        int data;\n        cin>>data;\n        del(d, data);\n      }\n\n      //print(d);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n        if(n == 0)break;\n        \n        set<P1> S1;\n        set<P1> S2;\n        S1.insert(mp1(0,-1,1000000001));\n        S2.insert(mp1(-1,0,1000000001));\n        \n        for(int i = 0 ; i < n ; i ++){\n            char c;\n            cin >> c;\n            //scanf(\"\\n%c\",&c);\n            if(c == 'W'){\n                int l,s;\n                scanf(\"%d%d\",&l,&s);\n                set<P1>::iterator itr = S2.lower_bound(mp1(-1,0,0));\n                while(1){\n                    if(itr->sc.sc > s){\n                        S1.insert(mp1(itr->sc.fr,l,s));\n                        S1.insert(mp1(itr->sc.fr+s,itr->fr,itr->sc.sc-s));\n                        S1.erase(mp1(itr->sc.fr,itr->fr,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,s));\n                        S2.insert(mp1(itr->fr,itr->sc.fr+s,itr->sc.sc-s));\n                        S2.erase(itr);\n                        break;\n                    }\n                    else {\n                        S1.insert(mp1(itr->sc.fr,l,itr->sc.sc));\n                        S1.erase(mp1(itr->sc.fr,-1,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,itr->sc.sc));\n                        s -= itr->sc.sc;\n                        S2.erase(itr++);\n                    }\n                    if(s == 0)break;\n                }\n            }\n            else if(c == 'D'){\n                int l;\n                scanf(\"%d\",&l);\n                set<P1>::iterator itr = S2.lower_bound(mp1(l,0,0));\n                while(1){\n                    S1.insert(mp1(itr->sc.fr,-1,itr->sc.sc));\n                    S1.erase(mp1(itr->sc.fr,l,itr->sc.sc));\n                    S2.insert(mp1(-1,itr->sc.fr,itr->sc.sc));\n                    S2.erase(itr++);\n                    if(itr->fr != l)break;\n                }\n            }\n            else {\n                int p;\n                scanf(\"%d\",&p);\n                set<P1>::iterator itr = S1.upper_bound(mp1(p+1,-1,0));\n                printf(\"%d%c\",(--itr)->sc.fr,10);\n            }\n        }\n        printf(\"%c\",10);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nint n;\n\nvector<pair<int, int>> seg;\n\nvoid init() {\n  seg = {{-1, inf}};\n}\n\nvoid solve() {\n  while (n--) {\n    char c;\n    cin >> c;\n\n    if (c == 'W') {\n      int id, s;\n      cin >> id >> s;\n\n      int left = 0;\n      rep(i, seg.size()) {\n        if (seg[i].first != -1) {\n          left = seg[i].second;\n          continue;\n        }\n        if (s >= seg[i].second - left) {\n          seg[i].first = id;\n          s -= seg[i].second - left;\n        }\n        else {\n          seg.insert(seg.begin() + i + 1, seg[i]);\n          seg[i] = {id, left + s};\n          s = 0;\n        }\n        left = seg[i].second;\n        if (!s) break;\n      }\n    }\n    else if (c == 'D') {\n      int id;\n      cin >> id;\n      rep(i, seg.size()) {\n        if (seg[i].first == id) seg[i].first = -1;\n      }\n    }\n    else {\n      int p;\n      cin >> p;\n\n      int left = 0;\n      rep(i, seg.size()) {\n        if (left <= p && p < seg[i].second) {\n          cout << seg[i].first << '\\n';\n          break;\n        }\n      }\n    }\n  }\n  //rep(i, seg.size()) cout << seg[i].first << ' ' << seg[i].second << '\\n';\n  cout << '\\n';\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  while (cin >> n, n) {\n    init();\n    solve();\n  }\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii, int> piii;\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    set<piii> se;               // piii(pii(a, b), c) -> [a,b) É c ªÍ¢ÁÄéB\n    REP(i,n) {\n      char c;\n      cin >> c;\n      if (c=='W') {\n        int a,m;\n        cin>>a>>m;\n        vector<piii> tmp;\n        int pre = 0;\n        FOR(it, se) {\n          if (m == 0) break;\n          pii p=it->first;\n          if (p.first > pre) {\n            int hoge = min(m, p.first-pre);\n            tmp.push_back(piii(pii(pre, pre+hoge), a));\n            m -= hoge;\n          }\n          pre = p.second;\n        }\n        if (m) {\n          tmp.push_back(piii(pii(pre, pre+m), a));\n        }\n        se.insert(ALL(tmp));\n      } else if (c == 'D') {\n        int a;\n        cin >> a;\n        set<piii> tmp;\n        FOR(it, se) {\n          if(it->second != a)\n            tmp.insert(*it);\n        }\n        se = tmp;\n      } else {\n        int m;\n        cin >> m;\n        int ans = -1;\n        FOR(it, se) {\n          pii p = it->first;\n          if (p.first<=m && m<p.second) {\n            ans = it->second;\n            break;\n          }\n        }\n        cout << ans << endl;\n      }\n       // cout << \"i = \" << i << endl;\n       // FOR(it, se) {\n       //   pii p =  it->first;\n       //   printf(\"(%d,%d),%d \", p.first,p.second,it->second);\n       // }\n       // cout << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nstruct Data{\n\tchar com;\n\tint idx;\n\tint len;\n};\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\n\t\tvector<Data> d(n);\n\t\tvector<int> r;\n\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\n\t\t\tint a, b = -1;\n\t\t\tif(c == 'W'){\n\t\t\t\tcin >> a >> b;\n\t\t\t}else{\n\t\t\t\tcin >> a;\n\t\t\t}\n\n\t\t\td[i] = Data{c,a,b};\n\t\t\tif(c == 'R') r.emplace_back(i);\n\t\t}\n\n\t\trep(i,r.size()){\n\t\t\tint cnt = 0;\n\t\t\tint p = -1;\n\t\t\tint idx = d[r[i]].idx;\n\t\t\tmap<int,int> ma;\n\t\t\trep(j,r[i]){\n\t\t\t\t//cout << cnt << ' ' << p << endl;\n\t\t\t\tif(d[j].com == 'W'){\n\t\t\t\t\tint add = min(idx - cnt, d[j].len);\n\t\t\t\t\tma[d[j].idx] = add;\n\n\t\t\t\t\tif(p == -1 and cnt < idx and cnt + add == idx){\n\t\t\t\t\t\tp = d[j].idx;\n\t\t\t\t\t}\n\n\t\t\t\t\tcnt += add;\n\t\t\t\t}else if(d[j].com == 'D'){\n\t\t\t\t\tif(p == d[j].idx) p = -1;\n\t\t\t\t\tcnt -= ma[d[j].idx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << p << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,a,b,cnt;\n  char c;\n  int inv[10010];\n  vector<P> v[10010];\n  map<int,int> m;\n\n  bool first = true;\n  while(cin >> n,n){\n    v[0].clear();\n    v[0].push_back(P(0,1000000001));\n    inv[0] = -1;\n    m.clear();\n    m[0] = 0;\n    cnt = 1;\n    \n    while(n--){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tint tmp = m[a] = cnt;\n\tinv[cnt] = a;\n\tcnt++;\n\twhile(b){\n\t  if(b<v[0][0].second){\n\t    v[tmp].push_back(P(v[0][0].first,b));\n\t    v[0][0].first += b;\n\t    v[0][0].second -= b;\n\t    b = 0;\n\t  }else{\n\t    v[tmp].push_back(v[0][0]);\n\t    b -= v[0][0].second;\n\t    v[0].erase(v[0].begin());\n\t  }\n\t} \n      }else if(c == 'D'){\n\tcin >> a;\n\tint tmp = m[a];\n\tfor(int i=0;i<(int)v[tmp].size();i++)v[0].push_back(v[tmp][i]);\n\tsort(v[0].begin(),v[0].end());\n\tv[tmp].clear();\n      }else{\n\tcin >> a;\n\tbool f = true;;\n\tfor(int i=0;i<cnt;i++){\n\t  for(int j=0;j<(int)v[i].size();j++){\n\t    if(v[i][j].first<= a && a<v[i][j].first+v[i][j].second){\n\t      cout << inv[i] << endl;\n\t      f = false;\n\t      break;\n\t    }\n\t  }\n\n\t  if(!f)break;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint n;\n\nvoid solve(){\n  int sqn=sqrt(n)+2;\n  vector<pair<PI,int> > sec[sqn];\n  set<int> app;\n  sec[0].pb(mp(mp(0,1000000000+10),-1));\n  rep(iii,n){\n    char co;\n    int a,b;\n    cin >> co >> a;\n    if(iii%sqn==0){\n      \n    }\n    \n    if(co=='W'){\n      cin >> b;\n      app.insert(a);\n      rep(i,sqn){\n        FOR(it,sec[i]){\n          if(app.count(it->S)) continue;\n          if(it->F.S-it->F.F<=b){\n            it->S=a;\n            b -= it->F.S - it->F.F;\n          }else{\n            pair<PI,int> val(mp(it->F.F,it->F.F+b),a);\n            it->F.F=it->F.F+b;\n            it->S=-1;\n            sec[i].insert(it,val);\n            b=0;\n            break;\n          }\n          if(!b) break;\n        }\n        if(!b) break;\n      }\n    }else if(co=='R'){\n      int out=-1;\n      for(int i=sqn-1;i>=0;--i){\n        if(sec[i].empty()) continue;\n        if(sec[i][0].F.F>a) continue;\n        FOR(it,sec[i]) if(it->F.F<=a && a<it->F.S){\n          out=app.count(it->S)?it->S:-1;\n          break;\n        }\n        break;\n      }\n      cout << out << endl;\n    }else app.erase(a);\n  }\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int,int>\nusing namespace std;\nint main(){\n    int n;\n    while(cin >> n,n){\n        vector<pii> v;\n        v.emplace_back(make_pair(-1,1000000000));\n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;cin >> i >> s;\n                for(auto it=v.begin();it!=v.end();it++){\n                    if(it->first == -1){\n                        if(s <= it->second){\n                            v.insert(it,make_pair(i,s));\n                            break;\n                        } else {\n                            it->first=i;\n                            s -= it->second;\n                        }\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;cin >> i;\n                for(auto it=v.begin();it!=v.end();it++){\n                    if(it->first == i) it->first = -1;\n                }\n            }\n            if(c == 'R'){\n                int p;cin >> p;\n                int i=0;\n                auto it=v.begin();\n                for(;it!=v.end();it++){\n                    i += it->second;\n                    if(p < i){\n                        cout << it->first << endl;\n                        break;\n                    }\n                }\n                if(it == v.end()) cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n \nint N;\nvector<Data> storage;\n\nvoid dump() {\n  #ifdef DEBUG\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n  #endif\n}\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  sort(storage.begin(), storage.end());\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n\tinto = i;\n\tbreak;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      /*\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      */\n      num = remain;\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nvoid del(int id) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n      #ifdef DEBUG\n      cout << \"Deleted: \" << id << endl;\n      dump();\n      #endif\n    }\n  }\n}\n \nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n\tdump();\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Data {\n  int id, st, num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n \nint N;\nvector<Data> storage;\n \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n\tinto = i;\n\tbreak;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      num = remain;\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nvoid del(int id) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n    }\n  }\n}\n \nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n\t/*\n        for(int i=0; i<storage.size(); i++) {\n          cout << \"storage[\"<<i<<\"]:\" << endl;\n          cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n        }\n\t*/\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct Seg{\n\tint s,e,no;\n\tSeg(){}\n\tSeg(int a,int b,int c):s(a),e(b),no(c){}\n};\n\nvector<Seg> v;\nvoid write(int l,int s){\n\tfor(int i=0;s;i++){\n\t\tif(v[i].no!=-1)continue;\n\t\tint t = v[i].e-v[i].s;\n\t\tif(t<=s){\n\t\t\tv[i].no=l;\n\t\t\ts-=t;\n\t\t}else{\n\t\t\tt = v[i].s;\n\t\t\tv[i].s += s;\n\t\t\tv.insert(v.begin()+i,Seg(t,t+s,l));\n\t\t\ts=0;\n\t\t}\n\t}\n}\nvoid del(int l){\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].no==l){\n\t\t\tv[i].no=-1;\n\t\t}\n\t}\n}\nvoid read(int p){\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].s<=p&&p<v[i].e){\n\t\t\tcout<<v[i].no<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tv.clear();\n\t\tv.push_back(Seg(1,1000000000+1,-1));\n\t\twhile(n--){\n\t\t\tchar com;\n\t\t\tcin>>com;\n\t\t\tif(com=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tcin>>l>>s;\n\t\t\t\twrite(l,s);\n\t\t\t}else if(com=='D'){\n\t\t\t\tint l;\n\t\t\t\tcin>>l;\n\t\t\t\tdel(l);\n\t\t\t}else {\n\t\t\t\tint p;\n\t\t\t\tcin>>p;\n\t\t\t\tread(p);\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll n;\n\ntypedef struct st{\n    ll val,pos,siz;\n    st(ll _val,ll _pos,ll _siz):val(_val),pos(_pos),siz(_siz){}\n    bool operator<(const st &s)const{\n        return pos < s.pos;\n    };\n}ST;\n\nint main(){\n    while(cin >> n && n){\n        vector<ST> v;\n        v.push_back(st(-1,0,1e9));\n        rep(i,n){\n            string s;\n            ll c,siz;\n            cin >> s;\n            if(s == \"W\"){\n                cin >> c >> siz;\n                rep(j,v.size()){\n                    if(v[j].val == -1){\n                        if(v[j].siz < siz){\n                            siz -= v[j].siz;\n                            v[j].val = c;\n                        }\n                        else{\n                            v.push_back(st(-1,v[j].pos+siz,v[j].siz - siz));\n                            v[j].siz = siz;\n                            v[j].val = c;\n                            break;\n                        }\n                    }\n                }\n            }\n            else if(s == \"D\"){\n                cin >> c;\n                rep(j,v.size()){\n                    if(v[j].val == c)v[j].val = -1;\n                }\n            }\n            else{\n                cin >> c;\n                c++;\n                rep(j,v.size()){\n                    c -= v[j].siz;\n                    if(c <= 0){\n                        cout << v[j].val << endl;\n                        break;\n                    }\n                }\n                if(c > 0)cout << -1 << endl;\n            }\n            sort(ALL(v));\n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n// #define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e9 + 7;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                            len = 0;\n                            break;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                    if(len == 0) break;\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<int,lli> P;\n\nconst lli INF = (1LL<<49);\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int a;\n    lli b,cnt;\n    char c;\n    vector<P> v;\n    v.push_back(P(-1,INF));\n    for(int i=0;i<n;i++){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[j].first == -1){\n\t    if(b >= v[j].second){\n\t      v[j].first = a;\n\t      b -= v[j].second;\n\t      if(b == 0) break;\n\t    } else {\n\t      v.insert(v.begin()+j,P(a,b));\n\t      v[j+1].second -= b;\n\t      break;\n\t    }\n\t  }\n\t}\n      } else if(c == 'D'){\n\tcin >> a;\n\tfor(int j=0;j<v.size();j++) if(v[j].first == a) v[j].first = -1;\n      } else if(c == 'R'){\n\t//for(int j=0;j<v.size();j++) cout << v[j].first << ' ' << v[j].second << endl;\n\tcin >> b;\n\tcnt = 0;\n\tfor(int j=0;j<v.size();j++){\n\t  cnt += v[j].second;\n\t  if(cnt > b){\n\t    cout << v[j].first << endl;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int MAXL = 1000000001;\ntypedef pair<int, int> SEG;\ntypedef pair<SEG, int> S;\n//int data[MAXL];\nint main(){\n  int N;\n  while(cin>>N && N){\n    //memset(data, -1, sizeof(data));\n    vector<S> data;\n    data.push_back(S(SEG(-1, 0), -1));\n    REP(time, N){\n      string cmd; cin>>cmd;\n      if(cmd == \"W\"){\n        int l, s; cin>>l>>s;\n        vector<S> add;\n        REP(i, data.size()-1){\n          if(s == 0) break;\n          if(data[i].first.second < data[i+1].first.first){\n            int fst = data[i].first.second;\n            int len = min(s, data[i+1].first.first - fst);\n            add.push_back(S(SEG(fst, fst + len), l));\n            s -= len;\n          }\n        }\n        if(s > 0){\n          int fst = data.back().first.second;\n          int len = s;\n          add.push_back(S(SEG(fst, fst + len), l));\n        }\n        REP(i, add.size()) data.insert(upper_bound(data.begin(), data.end(), add[i]), add[i]);\n        //sort(data.begin(), data.end());\n        /*\n        REP(i, MAXL){\n          if(S == 0) break;\n          if(data[i] == -1){\n            data[i] = l;\n            S --;\n          }\n        }\n        */\n      }else if(cmd == \"D\"){\n        int l; cin>>l;\n        //REP(i, MAXL)if(data[i] == l)data[i] = -1;\n        vector<S>::iterator it = data.begin();\n        while(it != data.end()){\n          if(it->second == l){\n            it = data.erase(it);\n          }else{\n            it++;\n          }\n        }\n      }else if(cmd == \"R\"){\n        int P; cin>>P;\n        int res = -1;\n        REP(i, data.size())if(data[i].first.first <= P && P < data[i].first.second){\n          res = data[i].second;\n        }\n        cout<< res <<endl;\n        //cout<<data[P]<<endl;\n      }else{\n        assert(false);\n      }\n      //REP(i, data.size())printf(\"%d:(%d, %d) \", data[i].second, data[i].first.first, data[i].first.second); cout<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nstruct list {\n\tP data;\n\tstruct list *next;\n};\n\nlist* make_list(P a, list *r) {\n\tlist* z = (list*)malloc(sizeof(list));\n\tz->data = a;\n\tz->next = r;\n\treturn z;\n}\n\nlist* insert_list(P a, list *r) {\n\tlist** x = &r;\n\tbool hantei = true;\n\twhile (*x != NULL) {\n\t\tif (((*x)->data).first == -1) {\n\t\t\t((*x)->data).first = a.first;\n\t\t\tif (((*x)->data).second < a.second) {\n\t\t\t\ta.second = a.second - ((*x)->data).second;\n\t\t\t} else if (((*x)->data).second > a.second){\n\t\t\t\tint b = ((*x)->data).second - a.second;\n\t\t\t\t((*x)->data).second = a.second;\n\t\t\t\t(*x)->next = make_list(P(-1, b), (*x)->next);\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\thantei = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx = &((*x)->next);\n\t}\n\tif (hantei) {\n\t\t*x = make_list(a, NULL);\n\t}\n\treturn r;\n}\n\nlist* delete_list(int a, list* r) {\n\tlist** x = &r;\n\twhile (*x != NULL) {\n\t\tif (((*x)->data).first == a) {\n\t\t\t((*x)->data).first = -1;\n\t\t}\n\t\tx = &((*x)->next);\n\t}\n\treturn r;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tchar c;\n\t\tP p;\n\t\tint a;\n\t\tlist* z = NULL;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> c;\n\t\t\tif (c == 'W') {\n\t\t\t\tcin >> p.first >> p.second;\n\t\t\t\tz = insert_list(p, z);\n\t\t\t} else if (c == 'D') {\n\t\t\t\tcin >> a;\n\t\t\t\tz = delete_list(a, z);\n\t\t\t} else {\n\t\t\t\tcin >> a;\n\t\t\t\ta++;\n\t\t\t\tlist** x = &z;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif ((*x) == NULL) {\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP q = (*x)->data;\n\t\t\t\t\tif (q.second >= a) {\n\t\t\t\t\t\tcout << q.first << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta -= q.second;\n\t\t\t\t\t\tif (a < 0) {\n\t\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx = &((*x)->next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define vecsize 1000000000\nint vec[vecsize];\nvoid W(int x,int y){\n    for(int i=0;i<vecsize;++i){\n        if(y>0)if(vec[i]==-1)vec[i]=x,--y;\n    }\n}\nvoid D(int x){\n    int size=vecsize-1;\n    if(x<=size)for(int i=vecsize-1;i>=0;--i){\n        if(vec[i]==x){\n            vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vecsize;\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n            for(int i=0;i<vecsize;++i){\n                std::cout<<vec[i]<<\":\";\n            }\n            std::cout<<std::endl;\n        }\n        b=false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint main(){\n  int n;\n  while (cin >> n, n){\n    list<pair<int, int>> l{{-1, inf}};\n    rep(i, n){\n      string c;\n      cin >> c;\n      if (c == \"W\"){\n        int a, b;\n        cin >> a >> b;\n        auto it = l.begin();\n        while (b > 0){\n          if (it->first == -1){\n            if (b >= it->second){\n              it->first = a;\n              b -= it->second;\n            }\n            else {\n              l.insert(next(it), {-1, it->second - b});\n              *it = {a, b};\n              b = 0;\n            }\n          }\n          ++it;\n        }\n      }\n      else if (c == \"D\"){\n        int a;\n        cin >> a;\n        auto it = l.begin();\n        while (it != l.end()){\n          if (it->first == a) it->first = -1;\n          ++it;\n        }\n        it = l.begin();\n        while (next(it) != l.end()){\n          if (it->first == -1 && next(it)->first == -1){\n            it->second += next(it)->second;\n            l.erase(next(it));\n          }\n          ++it;\n        }\n      }\n      else if (c == \"R\"){\n        int a;\n        cin >> a;\n        auto it = l.begin();\n        while (a >= it->second){\n          a -= it->second;\n          ++it;\n        }\n        cout << it->first << endl;\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20000];\nsegment *head, *blank;\n\nvoid W(int I, int S){\n    segment *p=head, *last=NULL;\n    while(S){\n        while(p->id!=-1) p=p->next;\n        if(p->length>S){\n            p->id=I;\n            segment *b=blank++;\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n            p=p->next;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head,*next;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        next=p->file;\n        p->file=NULL;\n        p=next;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20000;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<stdint.h>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\nusing namespace std;\n\nconst uint64_t INF = 100000000000010;\n\nstruct List\n{\n  int identifier;\n  uint64_t range[2];// [range[0],range[1]]\n  bool hasNext,hasPrev;\n  List *prev;\n  List *next;\n  List(int identifier=inf,uint64_t r1=INF,uint64_t r2=INF):identifier(identifier)\n  {\n    range[0] = r1, range[1] = r2;\n    hasNext = hasPrev = false;\n  }\n};\n\nint N,I,S,P;\nchar c;\nList list;\n\nvoid list_walk(List *l)\n{\n  cout << '[' << l->range[0] << \",\" << l->range[1] << \" : \" << l->identifier << \"]\";\n  if(l->hasNext)list_walk(l->next);\n}\n\nvoid ddfs(List *l)\n{\n  if(l->hasNext)ddfs(l->next);\n  if(l->hasPrev)delete l;\n    \n}\n\nvoid init()\n{\n  if(list.hasNext)ddfs(&list);\n  list.hasNext = true;\n  list.hasPrev = false;\n  list.range[0] = list.range[1] = -1;\n  list.identifier = -1;\n  list.next = new List;\n  list.next->hasNext = false;\n  list.next->hasPrev = true;\n  list.next->range[0] = list.next->range[1] = INF;\n  list.next->identifier = inf;\n  list.next->prev = &list;\n}\n\nvoid dfsW(List *l)\n{\n  uint64_t v1 = l->range[1];\n  uint64_t v2 = l->next->range[0];\n  uint64_t diff = v2-v1-1;\n  if(diff)\n    {\n      List *node = new List;\n      node->identifier = I;\n      node->hasNext = node->hasPrev = true;\n      node->next = l->next;\n      node->prev = l;\n      l->next->prev = node;\n      l->next = node;\n\n      node->range[0] = v1+1;\n      if(S <= diff)\n\t{\n\t  node->range[1] = node->range[0] + S - 1;\n\t  S = 0;\n\t}\n      else if(S > diff)\n\t{\n\t  node->range[1] = node->range[0] + diff - 1;\n\t  S -= diff;\n\t}    \n    }  \n  if(S > 0)dfsW(l->next);\n}\n\nvoid compute_W()\n{\n  dfsW(&list);\n}\n\nvoid dfsD(List *l)\n{\n  if(l->identifier == I)\n    {\n      l->next->prev = l->prev;\n      l->prev->next = l->next;\n      delete l;\n    }\n  if(l->hasNext)dfsD(l->next);\n}\n\nvoid compute_D()\n{\n  dfsD(&list);\n}\n\nvoid dfsR(List *l)\n{\n  if(l->range[0] <= P && P <= l->range[1])\n    {\n      cout << l->identifier << endl;\n    }\n  else\n    {\n      if(l->hasNext)dfsR(l->next);\n      else cout << -1 << endl;\n    }\n}\n\nvoid compute_R()\n{\n  dfsR(&list);\n}\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n\n      init();\n      rep(_,N)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')cin >> I >> S,compute_W();\n\t  if(c == 'D')cin >> I,compute_D();\n\t  if(c == 'R')cin >> P,compute_R();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 100100\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    {\n cerr << c << \" \" << l << \" \" << s << endl; \n\t\t      assert(false);\n\t\t      \n\t\t    }\n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct data{\n\tint no;\n\tint front;\n\tint size;\n\tint pre;\n\tint next;\n\tbool operator<(const data &right){\n\t\treturn front < right.front;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile (cin>>n,n){\n\t\tvector<data> file;\n\t\tfile.push_back({ -1, 0, 1000000001, -1, -1 });\n\t\tint first = 0;\n\t\tREP(i,n){\n\t\t\tint a, b;\n\t\t\tchar c;\n\t\t\tint now = first;\n\t\t\tcin >> c;\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t\tcin >> a >> b;\n\t\t\t\twhile(1){\n\t\t\t\t\tif (file[now].no == -1){\n\t\t\t\t\t\tif (file[now].size > b){\n\t\t\t\t\t\t\tfile.push_back({ a, file[now].front, b, file[now].pre, now });\n\t\t\t\t\t\t\tfile[now].front += b;\n\t\t\t\t\t\t\tfile[now].size -= b;\n\t\t\t\t\t\t\tif (file[now].pre == -1)\n\t\t\t\t\t\t\t\tfirst = file.size() - 1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfile[file[now].pre].next = file.size() - 1;\n\t\t\t\t\t\t\tfile[now].pre = file.size() - 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(file[now].size==b){\n\t\t\t\t\t\t\tfile[now].no = a;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfile[now].no = a;\n\t\t\t\t\t\t\tb -= file[now].size;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnow = file[now].next;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> a;\n\t\t\t\tREP(j, file.size()){\n\t\t\t\t\tif (file[j].no == a)\n\t\t\t\t\t\tfile[j].no = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> a;\n\t\t\t\twhile(1){\n\t\t\t\t\tif (file[now].front <= a&&a <file[now].front+file[now].size){\n\t\t\t\t\t\tcout << file[now].no << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnow = file[now].next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint N;\nconst int MAX = 1e9 + 10;\n\nclass D{\npublic:\n  int e,s,in;\n};\n\nvector<D>vec;\n\nvoid write(){\n  int a,b;\n  cin >> a >> b;\n\n  int pre = 0;\n  vector<D>nv;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].s - pre != 0 && b > 0){\n      D d;\n      d.s = pre;\n      d.e = pre + min(b,vec[i].s - pre);\n      d.in = a;\n      nv.push_back(d);\n      b -= (vec[i].s - pre);\n    }\n    nv.push_back(vec[i]);\n    pre = vec[i].e;\n  }\n  vec = nv;\n}\n\nvoid del(){\n  int a;\n  cin >> a;\n  vector<D>nv;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].in == a)continue;\n    nv.push_back(vec[i]);\n  }\n  vec = nv;\n}\n\nvoid read(){\n  int a;\n  cin >> a;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].s <= a && a < vec[i].e){\n      cout << vec[i].in << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\n\nvoid solve(){\n  vec.clear();\n  \n  D d;\n  d.s = 0;\n  d.e = 0;\n  d.in = -1;\n  vec.push_back(d);\n\n  d.s = MAX;\n  d.e = MAX;\n  d.in = -1;\n  vec.push_back(d);\n\n  for(int i = 0 ; i < N ; i++){\n    char c;\n    cin >> c;\n    switch(c){\n    case 'W':\n      write();\n      break;\n    case 'D':\n      del();\n      break;\n    case 'R':\n      read();\n      break;\n    }\n  }\n}\n\nint main(){\n  while(cin >> N,N){\n    solve();\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000010\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint n;\nvector<PP> v;\n\nvoid solve(){\n\tv.clear();\n\trep(i,n){\n\t\tchar x; cin >> x;\n\t\tif(x == 'D'){\n\t\t\tint l; cin >> l;\n\t\t\trep(j,v.size()) if(v[j].second == l){\n\t\t\t\tv[j].first.first = INF;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\twhile(true){\n\t\t\t\tif(v.size() == 0) break;\n\t\t\t\tif(v[v.size()-1].first.first != INF) break;\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t} else if(x == 'R'){\n\t\t\tint p; cin >> p;\n\t\t\tbool ok = false;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first <= p && p <= v[j].first.second){\n\t\t\t\t\tcout << v[j].second << endl;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) puts(\"-1\");\n\t\t} else{\n\t\t\tint l, s; cin >> s >> l;\n\t\t\tint st = 0;\n\t\t\tint V = v.size();\n\t\t\trep(j,V){\n\t\t\t\tif(v[j].first.first > st){\n\t\t\t\t\tif(l <= v[j].first.first-st){\n\t\t\t\t\t\tv.push_back(PP(P(st,st+l-1),s));\n\t\t\t\t\t\tl = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tv.push_back(PP(P(st,v[j].first.first-1),s));\n\t\t\t\t\t\tl -= v[j].first.first-st;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tst = v[j].first.second+1;\n\t\t\t\tif(st > INF){\n\t\t\t\t\tl = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l > 0) v.push_back(PP(P(st,st+l-1),s));\n\t\t\tsort(v.begin(),v.end());\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\nstruct st{\n    int first,second,ident;\n    bool operator < (st obj) const{\n        return this->second < obj.second;\n    }\n};\n\nint main(){\n    int n;\n    bool f = false;\n    while(cin>>n&&n){\n        if(f)cout<<endl;\n        f=true;\n        set<pii> free;\n        set<st> used;\n        free.insert(pii(0,1e9+1));\n        rep(i,n){\n            char ch;\n            cin>>ch;\n            if(ch=='W'){\n                int num,len;\n                cin>>num>>len;\n                while(len>0){\n                    pii tmp = *(free.begin());\n                    free.erase(free.begin());\n                    if(tmp.second-tmp.first<=len){  //????????????\n                        len -= tmp.second-tmp.first;\n                        used.insert(st{tmp.first,tmp.second,num});\n                    }\n                    else{                           //????????????????????????\n                        used.insert(st{tmp.first,tmp.first+len,num});\n                        free.insert(pii(tmp.first+len,tmp.second));\n                        len = 0;\n                    }\n                }\n            }\n            if(ch=='D'){\n                int num;\n                cin>>num;\n                for(auto itr = used.begin();itr!=used.end();itr++){\n                    if(itr->ident==num){\n                        st tmp = *itr;\n                        free.insert(pii(tmp.first,tmp.second)); //??????????£?\n                        itr = used.erase(itr);\n                    }\n                }\n            }\n            if(ch=='R'){\n                int pos;\n                cin>>pos;\n                auto res = used.upper_bound(st{0,pos,0});\n                if(res==used.end())cout<<\"-1\"<<endl;\n                else{\n                    st tmp = *(res);\n                    cout<<tmp.ident<<endl;\n                }\n            }\n        }\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n\n#define int long long\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e18 + 10;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nsigned main(){\n\tint n;\n\twhile(cin >> n && n) {\n\t\tmap<pii, int> empty;\n\t\tmap<pii, int> writed;\n\t\tmap<int, vector<pii> > v;\n\t\tempty[{0,INF}] = 1;\n\t\trep(_, n) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif(s == \"W\") {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tfor(auto it = empty.begin(); it != empty.end();) {\n\t\t\t\t\tint l = it -> fi.se - it -> fi.fi;\n\t\t\t\t\tif(l == b) {\n\t\t\t\t\t\twrited[it->fi] = a;\n\t\t\t\t\t\tv[a].pb(it->fi);\n\t\t\t\t\t\tit = empty.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(l > b) {\n\t\t\t\t\t\tpii p = {it->fi.fi, it->fi.fi+b};\n\t\t\t\t\t\tpii q = {it->fi.fi+b, it->fi.se};\n\t\t\t\t\t\twrited[p] = a;\n\t\t\t\t\t\tv[a].pb(p);\n\t\t\t\t\t\tit = empty.erase(it);\n\t\t\t\t\t\tempty[q] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\t// l < b\n\t\t\t\t\t\twrited[it->fi] = a;\n\t\t\t\t\t\tv[a].pb(it->fi);\n\t\t\t\t\t\tit = empty.erase(it);\n\t\t\t\t\t\tb -= a;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else if(s == \"D\") {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tauto& b = v[a];\n\t\t\t\twhile(b.size() > 0) {\n\t\t\t\t\tauto p = b.back();\n\t\t\t\t\twrited.erase(p);\n\t\t\t\t\tempty[p] = 1;\n\t\t\t\t\tb.pop_back();\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tint b = -1;\n\t\t\t\tfor(auto& p : writed) {\n\t\t\t\t\tif(p.fi.fi <= a && a < p.fi.se) {\n\t\t\t\t\t\tb = p.se;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << b << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n  \nusing namespace std;\n\nconst int LIMIT = 1000000000;\n\nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n  \nint N;\nvector<Data> storage;\n \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n      \n      if(st > LIMIT) return;\n    }\n    if(num == -1) {\n      // insert data back\n      num = remain;\n      if(st+num > LIMIT) {\n        num = LIMIT - (st+num);\n      }\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n\nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n  /*\n    ---------- same as follows ----------\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(storage[i].id == id) {\n        storage.erase(storage.begin()+i);\n        i--;\n      }\n    }\n  */\n}\n\nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n  \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nifstream ifs(\"2152_input.txt\");\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            auto it = disk.begin();\n            while(it != disk.end())\n              if(it->second == t) disk.erase(it++);\n              else it++;\n            \n        }else{\n            auto lb = disk.lower_bound(pint(t, 0));\n            pint temp;\n            if(lb == disk.begin()) goto fail;\n            lb--;\n            temp = lb->first;\n            if(temp.first <= t && t <= temp.second){\n                cout << lb->second << endl;\n                continue;\n            }\n          fail:\n            cout << \"-1\" << endl;\n        }\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <string>\n\nusing namespace std;\n\nstruct Segment {\n\tint start;\n\tint end;\n\tint id;\n\t\n\tSegment() {}\n\tSegment(int s, int e, int id) : start(s), end(e), id(id) {}\n};\n\nlist<Segment> storage;\nvoid do_write(const int id, const int sectors) {\n\tlist<Segment>::iterator it = storage.begin();\n\tint prev_last = -1;\n\tint remain = sectors;\n\twhile(it != storage.end()) {\n\t\tif(it->start > prev_last+1) {\n\t\t\t// insert file\n\t\t\tint size = min(remain, it->start - prev_last - 1);\n\t\t\tit = storage.insert(it, Segment(prev_last+1, prev_last+1+size-1, id));\n\t\t\tremain -= size;\n\t\t\tif(remain == 0) break;\n\t\t}\n\t\tprev_last = it->end;\n\t\t++it;\n\t}\n\tif(remain > 0) {\n\t\tstorage.insert(it, Segment(prev_last+1, prev_last+1+remain-1, id));\n\t}\n}\n\nvoid do_delete(const int id) {\n\tlist<Segment>::iterator it = storage.begin();\n\twhile(it != storage.end()) {\n\t\tif(it->id == id) {\n\t\t\tit = storage.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}\n\nint read_sector(const int sector) {\n\tfor(list<Segment>::const_iterator it = storage.begin(); it != storage.end(); ++it) {\n\t\tif(it->start <= sector && sector <= it->end) {\n\t\t\treturn it->id;\n\t\t}\n\t}\n\treturn -1;\n}\n\nbool solve() {\n\tint N;\n\tcin >> N;\n\tif(!N) return false;\n\twhile(N--) {\n\t\tstring cmd;\n\t\tcin >> cmd;\n\t\tif(cmd == \"W\") {\n\t\t\tint id, sectors;\n\t\t\tcin >> id >> sectors;\n\t\t\tdo_write(id, sectors);\n\t\t} else if(cmd == \"D\") {\n\t\t\tint id;\n\t\t\tcin >> id;\n\t\t\tdo_delete(id);\n\t\t} else if(cmd == \"R\") {\n\t\t\tint sector;\n\t\t\tcin >> sector;\n\t\t\tcout << read_sector(sector) << endl;\n\t\t}\n\t}\n\tcout << endl;\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\t\n\tfor(; solve(); ) ;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Data{\n    int idx;\n    int l,r;\n    Data* ptr;\n};\n\nvoid insert(int idx,int s,Data &data){\n    if(s<=0) return;\n    if(data.ptr==nullptr){\n        data.ptr=new Data{idx,data.r,data.r+s,nullptr};\n        return;\n    }\n    else if((data.ptr->l)-data.r>=1){\n        Data *to=data.ptr;\n        int buf=data.ptr->l-data.r;\n        data.ptr=new Data{idx,data.r,data.r+min(s,buf),to};\n        insert(idx,s-buf,*to);\n        return;\n    }\n    else{\n        insert(idx,s,*data.ptr);\n    }\n}\nvoid erase(int idx,Data &data){\n    if(data.ptr==nullptr) return;\n    while(data.ptr->idx==idx){\n        data.ptr=data.ptr->ptr;\n        if(data.ptr==nullptr) return;\n    }\n    erase(idx,*data.ptr);\n}\nint search(int pos,Data& data){\n    if(data.l<=pos && pos<data.r) return data.idx;\n    else if(data.ptr==nullptr) return -1;\n    else return search(pos,*data.ptr);\n}\nvoid solve(int n){\n    Data base=Data{-1,-1,0,nullptr};\n    for(int i=0;i<n;i++){\n        char com;\n        cin>>com;\n        if(com=='W'){\n            int idx,s;\n            cin>>idx>>s;\n            insert(idx,s,base);\n        }\n        if(com=='D'){\n            int idx;\n            cin>>idx;\n            erase(idx,base);\n        }\n        if(com=='R'){\n            int pos;\n            cin>>pos;\n            cout<<search(pos,base)<<endl;\n        }\n    }\n    return;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        solve(n);\n        cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    vector<pair<pair<int, int>, int> > files;\n    rep (iii, n) {\n      string str;\n      cin >> str;\n      if (str == \"W\") {\n\tvector<pair<pair<int, int>, int> > next;\n\tint num, sz, pre = -1;\n\tcin >> num >> sz;\n\trep (i, files.size()) {\n\t  if (pre + 1 != files[i].first.first && sz > 0) {\n\t    int fsz = min(sz, files[i].first.first - pre - 1);\n\t    next.push_back(make_pair(make_pair(pre + 1, pre + fsz), num));\n\t    sz -= fsz;\n\t  }\n\t  next.push_back(files[i]);\n\t  pre = files[i].first.second;\n\t}\n\tif (sz > 0) {\n\t  next.push_back(make_pair(make_pair(pre + 1, pre + sz), num));\n\t}\n\tfiles = next;\n      } else if (str == \"D\") {\n\tvector<pair<pair<int, int>, int> > next;\n\tint pos;\n\tcin >> pos;\n\trep (i, files.size()) {\n\t  if (files[i].first.first <= pos && pos <= files[i].first.second) continue;\n\t  next.push_back(files[i]);\n\t}\n\tfiles = next;\n      } else if (str == \"R\") {\n\tint pos;\n\tcin >> pos;\n\tint res = -1;\n\trep (i, files.size()) {\n\t  if (files[i].first.first <= pos && pos <= files[i].first.second) {\n\t    res = files[i].second;\n\t  }\n\t}\n\tcout << res << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> plll;\nlist<plll> li;\n\nll distplll(plll a){\n\treturn a.F.S-a.F.F+1;\n}\n\nvoid w_list(ll a,ll b){\n\tlist<plll>::iterator it=li.begin();\n\twhile(1){\n\t\tif(b==0) break;\n\t\tif(it==li.end()){\n\t\t\tif(it==li.begin()){\n\t\t\t\tli.PB(mkp(mkp(0,b-1),a));\n\t\t\t}\n\t\t\telse{\n\t\t\t\t--it;\n\t\t\t\tli.PB(mkp(mkp((*it).F.S+1,(*it).F.S+b),a));\n\t\t\t\t++it;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse{\n\t\t\tif((*it).S==-1){\n\t\t\t\tif(distplll(*it)<=b){\n\t\t\t\t\t(*it).S=a;\n\t\t\t\t\tb-=distplll(*it);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tplll tmp;\n\t\t\t\t\ttmp.S=a;\n\t\t\t\t\ttmp.F.S=(*it).F.F+b-1;\n\t\t\t\t\ttmp.F.F=(*it).F.F;\n\t\t\t\t\t(*it).F.F=tmp.F.S+1;\n\t\t\t\t\tit=li.insert(it,tmp);\n\t\t\t\t\t++it;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++it;\n\t}\n}\n\n\nvoid d_list(ll a){\n\tlist<plll>::iterator it=li.begin();\n\twhile(it!=li.end()){\n\t\tif((*it).S==a){\n\t\t\t(*it).S=-1;\n\t\t}\n\t\t++it;\n\t}\n}\n\nvoid r_list(ll a){\n\tlist<plll>::iterator it=li.begin();\n\twhile(it!=li.end()){\n\t\tif(a<=(*it).F.S){\n\t\t\tcout<<(*it).S<<endl;\n\t\t\treturn;\n\t\t}\n\t\t++it;\n\t}\n\tcout<<\"-1\"<<endl;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tlist<plll> ttt;\n\t\tli=ttt;\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tll a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tw_list(a,b);\t\n\t\n\t\t\t}\n\t\t\telse if(c=='D'){\n\t\t\t\tll a;\n\t\t\t\tcin>>a;\n\t\t\t\td_list(a);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tll a;\n\t\t\t\tcin>>a;\n\t\t\t\tr_list(a-1);\n\t\t\t}\n\t\t\t// list<plll>::iterator it=li.begin();\n\t\t\t// \n\t\t\t// for(;it!=li.end();++it){\n\t\t\t\t// cout<<(*it).F.F<<\" \"<<(*it).F.S<<\" \"<<(*it).S<<endl;\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nstruct DATA{\n\tint start;\n\tint end;\n\tint fileID;\n\tDATA(int start, int end, int fileID){\n\t\tthis->start = start, this->end = end, this->fileID = fileID;\n\t}\n};\n\nvector<DATA> data;\n\nvoid Write(int fileID, int file_length)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(file_length <= data[i].end - data[i].start + 1){\n\t\t\t\tdata.insert(data.begin() + i, DATA(data[i].start, data[i].start + file_length - 1, fileID));\n\t\t\t\tdata[i+1].start = data[i+1].start + file_length;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tdata[i].fileID = fileID;\n\t\t\t\tfile_length -= data[i].end - data[i].start + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Arrange()\n{\n\tfor(int i = 0; i < (int)data.size()-1; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(data[i+1].fileID == -1){\n\t\t\t\tdata[i].end = data[i+1].end;\n\t\t\t\tdata.erase(data.begin() + (i+1));\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Delete(int fileID)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == fileID) data[i].fileID = -1;\n\t}\n\tArrange();\n}\n\nvoid Reference(int pos)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].end >= pos){\n\t\t\tprintf(\"%d\\n\", data[i].fileID);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint N;\n\tchar com[5];\n\tint op1, op2;\n\t\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdata.clear();\n\t\tdata.push_back( DATA(0, 1000000001, -1) );\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\t\n\t\t\tscanf(\"%s\", com);\n\t\t\tif(strcmp(com, \"W\") == 0){\n\t\t\t\tscanf(\"%d %d\", &op1, &op2);\n\t\t\t\tWrite(op1, op2);\n\t\t\t}else if(strcmp(com, \"D\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tDelete(op1);\n\t\t\t}else if(strcmp(com, \"R\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tReference(op1);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1005,INF=1000000001;\n\nstruct query{\n    string kind;\n    int id;\n    int want;\n    int see;\n};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        vector<query> S(N);\n        \n        for(int i=0;i<N;i++){\n            cin>>S[i].kind;\n            if(S[i].kind==\"W\"){\n                cin>>S[i].id>>S[i].want;\n            }else if(S[i].kind==\"D\"){\n                cin>>S[i].id;\n            }else{\n                cin>>S[i].see;\n            }\n        }\n        \n        map<int,set<pair<int,int>>> MA;\n        MA[-1].insert({0,INF});\n        \n        for(int i=0;i<N;i++){\n            if(S[i].kind==\"W\"){\n                for(auto it=MA[-1].begin();S[i].want&&it!=MA[-1].end();){\n                    int a=(*it).first,b=(*it).second;\n                    if(b-a<=S[i].want){\n                        S[i].want-=(b-a);\n                        it=MA[-1].erase(it);\n                        MA[S[i].id].insert({a,b});\n                    }else{\n                        MA[S[i].id].insert({a,a+S[i].want});\n                        it=MA[-1].erase(it);\n                        MA[-1].insert({a+S[i].want,b});\n                        S[i].want=0;\n                    }\n                }\n            }else if(S[i].kind==\"D\"){\n                for(auto it=MA[S[i].id].begin();it!=MA[S[i].id].end();){\n                    int a=(*it).first,b=(*it).second;\n                    MA[-1].insert({a,b});\n                    it=MA[S[i].id].erase(it);\n                }\n            }else{\n                bool ok=false;\n                for(auto ii=MA.begin();ii!=MA.end();ii++){\n                    int aa=(*ii).first;\n                    \n                    for(auto it=MA[aa].begin();it!=MA[aa].end();it++){\n                        int a=(*it).first,b=(*it).second;\n                        if(a<=S[i].see&&S[i].see<b){\n                            cout<<aa<<endl;\n                            ok=true;\n                            break;\n                        }else if(S[i].see<a) break;\n                    }\n                    \n                    if(ok) break;\n                }\n            }\n        }\n        cout<<endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<(int)N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\nusing namespace std;\nconst int inf=1e9;\n\nstruct RF{\n\tint id,from,to;\n};\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tvector<RF> seg;\n\t\tseg.push_back({-1,0,inf});\n\t\tREP(i,0,N){\n\t\t\tchar c;\n\t\t\tint id,num;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tcin>>id>>num;\n\t\t\t\tint i=0;\n\t\t\t\twhile(num>0){\n\t\t\t\t\tif(seg[i].id==-1){\n\t\t\t\t\t\tint from=seg[i].from,to=seg[i].to;\n\t\t\t\t\t\tif(to-from+1<=num){\n\t\t\t\t\t\t\tseg[i].id=id;\n\t\t\t\t\t\t\tnum-=to-from+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tseg[i]={id,from,from+num-1};\n\t\t\t\t\t\t\tseg.insert(seg.begin()+i+1,{-1,from+num,to});\n\t\t\t\t\t\t\tnum=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}else if(c=='D'){\n\t\t\t\tcin>>id;\n\t\t\t\tREP(i,0,seg.size()){\n\t\t\t\t\tif(seg[i].id==id) seg[i].id=-1;\n\t\t\t\t}\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin>>num;\n\t\t\t\tfor(auto v:seg){\n\t\t\t\t\tif(ck(num,v.from,v.to)){\n\t\t\t\t\t\tp(v.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int>P;\nint main(){\n  string st;\n  vector<P>v;\n  int n,x,y;\n  while(cin>>n,n){\n    v.clear();\n    while(n--){\n      cin>>st;\n      if(st==\"W\"){\n        cin>>x>>y;\n        r(i,v.size()+1){\n          if(i==v.size()){\n            v.push_back(P(x,y));\n            break;\n          }\n          else if(v[i].f==-1){\n            if(v[i].s-y<0)v[i].f=x,y-=v[i].s;\n            else{\n              v[i].s-=y;\n              v.insert(v.begin()+i,P(x,y));\n              goto L;\n            }\n          }\n        }\n      }\n      else if(st==\"D\"){\n        cin>>x;\n        r(i,v.size())if(v[i].f==x)v[i].f=-1;\n      }\n      else{\n        int p=0,fl=0;\n        cin>>x;x++;\n        r(i,v.size()){\n          if(p<=x&&x<=p+v[i].s){\n            cout<<v[i].f<<endl;\n            fl++;\n            break;\n          }\n          p+=v[i].s;\n        }\n        if(!fl)cout<<-1<<endl;\n      }L:;\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nbool check(){\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].first != -1) return true;\n  }\n\n  vec.clear();\n  return false;\n}\n\nvoid Wri(){\n  int len = vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0 || !check()){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        cout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\ntypedef map<pair<int,int>,int> mpiii;\n\nvoid solve(int T){\n\tmpiii m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(mpiii::iterator it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tmpiii::iterator it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tmpiii::iterator it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(mpiii::iterator it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[make_pair(cur,cur+z-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(list<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.push_front({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.push_back({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.push_front({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert(it,{prev->l,t,id});\n            \n            cnt-=t;\n        }\n        if(cnt<=0) break;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.push_back({it->r,it->r+cnt,id});\n    \n}\nvoid solve() {\n    list<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n            //for(auto &e : range) {\n            //    cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n            //}\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                else it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          // cout << idx << \" \" << cnt << endl;\n          // if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].second == -1) {\n            if(idx + cnt - 1 <= dp[idx].first) {\n              if(dp.find(idx+cnt) == dp.end()) dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx] = {idx+cnt-1, l};\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].first - idx + 1;\n            }\n          }\n          // assert(idx < dp[idx].first + 1);\n          idx = dp[idx].first + 1;\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          // if(dp.find(idx) == dp.end()) assert(false);\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          }\n          assert(idx < dp[idx].first + 1);\n          idx = dp[idx].first + 1;\n        }\n      }\n      // for(auto& j: dp) cout << j.first << \" \" << j.second << \" \"; cout << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll n;\n\n    while (cin >> n, n) {\n\n        vector<tuple<ll, ll, ll>> files; // (l, r, i) means [l, r) is a part of the file i\n        \n        REP(i, n) {\n\n            char cmd; cin >> cmd;\n\n            if (cmd == 'R') {\n\n                ll p; cin >> p;\n                bool found = false;\n                for (auto &f : files) {\n                    if (get<0>(f) <= p && p < get<1>(f)) {\n                        cout << get<2>(f) << endl;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) cout << \"-1\" << endl;\n\n            } else if (cmd == 'D') {\n\n                ll i; cin >> i;\n                files.erase(remove_if(ALL_OF(files), [&i](auto f) -> bool { return get<2>(f) == i; }), files.end());\n\n            } else if (cmd == 'W') {\n\n                ll i, s; cin >> i >> s;\n\n                if (!files.empty()) {\n                    if (get<0>(files.front()) > 0) {\n                        ll gap = min(get<0>(files.front()), s);\n                        s -= gap;\n                        files.insert(files.begin(), {0, gap, i});\n                    }\n                    if (s >= 0) REP(j, files.size() - 1) {\n                        ll gap = get<0>(files[j+1]) - get<1>(files[j]);\n                        if (gap > 0) {\n                            chmin(gap, s);\n                            s -= gap;\n                            ll bk = get<1>(files[i]);\n                            files.emplace_back(bk, bk + gap, i);\n                            if (s <= 0) break;\n                        }\n                    }\n                }\n\n                if (s > 0) {\n                    ll bk = files.empty() ? 0 : get<1>(files.back());\n                    files.emplace_back(bk, bk + s, i);\n                }\n\n                sort(ALL_OF(files));\n\n            }\n\n        }\n\n        cout << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const list<T>& a){\n\tos<<'[';\n\tforeach(i,a) os<<(i==a.begin()?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int q;cin>>q,q;){\n\t\tlist<pair<int,pii>> allocated;\n\t\tallocated.emplace_back(-1,pii(1e9,1e9+1));\n\t\trep(_,q){\n\t\t\tchar type; cin>>type;\n\t\t\tif(type=='W'){\n\t\t\t\tint label,len; cin>>label>>len;\n\t\t\t\tint pos=0;\n\t\t\t\tforeach(i,allocated){\n\t\t\t\t\tif(len==0) break;\n\t\t\t\t\tint first=i->second.first,last=i->second.second;\n\t\t\t\t\tif(first>pos){\n\t\t\t\t\t\tint block=min(first-pos,len);\n\t\t\t\t\t\tallocated.emplace(i,label,mp(pos,pos+block));\n\t\t\t\t\t\tlen-=block;\n\t\t\t\t\t}\n\t\t\t\t\tpos=last;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type=='D'){\n\t\t\t\tint label; cin>>label;\n\t\t\t\tfor(auto i=allocated.begin();i!=allocated.end();){\n\t\t\t\t\tif(i->first==label)\n\t\t\t\t\t\ti=allocated.erase(i);\n\t\t\t\t\telse\n\t\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(type=='R'){\n\t\t\t\tint idx; cin>>idx;\n\t\t\t\tint label=-1;\n\t\t\t\tforeach(i,allocated){\n\t\t\t\t\tint first=i->second.first,last=i->second.second;\n\t\t\t\t\tif(first<=idx && idx<last){\n\t\t\t\t\t\tlabel=i->first;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<label<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        typedef tuple<int,int,int> triple;\n        set<triple> intervals;\n        intervals.insert(triple(0,0,-inf));\n        rep(i,0,n){\n            char command;\n            cin >> command;\n            if(command=='W'){\n                int id,len;\n                cin >> id >> len;\n                auto a=intervals.begin();\n                auto b=intervals.begin();\n                ++b;\n                while(len>0){\n                    int l=get<1>(*a);\n                    if(b==intervals.end()){\n                        intervals.insert(triple(l,l+len,id));\n                        break;\n                    }\n                    auto r=get<0>(*b);\n                    if(l==r){\n                        a=b;\n                        ++b;\n                        continue;\n                    }\n                    if(r-l>len) r=l+len;\n                    b=intervals.insert(triple(l,r,id)).first;\n                    a=b;\n                    ++b;\n                    len-=r-l;\n                }\n            }else if(command=='D'){\n                int id;\n                cin >> id;\n                for(auto it=intervals.begin();it!=intervals.end();){\n                    if(get<2>(*it)==id) it=intervals.erase(it);\n                    else ++it;\n                }\n            }else{\n                int addr;\n                cin >> addr;\n                bool ok=false;\n                for(const auto& interval:intervals) if(get<0>(interval)<=addr and addr<get<1>(interval)){\n                    cout << get<2>(interval) << endl;\n                    ok=true;\n                    break;\n                }\n                if(!ok) cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,a,b,cnt;\n  char c;\n  int inv[10010];\n  vector<P> v[10010];\n  map<int,int> m;\n\n  bool first = true;\n  while(cin >> n,n){\n    v[0].clear();\n    v[0].push_back(P(0,1000000001));\n    inv[0] = -1;\n    m.clear();\n    m[0] = 0;\n    cnt = 1;\n    \n    for(int i=0;i<n;i++){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tint tmp = m[a] = cnt;\n\tinv[cnt] = a;\n\tcnt++;\n\twhile(b){\n\t  if(b<v[0][0].second){\n\t    v[tmp].push_back(P(v[0][0].first,b));\n\t    v[0][0].first += b;\n\t    v[0][0].second -= b;\n\t    b = 0;\n\t  }else{\n\t    v[tmp].push_back(v[0][0]);\n\t    b -= v[0][0].first;\n\t    v[0].erase(v[0].begin());\n\t  }\n\t} \n      }else if(c == 'D'){\n\tcin >> a;\n\tint tmp = m[a];\n\tfor(int i=0;i<(int)v[tmp].size();i++)v[0].push_back(v[tmp][i]);\n\tsort(v[0].begin(),v[0].end());\n\tv[tmp].clear();\n      }else{\n\tcin >> a;\n\tbool f = true;;\n\tfor(int i=0;i<cnt;i++){\n\t  for(int j=0;j<(int)v[i].size();j++){\n\t    if(v[i][j].first<= a && a<v[i][j].first+v[i][j].second){\n\t      cout << inv[i] << endl;\n\t      f = false;\n\t      break;\n\t    }\n\t  }\n\n\t  if(!f)break;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<pair<int,int> ,int> M;\n\t\tM[make_pair(0,1000000001)]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='W'){\n\t\t\t\tint b,c;\n\t\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\t\tfor(map<pair<int,int>,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif(c<=0)break;\n\t\t\t\t\tpair<pair<int,int>,int> dat=*it;\n\t\t\t\t\tif(dat.second==-1){\n\t\t\t\t\t\tif(c>=dat.first.second-dat.first.first){\n\t\t\t\t\t\t\tc-=dat.first.second-dat.first.first;\n\t\t\t\t\t\t\tM[dat.first]=b;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tM[make_pair(dat.first.first,dat.first.first+c)]=b;\n\t\t\t\t\t\t\tM[make_pair(dat.first.first+c,dat.first.second)]=-1;\n\t\t\t\t\t\t\tM.erase(dat.first);\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='D'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tfor(map<pair<int,int>,int>::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif((*it).second==b){\n\t\t\t\t\t\tM[(*it).first]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='R'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tbool found=false;\n\t\t\t\tfor(map<pair<int,int> ,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tpair<int,int> q=(*it).first;\n\t\t\t\t\tif(q.first<=b&&b<q.second){\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).second);\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\ntypedef map<pair<int,int>,int> mpiii;\n\nvoid solve(int T){\n\tmpiii m;\n\tmpiii::iterator it,it2;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tit2=it++;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tit=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint N;\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N, N) {\n    using P = tuple<int,int,int>;\n    vector<P> v;\n    REP(i,N) {\n      char c;\n      cin >> c;\n      if (c == 'W') {\n        int I,S;\n        cin >> I >> S;\n        int pos = 0;\n        vector<P> w;\n        for (int j = 0; j < v.size(); j++) {\n          int x,l,r;\n          tie(x,l,r) = v[j];\n          if (S > 0 && pos < l) {\n            if (pos+S <= l) {\n              w.emplace_back(I,pos,pos+S);\n              S = 0;\n            } else {\n              w.emplace_back(I,pos,l);\n              S -= l-pos;\n            }\n          }\n          w.emplace_back(x,l,r);\n          pos = r;\n        }\n        if (S > 0) w.emplace_back(I,pos,pos+S);\n        swap(v,w);\n      } else if (c == 'D') {\n        int I;\n        cin >> I;\n        vector<P> w;\n        for (int j = 0; j < v.size(); j++) {\n          int x,l,r;\n          tie(x,l,r) = v[j];\n          if (x == I) continue;\n          w.emplace_back(x,l,r);\n        }\n        swap(v,w);\n      } else {\n        int P;\n        cin >> P;\n        int ans = -1;\n        for (int j = 0; j < v.size(); j++) {\n          int x,l,r;\n          tie(x,l,r) = v[j];\n          if (l <= P && P < r) {\n            ans = x;\n            break;\n          }\n        }\n        cout << ans << endl;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        list<pair<int,pair<int, int>>> ls;\n        ls.push_back(make_pair(-1,make_pair(-1,-1)));\n\n        rep(i,n){\n            char com;\n            cin >> com;\n            if(com == 'W'){\n                int a, b;\n                cin >> a >> b;\n                auto cur = ls.begin();\n                auto bef = ls.begin();\n                cur++;\n                while(b > 0){\n                    if(cur == ls.end()){\n                        int tmp = bef->second.second + 1;\n                        ls.push_back(make_pair(a,make_pair(tmp, tmp + b - 1)));\n                        b = 0;\n                    }else if(bef->second.second + 1 != cur->second.first){\n                        int dif = cur->second.first - bef->second.second - 1;\n                        int tmp = bef->second.second + 1;\n                        if(b <= dif){\n                            ls.insert(cur,make_pair(a,make_pair(tmp,tmp + dif - 1)));\n                            b = 0;\n                        }else{\n                            ls.insert(cur,make_pair(a,make_pair(tmp,cur->second.first - 1)));\n                            b -= dif;\n                        }\n                        cur--;\n                        bef = cur;\n                        bef--;\n                    }\n                    cur++;\n                    bef++;\n                }\n            }else if(com == 'D'){\n                int a;\n                cin >> a;\n                for(auto it = ls.begin(); it != ls.end(); it++){\n                    if(it->first == a){\n                        it = ls.erase(it);\n                    }\n                }\n            }else{\n                int a;\n                cin >> a;\n\n                bool f = false;\n                for(auto it:ls){\n                    if(it.second.first <= a && a <= it.second.second){\n                        cout << it.first << endl;\n                        f = true;\n                        break;\n                    }\n                }\n                if(not f) cout << -1 << endl;\n            }\n            //for(auto it : ls){ cout << it.second.first << ' ' << it.second.second << endl; }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <map>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long\n\nll n;\n\nint main(){\n  priority_queue <ll, vector<ll>, greater<ll> > empty;\n  //  priority_queue< pair<ll,ll>, vector< pair<ll,ll> >, greater< pair<ll,ll > > empty;\n  empty.push(MOD - 1);\n  map < ll, vector< pair<ll,ll> > > pos;\n  //  vector < vector< pair<ll,ll> > > pos;\n  map< pair<ll,ll>, ll> mp;\n  \n  while(cin >> n && n){\n    for(ll iii = 0; iii < n; iii++){\n      char c;\n      cin >> c;\n\n\t\n      if(c == 'W'){\n\tll name, num;\n\tcin >> name >> num;\n\twhile(1){\n\t  if(empty.top() % MOD - empty.top() / MOD + 1 >= num){\n\t    mp[make_pair(empty.top() / MOD, empty.top() / MOD + num - 1)] = name;\n\t    pos[name].push_back(make_pair(empty.top() / MOD, empty.top() / MOD + num - 1));\n\t    ll newempty = empty.top();\n\t    empty.pop();\n\t    newempty += num * MOD;\n\t    empty.push(newempty);\n\t    break;\n\t  }else{\n\t    pos[name].push_back(make_pair(empty.top() / MOD, empty.top() % MOD));\n\t    mp[make_pair(empty.top() / MOD, empty.top() % MOD)] = name;\n\t    num -= empty.top() % MOD - empty.top() / MOD + 1;\n\t    empty.pop();\n\t  }\n\t}\n      }else if(c == 'D'){\n\tll name;\n\tcin >> name;\n\tfor(auto i : pos[name]){\n\t  empty.push(i.first * MOD + i.second);\n\t  mp.erase(i);\n\t}\n      }else{\n\tll name;\n\tcin >> name;\n\tmap< pair<ll,ll>, ll> :: iterator it = mp.begin();\n\twhile(1){\n\t  if((*it).first.second >= name){\n\t    if((*it).first.first <= name){\n\t      cout << (*it).second << endl;\n\t    }else{\n\t      cout <<-1 << endl;\n\t    }\n\t    break;\n\t  }\n\t  it++;\n\t  if(it == mp.end()){\n\t    cout << -1 << endl;\n\t    break;\n\t  }\n\t}\n      }\n      \n    }\n    cout << endl;\n\t    \n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct C{\n  int f,a,s;\n};\n\nint main(){\n  bool ns=false;\n  for(int n;cin>>n,n;){\n    if(ns){\n      cout<<endl;\n    }\n    ns=true;\n    vector<C> v(1);\n    C is={-1,0,1000000001};\n    v[0]=is;\n    while(n--){\n      char c;\n      cin>>c;\n      if(c=='W'){\n\tint l,s;\n\tcin>>l>>s;\n\tfor(int i=0;s;i++){\n\t  if(v[i].f==-1){\n\t    v[i].f=l;\n\t    if(v[i].s<=s){\n\t      s-=v[i].s;\n\t    }else{\n\t      C n={-1,v[i].a+s,v[i].s-s};\n\t      v[i].s=s;\n\t      v.insert(v.begin()+i+1,n);\n\t      break;\n\t    }\n\t  }\n\t}\n      }else if(c=='D'){\n\tint l;\n\tcin>>l;\n\tfor(int i=0;i<v.size();i++){\n\t  if(v[i].f==l){\n\t    v[i].f=-1;\n\t  }\n\t}\n      }else{\n\tint p;\n\tcin>>p;\n\tfor(int i=0;i<v.size();i++){\n\t  if(v[i].a<=p&&p<v[i].a+v[i].s){\n\t    cout<<v[i].f<<endl;\n\t  }\n\t}\n      }\n    }\n  }\n  return 0;\n}\n\t    "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[2];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<pair<int,int> ,int> M;\n\t\tM[make_pair(0,1000000001)]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(str[0]=='W'){\n\t\t\t\tint b,c;\n\t\t\t\tscanf(\"%d%d\",&b,&c);\n\t\t\t\tfor(map<pair<int,int>,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif(c<=0)break;\n\t\t\t\t\tpair<pair<int,int>,int> dat=*it;\n\t\t\t\t\tif(dat.second==-1){\n\t\t\t\t\t\tif(c>=dat.first.second-dat.first.first){\n\t\t\t\t\t\t\tc-=dat.first.second-dat.first.first;\n\t\t\t\t\t\t\tM[dat.first]=b;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tM[make_pair(dat.first.first,dat.first.first+c)]=b;\n\t\t\t\t\t\t\tM[make_pair(dat.first.first+c,dat.first.second)]=-1;\n\t\t\t\t\t\t\tM.erase(dat.first);\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t//\t\tif(c>0){\n\t\t//\t\t\tif(M.size()==0)M[make_pair(0,c)]=b;\n\t\t//\t\t\telse{\n\t\t//\t\t\t\tint p=((*(M.rbegin())).first.second);\n\t\t//\t\t\t\tM[make_pair(p,p+c)]=b;\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='D'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tfor(map<pair<int,int>,int>::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tif((*it).second==b){\n\t\t\t\t\t\tM[(*it).first]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(str[0]=='R'){\n\t\t\t\tint b;\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tbool found=false;\n\t\t\t\tfor(map<pair<int,int> ,int >::iterator it=M.begin();it!=M.end();it++){\n\t\t\t\t\tpair<int,int> q=(*it).first;\n\t\t\t\t\tif(q.first<b&&b<=q.second){\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).second);\n\t\t\t\t\t\tfound=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!found)printf(\"%d\\n\",-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n  bool found = false;\n\n  scanf(\"%d\" ,&l);\n\n  if(len == 0){\n    return -1;\n  }\n\n  if(l == 0){\n    return num;\n  }  \n\n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      found = true;\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l || !found){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<P> D;\ntypedef map<ll,D> M;\ntypedef priority_queue<P,vector<P>,greater<P> > Q;\nint main(){\n  ll n,l,s,x,e;\n  while(cin>>n,n){\n    char c;\n    M m;\n    Q em;\n    e=0;\n    while(n--){\n      D d;\n      P p;\n      cin >> c;\n      if(c=='W'){\n\tcin >> l >> s;\n\twhile(!em.empty()&&s>0){\n\t  p=em.top();em.pop();\n\t  x=p.second-p.first+1;\n\t  if(x<=s){\n\t    s-=x;\n\t    m[l].push_back(p);\n\t  }else{\n\t    m[l].push_back(P(p.first,p.first+s-1));\n\t    p.first+=s;\n\t    em.push(p);\n\t    s=0;\n\t  }\n\t}\n\tif(s>0){\n\t  p.first=e;p.second=p.first+s-1;\n\t  m[l].push_back(p);\n\t  e=p.second+1;\n\t}\n      }\n      if(c=='D'){\n\tcin>>l;\n\tfor(int i=m[l].size()-1;i>=0;i--){\n\t  em.push(m[l][i]);\n\t}\n\tm[l].clear();\n      }\n      if(c=='R'){\n\tcin >> x;\n\tbool f=true;\n\tfor(M::iterator it=m.begin();it!=m.end();++it){\n\t  l=it->first;d=it->second;\n\t  for(int i=0;i<d.size();i++){\n\t    p=d[i];\n\t    if(p.first<=x&&x<=p.second){\n\t      cout << l << endl;\n\t      f=false;\n\t      break;\n\t    }\n\t  }\n\t  if(!f) break;\n\t}\n\tif(f) cout << -1 << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size < S) {\n              S -= v[i].size;\n            } else if(v[i].size > S) {\n              v.insert(v.begin()+i+1, (Data){v[i].size - S, -2});\n              v[i].size = S;\n              S = 0;\n            }\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(int i = 0, sum = 0; output == -1 && i < v.size();\n            sum += v[i].size, ++i) {\n          if(sum <= P && P < sum+v[i].size) {\n            output = v[i].id;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct data{\n  int l,r,id;\n};\n\nvector< data > t;\nint n;\n\nvoid funcW(int,int);\nvoid funcD(int);\nint funcR(int);\n\nint main(){\n  char ch;\n  int a,b;\n  while(cin>>n&&n){\n    t.clear();\n    t.push_back( (data){-1,-1,-1} );\n    t.push_back( (data){1e9+1,1e9+1,-1});\n    for(int i=0;i<n;i++){\n\n      cin>>ch;\n      if(ch=='W'){\n\tcin>>a>>b;\n\tfuncW(a,b);\n      }else if(ch=='D'){\n\tcin>>a;\n\tfuncD(a);\n      }else{\n\tcin>>a;\n\tcout<<funcR(a)<<endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\nvoid funcW(int id,int size){\n  for(int i=1;i<(int)t.size();i++){\n    int d=min(t[i].l-t[i-1].r-1 ,size);\n    if(d==0)continue;\n    size-=d;\n    t.insert(t.begin()+i ,(data){t[i-1].r+1,t[i-1].r+d,id});\n    if(size==0)break;\n  }\n}\n\nvoid funcD(int id){\n\n  for(int i=0;i<(int)t.size();i++){\n    if(t[i].id!=id)continue;\n    t.erase(t.begin()+i);\n  }\n}\n\nint funcR(int pos){\n  for(int i=0;i<(int)t.size();i++){\n    if(t[i].l<=pos&&pos<=t[i].r)return t[i].id;\n  }\n  return -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<string>\n#define INF 1000000000ll\n#define MOD 1000000007ll\n#define EPS 1e-10\n#define REP(i,m) for(long long i=0; i<m; i++)\n#define FOR(i,n,m) for(long long i=n; i<m; i++)\n#define DUMP(a) for(long long dump=0; dump<(ll)a.size(); dump++) { cout<<a[dump]; if(dump!=(ll)a.size()-1) cout<<\" \"; else cout<<endl; }\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tll n;\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tset<P> emp;\n\t\tset<pair<P,ll>> plt;\n\t\tmap<ll,vector<P>> buf;\n\t\temp.insert(P(0,INF+1));\n\t\tREP(roop,n) {\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W') {\n\t\t\t\tll idt,sec;\n\t\t\t\tcin>>idt>>sec;\n\t\t\t\tbuf[idt]=vector<P>();\n\t\t\t\twhile(sec>0) {\n\t\t\t\t\tP p=*(emp.begin());\n\t\t\t\t\temp.erase(emp.begin());\n\t\t\t\t\tif(p.second-p.first+1>sec) {\n\t\t\t\t\t\tbuf[idt].pb(P(p.first,p.first+sec-1));\n\t\t\t\t\t\tplt.insert(pair<P,ll>(P(p.first,p.first+sec-1),idt));\n\t\t\t\t\t\temp.insert(P(p.first+sec,p.second));\n\t\t\t\t\t\tsec=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuf[idt].pb(p);\n\t\t\t\t\t\tplt.insert(pair<P,ll>(p,idt));\n\t\t\t\t\t\tsec-=(p.second-p.first+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D') {\n\t\t\t\tll dlt;\n\t\t\t\tcin>>dlt;\n\t\t\t\tvector<P> vec=buf[dlt];\n\t\t\t\tREP(i,(ll)vec.size()) {\n\t\t\t\t\temp.insert(vec[i]);\n\t\t\t\t\tplt.erase(pair<P,ll>(vec[i],dlt));\n\t\t\t\t}\n\t\t\t\tbuf.erase(dlt);\n\t\t\t}\n\t\t\tif(c=='R') {\n\t\t\t\tll ref;\n\t\t\t\tcin>>ref;\n\t\t\t\tauto ite=upper_bound(ALL(plt),pair<P,ll>(P(ref,INF*INF),INF*INF));\n\t\t\t\tif(ite==plt.end()) {\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tite--;\n\t\t\t\tif((*ite).first.first<=ref&&(*ite).first.second>=ref) cout<<(*ite).second<<endl;\n\t\t\t\telse cout<<-1<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nvector<P> vec;\n\nbool check(){\n  for(int i = 0 ; i < (int)vec.size() ; i++){\n    if(vec[i].first != -1) return true;\n  }\n\n  vec.clear();\n  return false;\n}\n\nvoid change(int p, int S, int l){\n  vector<P> tmp;\n  int Next = vec[p].second - S;\n\n  for(int i = 0 ; i < p ; i++){\n    tmp.push_back(vec[i]);\n  }\n\n  tmp.push_back(P(l, S));\n  tmp.push_back(P(-1,Next));\n\n  for(int i = p+1 ; i < (int)vec.size() ; i++){\n    tmp.push_back(vec[i]);\n  }\n\n  vec = tmp;\n}\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  cin >> l >> S;\n\n  if(len == 0 || !check()){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }else{\n        change(i, S, l);\n        break;\n      }\n    }\n  }\n\n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  cin >> l;\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  long long cnt = 0;\n  int len = (int)vec.size(), l, num = vec[0].first;\n\n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    cnt += vec[i].second;\n    num = vec[i].first;\n    \n    if(cnt > l){\n      return num;\n    }\n  }\n\n  if(cnt <= l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        cout << Ref() << endl;\n        break;\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tint back = 0;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(!del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tauto it = upper_bound(seg.begin(), seg.end(), ppiii(pii(s.first, 0), 0));\n\t\t\t\t\tseg.insert(it, ppiii(pii(s.first, l), id));\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\tback += len;\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second >= id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm> \n#include <map> \n#include <set>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{\"; for(auto nth : list){ cout << nth << \" \";}cout << \"}\" << endl;\n\nusing namespace std;\n\ntemplate<class T> T MIN(const T& a, const T& b) { return a < b ? a : b; }\ntemplate<class T> T MAX(const T& a, const T& b) { return a > b ? a : b; }\ntemplate<class T> void MIN_UPDATE(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void MAX_UPDATE(T& a, const T& b) { if (a < b) a = b; }\n\n\nstruct data{\n\tdata(int a,int b){\n\t\tlength=a;\n\t\tid=b;\n\t}\n\tint length;\n\tint id;\n};\n\nvector<data> sys;\n\nvoid write(int id,int len){\n\tif(sys.size()==0){\n\t\tsys.push_back(data(len,id));\n\t}else{\n\t\tint n=sys.size();\n\t\trep(i,n){\n\t\t\tif(len<=0) return;\n\t\t\tif(sys[i].id==-1){\n\t\t\t\tif(len-sys[i].length==0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}else if(len-sys[i].length<0){ //length???????????§??????\n\t\t\t\t\tsys.insert(sys.begin()+i+1,data(sys[i].length-len,-1));\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tsys[i].length=len;\n\t\t\t\t\treturn;\n\t\t\t\t}else if(len-sys[i].length>0){\n\t\t\t\t\tsys[i].id=id;\n\t\t\t\t\tlen-=sys[i].length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(len>0){//????????????????´???????????????§????????¨??????????????????????????????\n\t\t\t\tsys.push_back(data(len,id));\t\n\t\t}\n\n\t}\n}\n\nvoid read(int id){\n\tint len=0;\n//\trep(i,sys.size()){\n//\t\tcout << sys[i].id << \":\" << sys[i].length << \" \";\n//\t}\n//\tcout << endl;\n\n\trep(i,sys.size()){\n\t\tlen+=sys[i].length;\n\t\tif(len>id){\n\t\t\tcout <<  sys[i].id << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nvoid del(int id){\n\trep(i,sys.size()){\n\t\tif(sys[i].id==id){\n\t\t\tsys[i].id=-1;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tsys.clear();\n\t\t\n\t\trep(i,n){\n\t\t\tchar c;\n\t\t\tint I,S;\n\t\t\tcin >> c;\n\t\t\n\t\t\tif(c=='D'){\n\t\t\t\tcin >> I;\n\t\t\t\tdel(I);\n\t\t\t}else if(c=='W'){\n\t\t\t\tcin >> I >> S;\n\t\t\t\twrite(I,S);\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin >> I;\n\t\t\t\tread(I);\n\t\t\t}\t\t\n\t\t\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct file{\n  int s, e, num;\n};\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    list<file> sector;\n    char ope;\n    file tmp;\n    int len, num;\n    for (int i = 0; i < n; i++) {\n      cin >> ope;\n      list<file>::iterator ite = sector.begin();\n      // std::cout << \"setor:\" << std::endl;\n      // for (file f:sector){\n      //   std::cout << f.s << \" \" << f.e<< std::endl;\n      // }\n      if(ope == 'W'){\n        cin >> tmp.num >> len;\n        tmp.s = 0, tmp.e = len;\n        while(ite != sector.end() && len > 0){\n          if(tmp.s < ite->s) {\n            tmp.e = tmp.s + min(len, ite->s - tmp.s);\n            len -= tmp.e - tmp.s;\n            sector.insert(ite, tmp);\n          }\n          tmp.s = ite->e , tmp.e = tmp.s + len;\n          ite++;\n        }\n        if(len > 0)sector.insert(ite, tmp);\n      }else if(ope == 'D'){\n        cin >> num;\n        while(ite != sector.end() && ite->num != num)ite++;\n        sector.erase(ite);\n      }else if(ope == 'R'){\n        int pos;\n        cin >> pos;\n        pos--;\n        while(ite != sector.end() && !(ite->s <= pos && pos < ite->e) )ite++;\n        if(ite != sector.end())std::cout << ite->num << std::endl;\n        else std::cout << -1 << std::endl;\n      }\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nunordered_map<int, PII> dp;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    dp.clear();\n    dp[0] = {INF, -1};\n\n    REP(i, n) {\n      char c;\n      cin >> c;\n      int l, r;\n      if(c == 'W') {\n        cin >> l >> r;\n        int idx = 0, cnt = r;\n        while(true) {\n          // cout << idx << \" \" << cnt << \" \" << dp[idx]<< endl;\n          if(dp[idx].second == -1) {\n            // cout << \"-1\" << endl;\n            if(idx + cnt - 1 <= dp[idx].first) {\n              // cout << \"a\" << endl;\n              dp[idx+cnt] = {dp[idx].first, -1};\n              dp[idx].second = l;\n              dp[idx].first = idx+cnt-1;\n              break;\n            } else {\n              dp[idx].second = l;\n              cnt -= dp[idx].second - dp[idx].first + 1;\n              idx = dp[idx].first + 1;\n            }\n          } else {\n            idx = dp[idx].first + 1;\n          }\n        }\n      } else if(c == 'D') {\n        cin >> l;\n        for(auto& j: dp) if(j.second.second == l) j.second.second = -1;\n      } else if(c == 'R') {\n        cin >> l;\n        int idx = 0;\n        while(true) {\n          if(dp[idx].first >= l) {\n            cout << dp[idx].second << endl;\n            break;\n          } else {\n            idx = dp[idx].first + 1;\n          }\n        }\n      }\n      // for(auto& j: dp) cout << j.first << \" \" << j.second << endl;\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct data{\n    int d,end,ind;//識別子、長さ、最初のセクタ番号\n};\n\nvector<data> v;\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        v.clear();\n        data t;\n        t.ind = 0;\n        t.end = INF+10;\n        t.d = -1;\n        v.push_back(t);\n\n        rep(i,n){\n            string s;\n            cin >> s;\n            if(s == \"W\"){\n                int l,s;\n                cin >> l >> s;\n                for(j = 0; s > 0; j++){\n                    if(v[j].d != -1)continue;\n                    int tmp = v[j].end - v[j].ind + 1;\n                    if(tmp <= s){\n                        v[j].d = l;\n                        s -= tmp;\n                    }else{\n                        data t;\n                        t.ind = v[j].ind;\n                        t.d = l;\n                        t.end = v[j].ind + s - 1;\n                        v.insert(v.begin()+j,t);\n                        v[j+1].ind = v[j].end + 1;\n                        j++;\n                        s = 0;\n                    }\n                }\n            }\n            if(s == \"D\"){\n                int l;\n                cin >> l;\n                rep(j,v.size()){\n                    if(v[j].d == l)v[j].d = -1;\n                }\n            }\n            if(s == \"R\"){\n                int p;\n                cin >> p;\n                j = 0;\n                while(v[j].end < p)j++;\n                cout << v[j].d << endl;\n            }\n        }\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <list>\n\nusing namespace std;\n\nstruct Flagment {\n\tint file;\n\tint loc, len;\n\n\tFlagment(int f, int lo, int le) : file(f), loc(lo), len(le) {}\n};\n\nint main() {\n\twhile (true) {\n\t\tint N;\n\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0) break;\n\n\t\tlist<Flagment> files;\n\t\tfiles.push_back(Flagment(-1, 0, 1000000001));\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tchar c[2];\n\t\t\tscanf(\"%s\", c);\n\n\t\t\tif (c[0] == 'R') {\n\t\t\t\tint loc;\n\t\t\t\tint found = 0;\n\t\t\t\tscanf(\"%d\", &loc);\n\n\t\t\t\tfor (auto flag : files) {\n\t\t\t\t\tif (flag.loc <= loc && loc < flag.loc + flag.len) {\n\t\t\t\t\t\tprintf(\"%d\\n\", flag.file);\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c[0] == 'W') {\n\t\t\t\tint file, len;\n\t\t\t\tscanf(\"%d%d\", &file, &len);\n\n\t\t\t\tfor (auto it = files.begin(); it != files.end(); ++it) {\n\t\t\t\t\tFlagment &flag = *it;\n\t\t\t\t\tif (flag.file != -1) continue;\n\n\t\t\t\t\tflag.file = file;\n\t\t\t\t\tif (flag.len <= len) {\n\t\t\t\t\t\tlen -= flag.len;\n\t\t\t\t\t\tif (len == 0) break;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfiles.insert(++it, Flagment(-1, flag.loc + len, flag.len - len));\n\t\t\t\t\t\tflag.len = len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c[0] == 'D') {\n\t\t\t\tint file;\n\t\t\t\tscanf(\"%d\", &file);\n\n\t\t\t\tfor (auto &flag : files) {\n\t\t\t\t\tif (flag.file == file) flag.file = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\nclass zone{\npublic:\n\tint s,t,id;\n\tzone(int s,int t,int id):s(s),t(t),id(id){}\n};\n\n\nint main()\n{\n\tint n;\n\twhile(cin>>n && n!=0){\n\t\tlist<zone> L;\n\t\tfor(int i=0;i<n;i++){\n\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tint id,length;\n\t\t\t\tcin>>id>>length;\n\t\t\t\tint now=0;\n\t\t\t\tfor(list<zone>::iterator it=L.begin();it!=L.end();){\n\t\t\t\t\tzone look=*it;\n\t\t\t\t\tif(now<look.s){\n\t\t\t\t\t\tit=L.insert(it,zone(now,now+min(length,look.s-now)-1,id));\n\t\t\t\t\t\tlength=length-min(length,look.s-now);\n\t\t\t\t\t\tif(length==0) break;\n\t\t\t\t\t\tnow=look.t+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnow=look.t+1;\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tif(length!=0)\n\t\t\t\t\tL.push_back(zone(now,now+length-1,id));\n\t\t\t}\n\t\t\telse if(c=='D'){\n\t\t\t\tint id; cin>>id;\n\t\t\t\tfor(list<zone>::iterator it=L.begin();it!=L.end();){\n\t\t\t\t\tzone look=*it;\n\t\t\t\t\tif(look.id==id){\n\t\t\t\t\t\tit=L.erase(it);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint id;cin>>id;\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(list<zone>::iterator it=L.begin();it!=L.end();){\n\t\t\t\t\tzone look=*it;\n\t\t\t\t\tif(look.s>id){break;}\n\t\t\t\t\tif(look.s<=id && id<=look.t){ok=true;cout<<look.id<<endl;break;}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t\tif(!ok) cout<<-1<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tdel.push(pii(0, 1000000000));\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(len && !del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\ts.first  += l;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\tif(it == seg.begin()) puts(\"-1\");\n\t\t\t\t\telse{\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tif(it->first.first <= id && id < it->first.first + it->first.second) printf(\"%d\\n\", it->second);\n\t\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg.resize(t);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int i,j;\n  int n;\n  while(cin>>n,n){\n    pair<int,int> a[11000];\n    int m=0;\n    fill(a,a+11000,make_pair(-1,1<<30));\n    for(i=0;i<n;++i){\n      char s;\n      int p,q;\n      cin>>s>>p;\n      if(0){\n      }else if(s=='W'){\n\tcin>>q;\n\tfor(j=0;;){\n\t  for(;a[j].first!=-1;++j);\n\t  if(0){\n\t  }else if(a[j].second<q){\n\t    a[j].first=p;\n\t    q-=a[j].second;\n\t  }else if(a[j].second>q){\n\t    if(a[j].second!=(1<<30)){\n\t      copy_backward(a+j+1,a+m,a+m+1);\n\t      a[j+1]=make_pair(-1,a[j].second-q);\n\t    }\n\t    ++m;\n\t    a[j]=make_pair(p,q);\n\t    break;\n\t  }else{\n\t    a[j]=make_pair(p,q);\n\t    break;\n\t  }\n\t}\n      }else if(s=='D'){\n\tfor(j=0;j<m;++j){\n\t  if(a[j].first==p)\n\t    a[j].first=-1;\n\t}\n      }else if(s=='R'){\n\tlong long sm=0;\n\tfor(j=0;p>=sm+a[j].second;++j)\n\t  sm+=a[j].second;\n\tcout<<a[j].first<<endl;\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <list>\n\nusing namespace std;\n\nstruct Flagment {\n\tint file;\n\tint loc, len;\n\n\tFlagment(int f, int lo, int le) : file(f), loc(lo), len(le) {}\n};\n\ntypedef list<Flagment>::iterator iter_t;\n\nint main() {\n\twhile (true) {\n\t\tint N;\n\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0) break;\n\n\t\tlist<Flagment> files;\n\t\tfiles.push_back(Flagment(-1, 0, 1000000001));\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tchar c[2];\n\t\t\tscanf(\"%s\", c);\n\n\t\t\tif (c[0] == 'R') {\n\t\t\t\tint loc;\n\t\t\t\tint found = 0;\n\t\t\t\tscanf(\"%d\", &loc);\n\n\n\t\t\t\tfor (iter_t it = files.begin(); it != files.end(); ++it) {\n\t\t\t\t\tFlagment &flag = *it;\n\t\t\t\t\tif (flag.loc <= loc && loc < flag.loc + flag.len) {\n\t\t\t\t\t\tprintf(\"%d\\n\", flag.file);\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c[0] == 'W') {\n\t\t\t\tint file, len;\n\t\t\t\tscanf(\"%d%d\", &file, &len);\n\n\t\t\t\tfor (iter_t it = files.begin(); it != files.end(); ++it) {\n\t\t\t\t\tFlagment &flag = *it;\n\t\t\t\t\tif (flag.file != -1) continue;\n\n\t\t\t\t\tflag.file = file;\n\t\t\t\t\tif (flag.len <= len) {\n\t\t\t\t\t\tlen -= flag.len;\n\t\t\t\t\t\tif (len == 0) break;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfiles.insert(++it, Flagment(-1, flag.loc + len, flag.len - len));\n\t\t\t\t\t\tflag.len = len;\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c[0] == 'D') {\n\t\t\t\tint file;\n\t\t\t\tscanf(\"%d\", &file);\n\n\t\t\t\tfor (iter_t it = files.begin(); it != files.end(); ++it) {\n\t\t\t\t\tFlagment &flag = *it;\n\t\t\t\t\tif (flag.file == file) flag.file = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main(){\n\twhile(1){\n\t\tstd::vector<int> v(1,-1);\n\t\tint a;\n\t\tstd::cin>>a;\n\t\tif(a==0)break;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tchar x;\n\t\t\tint p,q;\n\t\t\tstd::cin>>x;\n\t\t\tif(x=='W'){\n\t\t\t\tstd::cin>>p>>q;\n\t\t\t\tfor(int j=0;j<v.size()&&j<=1000000000;j++){\n\t\t\t\t\tif(v[j]==-1)v[j]=p,q--;\n\t\t\t\t\tif(q==0)break;\n\t\t\t\t\twhile(j==v.size()-1&&q!=0)v.push_back(p),q--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x=='D'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==p)v[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(x=='R'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tif(p-1>v.size())std::cout<<\"-1\"<<std::endl;\n\t\t\t\telse std::cout<<v[p-1]<<std::endl;\n\t\t\t}\n\t\t}\n\t\tstd::cout<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\ntypedef struct node{\n\tnode* mae;\n\tnode* ato;\n\tint s;\n\tint t;\n\tint val;\n}node;\n\nnode *newnode(int l,int r){\n\tnode* rr=new node;\n\trr->s=l;\n\trr->t=r;\n\trr->val=-1;\n\treturn rr;\n}\n\n\n signed main(){\n\n  //  \t       cin.tie(0);\n  // \t\t\tios::sync_with_stdio(false);\n\n\n \twhile(1){\n \tnode* st=newnode(-inf,-1);\n \tnode* las=newnode(inf*100000000ll,inf*100000000ll+3ll);\n \tst->ato=las;\n \t\n \t\n \tint n;\n \tcin>>n;\n \t\tif(n==0)break;\n \t\t\n \t\tfor(int er=0;er<n;er++){\n \t\tstring str;\n \t\t\tcin>>str;\n \t\t\tif(str==\"W\"){\n \t\t\t\tnode* ima=st;\n \t\t\t\tint no,val;\n \t\t\t\tcin>>val>>no;\n \t\t\t\twhile(1){\n \t\t\t\t\tif(ima->t+1!=ima->ato->s){\n \t\t\t\t\t\tint e;\n \t\t\t\t\t\te=ima->ato->s-ima->t-1;\n \t\t\t\t\t\tnode* nn=newnode(ima->t+1,ima->t+min(e,no));\n \t\t\t\t\t\tno-=min(e,no);\n \t\t\t\t\t\tnn->val=val;\n \t\t\t\t\t\tnn->ato=ima->ato;\n \t\t\t\t\t\tima->ato=nn;\n \t\t\t\t\t}\n \t\t\t\t\tif(no==0) break;\n \t\t\t\t\tima=ima->ato;\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(str==\"R\"){\n \t\t\t\tnode* ima=st;\n \t\t\t\tint e;\n \t\t\t\tcin>>e;\n \t\t\t\twhile(1){\n \t\t\t\t\tif(ima->s > e){\n \t\t\t\t\t\tcout<<-1<<endl;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tif(ima->s <= e && e<= ima->t){\n \t\t\t\t\t\tcout<<ima->val<<endl;\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t\t\tima=ima->ato;\n \t\t\t\t\t\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(str==\"D\"){\n \t\t\t\tint val;\n \t\t\t\tcin>>val;\n \t\t\t\tnode* ima=st;\n \t\t\t\twhile(1){\n \t\t\t\t\tlll:;\n \t\t\t\t\tif(ima->ato->val==val){\n \t\t\t\t\t\tima->ato=ima->ato->ato;\n \t\t\t\t\t\tgoto lll;\n \t\t\t\t\t}\n \t\t\t\t\tima=ima->ato;\n \t\t\t\t\tif(ima==las) break;\n \t\t\t\t}\n \t\t\t}\n \t\t\n \t\t}\n \t\tcout<<endl;\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                            break;\n                        }\n                    }\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    idx--;\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iterator>\n#define vecsize 1000000000\nint vec[vecsize];\nvoid W(int x,int y){\n    for(int i=0;i<vecsize;++i){\n        if(y>0)if(vec[i]==-1)vec[i]=x,--y;\n    }\n}\nvoid D(int x){\n    int size=vecsize-1;\n    if(x<=size)for(int i=vecsize-1;i>=0;--i){\n        if(vec[i]==x){\n            vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vecsize;\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n            for(int i=0;i<vecsize;++i){\n                std::cout<<vec[i]<<\":\";\n            }\n            std::cout<<std::endl;\n        }\n        b=false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef int ll;\ntypedef pair<int,int>P;\n#define MX 1000000001\nint N,d1[10005],d2[10005],cnt;\nchar c[10005];\n\nstruct BIT\n{\n\tvector<ll>T;\n\tint n;\n\tBIT( int n):n(n+1),T(n+1,0){}\n\tll _sum( int p){ll res=0;for (;p>0;p-=p&-p)res+=T[p];return res;}\n\tll sum( int r,int l){return _sum(l)-_sum(r);};\n\tvoid add(int i,int x){ for(;i<n;i+=i&-i)T[i]+=x;}\n};\n\n\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tvector<P>T;\n\t\tT.push_back(make_pair(-10000,0));\n\t\tmap<int,vector<int> >D;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%c\",&c[i]);\n\t\t\tif(c[i]=='W')scanf(\"%d%d\\n\",&d1[i],&d2[i]);\n\t\t\telse \n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1[i]);\n\t\t\t\tif(c[i]=='R')\n\t\t\t\t\tT.push_back(make_pair(d1[i],-1));\n\t\t\t}\n\t\t}\n\t\tsort(T.begin(),T.end());\n\t\tBIT SEQ(T.size());\n\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(c[i]=='R')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<T.size();j++)\n\t\t\t\t\tif(T[j].first==d1[i])\n\t\t\t\t\t\tprintf(\"%d\\n\",T[j].second);\n\t\t\t}\n\t\t\telse if(c[i]=='D')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<D[d1[i]].size();j++)\n\t\t\t\t\tSEQ.add(j,-D[d1[i]][j]);\n\t\t\t\tfor(int j=0;j<T.size();j++)\n\t\t\t\t\tif(T[i].first==d1[i])\n\t\t\t\t\t\tT[i].first=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[d1[i]].push_back(0);\n\t\t\t\tfor(int j=1,s=d2[i];j<T.size();j++)\n\t\t\t\t{\n\t\t\t\t\tint ins=0,emp=T[j].first-SEQ._sum(j)+1;\n\t\t\t\t\tif(emp>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s>=emp)T[j].second=d1[i];\n\t\t\t\t\t\tins=min(s,emp);\n\t\t\t\t\t\ts-=min(s,emp);\n\t\t\t\t\t}\n\t\t\t\t\tSEQ.add(j,ins);\n\t\t\t\t\tD[d1[i]].push_back(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tfor(int i=0;i<=10000;i++)place[i].clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve(){\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return;\n\t\tlist<pair<int, int>> inputs;\n\t\tinputs.push_back(mp(-1, 2e9));\n\t\tREP(i, n) {\n\t\t\tstring a;\n\t\t\tcin >> a;\n\t\t\tif (a == \"W\") {\n\t\t\t\tauto x = inputs.begin();\n\t\t\t\tint b, c;\n\t\t\t\tcin >> b >> c;\n\t\t\t\twhile (c != 0) {\n\t\t\t\t\tif ((*x).first == -1) {\n\t\t\t\t\t\tif ((*x).second <= c) {\n\t\t\t\t\t\t\t(*x).first = b;\n\t\t\t\t\t\t\tc -= (*x).second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tx = inputs.insert(x, mp(b, c));\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t(*x).second -= c;\n\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a == \"D\") {\n\t\t\t\tauto x = inputs.begin();\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\twhile (x != inputs.end()) {\n\t\t\t\t\tif ((*x).first == b) {\n\t\t\t\t\t\t(*x).first = -1;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (a == \"R\") {\n\t\t\t\tauto x = inputs.begin();\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tb++;\n\t\t\t\twhile (true) {\n\t\t\t\t\tif ((*x).second >= b) {\n\t\t\t\t\t\tcout << (*x).first << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tb -= (*x).second;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << endl;\n\t}\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 1145141919;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nvector<vector<pii>> v;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tv.clear();\n\t\tv.resize(1);\n\t\tv[0].push_back(pii(0, INF));\n\t\tvi index;\n\t\tindex.push_back(-1);\n\t\tREP(i, n)\n\t\t{\n\t\t\tchar c; int q;\n\t\t\tcin >> c >> q;\n\t\t\tif (c == 'W')\n\t\t\t{\n\t\t\t\tindex.push_back(q);\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tvector<pii> emp;\n\t\t\t\tv.push_back(emp);\n\t\t\t\tint cnt = 0;\n\t\t\t\tfor (int j = 0;; j++)\n\t\t\t\t{\n\t\t\t\t\tif (v[0][j].second - v[0][j].first >= t)\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(pii(v[0][j].first,v[0][j].first+t));\n\t\t\t\t\t\tif (v[0][j].second - v[0][j].first == t) cnt++;\n\t\t\t\t\t\telse v[0][j].first += t;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tv.back().push_back(v[0][j]);\n\t\t\t\t\t\tt -= v[0][j].first - v[0][j].second;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[0].erase(v[0].begin(), v[0].begin() + cnt);\n\t\t\t}\n\t\t\telse if (c == 'D')\n\t\t\t{\n\t\t\t\tint p = find(ALL(index), q)-index.begin();\n\t\t\t\tv[0].insert(v[0].end(),ALL(v[p]));\n\t\t\t\tv[p].erase(ALL(v[p]));\n\t\t\t\tsort(ALL(v[0]));\n\t\t\t\tbool up = true;\n\t\t\t\twhile (up)\n\t\t\t\t{\n\t\t\t\t\tup = false;\n\t\t\t\t\tREP(i, v[0].size() - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (v[0][i].second == v[0][i + 1].first)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tup = true;\n\t\t\t\t\t\t\tv[0][i] = v[0][i + 1] = pii(v[0][i].first, v[0][i + 1].second);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tauto a = unique(ALL(v[0]));\n\t\t\t\tv[0].erase(a, v[0].end());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tREP(i, v.size())\n\t\t\t\t{\n\t\t\t\t\tREP(j, v[i].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (q >= v[i][j].first&&q < v[i][j].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (i == 0) puts(\"-1\");\n\t\t\t\t\t\t\telse cout << index[i] << endl;\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst ll INF = 1L << 40;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        PQ que;\n        que.push(P(0,INF));\n        map<P,int> m;\n        while (n--) {\n            char c;\n            cin >> c;\n            if (c == 'W') {\n                ll t, l;\n                cin >> t >> l;\n                P p;\n                while (true) {\n                    p = que.top(); que.pop();\n                    ll s = p.first, g = p.second;\n                    if (s + l - 1 <= g) {\n                        if (s + l - 1 < g)\n                            que.push(P(s + l, g));\n                        m[P(s, s + l - 1)] = t;\n                        break;\n                    } else {\n                        m[P(s, g)] = t;\n                        l -= g - s + 1;\n                    }\n                }\n            } else if (c == 'D') {\n                ll t; cin >> t;\n                for (auto i : m) {\n                    if (i.second == t) {\n                        que.push(i.first);\n                        m.erase(m.find(i.first));\n                    }\n                }\n            } else {\n                ll x; cin >> x;\n                bool flag = true;\n                for (auto i : m) {\n                    if (i.first.first <= x && x <= i.first.second) {\n                        cout << i.second << endl;\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag)\n                    cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct List{\n\tint id, cnt;\n\tList *nxt;\n};\n\nvoid _delete(List *p){\n\tif (p == nullptr) return;\n\t_delete(p->nxt);\n\tdelete p;\n}\n\nvoid erase(List *p, int id){\n\tif (p == nullptr) return;\n\tif (p->id == id) p->id = -1;\n\terase(p->nxt, id);\n}\n\nint find(List *p, int pos){\n\tif (p == nullptr) return -1;\n\tif (p->cnt > pos) return p->id;\n\treturn find(p->nxt, pos - p->cnt);\n}\n\nList* add(List *p, int id, int cnt){\n\tif (!cnt) return p;\n\tif (p == nullptr)return new List{id, cnt, nullptr};\n\tif (p->id < 0){\n\t\tp->id = id;\n\t\tif (p->cnt > cnt){\n\t\t\tList *nl = new List{ -1, p->cnt - cnt, p->nxt };\n\t\t\tp->cnt -= cnt;\n\t\t\tp->nxt = nl;\n\t\t\treturn p;\n\t\t}\n\t\tcnt -= p->cnt;\n\t}\n\tp->nxt = add(p->nxt, id, cnt);\n\treturn p;\n}\n\nint main(){\n\tList *head = new List();\n\tint n;\n\twhile (cin >> n, n){\n\t\twhile (n--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint id, cnt;\n\t\t\t\tcin >> id >> cnt;\n\t\t\t\thead->nxt = add(head->nxt, id, cnt);\n\t\t\t}\n\t\t\telse if (c == 'D'){\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\terase(head->nxt, id);\n\t\t\t}\n\t\t\telse if (c == 'R'){\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << find(head->nxt, pos) << '\\n';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t\t_delete(head->nxt);\n\t\thead->nxt = nullptr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\n#define SC unsigned long long\n#define ID int\n#define PP pair<SC,ID> // セクタ数、識別子\n#define P pair<SC,PP > // セクタ開始、セクタ数、識別子\nusing namespace std;\n\nP makeP(SC s,SC n,ID id){ return P( s,PP(n,id) ); }\n\nint main(){\n  int n;\n  char cmd;\n  SC sc, inf = (SC)(1<<31) * (SC)(1<<20);;\n  ID id;\n  vector<P> v; // 使用中\n  priority_queue< P,vector<P>, greater<P> > q; // 空き領域\n\n  while( cin>>n && n ){\n    v.clear();\n    while( !q.empty() ) q.pop();\n    q.push( makeP(0,inf,-1) );\n\n    //    cout << \"N=\" << n << \"*************\" << endl;    \n    while( n-- ){\n      cin >> cmd;\n      /*\n      cout << \" CMD=\"<< cmd << \" vlen=\"<<v.size()\n\t   << \" qlen=\"<<q.size() << endl;\n      for( unsigned int i=0;i<v.size();i++ )\n\tcout << \"  \"<< v[i].first << \" \" << v[i].second.first\n\t     << \" |\" << v[i].second.second << endl;\n      cout << \"  q.f \" << q.top().first \n\t   << \" q.sf \"<< q.top().second.first << endl;\n      */\n      switch( cmd ){\n      case 'W':\n\tcin >> id >> sc;\n\twhile( sc>0 ){\n\t  P p=q.top(); q.pop();\n\t  SC bgn = p.first, len = p.second.first;\n\t  if( sc<len ){\n\t    v.push_back( makeP(bgn,sc,id) );\n\t    q.push( makeP(bgn+sc,len-sc,-1) );\n\t    sc=0;\n\t  }else{\n\t    v.push_back( makeP(bgn,len,id) );\n\t    sc -= len;\n\t  }\n\t}\n\tbreak;\n      case 'D':\n\tcin >> id;\n\tfor( unsigned int i=0;i<v.size(); ){\n\t  if( v[i].second.second == id ){\n\t    q.push( v[i] );\n\t    v.erase( v.begin()+i );\n\t  }else\n\t    i++;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> sc;\n\tunsigned int i=0;\n\twhile( i<v.size() ){\n\t  if( v[i].first <= sc && sc<= v[i].first+v[i].second.first ){\n\t    cout << v[i].second.second << endl;\n\t    break;\n\t  }\n\t  i++;\n\t}\n\tif( i==v.size() )\n\t    cout << \"-1\" << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nvector<ppiii> seg;\npriority_queue<pii, vector<pii>, greater<pii> > del;\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tseg.clear();\n\t\tdel.clear();\n\t\tint back = 0;\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(!del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tif(len){\n\t\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\t\tback += len;\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second >= id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct data{\n    int d,len,ind;//識別子、長さ、最初のセクタ番号\n};\n\nvector<data> v;\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        v.clear();\n        data t;\n        t.ind = 0;\n        t.len = INF+10;\n        t.d = -1;\n        v.push_back(t);\n\n        rep(i,n){\n            string s;\n            cin >> s;\n            if(s == \"W\"){\n                int l,s;\n                cin >> l >> s;\n                rep(j,v.size()){\n                    if(v[j].d == -1){\n                        if(v[j].len == s){\n                            v[j].d = l;\n                            break;\n                        }else if(v[j].len < s){\n                            v[j].d = l;\n                            s -= v[j].len;\n                        }else{\n                            data t;\n                            t.ind = v[j].ind + s;\n                            t.d = -1;\n                            t.len = v[j].len - s;\n                            v[j].d = l;\n                            v[j].len = s;\n                            v.insert(v.begin()+j+1,t);\n                            break;\n                        }\n                    }\n                }\n            }\n            if(s == \"D\"){\n                int l;\n                cin >> l;\n                rep(j,v.size()){\n                    if(v[j].d == l)v[j].d = -1;\n                }\n            }\n            if(s == \"R\"){\n                int p;\n                cin >> p;\n                rep(j,v.size()){\n                    //cout << v[j].ind << \" \" << v[j].d << \" \" << v[j].len << endl;\n                    if(v[j].ind >= p){\n                        break;\n                    }\n                }\n                cout << v[j-1].d << endl;\n\n            }\n        }\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n   \nusing namespace std;\n \nconst int LIMIT = 1000000000;\n \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n   \nint N;\nvector<Data> storage;\n  \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n       \n      if(st > LIMIT) return;\n    }\n    if(num == -1) {\n      // insert data back\n      num = remain;\n      if(st+num > LIMIT) {\n        num = LIMIT - (st+num);\n\tremain = num;\n\tif(remain == 0) return;\n      }\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n \nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n   \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(c,c+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(c,c+k-1)]=n;\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <algorithm>\n#include <set>\n#include <vector>\n\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\n\nstruct range {\n  int beg, ed;\n  int num;\n};\n\nint main()\n{\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    list<range> s;\n    REP(i,n){\n      string c;\n      cin>>c;\n      if(c==\"W\"){\n        int l,S;\n        cin >> l >> S;\n        int old = 0;\n        for(auto itr=begin(s);itr!=end(s);++itr){\n          auto r = *itr;\n          if(old < r.beg) {\n            int len = min(r.beg-old, S);\n            s.insert(itr, {old, old + len, l});\n            S -= len;\n            if (S <= 0) break;\n          }\n          old  = r.ed;\n        }\n        if(S > 0) {\n          s.push_back({old, old + S, l});\n        }\n      } else if (c == \"D\") {\n        int l;\n        cin>>l;\n        auto itr = remove_if(begin(s),end(s),[=](const range& r){return r.num == l;});\n        s.erase(itr, end(s));\n      } else {\n        int p;\n        cin>>p;\n        auto itr = find_if(begin(s),end(s),[=](const range& r){return r.beg <= p && p < r.ed;});\n        if (itr != end(s))\n          cout<<itr->num<<endl;\n        else\n          cout<<-1<<endl;\n      }\n      //for(auto r:s)cout<<\"(\"<<r.beg<<\",\"<<r.ed<<\"):\"<<r.num<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n\n#define int long long\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e18 + 10;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nsigned main(){\n\tint n;\n\twhile(cin >> n && n) {\n\t\tmap<pii, int> empty;\n\t\tmap<pii, int> writed;\n\t\tmap<int, vector<pii> > v;\n\t\tempty[{0,INF}] = 1;\n\t\trep(_, n) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif(s == \"W\") {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\tfor(auto it = empty.begin(); it != empty.end();) {\n\t\t\t\t\tint l = it -> fi.se - it -> fi.fi;\n\t\t\t\t\tif(l == b) {\n\t\t\t\t\t\twrited[it->fi] = a;\n\t\t\t\t\t\tv[a].pb(it->fi);\n\t\t\t\t\t\tit = empty.erase(it);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(l > b) {\n\t\t\t\t\t\tpii p = {it->fi.fi, it->fi.fi+b};\n\t\t\t\t\t\tpii q = {it->fi.fi+b, it->fi.se};\n\t\t\t\t\t\twrited[p] = a;\n\t\t\t\t\t\tv[a].pb(p);\n\t\t\t\t\t\tit = empty.erase(it);\n\t\t\t\t\t\tempty[q] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\t// l < b\n\t\t\t\t\t\twrited[it->fi] = a;\n\t\t\t\t\t\tv[a].pb(it->fi);\n\t\t\t\t\t\tit = empty.erase(it);\n\t\t\t\t\t\tb -= l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(s == \"D\") {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tauto& b = v[a];\n\t\t\t\twhile(b.size() > 0) {\n\t\t\t\t\tauto p = b.back();\n\t\t\t\t\twrited.erase(p);\n\t\t\t\t\tempty[p] = 1;\n\t\t\t\t\tb.pop_back();\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tint b = -1;\n\t\t\t\tfor(auto& p : writed) {\n\t\t\t\t\tif(p.fi.fi <= a && a < p.fi.se) {\n\t\t\t\t\t\tb = p.se;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << b << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nconst int INF = 1000000010;\n\nstruct Segment{\n    int pos, size, id;\n    Segment(int pos, int size, int id): pos(pos), size(size), id(id) {}\n    bool operator<(const Segment& right ) const {\n        return pos == right.pos ? size < right.size : pos < right.pos;\n    }\n};\n\nint main(){\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n\n        set<Segment> empty;\n        empty.emplace(0, INF, -1);\n        set<Segment> occupied;\n        \n        for(int i=0;i<N;i++){\n            char cmd;\n            cin >> cmd;\n            if(cmd == 'W'){\n                int id, size;\n                cin >> id >> size;\n                while(true){\n                    Segment u = *empty.begin();\n                    empty.erase(empty.begin());\n                    if(u.size < size){\n                        size -= u.size;\n                        u.id = id;\n                        occupied.insert(u);\n                    }else{\n                        empty.emplace(u.pos + size, u.size - size, -1);                    \n                        occupied.emplace(u.pos, size, id);\n                        break;\n                    }\n                }\n            }else if(cmd == 'D'){\n                int id;\n                cin >> id;\n                for(auto it=occupied.begin();it!=occupied.end();){\n                    if(it->id == id){\n                        empty.insert(*it);\n                        occupied.erase(it++);\n                    }else{\n                        it++;\n                    }\n                }\n            }else{\n                int pos;\n                cin >> pos;\n                auto it = occupied.lower_bound(Segment(pos, INF, INF));\n                bool found = false;\n                if(it != occupied.begin()){\n                    auto prev = next(it, -1);\n                    if(prev->pos <= pos && pos < prev->pos + prev->size){\n                        cout << prev->id << endl;\n                        found = true;\n                    }\n                }\n                if(!found){\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct Data{\n\tint id,pos,len;\n\tData(){}\n\tData(int I,int P,int L):id(I),pos(P),len(L){}\n};\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tlist<Data> L;\n\t\twhile(n--){\n\t\t\tchar type; scanf(\" %c\",&type);\n\t\t\tif(type=='W'){\n\t\t\t\tint id,len; scanf(\"%d%d\",&id,&len);\n\t\t\t\tint pos=0;\n\t\t\t\tlist<Data>::iterator it;\n\t\t\t\tfor(it=L.begin();it!=L.end();++it){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(pos<a.pos){\n\t\t\t\t\t\tint d=min(a.pos-pos,len);\n\t\t\t\t\t\tlen-=d;\n\t\t\t\t\t\tL.insert(it,Data(id,pos,d));\n\t\t\t\t\t}\n\t\t\t\t\tif(len==0) break;\n\t\t\t\t\tpos=a.pos+a.len;\n\t\t\t\t}\n\t\t\t\tif(len>0){\n\t\t\t\t\tL.insert(it,Data(id,pos,len));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(type=='D'){\n\t\t\t\tint id; scanf(\"%d\",&id);\n\t\t\t\tlist<Data>::iterator it;\n\t\t\t\tfor(it=L.begin();it!=L.end();){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(id==a.id) it=L.erase(it);\n\t\t\t\t\telse ++it;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{ // type=='R'\n\t\t\t\tint pos; scanf(\"%d\",&pos);\n\t\t\t\tint ans=-1;\n\t\t\t\tlist<Data>::iterator it;\n\t\t\t\tfor(it=L.begin();it!=L.end();++it){\n\t\t\t\t\tData &a=*it;\n\t\t\t\t\tif(a.pos<=pos && pos<a.pos+a.len){\n\t\t\t\t\t\tans=a.id;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos<a.pos) break;\n\t\t\t\t}\n\t\t\t\tprintf(\"%d\\n\",ans);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\ntemplate <typename T> constexpr T inf = numeric_limits<T>::has_infinity ? numeric_limits<T>::infinity() : numeric_limits<T>::max() / 4;\n\n#define REP(i, stop) FOR(i, 0, stop)\n#define FOR(i, start, stop) for (int i = start, i##_len = stop; i < i##_len; ++i)\n\nstruct InitCpp { InitCpp() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(10); } } initCpp;\n\nstruct Fragment {\n  i64 from;\n  i64 to;\n  i64 id;\n};\n\nsigned main() {\n  while (true) {\n    i64 n;\n    cin >> n;\n    if (n == 0) break;\n    list<Fragment> mem;\n    mem.push_back({0, inf<i64>, -1});\n    REP(_, n) {\n      char c;\n      cin >> c;\n      if (c == 'W') {\n        i64 i, s;\n        cin >> i >> s;\n        for (auto iter = mem.begin(); iter != mem.end(); ++iter) {\n          Fragment f = *iter;\n          if (f.id == -1) {\n            if (f.to - f.from > s) {\n              Fragment g = *mem.insert(iter, {f.from, f.from + s, i});\n              iter->from = g.to;\n              // f.from = g.to;\n              // *iter = f;\n              break;\n            } else {\n              s -= f.to - f.from;\n              iter->id = i;\n              // f.id = i;\n              // *iter = f;\n              if (s == 0) break;\n            }\n          }\n        }\n      }\n      if (c == 'D') {\n        i64 i;\n        cin >> i;\n        for (auto& f : mem) {\n          if (f.id == i) {\n            f.id = -1;\n          }\n        }\n      }\n      if (c == 'R') {\n        i64 p;\n        cin >> p;\n        p -= 1;\n        for (auto f : mem) {\n          if (f.from <= p && p < f.to) {\n            cout << f.id << endl;\n            goto read;\n          }\n        }\n        cout << -1 << endl;\n        read:;\n      }\n      // for (auto f : mem) {\n      //   cerr << f.from << \" \" << f.to << \" \" << f.id << \"; \";\n      // }\n      // cerr << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\nint main(){\n\tset< pair< pair<int,int> , int> > se;\n\tint N;\n\twhile(cin >> N && N){\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s == \"D\" ){\n\t\t\t\tint v;\n\t\t\t\tcin >> v;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;){\n\t\t\t\t\tif( it->second == v ){\n\t\t\t\t\t\tse.erase(it++);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t++it;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if( s == \"W\" ){\n\t\t\t\tint l,sec;\n\t\t\t\tcin >> l >> sec;\n\t\t\t\tint prev = 0;\n\t\t\t\tvector< pair<int,int> > ad;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( sec == 0 ) break;\n\t\t\t\t\tint width = it->first.first - prev;\n\t\t\t\t\tint use = min(sec,width);\n\t\t\t\t\tif( use != 0 ) {\n\t\t\t\t\t\tsec -= use;\n\t\t\t\t\t\tad.push_back(make_pair(prev,prev+use));\n\t\t\t\t\t}\n\t\t\t\t\tprev = it->first.second;\n\t\t\t\t}\n\t\t\t\tif( sec != 0 ){\n\t\t\t\t\tad.push_back(make_pair(prev,prev+sec));\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < ad.size() ; i++)\n\t\t\t\t\tse.insert(make_pair(ad[i],l));\n\t\t\t}else{\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tint flag = 0;\n\t\t\t\tfor( set< pair< pair<int,int> , int> >:: iterator it = se.begin(); it != se.end() ;++it){\n\t\t\t\t\tif( it->first.first <= pos && pos < it->first.second ){\n\t\t\t\t\t\tcout << it->second << endl;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !flag ){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000010\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint n;\nvector<PP> v;\n\nvoid solve(){\n\tv.clear();\n\trep(i,n){\n\t\tchar x; cin >> x;\n\t\tif(x == 'D'){\n\t\t\tint l; cin >> l;\n\t\t\trep(j,v.size()) if(v[j].second == l){\n\t\t\t\tv[j].first.first = INF;\n\t\t\t}\n\t\t\tsort(v.begin(),v.end());\n\t\t\twhile(true){\n\t\t\t\tif(v.size() == 0) break;\n\t\t\t\tif(v[v.size()-1].first.first != INF) break;\n\t\t\t\tv.pop_back();\n\t\t\t}\n\t\t} else if(x == 'R'){\n\t\t\tint p; cin >> p;\n\t\t\tbool ok = false;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first <= p && p <= v[j].first.second){\n\t\t\t\t\tcout << v[j].second << endl;\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) puts(\"-1\");\n\t\t} else{\n\t\t\tint l, s; cin >> s >> l;\n\t\t\tint st = 0;\n\t\t\trep(j,v.size()){\n\t\t\t\tif(v[j].first.first > st){\n\t\t\t\t\tif(l <= v[j].first.first-st){\n\t\t\t\t\t\tv.push_back(PP(P(st,st+l-1),s));\n\t\t\t\t\t\tl = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else{\n\t\t\t\t\t\tv.push_back(PP(P(st,v[j].first.first-1),s));\n\t\t\t\t\t\tl -= v[j].first.first-st;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tst = v[j].first.second+1;\n\t\t\t\tif(st > INF){\n\t\t\t\t\tl = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l > 0) v.push_back(PP(P(st,st+l-1),s));\n\t\t\tsort(v.begin(),v.end());\n\t\t}\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\ntypedef map<pair<int,int>,int> mpiii;\n\nvoid solve(int T){\n\tmpiii m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(mpiii::iterator it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tmpiii::iterator it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tmpiii::iterator it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(mpiii::iterator it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[make_pair(cur,cur+z-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tint back = 0;\n\t\tint sorted = 1;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(!del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tif(len){\n\t\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\t\tback += len;\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second >= id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\nstruct Node {\n  int begin, end, id;  // range is [begin, end)\n  Node* next;\n  Node(int begin, int end, int id)\n    : begin(begin), end(end), id(id), next(NULL) {}\n\n  void insert(Node* new_next) {\n    new_next->next = next;\n    next = new_next;\n  }\n  void remove(Node* prev) {\n    prev->next = next;\n    delete this;\n  }\n};\n\nvoid removeSome(Node* root, int id) {\n  for (Node *node = root->next, *prev = root;\n       node;\n       prev = node, node = node->next) {\n    if (id >= 0 ? (node->id == id) : (node->id != -1)) {\n      node->remove(prev);\n      node = prev;\n    }\n  }\n}\n\nint main() {\n  int n;\n  Node* root = new Node(-1,0,-1);\n  int INF = 1000000000 + 5;\n  Node* last = new Node(INF, INF+1, -1);\n  root->next = last;\n\n  ios::sync_with_stdio(false);\n\n  while(cin >> n, n) {\n    rep(_,n) {\n      char cmd;\n      cin >> cmd;\n      if (cmd == 'W') {\n        int id, s;\n        cin >> id >> s;\n        for (Node *node = root->next, *prev = root;\n             node && s > 0;\n             prev = node, node = node->next) {\n          int diff = node->begin - prev->end;\n          if (diff > 0) {\n            int size = min(s, diff);\n            prev->insert(new Node(prev->end, prev->end + size, id));\n            s -= size;\n          }\n        }\n      }\n      else if (cmd == 'D') {\n        int id;\n        cin >> id;\n        removeSome(root, id);\n      }\n      else if (cmd == 'R') {\n        int addr;\n        cin >> addr;\n        for (Node *node = root->next;\n             node;\n             node = node->next) {\n          if (addr < node->end) {\n            if (node->begin <= addr) cout << node->id << \"\\n\";\n            else cout << \"-1\\n\";\n            break;\n          }\n        }\n      }\n    }\n\n    removeSome(root, -1);  //clear\n    cout << \"\\n\";  // puts(\"\")とios::sync_with_stdio(false)を同時に使うと死ぬ\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//:55-\n#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  map[make_pair(h,e-1)]=I;\n\t  S-=h-e;\n\t}else{\n\t  map[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tIf(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Block{\npublic:\n    int label, start, size;\n    Block(int label, int start, int size): label(label), start(start), size(size){};\n};\n\nint N;\n\nvoid write(vector<Block> &blocks, int label, int size){\n    for(int i=0; i<blocks.size(); i++){\n        if(blocks[i].label == -1){\n            if(size == blocks[i].size){\n                blocks[i].label = label;\n                break;\n            }else if(size < blocks[i].size){\n                int start = blocks[i].start;\n                int lest_size = blocks[i].size - size;\n                auto it = blocks.erase(blocks.begin() + i);\n                it = blocks.insert(it, Block(-1, start+size+1, lest_size));\n                blocks.insert(it, Block(label, start, size));\n                break;\n            }else{\n                blocks[i].label = label;\n                size -= blocks[i].size;\n            }\n        }\n    }\n}\n\nvoid del(vector<Block> &blocks, int label){\n    //?????????????????£????????????????????????\n    for(int i=0; i<blocks.size(); i++)\n        if(blocks[i].label == label)\n            blocks[i].label = -1;\n    \n}\n\nvoid read(vector<Block> &blocks, int pointer){\n    for(int i=0; i<blocks.size(); i++)\n        if(blocks[i].start <= pointer && pointer <= blocks[i].start + blocks[i].size)\n            cout << blocks[i].label << endl;\n}\n\nvoid solve(){\n    vector<Block> blocks;\n    blocks.push_back(Block(-1, 0, INF));\n    \n    char c;\n    while(N--){\n        cin >> c;\n        if(c == 'W'){\n            int label, size;\n            cin >> label >> size;\n            write(blocks, label, size);\n        }\n        if(c == 'D'){\n            int label; cin >> label;\n            del(blocks, label);\n        }\n        if(c == 'R'){\n            int pointer; cin >> pointer;\n            read(blocks, pointer);\n        }\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(10);\n    \n    while(cin>>N, N){\n        solve();\n        cout << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int n,a,b,cnt;\n  char c;\n  int inv[10010];\n  vector<P> v[10010];\n  map<int,int> m;\n\n  bool first = true;\n\n  while(cin >> n,n){\n    v[0].clear();\n    v[0].push_back(P(0,1000000001));\n    inv[0] = -1;\n    m.clear();\n    m[0] = 0;\n    cnt = 1;\n    \n    while(n--){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tint tmp = m[a] = cnt;\n\tv[tmp].clear();\n\tinv[cnt] = a;\n\tcnt++;\n\twhile(b){\n\t  if(b<v[0][0].second){\n\t    v[tmp].push_back(P(v[0][0].first,b));\n\t    v[0][0].first += b;\n\t    v[0][0].second -= b;\n\t    b = 0;\n\t  }else{\n\t    v[tmp].push_back(v[0][0]);\n\t    b -= v[0][0].second;\n\t    v[0].erase(v[0].begin());\n\t  }\n\t} \n      }else if(c == 'D'){\n\tcin >> a;\n\tint tmp = m[a];\n\tfor(int i=0;i<(int)v[tmp].size();i++)v[0].push_back(v[tmp][i]);\n\tsort(v[0].begin(),v[0].end());\n\tv[tmp].clear();\n      }else{\n\tcin >> a;\n\tbool f = true;;\n\tfor(int i=0;i<cnt;i++){\n\t  for(int j=0;j<(int)v[i].size();j++){\n\t    if(v[i][j].first<= a && a<v[i][j].first+v[i][j].second){\n\t      cout << inv[i] << endl;\n\t      f = false;\n\t      break;\n\t    }\n\t  }\n\n\t  if(!f)break;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n      prev=pres;\n      pres=pres->next;\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp-1<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=sinki->start+s-1;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    }\n  }\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  //cout<<\"read!\\n\";\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres,*tmp;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i){\n      tmp=pres;\n      prev->next=pres->next;\n      pres=prev->next;\n      //      cout<<\"debug\"<<tmp->start<<endl;\n      delete tmp;\n      continue;\n    }\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next; \n  while(pres!=NULL){\n    delete prev;\n    prev=pres;\n    pres=pres->next;\n  }\n  delete prev;\n  return;\n}\nvoid debug(newrm* begin){\n  while(begin!=NULL){\n    cout<<begin->start<<\" \"<<begin->end<<endl;\n    begin=begin->next;\n  }\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    \n    if(N==0) return 0;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      else if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      else if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      else if(com=='B')\n\tdebug(begin);\n    }\n    reset(begin);\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//:55-\n#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  files[make_pair(h,e-1)]=I;\n\t  S-=h-e;\n\t}else{\n\t  files[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tIf(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef long long ll; \ntypedef map<ll,int>::iterator M;\nmap <ll,int> r;\n\nvoid W(int a,int b){\n  M it=r.begin();\n  ll pre=0;\n  while(it!=r.end()){\n    if(it->s==-1){\n      if((it->f)-pre>=b){\n\tr[pre+b]=a;\n\treturn;\n      }\n      it->s=a;\n      b-=((it->f)-pre);\n    }\n    pre=it->f;\n    it++;\n  }\n}\n\nvoid D(int a){\n  M it=r.begin();\n  while(it!=r.end()){\n    if(it->s==a)it->s=-1;\n    it++;\n  }\n}\n\nint R(ll a){\n  M it=r.begin();\n  while(it!=r.end()){\n    if((it->f)>=a){\n      return it->s;\n    }\n    it++;\n  }\n  return -1;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    r.clear();\n    r[1000000000000000LL]=-1;\n\n    while(n--){\n      char c;\n      int a,b;\n      cin>>c;\n      if(c=='W'){\n\tcin>>a>>b;\n\tW(a,b);\n\n      }\n      else if(c=='D'){\n\tcin>>a;\n\tD(a);\n      }\n      else if(c=='R'){\n\tcin>>a;\n\tcout<<R(a+1)<<endl;\n      }\n    }\n    /*\n    M it=r.begin();\n    while(it!=r.end()){\n    cout <<it->f<<\" \"<<it->s<<endl;\n      it++;\n      }*/\n    cout <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1000000001;\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    int a,b,cnt;\n    char c;\n    vector<P> v;\n    v.push_back(P(-1,INF));\n    for(int i=0;i<n;i++){\n      cin >> c;\n      if(c == 'W'){\n\tcin >> a >> b;\n\tfor(int j=0;j<v.size();j++){\n\t  if(v[j].first == -1 && v[j].second > b){\n\t    v.insert(v.begin()+j, P(a,b));\n\t    break;\n\t  }\n\t}\n      } else if(c == 'D'){\n\tcin >> a;\n\tfor(int j=0;j<v.size();j++) if(v[j].first == a) v[j].first = b;\n      } else if(c == 'R'){\n\tcin >> a;\n\tcnt = 0;\n\tfor(int j=0;j<v.size();j++){\n\t  cnt += v[j].second;\n\t  if(cnt > a){\n\t    cout << v[j].first << endl;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define vecsize 1000000000\nint vec[vecsize];\nvoid W(int x,int y){\n    for(int i=0;i<vecsize;++i){\n        if(y>0)if(vec[i]==-1)vec[i]=x,--y;\n    }\n}\nvoid D(int x){\n    int size=vecsize-1;\n    if(x<=size)for(int i=vecsize-1;i>=0;--i){\n        if(vec[i]==x){\n            vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vecsize;\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n        }\n        b=false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n; cin >> n&&n;) {\n\t\tset<T> st;\n\t\tst.emplace(-INF, 0, -1);\n\t\twhile (n--) {\n\t\t\tchar com; cin >> com;\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s; cin >> l >> s;\n\t\t\t\tfor (auto c = st.begin(); c != st.end(); c++) {\n\t\t\t\t\tint ca, cb, cc, na, nb, nc;\n\t\t\t\t\ttie(ca, cb, cc) = *c;\n\t\t\t\t\tif (next(c) == st.end()) {\n\t\t\t\t\t\tst.emplace(cb, cb + s, l);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttie(na, nb, nc) = *next(c);\n\t\t\t\t\tif (cb == na)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint d = min(s, na - ca);\n\t\t\t\t\tc = st.emplace(cb, cb + d, l).first;\n\t\t\t\t\ts -= d;\n\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tfor (auto it = st.begin(); it != st.end();) {\n\t\t\t\t\tif (get<2>(*it) == l)\n\t\t\t\t\t\tit = st.erase(it);\n\t\t\t\t\telse\n\t\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'R') {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tauto upper = st.upper_bound(T(p, 0, 0));\n\t\t\t\tif (upper != st.begin()) {\n\t\t\t\t\tupper--;\n\t\t\t\t\tint a, b, c;\n\t\t\t\t\ttie(a, b, c) = *upper;\n\t\t\t\t\tif (b <= p)\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << c << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iterator>\nstd::vector<int> vec;\nvoid W(int x,int y){\n    for(int i=0;i<vec.size();++i){\n        if(y>=0)\n        if(vec[i]==-1)vec[i]=x,--y;\n    }\n    while(y>0){\n        if(vec.size()>1000000000)break;\n        vec.push_back(x);\n        --y;\n    }\n}\nvoid D(int x){\n    for(int i=vec.size()-1;i>=0;--i){\n        if(vec[i]==x){\n            if(vec.size()-1==i){\n                std::vector<int>::iterator it=vec.end();\n                vec.erase(it);\n            }else vec[i]==-1;\n        }\n    }\n}\nint R(int x){\n    if(x>vec.size()-1)return -1;\n    else return vec[x];\n}\nint main(){\n  int n;\n  bool b=true;\n  while(std::cin>>n,n!=0){\n    if(!b)std::cout<<std::endl;\n    while(n>0){\n      char cm;\n      int x,y;\n      std::cin>>cm>>x;\n      if(cm==0)return 0;\n      if(x<=1000000000)switch(cm){\n      case 'W':\n        std::cin>>y;\n        W(x,y);\n        break;\n      case 'D':\n        D(x);\n        break;\n      case 'R':\n        std::cout<<R(x)<<std::endl;\n        break;\n      }\n      --n;\n    }\n    b=false;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \ntemplate<typename T=int>inline T readT() {\n  char c = getchar_unlocked(); bool neg = (c=='-');\n  T res = neg?0:c-'0';\n  while(isdigit(c=getchar_unlocked())) res = res*10 + c-'0';\n  return neg?-res:res;\n}\ntemplate<typename T=int>inline void writeT(T x, char c='\\n'){\n  int d[20],i=0; if(x<0)putchar_unlocked('-'),x*=-1;\n  do{d[i++]=x%10;}while(x/=10); while(i--)putchar_unlocked('0'+d[i]);\n  putchar_unlocked(c);\n}\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\n\n\nusing ld= long double;\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(18);\n    \n    int n; \n    while(cin >> n){\n        if(n == 0) break;\n        priority_queue<pair<pair<ll, ll>, int>, vector<pair<pair<ll, ll>, int>>, greater<pair<pair<ll, ll>, int>>> q;\n        for(int i=0; i<n; i++){\n            char c; cin >> c;\n            if(c == 'W'){\n                ll L, S; cin >> L >> S;\n                ll prev = -1;\n                bool f = true;\n                priority_queue<pair<pair<ll, ll>, int>, vector<pair<pair<ll, ll>, int>>, greater<pair<pair<ll, ll>, int>>> pq;\n\n                while(q.size()){\n                    auto p = q.top();\n                    pq.push(p);\n                    q.pop();\n                    ll num = p.second;\n                    ll l = p.first.first, r = p.first.second;\n\n                    if(S == 0) continue;\n                    if(f){\n                        if(l != 0){\n                            ll nl = 0, nr = l-1;\n                            if(S-(nr-nl+1)>=0){\n                                S -= (nr-nl+1);\n                                pq.push(make_pair(make_pair(nl, nr), L));\n                            }else{\n                                \n                                pq.push(make_pair(make_pair(nl, nl+S-1), L));\n                                S = 0;\n                            }\n                        }\n                        prev = r+1;\n                        f = false;\n                    }else{\n                        if(prev >= l){\n\n                        }else{\n                            ll nl = prev, nr = l-1;\n                            if(S-(nr-nl+1)>=0){\n                                S -= (nr-nl+1);\n                                pq.push(make_pair(make_pair(nl, nr), L));\n                            }else{\n                                \n                                pq.push(make_pair(make_pair(nl, nl+S-1), L));\n                                S = 0;\n                            }\n                        }\n                        prev = r+1;\n                    }\n                }\n                if(S != 0){\n                    if(prev == -1){\n                        pq.push(make_pair(make_pair(0, S-1), L));\n                    }else{\n                        pq.push(make_pair(make_pair(prev, prev+S-1), L));\n                    }\n                }\n                q = pq;\n                \n            }else if(c == 'D'){\n                int L; cin >> L;\n                priority_queue<pair<pair<ll, ll>, int>, vector<pair<pair<ll, ll>, int>>, greater<pair<pair<ll, ll>, int>>> pq;\n\n                while(q.size()){\n                    auto p = q.top();\n                    q.pop();\n                    if(p.second != L){\n                        pq.push(p);\n                    }\n                }\n                q = pq;\n            }else if(c == 'R'){\n                ll P; cin >> P;\n                ll res = -1;\n                priority_queue<pair<pair<ll, ll>, int>, vector<pair<pair<ll, ll>, int>>, greater<pair<pair<ll, ll>, int>>> pq;\n                while(q.size()){\n\n                    auto p = q.top();\n                    pq.push(p);\n                    q.pop();\n\n                    if(p.first.first <= P && P <= p.first.second) res = p.second;\n                }\n                cout << res << endl;\n                q = pq;\n            }\n            // {\n            //      priority_queue<pair<pair<ll, ll>, int>, vector<pair<pair<ll, ll>, int>>, greater<pair<pair<ll, ll>, int>>> pq;\n            //      while(q.size()){\n            //          auto p = q.top();\n            //          q.pop();\n            //          pq.push(p);\n            //          cout << p.first.first << \" \" << p.first.second << \" \" << p.second << endl;\n            //      }\n            //      q = pq;\n            // }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef vector<P>::iterator ITE;\nstruct data{\n  ll num;\n  vector<P> MEM;\n  data(){}\n  data(int n,vector<P> m):num(n),MEM(m){}\n  bool operator < (const data& d) const {return num < d.num;}\n};\n\nconst ll MAX = 10000000000000LL;\nvector<P> Free;\nvector<data> V;\n\nvoid init(){\n\n  Free.clear();\n  Free.push_back(P(0,MAX));\n  V.clear();\n\n}\n\nvoid write(ll a, ll b){\n  sort(Free.begin(),Free.end());\n  vector<P> tmp;\n\n  for(int i = 0; i < (int)Free.size(); i++){\n    if(Free[i].second-Free[i].first+1 > b){\n      tmp.push_back(P(Free[i].first, Free[i].first+b-1));\n      //     cout << \"push \" << Free[i].first << \" \" << Free[i].first+b-1 << \" \" << a << endl;\n      Free[i].first += b;\n      break;\n    }else{\n      tmp.push_back(Free[i]);\n      b -= Free[i].second-Free[i].first+1;\n      //  cout << \"push \" << Free[i].first << \" \" << Free[i].second << \" \" << a << endl;\n      vector<P>::iterator ite = (ITE)&Free[i];\n      Free.erase(ite);\n      i--;\n    }\n  }\n  V.push_back(data(a,tmp));\n}\n\nvoid del(ll num){\n\n  sort(V.begin(),V.end());\n  vector<data>::iterator ite = lower_bound(V.begin(),V.end(),data(num,vector<P>()));\n  if(ite->num != num) assert(false);\n\n  for(int i = 0; i < (int)ite->MEM.size(); i++)\n    Free.push_back(ite->MEM[i]);\n\n  V.erase(ite);\n\n}\n\nvoid ref(ll num){\n  for(int i = 0; i < (int)V.size(); i++){\n    vector<P> tmp = V[i].MEM;\n    for(int j = 0; j < (int)tmp.size(); j++){\n      if(tmp[j].first <= num && num <= tmp[j].second){\n\tcout << V[i].num << endl;\n\treturn;\n      }\n    }\n  }\n  \n  cout << \"-1\" << endl;\n}\n\nint main(){\n  int n;\n  bool f = false;\n\n  while(cin >> n && n){\n    if(f) cout << endl;\n    f = true;\n    init();\n    while(n--){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n\tll a,b;\n\tcin >> a >> b;\n\twrite(a,b);\n      }\n\n      if(c == 'D'){\n\tll a;\n\tcin >> a;\n\tdel(a);\n      }\n\n      if(c == 'R'){\n\tll a;\n\tcin >> a;\n\tref(a);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 100100\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    { \n\t\t      // assert(false);\n\t    \n\t\t    }\n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nstruct DATA{\n\tint start;\n\tint end;\n\tint fileID;\n\tDATA(int start, int end, int fileID){\n\t\tthis->start = start, this->end = end, this->fileID = fileID;\n\t}\n};\n\nvector<DATA> data;\n\nvoid Write(int fileID, int file_length)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(file_length <= data[i].end - data[i].start + 1){\n\t\t\t\tdata.insert(data.begin() + i, DATA(data[i].start, data[i].start + file_length - 1, fileID));\n\t\t\t\tdata[i+1].start = data[i+1].start + file_length;\n\t\t\t}else{\n\t\t\t\tdata[i].fileID = fileID;\n\t\t\t\tfile_length -= data[i].end - data[i].start + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Arrange()\n{\n\tfor(int i = 0; i < (int)data.size()-1; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(data[i+1].fileID == -1){\n\t\t\t\tdata[i].end = data[i+1].end;\n\t\t\t\tdata.erase(data.begin() + (i+1));\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Delete(int fileID)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == fileID) data[i].fileID = -1;\n\t}\n\tArrange();\n}\n\nvoid Reference(int pos)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].end >= pos){\n\t\t\tprintf(\"%d\\n\", data[i].fileID);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint N;\n\tchar com[5];\n\tint op1, op2;\n\t\n\tscanf(\"%d\", &N);\n\tdata.push_back( DATA(0, 1000000001, -1) );\n\t\n\tfor(int i = 0; i < N; i++){\n\t\t\n\t\tscanf(\"%s\", com);\n\t\tif(strcmp(com, \"W\") == 0){\n\t\t\tscanf(\"%d %d\", &op1, &op2);\n\t\t\tWrite(op1, op2);\n\t\t}else if(strcmp(com, \"D\") == 0){\n\t\t\tscanf(\"%d\", &op1);\n\t\t\tDelete(op1);\n\t\t}else if(strcmp(com, \"R\") == 0){\n\t\t\tscanf(\"%d\", &op1);\n\t\t\tReference(op1);\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iterator>\nstd::vector<int> vec;\nvoid W(int x,int y){\n    for(int i=0;i<vec.size();++i){\n        if(y>=0)\n            if(vec[i]==-1)vec[i]=x,--y;\n    }\n    while(y>0){\n        if(vec.size()>1000000000)break;\n        vec.push_back(x);\n        --y;\n    }\n}\nvoid D(int x){\n    int size=vec.size()-1;\n    if(x<=size)for(int i=vec.size()-1;i>=0;--i){\n        if(vec[i]==x){\n            if(vec.size()-1==i){\n                std::vector<int>::iterator it=vec.end();\n                vec.erase(it);\n            }else vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vec.size();\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n            for(int i=0;i<vec.size();++i){\n                std::cout<<vec[i]<<\":\";\n            }\n            std::cout<<std::endl;\n        }\n        b=false;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\nstruct DATA{\n\tint start;\n\tint end;\n\tint fileID;\n\tDATA(int start, int end, int fileID){\n\t\tthis->start = start, this->end = end, this->fileID = fileID;\n\t}\n};\n\nvector<DATA> data;\n\nvoid Write(int fileID, int file_length)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(file_length <= data[i].end - data[i].start + 1){\n\t\t\t\tdata.insert(data.begin() + i, DATA(data[i].start, data[i].start + file_length - 1, fileID));\n\t\t\t\tdata[i+1].start = data[i+1].start + file_length;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tdata[i].fileID = fileID;\n\t\t\t\tfile_length -= data[i].end - data[i].start + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Arrange()\n{\n\tfor(int i = 0; i < (int)data.size()-1; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(data[i+1].fileID == -1){\n\t\t\t\tdata[i].end = data[i+1].end;\n\t\t\t\tdata.erase(data.begin() + (i+1));\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Delete(int fileID)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == fileID) data[i].fileID = -1;\n\t}\n\tArrange();\n}\n\nvoid Reference(int pos)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].end >= pos){\n\t\t\tprintf(\"%d\\n\", data[i].fileID);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint N;\n\tchar com[5];\n\tint op1, op2;\n\t\n\twhile(1){\n\t\tscanf(\"%d\", &N);\n\t\tif(N == 0) break;\n\t\tdata.clear();\n\t\tdata.push_back( DATA(0, 1000000001, -1) );\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\t\n\t\t\tscanf(\"%s\", com);\n\t\t\tif(strcmp(com, \"W\") == 0){\n\t\t\t\tscanf(\"%d %d\", &op1, &op2);\n\t\t\t\tWrite(op1, op2);\n\t\t\t}else if(strcmp(com, \"D\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tDelete(op1);\n\t\t\t}else if(strcmp(com, \"R\") == 0){\n\t\t\t\tscanf(\"%d\", &op1);\n\t\t\t\tReference(op1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n// #define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e9 + 7;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                            break;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                    if(len == 0) break;\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PPI;\ntypedef pair<ll, P> IPP;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nset<PPI> mem;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tmem.clear();\n\t\tmem.insert(PPI(P(0,1e9),-1));\n\t\trep(i,n){\n\t\t\tchar op;\n\t\t\tcin>>op;\n\t\t\tif(op=='W'){\n\t\t\t\tll file,sizes;\n\t\t\t\tcin>>file>>sizes;\n\t\t\t\tbool end=false;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.se==-1){\n\t\t\t\t\t\tint idx=it.fi.fi,maxsize=it.fi.se;\n\t\t\t\t\t\tif(maxsize>sizes){\n\t\t\t\t\t\t\tmem.insert(PPI(P(idx,sizes),file));\n\t\t\t\t\t\t\tmem.insert(PPI(P(idx+sizes,maxsize-sizes),-1));\n\t\t\t\t\t\t\tend=true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tmem.insert(PPI(P(idx,maxsize),file));\n\t\t\t\t\t\t\tsizes-=maxsize;\n\t\t\t\t\t\t\tif(sizes==0)end=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmem.erase(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(end)break;\n\t\t\t\t}\n\t\t\t}else if(op=='D'){\n\t\t\t\tll file;\n\t\t\t\tcin>>file;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.se==file){\n\t\t\t\t\t\tmem.insert(PPI(P(it.fi.fi,it.fi.se),-1));\n\t\t\t\t\t\tmem.erase(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(op=='R'){\n\t\t\t\tll sec;\n\t\t\t\tcin>>sec;\n\t\t\t\tsec--;\n\t\t\t\teach(it,mem){\n\t\t\t\t\t//dbg(it.fi.fi); dbg(it.fi.fi+it.fi.se);\n\t\t\t\t\tif(it.fi.fi<=sec&&sec<it.fi.fi+it.fi.se){\n\t\t\t\t\t\tcout<<it.se<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            for(const auto& k : disk)\n              if(k.second == t){\n                  disk.erase(k.first);\n                  break;\n              }\n        }else{\n            auto lb = disk.lower_bound(pint(t, 0));\n            pint temp;\n            if(lb == disk.begin()) goto fail;\n            lb--;\n            temp = lb->first;\n            if(temp.first <= t && t <= temp.second){\n                cout << lb->second << endl;\n                continue;\n            }\n          fail:\n            cout << \"-1\" << endl;\n        }\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<utility>\nusing namespace std;\n\nint main(){\n  int num,n,s,r;\n  char c;\n  vector<pair<int,int> >cut;\n  while(true){\n  cin >> num;\n  if (num == 0)\n    break;\n  cut.push_back(make_pair((int) 1e9,-1));\n  for(int i=0;i<num;i++){\n    cin >> c;\n    switch(c){\n    case 'W':\n       cin >> n >> s;\n       for(int j=0;s>0;j++){\n         if (cut[j].second == -1){\n\t   if (cut[j].first >= s){\n\t     cut[j].first-=s;\n\t     cut.insert(cut.begin()+j,make_pair(s,n));\n\t     s=0;\n\t   }\n\t   else if(j==cut.size())s=0;\n\t   else{\n\t     s -= cut[j].first;\n\t     cut[j].second=n;\n\t   }\n\t }\n\t //\t cout << cut[j].first << \",\" << cut[j].second << endl;\n\t //cout << s << endl;\n       }\n       break;\n\n    case 'D':\n      int p;\n      cin>>p;\n      for(int a=0;a<cut.size();a++)if(cut[a].second==p)cut[a].second=-1;      \n      break;\n\n    case 'R':\n      \n      cin >> r;\n      int sum=0;\n      for(int a=0;a<cut.size();a++){\n\tsum+=cut[a].first;\n\tif(sum>r){\n\t  cout<<cut[a].second<<endl;\n\t  break;\n\t}\n      }\n      break;\n    }\n  }\n  cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef pair<int,int>P;\n#define pb push_back\n\nmap <int, vector<P> >MP;\nset<P> MAS;\n\n\nvoid Write(int a,int b){\n\twhile(b>0){\n\t\tset<P>::iterator it=MAS.begin();\n\t\tif((*it).second - (*it).first + 1 <= b){\n\t\t\tMP[a].pb((*it));\n\t\t\tb-=((*it).second - (*it).first + 1);\n\t\t\tMAS.erase(it);\n\t\t}\n\t\telse{\n\t\t\tP t=(*it);\n\t\t\tMP[a].pb(P(t.first,t.first+b-1));\n\t\t\tMAS.erase(it);\n\t\t\tMAS.insert(P(t.first+b,t.second));\n\t\t\tb=0;\n\t\t}\n\t}\n}\n\nvoid Delete(int a){\n\tfor(int i=0;i<MP[a].size();i++){\n\t\tMAS.insert(MP[a][i]);\n\t}\n\tMP[a].clear();\n}\n\nvoid Read(int a){\n\tmap<int, vector<P> >::iterator it =MP.begin();\n\tfor(;it != MP.end();it++){\n\t\tfor(int i=0;i<(*it).second.size();i++){\n\t\t\tif((*it).second[i].first <= a && a <= (*it).second[i].second ){\n\t\t\t\tcout<<(*it).first<<endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tMP.clear();\n\t\tMAS.clear();\n\t\tMAS.insert(P(0,1000000000));\n\t\t\n\t\tchar c;\n\t\tfor(;n;n--){\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tWrite(a,b);\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tDelete(a);\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\tRead(a);\n\t\t\t}\n\t\t\tif(c=='Q')n=1;\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<list>\nusing namespace std;\nint n;\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tlist<pair<int,int> >L;\n\t\tL.push_back(make_pair(-1,2e9));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tchar c;cin>>c;\n\t\t\tif(c=='W')\n\t\t\t{\n\t\t\t\tint s,l;cin>>s>>l;\n\t\t\t\tfor(auto it=L.begin();l>0&&it!=L.end();it++)\n\t\t\t\t{\n\t\t\t\t\tif(it->first==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(it->second>l)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tit->second-=l;\n\t\t\t\t\t\t\tL.insert(it,make_pair(s,l));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tl-=it->second;\n\t\t\t\t\t\t\tit->first=s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c=='R')\n\t\t\t{\n\t\t\t\tint l;cin>>l;\n\t\t\t\tfor(auto it=L.begin();l>=0&&it!=L.end();it++)\n\t\t\t\t{\n\t\t\t\t\tl-=it->second;\n\t\t\t\t\tif(l<0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<it->first<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint l;cin>>l;\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++)\n\t\t\t\t{\n\t\t\t\t\tif(it->first==l)it->first=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tfor(int i=0;i<=10000;i++)place[i].clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tif(d.rid!=-1)dat[d.rid].lid=d.lid;\n\t\t\t\t\tif(d.lid!=-1)dat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppiii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define SZ(container) ((int)container.size())\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\n\nmain(){\n\tint i,j;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvector<ppiii> seg;\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > del;\n\t\tint back = 0;\n\t\tint sorted = 1;\n\t\tREP(i, n){\n\t\t\tchar c;\n\t\t\tint id, len;\n\t\t\tscanf(\" %c%d\", &c, &id);\n//\t\t\tcerr << c << \", \" << id << endl;\n\t\t\tif(c == 'W'){\n\t\t\t\tscanf(\"%d\", &len);\n\t\t\t\twhile(len && !del.empty()){\n\t\t\t\t\tpii s = del.top();\n\t\t\t\t\tdel.pop();\n\t\t\t\t\tint l = min(len, s.second);\n\t\t\t\t\tlen -= l;\n\t\t\t\t\ts.second -= l;\n\t\t\t\t\tseg.push_back(ppiii(pii(s.first, l), id));\n\t\t\t\t\tsorted = 0;\n\t\t\t\t\tif(s.second) del.push(s);\n\t\t\t\t}\n\t\t\t\tif(len){\n\t\t\t\t\tseg.push_back(ppiii(pii(back, len), id));\n\t\t\t\t\tback += len;\n\t\t\t\t}\n\t\t\t}else if(c == 'R'){\n\t\t\t\tif(seg.size() == 0) puts(\"-1\");\n\t\t\t\telse{\n\t\t\t\t\tif(!sorted) sort(seg.begin(), seg.end());\n\t\t\t\t\tauto it = lower_bound(seg.begin(), seg.end(), ppiii(pii(id+1, 0), 0));\n\t\t\t\t\t--it;\n\t\t\t\t\tif(it->first.first <= id && it->first.first + it->first.second >= id) printf(\"%d\\n\", it->second);\n\t\t\t\t\telse puts(\"-1\");\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint t = 0;\n\t\t\t\tint s = 0;\n\t\t\t\tfor(;s<seg.size();s++){\n\t\t\t\t\tif(seg[s].second == id){\n\t\t\t\t\t\tdel.push(seg[s].first);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tseg[t] = seg[s];\n\t\t\t\t\t\tt ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tseg.resize(t);\n\t\t\t}\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S != 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  int cnt = 0, len = (int)vec.size(), l, num = vec[0].first;\n\n  scanf(\"%d\" ,&l);\n  for(int i = 0 ; i < len ; i++){\n    if(cnt >= l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }\n  }\n\n  if(cnt < l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\n\nstruct Point {\n\tint first;\n\tint len;\n\tint sikibetu_id;\n};\nvector<Point> sys;\n\nint read_sys(int real_i) {\n\trep(i,sys.size()) {\n\t\tint first = sys[i].first;\n\t\tint last = first + sys[i].len;\n\t\t/*\n\t\tdump(first);\n\t\tdump(last);\n\t\tdump(real_i);\n\t\t*/\n\t\tif (first <= real_i && real_i < last) {\n\t\t\treturn sys[i].sikibetu_id;\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid delete_sys(int siki) {\n\trep(i,sys.size()) {\n\t\tif (sys[i].sikibetu_id == siki) {\n\t\t\tsys.erase(sys.begin() + i); //i???????´??????????\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid write_sys(int siki, int len) {\n\tint tune_index = 0;\n\trep(i,sys.size()) {\n\t\tif (tune_index != sys[i].first) {\n\t\t\t//tune_index <= hoge <= sys[i].first??????????????£???\n\t\t\tint between = (sys[i].first - tune_index);\n\n\t\t\tif (between >= len) {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=len;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen=0; //0\n\t\t\t}\n\t\t\telse {\n\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=between;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen-=between;\n\t\t\t}\n\t\t}\n\t\ttune_index += sys[i].len;\n\t}\n\n\tif (len > 0) {\n\t\tPoint p;\n\t\tp.first=tune_index;\n\t\tp.len=len;\n\t\tp.sikibetu_id=siki;\n\t\tsys.push_back(p);\n\t}\n\n}\n\nvoid show() {\n\tdump(\"-------\");\n\trep(i,sys.size()) {\n\t\tdump(sys[i].first);\n\t\tdump(sys[i].len);\n\t\tdump(sys[i].sikibetu_id);\n\t}\n}\n\nint main() {\n\tint N;\n\tchar command;\n\tint arg1,arg2;\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tsys.clear();\n\t\trep(i,N) {\n\t\t\tcin >> command;\n\t\t\t//dump(command);\n\t\t\tif (command == 'R') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tcout << read_sys(arg1) << endl;\n\t\t\t}\n\t\t\telse if (command == 'D') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tdelete_sys(arg1);\n\t\t\t}\n\t\t\telse if (command == 'W') {\n\t\t\t\tcin >> arg1 >> arg2;\n\t\t\t\twrite_sys(arg1,arg2);\n\t\t\t}\n\t\t\t//show();\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_ADDR = 1000000000;\n\n/* typedef */\n\nstruct Range {\n  int i0, i1;\t// [i0, i1)\n  int id;\n  Range() {}\n  Range(int _i0, int _i1, int _id): i0(_i0), i1(_i1), id(_id) {}\n  bool operator<(const Range& r0) const { return i1 < r0.i1; }\n  void print() const { printf(\"(%d,%d)=%d\\n\", i0, i1, id); }\n};\n\ntypedef set<Range> sr;\ntypedef vector<Range> vr;\ntypedef map<int,vr> mivr;\n\n/* global variables */\n\nsr sctrs, blnks;\nmivr dir;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (n == 0) break;\n\n    sctrs.clear();\n    blnks.clear();\n    dir.clear();\n\n    sctrs.insert(Range(0, MAX_ADDR + 1, -1));\n    blnks.insert(Range(0, MAX_ADDR + 1, -1));\n    \n    while (n--) {\n      char op;\n      int l, s, p;\n\n      cin >> op;\n      if (op == 'W') {\n\tcin >> l >> s;\n\t//printf(\"W: %d %d\\n\", l, s);\n\t\n\twhile (s) {\n\t  sr::iterator bit = blnks.begin();\n\t  Range r = *bit;\n\t  sr::iterator sit = sctrs.find(r);\n\t  int rsz = r.i1 - r.i0;\n\n\t  if (s >= rsz) {\n\t    r.id = l;\n\t    blnks.erase(bit);\n\t    sctrs.erase(sit);\n\t    dir[l].push_back(r);\n\t    sctrs.insert(r);\n\t    s -= rsz;\n\t  }\n\t  else {\n\t    Range r1(r.i0, r.i0 + s, l);\n\t    r.i0 += s;\n\t    blnks.erase(bit);\n\t    sctrs.erase(sit);\n\t    dir[l].push_back(r1);\n\t    blnks.insert(r);\n\t    sctrs.insert(r1);\n\t    sctrs.insert(r);\n\t    s = 0;\n\t  }\n\t}\n      }\n      else if (op == 'D') {\n\tcin >> l;\n\t//printf(\"D: %d\\n\", l);\n\n\tvr& dirl = dir[l];\n\tfor (vr::iterator vit = dirl.begin(); vit != dirl.end(); vit++) {\n\t  sr::iterator sit = sctrs.find(*vit);\n\t  Range r = *sit;\n\t  sctrs.erase(sit);\n\n\t  r.id = -1;\n\t  blnks.insert(r);\n\t  sctrs.insert(r);\n\t}\n\tdirl.clear();\n      }\n      else {\n\tcin >> p;\n\t//printf(\"R: %d\\n\", p);\n\n\tsr::iterator sit = sctrs.upper_bound(Range(p, p, -1));\n\tcout << sit->id << endl;\n      }\n\n      if (false) {\n\tcout << \"blnks: \";\n\tfor (sr::iterator bit = blnks.begin(); bit != blnks.end(); bit++)\n\t  bit->print();\n\tcout << \"sctrs: \";\n\tfor (sr::iterator sit = sctrs.begin(); sit != sctrs.end(); sit++)\n\t  sit->print();\n      }\n    }\n\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct List{\n\tint id, cnt;\n\tList *nxt;\n};\n\nvoid _delete(List *p){\n\tif (p == nullptr) return;\n\t_delete(p->nxt);\n\tdelete p;\n}\n\nvoid erase(List *p, int id){\n\tif (p == nullptr) return;\n\tif (p->id == id) p->id = -1;\n\terase(p->nxt, id);\n}\n\nint find(List *p, int pos){\n\tif (p == nullptr) return -1;\n\tif (p->cnt > pos) return p->id;\n\treturn find(p->nxt, pos - p->cnt);\n}\n\nList* add(List *p, int id, int cnt){\n\tif (!cnt || p == nullptr)return new List{id, cnt, nullptr};\n\tif (p->id < 0){\n\t\tp->id = id;\n\t\tif (p->cnt > cnt){\n\t\t\tList *nl = new List{ -1, p->cnt - cnt, p->nxt };\n\t\t\tp->cnt -= cnt;\n\t\t\tp->nxt = nl;\n\t\t\treturn p;\n\t\t}\n\t\tcnt -= p->cnt;\n\t}\n\tp->nxt = add(p->nxt, id, cnt);\n\treturn p;\n}\n\nint main(){\n\tList *head = new List();\n\tint n;\n\twhile (cin >> n, n){\n\t\twhile (n--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint id, cnt;\n\t\t\t\tcin >> id >> cnt;\n\t\t\t\thead->nxt = add(head->nxt, id, cnt);\n\t\t\t}\n\t\t\telse if (c == 'D'){\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\terase(head->nxt, id);\n\t\t\t}\n\t\t\telse if (c == 'R'){\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << find(head->nxt, pos) << '\\n';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t\t_delete(head->nxt);\n\t\thead->nxt = nullptr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    set<tuple<int,int,int> >f;\n    //r,l,id\n    map<int,vector<tuple<int,int,int> > > pos;\n    REP(i,n){\n      string c;\n      cin >> c;\n      if(c==\"W\"){\n\tint id,se;\n\tcin >> id >> se;\n\tint tmp=0;\n\tfor(;;){\n\t  auto ite=(f.lower_bound(make_tuple(tmp,1123456789,0)));\n\t  if(ite==f.end()){\n\t    auto ma=make_tuple(tmp+se,tmp,id);\n\t    f.insert(ma);\n\t    pos[id].push_back(ma);\n\t    break;\n\t  }\n\t  int sup,suc;\n\t  tie(suc,sup,ignore)=*ite;\n\t  if(tmp<sup){\n\t    if(tmp+se<=sup){\n\t      auto ma=make_tuple(tmp+se,tmp,id);\n\t      f.insert(ma);\n\t      pos[id].push_back(ma);\n\t      break;\n\t    }else{\n\t      auto ma=make_tuple(sup,tmp,id);\n\t      f.insert(ma);\n\t      pos[id].push_back(ma);\n\t      se-=sup-tmp;\n\t    }\n\t  }\n\t  tmp=suc;\n\t}\n      }else if(c==\"D\"){\n\tint id;\n\tcin >> id;\n\tfor(auto x:pos[id]) f.erase(x);\n\tpos[id].clear();\n      }else if(c==\"R\"){\n\tint p;\n\tcin >> p;\n\tauto x=f.lower_bound(make_tuple(p,0,0));\n\tif(x==f.end()){\n\t  cout << -1 << endl;\n\t}else{\n\t  int l,id;\n\t  tie(ignore,l,id)=*x;\n\t  if(l<=p) cout << id << endl;\n\t  else cout << -1 << endl;\n\t}\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[1000001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int>m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tpair<int,int> f={n,2000000000};\n\t\t\tauto it=m.lower_bound(f);\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[make_pair(cur,cur+z-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\n\n#define rep(i,n) for(i=0;i<n;i++)\n\n\n/*\nlist<from,n,len>\n\n*/\n\nstruct DATA {\n\tint f;\n\tint n;\n\tint l;\n};\nlist<DATA> L;\n\n\nint main(){\n\t\n\tint N;\n\tchar q[2];\n\tint n,i,j;\n\tint I,S,P;\n\tint b;\n\tbool f;\n\tint nf,nl;\n\t\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)return 0;\n\t\t\n\t\tL.clear();\n\t\t\n\t\t\n\t\trep(n,N){\n\t\t\tscanf(\"%s\",q);\n\t\t\tif(q[0]=='W'){\n\t\t\t\tscanf(\"%d %d\",&I,&S);\n\t\t\t\tP=0;\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\t\tif((*it).n==-1){\n\t\t\t\t\t\tif((*it).l>S){\n\t\t\t\t\t\t\t(*it).n=I;\n\t\t\t\t\t\t\tnf=(*it).f+S;\n\t\t\t\t\t\t\tnl=(*it).l-S;\n\t\t\t\t\t\t\t(*it).l=S;S=0;\n\t\t\t\t\t\t\tit++;\n\t\t\t\t\t\t\tL.insert(it,DATA({nf,-1,nl}));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if((*it).l==S){\n\t\t\t\t\t\t\t(*it).n=I;S=0;break;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t(*it).n=I;\n\t\t\t\t\t\t\tS-=(*it).l;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tP=(*it).f+(*it).l;\n\t\t\t\t\tif(S<=0)break;\n\t\t\t\t}\n\t\t\t\tif(S>0){\n\t\t\t\t\tL.insert(L.end(),DATA({P,I,S}));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(q[0]=='D'){\n\t\t\t\tscanf(\"%d\",&I);\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\t\tif((*it).n==I){\n\t\t\t\t\t\t(*it).n=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t}else if(q[0]=='R'){\n\t\t\t\tscanf(\"%d\",&P);\n\t\t\t\tf=true;\n\t\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\t\tif(((*it).f<=P)&&(P<((*it).f+(*it).l))){\n\n\t\t\t\t\t\tprintf(\"%d\\n\",(*it).n);\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(f){\n\t\t\t\t\tputs(\"-1\");\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t}else{\n\t\t\t\tputs(\"Ereer!!!!\");return -1;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(auto it=L.begin();it!=L.end();it++){\n\t\t\t\tprintf(\"#    %2d %2d %2d\\n\",(*it).f,(*it).n,(*it).l);\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t}\n\t\tputs(\"\");\n\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cassert>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<P>::iterator ITE;\nstruct data{\n  int num;\n  vector<P> MEM;\n  data(){}\n  data(int n,vector<P> m):num(n),MEM(m){}\n  bool operator < (const data& d) const {return num < d.num;}\n};\n\nconst int MAX = 1000005000;\nvector<P> Free;\nvector<data> V;\n\nvoid init(){\n\n  Free.clear();\n  Free.push_back(P(0,MAX));\n\n}\n\nvoid write(int a, int b){\n  sort(Free.begin(),Free.end());\n  vector<P> tmp;\n\n  for(int i = 0; i < (int)Free.size(); i++){\n    if(Free[i].second-Free[i].first+1 > b){\n      tmp.push_back(P(Free[i].first, Free[i].first+b-1));\n      //     cout << \"push \" << Free[i].first << \" \" << Free[i].first+b-1 << \" \" << a << endl;\n      Free[i].first += b;\n      break;\n    }else{\n      tmp.push_back(Free[i]);\n      b -= Free[i].second-Free[i].first+1;\n      //  cout << \"push \" << Free[i].first << \" \" << Free[i].second << \" \" << a << endl;\n      vector<P>::iterator ite = (ITE)&Free[i];\n      Free.erase(ite);\n      i--;\n    }\n  }\n  V.push_back(data(a,tmp));\n}\n\nvoid del(int num){\n\n  sort(V.begin(),V.end());\n  vector<data>::iterator ite = lower_bound(V.begin(),V.end(),data(num,vector<P>()));\n  if(ite->num != num) assert(false);\n\n  for(int i = 0; i < (int)ite->MEM.size(); i++)\n    Free.push_back(ite->MEM[i]);\n\n  V.erase(ite);\n\n}\n\nvoid ref(int num){\n  for(int i = 0; i < (int)V.size(); i++){\n    vector<P> tmp = V[i].MEM;\n    for(int j = 0; j < (int)tmp.size(); j++){\n      if(tmp[j].first <= num && num <= tmp[j].second){\n\tcout << V[i].num << endl;\n\treturn;\n      }\n    }\n  }\n  \n  cout << \"-1\" << endl;\n}\n\nint main(){\n  int n;\n  bool f = false;\n\n  while(cin >> n && n){\n    if(f) cout << endl;\n    f = true;\n    init();\n    while(n--){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n\tint a,b;\n\tcin >> a >> b;\n\twrite(a,b);\n      }\n\n      if(c == 'D'){\n\tint a;\n\tcin >> a;\n\tdel(a);\n      }\n\n      if(c == 'R'){\n\tint a;\n\tcin >> a;\n\tref(a);\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        int output = -1;\n        for(lli i = 0, sum = 0; i < v.size(); sum += v[i++].size) {\n          if(P < sum+v[i].size) {\n            output = v[i].id;\n            break;\n          }\n        }\n        if(output < 0) output = -1;\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct file{\n  int s, e, num;\n};\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    list<file> sector;\n    char ope;\n    file tmp;\n    int len, num;\n    for (int i = 0; i < n; i++) {\n      cin >> ope;\n      list<file>::iterator ite = sector.begin();\n      // std::cout << \"setor:\" << std::endl;\n      // for (file f:sector){\n      //   std::cout << f.s << \" \" << f.e<< std::endl;\n      // }\n      if(ope == 'W'){\n        cin >> tmp.num >> len;\n        tmp.s = 0, tmp.e = len;\n        while(ite != sector.end() && len > 0){\n          if(tmp.s < ite->s) {\n            tmp.e = tmp.s + min(len, ite->s - tmp.s);\n            len -= tmp.e - tmp.s;\n            sector.insert(ite, tmp);\n          }\n          tmp.s = ite->e , tmp.e = tmp.s + len;\n          ite++;\n        }\n        if(len > 0)sector.insert(ite, tmp);\n      }else if(ope == 'D'){\n        cin >> num;\n        while(ite != sector.end()){\n          if(ite->num == num){\n            list<file>::iterator tmp = ite;\n            ite++;\n            sector.erase(tmp); \n          }\n          else ite++; \n        }\n      }else if(ope == 'R'){\n        int pos;\n        cin >> pos;\n        while(ite != sector.end() && !(ite->s <= pos && pos < ite->e) )ite++;\n        if(ite != sector.end())std::cout << ite->num << std::endl;\n        else std::cout << -1 << std::endl;\n      }\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define REP(i, n) rep(i, 0, n)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        int right = 0;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                    right = d[j].first + d[j].second.first;\n                }\n                if(len > 0){\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                id--;\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < right){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    idx--;\n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n\nusing namespace std;\n\n#define REP(i, n) for(long i=0; i<n; i++)\n\ntypedef pair<long, long> pii;\n\nconst long max_n = 10e5;\nconst long max_i = 10e9;\nlong n;\nchar com;\nmap<long, long> f2i;\nmap<long, long> i2f;\n\ndeque<pii> empty;\nvector<pii> used[max_n];\n\nvoid writef(long f, long c, long idx){\n    f2i[f] = idx;\n    i2f[idx] = f;\n\n    while(1){\n        if(c==0) break;\n\n        pii e = empty.front();\n        empty.pop_front();\n        if(e.second-e.first>c){\n            used[f2i[f]].push_back(make_pair(e.first, e.first+c));\n            empty.push_front(make_pair(e.first+c, e.second));\n            c = 0;\n        } else {\n            c -= (e.second - e.first);\n            used[f2i[f]].push_back(e);\n        }\n    }\n}\n\nvoid delf(long f){\n    REP(i, used[f2i[f]].size()){\n        deque<pii> tmp;\n        pii u = used[f2i[f]][i];\n        while(!empty.empty()){\n            pii e = empty.front();\n            empty.pop_front();\n            if(u.second<=e.first){\n                tmp.push_back(u);\n                empty.push_front(e);\n                break;\n            } else {\n                tmp.push_back(e);\n            }\n        }\n\n        while(!tmp.empty()){\n            pii t = tmp.back();\n            tmp.pop_back();\n            empty.push_front(t);\n        }\n    }\n    used[f2i[f]].clear();\n}\n\nvoid readf(long s){\n    REP(i, n){\n        REP(j, used[i].size()){\n            pii u = used[i][j];\n            if(u.first<=s && s<u.second){\n                cout << i2f[i] << endl;\n                return;\n            }\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        empty.clear();\n        REP(i, max_n) used[i].clear();\n\n        empty.push_back(make_pair(0, max_i));\n        REP(i, n){\n            cin >> com;\n\n            if(com=='W'){\n                long f, c; // file, count\n                cin >> f >> c;\n                writef(f, c, i);\n            } else if(com=='D'){\n                long f;\n                cin >> f;\n                delf(f);\n            } else if(com=='R'){\n                long s;\n                cin >> s;\n                readf(s);\n            }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 100100\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  else\n\t\t    {\n\t\t      cout << \"index = \" << index << endl;\n\t\t      print();\n\t\t      cerr << \"input = \"<< c << \" \" << l << \" \" << s << endl; \n\t\t      assert(false);\n\t\t      \n\t\t    }\n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <map>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ll long long\n\nll n;\n\nint main(){\n  priority_queue <ll, vector<ll>, greater<ll> > empty;\n  //  priority_queue< pair<ll,ll>, vector< pair<ll,ll> >, greater< pair<ll,ll > > empty;\n  empty.push(MOD - 1);\n  map < ll, vector< pair<ll,ll> > > pos;\n  //  vector < vector< pair<ll,ll> > > pos;\n  map< pair<ll,ll>, ll> mp;\n  \n  while(cin >> n && n){\n    for(ll iii = 0; iii < n; iii++){\n      char c;\n      cin >> c;\n\n\t\n      if(c == 'W'){\n\tll name, num;\n\tcin >> name >> num;\n\twhile(1){\n\t  if(empty.top() % MOD - empty.top() / MOD + 1 >= num){\n\t    mp[make_pair(empty.top() / MOD, empty.top() / MOD + num - 1)] = name;\n\t    pos[name].push_back(make_pair(empty.top() / MOD, empty.top() / MOD + num - 1));\n\t    ll newempty = empty.top();\n\t    empty.pop();\n\t    newempty += num * MOD;\n\t    empty.push(newempty);\n\t    break;\n\t  }else{\n\t    pos[name].push_back(make_pair(empty.top() / MOD, empty.top() % MOD));\n\t    mp[make_pair(empty.top() / MOD, empty.top() % MOD)] = name;\n\t    num -= empty.top() % MOD - empty.top() / MOD + 1;\n\t    empty.pop();\n\t  }\n\t}\n      }else if(c == 'D'){\n\tll name;\n\tcin >> name;\n\tfor(auto i : pos[name]){\n\t  empty.push(i.first * MOD + i.second);\n\t  mp.erase(i);\n\t}\n      }else{\n\tll name;\n\tcin >> name;\n\tmap< pair<ll,ll>, ll> :: iterator it = mp.begin();\n\twhile(1){\n\t  if((*it).first.second >= name){\n\t    if((*it).first.first <= name){\n\t      cout << (*it).second << endl;\n\t    }else{\n\t      cout <<-1 << endl;\n\t    }\n\t    break;\n\t  }\n\t  it++;\n\t  if(it == mp.end()){\n\t    cout << -1 << endl;\n\t    break;\n\t  }\n\t}\n      }\n      \n    }\n    cout << endl;\n\t    \n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        lli output = -1;\n        for(lli i = 0, sum = 0; i < v.size(); sum += v[i++].size) {\n          if(P < sum+v[i].size) {\n            if(v[i].id >= 0) output = v[i].id;\n            break;\n          }\n        }\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nstruct Data {\n\tint  num, pos, len;\n};\ntypedef pair<int, int> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile(cin >> n, n) {\n\t\tmap<int, Data> datamap; //[pos]->Data\n\t\tmap<int, vector<Data> > nummap;  //[num]->vec<idx>\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tq.push(P{ 0, int(1e9 + 1) });\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tchar op;\n\t\t\tcin >> op;\n\t\t\tif(op == 'W') {\n\t\t\t\tint num, len;\n\t\t\t\tcin >> num >> len;\n\t\t\t\twhile(len > 0) {\n\t\t\t\t\tP p = q.top();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tData d{ num, p.first, len };\n\t\t\t\t\tif(p.second >= len) {\n\t\t\t\t\t\tif(p.second > len)\n\t\t\t\t\t\t\tq.push(P(p.first + len, p.second - len));\n\t\t\t\t\t\tlen = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(p.second < len) {\n\t\t\t\t\t\td.len = p.second;\n\t\t\t\t\t\tlen -= p.second;\n\t\t\t\t\t}\n\t\t\t\t\tdatamap[d.pos] = d;\n\t\t\t\t\tnummap[num].push_back(d);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op == 'D') {\n\t\t\t\tint num;\n\t\t\t\tcin >> num;\n\t\t\t\tfor(const Data& d : nummap[num]) {\n\t\t\t\t\tdatamap.erase(d.pos);\n\t\t\t\t\tq.push(P(d.pos, d.len));\n\t\t\t\t}\n\t\t\t\tnummap[num].clear();\n\t\t\t}\n\t\t\telse {// 'R'\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tauto it = datamap.upper_bound(pos);\n\t\t\t\tif(it == datamap.end() && datamap.size() == 0) {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t--it;\n\t\t\t\tData d = it->second;\n\t\t\t\tif(d.pos <= pos && pos < d.pos + d.len) {\n\t\t\t\t\tcout << d.num << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << \"-1\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s));\n                        endtoi[x.first + s] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second));\n                        endtoi[x.second] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(mp[i][j]);\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\n// const int inf = 1e9;\nconst int inf = 2e9;\nconst int mod = 1e9 + 7;\n\nstruct Range {\n    int l, r; // [l, r)\n    int no;\n    Range(){}\n    Range(int _l, int _r, int _no) : l(_l), r(_r), no(_no) {}\n    bool operator<( const Range& right ) const {\n        if (l != right.l) return l < right.l;\n        if (r != right.r) return r < right.r;\n        return no < right.no;\n    }\n    void print() {\n        cout << l << \" \" << r << \" \" << no << endl;\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        set<Range> st;\n        st.insert(Range(-inf, 0, -1));\n        st.insert(Range(inf - 1, inf, -1));\n\n        rep(i, n) {\n            // cout << \"i = \" << i << endl;\n\n            char mode;\n            cin >> mode;\n            if (mode == 'W') {\n                int no, len;\n                cin >> no >> len;\n                // cout << \"command: W \" << no << \" \" << len << endl;\n                for (auto it = st.begin(); next(it) != st.end() && len > 0; it++) {\n                    int len_here = min(len, next(it)->l - it->r);\n                    if (len_here > 0) {\n                        it = st.insert(Range(it->r, it->r + len_here, no)).first;\n                        len -= len_here;\n                    }\n                }\n            } else if (mode == 'D') {\n                int no;\n                cin >> no;\n                // cout << \"command: D \" << no << endl;\n                for (auto it = st.begin(); it != st.end(); ) {\n                    if (it->no == no) {\n                        // cout << \"type 1: \" << it->first << \", \" << it->second << endl;\n                        it = st.erase(it);\n                    } else {\n                        // cout << \"type 2: \" << it->first << \", \" << it->second << endl;\n                        it++;\n                    }\n                }\n            } else if (mode == 'R') {\n                int pos;\n                cin >> pos;\n                // cout << \"command: R \" << pos << endl;\n                auto it = st.upper_bound(Range(pos, inf, inf));\n                it--;\n                cout << (pos < it->r ? it->no : -1) << endl;\n            }\n\n            // for (auto obj : st) {\n            //     obj.print();\n            // }\n            // cout << endl;\n        }\n\n        // end of data\n        cout << endl;\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\n\nstruct Point {\n\tint first;\n\tint len;\n\tint sikibetu_id;\n};\nvector<Point> sys;\n\nint read_sys(int real_i) {\n\trep(i,sys.size()) {\n\t\tint first = sys[i].first;\n\t\tint last = first + sys[i].len;\n\t\tif (first <= real_i && real_i < last) {\n\t\t\treturn sys[i].sikibetu_id;\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid delete_sys(int siki) {\n\trep(i,sys.size()) {\n\t\tif (sys[i].sikibetu_id == siki) {\n\t\t\tsys.erase(sys.begin() + i); //i???????´??????????\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid write_sys(int siki, int len) {\n\tint tune_index = 0;\n\trep(i,sys.size()) {\n\t\tif (tune_index != sys[i].first) {\n\t\t\t//tune_index <= hoge <= sys[i].first??????????????£???\n\t\t\tint between = (sys[i].first - tune_index);\n\n\t\t\tif (between >= len) {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=len;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen=0; //0\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=between;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen-=between;\n\t\t\t}\n\t\t}\n\t\ttune_index += sys[i].len;\n\t}\n\n\tif (len > 0) {\n\t\tPoint p;\n\t\tp.first=tune_index;\n\t\tp.len=len;\n\t\tp.sikibetu_id=siki;\n\t\tsys.push_back(p);\n\t}\n\n}\n\nvoid show() {\n\tdump(\"-------\");\n\trep(i,sys.size()) {\n\t\tdump(sys[i].first);\n\t\tdump(sys[i].len);\n\t\tdump(sys[i].sikibetu_id);\n\t}\n}\n\nint main() {\n\tint N;\n\tchar command;\n\tint arg1,arg2;\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tsys.clear();\n\t\trep(i,N) {\n\t\t\tcin >> command;\n\t\t\t//dump(command);\n\t\t\tif (command == 'R') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tcout << read_sys(arg1) << endl;\n\t\t\t}\n\t\t\telse if (command == 'D') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tdelete_sys(arg1);\n\t\t\t}\n\t\t\telse if (command == 'W') {\n\t\t\t\tcin >> arg1 >> arg2;\n\t\t\t\twrite_sys(arg1,arg2);\n\t\t\t}\n\t\t\t//show();\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  long long num, size, next;\n};\n\nstruct command {\n  string c;\n  data d;\n};\n\nint n;\nvector<data> sec;\nset<int> st;\nvector<command> commands;\n\nvoid solve();\nvoid secwrite(data now);\nvoid secdelete(data now);\nvoid secread(data now);\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    commands.assign(n, {\"a\", {0, 0, -1}});\n    for(int i = 0; i < n; ++i) {\n      cin >> commands[i].c >> commands[i].d.num;\n      if(commands[i].c == \"W\") cin >> commands[i].d.size;\n    }\n    solve();\n    cout << endl;\n    st.clear();\n  }\n  return 0;\n}\n\nvoid solve() {\n  sec.assign(1, {-1, 0, -1});\n  st.insert(-1);\n  for(int i = 0; i < n; ++i) switch(commands[i].c[0]) {\n      case 'W': secwrite(commands[i].d); break;\n      case 'D': secdelete(commands[i].d); break;\n      case 'R': secread(commands[i].d); break;\n    }\n}\n\nvoid secwrite(data now) {\n  auto it = sec.begin();\n  st.insert(now.num);\n  while(1) {\n    if(st.find(it->num) == st.end()) {\n      data newdata = {-2, it->size - now.size, it->next};\n      it->num = now.num;\n      it->size = min(it->size, now.size);\n      now.size -= it->size;\n      if(newdata.size > 0) {\n        it->next = sec.size();\n        sec.push_back(newdata);\n      }\n    }\n    if(it->next == -1 || now.size <= 0) break;\n    it = sec.begin() + it->next;\n  }\n  if(now.size > 0) {\n    it->next = sec.size();\n    sec.push_back(now);\n    return;\n  }\n}\n\nvoid secdelete(data now) { st.erase(now.num); }\n\nvoid secread(data now) {\n  auto it = sec.begin();\n\n  long long ans = -1;\n  while(1) {\n    now.size += it->size;\n    if(now.num < now.size) {\n      if(st.find(it->num) != st.end()) ans = it->num;\n      break;\n    }\n    if(it->next == -1) break;\n    it = sec.begin() + it->next;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> Pi;\ntypedef pair<Pi, int> Pii;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector<Pii> memory;\n    memory.push_back(Pii(Pi(0, 1000000001), -1)); // just divide the segments. (half-open)\n    while(N--) {\n      char command; cin >> command;\n      if(command == 'W') {\n\tint I, S; cin >> I >> S;\n\tfor(int i = 0; S > 0; i++) {\n\t  if(memory[i].second != -1) continue;\n\t  int space = memory[i].first.second - memory[i].first.first;\n\t  if(space <= S) { // fill the space\n\t    S -= space;\n\t    memory[i].second = I;\n\t  } else { // space too large so divide\n\t    Pii data = Pii(Pi(memory[i].first.first, memory[i].first.first + S), I);\n\t    memory.insert(memory.begin() + i, data);\n\t    memory[i+1].first.first = memory[i].first.second;\n\t    break;\n\t  }\n\t}\n      } else if(command == 'D') {\n\tint I; cin >> I;\n\tfor(int i = 0; i < memory.size(); i++) {\n\t  if(memory[i].second == I) memory[i].second = -1;\n\t}\n      } else if(command == 'R') {\n\tint P; cin >> P;\n\tfor(int i = 0; i < memory.size(); i++) {\n\t  if(P < memory[i].first.second) {\n\t    cout << memory[i].second << endl;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\n\nlist<pair<int,int>> tape; //first := ide, second len;\n\nvoid Write(int ide, int len){\n\tauto itr = tape.begin();\n\twhile(len > 0){\n\t\twhile(itr->first != -1)itr++;\n\t\tif(itr->second <= len){\n\t\t\tlen -= itr->second;\n\t\t\titr->first = ide;\n\t\t}\n\t\telse{\n\t\t\tint nokori = itr->second - len;\n\t\t\t*itr = {-1, nokori};\n\t\t\titr = tape.insert(itr, {ide, len});\n\t\t\tlen = 0;\n\t\t}\n\t}\n}\n\nvoid Delete(int ide){\n\tfor(auto itr = tape.begin(); itr != tape.end(); ++itr){\n\t\tif(itr->first == ide)itr->first = -1;\n\t}\n}\n\nint Ref(int sec){\n\tsec++;\n\tauto ret = tape.end();\n\tfor(auto itr = tape.begin(); itr != tape.end(); ++itr){\n\t\tsec -= itr->second;\n\t\tif(sec <= 0){\n\t\t\tret = itr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ret == tape.end())return -1;\n\treturn ret->first;\n}\n\nsigned main(){\n\twhile(true){\n\t\ttape = list<pair<int,int>>(1, {-1,(int)1e9});\n\t\tint n;cin >> n;\n\t\tif(n == 0)break;\n\t\tfor(int i = 0; i < n; i++){\n//\t\t\tfor(auto e : tape)cout << e.first << \":\" << e.second << \" \";cerr << endl;\n\t\t\tchar ope; cin >> ope;\n\t\t\tswitch(ope){\n\t\t\t\tcase 'W':{\n\t\t\t\t\tint ide, len; cin >> ide >> len;\n\t\t\t\t\tWrite(ide, len);\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':{\n\t\t\t\t\tint ide;cin >> ide;\n\t\t\t\t\tDelete(ide);\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':{\n\t\t\t\t\tint sec;cin >> sec;\n\t\t\t\t\tcout << Ref(sec) << endl;\n\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s - 1));\n                        endtoi[x.first + s - 1] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second));\n                        endtoi[x.second] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(mp[i][j]);\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                if(it == endtoi.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <assert.h>\n    \nusing namespace std;\n  \nconst int LIMIT = 1000000000;\n  \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n    \nint N;\nvector<Data> storage;\n   \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n  \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = min(remain, storage[i].st - st);\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n        \n      if(st > LIMIT) return;\n    }\n    \n    if(num == -1) {\n      // insert data back\n      num = remain;\n      into = storage.size();\n    }\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n    assert(remain>=0);\n  }\n}\n  \nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n\nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n    \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct data{\n\tint no;\n\tint front;\n\tint size;\n\tbool operator<(const data &right){\n\t\treturn front < right.front;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile (cin>>n,n){\n\t\tvector<data> file;\n\t\tfile.push_back({ -1, 1, 1000000000 });\n\t\tREP(i,n){\n\t\t\tint a, b;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t\t\n\t\t\t\tcin >> a >> b;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].no == -1){\n\t\t\t\t\t\tif (file[i].size > b){\n\t\t\t\t\t\t\tfile.push_back({a,file[i].front,b});\n\t\t\t\t\t\t\tfile[i].front += b;\n\t\t\t\t\t\t\tfile[i].size -= b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(file[i].size==b){\n\t\t\t\t\t\t\tfile[i].no = a;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfile[i].no = a;\n\t\t\t\t\t\t\tb -= file[i].size;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> a;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].no == a)\n\t\t\t\t\t\tfile[i].no = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> a;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (a <= file[i].size){\n\t\t\t\t\t\tcout << file[i].no << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ta -= file[i].size;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSORT(file);\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing P=pair<int,int>;\nusing PP=pair<P,int>;\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<PP>data;\n        for(int j=0;j<n;++j){\n            char c;cin>>c;\n            if(c=='W'){\n                int l,s;cin>>l>>s;\n                int siz=data.size();\n                for(int i=0;i<siz;++i){\n                    if(data[i].second==-1){\n                        if(s>=data[i].first.second-data[i].first.first){\n                            s-=(data[i].first.second-data[i].first.first);\n                            data[i].second=l;\n                            if(!s)break;\n                        }else{\n                            data.push_back(PP(P(data[i].first.first,data[i].first.first+s),l));\n                            data[i].first.first+=s;\n                            break;\n                        }\n                    }\n                    else if(i==(siz-1)){\n                        data.push_back(PP(P(data[i].first.second,data[i].first.second+s),l));\n                        s=0;\n                    }\n                }\n                if(s>0)data.push_back(PP(P(0,s),l));\n                sort(data.begin(),data.end());\n            }else if(c=='D'){\n                int l;cin>>l;\n                for(int i=0;i<data.size();++i){\n                    if(data[i].second==l){\n                        data[i].second=-1;\n                    }\n                }\n            }else{\n                int p,ans=-1;cin>>p;\n                for(int i=0;i<data.size();++i){\n                    if(data[i].first.first<=p && data[i].first.second>p){\n                        ans=data[i].second;\n                    }\n                }\n                cout<<ans<<endl;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(c,c+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(c,c+k-1)]=n;\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nstruct Seg{\n\tint s,e,no;\n\tSeg(){}\n\tSeg(int a,int b,int c):s(a),e(b),no(c){}\n};\n\nvector<Seg> v;\nvoid write(int l,int s){\n\tfor(int i=0;s;i++){\n\t\tif(v[i].no!=-1)continue;\n\t\tint t = v[i].e-v[i].s;\n\t\tif(t<=s){\n\t\t\tv[i].no=l;\n\t\t\ts-=t;\n\t\t}else{\n\t\t\tt = v[i].s;\n\t\t\tv[i].s += s;\n\t\t\tv.insert(v.begin()+i,Seg(t,t+s,l));\n\t\t\ts=0;\n\t\t}\n\t}\n}\nvoid del(int l){\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].no==l){\n\t\t\tv[i].no=-1;\n\t\t}\n\t}\n}\nvoid read(int p){\n\tfor(int i=0;i<v.size();i++){\n\t\tif(v[i].s<=p&&p<v[i].e){\n\t\t\tcout<<v[i].no<<endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tv.clear();\n\t\tv.push_back(Seg(0,1000000000+1,-1));\n\t\twhile(n--){\n\t\t\tchar com;\n\t\t\tcin>>com;\n\t\t\tif(com=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tcin>>l>>s;\n\t\t\t\twrite(l,s);\n\t\t\t}else if(com=='D'){\n\t\t\t\tint l;\n\t\t\t\tcin>>l;\n\t\t\t\tdel(l);\n\t\t\t}else {\n\t\t\t\tint p;\n\t\t\t\tcin>>p;\n\t\t\t\tread(p);\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nconst ll INF = 1LL << 60;\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        PQ que;\n        que.push(P(0LL,INF));\n        map<P,ll> m;\n        while (n--) {\n            char c;\n            cin >> c;\n            if (c == 'W') {\n                ll t, l;\n                cin >> t >> l;\n                P p;\n                while (true) {\n                    p = que.top(); que.pop();\n                    ll s = p.first, g = p.second;\n                    if (s + l - 1 <= g) {\n                        if (s + l - 1 < g)\n                            que.push(P(s + l, g));\n                        m[P(s, s + l - 1)] = t;\n                        break;\n                    } else {\n                        m[P(s, g)] = t;\n                        l -= g - s + 1;\n                    }\n                }\n            } else if (c == 'D') {\n                ll t; cin >> t;\n                for (auto i : m) {\n                    if (i.second == t) {\n                        que.push(i.first);\n                        m.erase(m.find(i.first));\n                    }\n                }\n            } else {\n                ll x; cin >> x;\n                bool flag = true;\n                for (auto i : m) {\n                    if (i.first.first <= x && x <= i.first.second) {\n                        cout << i.second << endl;\n                        flag = false;\n                        break;\n                    }\n                }\n                if (flag)\n                    cout << -1 << endl;\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tvector<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v[0].p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min(v[0].p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= v[0].p.second + 1;\n\t\t\t\t}\n\t\t\t\trep(i, v.size() - 1) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tif (v[i].p.second + 1 < v[i + 1].p.first) {\n\t\t\t\t\t\tv.insert(v.begin() + i + 1, { P(v[i].p.second + 1, min(v[i + 1].p.second - 1, v[i].p.first + b - 1)),a });\n\t\t\t\t\t\tb -= v[i + 1].p.second - v[i + 1].p.first + 1;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P(v[v.size() - 1].p.second + 1, b + v[v.size() - 1].p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\trep(i, v.size()) {\n\t\t\t\t\tif (v[i].p.first == a) {\n\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < v.size() && v[i].p.second < a; i++);\n\t\t\t\tif (i == v.size())puts(\"-1\");\n\t\t\t\telse if (v[i].p.first <= a&&a <= v[i].p.second)printf(\"%d\\n\", v[i].id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct C{\n  int f,a,s;\n};\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<C> v(1);\n    C is={-1,0,1000000001};\n    v[0]=is;\n    while(n--){\n      char c;\n      cin>>c;\n      if(c=='W'){\n\tint l,s;\n\tcin>>l>>s;\n\tfor(int i=0;s;i++){\n\t  if(v[i].f==-1){\n\t    v[i].f=l;\n\t    if(v[i].s<=s){\n\t      s-=v[i].s;\n\t    }else{\n\t      C n={-1,v[i].a+s,v[i].s-s};\n\t      v[i].s=s;\n\t      v.insert(v.begin()+i+1,n);\n\t      break;\n\t    }\n\t  }\n\t}\n      }else if(c=='D'){\n\tint l;\n\tcin>>l;\n\tfor(int i=0;i<v.size();i++){\n\t  if(v[i].f==l){\n\t    v[i].f=-1;\n\t  }\n\t}\n      }else{\n\tint p;\n\tcin>>p;\n\tfor(int i=0;i<v.size();i++){\n\t  if(v[i].a<=p&&p<v[i].a+v[i].s){\n\t    cout<<v[i].f<<endl;\n\t  }\n\t}\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}\n\t    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nifstream ifs(\"2152_input.txt\");\nofstream ofs(\"op.txt\");\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            auto it = disk.begin();\n            while(it != disk.end()){\n                if(it->second == t) disk.erase(it++);\n                else it++;\n            }\n        }else{\n            auto lb = disk.lower_bound(pint(t, 0));\n            if(lb != disk.begin()) lb--;\n            pint temp = lb->first;\n            if(temp.first <= t && t <= temp.second)\n              cout << lb->second << endl;\n            else\n              cout << \"-1\" << endl;\n        }\n       \n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        list<pair<int,pair<int, int>>> ls;\n        ls.push_back(make_pair(-1,make_pair(-1,-1)));\n\n        rep(i,n){\n            char com;\n            cin >> com;\n            if(com == 'W'){\n                int a, b;\n                cin >> a >> b;\n                auto cur = ls.begin();\n                auto bef = ls.begin();\n                cur++;\n                while(b > 0){\n                    if(cur == ls.end()){\n                        int tmp = bef->second.second + 1;\n                        ls.push_back(make_pair(a,make_pair(tmp, tmp + b - 1)));\n                        b = 0;\n                    }else if(bef->second.second + 1 != cur->second.first){\n                        int dif = cur->second.first - bef->second.second - 1;\n                        int tmp = bef->second.second + 1;\n                        if(b <= dif){\n                            ls.insert(cur,make_pair(a,make_pair(tmp,tmp + dif - 1)));\n                            b = 0;\n                        }else{\n                            ls.insert(cur,make_pair(a,make_pair(tmp,cur->second.first - 1)));\n                            b -= dif;\n                        }\n                        cur = ls.begin();\n                        bef = ls.begin();\n                        cur++;\n                        continue;\n                    }\n                    cur++;\n                    bef++;\n                }\n            }else if(com == 'D'){\n                int a;\n                cin >> a;\n                for(auto it = ls.begin(); it != ls.end(); it++){\n                    if(it->first == a){\n                        it = ls.erase(it);\n                    }\n                }\n            }else{\n                int a;\n                cin >> a;\n\n                bool f = false;\n                for(auto it:ls){\n                    if(it.second.first <= a && a <= it.second.second){\n                        cout << it.first << endl;\n                        f = true;\n                        break;\n                    }\n                }\n                if(not f) cout << -1 << endl;\n            }\n            //for(auto it : ls){ cout << it.second.first << ' ' << it.second.second << endl; }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <bitset>\n#include <deque>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <utility>\n#include <fstream>\n \nconst long INF = (1l << 30);\nconst long LINF = (1l << 60);\n\ntypedef std::pair<long, long> P;\n\nlong n;\nstd::map<P, long> mp;\nstd::string s;\n\nvoid write(){\n\tlong a, b;\n\tscanf(\"%ld%ld\", &a, &b);\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second == -1){\n\t\t\tlong l = it->first.first;\n\t\t\tlong r = std::min(it->first.second, l + b);\n\t\t\tb -= r-l;\n\t\t\tlong rr = it->first.second;\n\t\t\tif(b > it->first.second - l){\n\t\t\t\tit->second = a;\n\t\t\t\tb -= r - l;\n\t\t\t}else{\n\t\t\t\tmp.erase(it);\n\t\t\t\tmp[P(l, r)] = a;\n\t\t\t\tmp[P(r, rr)] = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid del(){\n\tlong a;\n\tscanf(\"%ld\", &a);\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->second == a){\n\t\t\tit->second = -1;\n\t\t}\n\t}\n}\n\nvoid ref(){\n\tlong a;\n\tscanf(\"%ld\", &a);\n\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\tif(it->first.first <= a && a < it->first.second){\n\t\t\tprintf(\"%ld\\n\", it->second);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tscanf(\"%ld\", &n);\n\t\tif(n == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tmp.clear();\n\t\tmp[P(0, 1000000009)] = -1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts.clear();\n\t\t\tstd::cin >> s;\n\t\t\tif(s[0] == 'W'){\n\t\t\t\twrite();\n\t\t\t}else if(s[0] == 'D'){\n\t\t\t\tdel();\n\t\t\t}else{\n\t\t\t\tref();\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(auto it = mp.begin(); it != mp.end(); it++){\n\t\t\t\tprintf(\"%d  [%ld, %ld)  %ld\\n\", i, it->first.first, it->first.second, it->second);\n\t\t\t}\n\t\t\tprintf(\"--------\\n\");\n\t\t\t//*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tusing T = tuple<int, int, int>;\n\tfor (int n; cin >> n&&n;) {\n\t\tset<T> st;\n\t\tst.emplace(-INF, 0, -1);\n\t\twhile (n--) {\n\t\t\tchar com; cin >> com;\n\t\t\tif (com == 'W') {\n\t\t\t\tint l, s; cin >> l >> s;\n\t\t\t\tfor (auto c = st.begin(); c != st.end(); c++) {\n\t\t\t\t\tint ca, cb, cc, na, nb, nc;\n\t\t\t\t\ttie(ca, cb, cc) = *c;\n\t\t\t\t\tif (next(c) == st.end()) {\n\t\t\t\t\t\tst.emplace(cb, cb + s, l);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttie(na, nb, nc) = *next(c);\n\t\t\t\t\tif (cb == na)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint d = min(s, na - cb);\n\t\t\t\t\tc = st.emplace(cb, cb + d, l).first;\n\t\t\t\t\ts -= d;\n\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tfor (auto it = st.begin(); it != st.end();) {\n\t\t\t\t\tif (get<2>(*it) == l)\n\t\t\t\t\t\tit = st.erase(it);\n\t\t\t\t\telse\n\t\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (com == 'R') {\n\t\t\t\tint p; cin >> p;\n\t\t\t\tauto upper = st.upper_bound(T(p, INF, INF));\n\t\t\t\tint a, b, c;\n\t\t\t\ttie(a, b, c) = *prev(upper);\n\t\t\t\tif (b <= p)\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << c << endl;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define mx 1000000000\n\nusing namespace std;\n\nint main()\n{\n  int n, s, t;\n  bool ft = false, f;\n  char com;\n\n  while(cin>>n && n){\n    if(ft){\n      cout << endl;\n    }\n    vector<int> vec;\n\n    while(n--){\n      cin >> com;\n\n      if(com == 'W'){\n\tcin >> s >> t;\n\tfor(int i = 0, l = vec.size(); i < l && l <= mx; i++){\n\t  if(vec[i] == -1){\n\t    vec[i] = s;\n\t    t--;\n\t    if(t == 0){\n\t      break;\n\t    }\n\t  }\n\t}\n\tif(t > 0){\n\t  while(t-- && vec.size() <= mx){\n\t    vec.push_back(s);\n\t  }\n\t}\n      } else if(com == 'R'){\n\tcin >> s;\n\tif(vec.size() <= s){\n\t  cout << -1 << endl;\n\t} else {\n\t  cout << vec[s] << endl;\n\t}\n      } else if(com == 'D'){\n\tcin >> s;\n\tfor(int i = 0; i < vec.size(); i++){\n\t  if(vec[i] == s){\n\t    vec[i] = -1;\n\t  }\n\t}\n      }\n    }\n\n    ft = true;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii, int> piii;\n\nint main() {\n  int n;\n  int hoho = 0;\n  while(cin>>n,n) {\n    if (hoho) cout << endl;\n    else hoho = 1;\n    set<piii> se;               // piii(pii(a, b), c) -> [a,b) É c ªÍ¢ÁÄéB\n    REP(i,n) {\n      char c;\n      cin >> c;\n      if (c=='W') {\n        int a,m;\n        cin>>a>>m;\n        vector<piii> tmp;\n        int pre = 0;\n        FOR(it, se) {\n          if (m == 0) break;\n          pii p=it->first;\n          if (p.first > pre) {\n            int hoge = min(m, p.first-pre);\n            tmp.push_back(piii(pii(pre, pre+hoge), a));\n            m -= hoge;\n          }\n          pre = p.second;\n        }\n        if (m) {\n          tmp.push_back(piii(pii(pre, pre+m), a));\n        }\n        se.insert(ALL(tmp));\n      } else if (c == 'D') {\n        int a;\n        cin >> a;\n        set<piii> tmp;\n        FOR(it, se) {\n          if(it->second != a)\n            tmp.insert(*it);\n        }\n        se = tmp;\n      } else {\n        int m;\n        cin >> m;\n        int ans = -1;\n        FOR(it, se) {\n          pii p = it->first;\n          if (p.first<=m && m<p.second) {\n            ans = it->second;\n            break;\n          }\n        }\n        cout << ans << endl;\n      }\n       // cout << \"i = \" << i << endl;\n       // FOR(it, se) {\n       //   pii p =  it->first;\n       //   printf(\"(%d,%d),%d \", p.first,p.second,it->second);\n       // }\n       // cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Data {\n  int id;\n  ull st;\n  int num;\n  Data(int id, ull st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n \nint N;\nvector<Data> storage;\n\nvoid dump() {\n  #ifdef DEBUG\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n  #endif\n}\n\nvoid write(const int id, int remain) {\n  ull st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n\tinto = i;\n\tbreak;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      num = remain;\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nvoid del(int id) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].id == id) {\n      storage.erase(storage.begin()+i);\n      #ifdef DEBUG\n      cout << \"Deleted: \" << id << endl;\n      #endif\n      dump();\n    }\n  }\n}\n \nint refer(ull sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n \nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n\tdump();\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <list>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nstruct sector{\n    int label, s,e; // [s,e]\n    sector(int _l, int _s, int _e){\n        label = _l, s = _s, e = _e;\n    }\n};\n\nstruct filesystem{\n    list<sector> li;\n\n    void clear(){ li.clear(); }\n\n    void write(int l, int s){\n        int num = 0;\n        foreach(it,li){\n            if( s <= 0 ) break;\n            if( num < it->s ){\n                li.insert(it, sector(l, num, min(s+num-1,it->s-1)));\n                s -= (it->s - 1 - num) + 1;\n            }\n            num = it->e+1;\n        }\n        if( s > 0 ){\n            li.push_back(sector(l,num,s+num-1));\n        }\n    }\n\n    void del(int l){\n        foreach(it,li){\n            if( it->label == l ){\n                it = li.erase(it);\n                it--;\n            }\n        }\n    }\n\n    int read(int p){\n        foreach(it,li){\n            if( it->s <= p && p <= it->e ) return it->label;\n        }\n        return -1;\n    }\n\n    void print(){\n        foreach(it,li){\n            printf(\"label = %d, [%d,%d]\\n\", it->label, it->s, it->e);\n        }\n    }\n};\n\nint main(){\n    int T,i,j,k,l,s,p;\n    filesystem fs;\n\n    while( cin >> T, T ){\n        fs.clear();\n\n        rep(i,T){\n            char ope; cin >> ope;\n            if( ope == 'W' ){\n                cin >> l >> s;\n                fs.write(l,s);\n                //printf(\"W %d %d\\n\", l,s);\n                //fs.print();\n            }\n            else if( ope == 'D' ){\n                cin >> l;\n                fs.del(l);\n                //printf(\"D %d\\n\",l);\n                //fs.print();\n            }\n            else{ // R\n                cin >> p;\n                cout << fs.read(p) << endl;\n            }\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n        if(n == 0)break;\n        \n        set<P1> S1;\n        set<P1> S2;\n        S1.insert(mp1(0,-1,1000000001));\n        S2.insert(mp1(-1,0,1000000001));\n        \n        for(int i = 0 ; i < n ; i ++){\n            char c;\n            cin >> c;\n            //scanf(\"\\n%c\",&c);\n            if(c == 'W'){\n                int l,s;\n                scanf(\"%d%d\",&l,&s);\n                set<P1>::iterator itr = S2.lower_bound(mp1(-1,0,0));\n                while(1){\n                    if(itr->sc.sc > s){\n                        S1.insert(mp1(itr->sc.fr,l,s));\n                        S1.insert(mp1(itr->sc.fr+s,itr->fr,itr->sc.sc-s));\n                        S1.erase(mp1(itr->sc.fr,itr->fr,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,s));\n                        S2.insert(mp1(itr->fr,itr->sc.fr+s,itr->sc.sc-s));\n                        S2.erase(itr);\n                        break;\n                    }\n                    else {\n                        S1.insert(mp1(itr->sc.fr,l,itr->sc.sc));\n                        S1.erase(mp1(itr->sc.fr,-1,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,itr->sc.sc));\n                        s -= itr->sc.sc;\n                        S2.erase(itr++);\n                    }\n                    if(s == 0)break;\n                }\n            }\n            else if(c == 'D'){\n                int l;\n                scanf(\"%d\",&l);\n                set<P1>::iterator itr = S2.lower_bound(mp1(l,0,0));\n                while(1){\n                    S1.insert(mp1(itr->sc.fr,-1,itr->sc.sc));\n                    S1.erase(mp1(itr->sc.fr,l,itr->sc.sc));\n                    S2.insert(mp1(-1,itr->sc.fr,itr->sc.sc));\n                    S2.erase(itr++);\n                    if(itr->fr != l)break;\n                }\n            }\n            else {\n                int p;\n                scanf(\"%d\",&p);\n                set<P1>::iterator itr = S1.upper_bound(mp1(p,-1,0));\n                printf(\"%d%c\",(--itr)->sc.fr,10);\n            }\n        }\n        printf(\"%c\",10);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint main(){\n  int n;\n  while (cin >> n, n){\n    list<pair<int, int>> l{{-1, inf}};\n    rep(i, n){\n      string c;\n      cin >> c;\n      if (c == \"W\"){\n        int a, b;\n        cin >> a >> b;\n        auto it = l.begin();\n        while (b > 0){\n          if (it->first == -1){\n            if (b >= it->second){\n              it->first = a;\n              b -= it->second;\n            }\n            else {\n              l.insert(next(it), {-1, it->second - b});\n              *it = {a, b};\n              b = 0;\n            }\n          }\n          ++it;\n        }\n      }\n      else if (c == \"D\"){\n        int a;\n        cin >> a;\n        auto it = l.begin();\n        while (it != l.end()){\n          if (it->first == a) it->first = -1;\n          ++it;\n        }\n        it = l.begin();\n        while (next(it) != l.end()){\n          if (it->first == -1 && next(it)->first == -1){\n            it->second += next(it)->second;\n            l.erase(next(it));\n          }\n          ++it;\n        }\n      }\n      else if (c == \"R\"){\n        int a;\n        cin >> a;\n        auto it = l.begin();\n        while (a >= it->second){\n          a -= it->second;\n          ++it;\n        }\n        cout << it->first << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nstruct P{\n\tint a, s, e;\n\tbool v;\n};\n\nint n;\nvector<P> f;\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tchar w;\n\t\t\tint a;\n\t\t\tscanf(\" %c%d\", &w, &a);\n\n\t\t\tif(w == 'W'){\n\t\t\t\tint c;\n\t\t\t\tscanf(\"%d\", &c);\n\t\t\t\t\n\t\t\t\tif(f.empty()){\n\t\t\t\t\tf.push_back(P{a, 0, c, true});\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint s = -1, e;\n\t\t\t\t\tfor(auto& x: f){\n\t\t\t\t\t\tif(!x.v){\n\t\t\t\t\t\t\tif(s == -1){\n\t\t\t\t\t\t\t\ts = x.s;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tc -= (x.e - x.s);\n\t\t\t\t\t\t\tif(c <= 0){\n\t\t\t\t\t\t\t\te = x.e + c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s == -1){\n\t\t\t\t\t\ts = f.back().e;\n\t\t\t\t\t}\n\t\t\t\t\tif(c > 0){\n\t\t\t\t\t\te = f.back().e + c;\n\t\t\t\t\t}\n\t\t\t\t\tf.push_back(P{a, s, e, true});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(w == 'D'){\n\t\t\t\tfor(auto& x: f){\n\t\t\t\t\tif(x.a == a){\n\t\t\t\t\t\tx.v = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(w == 'R'){\n\t\t\t\tbool b = false;\n\t\t\t\tfor(auto& x: f){\n\t\t\t\t\tif(x.v && x.s <= a && a < x.e){\n\t\t\t\t\t\tprintf(\"%d\\n\", x.a);\n\t\t\t\t\t\tb = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!b){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\tfor(auto& x: f){\n\t\t\t\tprintf(\"(id, s, e, v) = (%d, %d, %d, %s)\\n\", x.a, x.s, x.e, x.v ? \"true\" : \"false\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\n\t\t/*\n\t\tprintf(\"\\n\\n\\n\\n\");\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lidl,ridl;\n\tint idl;\n\tint l,r;\n\tdata(){}\n\tdata(int iidl,int ll,int rr,int lll,int rrr){\n\t\tidl=iidl;\n\t\tlidl=ll;\n\t\tridl=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> idl;\nvector<int> idldata;\nvector<int> placee[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tidl.clear();\n\t\tidldata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(idl.find(l)==idl.end()){\n\t\t\t\t\tidl[l]=idldata.size();\n\t\t\t\t\tidldata.push_back(l);\n\t\t\t\t\tplacee[idl[l]].clear();\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(idl[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tif(st==-1)return 0;\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lidl=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lidl].r){\n\t\t\t\t\t\t\tdat.push_back(data(idl[l],dat[nv].lidl,nv,dat[dat[nv].lidl].r,dat[dat[nv].lidl].r+min(s,dat[nv].l-dat[dat[nv].lidl].r)));\n\t\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lidl].r);\n\t\t\t\t\t\t\tdat[dat[nv].lidl].ridl=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lidl=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].ridl=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(idl.find(l)==idl.end())continue;\n\t\t\t\tfor(int i=0;i<placee[idl[l]].size();i++){\n\t\t\t\t\tdata d=dat[placee[idl[l]][i]];\n\t\t\t\t\tif(d.lidl==-1)st=d.ridl;\n\t\t\t\t\tif(d.ridl==-1)en=d.lidl;\n\t\t\t\t\tdat[d.ridl].lidl=d.lidl;\n\t\t\t\t\tdat[d.lidl].ridl=d.ridl;\n\t\t\t\t}\n\t\t\t\tplacee[idl[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?idldata[dat[nv].idl]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].ridl){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].idl,dat[i].lidl,dat[i].ridl,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\n#include<set>\n#include<cstring>\n#include<map>\n \nusing namespace std;\n \n\nint main(void)\n{\n\t\n\tint n;\n\twhile(cin>>n,n){\n\t\t//????????????,?????\\\n\t\tmap<int,int> sec;\n\t\t\n\t\t//-1(???)???0???????§???????\n\t\tsec[0]=-1;\n\t\tsec[1000000000]=-1;\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\t\n\t\t\tif(s==\"W\"){\n\t\t\t\tint a,len;\n\t\t\t\tcin>>a>>len;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second==-1){\n\t\t\t\t\t\tit->second=a;\n\t\t\t\t\t\tauto it2=it;\n\t\t\t\t\t\tit2++;\n\t\t\t\t\t\tif(it2->first - it->first > len){\n\t\t\t\t\t\t\tsec[it->first+len]=-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse len-=(it2)->first - it->first;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}else if(s==\"D\"){\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tif(it->second == a) it->second=-1;\n\t\t\t\t}\n\t\t\t}else if(s==\"R\"){\n\t\t\t\t/*\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\t\t\t\t\tcout<<\"map[\"<<it->first<<\"]=\"<<it->second<<endl;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tint a;\n\t\t\t\tcin>>a;\n\t\t\t\t\n\t\t\t\tfor(auto it=sec.begin();it!=sec.end();it++){\n\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\tit2++;\n\t\t\t\t\tif(it->first<=a && a<=it2->first){\n\t\t\t\t\t\tcout<<it->second<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout<<endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <assert.h>\n    \nusing namespace std;\n  \nconst int LIMIT = 1000000000;\n  \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n    \nint N;\nvector<Data> storage;\n   \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n  \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n        \n      if(st > LIMIT) return;\n    }\n    \n    if(num == -1) {\n      // insert data back\n      num = remain;\n      into = storage.size();\n    }\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n    assert(remain>=0);\n  }\n}\n  \nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n\nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n    \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//:55-\n#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  files[make_pair(h,e-1)]=I;\n\t  S-=h-e;\n\t}else{\n\t  files[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tif(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 区間を set で管理するやつ\n// 閉区間 [l, r] を扱うことに注意\ntemplate <typename numericType>\nstruct IntervalSet : set< pair<numericType, numericType> > {\n    // x を含む閉区間 [l, r] を取得\n    // イテレータを返す\n    auto get(numericType x) {\n        // x より始点が大きい区間の中で最小のもの\n        auto itr = this->upper_bound(make_pair(x, x));\n        if(itr == this->begin() or (--itr)->second < x) return this->end();\n        return itr;\n    }\n\n    // [l, r] と overlap する区間の集合を取得\n    // vector を返す\n    vector< pair<numericType, numericType> > get(numericType l, numericType r) {\n        auto itr = this->upper_bound(make_pair(l, l));\n        if(itr != this->begin()) itr--;\n\n        vector< pair<numericType, numericType> > res;\n        for(; itr != this->end(); itr++) {\n            numericType il, ir; tie(il, ir) = *itr;\n            if(r < il) break; // 対称区間に対して右に飛び出た\n            // 対称区間に対して左に飛び出るか、含まれているかしかない\n            if(ir >= l) res.push_back(make_pair(il, ir));\n        }\n        return res;\n    }\n    \n    void insert(numericType l, numericType r) {\n        auto vec = this->get(l, r);\n        numericType il = l, ir = r;\n        for(auto e : vec) {\n            this->erase(e);\n            il = min(il, e.first);\n            ir = max(ir, e.second);\n        }\n        this->emplace(il, ir);\n    }\n    \n    void remove(numericType l, numericType r) {\n        auto vec = this->get(l, r);\n        for(auto e : vec) this->erase(e);\n    }\n\n    // p と q は同じ区間上にあるか？\n    bool same(numericType p, numericType q) {\n        auto itr = get(p);\n        return itr != this->end() and itr->first <= q and q <= itr.second;\n    }\n\n    void dump() {\n        for(auto e : *this) {\n            numericType l, r; tie(l, r) = e;\n            fprintf(stderr, \"# debug: [%g, %g]\\n\", l, r);\n        }\n    }\n};\n\nsigned main() {\n    int N;\n    while(cin >> N, N) {\n        map< int, IntervalSet<int> > mp;\n        mp[-1].insert(0, INF);\n\n        for(int i=0; i<N; i++) {\n            char com; cin >> com;\n            if(com == 'W') {\n                int id, len; cin >> id >> len;\n                auto &S = mp[-1];\n\n                vector< pair<int, int> > rem_list, ins_list;\n                for(auto e : S) {\n                    int l, r; tie(l, r) = e;\n                    int lim = r - l + 1;\n\n                    int use = min(len, lim);\n                    if(use == lim) {\n                        mp[id].insert(l, r);\n                        rem_list.emplace_back(l, r);\n                    }\n                    else {\n                        mp[id].insert(l, l + use - 1);\n                        rem_list.emplace_back(l, r);\n                        ins_list.emplace_back(l + use, r);\n                    }\n                    len -= use;\n                    if(len == 0) break;\n                }\n\n                for(auto e : rem_list) {\n                    int l, r; tie(l, r) = e;\n                    mp[-1].remove(l, r);\n                }\n                for(auto e : ins_list) {\n                    int l, r; tie(l, r) = e;\n                    mp[-1].insert(l, r);\n                }\n            }\n            if(com == 'R') {\n                int pos; cin >> pos;\n\n                // 破滅？\n                int ans = -1;\n                for(auto e : mp) {\n                    if(e.first == -1) continue;\n                    auto &S = e.second;\n                    if(S.get(pos) != S.end()) {\n                        ans = e.first;\n                        break;\n                    }\n                }\n                cout << ans << endl;\n            }\n            if(com == 'D') {\n                int id; cin >> id;\n                if(mp.count(id)) {\n                    auto &S = mp[id];\n                    for(auto itvl : S) {\n                        int l, r; tie(l, r) = itvl;\n                        mp[-1].insert(l, r);\n                    }\n                    mp[id].clear();\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\n#define first start \n#define second goal \n\nusing namespace std;\n\nconst int NONE = -1;\nconst int MAX = 1000000000;\n\nstruct sector {\n\tint length, id;\t\n\tsector(int id_, int length_): id(id_), length(length_) {}\n};\n\nvector<sector> sys;\nint pos;\n\n\nvoid read(int pos) {\n\tint idx = 0;\n\t//rep(i, sys.size()) { cout << sys[i].id << \",\" << sys[i].length << \" \";} cout << endl;\n\trep(i, sys.size()) {\n\t\tidx += sys[i].length;\n\t\tif(idx >= pos) {\n\t\t\tcout << sys[i].id << endl;\t\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nvoid write(int id, int size) {\n\n\tif(sys.size() == 0) {\n\t\tsys.push_back(sector(id, size));\t\n\t\treturn;\n\t}\n\t\n\trep(i, sys.size()) {\n\t\tif(sys[i].id != -1) continue;\n\t\t\n\t\tvector<sector>::iterator it = sys.begin()+i;\n\t\tif(sys[i].length == size) {\n\t\t\tsys[i].id = id;\t\n\t\t\treturn;\n\t\t}\n\t\telse if(sys[i].length - size > 0){\n\t\t\tsys.insert(it, sector(-1, sys[i].length - size));\n\t\t\tsys[i].id = id;\n\t\t\tsys[i].length = size;\n\t\t}\n\t\telse if(sys[i].length - size < 0) {\n\t\t\tsys[i].id = id;\n\t\t\tsize -= sys[i].length;\n\t\t}\n\t\tif(size <= 0) return;\n\t}\n\tsys.push_back(sector(id, size));\n\n\treturn;\n}\n\nvoid del(int id) {\n\trep(i, sys.size()) {\n\t\tif(sys[i].id == id) sys[i].id = -1;\t\n\t}\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\t\n\t\tsys.clear();\n\n\t\tchar cmd;\n\t\trep(i, n) {\n\t\t\tcin >> cmd;\t\n\t\t\tif(cmd == 'W') {\n\t\t\t\tint id, size;\n\t\t\t\tcin >> id >> size;\n\t\t\t\twrite(id, size);\n\t\t\t}\n\t\t\telse if(cmd == 'D') {\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\tdel(id);\n\t\t\t}\n\t\t\telse if(cmd == 'R') {\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tread(pos);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        list<pair<int,pair<int, int>>> ls;\n        ls.push_back(make_pair(-1,make_pair(-1,-1)));\n\n        rep(i,n){\n            char com;\n            cin >> com;\n            if(com == 'W'){\n                int a, b;\n                cin >> a >> b;\n                auto cur = ls.begin();\n                auto bef = ls.begin();\n                cur++;\n                while(b > 0){\n                    if(cur == ls.end()){\n                        int tmp = bef->second.second + 1;\n                        ls.push_back(make_pair(a,make_pair(tmp, tmp + b - 1)));\n                        b = 0;\n                    }else if(bef->second.second + 1 != cur->second.first){\n                        int dif = cur->second.first - bef->second.second - 1;\n                        int tmp = bef->second.second + 1;\n                        if(b <= dif){\n                            ls.insert(cur,make_pair(a,make_pair(tmp,tmp + b - 1)));\n                            b = 0;\n                        }else{\n                            ls.insert(cur,make_pair(a,make_pair(tmp,cur->second.first - 1)));\n                            b -= dif;\n                        }\n                        cur--;\n                        bef = cur;\n                        bef--;\n                    }\n                    cur++;\n                    bef++;\n                }\n            }else if(com == 'D'){\n                int a;\n                cin >> a;\n                for(auto it = ls.begin(); it != ls.end(); it++){\n                    if(it->first == a){\n                        it = ls.erase(it);\n                    }\n                }\n            }else{\n                int a;\n                cin >> a;\n\n                bool f = false;\n                for(auto it:ls){\n                    if(it.second.first <= a && a <= it.second.second){\n                        cout << it.first << endl;\n                        f = true;\n                        break;\n                    }\n                }\n                if(not f) cout << -1 << endl;\n            }\n            //for(auto it : ls){ cout << it.second.first << ' ' << it.second.second << endl; }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[1000001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//25min\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    vector<int> M(1,-1);\n    for(int j=0;j<N;j++){\n      char command;\n      int i,s,p;\n      int index;\n      cin >> command;\n      switch(command){\n      case 'W':\n\tcin >> i >> s;\n\tindex=0;\n\twhile(s>0){\n\t  if(index>=M.size()){\n\t    M[index]=i;\n\t    s--;\n\t  }else if(M[index]==-1){\n\t    M[index]=i;\n\t    s--;\n\t  }\n\t  index++;\n\t}\n\tbreak;\n      case 'D':\n\tcin >> i;\n\tfor(int k=0;k<M.size();k++){\n\t  if(M[k]==i) M[k]=(-1);\n\t}\n\tbreak;\n      case 'R':\n\tcin >> p;\n\tif(p<M.size()) cout << M[p] << endl;\n\telse cout << \"-1\" << endl;\n\tbreak;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\nusing namespace std;\n\n#define MAX 1000000000\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint n;\n\n\twhile(cin>>n, n){\n\t\tdeque<P> d;\n\t\td.push_back(P(-1,MAX));\n\n\t\twhile(n--){\n\t\t\tchar ch;\n\t\t\tcin>>ch;\n\t\t\tif(ch == 'W'){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\tfor(int i=0;i<d.size();i++){\n\t\t\t\t\tif(d[i].first != -1) continue;\n\n\t\t\t\t\tif(y > d[i].second){\n\t\t\t\t\t\td[i].first = x;\n\t\t\t\t\t\ty -= d[i].second;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y == d[i].second){\n\t\t\t\t\t\td[i].first = x;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\td[i].second -= y;\n\t\t\t\t\t\td.insert(d.begin()+i,P(x,y));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(ch == 'D'){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tfor(int i=0;i<d.size();i++)\n\t\t\t\t\tif(d[i].first == x)\n\t\t\t\t\t\td[i].first = -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x >= MAX){\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint idx = 0;\n\t\t\t\tfor(idx=0;idx<d.size();idx++){\n\t\t\t\t\tx -= d[idx].second;\n\t\t\t\t\tif(x <= -1) break;\n\t\t\t\t}\n\t\t\t\tcout<<d[idx].first<<endl;\n\t\t\t}\n\t\t}\n\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int> m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*cmd=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\tprintf(\"%d\\n\",--it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <tuple>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct Data{\n    int l,r,id;\n\n    bool operator<(const Data &rhs) const  {\n        return tie(l,r) < tie(rhs.l,rhs.r);\n    }\n};\n\nint n;\nvoid insert(list<Data> &range, int id,int cnt) {\n    if(range.size()==0) {\n        range.push_front({0,cnt,id});\n        return;\n    }\n    if(range.size()==1) {\n        if(range.begin()->l==0) {\n            range.push_back({range.begin()->r,range.begin()->r+cnt,id});\n            return;\n        }\n        else {\n            int t=range.begin()->l;\n            range.push_front({0,t,id});\n            cnt-=t;\n            if(cnt<=0) return;\n        }\n    }\n    auto it=range.begin();\n    auto prev=it;\n    it++;\n    while(it!=range.end()) {\n        if(prev->r!=it->l) {\n            int t=it->l-prev->r;\n            t=min(cnt,t);\n            range.insert(it,{prev->l,t,id});\n            \n            cnt-=t;\n        }\n        if(cnt<=0) return;\n        prev=it;\n        it++;\n    }\n\n    it--;\n    range.push_back({it->r,it->r+cnt,id});\n    \n}\nvoid solve() {\n    list<Data> range;\n    set<int> delete_set;\n    rep(i,n) {\n        char c;\n        int a,b;\n        cin>>c;\n        if(c=='W') {\n            cin>>a>>b;\n            insert(range,a,b);\n            //for(auto &e : range) {\n            //    cout<<e.l<<\",\"<<e.r<<\" : \"<<e.id<<endl;\n            //}\n        }\n        else if(c=='D') {\n            cin>>a;\n\n            auto it=range.begin();\n            while(it!=range.end()) {\n                if(it->id==a) it=range.erase(it);\n                else it++;\n            }\n        }\n        else {\n            cin>>a;\n            bool ok=false;\n            for(auto &e : range) {\n                if(e.l<=a&&a<e.r) {\n                    ok=true;\n                    cout<<e.id<<endl;\n                }\n            }\n            if(!ok) cout<<\"-1\"<<endl;\n        }\n    }\n}\nint main() {\n    while(cin>>n) {\n        if(!n) break;\n        solve();\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n    \nusing namespace std;\n  \nconst int LIMIT = 1000000000;\n  \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n    \nint N;\nvector<Data> storage;\n   \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n  \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = min(remain, storage[i].st - st);\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n        \n      if(st > LIMIT) return;\n    }\n    \n    if(num == -1) {\n      // insert data back\n      num = remain;\n      into = storage.size();\n    }\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n  \nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n\nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n    \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define size_of(a) (int)a.size()\n\ntypedef pair< int, int > Seg;\n\nint N, n;\nmap< int, int > ftoi, itof;\nvector< Seg > segs, fseg[10010];\n\nvoid _write_() {\n\tint l, S; cin >> l >> S;\n\tftoi[l] = n;\n\titof[n] = l;\n\t\n\tvector< Seg > new_segs;\t\n\t\n\tfor_(i,0,size_of(segs)) {\n\t\tif (S) {\n\t\t\tint w = segs[i].second - segs[i].first;\n\t\t\n\t\t\tif (w <= S) {\n\t\t\t\tS -= w;\n\t\t\t\tfseg[n].push_back(segs[i]);\n\t\t\t} else {\n\t\t\t\tfseg[n].push_back(Seg(segs[i].first, segs[i].first + S));\n\t\t\t\tnew_segs.push_back(Seg(segs[i].first + S, segs[i].second));\n\t\t\t\tS = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tnew_segs.push_back(segs[i]);\n\t\t}\n\t}\n\t\n\tsegs = new_segs;\n\t\n\t++n;\n}\n\nvoid _delete_() {\n\tint l; cin >> l;\n\tint f = ftoi[l];\n\t\n\tfor_(i,0,size_of(fseg[f])) segs.push_back(fseg[f][i]);\n\t\n\tfseg[f].clear();\n\t\n\tsort(segs.begin(), segs.end());\n\t\n\tint s = segs[0].first, t = segs[0].second;\n\tvector< Seg > new_segs;\n\t\n\tfor_(i,1,size_of(segs)) {\n\t\tif (segs[i].first == t) {\n\t\t\tt = segs[i].second;\n\t\t} else {\n\t\t\tnew_segs.push_back(Seg(s, t));\n\t\t\ts = segs[i].first;\n\t\t\tt = segs[i].second;\n\t\t}\n\t}\n\tnew_segs.push_back(Seg(s, t));\n\t\n\tsegs = new_segs;\n}\n\nvoid _read_() {\n\tint p; cin >> p;\n\t\n\tfor_(i,0,n) {\n\t\tfor_(j,0,size_of(fseg[i])) {\n\t\t\tif (fseg[i][j].first <= p && p < fseg[i][j].second) {\n\t\t\t\tcout << itof[i] << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << -1 << endl;\n}\n\nint main() {\t\n\twhile (cin >> N, N) {\n\t\tn = 0;\n\t\tftoi.clear();\n\t\titof.clear();\n\t\t\n\t\tsegs.clear();\n\t\tsegs.push_back(Seg(0, (int)1e9 + 1));\n\t\t\n\t\tfor_(i,0,N) fseg[i].clear();\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tchar c; cin >> c;\n\t\t\tswitch (c) {\n\t\t\tcase 'W':\n\t\t\t\t_write_();\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t_delete_();\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\t_read_();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX = 1000000000;\n\nstruct data {\n\tint id, len;\n\tdata(int id_ = 0, int len_ = 0):id(id_), len(len_) {}\n};\n\nvector<data> disk;\n\ninline void Write() {\n\tint id, size;\n\tcin >> id >> size;\n\n\tfor(auto it = begin(disk); it != end(disk); ++it) {\n\t\tif(it->id == -1) {\n\t\t\tif(size <= it->len) {\n\t\t\t\tit->len -= size;\n\t\t\t\tdisk.insert(it, data(id, size));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tit->id = id;\n\t\t\t\tsize -= it->len;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void Delete() {\n\tint id;\n\tcin >> id;\n\n\tfor(auto &e : disk) {\n\t\tif(e.id == id) e.id = -1;\n\t}\n}\n\ninline void Read() {\n\tint pos;\n\tcin >> pos;\n\n\tfor(const auto &e : disk) {\n\t\tif(pos < e.len) {\n\t\t\tcout << e.id << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tpos -= e.len;\n\t}\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tvoid (*func[128])();\n\tfunc['W'] = &Write;\n\tfunc['D'] = &Delete;\n\tfunc['R'] = &Read;\n\n\tfor(int n; cin >> n && n;) {\n\t\tdisk.assign(1, data(-1, MAX + 1));\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tfunc[c]();\n\t\t}\n\n\t\tcout << '\\n';\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tif(en==-1)return 0;\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nstruct st {\n\tP p; int id;\n};\nchar s[2];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\twhile (n) {\n\t\tvector<st>v;\n\t\trep(i, n) {\n\t\t\tscanf(\"%s\", s);\n\t\t\tif (s[0] == 'W') {\n\t\t\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\t\t\tif (v.empty()) {\n\t\t\t\t\tv.push_back({ P(0, b - 1),a });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (v[0].p.first) {\n\t\t\t\t\tv.insert(v.begin(), { P(0, min(v[0].p.first - 1, b - 1)) ,a });\n\t\t\t\t\tb -= v[0].p.second + 1;\n\t\t\t\t}\n\t\t\t\trep(i, v.size() - 1) {\n\t\t\t\t\tif (!b)break;\n\t\t\t\t\tif (v[i].p.second < v[i + 1].p.first) {\n\t\t\t\t\t\tv.insert(v.begin() + i + 1, { P(v[i].p.second + 1, min(v[i + 1].p.second - 1, v[i].p.first + b - 1)),a });\n\t\t\t\t\t\tb -= v[i + 1].p.second - v[i + 1].p.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b)v.push_back({ P(v[v.size() - 1].p.second + 1, b + v[v.size() - 1].p.second),a });\n\t\t\t}\n\t\t\tif (s[0] == 'D') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\trep(i, v.size()) {\n\t\t\t\t\tif (v[i].p.first == a) {\n\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[0] == 'R') {\n\t\t\t\tint a; scanf(\"%d\", &a);\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < v.size() && v[i].p.second < a; i++);\n\t\t\t\tif (i == v.size())puts(\"-1\");\n\t\t\t\telse if (v[i].p.first <= a&&a <= v[i].p.second)printf(\"%d\\n\", v[i].id);\n\t\t\t\telse puts(\"-1\");\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\telse puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\ntypedef map<pair<int,int>,int> mpiii;\n\nvoid solve(int T){\n\tmpiii m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(mpiii::iterator it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tmpiii::iterator it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tmpiii::iterator it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(mpiii::iterator it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    while(true){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        typedef tuple<int,int,int> triple;\n        set<triple> intervals;\n        intervals.insert(triple(0,0,-inf));\n        rep(i,0,n){\n            /*\n            for(const auto& interval:intervals){\n                cout << get<0>(interval) << \" \" << get<1>(interval) << \" \" << get<2>(interval) << endl;\n            }\n            */\n            char command;\n            cin >> command;\n            if(command=='W'){\n                int id,len;\n                cin >> id >> len;\n                auto a=intervals.begin();\n                auto b=intervals.begin();\n                ++b;\n                while(len>0){\n                    int l=get<1>(*a);\n                    if(b==intervals.end()){\n                        intervals.insert(triple(l,l+len,id));\n                        break;\n                    }\n                    auto r=get<0>(*b);\n                    if(l==r){\n                        a=b;\n                        ++b;\n                        continue;\n                    }\n                    b=intervals.insert(triple(l,r,id)).first;\n                    a=b;\n                    ++b;\n                    len-=r-l;\n                }\n            }else if(command=='D'){\n                int id;\n                cin >> id;\n                for(auto it=intervals.begin();it!=intervals.end();){\n                    if(get<2>(*it)==id) it=intervals.erase(it);\n                    else ++it;\n                }\n            }else{\n                int index;\n                cin >> index;\n                bool ok=false;\n                for(const auto& interval:intervals) if(get<0>(interval)<=index and index<get<1>(interval)){\n                    cout << get<2>(interval) << endl;\n                    ok=true;\n                    break;\n                }\n                if(!ok) cout << -1 << endl;\n            }\n        }\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass writeInfo{\npublic:\n\tint from;\n\tint to;\n\tint discripter;\n\n\twriteInfo(){}\n\n\tbool operator<(const writeInfo &w)const{\n\t\treturn this->from < w.from;\n\t}\n};\n\nint main(){\n\tint N;\n\tbool fst=false;\n\twhile(cin>>N&&N!=0){\n\t\tif(!fst){\n\t\t\tfst=true;\n\t\t}\n\t\telse\n\t\t\tcout<<endl;\n\t\tvector<writeInfo> info;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tchar order;\n\t\t\tcin>>order;\n\t\t\tif(order=='W'){\n\t\t\t\tint discripter;\n\t\t\t\tint leftWritingSize=0;\n\t\t\t\tint finTo=0;\n\t\t\t\tcin>>discripter>>leftWritingSize;\n\t\t\t\tint prvPlace=0;\n\t\t\t\tfor(int j = 0; j < info.size(); j++){\n\t\t\t\t\tif(leftWritingSize==0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// àµó«Xy[Xª³©Á½ç\n\t\t\t\t\tif(prvPlace==info[j].from){\n\t\t\t\t\t\tprvPlace=info[j].to+1;\n\t\t\t\t\t\tfinTo=info[j].to+1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// ó«Xy[Xª Á½êA«ßé¾¯«Þ\n\t\t\t\t\telse{\n\t\t\t\t\t\tint to=min(leftWritingSize,info[j].from-prvPlace);\n\t\t\t\t\t\tleftWritingSize-=to;\n\t\t\t\t\t\twriteInfo wi;\n\t\t\t\t\t\twi.discripter=discripter;\n\t\t\t\t\t\twi.from=prvPlace;\n\t\t\t\t\t\twi.to=prvPlace+to-1;\n\t\t\t\t\t\t//info.push_back(wi);\n\t\t\t\t\t\tinfo.insert(info.begin()+j,wi);\n\t\t\t\t\t\tif(leftWritingSize==0)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfinTo=info[j].to+1;\n\t\t\t\t\t\tprvPlace=info[j].to+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(leftWritingSize>0){\n\t\t\t\t\twriteInfo wi;\n\t\t\t\t\twi.discripter=discripter;\n\t\t\t\t\twi.from=finTo;\n\t\t\t\t\twi.to=finTo+leftWritingSize-1;\n\t\t\t\t\tinfo.push_back(wi);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(order=='R'){\n\t\t\t\tint secter;\n\t\t\t\tcin>>secter;\n\t\t\t\tbool isFind=false;\n\t\t\t\t// from-toÌÔÉsecterª é©²×é\n\t\t\t\tfor(int j = 0; j < info.size(); j++){\n\t\t\t\t\tif(info[j].from<=secter&&info[j].to>=secter){\n\t\t\t\t\t\tcout<<info[j].discripter<<endl;\n\t\t\t\t\t\tisFind=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!isFind)\n\t\t\t\t\tcout<<-1<<endl;\n\t\t\t}\n\t\t\telse if(order=='D'){\n\t\t\t\tint discrepter;\n\t\t\t\tcin>>discrepter;\n\t\t\t\t// fBXNv^ªêv·éàÌð·×Äí\n\t\t\t\tfor(int j = info.size()-1; j>=0; j--){\n\t\t\t\t\tif(info[j].discripter==discrepter){\n\t\t\t\t\t\tinfo.erase(info.begin()+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define F first\n#define S second\n#define MAX 10010\n#define p2(a,b,c) P2(P(a,b),c)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2; // P2(P(st-index,ed-index),識別子)\nP2 file[MAX];\n\nvoid print()\n{\n  cout << \"print\" << endl;\n  for(int i=0;file[i] != p2(-2,-2,-2);i++)\n    cout << file[i].F.F << \" \" << file[i].F.S << \" \" << file[i].S << endl;\n  cout << endl; \n}\n\nint main()\n{\n  int N;\n  while(cin >> N,N)\n    {\n      char c;\n      int l,s;\n      file[0] = p2(-2,-2,-2);//most-right\n      for(int i=0;i<N;i++)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')\n\t    {\n\t      cin >> l >> s;\n\t      int index = 0;\n\t      for(int j=0;s;j++)\n\t\t{\n\t\t  if(file[j] == p2(-2,-2,-2))\n\t\t    {\n\t\t      file[j] = p2(index,index+s,l);//[index,index+s)\n\t\t      file[j+1] = p2(-2,-2,-2);\n\t\t      break;\n\t\t    }\n\t\t  else if(file[j] == p2(-1,-1,-1))\n\t\t    {\n\t\t      \n\t\t      if(file[j+1].first.first-index >= s)\n\t\t\tfile[j] = p2(index,index+s,l),s = 0;\n\t\t      else \n\t\t\tfile[j] = p2(index,file[j+1].F.F,l),s -= (file[j+1].F.F-index),index = file[j+1].F.F;\n\t\t\t  \n\t\t    }\t\t  \n\t\t  else if(file[j].first.first == index)\n\t\t    index = file[j].first.second;   \n\t\t  \n\t    \n\t\t}\n\t      \n\t    }\n\t  else if(c == 'D')\n\t    {\n\t      int ident;\n\t      cin >> ident;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].S == ident)\n\t\t  file[j] = file[j+1]==p2(-2,-2,-2)?p2(-2,-2,-2):p2(-1,-1,-1);\n\t\t  \n\t    }\n\t  else if(c == 'R') \n\t    {\n\t      int p;\n\t      cin >> p;\n\t      bool f = false;\n\t      for(int j=0;file[j] != p2(-2,-2,-2);j++)\n\t\tif(file[j].F.F <= p && p < file[j].F.S)\n\t\t  {\n\t\t    f = true;\n\t\t    cout << file[j].S << endl;\n\t\t    goto next;\n\t\t  } \n\t    next:;\n\t      if(!f)\n\t\tcout << -1 << endl;\n\t    }\n\t  else\n\t    assert(false);\n\t  //print();\n\t}\n      cout << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct Data{\n  int start;\n  int end;\n  int data;\n  Data *next;\n  Data *prev;\n  Data *eqnext;\n};\n\nData buff[100000];\nint  _pos;\n\nData *alloc(){\n  return &buff[_pos++];\n}\n\nData *write(Data *d, int size, int data){\n  if(d == NULL) return NULL;\n  if(d->data != -1){\n    return write(d->next, size, data);\n  }else{\n    int sz = d->end - d->start + 1;\n    if(sz > size){\n      //puts(\"test1\");\n      Data *next = alloc();\n      next->end   = d->end;\n      d->end      = d->start + size - 1;\n      next->start = d->end + 1;\n      next->data  = -1;\n      next->prev  = d;\n      next->next  = d->next;\n      next->eqnext= NULL;\n      d->next     = next;\n      d->data     = data;\n      d->eqnext   = NULL;\n      return d;\n    }else if(sz == size){\n      d->data = data;\n      d->eqnext = NULL;\n      return d;\n    }else{\n      //puts(\"test3\");\n      d->data   = data;\n      d->eqnext = write(d->next, size-sz, data);\n      return d;\n    }\n  }\n}\n\nData *merge(Data *d1, Data *d2){\n  if(d1 == NULL || d2 == NULL) return d2;\n  if(d1->data != d2->data) return d2;\n  d1->end  = d2->end;\n  d1->next = d2->next;\n  return d1;\n}\n\nvoid del(Data *d){\n  if(d == NULL) return;\n  d->data = -1;\n  del(d->eqnext);\n  merge(d->prev, d);\n  merge(d->next, d);\n}\n\nint ref(Data *d, int pos){\n  while(d != NULL){\n    if(d->start <= pos && pos <= d->end){\n      return d->data;\n    }\n    d = d->next;\n  }\n  return 0;\n}\n\nvoid print(Data *d){\n  while(d != NULL){\n    printf(\"[%d,%d]: %d\\n\",d->start,d->end,d->data);\n    d = d->next;\n  }\n}\n\nint main(){\n  int n;\n  int cc = 0;\n  while(cin>>n, n){\n    _pos = 0;\n    Data *d = alloc();\n    map<int,Data*> lst;\n    d->start = 0;\n    d->end   = INT_MAX - 1;\n    d->prev  = NULL;\n    d->next  = NULL;\n    d->data  = -1;\n\n    if(cc++ != 0) cout << endl;\n\n    while(n --> 0){\n      char c;\n      cin>>c;\n      if(c == 'W'){\n        int l,data;\n        cin>>data>>l;\n        lst[data] = write(d, l, data);\n      }else if(c == 'R'){\n        int pos;\n        cin>>pos;\n        cout << ref(d, pos) << endl;\n      }else{\n        int data;\n        cin>>data;\n        del(lst[data]);\n      }\n\n      //print(d);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1<<60\n\ntypedef pair<long long int, long long int> PII;\ntypedef vector<PII> VPII;\n\nint main() {\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tmap<long long int, VPII> M;\n\t\t//priority_queue<PII, VPII, greater<PII>>que;\n\t\t//que.push( make_pair( 0, 1LL << INF ) );\n\t\tVPII vque;\n\t\tvque.push_back( make_pair( 0, 1LL << INF ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif( c == 'W' ) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\twhile( b ) {\n\t\t\t\t\t//PII now = que.top(); que.pop();\n\t\t\t\t\tPII vnow = *vque.rbegin(); vque.pop_back();\n\t\t\t\t\tif( b < vnow.second - vnow.first ) {\n\t\t\t\t\t\tvque.push_back( make_pair( vnow.first + b, vnow.second ) );\n\t\t\t\t\t\tM[a].push_back( make_pair( vnow.first, vnow.first + b - 1 ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else if( b == vnow.second - vnow.first ) {\n\t\t\t\t\t\tM[a].push_back( make_pair( vnow.first, vnow.second ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM[a].push_back( make_pair( vnow.first, vnow.second ) );\n\t\t\t\t\t\tb -= vnow.second - vnow.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if( c == 'D' ) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor( auto x = M[a].rbegin(); x < M[a].rend(); x++ ) {\n\t\t\t\t\t//que.push( x );\n\t\t\t\t\tvque.push_back( *x );\n\t\t\t\t}\n\t\t\t\tM[a].clear();\n\t\t\t} else {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tbool f = 0;\n\t\t\t\tfor( auto x : M ) {\n\t\t\t\t\tfor( auto y : x.second ) {\n\t\t\t\t\t\tif( y.first <= a &&a <= y.second ) {\n\t\t\t\t\t\t\tcout << x.first << endl;\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( f ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !f ) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 区間を set で管理するやつ\n// 閉区間 [l, r] を扱うことに注意\ntemplate <typename numericType>\nstruct IntervalSet : set< pair<numericType, numericType> > {\n    // x を含む閉区間 [l, r] を取得\n    // イテレータを返す\n    auto get(numericType x) {\n        // x より始点が大きい区間の中で最小のもの\n        auto itr = this->upper_bound(make_pair(x+1, x));\n        if(itr == this->begin() or (--itr)->second < x) return this->end();\n        return itr;\n    }\n\n    // [l, r] と overlap する区間の集合を取得\n    // vector を返す\n    vector< pair<numericType, numericType> > get(numericType l, numericType r) {\n        auto itr = this->upper_bound(make_pair(l, l));\n        if(itr != this->begin()) itr--;\n\n        vector< pair<numericType, numericType> > res;\n        for(; itr != this->end(); itr++) {\n            numericType il, ir; tie(il, ir) = *itr;\n            if(r < il) break; // 対称区間に対して右に飛び出た\n            // 対称区間に対して左に飛び出るか、含まれているかしかない\n            if(ir >= l) res.push_back(make_pair(il, ir));\n        }\n        return res;\n    }\n    \n    void insert(numericType l, numericType r) {\n        auto vec = this->get(l, r);\n        numericType il = l, ir = r;\n        for(auto e : vec) {\n            this->erase(e);\n            il = min(il, e.first);\n            ir = max(ir, e.second);\n        }\n        this->emplace(il, ir);\n    }\n    \n    void remove(numericType l, numericType r) {\n        auto vec = this->get(l, r);\n        for(auto e : vec) this->erase(e);\n    }\n\n    // p と q は同じ区間上にあるか？\n    bool same(numericType p, numericType q) {\n        auto itr = get(p);\n        return itr != this->end() and itr->first <= q and q <= itr.second;\n    }\n\n    void dump() {\n        for(auto e : *this) {\n            numericType l, r; tie(l, r) = e;\n            fprintf(stderr, \"# debug: [%g, %g]\\n\", l, r);\n        }\n    }\n};\n\nsigned main() {\n    int N;\n    while(cin >> N, N) {\n        map< int, IntervalSet<int> > mp;\n        mp[-1].insert(0, INF);\n\n        for(int i=0; i<N; i++) {\n            char com; cin >> com;\n            if(com == 'W') {\n                int id, len; cin >> id >> len;\n                auto &S = mp[-1];\n\n                vector< pair<int, int> > rem_list, ins_list;\n                for(auto e : S) {\n                    int l, r; tie(l, r) = e;\n                    int lim = r - l + 1;\n\n                    int use = min(len, lim);\n                    if(use == lim) {\n                        mp[id].insert(l, r);\n                        rem_list.emplace_back(l, r);\n                    }\n                    else {\n                        mp[id].insert(l, l + use - 1);\n                        rem_list.emplace_back(l, r);\n                        ins_list.emplace_back(l + use, r);\n                    }\n                    len -= use;\n                    if(len == 0) break;\n                }\n\n                for(auto e : rem_list) {\n                    int l, r; tie(l, r) = e;\n                    // fprintf(stderr, \"# remove: [%lld, %lld]\\n\", l, r);\n                    mp[-1].remove(l, r);\n                }\n                for(auto e : ins_list) {\n                    int l, r; tie(l, r) = e;\n                    // fprintf(stderr, \"# insert: [%lld, %lld]\\n\", l, r);\n                    mp[-1].insert(l, r);\n                }\n            }\n            if(com == 'R') {\n                int pos; cin >> pos;\n\n                // 破滅？\n                int ans = -1;\n                for(auto e : mp) {\n                    if(e.first == -1) continue;\n                    auto &S = e.second;\n                    // fprintf(stderr, \"e.first = %lld\\n\", e.first);\n                    if(S.get(pos) != S.end()) {\n                        ans = e.first;\n                        break;\n                    }\n                }\n                cout << ans << endl;\n            }\n            if(com == 'D') {\n                int id; cin >> id;\n                if(mp.count(id)) {\n                    auto &S = mp[id];\n                    for(auto itvl : S) {\n                        int l, r; tie(l, r) = itvl;\n                        mp[-1].insert(l, r);\n                    }\n                    mp[id].clear();\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n   \nusing namespace std;\n \nconst int LIMIT = 1000000000;\n \nstruct Data {\n  int id;\n  int st;\n  int num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n   \nint N;\nvector<Data> storage;\n  \nvoid dump() {\n  cout << \"-----------------------------\" << endl;\n  for(int i=0; i<(int)storage.size(); i++) {\n    cout << \"storage[\"<<i<<\"]:\" << endl;\n    cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n  }\n  cout << \"-----------------------------\" << endl;\n}\n \nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    int into = -1;\n    //if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<(int)storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st;\n        into = i;\n        break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n       \n      if(st > LIMIT) return;\n    }\n    if(num == -1) {\n      // insert data back\n      num = remain;\n      if(st+num > LIMIT) {\n        num = LIMIT - (st+num);\n\tremain = num;\n      }\n    }\n    if(into == -1) into = storage.size();\n    storage.insert(storage.begin()+into, Data(id, st, num));\n    remain -= num;\n  }\n}\n \nclass EqualsID {\nprivate:\n  int id;\npublic:\n  EqualsID(int id) : id(id) {}\n  bool operator() (const Data &d) { return d.id == id; }\n};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n \nint refer(int sect) {\n  for(int i=0; i<(int)storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n   \nint main() {\n  while(scanf(\"%d\", &N) && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch; //scanf(\"%c\", &ch);\n      if(ch=='W') {\n        int id, num; scanf(\"%d%d\", &id, &num);\n        write(id, num);\n        //dump();\n      }\n      if(ch=='D') {\n        int id; scanf(\"%d\", &id);\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; scanf(\"%d\", &sect);\n        printf(\"%d\\n\", refer(sect));\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Block{\npublic:\n    int label, start, size;\n    Block(int label, int start, int size): label(label), start(start), size(size){};\n};\n\nint N;\n\nvoid write(vector<Block> &blocks, int label, int size){\n    for(int i=0; i<blocks.size(); i++){\n        if(blocks[i].label == -1){\n            if(size == blocks[i].size){\n                blocks[i].label = label;\n                break;\n                \n            }else if(size < blocks[i].size){\n                int start = blocks[i].start;\n                int lest_size = blocks[i].size - size;\n                auto it = blocks.erase(blocks.begin() + i);\n                it = blocks.insert(it, Block(-1, start+size, lest_size));\n                blocks.insert(it, Block(label, start, size));\n                break;\n                \n            }else{\n                blocks[i].label = label;\n                size -= blocks[i].size;\n            }\n        }\n    }\n}\n\nvoid del(vector<Block> &blocks, int label){\n    //?????????????????£????????????????????????\n    for(int i=0; i<blocks.size(); i++)\n        if(blocks[i].label == label)\n            blocks[i].label = -1;\n    \n}\n\nvoid read(vector<Block> &blocks, int pointer){\n    for(int i=0; i<blocks.size(); i++)\n        if(blocks[i].start <= pointer && pointer < blocks[i].start + blocks[i].size)\n            cout << blocks[i].label << endl;\n}\n\nvoid solve(){\n    vector<Block> blocks;\n    blocks.push_back(Block(-1, 0, INF));\n    \n    char c;\n    while(N--){\n        cin >> c;\n        if(c == 'W'){\n            int label, size;\n            cin >> label >> size;\n            write(blocks, label, size);\n        }\n        if(c == 'D'){\n            int label; cin >> label;\n            del(blocks, label);\n        }\n        if(c == 'R'){\n            int pointer; cin >> pointer;\n            read(blocks, pointer);\n        }\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(10);\n    \n    while(cin>>N, N){\n        solve();\n        cout << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(c,c+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nconst int INF = 1000000010;\n\nstruct Segment{\n    int pos, size, id;\n    Segment(int pos, int size, int id): pos(pos), size(size), id(id) {}\n    bool operator<(const Segment& right ) const {\n        return pos == right.pos ? size < right.size : pos < right.pos;\n    }\n};\n\nint main(){\n    while(true){\n        int N;\n        cin >> N;\n        if(N == 0) break;\n\n        set<Segment> empty;\n        empty.emplace(1, INF, -1);\n        set<Segment> occupied;\n        \n        for(int i=0;i<N;i++){\n            char cmd;\n            cin >> cmd;\n            if(cmd == 'W'){\n                int id, size;\n                cin >> id >> size;\n                while(true){\n                    Segment u = *empty.begin();\n                    empty.erase(empty.begin());\n                    if(u.size < size){\n                        size -= u.size;\n                        u.id = id;\n                        occupied.insert(u);\n                    }else{\n                        empty.emplace(u.pos + size, u.size - size, -1);                    \n                        occupied.emplace(u.pos, size, id);\n                        break;\n                    }\n                }\n            }else if(cmd == 'D'){\n                int id;\n                cin >> id;\n                for(auto it=occupied.begin();it!=occupied.end();){\n                    if(it->id == id){\n                        empty.insert(*it);\n                        occupied.erase(it++);\n                    }else{\n                        it++;\n                    }\n                }\n            }else{\n                int pos;\n                cin >> pos;\n                auto it = occupied.lower_bound(Segment(pos, INF, INF));\n                bool found = false;\n                if(it != occupied.begin()){\n                    auto prev = next(it, -1);\n                    if(prev->pos <= pos && pos < prev->pos + prev->size){\n                        cout << prev->id << endl;\n                        found = true;\n                    }\n                }\n                if(!found){\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main(){\n\twhile(1){\n\t\tstd::vector<int>v(1,-1);\n\t\tint a;\n\t\tstd::cin>>a;\n\t\tif(a==0)break;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tchar x;\n\t\t\tint p,q;\n\t\t\tstd::cin>>x;\n\t\t\tif(x=='W'){\n\t\t\t\tstd::cin>>p>>q;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==-1)v[j]=p,q--;\n\t\t\t\t\tif(q==0)break;\n\t\t\t\t\twhile(j==v.size()-1&&q!=0)v.push_back(p),q--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x=='D'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==p)v[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(x=='R'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tif(p-1>v.size())std::cout<<\"-1\"<<std::endl;\n\t\t\t\telse std::cout<<v[p-1]<<std::endl;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\ntypedef struct S\n{\n\tint s,e,f;//(s e]\n\tbool operator <(const S &a)const{ return s<a.s;};\n}S;\nint N;\nvector<S>F;\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tF.clear();\n\t\tS t={0,1000000001,-1};\n\t\tF.push_back(t);\n\t\tfor(;N--;)\n\t\t{\n\t\t\tint a,b;\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W')\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\\n\",&a,&b);\n\t\t\t\tfor(int i=0;b>0;i++)\n\t\t\t\t{\n\t\t\t\t\tif(F[i].f==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(b>F[i].e-F[i].s)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tF[i].f=a;\n\t\t\t\t\t\t\tb-=F[i].e-F[i].s;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tS ins={F[i].s,F[i].s+b,a};\n\t\t\t\t\t\t\tF[i].s=F[i].s+b;\n\t\t\t\t\t\t\tF.push_back(ins);\n\t\t\t\t\t\t\tb=0;\n\t\t\t\t\t\t\tsort(F.begin(),F.end());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(c=='R')\n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&a);\n\t\t\t\tfor(int i=0;i<F.size();i++)\n\t\t\t\t\tif(F[i].s<=a&&a<F[i].e)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d\\n\",F[i].f);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&a);\n\t\t\t\tfor(int i=0;i<F.size();i++)\n\t\t\t\t\tif(F[i].f==a)\n\t\t\t\t\t\tF[i].f=-1;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nlist<pair<int, int> > L;\n\nvoid Write(){\n\n    int l, s; cin >> l >> s;\n    for(auto itr = L.begin();;itr++){\n        if(itr->first != -1) continue;\n\n        if(itr->second <= s){\n            itr->first = l;\n            s -= itr->second;\n            if(s == 0) return;\n        }else{\n            itr->second -= s;\n            itr = L.insert(itr, {l, s});\n            return;\n        }\n    }\n\n}\n\nvoid Read(){\n    int p; cin >> p;\n    p++;\n    for(auto itr : L){\n        p -= itr.second;\n        if(p <= 0){\n            cout << itr.first << endl;\n            break;\n        }\n    }\n\n\n\n}\n\nvoid Delete(){\n\n    int l; cin >> l;\n    for(auto &itr : L){\n        if(itr.first == l){\n            itr.first = -1;\n        }\n    }\n\n}\n\n\nsigned main(){\n\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        L.clear();\n        L.push_back({-1, 10000000000});\n\n        for(int i = 0; i < n; i++){\n            char op; cin >> op;\n            if(op == 'W') Write();\n            else if(op == 'R') Read();\n            else Delete();\n                \n            //for(auto x : L) cerr << \"(\" << x.first << \", \" << x.second << \") \";\n            //cerr << endl;\n\n\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {\n  // location, value, numbers\n  int l, v, n;\n  bool operator<(const State& r) const {\n    return l < r.l;\n  }\n};\n\nint main() {\n  int N;\n  while (scanf(\"%d\", &N), N) {\n    vector<State> data;\n    int ub = 0;\n    rep(i,N) {\n      char op;\n      int lop, rop;\n      scanf(\" %c%d\", &op, &lop);\n\n      // rep(i,data.size()) {\n      //   printf(\"{%d,%d,%d}\", data[i].l, data[i].v, data[i].n);\n      // } puts(\"\");\n      \n      if (op == 'R') {\n        // location について二分探索する\n        int l = -1, r = data.size();\n        if (r == 0) {\n          printf(\"%d\\n\", -1); continue;\n        }\n        while (r - l > 1) {\n          int m = (l+r)/2;\n          if (data[m].l + data[m].n - 1 >= lop) {\n            r = m;\n          } else {\n            l = m;\n          }\n        }\n        printf(\"%d\\n\", (r >= data.size()) ? -1 : data[r].v);\n      } else if (op == 'W') {\n        scanf(\"%d\", &rop);\n        for (int i = 0; i < data.size() && rop > 0; ++i) {\n          if (data[i].v != -1) continue;\n          State& s = data[i];\n          // 空き領域と長さがちょうど\n          if (s.n == rop) {\n            s.v = lop;\n            rop = 0;\n          }\n          // 空き領域の方が大きい\n          else if (s.n > rop) {\n            const State cs = s;\n            // 現在の領域を上書き\n            s.v = lop;\n            s.n = rop;\n            // 圧縮された空き領域を追加\n            inserter(data, data.begin() + i + 1) = (State){cs.l + rop, -1, cs.n - rop};\n            rop = 0;\n          }\n          // 空き領域が足りない場合\n          else if (s.n < rop) {\n            s.v = lop;\n            rop -= s.n;\n          }\n        }\n        // 末尾に追加する必要がある場合\n        if (rop > 0) {\n          data.push_back((State){ub, lop, rop});\n          ub += rop;\n        }\n        // 最後にソート\n      } else {\n        rep(i,data.size()) {\n          if (data[i].v == lop)\n            data[i].v = -1;\n        }\n      }\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef int ll;\ntypedef pair<int,int>P;\n#define MX 1000000001\nint N,d1[100],d2[100],cnt;\nchar c[100];\n \nstruct BIT\n{\n\tvector<ll>T;\n\tint n;\n\tBIT( int n):n(n+1),T(n+1,0){}\n\tll _sum( int p){ll res=0;for (;p>0;p-=p&-p)res+=T[p];return res;}\n\tll sum( int r,int l){return _sum(l)-_sum(r);};\n\tvoid add(int i,int x){ for(;i<n;i+=i&-i)T[i]+=x;}\n};\n\n\nint main()\n{\n\tfor(;scanf(\"%d\\n\",&N),N;puts(\"\"))\n\t{\n\t\tvector<P>T;\n\t\tT.push_back(make_pair(-10000,0));\n\t\tmap<int,vector<int> >D;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%c\",&c[i]);\n\t\t\tif(c[i]=='W')scanf(\"%d%d\\n\",&d1[i],&d2[i]);\n\t\t\telse\n\t\t\t{\n\t\t\t\tscanf(\"%d\\n\",&d1[i]);\n\t\t\t\tif(c[i]=='R')\n\t\t\t\t\tT.push_back(make_pair(d1[i],-1));\n\t\t\t}\n\t\t}\n\t\tsort(T.begin(),T.end());\n\t\tBIT SEQ(T.size());\n \n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tif(c[i]=='R')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<T.size();j++)\n\t\t\t\t\tif(T[j].first==d1[i])\n\t\t\t\t\t\tprintf(\"%d\\n\",T[j].second);\n\t\t\t}\n\t\t\telse if(c[i]=='D')\n\t\t\t{\n\t\t\t\tfor(int j=1;j<D[d1[i]].size();j++)\n\t\t\t\t\tSEQ.add(j,-D[d1[i]][j]);\n\t\t\t\tfor(int j=0;j<T.size();j++)\n\t\t\t\t\tif(T[j].second==d1[i])\n\t\t\t\t\t\tT[j].second=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[d1[i]].push_back(0);\n\t\t\t\tfor(int j=1,s=d2[i];j<T.size();j++)\n\t\t\t\t{\n\t\t\t\t\tint ins=0,emp=T[j].first-SEQ._sum(j)+1;\n\t\t\t\t\tif(emp>0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(s>=emp)T[j].second=d1[i];\n\t\t\t\t\t\tins=min(s,emp);\n\t\t\t\t\t\ts-=min(s,emp);\n\t\t\t\t\t}\n\t\t\t\t\tSEQ.add(j,ins);\n\t\t\t\t\tD[d1[i]].push_back(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<pair<int,int>,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\nint N;\ninline int len(P x){\n\treturn x.sec-x.fi+1;\n}\npriority_queue<P,vector<P>,greater<P> > ep;\nset<T> s;\nvector<P> vec[10010];\nint idnum;\nmap<int,int> id;\nint rev[10010];\nvoid debug(){\n\tvector<P> tmp;\n\twhile(!ep.empty()){\n\t\ttmp.pb(ep.top());\n\t\tep.pop();\n\t}\n\tfor(int i=0;i<tmp.size();i++){\n\t\tprintf(\"[%d %d]\\n\",tmp[i].fi,tmp[i].sec);\n\t\tep.push(tmp[i]);\n\t}\n\tset<T>::iterator it;\n\tfor(it=s.begin();it!=s.end();++it){\n\t\tprintf(\"%d %d %d\\n\",(it->fi).sec,(it->fi).fi,it->sec);\n\t}\n\treturn;\n}\nint solve(){\n\twhile(!ep.empty())ep.pop();\n\ts.clear();\n\tfor(int i=0;i<10010;i++)vec[i].clear();\n\tidnum=0;\n\tid.clear();\n\tscanf(\"%d\",&N);\n\tif(N==0)return 1;\n\tep.push(P(0,1000000100));\n\tfor(int i=0;i<N;i++){\n\t\tchar type;\n\t\tscanf(\" %c\",&type);\n\t\tif(type=='W'){\n\t\t\tint l,S;\n\t\t\tscanf(\"%d %d\",&l,&S);\n\t\t\tid[l]=idnum;\n\t\t\trev[idnum]=l;\n\t\t\tl = idnum++;\n\t\t\twhile(S>0){\n\t\t\t\tP nxt = ep.top();\n\t\t\t\tep.pop();\n\t\t\t\tif(len(nxt)>S){\n\t\t\t\t\tvec[l].pb(P(nxt.fi,nxt.fi+S-1));\n\t\t\t\t\ts.insert(T(P(nxt.fi+S-1,nxt.fi),rev[l])); // s?????????????????¢\n\t\t\t\t\tep.push(P(nxt.fi+S,nxt.sec));\n\t\t\t\t\tS=0;\n\t\t\t\t}else{\n\t\t\t\t\tvec[l].pb(nxt);\n\t\t\t\t\ts.insert(T(P(nxt.sec,nxt.fi),rev[l])); \n\t\t\t\t\tS -= len(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug();\n\t\t}else if(type=='D'){\n\t\t\tint l;\n\t\t\tscanf(\"%d\",&l);\n\t\t\tl = id[l];\n\t\t\tfor(int i=0;i<vec[l].size();i++){\n\t\t\t\tP tmp = vec[l][i];\n\t\t\t\tep.push(tmp);\n\t\t\t\ts.erase(T(P(tmp.sec,tmp.fi),rev[l]));\n\t\t\t}\n\t\t\tdebug();\n\t\t}else{\n\t\t\tint p;\n\t\t\tscanf(\"%d\",&p);\n\t\t\tset<T>::iterator it = s.lower_bound(T(P(p,-1),-1));\n\t\t\tif(it==s.end()){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t}else{\n\t\t\t\tint L=(it->fi).sec,R=(it->fi).fi,ID=it->sec;\n\t\t\t\tif(L<=p&&p<=R)printf(\"%d\\n\",ID);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(!solve()){\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define foreach(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define mp make_pair\nusing namespace std;\ntypedef map<pair<int,int>,int> S;\nint main(){\n\tint n,t1,t2; char c;\n\twhile(cin>>n,n){\n\t\tS s;\n\t\trep(i,n){\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tcin>>t1>>t2;\n\t\t\t\tint p=0,q;\n\t\t\t\tif(s.empty())s.insert(mp(mp(0,t2),t1)),t2=0;\n\t\t\t\telse{\n\t\t\t\t\tforeach(j,s){\n\t\t\t\t\t\tif(j->first.first>p){\n\t\t\t\t\t\t\tq=min(p+t2,j->first.first);\n\t\t\t\t\t\t\ts.insert(mp(mp(p,q),t1));\n\t\t\t\t\t\t\tt2-=q-p; p=q;\n\t\t\t\t\t\t\tj--;\n\t\t\t\t\t\t}else p=j->first.second;\n\t\t\t\t\t\tif(t2==0)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(t2>0)s.insert(mp(mp(p,p+t2),t1));\n\t\t\t\t}\n\t\t\t}else if(c=='D'){\n\t\t\t\tcin>>t1;\n\t\t\t\tforeach(j,s)if(j->second==t1)s.erase(j);\n\t\t\t}else{\n\t\t\t\tcin>>t1;\n\t\t\t\tforeach(j,s)if(j->first.first<=t1&&t1<j->first.second){\n\t\t\t\t\tcout<<j->second<<endl; goto END;\n\t\t\t\t}\n\t\t\t\tcout<<-1<<endl; END:;\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> D;\ntypedef map<int,D> M;\ntypedef stack<P> S;\nint main(){\n  int n,l,s,x,e;\n  while(cin>>n,n){\n    char c;\n    M m;\n    S em;\n    e=0;\n    while(n--){\n      D d;\n      P p;\n      cin >> c;\n      if(c=='W'){\n\tcin >> l >> s;\n\twhile(!em.empty()&&s>0){\n\t  p=em.top();em.pop();\n\t  x=p.second-p.first;\n\t  if(x<=s){\n\t    s-=x;\n\t    m[l].push_back(p);\n\t  }else{\n\t    p.first+=s;\n\t    em.push(p);\n\t    m[l].push_back(p);\n\t    s=0;\n\t  }\n\t}\n\tif(s>0){\n\t  p.first=e;p.second=p.first+s;\n\t  m[l].push_back(p);\n\t  e=p.second+1;\n\t}\n      }\n      if(c=='D'){\n\tcin>>l;\n\ts=m[l].size()-1;\n\twhile(!m[l].empty()){\n\t  p=m[l][s];\n\t  m[l].pop_back();s--;\n\t  em.push(p);\n\t}\n      }\n      if(c=='R'){\n\tcin >> x;\n\tbool f=true;\n\tfor(M::iterator it=m.begin();it!=m.end();++it){\n\t  l=it->first;d=it->second;\n\t  for(int i=0;i<d.size();i++){\n\t    p=d[i];\n\t    if(p.first<=x&&x<=p.second){\n\t      cout << l << endl;\n\t      f=false;\n\t      break;\n\t    }\n\t  }\n\t  if(!f) break;\n\t}\n\tif(f) cout << -1 << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 1000000000\n\n\nstruct Node{\n\tint left,right,file_id;\n\tNode* prev;\n\tNode* next;\n};\n\nclass List{\npublic:\n\tList(){\n\t\tmotherNode = new Node();\n\t\tmotherNode->file_id = -1;\n\t\tmotherNode->prev = new Node();\n\t\tmotherNode->next = motherNode->prev;\n\n\t\tmotherNode->next->left = 0;\n\t\tmotherNode->next->right = NUM;\n\t\tmotherNode->next->file_id = -1;\n\n\t\tmotherNode->next->next = motherNode;\n\t\tmotherNode->next->prev = motherNode;\n\n\t};\n\tvoid writeFile(int id,int size){\n\n\t\tint rest = size,node_size;\n\n\t\tNode* tmpNode = motherNode->next;\n\n\t\twhile(rest > 0 && tmpNode != motherNode){\n\t\t\tif(tmpNode->file_id == -1){\n\t\t\t\tnode_size = tmpNode->right-tmpNode->left+1;\n\t\t\t\tif(node_size > rest){\n\n\t\t\t\t\tNode* tmp_next = tmpNode->next;\n\t\t\t\t\ttmpNode->next = new Node;\n\n\t\t\t\t\ttmpNode->next->right = tmpNode->right;\n\t\t\t\t\ttmpNode->next->left = tmpNode->left+rest;\n\t\t\t\t\ttmpNode->next->file_id = -1;\n\t\t\t\t\ttmpNode->next->next = tmp_next;\n\t\t\t\t\ttmpNode->next->prev = tmpNode;\n\n\t\t\t\t\ttmpNode->right = tmpNode->left+rest-1;\n\t\t\t\t\ttmpNode->file_id = id;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\ttmpNode->file_id = id;\n\t\t\t\t\trest -= node_size;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t};\n\n\tvoid delete_File(int id){\n\t\tNode* tmpNode = motherNode->next;\n\t\tif(tmpNode->file_id == id){\n\t\t\ttmpNode->file_id = -1;\n\t\t}\n\t\ttmpNode = tmpNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tif(tmpNode->file_id == id){\n\t\t\t\ttmpNode->file_id = -1;\n\t\t\t}\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t};\n\n\tint search_id(int loc){\n\t\tNode* tmpNode = motherNode->next;\n\t\tif(tmpNode->left <= loc && tmpNode->right >= loc){\n\t\t\treturn tmpNode->file_id;\n\t\t}\n\t\ttmpNode = tmpNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tif(tmpNode->left <= loc && tmpNode->right >= loc){\n\t\t\t\treturn tmpNode->file_id;\n\t\t\t}\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t\treturn -1;\n\t}\n\nprivate:\n\tNode* motherNode;\n};\n\nint N;\n\nvoid func(){\n\n\tList list;\n\n\tchar command[2];\n\tint id,size,loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%s\",command);\n\n\t\tswitch(command[0]){\n\t\tcase 'W':\n\t\t\tscanf(\"%d %d\",&id,&size);\n\t\t\tlist.writeFile(id,size);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tscanf(\"%d\",&id);\n\t\t\tlist.delete_File(id);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tscanf(\"%d\",&loc);\n\t\t\tprintf(\"%d\\n\",list.search_id(loc));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 1<<60\n\ntypedef pair<long long int, long long int> PII;\ntypedef vector<PII> VPII;\n\nint main() {\n\tlong long int N;\n\twhile( cin >> N, N ) {\n\t\tmap<long long int, VPII> M;\n\t\tpriority_queue<PII, VPII, greater<PII>>que;\n\t\tque.push( make_pair( 0, 1LL << INF ) );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif( c == 'W' ) {\n\t\t\t\tint a, b;\n\t\t\t\tcin >> a >> b;\n\t\t\t\twhile( b ) {\n\t\t\t\t\tPII now = que.top(); que.pop();\n\t\t\t\t\tif( b < now.second - now.first ) {\n\t\t\t\t\t\tque.push( make_pair( now.first + b, now.second ) );\n\t\t\t\t\t\tM[a].push_back( make_pair( now.first, now.first + b - 1 ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else if( b == now.second - now.first ) {\n\t\t\t\t\t\tM[a].push_back( make_pair( now.first, now.second ) );\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tM[a].push_back( make_pair( now.first, now.second ) );\n\t\t\t\t\t\tb -= now.second - now.first + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if( c == 'D' ) {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tfor( auto x : M[a] ) {\n\t\t\t\t\tque.push( x );\n\t\t\t\t}\n\t\t\t\tM[a].clear();\n\t\t\t} else {\n\t\t\t\tint a;\n\t\t\t\tcin >> a;\n\t\t\t\tbool f = 0;\n\t\t\t\tfor( auto x : M ) {\n\t\t\t\t\tfor( auto y : x.second ) {\n\t\t\t\t\t\tif( y.first <= a &&a <= y.second ) {\n\t\t\t\t\t\t\tcout << x.first << endl;\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( f ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !f ) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n      prev=pres;\n      pres=pres->next;\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp-1<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=sinki->start+s-1;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    }\n  }\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  //cout<<\"read!\\n\";\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres,*tmp;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i){\n      tmp=pres;\n      prev->next=pres->next;\n      pres=prev->next;\n      //      cout<<\"debug\"<<tmp->start<<endl;\n      delete tmp;\n      continue;\n    }\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm* next;\n  if(begin==NULL) return;\n  next=begin->next;\n  delete begin;\n  reset(next);\n}\nvoid debug(newrm* begin){\n  while(begin!=NULL){\n    cout<<begin->start<<\" \"<<begin->end<<endl;\n    begin=begin->next;\n  }\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    \n    if(N==0) return 0;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      else if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      else if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      else if(com=='B')\n\tdebug(begin);\n    }\n    //  reset(begin);\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nifstream ifs(\"2152_input.txt\");\nofstream ofs(\"op.txt\");\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w; bool accessed = false;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            accessed = true;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            auto it = disk.begin();\n            while(it != disk.end()){\n                if(it->second == t) disk.erase(it++);\n                else it++;\n            }\n        }else{\n            auto lb = disk.lower_bound(pint(t, 0));\n            if(lb != disk.begin()) lb--;\n            pint temp = lb->first;\n            if(temp.first <= t && t <= temp.second && accessed)\n              cout << lb->second << endl;\n            else\n              cout << \"-1\" << endl;\n        }\n       \n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P, ll> PPI;\ntypedef pair<ll, P> IPP;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nset<PPI> mem;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tmem.clear();\n\t\tmem.insert(PPI(P(0,1e9+10),-1));\n\t\trep(i,n){\n\t\t\tchar op;\n\t\t\tcin>>op;\n\t\t\tif(op=='W'){\n\t\t\t\tll file,sizes;\n\t\t\t\tcin>>file>>sizes;\n\t\t\t\tbool end=false;\n\t\t\t\tvector<PPI> later,later2;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.se==-1){\n\t\t\t\t\t\tint idx=it.fi.fi,maxsize=it.fi.se;\n\t\t\t\t\t\tif(maxsize>sizes){\n\t\t\t\t\t\t\tlater.pb(PPI(P(idx,sizes),file));\n\t\t\t\t\t\t\tlater.pb(PPI(P(idx+sizes,maxsize-sizes),-1));\n\t\t\t\t\t\t\tend=true;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlater.pb(PPI(P(idx,maxsize),file));\n\t\t\t\t\t\t\tsizes-=maxsize;\n\t\t\t\t\t\t\tif(sizes==0)end=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlater2.pb(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(end)break;\n\t\t\t\t}\n\t\t\t\trep(i,later.size())mem.insert(later[i]);\n\t\t\t\trep(i,later2.size())mem.erase(later2[i]);\n\t\t\t}else if(op=='D'){\n\t\t\t\tll file;\n\t\t\t\tvector<PPI> later,later2;\n\t\t\t\tcin>>file;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.se==file){\n\t\t\t\t\t\tlater.pb(PPI(P(it.fi.fi,it.fi.se),-1));\n\t\t\t\t\t\tlater2.pb(it);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(i,later.size())mem.insert(later[i]);\n\t\t\t\trep(i,later2.size())mem.erase(later2[i]);\n\t\t\t}else if(op=='R'){\n\t\t\t\tll sec;\n\t\t\t\tcin>>sec;\n\t\t\t\teach(it,mem){\n\t\t\t\t\tif(it.fi.fi<=sec&&sec<it.fi.fi+it.fi.se){\n\t\t\t\t\t\tcout<<it.se<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nvector<P> vec;\n\nvoid Wri(){\n  int len = (int)vec.size(), l, S;\n\n  scanf(\"%d%d\" ,&l ,&S);\n\n  if(len == 0){\n    vec.push_back(P(l,S));\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }\n    }\n  }\n\n  if(S != 0){\n    vec.push_back(P(l,S));\n  }\n}\n\nvoid Del(){\n  int len = (int)vec.size(), l;\n\n  scanf(\"%d\" ,&l);\n  if(len == 0){\n    return;\n  }\n\n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n\nint Ref(){\n  int cnt = 0, len = (int)vec.size(), l, num = vec[0].first;\n\n  scanf(\"%d\" ,&l);\n\n  if(len == 0){\n    return -1;\n  }\n  \n  for(int i = 0 ; i < len ; i++){\n    if(cnt > l){\n      return num;\n    }\n    if(vec[i].first != -1){\n      cnt += vec[i].second;\n      num = vec[i].first;\n    }else{\n      cnt += vec[i].second;\n    }\n  }\n\n  if(cnt <= l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n\nint main(){\n  int N;\n  char ch;\n\n  while(scanf(\"%d\" ,&N), N){\n    for(int i = 0 ; i < N ; i++){\n      scanf(\"\\n%c\" ,&ch);\n\n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        printf(\"%d\\n\" ,Ref());\n        break;\n      }\n    }\n\n    printf(\"\\n\");   \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int> m;\n\tchar cmd[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*cmd=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*cmd=='W'){\n\t\t\tint cur=0;\n\t\t\tscanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m[make_pair(cur,cur+d-1)]=n;\n\t\t\t\tk-=d;\n\t\t\t\tif(k==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m[make_pair(cur,cur+k-1)]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing P = tuple<int, int, int>;\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        set<P> A, B;\n        A.emplace(-1, 0, MOD);\n        B.emplace(0, MOD, -1);\n        for (int i = 0; i < n; ++i) {\n            char c;\n            cin >> c;\n            if(c == 'W'){\n                int x, y;\n                cin >> x >> y;\n                auto it = A.begin();\n                while(y){\n                    int p, q, r; tie(p, q, r) = (*it);\n                    it = A.erase(it); B.erase(P(q, r, p));\n                    if(r-q >= y){\n                        A.emplace(x, q, q+y);\n                        B.emplace(q, q+y, x);\n                        A.emplace(p, q+y, r);\n                        B.emplace(q+y, r, p);\n                        y = 0;\n                    }else {\n                        y -= r-q;\n                        A.emplace(x, q, r);\n                        B.emplace(q, r, x);\n                    }\n                }\n            }else {\n                int x;\n                cin >> x;\n                if(c == 'D'){\n                    auto it = A.lower_bound(P(x, 0, 0));\n                    while(it != A.end() && get<0>(*it) == x) {\n                        int p, q, r; tie(p, q, r) = (*it);\n                        it = A.erase(it); B.erase(P(q, r, p));\n                        A.emplace(-1, q, r);\n                        B.emplace(q, r, -1);\n                    }\n                }else {\n                    auto it = B.lower_bound(P(x, -1, -1));\n\n                    int p, q, r; tie(p, q, r) = (*it);\n                    while(x < p || it == B.end()) {\n                        it--;\n                        tie(p, q, r) = (*it);\n                    }\n                    cout << get<2>(*it) << \"\\n\";\n                }\n            }\n        }\n        puts(\"\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvp a;\n\t\tvip b;\n\t\ta.pb(pii(0,1000000007));\n\t\twhile(n--){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif(c=='R'){\n\t\t\t\tint r;cin>>r;\n\t\t\t\tbool h=false;\n\t\t\t\trep(i,b.size())if(b[i].second.first<=r&&r<b[i].second.second){\n\t\t\t\t\th=true;\n\t\t\t\t\tcout<<b[i].first<<endl;\n\t\t\t\t}\n\t\t\t\tif(!h)cout<<-1<<endl;\n\t\t\t}else if(c=='D'){\n\t\t\t\tint r;cin>>r;\n\t\t\t\trep(i,b.size())if(b[i].first==r){\n\t\t\t\t\ta.pb(b[i].second);\n\t\t\t\t\tb.erase(b.begin()+i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint s,t;\n\t\t\t\tcin>>s>>t;\n\t\t\t\trep(i,a.size()){\n\t\t\t\t\tif(t==0)break;\n\t\t\t\t\tint r=min(t,a[i].second-a[i].first);\n\t\t\t\t\tb.pb(pip(s,pii(a[i].first,a[i].first+r)));\n\t\t\t\t\tt-=r;\n\t\t\t\t\ta[i].first+=r;\n\t\t\t\t\tif(a[i].first==a[i].second){\n\t\t\t\t\t\ta.erase(a.begin()+i);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(a));\n\t\t\trep(i,a.size()-1){\n\t\t\t\tif(a[i].second==a[i+1].first){\n\t\t\t\t\ta[i].second=a[i+1].second;\n\t\t\t\t\ta.erase(a.begin()+1+i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= ((int)(a)); --i)\n#define all(c) c.begin(), c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (x == ',' && p == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n// #define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n#define dump(...)\n\nconst int INF = 1001001001001001001LL;\n\nvoid solve(int N) {\n    set<tuple<int, int, int>> range_u, range_a;\n    range_a.insert(make_tuple(0, INF, -1));\n\n    rep(i, 0, N) {\n        char com;\n        cin >> com;\n        if (com == 'W') {\n            int qf, size;\n            cin >> qf >> size;\n\n            set<tuple<int, int, int>> memo;\n            for (auto &ra : range_a) {\n                int l, r, f;\n                tie(l, r, f) = ra;\n\n                int len = r - l;\n                if (f == -1) {\n                    if (len <= size) {\n                        size -= len;\n                        range_u.insert(make_tuple(l, r, qf));\n                        memo.insert(ra);\n                    } else {\n                        range_u.insert(make_tuple(l, l + size, qf));\n                        range_a.insert(make_tuple(l + size, r, -1));\n                        range_a.erase(ra);\n                        size = 0;\n                    }\n                    if (size == 0) {\n                        break;\n                    }\n                }\n            }\n            for (auto tpl : memo) {\n                range_a.erase(tpl);\n            }\n        } else if (com == 'D') {\n            int qf;\n            cin >> qf;\n            set<tuple<int, int, int>> memo;\n            for (auto &ra : range_u) {\n                int l, r, f;\n                tie(l, r, f) = ra;\n                if (f == qf) {\n                    range_a.insert(make_tuple(l, r, -1));\n                    memo.insert(ra);\n                }\n            }\n            for (auto tpl : memo) {\n                range_u.erase(tpl);\n            }\n        } else {\n            int sec;\n            cin >> sec;\n            for (auto ra : range_a) {\n                int l, r, f;\n                tie(l, r, f) = ra;\n                if (l <= sec && sec < r) {\n                    dump(l, r, f);\n                    cout << f << endl;\n                    break;\n                }\n            }\n            for (auto ra : range_u) {\n                int l, r, f;\n                tie(l, r, f) = ra;\n                if (l <= sec && sec < r) {\n                    dump(l, r, f);\n                    cout << f << endl;\n                    break;\n                }\n            }\n            // cerr << \"----\" << endl;\n        }\n\n        // cerr << \"range_a\" << endl;\n        // for (auto ra : range_a) {\n        //     int l, r, f;\n        //     tie(l, r, f) = ra;\n        //     dump(l, r, f);\n        // }\n        // cerr << \"range_u\" << endl;\n        // for (auto ra : range_u) {\n        //     int l, r, f;\n        //     tie(l, r, f) = ra;\n        //     dump(l, r, f);\n        // }\n        // cerr << \"==========\" << endl;\n    }\n    cout << endl;\n}\n\nsigned main() {\n    int N;\n    while (cin >> N, N) {\n        solve(N);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n\nusing namespace std;\n\n#define REP(i, n) for(long i=0; i<n; i++)\n\ntypedef pair<long, long> pii;\n\nconst long max_n = 10e5;\nconst long max_i = 10e9;\nlong n;\nchar com;\nmap<long, long> f2i;\nmap<long, long> i2f;\n\ndeque<pii> empty;\nvector<pii> used[max_n];\n\nvoid writef(long f, long c, long idx){\n    f2i[f] = idx;\n    i2f[idx] = f;\n\n    while(1){\n        if(c==0) break;\n\n        pii e = empty.front();\n        empty.pop_front();\n        if(e.second-e.first>c){\n            used[f2i[f]].push_back(make_pair(e.first, e.first+c));\n            empty.push_front(make_pair(e.first+c, e.second));\n            c = 0;\n        } else {\n            c -= (e.second - e.first);\n            used[f2i[f]].push_back(e);\n        }\n    }\n}\n\nvoid delf(long f){\n    deque<pii> tmp;\n    REP(i, used[f2i[f]].size()){\n        pii u = used[f2i[f]][i];\n        while(!empty.empty()){\n            pii e = empty.front();\n            empty.pop_front();\n            if(u.second<=e.first){\n                tmp.push_back(u);\n                empty.push_front(e);\n                break;\n            } else {\n                tmp.push_back(e);\n            }\n        }\n    }\n\n    while(!tmp.empty()){\n        pii t = tmp.back();\n        tmp.pop_back();\n        empty.push_front(t);\n    }\n    used[f2i[f]].clear();\n}\n\nvoid readf(long s){\n    REP(i, n){\n        REP(j, used[i].size()){\n            pii u = used[i][j];\n            if(u.first<=s && s<u.second){\n                cout << i2f[i] << endl;\n                return;\n            }\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(n==0) break;\n\n        empty.clear();\n        REP(i, max_n) used[i].clear();\n\n        empty.push_back(make_pair(0, max_i));\n        REP(i, n){\n            cin >> com;\n\n            if(com=='W'){\n                long f, c; // file, count\n                cin >> f >> c;\n                writef(f, c, i);\n            } else if(com=='D'){\n                long f;\n                cin >> f;\n                delf(f);\n            } else if(com=='R'){\n                long s;\n                cin >> s;\n                readf(s);\n            }\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct file{\n  int s, e, num;\n};\n\nint main(int argc, char *argv[]){\n  int n;\n  while(cin >> n, n){\n    list<file> sector;\n    char ope;\n    file tmp;\n    int len, num;\n    for (int i = 0; i < n; i++) {\n      cin >> ope;\n      list<file>::iterator ite = sector.begin();\n      // std::cout << \"setor:\" << std::endl;\n      // for (file f:sector){\n      //   std::cout << f.s << \" \" << f.e<< std::endl;\n      // }\n      if(ope == 'W'){\n        cin >> tmp.num >> len;\n        tmp.s = 0, tmp.e = len;\n        while(ite != sector.end() && len > 0){\n          if(tmp.s < ite->s) {\n            tmp.e = tmp.s + min(len, ite->s - tmp.s);\n            len -= tmp.e - tmp.s;\n            sector.insert(ite, tmp);\n          }\n          tmp.s = ite->e , tmp.e = tmp.s + len;\n          ite++;\n        }\n        if(len > 0)sector.insert(ite, tmp);\n      }else if(ope == 'D'){\n        cin >> num;\n        while(ite != sector.end()){\n          if(ite->num == num){\n            list<file>::iterator tmp = ite;\n            ite++;\n            sector.erase(tmp); \n          }\n          else ite++; \n        }\n      }else if(ope == 'R'){\n        int pos;\n        cin >> pos;\n        pos--;\n        while(ite != sector.end() && !(ite->s <= pos && pos < ite->e) )ite++;\n        if(ite != sector.end())std::cout << ite->num << std::endl;\n        else std::cout << -1 << std::endl;\n      }\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nstruct data{\n\tint no;\n\tint front;\n\tint size;\n\tbool operator<(const data &right){\n\t\treturn front < right.front;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile (cin>>n,n){\n\t\tvector<data> file;\n\t\tfile.push_back({ -1, 0, 1000000000 });\n\t\tREP(i,n){\n\t\t\tint a, b;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t\tcin >> a >> b;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].no == -1){\n\t\t\t\t\t\tif (file[i].size > b){\n\t\t\t\t\t\t\tfile.push_back({a,file[i].front,b});\n\t\t\t\t\t\t\tfile[i].front += b;\n\t\t\t\t\t\t\tfile[i].size -= b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(file[i].size==b){\n\t\t\t\t\t\t\tfile[i].no = a;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfile[i].no = a;\n\t\t\t\t\t\t\tb -= file[i].size;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> a;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].no == a)\n\t\t\t\t\t\tfile[i].no = -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> a;\n\t\t\t\tREP(i, file.size()){\n\t\t\t\t\tif (file[i].front <= a&&a <file[i].front+file[i].size){\n\t\t\t\t\t\tcout << file[i].no << endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSORT(file);\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152&lang=jp\nusing namespace std;\ntypedef pair<int,int> pii;\n#define MAX 1000000000\n\npriority_queue<pii, vector<pii>, greater<pii>> emp_secta;\nmap<int, vector<pii>> sectas;\nvoid Write(int l,int S) {\n\twhile (S) {\n\t\tauto q = emp_secta.top(); emp_secta.pop();\n\t\tint lx = q.first, rx = q.second;\n\t\tif (rx - lx + 1 == S ) {\n\t\t\tsectas[l].push_back(pii(lx, rx));\n\t\t\tS = 0;\n\t\t}\n\t\telse if(rx - lx + 1 > S) {\n\t\t\tsectas[l].push_back(pii(lx, lx + S - 1));\n\t\t\temp_secta.push(pii(lx + S, rx));\n\t\t\tS = 0;\n\t\t}\n\t\telse {\n\t\t\tsectas[l].push_back(pii(lx, rx));\n\t\t\tS -= (rx - lx + 1);\n\t\t}\n\t}\n}\n\nvoid Delete(int l) {\n\tfor (auto e : sectas[l]) {\n\t\temp_secta.push(pii(e.first, e.second));\n\t}\n\t//sectas[l].clear();\n\tsectas[l].erase(sectas[l].begin(), sectas[l].end());\n}\n\nvoid Refer(int P,int cnt) {\n\tfor (int i = 0; i < cnt;i++) {\n\t\tfor (auto e : sectas[i]) {\n\t\t\tif (P >= e.first && P <= e.second) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tsectas.clear();\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> temp;\n\t\tswap(emp_secta, temp);\n\t\temp_secta.push(pii(0,MAX));\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tchar command; cin >> command;\n\t\t\tif (command == 'W') {\n\t\t\t\tcnt++;\n\t\t\t\tint l, S; cin >> l >> S;\n\t\t\t\tWrite(l, S);\n\t\t\t}\n\t\t\tif (command == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tDelete(l);\n\t\t\t}\n\t\t\tif (command == 'R') {\n\t\t\t\tint P; cin >> P;\n\t\t\t\tRefer(P, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef pair<int,int> P;\nvector<P> vec;\n \nbool check(){\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].first != -1) return true;\n  }\n \n  vec.clear();\n  return false;\n}\n \nvoid change(int p, int S, int l){\n  vector<P> tmp;\n  int Next = vec[p].second - S;\n \n  for(int i = 0 ; i < p ; i++){\n    tmp.push_back(vec[i]);\n  }\n \n  tmp.push_back(P(l, S));\n  tmp.push_back(P(-1,Next));\n \n  for(int i = p+1 ; i < vec.size() ; i++){\n    tmp.push_back(vec[i]);\n  }\n \n  vec = tmp;\n}\n \nvoid Wri(){\n  int len = vec.size(), l, S;\n \n  cin >> l >> S;\n \n  if(len == 0 || !check()){\n    vec.push_back(P(l,S));\n    return;\n  }\n \n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == -1){\n      if(S - vec[i].second >= 0){\n        vec[i].first = l;\n        S -= vec[i].second;\n      }else{\n        change(i, S, l);\n        return;\n      }\n    }\n  }\n \n  if(S > 0){\n    vec.push_back(P(l,S));\n  }\n}\n \nvoid Del(){\n  int len = vec.size(), l;\n \n  cin >> l;\n  if(len == 0){\n    return;\n  }\n \n  for(int i = 0 ; i < len ; i++){\n    if(vec[i].first == l){\n      vec[i].first = -1;\n    }\n  }\n}\n \nint Ref(){\n  long long cnt = 0;\n  int len = vec.size(), l, num = vec[0].first;\n \n  cin >> l;\n  if(len == 0){\n    return -1;\n  }\n \n  for(int i = 0 ; i < len ; i++){\n    cnt += vec[i].second;\n    num = vec[i].first;\n     \n    if(cnt > l){\n      return num;\n    }\n  }\n \n  if(cnt <= l){\n    return -1;\n  }else{\n    return vec[len-1].first;\n  }\n}\n \nint main(){\n  int N;\n  char ch;\n \n  while(cin >> N, N){\n    vec.clear();\n    for(int i = 0 ; i < N ; i++){\n      cin >> ch;\n \n      switch(ch){\n      case 'W':\n        Wri();\n        break;\n      case 'D':\n        Del();\n        break;\n      default:\n        cout << Ref() << endl;\n        break;\n      }\n    }\n \n    cout << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct List{\n\tint id, cnt;\n\tList *nxt;\n};\n\nvoid _delete(List *p){\n\tif (p == nullptr) return;\n\t_delete(p->nxt);\n\tdelete p;\n}\n\nvoid erase(List *p, int id){\n\tif (p == nullptr) return;\n\tif (p->id == id) p->id = -1;\n\terase(p->nxt, id);\n}\n\nint find(List *p, int pos){\n\tif (p == nullptr) return -1;\n\tif (p->cnt > pos) return p->id;\n\treturn find(p->nxt, pos - p->cnt);\n}\n\nList* add(List *p, int id, int cnt){\n\tif (!cnt || p == nullptr)return new List{id, cnt, nullptr};\n\tif (p->id < 0){\n\t\tp->id = id;\n\t\tif (p->cnt > cnt){\n\t\t\tp->cnt -= cnt;\n\t\t\tList *nl = new List{ -1, p->cnt - cnt, p->nxt };\n\t\t\tp->nxt = nl;\n\t\t\treturn p;\n\t\t}\n\t\tcnt -= p->cnt;\n\t}\n\tp->nxt = add(p->nxt, id, cnt);\n\treturn p;\n}\n\nint main(){\n\tList *head = new List();\n\tint n;\n\twhile (cin >> n, n){\n\t\twhile (n--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint id, cnt;\n\t\t\t\tcin >> id >> cnt;\n\t\t\t\thead->nxt = add(head->nxt, id, cnt);\n\t\t\t}\n\t\t\telse if (c == 'D'){\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\terase(head->nxt, id);\n\t\t\t}\n\t\t\telse if (c == 'R'){\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << find(head->nxt, pos) << '\\n';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t\t_delete(head->nxt);\n\t\thead->nxt = nullptr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n){\n\n\t\tmap<P, int> mp;\n\n\t\t//??????\n\t\tmp[P(-1, -1)] = -1;\n\t\tmp[P(INF + 1, INF + 1)] = -1;\n\n\t\trep(i, n){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint l, s;\n\t\t\t\tcin >> l >> s;\n\n\t\t\t\tauto bg = mp.begin();\n\t\t\t\twhile (s){\n\t\t\t\t\tauto nx = next(bg);\n\t\t\t\t\tint ri = bg->first.second;\n\t\t\t\t\tint le = nx->first.first;\n\t\t\t\t\tif (ri + 1 < le){\n\t\t\t\t\t\tint ad = min(s, le - ri - 1);\n\t\t\t\t\t\tmp[P(ri + 1, ri + ad)] = l;\n\t\t\t\t\t\ts -= ad;\n\t\t\t\t\t\tbg = next(bg);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (s)\n\t\t\t\t\t\tif (next(bg)->second != -1)bg = nx;\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tint st = nx->first.second + 1;\n\t\t\t\t\t\t\tmp[P(st, st + s - 1)] = l;\n\t\t\t\t\t\t\ts = 0; break;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c == 'D'){\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tfor (auto j = mp.begin(); j != mp.end(); j = next(j)){\n\t\t\t\t\tif (j->second == l){\n\t\t\t\t\t\tj = prev(j);\n\t\t\t\t\t\tmp.erase(next(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c == 'R'){\n\t\t\t\tint l;\n\t\t\t\tcin >> l;\n\t\t\t\tbool f = false;\n\t\t\t\tfor (auto j : mp){\n\t\t\t\t\tif (j.first.first <= l && l <= j.first.second){\n\t\t\t\t\t\tcout << j.second << endl; f = true; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f){\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct State {\n  int v, c, rest;\n};\n\nbool operator<(const State &a, const State &b) {\n  return a.c > b.c;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n, m, l;\n  while(cin >> n >> m >> l, n) {\n    P cost[n][n];\n    rep(i, n)rep(j, n) cost[i][j] = P(INF, INF);\n    rep(i, m) {\n      int u, v, len, num;\n      cin >> u >> v >> len >> num; u--, v--;\n      cost[u][v] = cost[v][u] = P(len, num);\n    }\n\n    priority_queue<State> q;\n    q.push(State{0, 0, l});\n    bool visited[n][l] = {};\n    int ans = 0;\n    while(!q.empty()) {\n      State s = q.top(); q.pop();\n\n      if (s.v == n - 1) {\n        ans = s.c;\n        break;\n      }\n\n      if (visited[s.v][s.rest]) continue;\n      else visited[s.v][s.rest] = true;\n\n      rep(i, n) {\n        if (cost[s.v][i] != P(INF, INF)) {\n          q.push(State{i, s.c + cost[s.v][i].se, s.rest});\n          if (cost[s.v][i].fi <= s.rest) q.push(State{i, s.c, s.rest - cost[s.v][i].fi});\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstruct List{\n\tint id, cnt;\n\tList *nxt;\n};\n\nvoid _delete(List *p){\n\tif (p == nullptr) return;\n\t_delete(p->nxt);\n\tdelete p;\n}\n\nvoid erase(List *p, int id){\n\tif (p == nullptr) return;\n\tif (p->id == id) p->id = -1;\n\terase(p->nxt, id);\n}\n\nint find(List *p, int pos){\n\tif (p == nullptr) return -1;\n\tif (p->cnt > pos) return p->id;\n\treturn find(p->nxt, pos - p->cnt);\n}\n\nList* add(List *p, int id, int cnt){\n\tif (!cnt || p == nullptr)return new List{id, cnt, nullptr};\n\tif (p->id < 0){\n\t\tp->id = id;\n\t\tif (p->cnt > cnt){\n\t\t\tList *nl = new List{ -1, p->cnt - cnt, p->nxt };\n\t\t\tp->nxt = nl;\n\t\t\treturn p;\n\t\t}\n\t\tcnt -= p->cnt;\n\t}\n\tp->nxt = add(p->nxt, id, cnt);\n\treturn p;\n}\n\nint main(){\n\tList *head = new List();\n\tint n;\n\twhile (cin >> n, n){\n\t\twhile (n--){\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W'){\n\t\t\t\tint id, cnt;\n\t\t\t\tcin >> id >> cnt;\n\t\t\t\thead->nxt = add(head->nxt, id, cnt);\n\t\t\t}\n\t\t\telse if (c == 'D'){\n\t\t\t\tint id;\n\t\t\t\tcin >> id;\n\t\t\t\terase(head->nxt, id);\n\t\t\t}\n\t\t\telse if (c == 'R'){\n\t\t\t\tint pos;\n\t\t\t\tcin >> pos;\n\t\t\t\tcout << find(head->nxt, pos) << '\\n';\n\t\t\t}\n\t\t}\n\t\tcout << '\\n';\n\t\t_delete(head->nxt);\n\t\thead->nxt = nullptr;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvoid qwrite(int a, int b, queue<P>& que){\n  int size = que.size();\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.first != -1 || b == 0){\n      que.push(p);\n      continue;\n    }\n    if(p.first == -1){\n      if(p.second == -1){\n        que.push(P(a, b));\n        que.push(P(-1, -1));\n        b = 0;\n      }else if(p.second > b){\n        que.push(P(a, b));\n        que.push(P(-1, p.second - b));\n        b = 0;\n      }else if(p.second <= b){\n        que.push(P(a, p.second));\n        b -= p.second;\n      }\n    }\n  }\n}\n\nvoid qdelete(int a, queue<P>& que){\n  int size = que.size();\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.first == a){\n      que.push(P(-1, p.second));\n    }else{\n      que.push(p);\n    }\n  }\n}\n\nvoid qread(int a, queue<P>& que){\n  long long cnt = 0LL;\n  int size = que.size();\n  bool f = false;\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.second != -1) cnt += p.second;\n    if(f || a >= cnt){\n      que.push(p);\n      continue;\n    }\n    if(a < cnt){\n      cout << p.first << endl;\n      f = true;\n    }\n  }\n  if(!f) cout << -1 << endl;\n}\n\nmain(){\n  int n;\n  while(cin >> n && n){\n    queue<P> que;\n    que.push(P(-1, -1));\n    for(int i=0;i<n;i++){\n      char c;\n      int a, b;\n      cin >> c;\n      if(c == 'W'){\n        cin >> a >> b;\n        qwrite(a, b, que);\n      }\n      if(c == 'D'){\n        cin >> a;\n        qdelete(a, que);\n      }\n      if(c == 'R'){\n        cin >> a;\n        qread(a, que);\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\nusing namespace std;\n\nstruct List\n{\n  int identifier;\n  int range[2];// [range[0],range[1]]\n  bool hasNext,hasPrev;\n  List *prev;\n  List *next;\n  List(int identifier=inf,int r1=inf,int r2=inf):identifier(identifier)\n  {\n    range[0] = r1, range[1] = r2;\n    hasNext = hasPrev = false;\n  }\n};\n\nint N,I,S,P;\nchar c;\nList list;\n\nvoid list_walk(List *l)\n{\n  cout << '[' << l->range[0] << \",\" << l->range[1] << \" : \" << l->identifier << \"]\";\n  if(l->hasNext)list_walk(l->next);\n}\n\n\nvoid ddfs(List *l)\n{\n  if(l->hasNext)ddfs(l->next);\n  if(l->hasPrev)delete l;\n    \n}\n\nvoid init()\n{\n  if(list.hasNext)ddfs(&list);\n  list.hasNext = true;\n  list.hasPrev = false;\n  list.range[0] = list.range[1] = -1;\n  list.identifier = -1;\n  list.next = new List;\n  list.next->hasNext = false;\n  list.next->hasPrev = true;\n  list.next->range[0] = list.next->range[1] = inf;\n  list.next->identifier = inf;\n  list.next->prev = &list;\n  //cout << \"test : \" << list.next->prev->identifier << endl;\n  //cout << \"test : \" << list.next->identifier << endl;\n}\n\nvoid dfsW(List *l)\n{\n  if(!l->hasNext)\n    {\n      assert(false);\n      return;\n    }\n\n  int v1 = l->range[1];\n  int v2 = l->next->range[0];\n  //cout << \"v1 = \" << v1 << \" v2 = \" << v2 << endl;\n  int diff = v2-v1-1;\n  //cout << \"diff = \" << diff << endl;\n  //assert(diff >= 0);\n  if(diff)\n    {\n      List *node = new List;\n      node->identifier = I;\n      node->hasNext = node->hasPrev = true;\n      node->next = l->next;\n      node->prev = l;\n      l->next->prev = node;\n      l->next = node;\n\n      node->range[0] = v1+1;\n      if(S <= diff)\n\t{\n\t  node->range[1] = node->range[0] + S - 1;\n\t  S = 0;\n\t}\n      else if(S > diff)\n\t{\n\t  node->range[1] = node->range[0] + diff - 1;\n\t  S -= diff;\n\t}\n    \n    }  \n\n  if(S > 0)dfsW(l->next);\n}\n\nvoid compute_W()\n{\n  dfsW(&list);\n}\n\nvoid dfsD(List *l)\n{\n  if(l->identifier == I)\n    {\n      l->next->prev = l->prev;\n      l->prev->next = l->next;\n      delete l;\n    }\n  if(l->hasNext)dfsD(l->next);\n}\n\nvoid compute_D()\n{\n  dfsD(&list);\n}\n\nvoid dfsR(List *l)\n{\n  if(l->range[0] <= P && P <= l->range[1])\n    {\n      cout << l->identifier << endl;\n    }\n  else\n    {\n      if(l->hasNext)dfsR(l->next);\n      else cout << -1 << endl;\n    }\n}\n\nvoid compute_R()\n{\n  dfsR(&list);\n}\n\n\nint main()\n{\n  bool f = true;\n  while(cin >> N,N)\n    {\n      if(!f)cout << endl;\n      f = false;\n      init();\n      rep(_,N)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')cin >> I >> S,compute_W();\n\t  if(c == 'D')cin >> I,compute_D();\n\t  if(c == 'R')cin >> P,compute_R();\n\t  //list_walk(&list);cout << endl;\n\t}\n      //list_walk(&list);cout << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152\n  ?¨???¶?£???????map<kukan, int>??§????????????????????????priprity_queue??§?????????\n  ?????????\n  D??????erase???????????????\n  ??§??????????????????????????°???????????¬?????????????????????????????????????????????????¬????????´??????????????????¬?????????\n  set?????´???????????°??????????????????????????????????????????????????????????????°???\n  map?????´???????????°???key??????????????????key??????????????????????????????????????????????????°???\n  R??????lower_bound?????¨??????????£?????????°??\\??????????°????????????????????????????????????????????????????\n  ??????????????¢?????????set???lower_bound????????????????????¬?????????\n  map???lower_bound???????????¬???????????????key?????????????????¨?????? ->first ??¨??????\n  ????????????????????¨?????? ->second ??¨?????????\n*/\n\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nconst int C = 1e9+7;\ntypedef tuple<int, int> kukan; // ?????????????????????????????????\n\nbool debug = false;\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    map<kukan, int> X;\n    X[make_tuple(-1, 0)] = -1;\n    X[make_tuple(C+1, 0)] = -1;\n    priority_queue<kukan, vector<kukan>, greater<kukan> > Q;\n    Q.push(make_tuple(0, C));\n    for (auto i=0; i<N; i++) {\n      char com;\n      cin >> com;\n      if (com == 'W') {\n        int l, S;\n        cin >> l >> S;\n        while (S > 0) {\n          assert(!Q.empty());\n          kukan I = Q.top();\n          Q.pop();\n          int pt = get<0>(I);\n          int si = get<1>(I);\n          if (S >= si) {\n            X[I] = l;\n            S -= si;\n          } else {\n            X[make_tuple(pt, S)] = l;\n            Q.push(make_tuple(pt+S, si - S));\n            S = 0;\n          }\n        }\n      } else if (com == 'D') {\n        int l;\n        cin >> l;\n        auto it = X.begin();\n        while (it != X.end()) {\n          if (it->second == l) {\n            Q.push(it->first);\n            it = X.erase(it);\n          } else {\n            it++;\n          }\n        }\n      } else {\n        assert(com == 'R');\n        int P;\n        cin >> P;\n        auto U = X.lower_bound(make_tuple(P, C+3));\n        U--;\n        auto I = U->first;\n        int pt = get<0>(I);\n        int si = get<1>(I);\n        int va = U->second;\n        if (debug) {\n          cerr << \"sansho\" << endl;\n          cerr << pt << \" \" << si << \" \" << va << endl;\n        }\n        if (P < pt+si) {\n          cout << va << endl;\n        } else {\n          cout << -1 << endl;\n        }\n      }\n      if (debug) {\n        auto it = X.begin();\n        it++;\n        cerr << \"nakami\" << endl;\n        auto end = X.end();\n        end--;\n        while (it != end) {\n          cerr << get<0>(it->first) << \" \"\n               << get<1>(it->first) << \" \"\n               << it->second << endl;\n          it++;\n        }\n      }\n    }\n    cout << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.emplace({c,c+d-1},n);\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.emplace({c,c+k-1},n);\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <string>\n\nusing namespace std;\n\nstruct Segment {\n\tint start;\n\tint end;\n\tint id;\n\t\n\tSegment() {}\n\tSegment(int s, int e, int id) : start(s), end(e), id(id) {}\n};\n\nlist<Segment> storage;\nvoid do_write(const int id, const int sectors) {\n\tlist<Segment>::iterator it = storage.begin();\n\tint prev_last = -1;\n\tint remain = sectors;\n\twhile(it != storage.end()) {\n\t\tif(it->start > prev_last+1) {\n\t\t\t// insert file\n\t\t\tint size = min(remain, it->start - prev_last - 1);\n\t\t\tit = storage.insert(it, Segment(prev_last+1, prev_last+1+size-1, id));\n\t\t\tremain -= size;\n\t\t\tif(remain == 0) break;\n\t\t}\n\t\tprev_last = it->end;\n\t\t++it;\n\t}\n\tif(remain > 0) {\n\t\tstorage.insert(it, Segment(prev_last+1, prev_last+1+remain-1, id));\n\t}\n}\n\nvoid do_delete(const int id) {\n\tlist<Segment>::iterator it = storage.begin();\n\twhile(it != storage.end()) {\n\t\tif(it->id == id) {\n\t\t\tit = storage.erase(it);\n\t\t} else {\n\t\t\t++it;\n\t\t}\n\t}\n}\n\nint read_sector(const int sector) {\n\tfor(list<Segment>::const_iterator it = storage.begin(); it != storage.end(); ++it) {\n\t\tif(it->start <= sector && sector <= it->end) {\n\t\t\treturn it->id;\n\t\t}\n\t}\n\treturn -1;\n}\n\nbool solve() {\n\tint N;\n\tcin >> N;\n\tif(!N) return false;\n\tstorage.clear();\n\twhile(N--) {\n\t\tstring cmd;\n\t\tcin >> cmd;\n\t\tif(cmd == \"W\") {\n\t\t\tint id, sectors;\n\t\t\tcin >> id >> sectors;\n\t\t\tdo_write(id, sectors);\n\t\t} else if(cmd == \"D\") {\n\t\t\tint id;\n\t\t\tcin >> id;\n\t\t\tdo_delete(id);\n\t\t} else if(cmd == \"R\") {\n\t\t\tint sector;\n\t\t\tcin >> sector;\n\t\t\tcout << read_sector(sector) << endl;\n\t\t}\n\t}\n\tcout << endl;\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\t\n\tfor(; solve(); ) ;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint N;\nconst int MAX = 1e9 + 1;\n\nclass D{\npublic:\n  int e,s,in;\n};\n\nvector<D>vec;\n\nvoid write(){\n  int a,b;\n  cin >> a >> b;\n\n  int pre = 0;\n  vector<D>nv;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].s - pre != 0 && b > 0){\n      D d;\n      d.s = pre;\n      d.e = pre + min(b,vec[i].s - pre);\n      d.in = a;\n      nv.push_back(d);\n      b -= (vec[i].s - pre);\n    }\n    nv.push_back(vec[i]);\n    pre = vec[i].e;\n  }\n  vec = nv;\n}\n\nvoid del(){\n  int a;\n  cin >> a;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].in == a)vec.erase(vec.begin() + i);\n  }\n}\n\nvoid read(){\n  int a;\n  cin >> a;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].s <= a && a < vec[i].e){\n      cout << vec[i].in << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\n\nvoid solve(){\n  vec.clear();\n  \n  D d;\n  d.s = 0;\n  d.e = 0;\n  d.in = -1;\n  vec.push_back(d);\n\n  d.s = MAX;\n  d.e = MAX;\n  d.in = -1;\n  vec.push_back(d);\n\n  for(int i = 0 ; i < N ; i++){\n    char c;\n    cin >> c;\n    switch(c){\n    case 'W':\n      write();\n      break;\n    case 'D':\n      del();\n      break;\n    case 'R':\n      read();\n      break;\n    }\n  }\n}\n\nint main(){\n  while(cin >> N,N){\n    solve();\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s - 1));\n                        endtoi[x.first + s - 1] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second - 1));\n                        endtoi[x.second - 1] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(make_pair(mp[i][j].first,mp[i][j].second+1));\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                if(it == endtoi.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n            if(c == 'X'){\n                \n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <algorithm>\n#include <set>\n#include <vector>\n\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\n\nstruct range {\n  int beg, ed;\n  int num;\n};\n\nint main()\n{\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    list<range> s;\n    REP(i,n){\n      string c;\n      cin>>c;\n      if(c==\"W\"){\n        int l,S;\n        cin >> l >> S;\n        int old = 0;\n        for(auto itr=begin(s);itr!=end(s);++itr){\n          auto r = *itr;\n          if(old < r.beg) {\n            int len = min(r.beg-old, S);\n            s.insert(itr, {old, r.beg, l});\n            S -= len;\n            if (S <= 0) break;\n          }\n          old  = r.ed;\n        }\n        if(S > 0) {\n          s.push_back({old, old + S, l});\n        }\n      } else if (c == \"D\") {\n        int l;\n        cin>>l;\n        auto itr = remove_if(begin(s),end(s),[=](const range& r){return r.num == l;});\n        s.erase(itr, end(s));\n      } else {\n        int p;\n        cin>>p;\n        auto itr = find_if(begin(s),end(s),[=](const range& r){return r.beg <= p && p < r.ed;});\n        if (itr != end(s))\n          cout<<itr->num<<endl;\n        else\n          cout<<-1<<endl;\n      }\n      //for(auto r:s)cout<<\"(\"<<r.beg<<\",\"<<r.ed<<\"):\"<<r.num<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct zalis{\npublic:\n    zalis *prev;\n    zalis *next;\n    int v;\n    int l,r;//[l,r]\n    zalis(int v,int l,int r):v(v),l(l),r(r){\n        prev= nullptr;\n        next= nullptr;\n    }\n\n    int size(){\n        return r-l+1;\n    }\n};\n\nint main(){\n    int n;\n    while(true){\n        cin>>n;\n        if(n==0)break;\n        zalis za(-1,0,1000000000);\n        zalis *frontza=&za;\n        for (int i = 0; i < n; ++i) {\n            char c;\n            cin>>c;\n            if(c=='W'){\n                int value,length;\n                cin>>value>>length;\n                zalis *tempza=frontza;\n                while(tempza!= nullptr){\n                    if(tempza->v==-1){\n                        if(tempza->size()<=length){//入りきらない\n                            tempza->v=value;\n                            length-=tempza->size();\n                            if(length==0)break;\n                        }\n                        else {//入りきる\n                            zalis *newempty=new zalis(value,tempza->l,tempza->l+length-1);\n                            if(newempty->l==0)frontza=newempty;\n\n                            tempza->l+=length;\n\n                            if(tempza->prev!= nullptr)tempza->prev->next=newempty;\n                            newempty->prev=tempza->prev;\n\n                            newempty->next=tempza;\n                            tempza->prev=newempty;\n\n                            break;\n                        }\n                    }\n                    tempza=tempza->next;\n                }\n            }\n            else if(c=='D'){\n                int k;\n                cin>>k;\n                zalis *tempza=frontza;\n                while(tempza!= nullptr){\n                    if(tempza->v==k)tempza->v=-1;\n                    tempza=tempza->next;\n                }\n            }\n            else {//c=='R'\n                int k;\n                cin>>k;\n                zalis *tempza=frontza;\n                while(tempza!= nullptr){\n                    if(tempza->l<=k&&tempza->r>=k){\n                        cout<<tempza->v<<endl;\n                        break;\n                    }\n                    tempza=tempza->next;\n                }\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20001];\nsegment *head, *blank;\n\nsegment* newseg(){\n    blank->next=NULL;\n    blank->file=NULL;\n    blank->id=-1;\n    blank->head=-1;\n    blank->length=-1;\n    return blank++;\n}\n\nvoid W(int I, int S){\n    segment *p=head, *last;\n    while(S){\n        while(p->id!=-1) p=p->next;\n        if(p->length>S){\n            p->id=I;\n            segment *b=newseg();\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n            p=p->next;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head,*next;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        next=p->file;\n        p->file=NULL;\n        p=next;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20001;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<numeric>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<sstream>\n#define REP(i,p,n) for(int i=p;i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep_split(tok,a_str,re) for(char *tok = strtok((char *)a_str.c_str(),re); tok != NULL; tok = strtok(NULL,re))\n#define ALL(c) (c).begin(), (c).end()\n#define dump(a) cerr << #a << \"=\" << (a) << endl\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; } //t=min\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; } //t=max\nusing namespace std;\n\n\n\nstruct Point {\n\tint first;\n\tint len;\n\tint sikibetu_id;\n};\nvector<Point> sys;\n\nint read_sys(int real_i) {\n\trep(i,sys.size()) {\n\t\tint first = sys[i].first;\n\t\tint last = first + sys[i].len;\n\t\tif (first <= real_i && real_i < last) {\n\t\t\treturn sys[i].sikibetu_id;\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid delete_sys(int siki) {\n\trep(i,sys.size()) {\n\t\tif (sys[i].sikibetu_id == siki) {\n\t\t\tsys.erase(sys.begin() + siki); //i???????´??????????\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid write_sys(int siki, int len) {\n\tint tune_index = 0;\n\trep(i,sys.size()) {\n\t\tif (tune_index != sys[i].first) {\n\t\t\t//tune_index <= hoge <= sys[i].first??????????????£???\n\t\t\tint between = (sys[i].first - tune_index);\n\n\t\t\tif (between >= len) {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=len;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen=0; //0\n\t\t\t}\n\t\t\telse {\n\t\t\t\tPoint p;\n\t\t\t\tp.first=tune_index;\n\t\t\t\tp.len=between;\n\t\t\t\tp.sikibetu_id = siki;\n\t\t\t\tsys.insert(sys.begin()+i, p);\n\t\t\t\tlen-=between;\n\t\t\t}\n\t\t}\n\t\ttune_index += sys[i].len;\n\t}\n\n\tif (len > 0) {\n\t\tPoint p;\n\t\tp.first=tune_index;\n\t\tp.len=len;\n\t\tp.sikibetu_id=siki;\n\t\tsys.push_back(p);\n\t}\n\n}\n\nvoid show() {\n\tdump(\"-------\");\n\trep(i,sys.size()) {\n\t\tdump(sys[i].first);\n\t\tdump(sys[i].len);\n\t\tdump(sys[i].sikibetu_id);\n\t}\n}\n\nint main() {\n\tint N;\n\tchar command;\n\tint arg1,arg2;\n\n\twhile(cin >> N) {\n\t\tif (N == 0) { break; }\n\t\tsys.clear();\n\t\trep(i,N) {\n\t\t\tcin >> command;\n\t\t\t//dump(command);\n\t\t\tif (command == 'R') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tcout << read_sys(arg1) << endl;\n\t\t\t}\n\t\t\telse if (command == 'D') {\n\t\t\t\tcin >> arg1;\n\t\t\t\tdelete_sys(arg1);\n\t\t\t}\n\t\t\telse if (command == 'W') {\n\t\t\t\tcin >> arg1 >> arg2;\n\t\t\t\twrite_sys(arg1,arg2);\n\t\t\t}\n\t\t\t//show();\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define int long long\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\nconst int INF = 1e12;\n\nsigned main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(1){\n        cin >> n;\n        if(n == 0) break;\n        vector<PP> d; // start, len, id;\n        rep(i, 0, n){\n            char c;\n            int id, len;\n            cin >> c >> id;\n            if(c == 'W'){\n                cin >> len;\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == -1){\n                        int sz = d[j].second.first;\n                        int st = d[j].first;\n                        if(len < sz){\n                            d.push_back(PP(st + len, P(sz - len, -1)));\n                            d[j].second.first = len;\n                            d[j].second.second = id;\n                        }else{\n                            len -= sz;\n                            d[j].second.second = id;  \n                        }\n                    }\n                }\n                int right = 0;\n                if(len > 0){\n                    if(d.size() == 0){\n                        right = 0;\n                    }else{\n                        right = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                    }\n                    d.push_back(PP(right, P(len, id)));\n                }\n            }else if(c == 'D'){\n                rep(j, 0, d.size()){\n                    if(d[j].second.second == id){\n                        d[j].second.second = -1;\n                    }\n                }\n            }else if(c == 'R'){\n                int idx = upper_bound(all(d), PP(id, P(INF, INF))) - d.begin();\n                // cout << id << ' ' << idx << endl;\n                if(idx == d.size()){\n                    if(d.size() == 0) cout << -1 << endl;\n                    else{\n                        int r = d[d.size() - 1].first + d[d.size() - 1].second.first;\n                        if(id < r){\n                            cout << d[d.size() - 1].second.second << endl;\n                        }else{\n                            cout << -1 << endl;\n                        }\n                    }\n                }else{\n                    idx--;\n                    assert(0 <= idx && idx < d.size());                    \n                    cout << d[idx].second.second << endl;          \n                }\n            }\n            sort(all(d));   \n        }\n        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nint N;\nconst int MAX = 1e9 + 1;\n\nclass D{\npublic:\n  int e,s,in;\n};\n\nvector<D>vec;\n\nvoid write(){\n  int a,b;\n  cin >> a >> b;\n\n  int pre = 0;\n  vector<D>nv;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].s - pre != 0 && b > 0){\n      D d;\n      d.s = pre;\n      d.e = pre + min(b,vec[i].s - pre);\n      d.in = a;\n      nv.push_back(d);\n      b -= (d.s - pre);\n    }\n    nv.push_back(vec[i]);\n    pre = vec[i].e;\n  }\n  vec = nv;\n}\n\nvoid del(){\n  int a;\n  cin >> a;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].in == a)vec.erase(vec.begin() + i);\n  }\n}\n\nvoid read(){\n  int a;\n  cin >> a;\n  for(int i = 0 ; i < vec.size() ; i++){\n    if(vec[i].s <= a && a < vec[i].e){\n      cout << vec[i].in << endl;\n      return;\n    }\n  }\n  cout << -1 << endl;\n}\n\nvoid solve(){\n  vec.clear();\n  \n  D d;\n  d.s = 0;\n  d.e = 0;\n  d.in = -1;\n  vec.push_back(d);\n\n  d.s = MAX;\n  d.e = MAX;\n  d.in = -1;\n  vec.push_back(d);\n\n  for(int i = 0 ; i < N ; i++){\n    char c;\n    cin >> c;\n    switch(c){\n    case 'W':\n      write();\n      break;\n    case 'D':\n      del();\n      break;\n    case 'R':\n      read();\n      break;\n    }\n  }\n}\n\nint main(){\n  while(cin >> N,N){\n    solve();\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    for(unsigned long n; cin >> n && n; cout << endl){\n        map<pair<unsigned long, unsigned long>, unsigned long> rlc;\n        set<unsigned long> del;\n        rlc.emplace(pair<unsigned long, unsigned long>(0, 100000000000), ~0);\n        del.insert(~0);\n        for(unsigned long iter = 0, A, B; iter < n; ++iter){\n            char c;\n            cin >> c >> A;\n            if(c == 'W'){\n                cin >> B;\n                for(auto it = rlc.begin(), en = rlc.end(); it != en; ++it)if(del.count(it -> second))if(B + it -> first.first < it -> first.second){\n                    auto i = *it;\n                    rlc.erase(it);\n                    rlc.emplace(pair<unsigned long, unsigned long>(i.first.first, i.first.first + B), A);\n                    rlc.emplace(pair<unsigned long, unsigned long>(i.first.first + B, i.first.second), i.second);\n                    break;\n                }else{\n                    it -> second = A;\n                    B -= it -> first.second - it -> first.first;\n                }\n            }else if(c == 'D') del.insert(A);\n            else for(const auto& i : rlc)if(i.first.first <= A && A < i.first.second)cout << static_cast<long>(del.count(i.second) ? -1 : i.second) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll n;\n\n    while (cin >> n, n) {\n\n        vector<tuple<ll, ll, ll>> files; // (l, r, i) means [l, r) is a part of the file i\n        \n        REP(i, n) {\n\n            char cmd; cin >> cmd;\n\n            if (cmd == 'R') {\n\n                ll p; cin >> p;\n                bool found = false;\n                for (auto &f : files) {\n                    if (get<0>(f) <= p && p < get<1>(f)) {\n                        cout << get<2>(f) << endl;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) cout << \"-1\" << endl;\n\n            } else if (cmd == 'D') {\n\n                ll i; cin >> i;\n                files.erase(remove_if(ALL_OF(files), [&i](auto f) -> bool { return get<2>(f) == i; }), files.end());\n\n            } else if (cmd == 'W') {\n\n                ll i, s; cin >> i >> s;\n\n                auto old_back = files.empty() ? make_tuple(0LL,0LL,0LL) : files.back();\n\n                if (!files.empty()) {\n                    if (get<0>(files.front()) > 0) {\n                        ll gap = min(get<0>(files.front()), s);\n                        s -= gap;\n                        files.insert(files.begin(), make_tuple(0LL, gap, i));\n                    }\n                    if (s >= 0) REP(j, files.size() - 1) {\n                        ll gap = get<0>(files[j+1]) - get<1>(files[j]);\n                        if (gap > 0) {\n                            chmin(gap, s);\n                            s -= gap;\n                            ll bk = get<1>(files[j]);\n                            files.emplace_back(bk, bk + gap, i);\n                            if (s <= 0) break;\n                        }\n                    }\n                }\n\n                if (s > 0) {\n                    ll bk = files.empty() ? 0 : get<1>(old_back);\n                    files.emplace_back(bk, bk + s, i);\n                }\n\n                sort(ALL_OF(files));\n\n            }\n\n        }\n\n        cout << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nusing PLL = pair<ll, ll>;\ntemplate <typename T> using V = vector<T>;\n\nconst ll inf = 1e12;\nstruct Solver {\n    ll N;\n    map<ll, ll> lefts;\n    set<ll> left_minus;\n    V<set<ll>> file_lefts;\n    map<ll, ll> file_id;\n    V<ll> rev_file_id;\n\n    Solver() {\n        cin >> N;\n        lefts[0] = -1;\n        lefts[inf] = -1;\n        left_minus.insert(0);\n        left_minus.insert(-inf);\n        file_lefts.resize(N);\n    }\n\n    ll set_file_id(ll name) {\n        auto ite = file_id.find(name);\n        if(ite != file_id.end()) return ite->second;\n        ll ret = file_id.size();\n        file_id[name] = ret;\n        file_lefts.push_back(set<ll>());\n        rev_file_id.push_back(name);\n        return ret;\n    }\n\n    void write() {\n        ll file_name, file_size;\n        cin >> file_name >> file_size;\n        ll id = set_file_id(file_name);\n        ll left_now = 0;\n        while(file_size) {\n            auto itel = lefts.lower_bound(left_now);\n            if(itel->second != -1) {\n                left_now = itel->first + 1;\n                continue;\n            }\n            auto iter = lefts.upper_bound(itel->first);\n            ll range = iter->first - itel->first;\n            itel->second = id;\n            file_lefts[id].insert(itel->first);\n            if(file_size < range) {\n                ll key = itel->first + file_size;\n                lefts[key] = -1;\n                left_minus.insert(-key);\n                file_size = 0;\n            } else {\n                file_size -= range;\n            }\n            left_now = iter->first;\n        }\n    }\n\n    void del() {\n        ll file_name;\n        cin >> file_name;\n        ll id = set_file_id(file_name);\n        for(auto &&left : file_lefts[id]) {\n            auto ite = lefts.lower_bound(left);\n            ite->second = -1;\n        }\n        file_lefts[id].clear();\n    }\n\n    ll read() {\n        ll sector;\n        cin >> sector;\n        auto ite_m = left_minus.lower_bound(-sector);\n        auto ite = lefts.lower_bound(-*ite_m);\n        if(ite->second == -1) return -1;\n        return rev_file_id[ite->second];\n    }\n\n    bool solve() {\n        if(!N) return false;\n\n        while(N--) {\n            char c;\n            cin >> c;\n            switch(c) {\n                case 'W':\n                    write();\n                    break;\n                case 'D':\n                    del();\n                    break;\n                case 'R':\n                    cout << read() << endl;\n                    break;\n                default:\n                    assert(false);\n            }\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    while(Solver().solve()) cout << endl;;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct data{\n    int d,len,ind;//識別子、長さ、最初のセクタ番号\n};\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n\n        vector<data> v;\n        data t;\n        t.ind = 0;\n        t.len = INF+10;\n        t.d = -1;\n        v.push_back(t);\n\n        rep(i,n){\n            string s;\n            cin >> s;\n            if(s == \"W\"){\n                int l,s;\n                cin >> l >> s;\n                rep(j,v.size()){\n                    if(v[j].d == -1){\n                        if(v[j].len == s){\n                            v[j].d = l;\n                            break;\n                        }else if(v[j].len < s){\n                            v[j].d = l;\n                            s -= v[j].len;\n                        }else{\n                            data t;\n                            t.ind = v[j].ind + s;\n                            t.d = -1;\n                            t.len = v[j].len - s;\n                            v[j].d = l;\n                            v[j].len = s;\n                            v.insert(v.begin()+j+1,t);\n                            break;\n                        }\n                    }\n                }\n            }\n            if(s == \"D\"){\n                int l;\n                cin >> l;\n                rep(j,v.size()){\n                    if(v[j].d == l)v[j].d = -1;\n                }\n            }\n            if(s == \"R\"){\n                int p;\n                cin >> p;\n                rep(j,v.size()){\n                    //cout << v[j].ind << \" \" << v[j].d << \" \" << v[j].len << endl;\n                    if(v[j].ind >= p){\n                        break;\n                    }\n                }\n                cout << v[j-1].d << endl;\n\n            }\n        }\n        cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\nusing namespace std;\n\n//// MACRO ////\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define allof(c) c.begin(), c.end()\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define EPS 1e-10\n#define INF 1000000000\n\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n//// iota iterator ////\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n//// geo ////\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) { return (c - rhs.c).length() - (r + rhs.r) < EPS; } // 接してても真。\n};\n\n//// graph ////\nstruct Path\n{\n\tint from;\n\tint to;\n\tdouble cost;\n\tPath(int from = 0, int to = 0, double cost = 0) : from(from), to(to), cost(cost) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<double, vector<int>> prim(const vector<vector<double>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tdouble totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<double>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<double> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T> void write(const T &t, const T &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\twhile\n\t\t(true)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tstruct F { int ln, fn; };\n\t\tdeque<F> fs;\n\t\tfs.push_back({ INF + 1, -1 });\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tREAD(char, c);\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\tcase 'W':\n\t\t\t{\n\t\t\t\tREAD(int, fn, ln);\n\t\t\t\tauto it = fs.begin();\n\t\t\t\twhile (ln > 0)\n\t\t\t\t{\n\t\t\t\t\tif (it->fn == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint n = min(it->ln, ln);\n\t\t\t\t\t\tit->fn = fn;\n\t\t\t\t\t\tif (n < it->ln) { it = fs.insert(it + 1, { it->ln - n, -1 }) - 1; }\n\t\t\t\t\t\tit->ln = n;\n\t\t\t\t\t\tln -= n;\n\t\t\t\t\t}\n\t\t\t\t\tit++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\t{\n\t\t\t\t\tREAD(int, fn);\n\t\t\t\t\tfor (auto &f : fs){ if (f.fn == fn) { f.fn = -1; } }\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'R':\n\t\t\t\t{\n\t\t\t\t\tREAD(int, p);\n\t\t\t\t\tfor (auto &f : fs) { if (p - f.ln < 0) { write(f.fn); break; } p -= f.ln; }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lidl,ridl;\n\tint idl;\n\tint l,r;\n\tdata(){}\n\tdata(int iidl,int ll,int rr,int lll,int rrr){\n\t\tidl=iidl;\n\t\tlidl=ll;\n\t\tridl=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> idl;\nvector<int> idldata;\nvector<int> placee[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tidl.clear();\n\t\tidldata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(idl.find(l)==idl.end()){\n\t\t\t\t\tidl[l]=idldata.size();\n\t\t\t\t\tidldata.push_back(l);\n\t\t\t\t\tplacee[idl[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(idl[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lidl=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lidl].r){\n\t\t\t\t\t\t\tdat.push_back(data(idl[l],dat[nv].lidl,nv,dat[dat[nv].lidl].r,dat[dat[nv].lidl].r+min(s,dat[nv].l-dat[dat[nv].lidl].r)));\n\t\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lidl].r);\n\t\t\t\t\t\t\tdat[dat[nv].lidl].ridl=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lidl=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(idl[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplacee[idl[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].ridl=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(idl.find(l)==idl.end())continue;\n\t\t\t\tfor(int i=0;i<placee[idl[l]].size();i++){\n\t\t\t\t\tdata d=dat[placee[idl[l]][i]];\n\t\t\t\t\tif(d.lidl==-1)st=d.ridl;\n\t\t\t\t\tif(d.ridl==-1)en=d.lidl;\n\t\t\t\t\tdat[d.ridl].lidl=d.lidl;\n\t\t\t\t\tdat[d.lidl].ridl=d.ridl;\n\t\t\t\t}\n\t\t\t\tplacee[idl[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].ridl;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?idldata[dat[nv].idl]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].ridl){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].idl,dat[i].lidl,dat[i].ridl,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        \n        // ?????????????????????????????±\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\n        \n        // ?????\\??????????????????????´???????????????????\n        map<int,vector<pii>> mp;\n        \n        // ??????????????????????????????->?????\\??????\n        map<int,int> endtoi;\n        \n        pq.push(make_pair(0, 1000000000));\n        \n        for(int i=0;i<n;i++){\n            char c;cin >> c;\n            if(c == 'W'){\n                int i,s;\n                cin >> i >> s;\n                while(s > 0){\n                    pii x = pq.top();\n                    pq.pop();\n                    if(s <= x.second - x.first){\n                        pq.push(make_pair(x.first + s, x.second));\n                        mp[i].push_back(make_pair(x.first, x.first + s));\n                        endtoi[x.first + s] = i;\n                        s = 0;\n                    } else {\n                        s -= x.second - x.first;\n                        mp[i].push_back(make_pair(x.first, x.second));\n                        endtoi[x.second] = i;\n                    }\n                }\n            }\n            if(c == 'D'){\n                int i;\n                cin >> i;\n                for(int unsigned j = 0; j < mp[i].size(); j++){\n                    pq.push(mp[i][j]);\n                    endtoi.erase(mp[i][j].second);\n                }\n                mp.erase(i);\n            }\n            // ?????°???\n            if(c == 'R'){\n                int p;\n                cin >> p;\n                auto it = endtoi.lower_bound(p);\n                if(it == m1.end()){\n                    cout << -1 << endl;\n                    continue;\n                }\n                int i = it->second;\n                \n                bool isInRange = false;\n                for(int unsigned j = 0;j<mp[i].size();j++){\n                \tif(mp[i][j].first <= p && p <= mp[i][j].second){\n                \t\tisInRange = true;\n                \t}\n                }\n                if(isInRange){\n                    cout << i << endl;\n                } else {\n                    cout << -1 << endl;\n                }\n            }\n        }\n        cout << endl;\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef int lli;\n\nstruct Data {\n  lli size, id;\n};\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    vector<Data> v;\n    while(N--) {\n      char op;\n      cin >> op;\n      if(op == 'W') {\n        lli l, S;\n        cin >> l >> S;\n        for(int i = 0; S && i < v.size(); ++i) {\n          if(v[i].id == -2) {\n            v[i].id = l;\n            if(v[i].size > S) {\n              lli r = v[i].size - S;\n              v[i].size = S;\n              v.insert(v.begin()+i+1, (Data){r, -2});\n            }\n            S -= v[i].size;\n          }\n        }\n        if(S) {\n          v.push_back((Data){S, l});\n        }\n      } else if(op == 'D') {\n        lli l;\n        cin >> l;\n        for(int i = 0; i < v.size(); ++i) {        \n          if(v[i].id == l) v[i].id = -2;\n        }\n      } else if(op == 'R') {\n        lli P;\n        cin >> P;\n        --P;\n        lli output = -1;\n        for(lli i = 0, sum = 0; i < v.size(); sum += v[i++].size) {\n          if(P < sum+v[i].size) {\n            if(v[i].id >= 0) output = v[i].id;\n            break;\n          }\n        }\n        cout << output << endl;\n      }\n      /*\n      for(int i = 0; i < v.size(); ++i) {\n        cout << v[i].id << \" \" << v[i].size << endl;\n      }\n      cout << \"-----------\" << endl;\n      */\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\nint main(void){\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(n == 0) break;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tq.push(make_pair(0, INF));\n\t\tmap<int, vpint> m;\n\t\trep(i, n){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c == 'W'){\n\t\t\t\tint num, size; cin >> num >> size;\n\t\t\t\twhile(size > 0){\n\t\t\t\t\tint l = q.top().fi, r = q.top().se;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(r - l + 1 >= size){//??????\n\t\t\t\t\t\tq.push(make_pair(l + size, r));\n\t\t\t\t\t\tm[num].push_back(make_pair(l, l + size - 1));\n\t\t\t\t\t\tsize = 0;\n\t\t\t\t\t}else{//?¶??????????\n\t\t\t\t\t\tm[num].push_back(make_pair(l, r));\n\t\t\t\t\t\tsize -= (r - l + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint num; cin >> num;\n\t\t\t\tfor(auto u : m[num]){\n\t\t\t\t\tq.push(make_pair(u.fi, u.se));\n\t\t\t\t}\n\t\t\t\tm[num].erase(all(m[num]));\n\t\t\t}else{\n\t\t\t\tint idx; cin >> idx;\n\t\t\t\tbool flag = false;\n\t\t\t\teach(it, m){\n\t\t\t\t\tauto key = it->fi;\n\t\t\t\t\tauto v = it->se;\n\t\t\t\t\tfor (int i = 0; i < v.size(); ++i){\n\t\t\t\t\t\tif(v[i].fi <= idx && idx <= v[i].se){\n\t\t\t\t\t\t\tprintf(\"%d\\n\", key);\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) break;\n\t\t\t\t}\n\t\t\t\tif(!flag){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nstruct Data{\n  int start;\n  int end;\n  int data;\n  Data *next;\n  Data *prev;\n};\n\nData buff[20000];\nint  _pos;\n\nData *alloc(){\n  if(_pos == 20000) _pos = 0;\n  return &buff[_pos++];\n}\n\nvoid write(Data *d, int size, int data){\n  if(d == NULL) return;\n  if(d->data != -1){\n    write(d->next, size, data);\n  }else{\n    int sz = d->end - d->start + 1;\n    if(sz > size){\n      //puts(\"test1\");\n      Data *next = alloc();\n      next->end   = d->end;\n      d->end      = d->start + size - 1;\n      next->start = d->end + 1;\n      next->data  = -1;\n      next->prev  = d;\n      next->next  = d->next;\n      d->next     = next;\n      d->data     = data;\n    }else if(sz == size){\n      //puts(\"test2\");\n      d->data = data;\n    }else{\n      //puts(\"test3\");\n      d->data = data;\n      write(d->next, size-sz, data);\n    }\n  }\n}\n\nData *merge(Data *d1, Data *d2){\n  if(d1 == NULL || d2 == NULL) return d2;\n  if(d1->data != d2->data) return d2;\n  d1->end  = d2->end;\n  d1->next = d2->next;\n  return d1;\n}\n\nvoid del(Data *d, int data){\n  while(d != NULL){\n    if(d->data == data){\n      d->data = -1;\n      merge(d->prev, d);\n      merge(d->next, d);\n    }\n    d = d->next;\n  }\n}\n\nint ref(Data *d, int pos){\n  while(d != NULL){\n    if(d->start <= pos && pos <= d->end){\n      return d->data;\n    }\n    d = d->next;\n  }\n  return 0;\n}\n\nvoid print(Data *d){\n  while(d != NULL){\n    printf(\"[%d,%d]: %d\\n\",d->start,d->end,d->data);\n    d = d->next;\n  }\n}\n\nint main(){\n  int n;\n  int cc = 0;\n  while(cin>>n, n){\n    Data *d = alloc();\n    d->start = 0;\n    d->end   = 1e9 + 10;\n    d->prev  = NULL;\n    d->next  = NULL;\n    d->data  = -1;\n\n    if(cc++ != 0) cout << endl;\n\n    while(n --> 0){\n      char c;\n      cin>>c;\n      if(c == 'W'){\n        int l,data;\n        cin>>data>>l;\n        write(d, l, data);\n      }else if(c == 'R'){\n        int pos;\n        cin>>pos;\n        cout << ref(d, pos) << endl;\n      }else{\n        int data;\n        cin>>data;\n        del(d, data);\n      }\n\n      //print(d);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//:55-\n#include <iostream>\n#include <utility>\n#include <map>\nusing namespace std;\n\nint main(){\n  int N;\n  while(cin >> N && N>0){\n    map<pair<int,int>,int> files;\n    for(int j=0;j<N;j++){\n      char cmd;\n      int I,S,P;\n      int h=0, e;\n      bool flg;\n      cin >> cmd;\n\n      map<pair<int,int>,int>::iterator f;\n      switch(cmd){\n      case 'W':\n      cin >> I >> S;\n      while(S>0){\n\te=1000000000;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->first.first < e && f->first.first > h) e=f->first.first;\n\t}\n\tif(S>=h-e){\n\t  files[make_pair(h,e-1)]=I;\n\t  S-=h-e;\n\t}else{\n\t  files[make_pair(h,h+S)]=I;\n\t  S=0;\n\t}\n\tfor(h=e+1;;h++){\n\t  flg=true;\n\t  for(f=files.begin();f!=files.end();++f){\n\t    if(f->first.first<=h && h<=f->first.second){\n\t      flg=(f->second==-1);\n\t      break;\n\t    }\n\t  }\n\t  if(flg) break;\n\t}\n      }\n      break;\n      case 'D':\n\tcin >> I;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(f->second==I) f->second=-1;\n\t  if(h>f->first.first) h=f->first.first;\n\t}\n\tbreak;\n      case 'R':\n\tcin >> P;\n\tfor(f=files.begin();f!=files.end();++f){\n\t  if(P>=f->first.first && P<=f->first.second){\n\t    cout << f->second << endl;\n\t    break;\n\t  }\n\t}\n\tif(f==files.end()) cout << -1 << endl;\n\tbreak;\n      }\n    }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\ntypedef pair<int, int> pint;\nvoid solve(int N){\n    map<pint, int> disk;//disk[[l, r)] = id;\n    char q; int t, w;\n    rep(casenum, N){\n        cin >> q >> t;\n        if(q == 'W'){\n            cin >> w;\n            int crr = 0;\n            for(const auto& k : disk){\n                if(k.first.first - crr > 0){\n                    int r = min(k.first.first, crr + w);\n                    disk[pint(crr, r)] = t;\n                    w -= r - crr;\n                }\n                crr = k.first.second;\n                if(w <= 0) break;\n            }\n            if(w > 0) disk[pint(crr, crr + w)] = t;\n        }else if(q == 'D'){\n            for(const auto& k : disk)\n              if(k.second == t){\n                  disk.erase(k.first);\n                  break;\n              }\n        }else{\n            auto lb = disk.lower_bound(pint(t, 0));\n            if(lb != disk.begin()) lb--;\n            pint temp = lb->first;\n            //cout << temp.first << ' ' << temp.second << endl;\n            if(temp.first <= t && t <= temp.second)\n              cout << lb->second << endl;\n            else\n              cout << \"-1\" << endl;\n        }\n    }\n}\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n && n){\n        solve(n);\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 1000000000\n\nstruct Node{\n\tint left,right,file_id;\n\tNode* prev;\n\tNode* next;\n};\n\nclass List{\npublic:\n\tList(){\n\t\tmotherNode = new Node();\n\t\tmotherNode->file_id = -1;\n\t\tmotherNode->prev = new Node();\n\t\tmotherNode->next = motherNode->prev;\n\n\t\tmotherNode->next->left = 0;\n\t\tmotherNode->next->right = NUM;\n\t\tmotherNode->next->file_id = -1;\n\n\t\tmotherNode->next->next = motherNode;\n\t\tmotherNode->next->prev = motherNode;\n\n\t};\n\tvoid writeFile(int id,int size){\n\n\t\tint rest = size,node_size;\n\n\t\tNode* tmpNode = motherNode->next;\n\n\t\twhile(tmpNode != motherNode){\n\t\t\tif(tmpNode->file_id == -1){\n\t\t\t\tnode_size = tmpNode->right-tmpNode->left+1;\n\t\t\t\tif(node_size >= rest){\n\n\t\t\t\t\tNode* tmp_next = tmpNode->next;\n\t\t\t\t\ttmpNode->next = new Node;\n\n\t\t\t\t\ttmpNode->next->right = tmpNode->right;\n\t\t\t\t\ttmpNode->next->left = tmpNode->left+size;\n\t\t\t\t\ttmpNode->next->file_id = -1;\n\t\t\t\t\ttmpNode->next->next = tmp_next;\n\t\t\t\t\ttmpNode->next->prev = tmpNode;\n\n\t\t\t\t\ttmpNode->right = tmpNode->left+size-1;\n\t\t\t\t\ttmpNode->file_id = id;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\ttmpNode->file_id = id;\n\t\t\t\t\trest -= node_size;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t};\n\n\tvoid delete_File(int id){\n\t\tNode* tmpNode = motherNode->next;\n\t\tif(tmpNode->file_id == id){\n\t\t\ttmpNode->file_id = -1;\n\t\t}\n\t\ttmpNode = tmpNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tif(tmpNode->file_id == id){\n\t\t\t\ttmpNode->file_id = -1;\n\t\t\t}\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t};\n\n\n\tint search_id(int loc){\n\t\tNode* tmpNode = motherNode->next;\n\t\tif(tmpNode->left <= loc && tmpNode->right >= loc){\n\t\t\treturn tmpNode->file_id;\n\t\t}\n\t\ttmpNode = tmpNode->next;\n\t\twhile(tmpNode != motherNode){\n\t\t\tif(tmpNode->left <= loc && tmpNode->right >= loc){\n\t\t\t\treturn tmpNode->file_id;\n\t\t\t}\n\t\t\ttmpNode = tmpNode->next;\n\t\t}\n\t\treturn -1;\n\t}\n\nprivate:\n\tNode* motherNode;\n};\n\nint N;\n\nvoid func(){\n\n\tList list;\n\n\tchar command[2];\n\tint id,size,loc;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%s\",command);\n\n\t\tswitch(command[0]){\n\t\tcase 'W':\n\t\t\tscanf(\"%d %d\",&id,&size);\n\t\t\tlist.writeFile(id,size);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tscanf(\"%d\",&id);\n\t\t\tlist.delete_File(id);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tscanf(\"%d\",&loc);\n\t\t\tprintf(\"%d\\n\",list.search_id(loc));\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\nconst long long INF = (1e18);\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    map< pair<long long, long long>, long long > F;\n    map< long long, vector< pair<long long, long long> > > M;\n    F[{-INF,0}] = -1;\n    for(int i = 0; i < N; ++i){\n      char c;\n      cin >> c;\n      if(c == 'W'){\n        long long l, s, r = 0;\n        cin >> l >> s;\n        vector< pair<long long, long long> > V;\n        for(auto itr = F.begin(); itr != F.end(); ++itr){\n          r = max(r, itr->first.second);\n          auto itr_ = itr;\n          ++itr_;\n          if(itr_ == F.end()) continue;\n          if(itr_->first.first != itr->first.second){\n            long long n = min(s, itr_->first.first - itr->first.second);\n            s -= n;\n            V.emplace_back(itr->first.second,itr->first.second+n);\n            if(!s) break;\n          }\n        }\n        if(s){\n          V.emplace_back(r,r+s);\n        }\n        for(int j = 0; j < (int)V.size(); ++j){\n          F[V.at(j)] = l;\n          M[l].push_back(V.at(j));\n        }\n        /*\n        sort(M[l].begin(), M[l].end());\n        V = {};\n        long long x = -2, y = -1;\n        for(int j = 0; j < (int)M[l].size(); ++j){\n          if(y == M[l].at(j).first){\n            F.erase(F.find({x,y}));\n            F.erase(F.find(M[l].at(j)));\n            y = M[l].at(j).second;\n            F[{x,y}] = l;\n            V.pop_back();\n            V.emplace_back(x,y);\n          }else{\n            x = M[l].at(j).first;\n            y = M[l].at(j).second;\n            V.emplace_back(x,y);\n          }\n        }\n        M[l] = V;\n        */\n      }else if(c == 'D'){\n        long long l;\n        cin >> l;\n        for(int j = 0; j < (int)M[l].size(); ++j) F.erase(F.find(M[l].at(j)));\n        M[l] = {};\n      }else{\n        long long p;\n        cin >> p;\n        auto itr = F.upper_bound({p,INF});\n        //cout << itr->first.first << \" \" << itr->first.second << \" \" << itr->second << endl;\n        assert(itr != F.begin());\n        --itr;\n        if(itr->first.second <= p) cout << -1 << endl;\n        else cout << itr->second << endl;\n      }\n      //for(auto itr = F.begin(); itr != F.end(); ++itr) cout << \"[\" << itr->first.first << \", \" << itr->first.second << \") =  \" << itr->second << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n#define NON -1\ntypedef pair < int , int > Pi;\ntypedef pair < Pi , int > Pii;\nvector< Pii > memory; //セクタの状態\nvoid write( int l, int sum){ //書き込む\n  for(int i = 0; sum > 0 ; i++){\n    if(memory[i].sc != NON) continue;\n    int kazu = memory[i].fr.sc - memory[i].fr.fr + 1;\n    if(kazu <= sum){\n      memory[i].sc = l, sum -= kazu;\n    }else{\n      memory.insert( memory.begin() + i, Pii( Pi( memory[i].fr.fr, memory[i].fr.fr + sum - 1), l));\n      memory[++i].fr.fr = memory[i - 1].fr.sc + 1;\n      sum = 0;\n    }\n  }\n}\nvoid erase( int idx){ //消す\n  for(int i = 0; i < memory.size() ; i++){\n    if(memory[i].sc == idx) memory[i].sc = NON;\n  }\n}\nvoid read( int idx){ //読み込む\n  int pos = 0;\n  while(memory[pos].fr.sc < idx) pos++;\n  cout << memory[pos].sc << endl;\n}\n\n\nint main(){\n  int n;\n  bool flag = false;\n  while(cin >> n, n){\n    if(flag++) cout << endl;\n    memory.clear();\n    memory.push_back( Pii( Pi( 0, 1000000001), NON));\n    while(n--){\n      char buff;\n      cin >> buff;\n      if(buff == 'W'){ //write\n        int a, b;\n        cin >> a >> b;\n        write(a,b);\n      }else if(buff == 'D'){ //delete\n        int a;\n        cin >> a;\n        erase(a);\n      }else{ //read\n        int a;\n        cin >> a;\n        read(a);\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152\n  ?¨???¶?£???????map<kukan, int>??§????????????????????????priprity_queue??§?????????\n  ?????????\n  D??????erase???????????????\n  ??§??????????????????????????°???????????¬?????????????????????????????????????????????????¬????????´??????????????????¬?????????\n  set?????´???????????°??????????????????????????????????????????????????????????????°???\n  map?????´???????????°???key??????????????????key??????????????????????????????????????????????????°???\n  R??????lower_bound?????¨??????????£?????????°??\\??????????°????????????????????????????????????????????????????\n  ??????????????¢?????????set???lower_bound????????????????????¬?????????\n  map???lower_bound???????????¬???????????????key?????????????????¨?????? ->first ??¨??????\n  ????????????????????¨?????? ->second ??¨?????????\n*/\n\n#include <iostream>\n#include <queue>\n#include <tuple>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nconst int C = 1e9+7;\ntypedef tuple<int, int> kukan; // ?????????????????????????????????\n\nbool debug = false;\n\nint main() {\n  int N;\n  while(cin >> N && N) {\n    map<kukan, int> X;\n    X[make_tuple(-1, 0)] = -1;\n    X[make_tuple(C+1, 0)] = -1;\n    priority_queue<kukan, vector<kukan>, greater<kukan> > Q;\n    Q.push(make_tuple(0, C));\n    for (auto i=0; i<N; i++) {\n      char com;\n      cin >> com;\n      if (com == 'W') {\n        int l, S;\n        cin >> l >> S;\n        while (S > 0) {\n          assert(!Q.empty());\n          kukan I = Q.top();\n          Q.pop();\n          int pt = get<0>(I);\n          int si = get<1>(I);\n          if (S >= si) {\n            X[I] = l;\n            S -= si;\n          } else {\n            X[make_tuple(pt, S)] = l;\n            Q.push(make_tuple(pt+S, si - S));\n            S = 0;\n          }\n        }\n      } else if (com == 'D') {\n        int l;\n        cin >> l;\n        auto it = X.begin();\n        while (it != X.end()) {\n          if (it->second == l) {\n            Q.push(it->first);\n            it = X.erase(it);\n          } else {\n            it++;\n          }\n        }\n      } else {\n        assert(com == 'R');\n        int P;\n        cin >> P;\n        auto U = X.lower_bound(make_tuple(P, -C));\n        U--;\n        auto I = U->first;\n        int pt = get<0>(I);\n        int si = get<1>(I);\n        int va = U->second;\n        if (debug) {\n          cerr << \"sansho\" << endl;\n          cerr << pt << \" \" << si << \" \" << va << endl;\n        }\n        if (P < pt+si) {\n          cout << va << endl;\n        } else {\n          cout << -1 << endl;\n        }\n      }\n      if (debug) {\n        auto it = X.begin();\n        it++;\n        cerr << \"nakami\" << endl;\n        auto end = X.end();\n        end--;\n        while (it != end) {\n          cerr << get<0>(it->first) << \" \"\n               << get<1>(it->first) << \" \"\n               << it->second << endl;\n          it++;\n        }\n      }\n    }\n    cout << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n        if(n == 0)break;\n        \n        set<P1> S1;\n        set<P1> S2;\n        S1.insert(mp1(0,-1,1000000001));\n        S2.insert(mp1(-1,0,1000000001));\n        \n        for(int i = 0 ; i < n ; i ++){\n            char c;\n            cin >> c;\n            //scanf(\"\\n%c\",&c);\n            if(c == 'W'){\n                int l,s;\n                scanf(\"%d%d\",&l,&s);\n                set<P1>::iterator itr = S2.lower_bound(mp1(-1,0,0));\n                while(1){\n                    if(itr->sc.sc > s){\n                        S1.insert(mp1(itr->sc.fr,l,s));\n                        S1.insert(mp1(itr->sc.fr+s,itr->fr,itr->sc.sc-s));\n                        S1.erase(mp1(itr->sc.fr,itr->fr,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,s));\n                        S2.insert(mp1(itr->fr,itr->sc.fr+s,itr->sc.sc-s));\n                        S2.erase(itr);\n                        break;\n                    }\n                    else {\n                        S1.insert(mp1(itr->sc.fr,l,itr->sc.sc));\n                        S1.erase(mp1(itr->sc.fr,-1,itr->sc.sc));\n                        S2.insert(mp1(l,itr->sc.fr,itr->sc.sc));\n                        S2.erase(itr++);\n                        s -= itr->sc.sc;\n                    }\n                    if(s == 0)break;\n                }\n            }\n            else if(c == 'D'){\n                int l;\n                scanf(\"%d\",&l);\n                set<P1>::iterator itr = S2.lower_bound(mp1(l,0,0));\n                while(1){\n                    S1.insert(mp1(itr->sc.fr,-1,itr->sc.sc));\n                    S1.erase(mp1(itr->sc.fr,l,itr->sc.sc));\n                    S2.insert(mp1(-1,itr->sc.fr,itr->sc.sc));\n                    S2.erase(itr++);\n                    if(itr->fr != l)break;\n                }\n            }\n            else {\n                int p;\n                scanf(\"%d\",&p);\n                set<P1>::iterator itr = S1.upper_bound(mp1(p,-1,0));\n                printf(\"%d\",(--itr)->sc.fr);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t2152: Restrictive Filesystem\n*/\n#include\t<iostream>\n#include\t<vector>\n#include\t<utility>\n#include\t<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P_ii;\n\nclass datlst {\nprivate:\n\tvector<P_ii> lst;\npublic:\n\tvoid push_file(int, int);\n\tvoid erase_file(int);\n\tint show_file(int);\n};\n\nvoid datlst::push_file(int ident, int count) {\n\tint\t\tctSector;\n\tbool\tflagHit;\n\tfor (int i = 0; i < count; i++) {\n\t\tif (lst.empty()) {\n\t\t\tlst.push_back(P_ii(0, ident));\n\t\t} else {\n\t\t\tvector<P_ii>::iterator it = lst.begin();\n\t\t\tctSector = 0;\n\t\t\tflagHit = true;\n\t\t\twhile (it != lst.end()) {\n\t\t\t\tif (it->second == -1) {\n\t\t\t\t\tit->first = ctSector;\n\t\t\t\t\tit->second = ident;\n\t\t\t\t\tflagHit = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tctSector++;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\tif (flagHit) {\n\t\t\t\tlst.push_back(P_ii(++ctSector, ident));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid datlst::erase_file(int ident) {\n\tvector<P_ii>::iterator it = lst.begin();\n\twhile (it != lst.end()) {\n\t\tif (it->second == ident) {\n\t\t\tit->second = -1;\n\t\t}\n\t\tit++;\n\t}\n}\n\nint datlst::show_file(int sector) {\n\tvector<P_ii>::iterator it = lst.begin();\n\twhile (it != lst.end()) {\n\t\tif (it->first == sector) {\n\t\t\treturn it->second;\n\t\t\tbreak;\n\t\t}\n\t\tit++;\n\t}\n\treturn -1;\n}\n\nint main(void) {\n\tint\t\tN, f, s;\n\tchar\tc;\n\twhile (1) {\n\t\tdatlst DataList;\n\t\tcin >> N;\n\t\tif (N == 0) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> c;\n\t\t\tswitch (c) {\n\t\t\tcase 'W':\n\t\t\t\tcin >> f >> s;\n\t\t\t\tDataList.push_file(f, s);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tcin >> f;\n\t\t\t\tDataList.erase_file(f);\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tcin >> f;\n\t\t\t\tcout << DataList.show_file(f) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvoid qwrite(int a, int b, queue<P>& que){\n  int size = que.size();\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(b == 0){\n      que.push(p);\n      continue;\n    }\n    if(p.first == -1){\n      if(p.second == -1){\n        que.push(P(a, b));\n        que.push(P(-1, -1));\n        b = 0;\n      }else if(p.second > b){\n        que.push(P(a, b));\n        que.push(P(-1, p.second - b));\n        b = 0;\n      }else if(p.second <= b){\n        que.push(P(a, p.second));\n        b -= p.second;\n      }\n    }else{\n      que.push(p);\n    }\n  }\n}\n\nvoid qdelete(int a, queue<P>& que){\n  int size = que.size();\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(p.first == a){\n      que.push(P(-1, p.second));\n    }else{\n      que.push(p);\n    }\n  }\n}\n\nvoid qread(int a, queue<P>& que){\n  long long cnt = 0LL;\n  int size = que.size();\n  bool f = false;\n  for(int i=0;i<size;i++){\n    P p = que.front(); que.pop();\n    if(f){\n      que.push(p);\n      continue;\n    }\n    cnt += p.second;\n    if(a < cnt){\n      cout << p.first << endl;\n      f = true;\n    }else{\n      que.push(p);\n    }\n  }\n  if(!f) cout << -1 << endl;\n}\n\nmain(){\n  int n;\n  while(cin >> n && n){\n    queue<P> que;\n    que.push(P(-1, -1));\n    for(int i=0;i<n;i++){\n      char c;\n      int a, b;\n      cin >> c;\n      if(c == 'W'){\n        cin >> a >> b;\n        qwrite(a, b, que);\n      }\n      if(c == 'D'){\n        cin >> a;\n        qdelete(a, que);\n      }\n      if(c == 'R'){\n        cin >> a;\n        qread(a, que);\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Data\n{\n  int id, st, num;\n  Data(int id, int st, int num) : id(id), st(st), num(num) {}\n  bool operator<(const Data& rhs) const { return st<rhs.st; }\n};\n\nint N;\nvector<Data> storage;\n\nvoid write(const int id, int remain) {\n  int st = 0;\n  while(remain > 0) {\n    int num = -1;\n    if(!storage.empty()) sort(storage.begin(), storage.end());\n    for(int i=0; i<storage.size(); i++) {\n      if(st < storage[i].st) {\n        num = storage[i].st - st; break;\n      }\n      else if(st < storage[i].st+storage[i].num) {\n        st = st+storage[i].num;\n      }\n    }\n    if(num == -1) {\n      if(!storage.empty()) {\n        st = storage[storage.size()-1].st+storage[storage.size()-1].num;\n      }\n      else { st = 0; }\n      num = remain;\n    }\n    storage.push_back(Data(id, st, num));\n    remain -= num;\n  }\n}\n\nstruct EqualsID {int id;EqualsID(int id) : id(id) {}bool operator() (const Data &d) { return d.id == id; }};\nvoid del(int id) {\n  storage.erase(remove_if(storage.begin(), storage.end(), EqualsID(id)), storage.end());\n}\n\nint refer(int sect) {\n  for(int i=0; i<storage.size(); i++) {\n    if(storage[i].st<=sect && sect<storage[i].st+storage[i].num) {\n      return storage[i].id;\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N && N) {\n    storage.clear();\n    for(int i=0; i<N; i++) {\n      char ch; cin >> ch;\n      if(ch=='W') {\n        int id, num; cin >> id >> num;\n        write(id, num);\n        /*\n        for(int i=0; i<storage.size(); i++) {\n          cout << \"storage[\"<<i<<\"]:\" << endl;\n          cout << \"id: \" << storage[i].id << \" st: \" << storage[i].st << \" num: \" << storage[i].num << endl;\n        }\n        */\n      }\n      if(ch=='D') {\n        int id; cin >> id;\n        del(id);\n      }\n      if(ch=='R') {\n        int sect; cin >> sect;\n        cout << refer(sect) << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nconst int MAXL = 1000000001;\ntypedef pair<int, int> SEG;\ntypedef pair<SEG, int> S;\n//int data[MAXL];\nint main(){\n  int N;\n  while(cin>>N && N){\n    //memset(data, -1, sizeof(data));\n    vector<S> data;\n    data.push_back(S(SEG(-1, 0), -1));\n    REP(time, N){\n      string cmd; cin>>cmd;\n      if(cmd == \"W\"){\n        int l, s; cin>>l>>s;\n        vector<S> add;\n        REP(i, data.size()-1){\n          if(s == 0) break;\n          if(data[i].first.second < data[i+1].first.first){\n            int fst = data[i].first.second;\n            int len = min(s, data[i+1].first.first - fst);\n            add.push_back(S(SEG(fst, fst + len), l));\n            s -= len;\n          }\n        }\n        if(s > 0){\n          int fst = data.back().first.second;\n          int len = s;\n          add.push_back(S(SEG(fst, fst + len), l));\n        }\n        REP(i, add.size()) data.push_back(add[i]);\n        sort(data.begin(), data.end());\n        /*\n        REP(i, MAXL){\n          if(S == 0) break;\n          if(data[i] == -1){\n            data[i] = l;\n            S --;\n          }\n        }\n        */\n      }else if(cmd == \"D\"){\n        int l; cin>>l;\n        //REP(i, MAXL)if(data[i] == l)data[i] = -1;\n        vector<S>::iterator it = data.begin();\n        while(it != data.end()){\n          if(it->second == l){\n            it = data.erase(it);\n          }else{\n            it++;\n          }\n        }\n      }else if(cmd == \"R\"){\n        int P; cin>>P;\n        vector<S>::iterator it = upper_bound(data.begin(), data.end(), S(SEG(P, P), -1));\n        if(it != data.begin()) it--;\n        if(it->first.first <= P && P < it->first.second) cout<< it->second <<endl;\n        else cout<< -1 << endl;\n        //cout<<data[P]<<endl;\n      }else{\n        assert(false);\n      }\n      //REP(i, data.size())printf(\"%d:(%d, %d) \", data[i].second, data[i].first.first, data[i].first.second); cout<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[dat[nv].lid].r-dat[nv].l)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[dat[nv].lid].r-dat[nv].l);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\twhile(nv!=-1 && dat[nv].r<=p)nv=dat[nv].rid;\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t//printf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\t//printf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main(){\n\twhile(1){\n\t\tstd::vector<int> v(1,-1);\n\t\tint a;\n\t\tstd::cin>>a;\n\t\tstd::cout<<a;\n\t\tif(a==0)break;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tchar x;\n\t\t\tint p,q;\n\t\t\tstd::cin>>x;\n\t\t\tif(x=='W'){\n\t\t\t\tstd::cin>>p>>q;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==-1)v[j]=p,q--;\n\t\t\t\t\tif(q==0)break;\n\t\t\t\t\twhile(j==v.size()-1&&q!=0&&v.size()<=1000000000)v.push_back(p),q--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x=='D'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tfor(int j=0;j<v.size();j++){\n\t\t\t\t\tif(v[j]==p)v[j]=-1;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tif(x=='R'){\n\t\t\t\tstd::cin>>p;\n\t\t\t\tif(p-1>v.size())std::cout<<\"-1\"<<std::endl;\n\t\t\t\telse std::cout<<v[p-1]<<std::endl;\n\t\t\t}\n\t\t}\n\t\tstd::cout<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",C,&n);\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else\t++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n ? -1 : it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[1000001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t\tplace[id[l]].clear();\n\t\t\t\t}\n\t\t\t\tif(dat.size()==0 || st==-1){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\twhile(nv!=-1 && dat[nv].r<=p)nv=dat[nv].rid;\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t\t/*\n\t\t\tprintf(\"%d %d\\n\",st,en);\n\t\t\tfor(int i=st;i!=-1;i=dat[i].rid){\n\t\t\t\tprintf(\"%d %d %d %d %d\\n\",dat[i].id,dat[i].lid,dat[i].rid,dat[i].l,dat[i].r);\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct file{\n  int s, e, num;\n};\n\nint main(int argc, char *argv[]){\n  list<file> sector;\n  int n;\n  while(cin >> n, n){\n    char ope;\n    file tmp;\n    int len, num;\n    for (int i = 0; i < n; i++) {\n      cin >> ope;\n      list<file>::iterator ite = sector.begin();\n      // std::cout << \"setor:\" << std::endl;\n      // for (file f:sector){\n      //   std::cout << f.s << std::endl;\n      // }\n      if(ope == 'W'){\n        cin >> tmp.num >> len;\n        tmp.s = 0, tmp.e = len;\n        while(ite != sector.end() && len > 0){\n          if(tmp.s < ite->s) {\n            tmp.e = tmp.s + min(len, ite->s - tmp.s);\n            len -= min(len, ite->s - tmp.s);\n            sector.insert(ite, tmp);\n          }\n          tmp.s = ite->e , tmp.e = tmp.s + len;\n          ite++;\n        }\n        sector.insert(ite, tmp);\n      }else if(ope == 'D'){\n        cin >> num;\n        while(ite != sector.end() && ite->num != num)ite++;\n        sector.erase(ite);\n      }else if(ope == 'R'){\n        int pos;\n        cin >> pos;\n        while(ite != sector.end() && !(ite->s <= pos && pos <= ite->e) )ite++;\n        if(ite != sector.end())std::cout << ite->num << std::endl;\n        else std::cout << -1 << std::endl;\n      }\n    }\n    std::cout << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int n;\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    vector<pair<pair<int, int>, int> > files;\n    rep (iii, n) {\n      string str;\n      cin >> str;\n      if (str == \"W\") {\n\tvector<pair<pair<int, int>, int> > next;\n\tint num, sz, pre = -1;\n\tcin >> num >> sz;\n\trep (i, files.size()) {\n\t  if (pre + 1 != files[i].first.first && sz > 0) {\n\t    int fsz = min(sz, files[i].first.first - pre - 1);\n\t    next.push_back(make_pair(make_pair(pre + 1, pre + fsz), num));\n\t  }\n\t  next.push_back(files[i]);\n\t  pre = files[i].first.second;\n\t}\n\tif (sz > 0) {\n\t  next.push_back(make_pair(make_pair(pre + 1, pre + sz), num));\n\t}\n\tfiles = next;\n      } else if (str == \"D\") {\n\tvector<pair<pair<int, int>, int> > next;\n\tint pos;\n\tcin >> pos;\n\trep (i, files.size()) {\n\t  if (files[i].first.first <= pos && pos <= files[i].first.second) continue;\n\t  next.push_back(files[i]);\n\t}\n\tfiles = next;\n      } else if (str == \"R\") {\n\tint pos;\n\tcin >> pos;\n\tint res = -1;\n\trep (i, files.size()) {\n\t  if (files[i].first.first <= pos && pos <= files[i].first.second) {\n\t    res = files[i].second;\n\t  }\n\t}\n\tcout << res << endl;\n      }\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nstruct newrm{\n  int start,end,dot;\n  newrm* next;\n};\nvoid write(newrm* begin,int i,int s){\n  int tmp;\n  newrm *prev,*pres,*sinki;\n  \n  prev=begin;\n  pres=prev->next;\n\n  while(pres!=NULL){\n    tmp=pres->start-prev->end;\n    if(tmp==1){\n      prev=pres;\n      pres=pres->next;\n    }\n    else{\n      sinki=new newrm();\n      sinki->start=prev->end+1;\n      sinki->dot=i;\n      if(tmp-1<s){\n\tsinki->end=pres->start-1;\n\ts-=tmp-1;\n      }\n      else \t{\n\tsinki->end=sinki->start+s-1;\n\ts=0;\n\n      }\n      prev->next=sinki;\n      sinki->next=pres;\n      if(s==0)return;\n    }\n  }\n  sinki=new newrm();\n  prev->next=sinki;\n  sinki->start=prev->end+1;\n  sinki->end=sinki->start+s-1;\n  sinki->dot=i;\n  sinki->next=NULL;\n}\n\nvoid read(newrm* begin,int p){\n  //cout<<\"read!\\n\";\n  newrm *prev,*pres;\n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->start <= p&& pres->end >= p){\n      cout<<pres->dot<<endl;\n      return;\n    } \n    else if(pres->end < p){\n      //  cout<<prev->end<<\" | \"<<pres->start<<endl;\n      prev=pres;\n      pres=pres->next;\n      //cout<<prev->end<<\" || \"<<pres->start<<endl;\n      continue;\n    }\n    else {cout<<-1<<endl;\n      return;\n    } \n  }\n  cout<<-1<<endl;\n}\nvoid del(newrm* begin,int i){\n  newrm *prev,*pres;  \n  prev=begin;\n  pres=prev->next;\n  while(pres!=NULL){\n    if(pres->dot==i)\n      prev->next=pres->next;\n    prev=prev->next;\n    pres=prev->next;\n  }\n}\nvoid reset(newrm* begin){\n  newrm* next;\n  if(begin==NULL) return;\n  next=begin->next;\n  delete begin;\n  reset(next);\n}\nvoid debug(newrm* begin){\n  while(begin!=NULL){\n    cout<<begin->start<<\" \"<<begin->end<<endl;\n    begin=begin->next;\n  }\n}\nint main(){\n  int N,i,p,s;\n  char com;\n\n  while(1){\n    newrm* begin=new newrm();\n    begin->start=-2;\n    begin->end=-1;\n    begin->dot=-1;\n    begin->next=NULL;\n    cin>>N;\n    \n    if(N==0) return 0;\n    for(int i=0;i<N;i++){\n      cin>>com;\n    \n      if(com=='W'){\n\tcin>>p>>s;\n\twrite(begin,p,s);\n      }\n      else if(com=='D'){\n\tcin>>p;\n\tdel(begin,p);\n      }\n      else if(com=='R'){\n\tcin>>p;\n\tread(begin,p);\n      }\n      else if(com=='B')\n\tdebug(begin);\n    }\n    //  reset(begin);\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define B begin()\n#define Y second\n#define E end()\n#define X first\n#define M (1e9)\nusing namespace std;\nmap<int,int>::iterator p;\nmap<int,int> m;\n\nint Read(int x){\n  for(p=m.B;p!=m.E;p++)\n    if(x<=(*p).X)return (*p).Y;\n}\n\nvoid Del(int x){\n  for(p=m.B;p!=m.E;p++)\n    if((*p).Y==x)(*p).Y=-1;\n}\n\nvoid Write(int x,int y){\n  int s=-1;\n  for(p=m.B;p!=m.E;p++){\n    if(!y)return;\n    if((*p).Y!=-1){\n      s=(*p).X;\n      continue;\n    }\n    if((*p).X-s>=y)m[s+y]=x,y=0;\n    else y-=(*p).X-s,(*p).Y=x;\n    s=(*p).X;\n  }\n}\n\nint main(){\n  int n,a,b;\n  string s;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    m.clear();\n    m[M]=-1;\n    while(n--){\n      cin>>s;\n      if(s==\"R\")cin>>a,cout<<Read(a)<<endl;\n      if(s==\"W\")cin>>a>>b,Write(a,b);\n      if(s==\"D\")cin>>a,Del(a);\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Block{\npublic:\n    int label, start, size;\n    Block(int label, int start, int size): label(label), start(start), size(size){};\n};\n\nclass FileSystem{\nprivate:\n    vector<Block> blocks;\n    \npublic:\n    FileSystem(){\n        blocks.push_back(Block(-1, 0, INF));\n    }\n    \n    void write(int label, int size){\n        for(int i=0; i<blocks.size(); i++){\n            if(blocks[i].label == -1){\n                if(size == blocks[i].size){\n                    blocks[i].label = label;\n                    break;\n                    \n                }else if(size < blocks[i].size){\n                    int start = blocks[i].start;\n                    int lest_size = blocks[i].size - size;\n                    auto it = blocks.erase(blocks.begin() + i);\n                    it = blocks.insert(it, Block(-1, start+size, lest_size));\n                    blocks.insert(it, Block(label, start, size));\n                    break;\n                    \n                }else{\n                    blocks[i].label = label;\n                    size -= blocks[i].size;\n                }\n            }\n        }\n    }\n    \n    void del(int label){\n        //?????????????????£????????????????????????\n        for(int i=0; i<blocks.size(); i++)\n            if(blocks[i].label == label)\n                blocks[i].label = -1;\n        \n    }\n    \n    void read(int pointer){\n        for(int i=0; i<blocks.size(); i++)\n            if(blocks[i].start <= pointer && pointer < blocks[i].start + blocks[i].size)\n                cout << blocks[i].label << endl;\n    }\n};\n\nvoid solve(int N){\n    FileSystem file_system = FileSystem();\n    char c;\n    while(N--){\n        cin >> c;\n        if(c == 'W'){\n            int label, size;\n            cin >> label >> size;\n            file_system.write(label, size);\n        }\n        if(c == 'D'){\n            int label; cin >> label;\n            file_system.del(label);\n        }\n        if(c == 'R'){\n            int pointer; cin >> pointer;\n            file_system.read(pointer);\n        }\n    }\n}\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout.precision(10);\n    \n    int N;\n    while(cin>>N, N){\n        solve(N);\n        cout << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <utility>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\nlist<pair<int, int> > lis;\n\ninline void Write() {\n\tint l, s;\n\tcin >> l >> s;\n\n\tFOR(it, lis) {\n\t\tif(it->second == -1) {\n\t\t\tif(it->first > s) {\n\t\t\t\tit->first -= s;\n\t\t\t\tlis.insert(it, make_pair(s, l));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(it->first == s) {\n\t\t\t\tit->second = l;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tit->second = l;\n\t\t\t\ts -= it->first;\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void Delete() {\n\tint l;\n\tcin >> l;\n\n\tFOR(it, lis) {\n\t\tif(it->second == l)\n\t\t\tit->second = -1;\n\t}\n}\n\ninline void Read() {\n\tint p;\n\tcin >> p;\n\n\tint cnt = 0;\n\tFOR(it, lis) {\n\t\tcnt += it->first;\n\t\tif(cnt >= p + 1) {\n\t\t\tcout << it->second << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tlis.clear();\n\t\tlis.push_back(make_pair(1000000001, -1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tchar ope;\n\t\t\tcin >> ope;\n\n\t\t\tswitch(ope) {\n\t\t\tcase 'W':\n\t\t\t\tWrite();\n\t\t\t\tbreak;\n\t\t\tcase'D':\n\t\t\t\tDelete();\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\tRead();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct data{\n\tint lid,rid;\n\tint id;\n\tint l,r;\n\tdata(){}\n\tdata(int iid,int ll,int rr,int lll,int rrr){\n\t\tid=iid;\n\t\tlid=ll;\n\t\trid=rr;\n\t\tl=lll;\n\t\tr=rrr;\n\t}\n};\n\nvector<data> dat;\nmap<int,int> id;\nvector<int> iddata;\nvector<int> place[10001];\nint n;\nint st,en;\n\nint main(void){\n\twhile(1){\n\t\tdat.clear();\n\t\tid.clear();\n\t\tiddata.clear();\n\t\tfor(int i=0;i<=10000;i++)place[i].clear();\n\t\tst=-1;\n\t\ten=-1;\n\t\tscanf(\"%d%*c\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar c;\n\t\t\tscanf(\"%c\",&c);\n\t\t\tif(c=='W'){\n\t\t\t\tint l,s;\n\t\t\t\tscanf(\"%d %d%*c\",&l,&s);\n\t\t\t\tif(id.find(l)==id.end()){\n\t\t\t\t\tid[l]=iddata.size();\n\t\t\t\t\tiddata.push_back(l);\n\t\t\t\t}\n\t\t\t\tif((dat.size()==0 || st==-1)){\n\t\t\t\t\tdat.push_back(data(id[l],-1,-1,0,s));\n\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t}else{\n\t\t\t\t\tint v=0;\n\t\t\t\t\tint nv=st;\n\t\t\t\t\tif(dat[st].l>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],-1,st,0,min(s,dat[st].l)));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[st].lid=dat.size()-1;\n\t\t\t\t\t\ts-=min(s,dat[st].l);\n\t\t\t\t\t\tst=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\twhile(s>0 && nv!=-1){\n\t\t\t\t\t\tif(dat[nv].l!=dat[dat[nv].lid].r){\n\t\t\t\t\t\t\tdat.push_back(data(id[l],dat[nv].lid,nv,dat[dat[nv].lid].r,dat[dat[nv].lid].r+min(s,dat[nv].l-dat[dat[nv].lid].r)));\n\t\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\t\ts-=min(s,dat[nv].l-dat[dat[nv].lid].r);\n\t\t\t\t\t\t\tdat[dat[nv].lid].rid=dat.size()-1;\n\t\t\t\t\t\t\tdat[nv].lid=dat.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t}\n\t\t\t\t\tif(s>0){\n\t\t\t\t\t\tdat.push_back(data(id[l],en,-1,dat[en].r,dat[en].r+s));\n\t\t\t\t\t\tplace[id[l]].push_back(dat.size()-1);\n\t\t\t\t\t\tdat[en].rid=dat.size()-1;\n\t\t\t\t\t\ten=dat.size()-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tscanf(\"%d%*c\",&l);\n\t\t\t\tif(id.find(l)==id.end())continue;\n\t\t\t\tfor(int i=0;i<place[id[l]].size();i++){\n\t\t\t\t\tdata d=dat[place[id[l]][i]];\n\t\t\t\t\tif(d.lid==-1)st=d.rid;\n\t\t\t\t\tif(d.rid==-1)en=d.lid;\n\t\t\t\t\tdat[d.rid].lid=d.lid;\n\t\t\t\t\tdat[d.lid].rid=d.rid;\n\t\t\t\t}\n\t\t\t\tplace[id[l]].clear();\n\t\t\t}\n\t\t\tif(c=='R'){\n\t\t\t\tint p;\n\t\t\t\tscanf(\"%d%*c\",&p);\n\t\t\t\tint nv=st;\n\t\t\t\tif(nv!=-1){\n\t\t\t\t\twhile(dat[nv].r<=p){\n\t\t\t\t\t\tnv=dat[nv].rid;\n\t\t\t\t\t\tif(nv==-1)break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(nv!=-1)printf(\"%d\\n\",(dat[nv].l<=p && p<dat[nv].r)?iddata[dat[nv].id]:-1);\n\t\t\t\telse printf(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tif(id.size()>=1000)return 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nstruct segment{\n    segment *next, *file;\n    int id, head, length;\n};\n\nsegment S[20000];\nsegment *head, *blank;\n\nsegment* newseg(){\n    blank->next=NULL;\n    blank->file=NULL;\n    blank->id=-1;\n    blank->head=-1;\n    blank->length=-1;\n    return blank++;\n}\n\nvoid W(int I, int S){\n    segment *p=head, *last;\n    while(S){\n        while(p->id!=-1) p=p->next;\n        if(p->length>S){\n            p->id=I;\n            segment *b=newseg();\n            b->next=p->next;\n            p->next=b;\n            b->head=p->head+S;\n            b->length=p->length-S;\n            p->length=S;\n            S=0;\n            if(last!=NULL)last->file=p;\n        }else{\n            p->id=I;\n            S-=p->length;\n            if(last!=NULL)last->file=p;\n            last=p;\n            p=p->next;\n        }\n    }\n    return;\n}\n\nvoid D(int I){\n    segment *p=head;\n    while(p->id!=I) p=p->next;\n    while(p!=NULL){\n        p->id=-1;\n        p=p->file;\n    }\n    return;\n}\n\nvoid R(int P){\n    segment *p=head;\n    while(p!=NULL){\n        if(p->head<=P && P<p->head+p->length){\n            cout<<p->id<<endl;\n            return;\n        }else{\n            p=p->next;\n        }\n    }\n}\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        for(int i=0;i<20000;i++){\n            S[i].next=S[i].file=NULL;\n            S[i].id=S[i].head=S[i].length=-1;\n        }\n        blank=&S[1];\n        head=&S[0];\n        head->id=-1;\n        head->head=0;\n        head->length=1000000001;\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>c;\n            int I,S,P;\n            switch(c){\n                case 'W':\n                    cin>>I>>S;\n                    // cout<<'W'<<' '<<I<<' '<<S<<endl;\n                    W(I,S);\n                    break;\n                case 'D':\n                    cin>>I;\n                    // cout<<'D'<<' '<<I<<endl;\n                    D(I);\n                    break;\n                case 'R':\n                    cin>>P;\n                    // cout<<'R'<<' '<<P<<endl;\n                    R(P);\n                    break;\n                default:\n                    break;\n            }\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n//#include <cstdio>\n//#include <iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n//#include <string>//\"reverse(s's it,s's it)\"\n//#include <functional>//\"greater<T>\" \"sort(a,a+n,greater<int>());\"\"\n//#include <cmath>//\"abs\" \"sqrt\"\n//#include <numeric>//\"accumulate(inputit,inputit,init,(optional) object)\"\n//#include <algorithm>//\"lower_bound(it,it,v)\" \"next_permutation(a,a+n)\"\n//\"reverse(v's it,v's it)\"(v: vector)\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\n#define ps push//TMP//stack,(priority) queue,\n#define fr front//TMP//queue//for priority, use top().\n\nstruct seg{\n\tint l,r,id;\n};\n\nconst int inf=1000000001;\n\nvoid solve(int q){\n\tlist<seg> l;\n\tl.pb((seg){0,inf,-1});\n\twhile((q--)>0){\n\t\tchar C;\n\t\tcin>>C;\n\t\tif(C=='W'){\n\t\t\tint i,s;\n\t\t\tcin>>i>>s;\n\t\t\tfor(list<seg>::iterator it=l.begin();it!=l.end();++it) if((*it).id==-1){\n\t\t\t\t(*it).id=i;\n\t\t\t\tif((*it).r-(*it).l>=s){\n\t\t\t\t\tif((*it).r-(*it).l>s){\n\t\t\t\t\t\tlist<seg>::iterator nit=it;\n\t\t\t\t\t\t++nit;\n\t\t\t\t\t\tl.is(nit,(seg){(*it).l+s,(*it).r,-1});\n\t\t\t\t\t\t(*it).r=(*it).l+s;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}else s-=((*it).r-(*it).l);\n\t\t\t}\n\t\t}else if(C=='D'){\n\t\t\tint i;\n\t\t\tcin>>i;\n\t\t\tfor(list<seg>::iterator it=l.begin();it!=l.end();++it) if((*it).id==i) (*it).id=-1;\t\t\t\n\t\t}else{//if(C=='R')\n\t\t\tint p;\n\t\t\tcin>>p;\n//\t\t\tfor(list<seg>::iterator it=l.begin();it!=l.end();++it){\n//\t\t\t\tcout<<\"segment: from \"<<(*it).l<<\" to \"<<(*it).r<<\", id: \"<<(*it).id<<endl;\n//\t\t\t}\n\t\t\tfor(list<seg>::iterator it=l.begin();it!=l.end();++it) if((*it).r>p){\n\t\t\t\tcout<<(*it).id<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<endl;\n}\n\nint main(){\n\twhile(true){\n\t\tint q;\n\t\tcin>>q;\n\t\tif(q>0) solve(q);\n\t\telse break;\n\t}\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<pint> vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9;\n\nint main(void){\n\twhile(1){\n\t\tint n; cin >> n;\n\t\tif(n == 0) break;\n\t\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\t\tq.push(make_pair(0, INF));\n\t\tmap<int, vpint> m;\n\t\trep(i, n){\n\t\t\tchar c; cin >> c;\n\t\t\tif(c == 'W'){\n\t\t\t\tint num, size; cin >> num >> size;\n\t\t\t\twhile(size > 0){\n\t\t\t\t\tint l = q.top().fi, r = q.top().se;\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(r - l + 1 >= size){//??????\n\t\t\t\t\t\tq.push(make_pair(l + size, r));\n\t\t\t\t\t\tm[num].push_back(make_pair(l, l + size - 1));\n\t\t\t\t\t\tsize = 0;\n\t\t\t\t\t}else{//?¶??????????\n\t\t\t\t\t\tm[num].push_back(make_pair(l, r));\n\t\t\t\t\t\tsize -= (r - l + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(c == 'D'){\n\t\t\t\tint num; cin >> num;\n\t\t\t\tfor(auto u : m[num]){\n\t\t\t\t\tq.push(make_pair(u.fi, u.se));\n\t\t\t\t}\n\t\t\t\tm[num].erase(all(m[num]));\n\t\t\t}else{\n\t\t\t\tint idx; cin >> idx;\n\t\t\t\tbool flag = false;\n\t\t\t\teach(it, m){\n\t\t\t\t\tauto key = it->fi;\n\t\t\t\t\tauto v = it->se;\n\t\t\t\t\tfor (int i = 0; i < v.size(); ++i){\n\t\t\t\t\t\tif(v[i].fi <= idx && idx <= v[i].se){\n\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(flag) break;\n\t\t\t\t}\n\t\t\t\tif(!flag){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n */\n#include <iostream>\n#include <algorithm>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n// init\n\n// input\nint iN;\nchar cC; // 0 <= N <= 100,000\nint iI; // 1 <= P <= 100\nint iS; // 1 <= P <= 100\nint iP; // 1 <= P <= 100\n\n// manage\n\n// ú»\nvoid init() {\n}\n\n// üÍ\nbool input() {\n  scanf(\"%d\", &iN);\n  if (iN == 0)\n    return false;\n  return true;\n}\n\n// \nvoid manage() {\n  int i;\n  list<P> lis;\n  list<P>::iterator it; // Ce[^\n  P p;\n  for (i = 0; i < iN; i++) {\n    scanf(\" %c\", &cC);\n\n    if (cC == 'W') {\n      scanf(\"%d %d\", &iI, &iS);\n      it = lis.begin();\n      while (iS != 0) { // listÌöÜÅ\n        if (it == lis.end()) {\n          lis.push_back(P(iI, iS));\n          break;\n        }\n        if (it->first == -1) {\n          it->first = iI;\n          iS -= it->second;\n        }\n        it++;\n      }\n      continue;\n    }\n\n    if (cC == 'D') {\n      scanf(\"%d\", &iI);\n      it = lis.begin();\n      while (it != lis.end()) { // listÌöÜÅ\n        if (it->first == iI) {\n          it->first = -1;\n        }\n        it++;\n      }\n\n      continue;\n    }\n\n    if (cC == 'R') {\n      scanf(\"%d\", &iP);\n      it = lis.begin();\n      int sum = 0;\n      while (it != lis.end()) { // listÌöÜÅ\n        if (sum + it->second > iP)\n          break;\n        sum += it->second;\n        iP--;\n        it++;\n      }\n      if (it != lis.end()) {\n        printf(\"%d\\n\", it->first);\n      } else {\n        printf(\"-1\\n\");\n      }\n      continue;\n    }\n\n  }\n\n}\n\n// oÍ\nvoid output() {\nprintf(\"\\n\");\n}\n\n// mizoSâ¤Ê\nint main() {\ninit(); // ú»\nwhile (1) {\n  if (!input())\n    break; // üÍ + I¹»è\n  manage(); // \n  output(); // oÍ\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nvoid solve(int n){\n\tvector<P> vec;\n\tfor(int i = 0;i < n;i++){\n\t\tchar c;\n\t\tint x,y;\n\t\tcin >> c >> x;\n\t\tif(c == 'W'){\n\t\t\tcin >> y;\n\t\t\tint pos = -1,l;\n\t\t\tfor(int j = 0;j < vec.size();j++){\n\t\t\t\tif(vec[j].first == -1){\n\t\t\t\t\tvec[j].first = x;\n\t\t\t\t\tif(y >= vec[j].second) y -= vec[j].second;\n\t\t\t\t\telse{\n\t\t\t\t\t\tpos = j;\n\t\t\t\t\t\tl = vec[j].second - y;\n\t\t\t\t\t\tvec[j].second = y;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!y) break;\n\t\t\t}\n\t\t\tif(pos != -1) vec.emplace(vec.begin() + pos + 1,-1,l);\n\t\t\tif(y) vec.emplace_back(x,y);\n\t\t}else if(c == 'D'){\n\t\t\tfor(auto &p : vec){\n\t\t\t\tif(p.first == x) p.first = -1;\n\t\t\t}\n\t\t}else{\n\t\t\tint ans = -1;\n\t\t\tfor(auto p : vec){\n\t\t\t\tx -= p.second;\n\t\t\t\tif(x < 0){\n\t\t\t\t\tans = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\tcout << endl;\n}\n\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tsolve(n);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n#define int ll\nstruct st{\n    int first,second,ident;\n    bool operator < (st obj) const{\n        return this->second < obj.second;\n    }\n};\n\nsigned main(){\n    int n;\n    while(cin>>n&&n){\n        set<pii> free;\n        set<st> used;\n        free.insert(pii(0,1e9+1));\n        rep(i,n){\n            char ch;\n            cin>>ch;\n            if(ch=='W'){\n                int num,len;\n                cin>>num>>len;\n                while(len>0){\n                    pii tmp = *(free.begin());\n                    free.erase(free.begin());\n                    if(tmp.second-tmp.first<=len){  //????????????\n                        len -= tmp.second-tmp.first;\n                        used.insert(st{tmp.first,tmp.second,num});\n                    }\n                    else{                           //????????????????????????\n                        used.insert(st{tmp.first,tmp.first+len,num});\n                        free.insert(pii(tmp.first+len,tmp.second));\n                        len = 0;\n                    }\n                }\n            }\n            if(ch=='D'){\n                int num;\n                cin>>num;\n                auto itr = used.begin();\n                while (itr != used.end()) {\n                    if (itr->ident==num) {\n                        st tmp = *itr;\n                        free.insert(pii(tmp.first,tmp.second)); //??????????£?\n                        itr = used.erase(itr);\n                    }\n                    else {\n                        itr++;\n                    }\n                }\n            }\n            if(ch=='R'){\n                int pos;\n                cin>>pos;\n                auto res = used.upper_bound(st{0,pos,0});\n                if(res==used.end())cout<<\"-1\"<<endl;\n                else{\n                    st tmp = *(res);\n                    cout<<tmp.ident<<endl;\n                }\n            }\n        }\n        cout<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nvector<pi> v;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tint N;\n\twhile(cin>>N && N){\n\t\tv.clear();\n\t\tv.pb(mp(-1,INF));\n\t\trep(i,N){\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\t\n\t\t\tif(c=='W'){\n\t\t\t\tint l,S;\n\t\t\t\tcin>>l>>S;\n\t\t\t\tvector<pi> w;\n\t\t\t\trep(i,sz(v)){\n\t\t\t\t\tif(v[i].fir==-1){\n\t\t\t\t\t\tif(S==0){\n\t\t\t\t\t\t\tw.pb(v[i]);\n\t\t\t\t\t\t}else if(S<=v[i].sec){\n\t\t\t\t\t\t\tw.pb(mp(l,S));\n\t\t\t\t\t\t\tw.pb(mp(-1,v[i].sec-S));\n\t\t\t\t\t\t\tS=0;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tw.pb(mp(l,v[i].sec));\n\t\t\t\t\t\t\tS-=v[i].sec;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tw.pb(v[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv=w;\n\t\t\t}\n\t\t\t\n\t\t\tif(c=='D'){\n\t\t\t\tint l;\n\t\t\t\tcin>>l;\n\t\t\t\tvector<pi> w;\n\t\t\t\trep(i,sz(v)){\n\t\t\t\t\tif(v[i].fir==l){\n\t\t\t\t\t\tw.pb(mp(-1,v[i].sec));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tw.pb(v[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv=w;\n\t\t\t}\n\t\t\t\n\t\t\tif(c=='R'){\n\t\t\t\tint P;\n\t\t\t\tcin>>P;\n\t\t\t\trep(i,sz(v)){\n\t\t\t\t\tif(P<=v[i].sec-1){\n\t\t\t\t\t\tcout<<v[i].fir<<endl;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tP-=v[i].sec;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152&lang=jp\nusing namespace std;\ntypedef pair<int,int> pii;\n#define MAX 1000000000\n\npriority_queue<pii, vector<pii>, greater<pii>> emp_secta;\nmap<int, vector<pii>> sectas;\nvoid Write(int l,int S) {\n\twhile (S) {\n\t\tauto q = emp_secta.top(); emp_secta.pop();\n\t\tint lx = q.first, rx = q.second;\n\t\tif (rx - lx + 1 == S ) {\n\t\t\tsectas[l].push_back(pii(lx, rx));\n\t\t\tS = 0;\n\t\t}\n\t\telse if(rx - lx + 1 > S) {\n\t\t\tsectas[l].push_back(pii(lx, lx + S - 1));\n\t\t\temp_secta.push(pii(lx + S, rx));\n\t\t\tS = 0;\n\t\t}\n\t\telse {\n\t\t\tsectas[l].push_back(pii(lx, rx));\n\t\t\tS -= (rx - lx + 1);\n\t\t}\n\t}\n}\n\nvoid Delete(int l) {\n\tfor (auto e : sectas[l]) {\n\t\temp_secta.push(pii(e.first, e.second));\n\t}\n\tsectas[l].clear();\n}\n\nvoid Refer(int P,int cnt) {\n\tfor (int i = 0; i < cnt;i++) {\n\t\tfor (auto e : sectas[i]) {\n\t\t\tif (P >= e.first && P <= e.second) {\n\t\t\t\tcout << i << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tsectas.clear();\n\t\tpriority_queue<pii, vector<pii>, greater<pii>> temp;\n\t\tswap(emp_secta, temp);\n\t\temp_secta.push(pii(0,MAX));\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tchar command; cin >> command;\n\t\t\tif (command == 'W') {\n\t\t\t\tcnt++;\n\t\t\t\tint l, S; cin >> l >> S;\n\t\t\t\tWrite(l, S);\n\t\t\t}\n\t\t\tif (command == 'D') {\n\t\t\t\tint l; cin >> l;\n\t\t\t\tDelete(l);\n\t\t\t}\n\t\t\tif (command == 'R') {\n\t\t\t\tint P; cin >> P;\n\t\t\t\tRefer(P, cnt);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fr first\n#define sc second\n#define NON -1\ntypedef pair < int , int > Pi;\ntypedef pair < Pi , int > Pii;\nvector< Pii > memory; //セクタの状態\nvoid write( int l, int sum){ //書き込む\n  for(int i = 0; sum > 0 ; i++){\n    if(memory[i].sc != NON) continue;\n    int kazu = memory[i].fr.sc - memory[i].fr.fr + 1;\n    if(kazu <= sum){\n      memory[i].sc = l, sum -= kazu;\n    }else{\n      memory.insert( memory.begin() + i, Pii( Pi( memory[i].fr.fr, memory[i].fr.fr + sum - 1), l));\n      memory[++i].fr.fr = memory[i - 1].fr.sc + 1;\n      sum = 0;\n    }\n  }\n}\nvoid erase( int idx){ //消す\n  for(int i = 0; i < memory.size() ; i++){\n    if(memory[i].sc == idx) memory[i].sc = NON;\n  }\n}\nvoid read( int idx){ //読み込む\n  int pos = 0;\n  while(memory[pos].fr.sc < idx) pos++;\n  cout << memory[pos].sc << endl;\n}\n\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    memory.clear();\n    memory.push_back( Pii( Pi( 0, 1000000001), NON));\n    while(n--){\n      char buff;\n      cin >> buff;\n      if(buff == 'W'){ //write\n        int a, b;\n        cin >> a >> b;\n        write(a,b);\n      }else if(buff == 'D'){ //delete\n        int a;\n        cin >> a;\n        erase(a);\n      }else{ //read\n        int a;\n        cin >> a;\n        read(a);\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <list>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n\nusing interval = std::pair<size_t, size_t>;\nusing disk_type = std::list<std::pair<interval, size_t>>;\n\nvoid write(disk_type& disk, size_t id, size_t size) {\n  size_t last = 0;\n  auto it = disk.begin();\n  while (size > 0) {\n    size_t s, e;\n    std::tie(s, e) = it->first;\n    if (last < s) {\n      size_t s0 = last;\n      size_t e0 = std::min(s0+size, s);\n      interval p(s0, e0);\n      disk.emplace(it, p, id);\n      size -= e0-s0;\n    }\n    last = e;\n    ++it;\n  }\n}\n\nvoid delete_(disk_type& disk, size_t id, size_t size) {\n  for (auto it = disk.begin(); it != disk.end();) {\n    if (size == 0) break;\n    if (it->second == id) {\n      it = disk.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}\n\nsize_t read(const disk_type& disk, size_t id) {\n  for (auto it = disk.begin(); it != disk.end(); ++it) {\n    size_t s, e;\n    std::tie(s, e) = it->first;\n    if (s <= id && id < e) return it->second;\n    if (id < s) return -1;\n  }\n  return -1;\n}\n\nvoid inspect(const disk_type& disk) {\n  for (auto it = disk.begin(); it != disk.end(); ++it) {\n    fprintf(stderr, \"[%zu:%zu): %zu\\n\",\n            it->first.first, it->first.second, it->second);\n  }\n  fprintf(stderr, \"===\\n\");\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::map<size_t, size_t> sizes;\n  disk_type disk;\n  size_t inf = 2e9;\n  disk.emplace_back(std::make_pair(inf, inf), -1);\n  for (size_t i = 0; i < n; ++i) {\n    char cmd;\n    scanf(\" %c\", &cmd);\n\n    if (cmd == 'W') {\n      size_t id, size;\n      scanf(\"%zu %zu\", &id, &size);\n      write(disk, id, size);\n      sizes[id] = size;\n    } else if (cmd == 'D') {\n      size_t id;\n      scanf(\"%zu\", &id);\n      delete_(disk, id, sizes.at(id));\n      sizes.erase(id);\n    } else if (cmd == 'R') {\n      size_t index;\n      scanf(\"%zu\", &index);\n      size_t res = read(disk, index);\n      if (res+1 == 0) {\n        puts(\"-1\");\n      } else {\n        printf(\"%zu\\n\", res);\n      }\n    }\n  }\n\n  puts(\"\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct DATA{\n\tint start;\n\tint end;\n\tint fileID;\n\tDATA(int start, int end, int fileID){\n\t\tthis->start = start, this->end = end, this->fileID = fileID;\n\t}\n};\n\nvector<DATA> data;\n\nvoid Write(int fileID, int file_length)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(file_length <= data[i].end - data[i].start + 1){\n\t\t\t\tdata.insert(data.begin() + i, DATA(data[i].start, data[i].start + file_length - 1, fileID));\n\t\t\t\tdata[i+1].start = data[i+1].start + file_length;\n\t\t\t}else{\n\t\t\t\tdata[i].fileID = fileID;\n\t\t\t\tfile_length -= data[i].end - data[i].start + 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Arrange()\n{\n\tfor(int i = 0; i < (int)data.size()-1; i++){\n\t\tif(data[i].fileID == -1){\n\t\t\tif(data[i+1].fileID == -1){\n\t\t\t\tdata[i].end = data[i+1].end;\n\t\t\t\tdata.erase(data.begin() + (i+1));\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid Delete(int fileID)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].fileID == fileID) data[i].fileID = -1;\n\t}\n\tArrange();\n}\n\nvoid Reference(int pos)\n{\n\tint size = (int)data.size();\n\tfor(int i = 0; i < size; i++){\n\t\tif(data[i].end >= pos){\n\t\t\tprintf(\"%d\\n\", data[i].fileID);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint N;\n\tchar com[5];\n\tint op1, op2;\n\t\n\tscanf(\"%d\", &N);\n\tdata.push_back( DATA(0, 1000000001, -1) );\n\t\n\tfor(int i = 0; i < N; i++){\n\t\t\n\t\tscanf(\"%s\", com);\n\t\tif(strcmp(com, \"W\") == 0){\n\t\t\tscanf(\"%d %d\", &op1, &op2);\n\t\t\tWrite(op1, op2);\n\t\t}else if(strcmp(com, \"D\") == 0){\n\t\t\tscanf(\"%d\", &op1);\n\t\t\tDelete(op1);\n\t\t}else if(strcmp(com, \"R\") == 0){\n\t\t\tscanf(\"%d\", &op1);\n\t\t\tReference(op1);\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cassert>\n#include<stdint.h>\n#include<vector>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\nusing namespace std;\n\nconst uint64_t INF = 100000000000010;\n\nstruct List\n{\n  int identifier;\n  uint64_t range[2];// [range[0],range[1]]\n  bool hasNext,hasPrev;\n  List *prev;\n  List *next;\n  List(int identifier=inf,uint64_t r1=INF,uint64_t r2=INF):identifier(identifier)\n  {\n    range[0] = r1, range[1] = r2;\n    hasNext = hasPrev = false;\n  }\n};\n\nint N,I,S,P;\nchar c;\nList list;\n\nvoid list_walk(List *l)\n{\n  cout << '[' << l->range[0] << \",\" << l->range[1] << \" : \" << l->identifier << \"]\";\n  if(l->hasNext)list_walk(l->next);\n}\n\n\nvoid ddfs(List *l)\n{\n  if(l->hasNext)ddfs(l->next);\n  if(l->hasPrev)delete l;\n    \n}\n\nvoid init()\n{\n  if(list.hasNext)ddfs(&list);\n  list.hasNext = true;\n  list.hasPrev = false;\n  list.range[0] = list.range[1] = -1;\n  list.identifier = -1;\n  list.next = new List;\n  list.next->hasNext = false;\n  list.next->hasPrev = true;\n  list.next->range[0] = list.next->range[1] = INF;\n  list.next->identifier = inf;\n  list.next->prev = &list;\n  //cout << \"test : \" << list.next->prev->identifier << endl;\n  //cout << \"test : \" << list.next->identifier << endl;\n}\n\nvoid dfsW(List *l)\n{\n  if(!l->hasNext)\n    {\n      cout << \"S = \" << S << endl;\n      list_walk(&list);\n      assert(false);\n      return;\n    }\n\n  uint64_t v1 = l->range[1];\n  uint64_t v2 = l->next->range[0];\n  //cout << \"v1 = \" << v1 << \" v2 = \" << v2 << endl;\n  uint64_t diff = v2-v1-1;\n  //cout << \"diff = \" << diff << endl;\n  //assert(diff >= 0);\n  if(diff)\n    {\n      List *node = new List;\n      node->identifier = I;\n      node->hasNext = node->hasPrev = true;\n      node->next = l->next;\n      node->prev = l;\n      l->next->prev = node;\n      l->next = node;\n\n      node->range[0] = v1+1;\n      if(S <= diff)\n\t{\n\t  node->range[1] = node->range[0] + S - 1;\n\t  S = 0;\n\t}\n      else if(S > diff)\n\t{\n\t  node->range[1] = node->range[0] + diff - 1;\n\t  S -= diff;\n\t}\n    \n    }  \n\n  if(S > 0)dfsW(l->next);\n}\n\nvoid compute_W()\n{\n  dfsW(&list);\n}\n\nvoid dfsD(List *l)\n{\n  if(l->identifier == I)\n    {\n      l->next->prev = l->prev;\n      l->prev->next = l->next;\n      delete l;\n    }\n  if(l->hasNext)dfsD(l->next);\n}\n\nvoid compute_D()\n{\n  dfsD(&list);\n}\n\nvoid dfsR(List *l)\n{\n  if(l->range[0] <= P && P <= l->range[1])\n    {\n      cout << l->identifier << endl;\n    }\n  else\n    {\n      if(l->hasNext)dfsR(l->next);\n      else cout << -1 << endl;\n    }\n}\n\nvoid compute_R()\n{\n  dfsR(&list);\n}\n\n\nint main()\n{\n  bool f = true;\n  while(cin >> N,N)\n    {\n      if(!f)cout << endl;\n      f = false;\n      init();\n      rep(_,N)\n\t{\n\t  cin >> c;\n\t  if(c == 'W')cin >> I >> S,compute_W();\n\t  if(c == 'D')cin >> I,compute_D();\n\t  if(c == 'R')cin >> P,compute_R();\n\t  //list_walk(&list);cout << endl;\n\t}\n      //list_walk(&list);cout << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nlist<pair<int,int> > a;\nint main(){\n  int h,i,j;\n  int n,p,q;\n  char c;\n  list<pair<int,int> >::iterator it;\n  h=0;\n  while(cin>>n&&n){\n    if(h)\n      cout<<endl;\n    else\n      h=1;\n    a.clear();\n    a.push_back(make_pair(-1,1000000000));\n    for(i=0;i<n;i++){\n      cin>>c;\n      if(0){\n      }else if(c=='W'){\n\tcin>>p>>q;\n\tfor(it=a.begin();q;it++){\n\t  if((*it).first==-1){\n\t    if(0){\n\t    }else if((*it).second<q){\n\t      (*it).first=p;\n\t      q-=(*it).second;\n\t    }else if((*it).second>q){\n\t      (*it).second-=q;\n\t      a.insert(it,make_pair(p,q));\n\t      q=0;\n\t    }else{\n\t      (*it).first=p;\n\t      q=0;\n\t    }\n\t  }\n\t}\n      }else if(c=='D'){\n\tcin>>p;\n\tfor(it=a.begin();it!=a.end();it++){\n\t  if((*it).first==p)\n\t    (*it).first=-1;\n\t}\n      }else if(c=='R'){\n\tcin>>p;\n\tj=1;\n\tfor(it=a.begin();;it++){\n\t  if(j<=p&&p<j+(*it).second){\n\t    cout<<(*it).first<<endl;\n\t    break;\n\t  }\n\t  j+=(*it).second;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  \n  int N;\n  while(cin >> N, N){\n\t// nuse[left] = width\n\tmap<int,int> nuse;\n\tnuse.insert(MP(0,1000000100));\n\t// use[left] = (width, id)\n\tmap<int,PII> use;\n\t// idx[id] = {left_1, left_2, ...}\n\tmap<int, VI> idx;\n\tREP(i,N){//cout<<i<<endl;\n\t  char q; int a, b;\n\t  cin >> q;\n\t  switch(q){\n\t  case 'W':\n\t\tcin >> a >> b;\n\t\twhile(b > 0){\n\t\t  auto it = nuse.begin();\n\t\t  int w = min(b, it->second);\n\t\t  use[it->first] = MP(w, a);\n\t\t  idx[a].PB(it->first);\n\t\t  if(it->second > b)\n\t\t\tnuse[it->first+b+1] =  it->second - b;\n\t\t  nuse.erase(it);\n\t\t  b -= w;\n\t\t}\n\t\tbreak;\n\t  case 'D':\n\t\tcin >> a;\n\t\tfor(int left: idx[a]){\n\t\t  auto it = use.find(left);\n\t\t  nuse[left] = it->second.first;\n\t\t  use.erase(it);\n\t\t}\n\t\tidx[a].clear();\n\t\tbreak;\n\t  case 'R':\n\t\tcin >> a;\n\t\tauto up = use.upper_bound(a);\n\t\tif(up != use.begin()) --up;\n\t\tif(up->first <= a && a <= up->first + up->second.first)\n\t\t  cout << up->second.second << endl;\n\t\telse\n\t\t  cout << -1 << endl;\n\t\t  \n\t\tbreak;\t\t\n\t  }\n\t  /*\n\t  for(auto& ppii: use){\n\t\tcout << ppii.first << \" - \" << ppii.second.first << \": \" << ppii.second.second << endl;\n\t  }cout << endl;\n\t  */\n\t}\n\tcout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Data\n{\npublic:\n    int a, b, id;\n    Data(int a0, int b0, int id0){\n        a = a0;\n        b = b0;\n        id = id0;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        list<Data> x;\n        x.push_back(Data(-1,-1, -1));\n        x.push_back(Data(1000000001, 1000000001, -1));\n\n        while(--n >= 0){\n            char c;\n            cin >> c;\n\n            if(c == 'W'){\n                int id, s;\n                cin >> id >> s;\n                list<Data>::iterator it = x.begin();\n                while(s > 0){\n                    list<Data>::iterator it2 = it;\n                    ++ it2;\n                    int len = it2->a - it->b - 1;\n                    if(len > 0){\n                        x.insert(it2, Data(it->b+1, it->b+min(s,len), id));\n                        s -= min(s, len);\n                    }\n                    it = it2;\n                }\n            }else if(c == 'D'){\n                int id;\n                cin >> id;\n                list<Data>::iterator it = x.begin();\n                while(it != x.end()){\n                    if(it->id == id)\n                        it = x.erase(it);\n                    else\n                        ++ it;\n                }\n            }else{\n                int p;\n                cin >> p;\n                list<Data>::iterator it = x.begin();\n                while(p > it->b)\n                    ++ it;\n\n                if(p >= it->a)\n                    cout << it->id << endl;\n                else\n                    cout << -1 << endl;\n            }\n        }\n\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\nusing namespace std;\nvoid solve(int T){\n\tmap<pair<int,int>,int>m;\n\tchar cmd[2];\n\tint n;\n\tfor(;T--;){\n\t\tscanf(\"%s%d\",cmd,&n);\n\t\tif(*cmd=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();){\n\t\t\t\tif(it->second==n){\n\t\t\t\t\tauto it2=it;\n\t\t\t\t\t++it;\n\t\t\t\t\tm.erase(it2);\n\t\t\t\t}else{\n\t\t\t\t\t++it;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(*cmd=='R'){\n\t\t\tpair<int,int> f={n,2000000000};\n\t\t\tauto it=m.lower_bound(f);\n\t\t\tif(it==m.begin()){\n\t\t\t\tputs(\"-1\");\n\t\t\t}else{\n\t\t\t\t--it;\n\t\t\t\tprintf(\"%d\\n\",it->first.first<=n&&n<=it->first.second ? it->second : -1);\n\t\t\t}\n\t\t}else if(*cmd=='W'){\n\t\t\tint z;\n\t\t\tscanf(\"%d\",&z);\n\t\t\tint cur=0;\n\t\t\tfor(auto it=m.begin();it!=m.end();++it){\n\t\t\t\tint d=it->first.first-cur;\n\t\t\t\tif(d>z)d=z;\n\t\t\t\tif(d)m[{cur,cur+d-1}]=n;\n\t\t\t\tz-=d;\n\t\t\t\tif(z==0)break;\n\t\t\t\tcur=it->first.second+1;\n\t\t\t}\n\t\t\tif(z)m[{cur,cur+z-1}]=n;\n\t\t}\n\t}\n}\nint main(){for(int T;~scanf(\"%d\",&T)&&T;puts(\"\"))solve(T);}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T;scanf(\"%d\",&T),T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tchar C[2];\n\tint n,k;\n\tfor(;T--&&scanf(\"%s%d\",C,&n);;){\n\t\tif(*C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else ++it;\n\t\t}else if(*C=='R'){\n\t\t\tauto it=m.lower_bound(make_pair(n,2000000000));\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n?-1:it->second);\n\t\t}else if(*C=='W'){\n\t\t\tint c=!scanf(\"%d\",&k),d;\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<(int)N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\n#define F first\n#define S second\nusing namespace std;\nconst int inf=1e9;\n\nstruct RF{\n\tint id,from,to;\n};\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tvector<RF> seg;\n\t\tseg.push_back({-1,0,inf});\n\t\tREP(i,0,N){\n\t\t\tchar c;\n\t\t\tint id,num;\n\t\t\tcin>>c;\n\t\t\tif(c=='W'){\n\t\t\t\tcin>>id>>num;\n\t\t\t\tint i=0;\n\t\t\t\twhile(num>0){\n\t\t\t\t\tif(seg[i].id==-1){\n\t\t\t\t\t\tint from=seg[i].from,to=seg[i].to;\n\t\t\t\t\t\tif(to-from+1<=num){\n\t\t\t\t\t\t\tseg[i].id=id;\n\t\t\t\t\t\t\tnum-=to-from+1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tseg[i]={id,from,from+num-1};\n\t\t\t\t\t\t\tseg.insert(seg.begin()+i+1,{-1,from+num,to});\n\t\t\t\t\t\t\tnum=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t//for(auto v:seg){\n\t\t\t\t\t//cout<<v.id<<\" \"<<v.from<<\" \"<<v.to<<endl;\n\t\t\t\t//}\n\t\t\t}else if(c=='D'){\n\t\t\t\tcin>>id;\n\t\t\t\tREP(i,0,seg.size()){\n\t\t\t\t\tif(seg[i].id==id) seg[i].id=-1;\n\t\t\t\t}\n\t\t\t}else if(c=='R'){\n\t\t\t\tcin>>num;\n\t\t\t\tfor(auto v:seg){\n\t\t\t\t\tif(ck(num,v.from,v.to)){\n\t\t\t\t\t\tp(v.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstatic const int N = 1000000001;\n\nint n;\nvector<pair<int, int> > sec;\n\nmain(){\n  while(cin >>n && n){\n    sec.clear();\n    sec.push_back(make_pair(-1, N));\n    for(int i=0;i<n;i++){\n      /*for(int j=0;j<sec.size();j++){\n        cout << \"(\" << sec[j].first << \",\" << sec[j].second << \"), \";\n      }\n      cout << endl;*/\n      char op;\n      cin >> op;\n      if(op == 'W'){\n        int a, b;\n        cin >> a >> b;\n        vector<pair<int, int> >::iterator ite;\n        for(ite=sec.begin();ite!=sec.end();ite++){\n          if(ite->first == -1){\n            ite->first = a;\n            if(b > ite->second) b -= ite->second;\n            else if(b == ite->second) break;\n            else{\n              int tmp = ite->second - b;\n              ite->second = b;\n              ite++;\n              sec.insert(ite, make_pair(-1, tmp));\n              break;\n            }\n          }\n        }\n      }else if(op == 'R'){\n        int in;\n        cin >> in;\n        int p = -1;\n        for(int j=0;j<sec.size();j++){\n          p += sec[j].second;\n          if(p >= in){\n            cout << sec[j].first << endl;\n            break;\n          }\n        }\n      }else if(op == 'D'){\n        int in;\n        cin >> in;\n        for(int j=0;j<sec.size();j++) if(sec[j].first == in) sec[j].first = -1;\n      }\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n\nstruct st{\n    int first,second,ident;\n    bool operator < (st obj) const{\n        return this->second < obj.second;\n    }\n};\n\nsigned main(){\n    int n;\n    while(cin>>n&&n){\n        set<pii> free;\n        set<st> used;\n        free.insert(pii(0,1e9+1));\n        rep(i,n){\n            char ch;\n            cin>>ch;\n            if(ch=='W'){\n                int num,len;\n                cin>>num>>len;\n                while(len>0){\n                    pii tmp = *(free.begin());\n                    free.erase(free.begin());\n                    if(tmp.second-tmp.first<=len){  //????????????\n                        len -= tmp.second-tmp.first;\n                        used.insert(st{tmp.first,tmp.second,num});\n                    }\n                    else{                           //????????????????????????\n                        used.insert(st{tmp.first,tmp.first+len,num});\n                        free.insert(pii(tmp.first+len,tmp.second));\n                        len = 0;\n                    }\n                }\n            }\n            if(ch=='D'){\n                int num;\n                cin>>num;\n                auto itr = used.begin();\n                while (itr != used.end()) {\n                    if (itr->ident==num) {\n                        st tmp = *itr;\n                        free.insert(pii(tmp.first,tmp.second));\n                        used.erase(itr++);\n                    }\n                    else itr++;\n                }\n            }\n            if(ch=='R'){\n                int pos;\n                cin>>pos;\n                auto res = used.upper_bound(st{0,pos,0});\n                if(res==used.end() || res->first>pos)cout<<\"-1\"<<endl;\n                else{\n                    st tmp = *(res);\n                    cout<<tmp.ident<<endl;\n                }\n            }\n        }\n        cout<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\nusing namespace std;\nint main(){for(int T,n,k,c,d,C;scanf(\"%d\",&T),T;puts(\"\")){\n\tmap<pair<int,int>,int>m;\n\tfor(;T--&&scanf(\"%s%d\",&C,&n);){\n\t\tif(C=='D'){\n\t\t\tfor(auto it=m.begin();it!=m.end();)if(it->second==n)m.erase(it++);else ++it;\n\t\t}else if(C=='R'){\n\t\t\tauto it=m.lower_bound({n,2000000000});\n\t\t\tprintf(\"%d\\n\",it==m.begin()||n<(--it)->first.first||it->first.second<n?-1:it->second);\n\t\t}else if(C=='W'){\n\t\t\tc=!scanf(\"%d\",&k);\n\t\t\tfor(auto it=m.begin();k&&it!=m.end();++it){\n\t\t\t\td=it->first.first-c;\n\t\t\t\tif(d>k)d=k;\n\t\t\t\tif(d)m.insert({{c,c+d-1},n});\n\t\t\t\tk-=d;\n\t\t\t\tc=it->first.second+1;\n\t\t\t}\n\t\t\tif(k)m.insert({{c,c+k-1},n});\n\t\t}\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define vecsize 16000000\nint vec[vecsize];\nvoid W(int x,int y){\n    for(int i=0;i<vecsize;++i){\n        if(y>0)if(vec[i]==-1)vec[i]=x,--y;\n    }\n}\nvoid D(int x){\n    int size=vecsize-1;\n    if(x<=size)for(int i=vecsize-1;i>=0;--i){\n        if(vec[i]==x){\n            vec[i]=-1;\n        }\n    }\n}\nint R(int x){\n    int size=vecsize;\n    if(x>size-1)return -1;\n    else return vec[x];\n}\nint main(){\n    int n;\n    bool b=true;\n    for(int i=0;i<vecsize;++i){\n        vec[i]=-1;\n    }\n    while(std::cin>>n,n!=0){\n        if(!b)std::cout<<std::endl;\n        while(n>0){\n            char cm;\n            int x,y;\n            std::cin>>cm>>x;\n            if(cm==0)return 0;\n            if(x<=1000000000)switch(cm){\n                case 'W':\n                    std::cin>>y;\n                    W(x,y);\n                    break;\n                case 'D':\n                    D(x);\n                    break;\n                case 'R':\n                    std::cout<<R(x)<<std::endl;\n                    break;\n            }\n            --n;\n        }\n        b=false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define SS 100000000\nint F[SS],R[SS];\nint main()\n{\n  int i,j,t=0,n,y,x;\n  char ch;\n  \n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(i=0;i<SS;i++){\n      F[i]=-1;\n    }\n    \n    for(i=0;i<n*2;i++){\n      scanf(\"%c\",&ch);\n      if(ch=='W'){\n        scanf(\"%d%d\",&x,&y);\n        for(j=0;y!=0;j++){\n          if(F[j]==-1){\n            F[j]=x;\n\t    y--;\n\t  }\n\t}\n      }\n      if(ch== 'D'){\n        scanf(\"%d\",&x);\n        for(j=0;j<SS;j++){\n          if(F[j]==x){\n\t    F[j]= -1;\n\t  }\n\t}\n      }\n      if(ch=='R'){\n        scanf(\"%d\",&x);\n        R[t]=F[x-1];\n        t++;\n      }\n    }\n    for(i=0;i<t;i++){\n      printf(\"%d\\n\",R[i]);\n    }\n    printf(\"\\n\");\n    t=0;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define SS 1000000000\nint F[SS],R[SS];\nint main()\n{\n  int i,j,t=0,n,y,x;\n  char ch;\n  \n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(i=0;i<SS;i++){\n      F[i]=-1;\n    }\n    \n    for(i=0;i<n*2;i++){\n      scanf(\"%c\",&ch);\n      if(ch=='W'){\n        scanf(\"%d%d\",&x,&y);\n        for(j=0;y!=0;j++){\n          if(F[j]==-1){\n            F[j]=x;\n\t    y--;\n\t  }\n\t}\n      }\n      if(ch== 'D'){\n        scanf(\"%d\",&x);\n        for(j=0;j<SS;j++){\n          if(F[j]==x){\n\t    F[j]= -1;\n\t  }\n\t}\n      }\n      if(ch=='R'){\n        scanf(\"%d\",&x);\n        R[t]=F[x-1];\n        t++;\n      }\n    }\n    for(i=0;i<t;i++){\n      printf(\"%d\\n\",R[i]);\n    }\n    printf(\"\\n\");\n    t=0;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2152\nTitle Restricted File SYSTEM\nRE\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct bd //block descriptor\n{\n        int start;\n        int size;\n        struct bd * nextp;\n} bds[10001];\nstruct bd * emptyblock;\nstruct bd * free_block;  // start ptr\nstruct fd //file descriptor\n{\n        int name;\n        struct bd * b;\n} fds[10001];\nstruct fd * last_fdp;\n\nint N;\nchar read_buf[30];\nstruct mcb\n{\n        int name;\n        int start;\n        int end;\n} mcbs[10001];\nint mcbcnt;\n//\nvoid dump_sector_memory()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n        int cnt;\n\n        cnt=0;\n        bdp=free_block;\n        do\n        {     \n                mcbs[cnt].name = -1;\n                mcbs[cnt].start=bdp->start;\n                mcbs[cnt].end  =bdp->start+bdp->size-1;\n                cnt++;\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                while(bdp)\n                {\n                        mcbs[cnt].name = fdp->name;\n                        mcbs[cnt].start=bdp->start;\n                        mcbs[cnt].end  =bdp->start+bdp->size-1;\n                        cnt++;\n                        bdp=bdp->nextp;\n                }\n        }\n        mcbcnt = cnt;\n}\n\nvoid dump_sector()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n     \n\n        printf(\"------------\\n\");\n        bdp=free_block;\n        do\n        {       printf(\"Free block:\");\n                printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                //if(bdp)\n                        while(bdp)\n                {\n                        printf(\"File:%d:\",fdp->name);\n                        printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                        bdp=bdp->nextp;\n                }\n                \n                \n        }\n}\nvoid copy_block(struct bd *src,struct bd *dst)\n{\n        memcpy(dst,src,sizeof(struct bd));\n}\n\nvoid write_command(int fname,int fsize)\n{\n        struct bd *bp,**bpp,*nextbp;\n        struct fd *filep;\n        int oldsize;\n\n\n        \n        filep=last_fdp++;\n        filep->name=fname;\n\n        bpp=&(filep->b);\n                        \n        while(1)\n        {\n                *bpp=free_block;\n                bp = free_block;\n                //printf(\"FSZ %d\\n\",fsize);\n                        \n                if(fsize <= bp->size)   //\n                {\n                        nextbp=bp->nextp;\n                        bp->nextp = NULL;\n                        oldsize   = bp->size;\n                        bp->size  = fsize;\n\n                        if(fsize < oldsize)   //split\n                        {\n                                copy_block(bp,emptyblock);\n                                free_block=emptyblock++;\n                                free_block->start = bp ->start +fsize;\n                                free_block->size  = oldsize    -fsize;\n                                free_block->nextp = nextbp;\n                                return;\n                        }\n                        else //just size\n                        {\n                                free_block=nextbp;\n                                break;\n                        }\n                }\n                else \n                {\n                        free_block=bp->nextp;     \n                        fsize -= bp->size;\n                        if(fsize > 0)\n                        {\n                                bpp=&(bp->nextp);\n                                continue;\n                        }\n                        return;\n                }\n        }\n}\nint compare_mcb(const void *x, const void *y)\n{\n        return ((struct mcb *)x)->start - ((struct mcb *)y)->start;\n}\n\nint read_command(int sector)\n{\n        int center,mini,maxi;\n\n        dump_sector_memory();\n        qsort(mcbs,mcbcnt,sizeof(struct mcb),compare_mcb);\n        mini=0;maxi=mcbcnt;\n        while(maxi-mini>1)\n        {\n                center=(maxi+mini)/2;\n#ifdef DEBUG\n                printf(\"R:%d C:%d %d\\n\",sector,\n                       mcbs[center].start,mcbs[center].end);\n#endif\n                if(mcbs[center].start > sector)\n                {\n                        maxi=(maxi+mini)/2;\n                }\n                else if(mcbs[center].end < sector)\n                {\n                        mini=(maxi+mini)/2;\n                }\n                else  //equal\n                {\n                        return(mcbs[center].name);\n                }\n        }\n        if(maxi-mini==1)\n        {\n                if(mcbs[maxi].start < sector)\n                        return(mcbs[maxi].name);\n                else\n                        return(mcbs[mini].name);\n        }\n        return(mcbs[center].name);\n}\nvoid release_block(struct bd * r_bdp)\n{\n        struct bd *bdp,*next_bdp,*prev_bdp;\n\n        bdp=free_block;\nLOOP:\n        if(bdp->start > r_bdp->start)\n        {\n                if(bdp==free_block)\n                {\n                        next_bdp  = free_block;\n                        free_block = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                else  // 2nd block iko\n                {\n                        next_bdp = bdp;\n                        prev_bdp->nextp = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                return;\n        }\n\n        prev_bdp=bdp;\n        if((bdp=bdp->nextp))\n                goto LOOP;\n        else  // last block\n        {\n                prev_bdp->nextp=r_bdp;\n                r_bdp->nextp=NULL;\n        }\n}\nvoid delete_command(int fname)\n{\n        struct fd *fdp;\n        struct bd *bdp,*nextbdp;\n\n        for(fdp=fds;fdp<last_fdp;fdp++)\n                if(fdp->name==fname)\n                        goto NEXT;\n        return;\nNEXT:\n\n        bdp=fdp->b;\n\n        while(bdp)\n        {\n                nextbdp=bdp->nextp;\n                release_block(bdp);\n                bdp = nextbdp;\n        }\n        fdp->b=NULL;\n}\nvoid dispatch(char * buf)\n{\n        char *p;\n        int  op1,op2,ret;\n\n        p=strtok(buf,\" \");\n        if(p[0]=='W')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op2);\n                write_command(op1,op2);\n                return;\n        }\n        if(p[0]=='D')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                delete_command(op1);\n                return;\n        }\n        if(p[0]=='R')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                ret=read_command(op1);\n#ifdef DEBUG\n                printf(\"ANS=\");\n#endif\n                printf(\"%d\\n\",ret);\n                return;\n        }\n}\nvoid init()\n{\n        bds[0].start=0;\n        bds[0].size=1000000000;\n        bds[0].nextp=NULL;\n        free_block = &bds[0];\n\n        last_fdp = &fds[0];\n        emptyblock=&bds[1];\n}\nint main()\n{\n        int i;\n        char * ret;\n\n        init();\n\n        while(EOF!=scanf(\"%d \",&N) && N)\n        {\n                for(i=0;i<N;i++)\n                {\n                        memset(read_buf,30,'\\0');\n                        ret=fgets(read_buf,30,stdin);\n                        dispatch(read_buf);\n#ifdef DEBUG\n                        if(read_buf[0] != 'R')\n                                dump_sector();\n#endif\n                }\n        \n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2152\nTitle Restricted File SYSTEM\nRE\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct bd //block descriptor\n{\n        int start;\n        int size;\n        struct bd * nextp;\n} *bds;\nstruct bd * emptyblock;\nstruct bd * free_block;  // start ptr\nstruct fd //file descriptor\n{\n        int name;\n        struct bd * b;\n} *fds;\nstruct fd * last_fdp;\n\nint N;\nchar read_buf[30];\nstruct mcb\n{\n        int name;\n        int start;\n        int end;\n} *mcbs;\nint mcbcnt;\n//\nvoid memalloc()\n{\n        bds= malloc(sizeof(struct bd)*10001);\n        fds= malloc(sizeof(struct fd)*10001);\n        mcbs=malloc(sizeof(struct mcb)*10001);\n}\nvoid dump_sector_memory()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n        int cnt;\n\n        cnt=0;\n        bdp=free_block;\n        do\n        {     \n                mcbs[cnt].name = -1;\n                mcbs[cnt].start=bdp->start;\n                mcbs[cnt].end  =bdp->start+bdp->size-1;\n                cnt++;\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                while(bdp)\n                {\n                        mcbs[cnt].name = fdp->name;\n                        mcbs[cnt].start=bdp->start;\n                        mcbs[cnt].end  =bdp->start+bdp->size-1;\n                        cnt++;\n                        bdp=bdp->nextp;\n                }\n        }\n        mcbcnt = cnt;\n}\n\nvoid dump_sector()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n     \n\n        printf(\"------------\\n\");\n        bdp=free_block;\n        do\n        {       printf(\"Free block:\");\n                printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                //if(bdp)\n                        while(bdp)\n                {\n                        printf(\"File:%d:\",fdp->name);\n                        printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                        bdp=bdp->nextp;\n                }\n                \n                \n        }\n}\nvoid copy_block(struct bd *src,struct bd *dst)\n{\n        memcpy(dst,src,sizeof(struct bd));\n}\n\nvoid write_command(int fname,int fsize)\n{\n        struct bd *bp,**bpp,*nextbp;\n        struct fd *filep;\n        int oldsize;\n\n\n        \n        filep=last_fdp++;\n        filep->name=fname;\n\n        bpp=&(filep->b);\n                        \n        while(1)\n        {\n                *bpp=free_block;\n                bp = free_block;\n                //printf(\"FSZ %d\\n\",fsize);\n                        \n                if(fsize <= bp->size)   //\n                {\n                        nextbp=bp->nextp;\n                        bp->nextp = NULL;\n                        oldsize   = bp->size;\n                        bp->size  = fsize;\n\n                        if(fsize < oldsize)   //split\n                        {\n                                copy_block(bp,emptyblock);\n                                free_block=emptyblock++;\n                                free_block->start = bp ->start +fsize;\n                                free_block->size  = oldsize    -fsize;\n                                free_block->nextp = nextbp;\n                                return;\n                        }\n                        else //just size\n                        {\n                                free_block=nextbp;\n                                break;\n                        }\n                }\n                else \n                {\n                        free_block=bp->nextp;     \n                        fsize -= bp->size;\n                        if(fsize > 0)\n                        {\n                                bpp=&(bp->nextp);\n                                continue;\n                        }\n                        return;\n                }\n        }\n}\nint compare_mcb(const void *x, const void *y)\n{\n        return ((struct mcb *)x)->start - ((struct mcb *)y)->start;\n}\n\nint read_command(int sector)\n{\n        int center,mini,maxi;\n\n        dump_sector_memory();\n        qsort(mcbs,mcbcnt,sizeof(struct mcb),compare_mcb);\n        mini=0;maxi=mcbcnt;\n        while(maxi-mini>1)\n        {\n                center=(maxi+mini)/2;\n#ifdef DEBUG\n                printf(\"R:%d C:%d %d\\n\",sector,\n                       mcbs[center].start,mcbs[center].end);\n#endif\n                if(mcbs[center].start > sector)\n                {\n                        maxi=(maxi+mini)/2;\n                }\n                else if(mcbs[center].end < sector)\n                {\n                        mini=(maxi+mini)/2;\n                }\n                else  //equal\n                {\n                        return(mcbs[center].name);\n                }\n        }\n        if(maxi-mini==1)\n        {\n                if(mcbs[maxi].start < sector)\n                        return(mcbs[maxi].name);\n                else\n                        return(mcbs[mini].name);\n        }\n        return(mcbs[center].name);\n}\nvoid release_block(struct bd * r_bdp)\n{\n        struct bd *bdp,*next_bdp,*prev_bdp;\n\n        bdp=free_block;\nLOOP:\n        if(bdp->start > r_bdp->start)\n        {\n                if(bdp==free_block)\n                {\n                        next_bdp  = free_block;\n                        free_block = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                else  // 2nd block iko\n                {\n                        next_bdp = bdp;\n                        prev_bdp->nextp = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                return;\n        }\n\n        prev_bdp=bdp;\n        if((bdp=bdp->nextp))\n                goto LOOP;\n        else  // last block\n        {\n                prev_bdp->nextp=r_bdp;\n                r_bdp->nextp=NULL;\n        }\n}\nvoid delete_command(int fname)\n{\n        struct fd *fdp;\n        struct bd *bdp,*nextbdp;\n\n        for(fdp=fds;fdp<last_fdp;fdp++)\n                if(fdp->name==fname)\n                        goto NEXT;\n        return;\nNEXT:\n\n        bdp=fdp->b;\n\n        while(bdp)\n        {\n                nextbdp=bdp->nextp;\n                release_block(bdp);\n                bdp = nextbdp;\n        }\n        fdp->b=NULL;\n}\nvoid dispatch(char * buf)\n{\n        char *p;\n        int  op1,op2,ret;\n\n        p=strtok(buf,\" \");\n        if(p[0]=='W')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op2);\n                write_command(op1,op2);\n                return;\n        }\n        if(p[0]=='D')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                delete_command(op1);\n                return;\n        }\n        if(p[0]=='R')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                ret=read_command(op1);\n#ifdef DEBUG\n                printf(\"ANS=\");\n#endif\n                printf(\"%d\\n\",ret);\n                return;\n        }\n}\nvoid init()\n{\n        memalloc();\n\n        bds[0].start=0;\n        bds[0].size=1000000000;\n        bds[0].nextp=NULL;\n        free_block = &bds[0];\n\n        last_fdp = &fds[0];\n        emptyblock=&bds[1];\n}\nint main()\n{\n        int i;\n        char * ret;\n\n        init();\n\n        while(EOF!=scanf(\"%d \",&N) && N)\n        {\n                for(i=0;i<N;i++)\n                {\n                        memset(read_buf,30,'\\0');\n                        ret=fgets(read_buf,30,stdin);\n                        dispatch(read_buf);\n#ifdef DEBUG\n                        if(read_buf[0] != 'R')\n                                dump_sector();\n#endif\n                }\n                printf(\"\\n\");        \n        }\n\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main()\n{\n  int i,j,t=0,n,y,x;\n  int F[1000000001],R[1000000001];\n  char ch;\n  \n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(i=0;i<1000000001;i++){\n      F[i]=-1;\n    }\n    \n    for(i=0;i<n*2;i++){\n      scanf(\"%c\",&ch);\n      if(ch=='W'){\n        scanf(\"%d%d\",&x,&y);\n        for(j=0;y!=0;j++){\n          if(F[j]==-1){\n            F[j]=x;\n\t    y--;\n\t  }\n\t}\n      }\n      if(ch== 'D'){\n        scanf(\"%d\",&x);\n        for(j=0;j<1000000001;j++){\n          if(F[j]==x){\n\t    F[j]= -1;\n\t  }\n\t}\n      }\n      if(ch=='R'){\n        scanf(\"%d\",&x);\n        R[t]=F[x-1];\n        t++;\n      }\n    }\n    for(i=0;i<t;i++){\n      printf(\"%d\\n\",R[i]);\n    }\n    printf(\"\\n\");\n    t=0;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2152 Restrictive Filesystem\n// 2018.2.24 bal4u\n\n#include <stdio.h>\n\n#define INF 1000000010\n\ntypedef struct { int fid, from, end; } T;\nT tbl[5000]; int sz;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, j, cmd, id, sec, sno, from, end;\n\n\twhile (n = in()) {\n\t\ttbl[0].fid = -1, tbl[0].from = 0, tbl[0].end = INF, sz = 1;\n\n\t\twhile (n--) {\n\t\t\tcmd = getchar_unlocked(), getchar_unlocked();\n\t\t\tif (cmd == 'W') {\n\t\t\t\tid = in(), sec = in();\n\t\t\t\tfor (i = 0; sec > 0; i++) {\n\t\t\t\t\tif (tbl[i].fid >= 0) continue;\n\t\t\t\t\tfrom = tbl[i].from, end = tbl[i].end;\n\t\t\t\t\tif (end-from+1 <= sec) {\n\t\t\t\t\t\ttbl[i].fid = id;\n\t\t\t\t\t\tsec -= end-from+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttbl[i].fid = id;\n\t\t\t\t\t\ttbl[i].from = from, tbl[i].end = from+sec-1;\n\t\t\t\t\t\tfor (j = sz; j > i; j--) tbl[j] = tbl[j-1]; sz++;\n\t\t\t\t\t\ttbl[++i].fid = -1, tbl[i].from = from+sec, tbl[i].end = end;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cmd == 'R') {\n\t\t\t\tsno = in();\n\t\t\t\tfor (i = 0; i < sz; i++) {\n\t\t\t\t\tif (sno >= tbl[i].from && sno <= tbl[i].end) {\n\t\t\t\t\t\tprintf(\"%d\\n\", tbl[i].fid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\t\t// cmd == 'D'\n\t\t\t\tid = in();\n\t\t\t\tfor (i = 0; i < sz; i++) if (tbl[i].fid == id) tbl[i].fid = -1;\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n \treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2152\nTitle\n*/\n#include <stdio.h>\n#include <string.h>\n\nstruct bd //block descriptor\n{\n        int start;\n        int size;\n        struct bd * nextp;\n} bds[10000];\nstruct bd * emptyblock;\nstruct bd * free_block;  // start ptr\nstruct fd //file descriptor\n{\n        int name;\n        struct bd * b;\n} fds[10000];\nstruct fd * last_fdp;\n\nint N;\nchar read_buf[30];\nstruct mcb\n{\n        int name;\n        int start;\n        int end;\n} mcbs[10000];\nint mcbcnt;\n//\ndump_sector_memory()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n        int cnt;\n\n        cnt=0;\n        bdp=free_block;\n        do\n        {     \n                mcbs[cnt].name = -1;\n                mcbs[cnt].start=bdp->start;\n                mcbs[cnt].end  =bdp->start+bdp->size-1;\n                cnt++;\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                while(bdp)\n                {\n                        mcbs[cnt].name = fdp->name;\n                        mcbs[cnt].start=bdp->start;\n                        mcbs[cnt].end  =bdp->start+bdp->size-1;\n                        cnt++;\n                        bdp=bdp->nextp;\n                }\n        }\n        mcbcnt = cnt;\n}\n\ndump_sector()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n     \n\n        printf(\"------------\\n\");\n        bdp=free_block;\n        do\n        {       printf(\"Free block:\");\n                printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                //if(bdp)\n                        while(bdp)\n                {\n                        printf(\"File:%d:\",fdp->name);\n                        printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                        bdp=bdp->nextp;\n                }\n                \n                \n        }\n}\ncopy_block(struct bd *src,struct bd *dst)\n{\n        memcpy(dst,src,sizeof(struct bd));\n}\n\nvoid write_command(int fname,int fsize)\n{\n        struct bd *bp,**bpp,*nextbp;\n        struct fd *filep;\n        int oldsize;\n\n\n        \n        filep=last_fdp++;\n        filep->name=fname;\n\n        filep->b=free_block;\n                        \n        while(1)\n        {\n                *bpp=free_block;\n                bp = free_block;\n                //printf(\"FSZ %d\\n\",fsize);\n                        \n                if(fsize <= bp->size)   //\n                {\n                        nextbp=bp->nextp;\n                        bp->nextp = NULL;\n                        oldsize   = bp->size;\n                        bp->size  = fsize;\n\n                        if(fsize < oldsize)   //split\n                        {\n                                copy_block(bp,emptyblock);\n                                free_block=emptyblock++;\n                                free_block->start = bp ->start +fsize;\n                                free_block->size  = oldsize    -fsize;\n                                free_block->nextp = nextbp;\n                                return;\n                        }\n                        else //just size\n                        {\n                                free_block=nextbp;\n                                break;\n                        }\n                }\n                else \n                {\n                        free_block=bp->nextp;     \n                        fsize -= bp->size;\n                        if(fsize > 0)\n                        {\n                                bpp=&(bp->nextp);\n                                continue;\n                        }\n                        return;\n                }\n        }\n}\nint compare_mcb(const void *x, const void *y)\n{\n        return ((struct mcb *)x)->start - ((struct mcb *)y)->start;\n}\n\nint read_command(int sector)\n{\n        int siz,center,mini,maxi;\n\n        dump_sector_memory();\n        qsort(mcbs,mcbcnt,sizeof(struct mcb),compare_mcb);\n        mini=0;maxi=mcbcnt;\n        while(maxi-mini>1)\n        {\n                center=(maxi+mini)/2;\n#ifdef DEBUG\n                printf(\"R:%d C:%d %d\\n\",sector,\n                       mcbs[center].start,mcbs[center].end);\n#endif\n                if(mcbs[center].start > sector)\n                {\n                        maxi=(maxi+mini)/2;\n                }\n                else if(mcbs[center].end < sector)\n                {\n                        mini=(maxi+mini)/2;\n                }\n                else  //equal\n                {\n                        return(mcbs[center].name);\n                }\n        }\n        if(maxi-mini==1)\n        {\n                if(mcbs[maxi].start < sector)\n                        return(mcbs[maxi].name);\n                else\n                        return(mcbs[mini].name);\n        }\n        return(mcbs[center].name);\n}\nvoid release_block(struct bd * r_bdp)\n{\n        struct bd *bdp,*next_bdp,*prev_bdp;\n\n        bdp=free_block;\nLOOP:\n        if(bdp->start > r_bdp->start)\n        {\n                if(bdp==free_block)\n                {\n                        next_bdp  = free_block;\n                        free_block = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                else  // 2nd block iko\n                {\n                        next_bdp = bdp;\n                        prev_bdp->nextp = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                return;\n        }\n\n        prev_bdp=bdp;\n        if(bdp=bdp->nextp)\n                goto LOOP;\n        else  // last block\n        {\n                prev_bdp->nextp=r_bdp;\n                r_bdp->nextp=NULL;\n        }\n}\nvoid delete_command(int fname)\n{\n        struct fd *fdp;\n        struct bd *bdp,*nextbdp;\n\n        for(fdp=fds;fdp<last_fdp;fdp++)\n                if(fdp->name==fname)\n                        goto NEXT;\n        return;\nNEXT:\n\n        bdp=fdp->b;\n\n        while(bdp)\n        {\n                nextbdp=bdp->nextp;\n                release_block(bdp);\n                bdp = nextbdp;\n        }\n        fdp->b=NULL;\n}\nvoid dispatch(char * buf)\n{\n        char *p;\n        int  op1,op2,ret;\n\n        p=strtok(buf,\" \");\n        if(p[0]=='W')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op2);\n                write_command(op1,op2);\n                return;\n        }\n        if(p[0]=='D')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                delete_command(op1);\n                return;\n        }\n        if(p[0]=='R')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                ret=read_command(op1);\n#ifdef DEBUG\n                printf(\"ANS=\");\n#endif\n                printf(\"%d\\n\",ret);\n                return;\n        }\n}\ninit()\n{\n        bds[0].start=0;\n        bds[0].size=1000000000;\n        bds[0].nextp=NULL;\n        free_block = &bds[0];\n\n        last_fdp = &fds[0];\n        emptyblock=&bds[1];\n}\nmain()\n{\n        int i;\n\n        init();\n\n        while(EOF!=scanf(\"%d \",&N) && N)\n        {\n                for(i=0;i<N;i++)\n                {\n                        memset(read_buf,30,0);\n                        fgets(read_buf,30,stdin);\n                        dispatch(read_buf);\n#ifdef DEBUG\n                        if(read_buf[0] != 'R')\n                                dump_sector();\n#endif\n                }\n        \n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2152 Restrictive Filesystem\n// 2018.2.24 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define INF 1000000010\n\ntypedef struct { int id, f, e, nxt; } T;\nT tbl[5000]; int sz;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, i, cmd, id, sno, from, end;\n\n\twhile (n = in()) {\n\t\ttbl[0].id = -1, tbl[0].f = 0, tbl[0].e = INF, tbl[0].nxt = 0;\n\t\tsz = 1;\n\n\t\twhile (n--) {\n\t\t\tcmd = getchar_unlocked(), getchar_unlocked();\n\t\t\tif (cmd == 'W') {\n\t\t\t\tid = in(), sno = in();\n\t\t\t\tfor (i = 0; sno > 0; i = tbl[i].nxt) {\n\t\t\t\t\tif (tbl[i].id >= 0) continue;\n\t\t\t\t\tfrom = tbl[i].f, end = tbl[i].e;\n\t\t\t\t\tif (end-from+1 <= sno) {\n\t\t\t\t\t\ttbl[i].id = id;\n\t\t\t\t\t\tsno -= end-from+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttbl[i].id = id;\n\t\t\t\t\t\ttbl[i].f = from, tbl[i].e = from+sno-1;\n\t\t\t\t\t\ttbl[sz].nxt = tbl[i].nxt;\n\t\t\t\t\t\ttbl[i].nxt = sz;\n\t\t\t\t\t\ti = sz++;\n\t\t\t\t\t\ttbl[i].id = -1, tbl[i].f = from+sno, tbl[i].e = end;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cmd == 'R') {\n\t\t\t\tsno = in();\n\t\t\t\ti = 0; while (sno < tbl[i].f || sno > tbl[i].e) i = tbl[i].nxt;\n\t\t\t\tprintf(\"%d\\n\", tbl[i].id);\n\t\t\t} else {\t\t// cmd == 'D'\n\t\t\t\tid = in();\n\t\t\t\tfor (i = 0; tbl[i].nxt != 0; i = tbl[i].nxt)\n\t\t\t\t\tif (tbl[i].id == id) tbl[i].id = -1;\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t}\n \treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2152\nTitle Restricted File SYSTEM\nRE\n*/\n#include <stdio.h>\n#include <string.h>\n\nstruct bd //block descriptor\n{\n        int start;\n        int size;\n        struct bd * nextp;\n} bds[10000];\nstruct bd * emptyblock;\nstruct bd * free_block;  // start ptr\nstruct fd //file descriptor\n{\n        int name;\n        struct bd * b;\n} fds[10000];\nstruct fd * last_fdp;\n\nint N;\nchar read_buf[30];\nstruct mcb\n{\n        int name;\n        int start;\n        int end;\n} mcbs[10000];\nint mcbcnt;\n//\ndump_sector_memory()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n        int cnt;\n\n        cnt=0;\n        bdp=free_block;\n        do\n        {     \n                mcbs[cnt].name = -1;\n                mcbs[cnt].start=bdp->start;\n                mcbs[cnt].end  =bdp->start+bdp->size-1;\n                cnt++;\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                while(bdp)\n                {\n                        mcbs[cnt].name = fdp->name;\n                        mcbs[cnt].start=bdp->start;\n                        mcbs[cnt].end  =bdp->start+bdp->size-1;\n                        cnt++;\n                        bdp=bdp->nextp;\n                }\n        }\n        mcbcnt = cnt;\n}\n\ndump_sector()\n{\n        struct fd *fdp;\n        struct bd *bdp;\n     \n\n        printf(\"------------\\n\");\n        bdp=free_block;\n        do\n        {       printf(\"Free block:\");\n                printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                bdp=bdp->nextp;\n        }\n        while(bdp);\n\n        for(fdp=&fds[0];fdp<last_fdp;fdp++)\n        {\n                bdp=fdp->b;\n                \n                //if(bdp)\n                        while(bdp)\n                {\n                        printf(\"File:%d:\",fdp->name);\n                        printf(\"%d ~ %d\\n\",bdp->start,bdp->start+bdp->size-1);\n                        bdp=bdp->nextp;\n                }\n                \n                \n        }\n}\ncopy_block(struct bd *src,struct bd *dst)\n{\n        memcpy(dst,src,sizeof(struct bd));\n}\n\nvoid write_command(int fname,int fsize)\n{\n        struct bd *bp,**bpp,*nextbp;\n        struct fd *filep;\n        int oldsize;\n\n\n        \n        filep=last_fdp++;\n        filep->name=fname;\n\n        bpp=&(filep->b);\n                        \n        while(1)\n        {\n                *bpp=free_block;\n                bp = free_block;\n                //printf(\"FSZ %d\\n\",fsize);\n                        \n                if(fsize <= bp->size)   //\n                {\n                        nextbp=bp->nextp;\n                        bp->nextp = NULL;\n                        oldsize   = bp->size;\n                        bp->size  = fsize;\n\n                        if(fsize < oldsize)   //split\n                        {\n                                copy_block(bp,emptyblock);\n                                free_block=emptyblock++;\n                                free_block->start = bp ->start +fsize;\n                                free_block->size  = oldsize    -fsize;\n                                free_block->nextp = nextbp;\n                                return;\n                        }\n                        else //just size\n                        {\n                                free_block=nextbp;\n                                break;\n                        }\n                }\n                else \n                {\n                        free_block=bp->nextp;     \n                        fsize -= bp->size;\n                        if(fsize > 0)\n                        {\n                                bpp=&(bp->nextp);\n                                continue;\n                        }\n                        return;\n                }\n        }\n}\nint compare_mcb(const void *x, const void *y)\n{\n        return ((struct mcb *)x)->start - ((struct mcb *)y)->start;\n}\n\nint read_command(int sector)\n{\n        int siz,center,mini,maxi;\n\n        dump_sector_memory();\n        qsort(mcbs,mcbcnt,sizeof(struct mcb),compare_mcb);\n        mini=0;maxi=mcbcnt;\n        while(maxi-mini>1)\n        {\n                center=(maxi+mini)/2;\n#ifdef DEBUG\n                printf(\"R:%d C:%d %d\\n\",sector,\n                       mcbs[center].start,mcbs[center].end);\n#endif\n                if(mcbs[center].start > sector)\n                {\n                        maxi=(maxi+mini)/2;\n                }\n                else if(mcbs[center].end < sector)\n                {\n                        mini=(maxi+mini)/2;\n                }\n                else  //equal\n                {\n                        return(mcbs[center].name);\n                }\n        }\n        if(maxi-mini==1)\n        {\n                if(mcbs[maxi].start < sector)\n                        return(mcbs[maxi].name);\n                else\n                        return(mcbs[mini].name);\n        }\n        return(mcbs[center].name);\n}\nvoid release_block(struct bd * r_bdp)\n{\n        struct bd *bdp,*next_bdp,*prev_bdp;\n\n        bdp=free_block;\nLOOP:\n        if(bdp->start > r_bdp->start)\n        {\n                if(bdp==free_block)\n                {\n                        next_bdp  = free_block;\n                        free_block = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                else  // 2nd block iko\n                {\n                        next_bdp = bdp;\n                        prev_bdp->nextp = r_bdp;\n                        r_bdp->nextp = next_bdp;\n                }\n                return;\n        }\n\n        prev_bdp=bdp;\n        if(bdp=bdp->nextp)\n                goto LOOP;\n        else  // last block\n        {\n                prev_bdp->nextp=r_bdp;\n                r_bdp->nextp=NULL;\n        }\n}\nvoid delete_command(int fname)\n{\n        struct fd *fdp;\n        struct bd *bdp,*nextbdp;\n\n        for(fdp=fds;fdp<last_fdp;fdp++)\n                if(fdp->name==fname)\n                        goto NEXT;\n        return;\nNEXT:\n\n        bdp=fdp->b;\n\n        while(bdp)\n        {\n                nextbdp=bdp->nextp;\n                release_block(bdp);\n                bdp = nextbdp;\n        }\n        fdp->b=NULL;\n}\nvoid dispatch(char * buf)\n{\n        char *p;\n        int  op1,op2,ret;\n\n        p=strtok(buf,\" \");\n        if(p[0]=='W')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op2);\n                write_command(op1,op2);\n                return;\n        }\n        if(p[0]=='D')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                delete_command(op1);\n                return;\n        }\n        if(p[0]=='R')\n        {\n                p=strtok(NULL,\" \");\n                sscanf(p,\"%d\",&op1);\n                ret=read_command(op1);\n#ifdef DEBUG\n                printf(\"ANS=\");\n#endif\n                printf(\"%d\\n\",ret);\n                return;\n        }\n}\ninit()\n{\n        bds[0].start=0;\n        bds[0].size=1000000000;\n        bds[0].nextp=NULL;\n        free_block = &bds[0];\n\n        last_fdp = &fds[0];\n        emptyblock=&bds[1];\n}\nmain()\n{\n        int i;\n\n        init();\n\n        while(EOF!=scanf(\"%d \",&N) && N)\n        {\n                for(i=0;i<N;i++)\n                {\n                        memset(read_buf,30,0);\n                        fgets(read_buf,30,stdin);\n                        dispatch(read_buf);\n#ifdef DEBUG\n                        if(read_buf[0] != 'R')\n                                dump_sector();\n#endif\n                }\n        \n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define L 1000000001\n\nstatic int d[ L ];\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int n;\n\n    scanf ( \" %d\", &n );\n    if ( n == 0 ) break ;\n    memset ( d, -1, sizeof ( d ) );\n\n    while ( n-- )\n    {\n      char cmd;\n\n      scanf ( \" %c\", &cmd );\n      switch ( cmd )\n      {\n        case 'W':\n        {\n          int l, s;\n\n          scanf ( \" %d %d\", &l, &s );\n          for ( i = 0; s > 0; ++i )\n          {\n            if ( d[ i ] != -1 ) continue ;\n            d[ i ] = l; --s;\n          }\n        } break ;\n        case 'D':\n        {\n          int l;\n\n          scanf ( \" %d\", &l );\n          for ( i = 0; i < L; ++i )\n          if ( d[ i ] == l )\n            d[ i ] = -1;\n        } break ;\n        case 'R':\n        {\n          int p;\n\n          scanf ( \" %d\", &p );\n          printf ( \"%d\\n\", d[ p ] );\n        } break ;\n      }\n    }\n    puts ( \"\" );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint F[1000000000],R[1000000000];\nint main()\n{\n  int i,j,t=0,n,y,x;\n  char ch;\n  \n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    for(i=0;i<1000000000;i++){\n      F[i]=-1;\n    }\n    \n    for(i=0;i<n*2;i++){\n      scanf(\"%c\",&ch);\n      if(ch=='W'){\n        scanf(\"%d%d\",&x,&y);\n        for(j=0;y!=0;j++){\n          if(F[j]==-1){\n            F[j]=x;\n\t    y--;\n\t  }\n\t}\n      }\n      if(ch== 'D'){\n        scanf(\"%d\",&x);\n        for(j=0;j<1000000001;j++){\n          if(F[j]==x){\n\t    F[j]= -1;\n\t  }\n\t}\n      }\n      if(ch=='R'){\n        scanf(\"%d\",&x);\n        R[t]=F[x-1];\n        t++;\n      }\n    }\n    for(i=0;i<t;i++){\n      printf(\"%d\\n\",R[i]);\n    }\n    printf(\"\\n\");\n    t=0;\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main\n{\n\tstatic Long start;\n\tstatic HashMap<Long, Long> fsys;\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String args[])\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tfsys = new HashMap<Long, Long>();\n\t\t\tstart = 0L;\n\t\t\tif (n == 0) break;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tswitch (sc.next().charAt(0))\n\t\t\t\t{\n\t\t\t\tcase 'W':\n\t\t\t\t\twrite();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tread();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdelete();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for (Long j = 0L; j < 10L; j++)\n\t\t\t\t//\tSystem.out.println(fsys.get(j));\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void write()\n\t{\n\t\tLong x = sc.nextLong();\n\t\tLong n = sc.nextLong();\n\t\tLong i;\n\t\tfor (i = start; i < 1000000000L; i++)\n\t\t{\n\t\t\tif (fsys.get(i) != null) continue;\n\t\t\tfsys.put(i, x);\n\t\t\tn--;\n\t\t\tif (n == 0) break;\n\t\t}\n\t\tstart = i + 1L;\n\t}\n\tprivate static void read()\n\t{\n\t\tLong n = sc.nextLong();\n\t\tLong value = fsys.get(n);\n\t\tif (value == null)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\telse System.out.println(value);\n\t}\n\tprivate static void delete()\n\t{\n\t\tLong n = sc.nextLong();\n\t\tSet<Long> key = fsys.keySet();\n\t\tIterator<Long> it = key.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tLong i = it.next();\n\t\t\tif (fsys.get(i) == n)\n\t\t\t{\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t\tstart = Math.min(i, start);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main\n{\n\n  \n\n    public static void main(String args[])\n    {\n\tScanner in = new Scanner(System.in);\n\tint N;\n\twhile(true)\n\t    {\n\t\tN = in.nextInt();\n\t\tif(N == 0)break;\n\t\tLinkedList<P> list = new LinkedList<P>();\n\t\tlist.add(new P(0,0,-1));\n\n\t\tString c;\n\t\tint I,S;\n\t\tfor(int i=0;i<N;i++)\n\t\t    {\n\t\t\tc = in.next();\n\t\t\tif(c.equals(\"W\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tS = in.nextInt();\n\t\t\t\tfor(int j=0;j<list.size()-1;j++)\n\t\t\t\t    {\t\n\t\t\t\t\tint v1 = list.get(j).r;\n\t\t\t\t\tint v2 = list.get(j+1).l;\n\t\t\t\t\tif(v1 == v2)continue;\n\t\t\t\t\t//System.out.println(\"add ! \" + j + \" \" + v1 + \" \" + v2);\n\t\t\t\t\tlist.add(j+1,new P(v1,Math.min((v2-v1)+v1,v1+S),I) ); \n\t\t\t\t\tS -= (v2-v1);\n\t\t\t\t\tif(S < 0)S = 0;\n\n\t\t\t\t\tif(S == 0)break;\n\t\t\t\t    }\n\t\t\t\tif(S != 0)\n\t\t\t\t    {\n\n\t\t\t\t\t\tint lass = (list.size()-1 >= 0?list.get(list.size()-1).r:0);\n\t\t\t\t\t\tlist.add(new P(lass,lass+S,I));\n\n\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t    }\n\t\t\telse if(c.equals(\"D\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tint v = list.get(j).id;\n\t\t\t\t\tif(v == I)\n\t\t\t\t\t    {\n\t\t\t\t\t\tP p = list.remove(j);\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tboolean found = false;\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tP p = list.get(j);\n\t\t\t\t\tif(p.l <= I && I < p.r)\n\t\t\t\t\t    {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tSystem.out.println(p.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\tif(!found)System.out.println(-1);\n\t\t\t    }\n\t\t\t/*\n\t\t\tSystem.out.println(\"------------\");\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tSystem.out.println(list.get(j).l + \" - \" +list.get(j).r + \" : \" + list.get(j).id);\n\t\t\t    }\n\t\t\tSystem.out.println(\"------------\");\n\t\t\t*/\n\t\t    }\n\t    }\n    }\n}\n\nclass P\n{\n    public int r,l,id;\n    P(int rl,int rr,int rid)\n    {\n\tr = rr;\n\tl = rl;\n\tid = rid;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n \n \npublic class Main{\n\tpublic static class File{\n\t\tint identifer;\n\t\tlong start;\n\t\tlong size;\n\t\t\n\t\tpublic File(int identifer, long start, long size) {\n\t\t\tsuper();\n\t\t\tthis.identifer = identifer;\n\t\t\tthis.start = start;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.identifer + \" \" + this.start + \"->\" + (this.start + this.size - 1);\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\t\n    \t\tif(N == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tLinkedList<File> files = new LinkedList<File>();\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tString ops = sc.next();\n    \t\t\t\n    \t\t\t//System.out.println(files);\n    \t\t\t\n    \t\t\tif(\"W\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\tfinal int S = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tlong rest = S;\n    \t\t\t\tlong pos = 0;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(pos < file.start){\n    \t\t\t\t\t\titer.previous();\n    \t\t\t\t\t\tfinal long size = Math.min(rest, file.start - pos);\n    \t\t\t\t\t\titer.add(new File(l, pos, size));\n    \t\t\t\t\t\trest -= size;\n    \t\t\t\t\t\titer.next();\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tif(rest <= 0){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tpos = file.start + file.size;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(rest > 0){\n    \t\t\t\t\tfiles.add(new File(l, pos, rest));\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"D\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.identifer == l){\n    \t\t\t\t\t\titer.remove();\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"R\".equals(ops)){\n    \t\t\t\tfinal int P = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tboolean found = false;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.start <= P && P < file.start + file.size){\n    \t\t\t\t\t\tSystem.out.println(file.identifer);\n    \t\t\t\t\t\tfound = true;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}else if(file.start > P){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(!found){\n    \t\t\t\t\tSystem.out.println(-1);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println();\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 1000000000;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tLinkedList<Seg> list = new LinkedList<Seg>();\n\t\t\tfor(int i=0;i<n;i++) {\n//\t\t\t\tfor(Seg seg: list) debug(seg.id, seg.s, seg.e);\n//\t\t\t\tdebug(\" \");\n\t\t\t\tswitch ( sc.next().charAt(0) ) {\n\t\t\t\tcase 'W':\n\t\t\t\t\tint l = sc.nextInt();\n\t\t\t\t\tint mem = sc.nextInt();\n\t\t\t\t\tLinkedList<Seg> tmp = new LinkedList<Seg>();\n\t\t\t\t\n\t\t\t\t\tlong s = 0; long e = mem;\n\t\t\t\t\tfor(;!list.isEmpty();) {\n\t\t\t\t\t\tSeg seg = list.removeFirst();\n\t\t\t\t\t\tif(mem == 0) {\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\t\tfor(;!list.isEmpty();)\n\t\t\t\t\t\t\t\ttmp.addLast(list.removeFirst());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( seg.s > s ) {\n\t\t\t\t\t\t\te = min(s + mem, seg.s);\n\t\t\t\t\t\t\tmem -= (e-s);\n\t\t\t\t\t\t\ttmp.addLast(new Seg(l, s, e));\n\t\t\t\t\t\t\ttmp.addLast(seg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.addLast(seg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = seg.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(mem != 0) tmp.addLast(new Seg(l, s, s+mem));\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'D':\n\t\t\t\t\tl = sc.nextInt();\n\t\t\t\t\ttmp = new LinkedList<Seg>();\n\t\t\t\t\tfor(;!list.isEmpty();) {\n\t\t\t\t\t\tSeg seg = list.removeFirst();\n\t\t\t\t\t\tif(seg.id == l);\n\t\t\t\t\t\telse tmp.addLast(seg);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'R':\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tboolean flg = false;\n\t\t\t\t\tfor(Seg seg: list) {\n\t\t\t\t\t\tif( seg.s <= p && p < seg.e ) {\n\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\tSystem.out.println(seg.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg) System.out.println(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tclass Seg {\n\t\tlong id, s, e;\n\t\tSeg(long id, long s, long e) {\n\t\t\tthis.s = s;\n\t\t\tthis.id = id;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n///Restrictive Filesystem\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint id, s, t;\n\t\tpublic R(int id, int s, int t) {\n\t\t\tthis.id = id;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(-1, 0, 1000000000));\n\t\t\tMap<Integer, Integer> tail = new HashMap<Integer, Integer>();\n\t\t\twhile(n--!=0){\n//\t\t\t\tCollections.sort(l);\n\t\t\t\tchar cmd = sc.next().charAt(0);\n\t\t\t\tif(cmd=='R'){\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tfor(R r:l){\n\t\t\t\t\t\tif(r.s<=p&&p<=r.t){\n\t\t\t\t\t\t\tSystem.out.println(r.id); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cmd=='W'){\n\t\t\t\t\tint id = sc.nextInt(), len = sc.nextInt();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=-1)continue;\n\t\t\t\t\t\tint L = r.t-r.s+1;\n\t\t\t\t\t\tif(L<len){\n\t\t\t\t\t\t\tr.id = id;\n\t\t\t\t\t\t\tlen-=L;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.remove(i);\n\t\t\t\t\t\t\tl.add(i, new R(id, r.s, r.s+len-1));\n\t\t\t\t\t\t\tl.add(i+1, new R(r.id, r.s+len, r.t));\n\t\t\t\t\t\t\ttail.put(id, r.s+len-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint id = sc.nextInt();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=id)continue;\n\t\t\t\t\t\tif(tail.get(id)<r.s)break;\n\t\t\t\t\t\tr.id = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i+1<l.size();i++){\n\t\t\t\t\tR r1 = l.get(i), r2 = l.get(i+1);\n\t\t\t\t\tif(r1.id!=r2.id)continue;\n\t\t\t\t\tR r = new R(r1.id, r1.s, r2.t);\n\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, r);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\n\tstatic class S{\n\t\tlong id,s,e;\n\t\tS(long _id,long _s,long _e){\n\t\t\tid=_id;s=_s;e=_e;\n\t\t}\n\t}\n\n\tint N;\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tN=sc.nextInt();\n\t\t\tif(N==0)return;\n\n\t\t\tLinkedList<S> segs=new LinkedList<S>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tchar k=sc.next().charAt(0);\n\t\t\t\tswitch(k){\n\t\t\t\tcase 'W':\n\t\t\t\t\tint id=sc.nextInt(),len=sc.nextInt();\n\t\t\t\t\tList<S> tmp=new LinkedList<S>();\n\t\t\t\t\tlong s=0,e=len;\n\t\t\t\t\twhile(!segs.isEmpty()){\n\t\t\t\t\t\tS seg=segs.poll();\n\t\t\t\t\t\tif(len==0){\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\t\twhile(!segs.isEmpty())\n\t\t\t\t\t\t\t\ttmp.add(segs.poll());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(seg.s>s){\n\t\t\t\t\t\t\te=min(s+len,seg.s);\n\t\t\t\t\t\t\tlen-=e-s;\n\t\t\t\t\t\t\ttmp.add(new S(id,s,e));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\ts=seg.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(len!=0)tmp.add(new S(id,s,s+len));\n\t\t\t\t\tsegs.clear();\n\t\t\t\t\tsegs.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tid=sc.nextInt();\n\t\t\t\t\ttmp=new LinkedList<S>();\n\t\t\t\t\twhile(!segs.isEmpty()){\n\t\t\t\t\t\tS seg=segs.poll();\n\t\t\t\t\t\tif(seg.id!=id)\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t}\n\t\t\t\t\tsegs.clear();\n\t\t\t\t\tsegs.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tint p=sc.nextInt();\n\t\t\t\t\tboolean ex=false;\n\t\t\t\t\tfor(S seg:segs){\n\t\t\t\t\t\tif(seg.s<=p && p<seg.e){\n\t\t\t\t\t\t\tex=true;\n\t\t\t\t\t\t\tln(seg.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ex)ln(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node implements Comparable<Node> {\n    int id;\n    int s;\n    int t;\n\n    Node(int a, int b, int c) {\n      id = a;\n      s = b;\n      t = c;\n    }\n\n    @Override\n    public int compareTo(Node node) {\n      return Integer.compare(s, node.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + id + \" : [\" + s + \", \" + t + \"]}\";\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      HashMap<Integer, LinkedList<Node>> map = new HashMap<>();\n      LinkedList<Node> aki = new LinkedList<>();\n      aki.add(new Node(-1, 0, 1_000_000_000));\n      for (int i = 0; i < n; ++i) {\n        char cmd = sc.next().charAt(0);\n        switch (cmd) {\n          case 'W': {\n            int id = ni();\n            int len = ni();\n            LinkedList<Node> list = new LinkedList<>();\n            for (ListIterator<Node> ite = aki.listIterator(); ite.hasNext(); ) {\n              Node node = ite.next();\n              ite.remove();\n              int now = node.t - node.s + 1;\n              if (now < len) {\n                list.add(new Node(id, node.s, node.t));\n                len -= now;\n              } else if (now == len) {\n                list.add(new Node(id, node.s, node.t));\n                break;\n              } else {\n                list.add(new Node(id, node.s, node.s + len - 1));\n                ite.add(new Node(-1, node.s + len, node.t));\n                break;\n              }\n            }\n            map.put(id, list);\n          }\n          break;\n          case 'D': {\n            int id = ni();\n            for (Node node : map.get(id)) {\n              aki.add(new Node(-1, node.s, node.t));\n            }\n            map.remove(id);\n            ArrayList<Node> dup = new ArrayList<>(aki);\n            Collections.sort(dup);\n            aki = new LinkedList<>(dup);\n            // ?????¨???\n            for (ListIterator<Node> ite = aki.listIterator(); ite.hasNext(); ) {\n              Node left = ite.next();\n              if (!ite.hasNext()) {\n                break;\n              }\n              Node right = ite.next();\n              ite.previous();\n              if (left.t + 1 != right.s) {\n                continue;\n              }\n              ite.previous();\n              ite.remove();\n              ite.next();\n              ite.remove();\n              ite.add(new Node(-1, left.s, right.t));\n              ite.previous();\n            }\n          }\n          break;\n          case 'R': {\n            int sec = ni();\n            int ans = -1;\n            for (Integer id : map.keySet()) {\n              for (Node node : map.get(id)) {\n                if (node.s <= sec && sec <= node.t) {\n                  ans = id;\n                }\n              }\n            }\n            System.out.println(ans);\n          }\n          break;\n          default:\n            assert false;\n        }\n//        debug(aki);\n//        debug(map);\n      }\n      System.out.println();\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n \n \npublic class Main{\n\tpublic static class File{\n\t\tint identifer;\n\t\tint start;\n\t\tint size;\n\t\t\n\t\tpublic File(int identifer, int start, int size) {\n\t\t\tsuper();\n\t\t\tthis.identifer = identifer;\n\t\t\tthis.start = start;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.identifer + \" \" + this.start + \"->\" + (this.start + this.size);\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\tLinkedList<File> files = new LinkedList<File>();\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tString ops = sc.next();\n    \t\t\t\n    \t\t\t//System.out.println(files);\n    \t\t\t\n    \t\t\tif(\"W\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\tfinal int S = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tint rest = S;\n    \t\t\t\tint pos = 0;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(pos < file.start){\n    \t\t\t\t\t\titer.previous();\n    \t\t\t\t\t\titer.add(new File(l, pos, file.start - pos));\n    \t\t\t\t\t\trest -= file.start - pos;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tpos = file.start + file.size;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(rest > 0){\n    \t\t\t\t\tfiles.add(new File(l, pos, rest));\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"D\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.identifer == l){\n    \t\t\t\t\t\titer.remove();\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"R\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tboolean found = false;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.start <= l && l < file.start + file.size){\n    \t\t\t\t\t\tSystem.out.println(file.identifer);\n    \t\t\t\t\t\tfound = true;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}else if(file.start > l){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(!found){\n    \t\t\t\t\tSystem.out.println(-1);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println();\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\tclass Seg implements Comparable<Seg>{\n\t\tint start, end;\n\n\t\tpublic Seg(int start, int end) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Seg o) {\n\t\t\treturn this.start- o.start;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Seg [start=\" + start + \", end=\" + end + \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint MAX = 1000000000;\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tArrayList<Seg> emptylist = new ArrayList<Seg>();\n\t\t\temptylist.add(new Seg(0, MAX));\n\t\t\tHashMap<Integer, ArrayList<Seg>> sector = new HashMap<Integer, ArrayList<Seg>>();\n\t\t\twhile(n-- > 0){\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif(c == 'W'){\n\t\t\t\t\tint name = sc.nextInt();\n\t\t\t\t\tint size = sc.nextInt();\n\t\t\t\t\tArrayList<Seg> newsector  = new ArrayList<Main.Seg>();\n\t\t\t\t\tfor(int i = 0; i < emptylist.size(); i++){\n\t\t\t\t\t\tSeg nows = emptylist.get(i);\n\t\t\t\t\t\tif(nows.end - nows.start + 1 > size){\n\t\t\t\t\t\t\tSeg afterS = new Seg(nows.start, nows.start + size - 1);\n\t\t\t\t\t\t\tnewsector.add(afterS);\n\t\t\t\t\t\t\temptylist.set(i, new Seg(nows.start + size, nows.end));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(nows.end - nows.start + 1 == size){\n\t\t\t\t\t\t\tnewsector.add(nows);\n\t\t\t\t\t\t\temptylist.remove(i);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tnewsector.add(nows);\n\t\t\t\t\t\t\temptylist.remove(i);\n\t\t\t\t\t\t\tsize = size - (nows.end - nows.start + 1);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsector.put(name, newsector);\n\t\t\t\t}\n\t\t\t\telse if(c == 'D'){\n\t\t\t\t\tint name = sc.nextInt();\n\t\t\t\t\tfor(int i = 0; i < sector.get(name).size(); i++){\n\t\t\t\t\t\temptylist.add(sector.get(name).get(i));\n\t\t\t\t\t}\n\t\t\t\t\tCollections.sort(emptylist);\n\t\t\t\t\tsector.remove(name);\n\t\t\t\t}\n\t\t\t\telse if(c == 'R'){\n\t\t\t\t\tint sectornum = sc.nextInt();\n\t\t\t\t\tint ind = -1;\n\t\t\t\t\tfor(int key: sector.keySet()){\n\t\t\t\t\t\tfor(int i = 0; i < sector.get(key).size(); i++){\n\t\t\t\t\t\t\tSeg nowS = sector.get(key).get(i);\n\t\t\t\t\t\t\tif(nowS.start <= sectornum && sectornum <= nowS.end){\n\t\t\t\t\t\t\t\tind = key;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ind != -1) break;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(ind);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic int idx;\n\tstatic char[] in;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(sc.hasNext()) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif(N == 0) break;\n\t\t\tPriorityQueue<Data> e = new PriorityQueue<Data>();\n\t\t\te.add(new Data(0,1000000001,-1));\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tchar OP = sc.next().charAt(0);\n\t\t\t\tif(OP == 'W') {\n\t\t\t\t\tint a = sc.nextInt();\n\t\t\t\t\tint b = sc.nextInt();\n\t\t\t\t\tPriorityQueue<Data> cp = new PriorityQueue<Data>();\n\t\t\t\t\twhile(b > 0) {\n\t\t\t\t\t\tData tmp = e.poll();\n\t\t\t\t\t\tif(tmp.id != -1) cp.add(tmp);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint canSize = tmp.R - tmp.L + 1;\n\t\t\t\t\t\t\tif(canSize > b) {\n\t\t\t\t\t\t\t\tData mm = new Data(tmp.L + b, tmp.R,-1);\n\t\t\t\t\t\t\t\ttmp.id = a;\n\t\t\t\t\t\t\t\ttmp.R = tmp.L + b-1;\n\t\t\t\t\t\t\t\tcp.add(mm);\n\t\t\t\t\t\t\t\tcp.add(tmp);\n\t\t\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tb -= canSize;\n\t\t\t\t\t\t\t\ttmp.id = a;\n\t\t\t\t\t\t\t\tcp.add(tmp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\te.addAll(cp);\n\t\t\t\t}\n\t\t\t\telse if(OP == 'D') {\n\t\t\t\t\tint a = sc.nextInt();\n\t\t\t\t\tPriorityQueue<Data> cp = new PriorityQueue<Data>();\n\t\t\t\t\twhile(!e.isEmpty()) {\n\t\t\t\t\t\tData tmp = e.poll();\n\t\t\t\t\t\tif(tmp.id != a) cp.add(tmp);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.id = -1;\n\t\t\t\t\t\t\tcp.add(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\te = cp;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint a = sc.nextInt();\n\t\t\t\t\tPriorityQueue<Data> cp = new PriorityQueue<Data>();\n\t\t\t\t\twhile(e.peek().R < a) cp.add(e.poll());\n\t\t\t\t\tSystem.out.println(e.peek().id);\n\t\t\t\t\twhile(!cp.isEmpty()) e.add(cp.poll());\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t}\n\tstatic class Data implements Comparable<Data>{\n\t\tint L;\n\t\tint R;\n\t\tint id;\n\t\tData(int a, int b, int c) {\n\t\t\tL = a;\n\t\t\tR = b;\n\t\t\tid = c;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\treturn this.L - o.L;\n\t\t}\n\t}\n\t\n\t\t\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\nimport org.omg.PortableServer.POAManagerPackage.State;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint MAX = 1000000010;\n\tclass State implements Comparable<State> {\n\t\tint id;\n\t\tint low;\n\t\tint high;\n\n\t\tState(int id, int low, int high) {\n\t\t\tthis.id = id;\n\t\t\tthis.low = low;\n\t\t\tthis.high = high;\n\t\t}\n\n\t\tboolean isInside(int val) {\n\t\t\treturn low <= val && val <= high;\n\t\t}\n\t\t\n\t\tpublic int compareTo(State s) {\n\t\t\treturn low - s.low;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + id + \" \" + low + \" \" + high;\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tTreeSet<State> tset = new TreeSet<State>();\n\t\t\ttset.add(new State(-1, -1, 0));\n\t\t\ttset.add(new State(-1, MAX, MAX + 1));\n\t\t\t\n\t\t\tArrayList<State> temp = new ArrayList<State>();\n\t\t\tfor (int times = 0; times < n; times++) {\n\t\t\t\tchar command = in.next().charAt(0);\n\t\t\t\tint id, S;\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'W' :\n\t\t\t\t\tid = in.nextInt();\n\t\t\t\t\tS = in.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint upper = -1;\n\t\t\t\t\ttemp.clear();\n\t\t\t\t\tfor (State st : tset) {\n\t\t\t\t\t\tif (st.low - upper > 0) {\n\t\t\t\t\t\t\ttemp.add(new State(id, upper, Math.min(upper + S, st.low)));\n\t\t\t\t\t\t\tS = Math.max(S - st.low - upper, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (S == 0) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tupper = st.high;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (State st : temp) tset.add(st);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D' :\n\t\t\t\t\tid = in.nextInt();\n\t\t\t\t\ttemp.clear();\n\t\t\t\t\tfor (State st : tset) {\n\t\t\t\t\t\tif (st.id == id) temp.add(st);\n\t\t\t\t\t}\n\t\t\t\t\tfor (State st : temp) tset.remove(st);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R' :\n\t\t\t\t\tint pos = in.nextInt();\n\t\t\t\t\tState dummy = new State(-1, pos, -1);\n\t\t\t\t\tState ceiling = tset.ceiling(dummy);\n\t\t\t\t\tState floor = tset.floor(dummy);\n\t\t\t\t\tif (ceiling.isInside(pos)) {\n\t\t\t\t\t\tout.println(ceiling.id);\n\t\t\t\t\t} else if (floor.isInside(pos)) {\n\t\t\t\t\t\tout.println(floor.id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 1000000000;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tLinkedList<Seg> list = new LinkedList<Seg>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tswitch ( sc.next().charAt(0) ) {\n\t\t\t\tcase 'W':\n\t\t\t\t\tint l = sc.nextInt();\n\t\t\t\t\tint mem = sc.nextInt();\n\t\t\t\t\tLinkedList<Seg> tmp = new LinkedList<Seg>();\n\t\t\t\t\n\t\t\t\t\tint s = 0; int e = mem;\n\t\t\t\t\tfor(;!list.isEmpty();) {\n\t\t\t\t\t\tSeg seg = list.removeFirst();\n\t\t\t\t\t\tif(mem == 0) {\n\t\t\t\t\t\t\ttmp.addAll(list);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( seg.s > s ) {\n\t\t\t\t\t\t\te = min(s + mem, seg.s);\n\t\t\t\t\t\t\tmem -= (e-s);\n\t\t\t\t\t\t\ttmp.addLast(new Seg(l, s, e));\n\t\t\t\t\t\t\ttmp.addLast(seg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.addLast(seg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = seg.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(mem != 0) tmp.addLast(new Seg(l, s, s+mem));\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'D':\n\t\t\t\t\tl = sc.nextInt();\n\t\t\t\t\ttmp = new LinkedList<Seg>();\n\t\t\t\t\tfor(;!list.isEmpty();) {\n\t\t\t\t\t\tSeg seg = list.removeFirst();\n\t\t\t\t\t\tif(seg.id == l);\n\t\t\t\t\t\telse tmp.addLast(seg);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'R':\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tboolean flg = false;\n\t\t\t\t\tfor(Seg seg: list) {\n\t\t\t\t\t\tif( seg.s <= p && p < seg.e ) {\n\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\tSystem.out.println(seg.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg) System.out.println(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tclass Seg {\n\t\tint id, s, e;\n\t\tSeg(int id, int s, int e) {\n\t\t\tthis.s = s;\n\t\t\tthis.id = id;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\n\tstatic class S{\n\t\tlong id,s,e;\n\t\tS(long _id,long _s,long _e){\n\t\t\tid=_id;s=_s;e=_e;\n\t\t}\n\t}\n\n\tint N;\n\tpublic void run() {\n\t\tHashMap<Integer,Integer> hash=new HashMap<Integer, Integer>();\n\n\t\tCase:while(true){\n\t\t\tN=sc.nextInt();\n\t\t\tif(N==0)return;\n\n\t\t\tLinkedList<S> segs=new LinkedList<S>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tchar k=sc.next().charAt(0);\n\t\t\t\tswitch(k){\n\t\t\t\tcase 'W':\n\t\t\t\t\tint id=sc.nextInt(),len=sc.nextInt();\n\t\t\t\t\tList<S> tmp=new LinkedList<S>();\n\t\t\t\t\tlong s=0,e=len;\n\t\t\t\t\twhile(!segs.isEmpty()){\n\t\t\t\t\t\tS seg=segs.poll();\n\t\t\t\t\t\tif(len==0){\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\t\twhile(!segs.isEmpty())\n\t\t\t\t\t\t\t\ttmp.add(segs.poll());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(seg.s>s){\n\t\t\t\t\t\t\te=min(s+len,seg.s);\n\t\t\t\t\t\t\tlen-=e-s;\n\t\t\t\t\t\t\ttmp.add(new S(id,s,e));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\ts=seg.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(len!=0)tmp.add(new S(id,s,s+len));\n\t\t\t\t\tsegs.clear();\n\t\t\t\t\tsegs.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tid=sc.nextInt();\n\t\t\t\t\ttmp=new LinkedList<S>();\n\t\t\t\t\twhile(!segs.isEmpty()){\n\t\t\t\t\t\tS seg=segs.poll();\n\t\t\t\t\t\tif(seg.id!=id)\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t}\n\t\t\t\t\tsegs.clear();\n\t\t\t\t\tsegs.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tint p=sc.nextInt();\n\t\t\t\t\tboolean ex=false;\n\t\t\t\t\tfor(S seg:segs){\n\t\t\t\t\t\tif(seg.s<=p && p<seg.e){\n\t\t\t\t\t\t\tex=true;\n\t\t\t\t\t\t\tln(seg.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ex)ln(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 1000000000;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tLinkedList<Seg> list = new LinkedList<Seg>();\n\t\t\tfor(int i=0;i<n;i++) {\n//\t\t\t\tfor(Seg seg: list) debug(seg.id, seg.s, seg.e);\n//\t\t\t\tdebug(\" \");\n\t\t\t\tswitch ( sc.next().charAt(0) ) {\n\t\t\t\tcase 'W':\n\t\t\t\t\tint l = sc.nextInt();\n\t\t\t\t\tint mem = sc.nextInt();\n\t\t\t\t\tLinkedList<Seg> tmp = new LinkedList<Seg>();\n\t\t\t\t\n\t\t\t\t\tint s = 0; int e = mem;\n\t\t\t\t\tfor(;!list.isEmpty();) {\n\t\t\t\t\t\tSeg seg = list.removeFirst();\n\t\t\t\t\t\tif(mem == 0) {\n\t\t\t\t\t\t\ttmp.addAll(list);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( seg.s > s ) {\n\t\t\t\t\t\t\te = min(s + mem, seg.s);\n\t\t\t\t\t\t\tmem -= (e-s);\n\t\t\t\t\t\t\ttmp.addLast(new Seg(l, s, e));\n\t\t\t\t\t\t\ttmp.addLast(seg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttmp.addLast(seg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts = seg.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(mem != 0) tmp.addLast(new Seg(l, s, s+mem));\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'D':\n\t\t\t\t\tl = sc.nextInt();\n\t\t\t\t\ttmp = new LinkedList<Seg>();\n\t\t\t\t\tfor(;!list.isEmpty();) {\n\t\t\t\t\t\tSeg seg = list.removeFirst();\n\t\t\t\t\t\tif(seg.id == l);\n\t\t\t\t\t\telse tmp.addLast(seg);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlist.clear();\n\t\t\t\t\tlist.addAll(tmp);\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t\tcase 'R':\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tboolean flg = false;\n\t\t\t\t\tfor(Seg seg: list) {\n\t\t\t\t\t\tif( seg.s <= p && p < seg.e ) {\n\t\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\t\tSystem.out.println(seg.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg) System.out.println(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tclass Seg {\n\t\tint id, s, e;\n\t\tSeg(int id, int s, int e) {\n\t\t\tthis.s = s;\n\t\t\tthis.id = id;\n\t\t\tthis.e = e;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main\n{\n\tstatic HashMap<Long, Long> fsys;\n\tstatic Scanner sc = new Scanner(System.in);\n\tpublic static void main(String args[])\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tint n = sc.nextInt();\n\t\t\tfsys = new HashMap<Long, Long>();\n\t\t\tif (n == 0) break;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tswitch (sc.next().charAt(0))\n\t\t\t\t{\n\t\t\t\tcase 'W':\n\t\t\t\t\twrite();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tread();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tdelete();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t//for (Long j = 0L; j < 10L; j++)\n\t\t\t\t//\tSystem.out.println(fsys.get(j));\n\t\t\t}\n\t\t}\n\t}\n\tprivate static void write()\n\t{\n\t\tLong x = sc.nextLong();\n\t\tLong n = sc.nextLong();\n\t\tfor (long i = 0; i < 1000000000; i++)\n\t\t{\n\t\t\tif (fsys.get(i) != null) continue;\n\t\t\tfsys.put(i, x);\n\t\t\tn--;\n\t\t\tif (n == 0) break;\n\t\t}\n\t}\n\tprivate static void read()\n\t{\n\t\tLong n = sc.nextLong();\n\t\tLong value = fsys.get(n);\n\t\tif (value == null)\n\t\t{\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t\telse System.out.println(value);\n\t}\n\tprivate static void delete()\n\t{\n\t\tLong n = sc.nextLong();\n\t\tSet<Long> key = fsys.keySet();\n\t\tIterator<Long> it = key.iterator();\n\t\twhile (it.hasNext())\n\t\t{\n\t\t\tLong i = it.next();\n\t\t\tif (fsys.get(i) == n)\n\t\t\t{\n\t\t\t\tit.remove();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n///Restrictive Filesystem\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint id, s, t;\n\t\tpublic R(int id, int s, int t) {\n\t\t\tthis.id = id;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(-1, 0, 1000000000));\n\t\t\tMap<Integer, List<R>> ref = new HashMap<Integer, List<R>>();\n\t\t\twhile(n--!=0){\n//\t\t\t\tSystem.out.println(\"DEBUG\");\n//\t\t\t\tList<R> d = new LinkedList<R>();\n//\t\t\t\td.addAll(l);\n//\t\t\t\tfor(int k:ref.keySet())for(R r:ref.get(k))d.add(r);\n//\t\t\t\tCollections.sort(d);\n//\t\t\t\tfor(R r:d)System.out.println(r.s+\"-\"+r.t+\" :\"+r.id);\n\t\t\t\tchar cmd = sc.next().charAt(0);\n\t\t\t\tif(cmd=='R'){\n\t\t\t\t\tint p = sc.nextInt(), res = -1;\n\t\t\t\t\tfor(int k:ref.keySet())for(R r:ref.get(k)){\n\t\t\t\t\t\tif(res!=-1)break;\n\t\t\t\t\t\tif(r.s<=p&&p<=r.t)res = r.id;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res);\n\t\t\t\t}\n\t\t\t\telse if(cmd=='W'){\n\t\t\t\t\tint id = sc.nextInt(), len = sc.nextInt();\n\t\t\t\t\tList<R> list = new LinkedList<R>();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tint L = r.t-r.s+1;\n\t\t\t\t\t\tif(L<len){\n\t\t\t\t\t\t\tlist.add(new R(id, r.s, r.t));\n\t\t\t\t\t\t\tl.remove(i); i--;\n\t\t\t\t\t\t\tlen-=L;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(L==len){\n\t\t\t\t\t\t\tlist.add(new R(id, r.s, r.t));\n\t\t\t\t\t\t\tl.remove(i);\n\t\t\t\t\t\t\tref.put(id, list);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.remove(i);\n\t\t\t\t\t\t\tlist.add(new R(id, r.s, r.s+len-1));\n\t\t\t\t\t\t\tl.add(i, new R(-1, r.s+len, r.t));\n\t\t\t\t\t\t\tref.put(id, list);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint id = sc.nextInt();\n\t\t\t\t\tif(ref.containsKey(id)){\n\t\t\t\t\t\tfor(R r:ref.get(id)){\n\t\t\t\t\t\t\tl.add(new R(-1, r.s, r.t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tref.remove(id);\n\t\t\t\t\t\tCollections.sort(l);\n\t\t\t\t\t\tfor(int i=0;i+1<l.size();i++){\n\t\t\t\t\t\t\tR r1 = l.get(i), r2 = l.get(i+1);\n\t\t\t\t\t\t\tif(r1.t+1!=r2.s)continue;\n\t\t\t\t\t\t\tR r = new R(r1.id, r1.s, r2.t);\n\t\t\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, r);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\t// Scanner sc=new Scanner(System.in);\n\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tString[] ss;\n\n\tvoid run(){\n\t\ttry{\n\t\t\tfor(;;){\n\t\t\t\tn=Integer.parseInt(br.readLine());\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tss=new String[n];\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tss[i]=br.readLine();\n\t\t\t\t}\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}catch(Exception e){}\n\t}\n\n\tvoid solve(){\n\t\tArrayList<Mem> list=new ArrayList<Mem>();\n\t\tboolean[] removed=new boolean[10010];\n\t\tint[] ids=new int[10010];\n\t\tHashMap<Integer, Integer> rev=new HashMap<Integer, Integer>();\n\n\t\tlist.add(new Mem(0, (int)1e9+10));\n\t\tremoved[0]=true;\n\t\tids[0]=-1;\n\t\trev.put(-1, 0);\n\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(String s : ss){\n\t\t\tString[] ss=s.split(\" \");\n\t\t\tif(ss[0].equals(\"W\")){\n\t\t\t\tint id=Integer.parseInt(ss[1]), len=Integer.parseInt(ss[2]);\n\t\t\t\tids[rev.size()+1]=id;\n\t\t\t\trev.put(id, rev.size()+1);\n\t\t\t\tid=rev.get(id);\n\t\t\t\tfor(int i=0, size=list.size(); i<size; i++){\n\t\t\t\t\tMem m=list.get(i);\n\t\t\t\t\tif(removed[m.id]){\n\t\t\t\t\t\tif(len>=m.len){\n\t\t\t\t\t\t\tm.id=id;\n\t\t\t\t\t\t\tlen-=m.len;\n\t\t\t\t\t\t}else if(len<m.len){\n\t\t\t\t\t\t\tint right=m.len-len;\n\t\t\t\t\t\t\tm.id=id;\n\t\t\t\t\t\t\tm.len=len;\n\t\t\t\t\t\t\tlist.add(i+1, new Mem(0, right));\n\t\t\t\t\t\t\tlen=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(len==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(ss[0].equals(\"D\")){\n\t\t\t\tint id=Integer.parseInt(ss[1]);\n\t\t\t\tid=rev.get(id);\n\t\t\t\tremoved[id]=true;\n\t\t\t}else{\n\t\t\t\tint at=Integer.parseInt(ss[1]);\n\t\t\t\tint tot=0;\n\t\t\t\tfor(int i=0, size=list.size(); i<size; i++){\n\t\t\t\t\tMem m=list.get(i);\n\t\t\t\t\tif(tot+m.len>at){\n\t\t\t\t\t\tint id=m.id;\n\t\t\t\t\t\tsb.append(ids[id]).append('\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttot+=m.len;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug();\n\t\t\t// for(Mem sec : list){\n\t\t\t// debug(sec.id, sec.len);\n\t\t\t// }\n\t\t\t// debug();\n\t\t}\n\t\tprintln(sb.toString());\n\t}\n\n\tclass Mem{\n\t\tint id, len;\n\n\t\tMem(int id, int len){\n\t\t\tthis.id=id;\n\t\t\tthis.len=len;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    LinkedList<int[]> list;\n    PriorityQueue<int[]> empty;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        int INF = Integer.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            list = new LinkedList<int[]>(); // from, to, id\n            empty = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[0] - b[0];\n                    }\n                });\n            empty.add(new int[]{0, INF});\n\n            for(int i=0; i<n; i++){\n                char command = sc.next().charAt(0);\n                if(command=='R') print(sc.nextInt());\n                if(command=='W') write(sc.nextInt(), sc.nextInt());\n                if(command=='D') delete(sc.nextInt());\n            }\n            System.out.println();\n        }\n    }\n\n    void print(int idx){\n        for(int i=0; i<list.size(); i++){\n            int[] one = list.poll();\n            if(one[0]<=idx && idx<=one[1]){\n                System.out.println(one[2]);\n                list.add(one);\n                return;\n            }\n            list.add(one);\n        }\n        System.out.println(-1);\n    }\n\n    void write(int idx, int length){\n        while(length>0){\n            int[] one = empty.poll();\n            int from = one[0], to = Math.min(one[0]+length-1, one[1]);\n            list.add(new int[]{from, to, idx});\n            int len = to - from + 1;\n            length -= Math.min(length, len);\n            if(length<len) empty.add(new int[]{one[1]-length, one[1]});\n        }\n    }\n\n    void delete(int idx){\n        int size = list.size();\n        for(int i=0; i<size; i++){\n            int[] one = list.poll();\n            if(one[2]==idx) empty.add(new int[]{one[0], one[1]});\n            else list.add(one);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\nimport org.omg.PortableServer.POAManagerPackage.State;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint MAX = 1000000010;\n\tclass State implements Comparable<State> {\n\t\tint id;\n\t\tint low;\n\t\tint high;\n\n\t\tState(int id, int low, int high) {\n\t\t\tthis.id = id;\n\t\t\tthis.low = low;\n\t\t\tthis.high = high;\n\t\t}\n\n\t\tboolean isInside(int val) {\n\t\t\treturn low <= val && val < high;\n\t\t}\n\t\t\n\t\tpublic int compareTo(State s) {\n\t\t\treturn low - s.low;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + id + \" \" + low + \" \" + high;\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tTreeSet<State> tset = new TreeSet<State>();\n\t\t\ttset.add(new State(-1, -1, 0));\n\t\t\ttset.add(new State(-1, MAX, MAX + 1));\n\t\t\t\n\t\t\tArrayList<State> temp = new ArrayList<State>();\n\t\t\tfor (int times = 0; times < n; times++) {\n\t\t\t\tchar command = in.next().charAt(0);\n\t\t\t\tint id, S;\n\t\t\t\tswitch (command) {\n\t\t\t\tcase 'W' :\n\t\t\t\t\tid = in.nextInt();\n\t\t\t\t\tS = in.nextInt();\n\t\t\t\t\t\n\t\t\t\t\tint upper = -1;\n\t\t\t\t\ttemp.clear();\n\t\t\t\t\tfor (State st : tset) {\n\t\t\t\t\t\tif (st.low - upper > 0) {\n\t\t\t\t\t\t\ttemp.add(new State(id, upper, Math.min(upper + S, st.low)));\n\t\t\t\t\t\t\tS = Math.max(S - (st.low - upper), 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (S == 0) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tupper = st.high;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (State st : temp) tset.add(st);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D' :\n\t\t\t\t\tid = in.nextInt();\n\t\t\t\t\ttemp.clear();\n\t\t\t\t\tfor (State st : tset) {\n\t\t\t\t\t\tif (st.id == id) temp.add(st);\n\t\t\t\t\t}\n\t\t\t\t\tfor (State st : temp) tset.remove(st);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R' :\n\t\t\t\t\tint pos = in.nextInt();\n\t\t\t\t\tState dummy = new State(-1, pos, -1);\n\t\t\t\t\tState ceiling = tset.ceiling(dummy);\n\t\t\t\t\tState floor = tset.floor(dummy);\n\t\t\t\t\tif (ceiling.isInside(pos)) {\n\t\t\t\t\t\tout.println(ceiling.id);\n\t\t\t\t\t} else if (floor.isInside(pos)) {\n\t\t\t\t\t\tout.println(floor.id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.println(-1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    LinkedList<int[]> list;\n    PriorityQueue<int[]> empty;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        int INF = Integer.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            list = new LinkedList<int[]>(); // from, to, id\n            empty = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[0] - b[0];\n                    }\n                });\n            empty.add(new int[]{0, INF});\n\n            for(int i=0; i<n; i++){\n                char command = sc.next().charAt(0);\n                if(command=='R') print(sc.nextInt());\n                if(command=='W') write(sc.nextInt(), sc.nextInt());\n                if(command=='D') delete(sc.nextInt());\n            }\n            System.out.println();\n        }\n    }\n\n    void print(int idx){\n        for(int i=0; i<list.size(); i++){\n            int[] one = list.poll();\n            if(one[0]<=idx && idx<=one[1]){\n                System.out.println(one[2]);\n                list.add(one);\n                return;\n            }\n            list.add(one);\n        }\n        System.out.println(-1);\n    }\n\n    void write(int idx, int length){\n        while(length>0){\n            int[] one = empty.poll();\n            int from = one[0], to = Math.min(one[0]+length-1, one[1]);\n            list.add(new int[]{from, to, idx});\n            length -= Math.min(length, to-from+1);\n            if(to<one[1]) empty.add(new int[]{to+1, one[1]});\n        }\n    }\n\n    void delete(int idx){\n        int size = list.size();\n        for(int i=0; i<size; i++){\n            int[] one = list.poll();\n            if(one[2]==idx) empty.add(new int[]{one[0], one[1]});\n            else list.add(one);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n \n \npublic class Main{\n\tpublic static class File{\n\t\tint identifer;\n\t\tint start;\n\t\tint size;\n\t\t\n\t\tpublic File(int identifer, int start, int size) {\n\t\t\tsuper();\n\t\t\tthis.identifer = identifer;\n\t\t\tthis.start = start;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.identifer + \" \" + this.start + \"->\" + (this.start + this.size);\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\t\n    \t\tif(N == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tLinkedList<File> files = new LinkedList<File>();\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tString ops = sc.next();\n    \t\t\t\n    \t\t\t//System.out.println(files);\n    \t\t\t\n    \t\t\tif(\"W\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\tfinal int S = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tint rest = S;\n    \t\t\t\tint pos = 0;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(pos < file.start){\n    \t\t\t\t\t\titer.previous();\n    \t\t\t\t\t\titer.add(new File(l, pos, file.start - pos));\n    \t\t\t\t\t\trest -= file.start - pos;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tpos = file.start + file.size;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(rest > 0){\n    \t\t\t\t\tfiles.add(new File(l, pos, rest));\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"D\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.identifer == l){\n    \t\t\t\t\t\titer.remove();\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"R\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tboolean found = false;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.start <= l && l < file.start + file.size){\n    \t\t\t\t\t\tSystem.out.println(file.identifer);\n    \t\t\t\t\t\tfound = true;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}else if(file.start > l){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(!found){\n    \t\t\t\t\tSystem.out.println(-1);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println();\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class AOJ2152\n{\n\n  \n\n    public static void main(String args[])\n    {\n\tScanner in = new Scanner(System.in);\n\tint N;\n\tboolean aaa = true;\n\twhile(true)\n\t    {\n\n\t\tN = in.nextInt();\n\t\tif(N == 0)break;\n\n\t\tif(!aaa)System.out.println();\n\t\taaa = false;\n\t\tLinkedList<P> list = new LinkedList<P>();\n\t\tlist.add(new P(0,0,-1));\n\n\t\tString c;\n\t\tint I,S;\n\t\tfor(int i=0;i<N;i++)\n\t\t    {\n\t\t\tc = in.next();\n\t\t\tif(c.equals(\"W\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tS = in.nextInt();\n\t\t\t\tfor(int j=0;j<list.size()-1;j++)\n\t\t\t\t    {\t\n\t\t\t\t\tint v1 = list.get(j).r;\n\t\t\t\t\tint v2 = list.get(j+1).l;\n\t\t\t\t\tif(v1 == v2)continue;\n\t\t\t\t\t//System.out.println(\"add ! \" + j + \" \" + v1 + \" \" + v2);\n\t\t\t\t\tlist.add(j+1,new P(v1,Math.min((v2-v1)+v1,v1+S),I) ); \n\t\t\t\t\tS -= (v2-v1);\n\t\t\t\t\tif(S < 0)S = 0;\n\n\t\t\t\t\tif(S == 0)break;\n\t\t\t\t    }\n\t\t\t\tif(S != 0)\n\t\t\t\t    {\n\n\t\t\t\t\t\tint lass = (list.size()-1 >= 0?list.get(list.size()-1).r:0);\n\t\t\t\t\t\tlist.add(new P(lass,lass+S,I));\n\n\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t    }\n\t\t\telse if(c.equals(\"D\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tint v = list.get(j).id;\n\t\t\t\t\tif(v == I)\n\t\t\t\t\t    {\n\t\t\t\t\t\tP p = list.remove(j);\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tboolean found = false;\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tP p = list.get(j);\n\t\t\t\t\tif(p.l <= I && I < p.r)\n\t\t\t\t\t    {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tSystem.out.println(p.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\tif(!found)System.out.println(-1);\n\t\t\t    }\n\t\t\t/*\n\t\t\tSystem.out.println(\"------------\");\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tSystem.out.println(list.get(j).l + \" - \" +list.get(j).r + \" : \" + list.get(j).id);\n\t\t\t    }\n\t\t\tSystem.out.println(\"------------\");\n\t\t\t*/\n\t\t    }\n\n\t    }\n    }\n}\n\nclass P\n{\n    public int r,l,id;\n    P(int rl,int rr,int rid)\n    {\n\tr = rr;\n\tl = rl;\n\tid = rid;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Task{\n\t\tchar key;\n\t\tint e1=-1,e2=-1;\n\t\tTask(char _key,int _e1,int _e2){\n\t\t\tkey=_key;e1=_e1;e2=_e2;\n\t\t}\n\t}\n\n\tint N,M,L;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tTask[] tasks=new Task[N];\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tchar k=sc.next().charAt(0);\n\t\t\t\tswitch(k){\n\t\t\t\tcase 'W':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),sc.nextInt());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tHashMap<Integer,Integer> hash=new HashMap<Integer, Integer>();\n\t\t\tfor(int i=0;i<N;i++)if(tasks[i].key=='R'){\n\t\t\t\tint p=tasks[i].e1+1;\n\t\t\t\tint e=-1;\n\t\t\t\tint count=0;\n\t\t\t\thash.clear();\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tswitch(tasks[j].key){\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tif(count+tasks[j].e2>=p && e==-1){\n\t\t\t\t\t\t\te=tasks[j].e1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint v=0;\n\t\t\t\t\t\tif(count+tasks[j].e2>=p)v=count+tasks[j].e2-p;\n\t\t\t\t\t\telse v+=tasks[j].e2;\n\t\t\t\t\t\tif(hash.containsKey(tasks[j].e1)){\n\t\t\t\t\t\t\thash.put(tasks[j].e1,hash.get(tasks[j].e1)+v);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\thash.put(tasks[j].e1,v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount=min(count+tasks[j].e2,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\tif(tasks[j].e1==e)e=-1;\n\t\t\t\t\t\tif(hash.containsKey(tasks[j].e1)){\n\t\t\t\t\t\t\tInteger c=hash.get(tasks[j].e1);\n\t\t\t\t\t\t\tcount-=c;\n\t\t\t\t\t\t\thash.put(tasks[j].e1,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tln(e);\n\t\t\t}\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Task{\n\t\tchar key;\n\t\tint e1=-1,e2=-1;\n\t\tTask(char _key,int _e1,int _e2){\n\t\t\tkey=_key;e1=_e1;e2=_e2;\n\t\t}\n\t}\n\n\tint N;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tTask[] tasks=new Task[N];\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tchar k=sc.next().charAt(0);\n\t\t\t\tswitch(k){\n\t\t\t\tcase 'W':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),sc.nextInt());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<N;i++)if(tasks[i].key=='R'){\n\t\t\t\tint p=tasks[i].e1+1;\n\t\t\t\tint e=-1;\n\t\t\t\tint count=0;\n\t\t\t\tHashMap<Integer,Integer> hash=new HashMap<Integer, Integer>();\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tswitch(tasks[j].key){\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tif(count+tasks[j].e2>=p && e==-1){\n\t\t\t\t\t\t\te=tasks[j].e1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint v=0;\n\t\t\t\t\t\tif(count+tasks[j].e2>=p)v=count+tasks[j].e2-p;\n\t\t\t\t\t\telse v+=tasks[j].e2;\n\t\t\t\t\t\tif(hash.containsKey(tasks[j].e1)){\n\t\t\t\t\t\t\thash.put(tasks[j].e1,hash.get(tasks[j].e1)+v);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\thash.put(tasks[j].e1,v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount=min(count+tasks[j].e2,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\tif(tasks[j].e1==e)e=-1;\n\t\t\t\t\t\tif(hash.containsKey(tasks[j].e1)){\n\t\t\t\t\t\t\tInteger c=hash.get(tasks[j].e1);\n\t\t\t\t\t\t\tcount-=c;\n\t\t\t\t\t\t\thash.put(tasks[j].e1,0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tln(e);\n\t\t\t}\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static ArrayList<Read> read;\n\tpublic static HashMap<Integer, Integer> table;\n\tpublic static HashMap<Integer, Integer> fsize;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\t// 0:write 1:delete 2:read\n\t\t\tint n = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint[][] command = new int[n][3];\n\t\t\tread = new ArrayList<Read>();\n\t\t\ttable = new HashMap<Integer, Integer>();\n\t\t\tfsize = new HashMap<Integer, Integer>();\n\t\t\tHashSet<Integer> used = new HashSet<Integer>();\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tchar c = in.next().charAt(0);\n\t\t\t\tif(c=='W'){\n\t\t\t\t\tcommand[i][1] = in.nextInt();\n\t\t\t\t\tcommand[i][2] = in.nextInt();\n\t\t\t\t\tfsize.put(command[i][1], command[i][2]);\n\t\t\t\t}else if(c=='D'){\n\t\t\t\t\tcommand[i][0] = 1;\n\t\t\t\t\tcommand[i][1] = in.nextInt();\n\t\t\t\t}else{\n\t\t\t\t\tcommand[i][0] = 2;\n\t\t\t\t\tcommand[i][1] = in.nextInt();\n\t\t\t\t\tif(used.contains(command[i][1])) continue;\n\t\t\t\t\tused.add(command[i][1]);\n\t\t\t\t\tread.add(new Read(command[i][1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(read);\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0; i<read.size(); i++){\n\t\t\t\tsum = read.get(i).setSpace(sum);\n\t\t\t\ttable.put(read.get(i).sector, i);\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tswitch(command[i][0]){\n\t\t\t\tcase 0:\n\t\t\t\t\twrite(command[i][1], command[i][2]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tdelete(command[i][1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tSystem.out.println(read(command[i][1]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void delete(int file){\n\t\tint size = fsize.get(file);\n\t\tfor(Read r: read){\n\t\t\tsize -= r.delete(file);\n\t\t\tif(size == 0) break;\n\t\t}\n\t}\n\t\n\tpublic static int read(int sector){\n\t\treturn read.get(table.get(sector)).read();\n\t}\n\t\n\tpublic static void write(int file, int size){\n\t\tfor(Read r: read){\n\t\t\tsize = r.write(file, size);\n\t\t\tif(size == 0) break;\n\t\t}\n\t}\n}\n\nclass Read implements Comparable<Read>{\n\tint file = -1;\n\tHashMap<Integer, Integer> map\n\t\t= new HashMap<Integer, Integer>();\n\tint space;\n\tint sector;\n\tpublic Read(int sector){\n\t\tthis.sector = sector;\n\t\tspace = sector;\n\t}\n\t\n\tpublic int setSpace(int sum){\n\t\tspace -= sum;\n\t\treturn sum+space+1;\n\t}\n\t\n\tpublic int write(int f, int size){\n\t\tint res = 0;\n\t\tint wr = file == -1 ? 1 : 0;\n\t\tif(space == 0 && wr == 0) return size;\n\t\tif(size >= space + wr){\n\t\t\tres = size - space-wr;\n\t\t\tsize = space;\n\t\t\tif(wr==1) file = f;\n\t\t}\n\t\tspace -= size;\n\t\tmap.put(f, size);\n\t\treturn res;\n\t}\n\t\n\tpublic int delete(int f){\n\t\tif(!map.containsKey(f)) return 0;\n\t\tint size = map.get(f);\n\t\tspace += size;\n\t\tmap.remove(f);\n\t\tif(f == file){\n\t\t\tfile = -1;\n\t\t\tsize++;\n\t\t}\n\t\treturn size;\n\t}\n\t\n\tpublic int read(){\n\t\treturn file;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Read o) {\n\t\treturn sector-o.sector;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\t// Scanner sc=new Scanner(System.in);\n\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tString[] ss;\n\n\tvoid run(){\n\t\ttry{\n\t\t\tfor(;;){\n\t\t\t\tn=Integer.parseInt(br.readLine());\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tss=new String[n];\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tss[i]=br.readLine();\n\t\t\t\t}\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}catch(Exception e){}\n\t}\n\n\tvoid solve(){\n\t\tArrayList<Mem> list=new ArrayList<Mem>();\n\t\tboolean[] removed=new boolean[10010];\n\t\tint[] ids=new int[10010];\n\t\tHashMap<Integer, Integer> rev=new HashMap<Integer, Integer>();\n\n\t\tlist.add(new Mem(0, (int)1e9+10));\n\t\tremoved[0]=true;\n\t\tids[0]=-1;\n\t\trev.put(-1, 0);\n\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(String s : ss){\n\t\t\tString[] ss=s.split(\" \");\n\t\t\tif(ss[0].equals(\"W\")){\n\t\t\t\tint id=Integer.parseInt(ss[1]), len=Integer.parseInt(ss[2]);\n\t\t\t\tids[rev.size()+1]=id;\n\t\t\t\trev.put(id, rev.size()+1);\n\t\t\t\tid=rev.get(id);\n\t\t\t\tfor(int i=0, size=list.size(); i<size; i++){\n\t\t\t\t\tMem m=list.get(i);\n\t\t\t\t\tif(removed[m.id]){\n\t\t\t\t\t\tif(len>=m.len){\n\t\t\t\t\t\t\tm.id=id;\n\t\t\t\t\t\t\tlen-=m.len;\n\t\t\t\t\t\t}else if(len<m.len){\n\t\t\t\t\t\t\tint right=m.len-len;\n\t\t\t\t\t\t\tm.id=id;\n\t\t\t\t\t\t\tm.len=len;\n\t\t\t\t\t\t\tlist.add(i+1, new Mem(0, right));\n\t\t\t\t\t\t\tlen=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(len==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(ss[0].equals(\"D\")){\n\t\t\t\tint id=Integer.parseInt(ss[1]);\n\t\t\t\tid=rev.get(id);\n\t\t\t\tremoved[id]=true;\n\t\t\t}else{\n\t\t\t\tint at=Integer.parseInt(ss[1]);\n\t\t\t\tint tot=0;\n\t\t\t\tfor(int i=0, size=list.size(); i<size; i++){\n\t\t\t\t\tMem m=list.get(i);\n\t\t\t\t\tif(tot+m.len>at){\n\t\t\t\t\t\tint id=m.id;\n\t\t\t\t\t\tsb.append(removed[id]?-1:ids[id]).append('\\n');\n\t\t\t\t\t\t// sb.append(ids[id]).append('\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttot+=m.len;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug();\n\t\t\t// for(Mem sec : list){\n\t\t\t// debug(sec.id, sec.len);\n\t\t\t// }\n\t\t\t// debug();\n\t\t}\n\t\tprintln(sb.toString());\n\t}\n\n\tclass Mem{\n\t\tint id, len;\n\n\t\tMem(int id, int len){\n\t\t\tthis.id=id;\n\t\t\tthis.len=len;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\t//public static Random rand=new Random();\n\n\tstatic final int INF =1<<30;\n\n\tstatic class S{\n\t\tlong id,s,e;\n\t\tS(long _id,long _s,long _e){\n\t\t\tid=_id;s=_s;e=_e;\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint N=sc.nextInt();\n\t\t\tif(N==0)return;\n\n\t\t\tLinkedList<S> segs=new LinkedList<S>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tchar k=sc.next().charAt(0);\n\t\t\t\tswitch(k){\n\t\t\t\tcase 'W':\n\t\t\t\t\tint id=sc.nextInt(),len=sc.nextInt();\n\t\t\t\t\tList<S> tmp=new LinkedList<S>();\n\t\t\t\t\tlong s=0,e=len;\n\t\t\t\t\twhile(!segs.isEmpty()){\n\t\t\t\t\t\tS seg=segs.poll();\n\t\t\t\t\t\tif(len==0){\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\t\twhile(!segs.isEmpty())\n\t\t\t\t\t\t\t\ttmp.add(segs.poll());\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(seg.s>s){\n\t\t\t\t\t\t\te=min(s+len,seg.s);\n\t\t\t\t\t\t\tlen-=e-s;\n\t\t\t\t\t\t\ttmp.add(new S(id,s,e));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t\ts=seg.e;\n\t\t\t\t\t}\n\t\t\t\t\tif(len!=0)tmp.add(new S(id,s,s+len));\n\t\t\t\t\tsegs.clear();segs.addAll(tmp);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tid=sc.nextInt();\n\t\t\t\t\ttmp=new LinkedList<S>();\n\t\t\t\t\twhile(!segs.isEmpty()){\n\t\t\t\t\t\tS seg=segs.poll();\n\t\t\t\t\t\tif(seg.id!=id)\n\t\t\t\t\t\t\ttmp.add(seg);\n\t\t\t\t\t}\n\t\t\t\t\tsegs.clear();segs.addAll(tmp);\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tint p=sc.nextInt();\n\t\t\t\t\tboolean ex=false;\n\t\t\t\t\tfor(S seg:segs){\n\t\t\t\t\t\tif(seg.s<=p && p<seg.e){\n\t\t\t\t\t\t\tex=true;\n\t\t\t\t\t\t\tln(seg.id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!ex)ln(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    LinkedList<int[]> list;\n    PriorityQueue<int[]> empty;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        int INF = Integer.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            list = new LinkedList<int[]>(); // from, to, id\n            empty = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[0] - b[0];\n                    }\n                });\n            empty.add(new int[]{0, INF});\n\n            for(int i=0; i<n; i++){\n                char command = sc.next().charAt(0);\n                if(command=='R') print(sc.nextInt());\n                if(command=='W') write(sc.nextInt(), sc.nextInt());\n                if(command=='D') delete(sc.nextInt());\n            }\n            System.out.println();\n        }\n    }\n\n    void print(int idx){\n        for(int i=0; i<list.size(); i++){\n            int[] one = list.poll();\n            if(one[0]<=idx && idx<=one[1]){\n                System.out.println(one[2]);\n                list.add(one);\n                return;\n            }\n            list.add(one);\n        }\n        System.out.println(-1);\n    }\n\n    void write(int idx, int length){\n        while(length>0){\n            int[] one = empty.poll();\n            //System.out.println(Arrays.toString(one));\n            //System.out.println(idx+\" \"+length);\n            int from = one[0], to = Math.min(one[0]+length-1, one[1]);\n            //System.out.println(from+\" \"+to);\n            list.add(new int[]{from, to, idx});\n            int len = to - from + 1;\n            length -= Math.min(length, len);\n            if(length<len) empty.add(new int[]{one[1]-length, one[1]});\n        }\n    }\n\n    void delete(int idx){\n        int size = list.size();\n        for(int i=0; i<list.size(); i++){\n            int[] one = list.poll();\n            if(one[2]==idx) empty.add(new int[]{one[0], one[1]});\n            else list.add(one);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n///Restrictive Filesystem\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint id, s, t;\n\t\tpublic R(int id, int s, int t) {\n\t\t\tthis.id = id;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(-1, 0, 1000000000));\n\t\t\tMap<Integer, List<R>> ref = new HashMap<Integer, List<R>>();\n\t\t\twhile(n--!=0){\n\t\t\t\tCollections.sort(l);\n\t\t\t\tchar cmd = sc.next().charAt(0);\n\t\t\t\tif(cmd=='R'){\n\t\t\t\t\tint p = sc.nextInt(), res = -1;\n\t\t\t\t\tfor(int k:ref.keySet())for(R r:ref.get(k)){\n\t\t\t\t\t\tif(res!=-1)break;\n\t\t\t\t\t\tif(r.s<=p&&p<=r.t)res = r.id;\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(res);\n\t\t\t\t}\n\t\t\t\telse if(cmd=='W'){\n\t\t\t\t\tint id = sc.nextInt(), len = sc.nextInt();\n\t\t\t\t\tList<R> list = new LinkedList<R>();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=-1)continue;\n\t\t\t\t\t\tint L = r.t-r.s+1;\n\t\t\t\t\t\tif(L<len){\n\t\t\t\t\t\t\tlist.add(new R(id, r.s, r.t));\n\t\t\t\t\t\t\tl.remove(i); i--;\n\t\t\t\t\t\t\tlen-=L;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.remove(i);\n\t\t\t\t\t\t\tlist.add(new R(id, r.s, r.s+len-1));\n\t\t\t\t\t\t\tl.add(i, new R(-1, r.s+len, r.t));\n\t\t\t\t\t\t\tref.put(id, list);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint id = sc.nextInt();\n\t\t\t\t\tif(ref.containsKey(id)){\n\t\t\t\t\t\tfor(R r:ref.get(id)){\n\t\t\t\t\t\t\tl.add(new R(-1, r.s, r.t));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tfor(int i=0;i+1<l.size();i++){\n//\t\t\t\t\tR r1 = l.get(i), r2 = l.get(i+1);\n//\t\t\t\t\tif(r1.id!=r2.id)continue;\n//\t\t\t\t\tR r = new R(r1.id, r1.s, r2.t);\n//\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, r);\n//\t\t\t\t\ti--;\n//\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n///Restrictive Filesystem\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint id, s, t;\n\t\tpublic R(int id, int s, int t) {\n\t\t\tthis.id = id;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(-1, 0, 1000000000));\n\t\t\twhile(n--!=0){\n//\t\t\t\tCollections.sort(l);\n\t\t\t\tchar cmd = sc.next().charAt(0);\n\t\t\t\tif(cmd=='R'){\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tfor(R r:l){\n\t\t\t\t\t\tif(r.s<=p&&p<=r.t){\n\t\t\t\t\t\t\tSystem.out.println(r.id); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cmd=='W'){\n\t\t\t\t\tint id = sc.nextInt(), len = sc.nextInt();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=-1)continue;\n\t\t\t\t\t\tint L = r.t-r.s+1;\n\t\t\t\t\t\tif(L<len){\n\t\t\t\t\t\t\tr.id = id;\n\t\t\t\t\t\t\tlen-=L;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.remove(i);\n\t\t\t\t\t\t\tl.add(i, new R(id, r.s, r.s+len-1));\n\t\t\t\t\t\t\tl.add(i+1, new R(r.id, r.s+len, r.t));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint id = sc.nextInt();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=id)continue;\n\t\t\t\t\t\tr.id = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n \n \npublic class Main{\n\tpublic static class File{\n\t\tint identifer;\n\t\tlong start;\n\t\tlong size;\n\t\t\n\t\tpublic File(int identifer, long start, long size) {\n\t\t\tsuper();\n\t\t\tthis.identifer = identifer;\n\t\t\tthis.start = start;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.identifer + \" \" + this.start + \"->\" + (this.start + this.size - 1);\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\t\n    \t\tif(N == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tLinkedList<File> files = new LinkedList<File>();\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tString ops = sc.next();\n    \t\t\t\n    \t\t\t//System.out.println(files);\n    \t\t\t\n    \t\t\tif(\"W\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\tfinal int S = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tlong rest = S;\n    \t\t\t\tlong pos = 0;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(pos < file.start){\n    \t\t\t\t\t\titer.previous();\n    \t\t\t\t\t\titer.add(new File(l, pos, file.start - pos));\n    \t\t\t\t\t\trest -= file.start - pos;\n    \t\t\t\t\t\titer.next();\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tpos = file.start + file.size;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(rest > 0){\n    \t\t\t\t\tfiles.add(new File(l, pos, rest));\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"D\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.identifer == l){\n    \t\t\t\t\t\titer.remove();\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"R\".equals(ops)){\n    \t\t\t\tfinal int P = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tboolean found = false;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.start <= P && P < file.start + file.size){\n    \t\t\t\t\t\tSystem.out.println(file.identifer);\n    \t\t\t\t\t\tfound = true;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}else if(file.start > P){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(!found){\n    \t\t\t\t\tSystem.out.println(-1);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println();\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Restrictive Filesystem\n// 2013/05/13\npublic class Main{\n\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n\tint n;\n\tString[] ss;\n\n\tvoid run(){\n\t\ttry{\n\t\t\tfor(;;){\n\t\t\t\tn=Integer.parseInt(br.readLine());\n\t\t\t\tif(n==0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tss=new String[n];\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tss[i]=br.readLine();\n\t\t\t\t}\n\t\t\t\tsolve();\n\t\t\t}\n\t\t}catch(Exception e){}\n\t}\n\n\tvoid solve(){\n\t\tArrayList<Mem> list=new ArrayList<Mem>();\n\t\tboolean[] removed=new boolean[10010];\n\t\tint[] ids=new int[10010];\n\t\tHashMap<Integer, Integer> rev=new HashMap<Integer, Integer>();\n\n\t\tlist.add(new Mem(0, (int)1e9+10));\n\t\tremoved[0]=true;\n\t\tids[0]=-1;\n\t\trev.put(-1, 0);\n\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(String s : ss){\n\t\t\tString[] ss=s.split(\" \");\n\t\t\tif(ss[0].equals(\"W\")){\n\t\t\t\tint id=Integer.parseInt(ss[1]), len=Integer.parseInt(ss[2]);\n\t\t\t\tids[rev.size()+1]=id;\n\t\t\t\trev.put(id, rev.size()+1);\n\t\t\t\tid=rev.get(id);\n\t\t\t\tfor(int i=0, size=list.size(); i<size; i++){\n\t\t\t\t\tMem m=list.get(i);\n\t\t\t\t\tif(removed[m.id]){\n\t\t\t\t\t\tif(len>=m.len){\n\t\t\t\t\t\t\tm.id=id;\n\t\t\t\t\t\t\tlen-=m.len;\n\t\t\t\t\t\t}else if(len<m.len){\n\t\t\t\t\t\t\tint right=m.len-len;\n\t\t\t\t\t\t\tm.id=id;\n\t\t\t\t\t\t\tm.len=len;\n\t\t\t\t\t\t\tlist.add(i+1, new Mem(0, right));\n\t\t\t\t\t\t\tlen=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(len==0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(ss[0].equals(\"D\")){\n\t\t\t\tint id=Integer.parseInt(ss[1]);\n\t\t\t\tremoved[rev.get(id)]=true;\n\t\t\t}else{\n\t\t\t\tint at=Integer.parseInt(ss[1]);\n\t\t\t\tint tot=0;\n\t\t\t\tfor(int i=0, size=list.size(); i<size; i++){\n\t\t\t\t\tMem m=list.get(i);\n\t\t\t\t\tif(tot+m.len>at){\n\t\t\t\t\t\tint id=m.id;\n\t\t\t\t\t\tsb.append(removed[id]?-1:ids[id]).append('\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttot+=m.len;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(sb.toString());\n\t}\n\n\tclass Mem{\n\t\tint id, len;\n\n\t\tMem(int id, int len){\n\t\t\tthis.id=id;\n\t\t\tthis.len=len;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n\n  \n\n    public static void main(String args[])\n    {\n\tScanner in = new Scanner(System.in);\n\tint N;\n\tboolean aaa = true;\n\twhile(true)\n\t    {\n\n\t\tN = in.nextInt();\n\t\tif(N == 0)break;\n\n\t\tif(!aaa)System.out.println();\n\t\taaa = false;\n\t\tLinkedList<P> list = new LinkedList<P>();\n\t\tlist.add(new P(0,0,-1));\n\n\t\tString c;\n\t\tint I,S;\n\t\tfor(int i=0;i<N;i++)\n\t\t    {\n\t\t\tc = in.next();\n\t\t\tif(c.equals(\"W\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tS = in.nextInt();\n\t\t\t\tfor(int j=0;j<list.size()-1;j++)\n\t\t\t\t    {\t\n\t\t\t\t\tint v1 = list.get(j).r;\n\t\t\t\t\tint v2 = list.get(j+1).l;\n\t\t\t\t\tif(v1 == v2)continue;\n\t\t\t\t\t//System.out.println(\"add ! \" + j + \" \" + v1 + \" \" + v2);\n\t\t\t\t\tlist.add(j+1,new P(v1,Math.min((v2-v1)+v1,v1+S),I) ); \n\t\t\t\t\tS -= (v2-v1);\n\t\t\t\t\tif(S < 0)S = 0;\n\n\t\t\t\t\tif(S == 0)break;\n\t\t\t\t    }\n\t\t\t\tif(S != 0)\n\t\t\t\t    {\n\n\t\t\t\t\t\tint lass = (list.size()-1 >= 0?list.get(list.size()-1).r:0);\n\t\t\t\t\t\tlist.add(new P(lass,lass+S,I));\n\n\t\t\t\t    }\n\t\t\t\t\t\n\t\t\t    }\n\t\t\telse if(c.equals(\"D\"))\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tint v = list.get(j).id;\n\t\t\t\t\tif(v == I)\n\t\t\t\t\t    {\n\t\t\t\t\t\tP p = list.remove(j);\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t    }\n\t\t\telse\n\t\t\t    {\n\t\t\t\tI = in.nextInt();\n\t\t\t\tboolean found = false;\n\t\t\t\tfor(int j=1;j<list.size();j++)\n\t\t\t\t    {\n\t\t\t\t\tP p = list.get(j);\n\t\t\t\t\tif(p.l <= I && I < p.r)\n\t\t\t\t\t    {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tSystem.out.println(p.id);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t    }\n\t\t\t\t    }\n\t\t\t\tif(!found)System.out.println(-1);\n\t\t\t    }\n\t\t\t/*\n\t\t\tSystem.out.println(\"------------\");\n\t\t\tfor(int j=0;j<list.size();j++)\n\t\t\t    {\n\t\t\t\tSystem.out.println(list.get(j).l + \" - \" +list.get(j).r + \" : \" + list.get(j).id);\n\t\t\t    }\n\t\t\tSystem.out.println(\"------------\");\n\t\t\t*/\n\t\t    }\n\n\t    }\n    }\n}\n\nclass P\n{\n    public int r,l,id;\n    P(int rl,int rr,int rid)\n    {\n\tr = rr;\n\tl = rl;\n\tid = rid;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n///Restrictive Filesystem\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint id, s, t;\n\t\tpublic R(int id, int s, int t) {\n\t\t\tthis.id = id;\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn s-o.s;\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tList<R> l = new LinkedList<R>();\n\t\t\tl.add(new R(-1, 0, 1000000000));\n\t\t\twhile(n--!=0){\n//\t\t\t\tCollections.sort(l);\n\t\t\t\tchar cmd = sc.next().charAt(0);\n\t\t\t\tif(cmd=='R'){\n\t\t\t\t\tint p = sc.nextInt();\n\t\t\t\t\tfor(R r:l){\n\t\t\t\t\t\tif(r.s<=p&&p<=r.t){\n\t\t\t\t\t\t\tSystem.out.println(r.id); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(cmd=='W'){\n\t\t\t\t\tint id = sc.nextInt(), len = sc.nextInt();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=-1)continue;\n\t\t\t\t\t\tint L = r.t-r.s+1;\n\t\t\t\t\t\tif(L<len){\n\t\t\t\t\t\t\tr.id = id;\n\t\t\t\t\t\t\tlen-=L;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tl.remove(i);\n\t\t\t\t\t\t\tl.add(i, new R(id, r.s, r.s+len-1));\n\t\t\t\t\t\t\tl.add(i+1, new R(r.id, r.s+len, r.t));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint id = sc.nextInt();\n\t\t\t\t\tfor(int i=0;i<l.size();i++){\n\t\t\t\t\t\tR r = l.get(i);\n\t\t\t\t\t\tif(r.id!=id)continue;\n\t\t\t\t\t\tr.id = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i+1<l.size();i++){\n\t\t\t\t\tR r1 = l.get(i), r2 = l.get(i+1);\n\t\t\t\t\tif(r1.id!=r2.id)continue;\n\t\t\t\t\tR r = new R(r1.id, r1.s, r2.t);\n\t\t\t\t\tl.remove(i); l.remove(i); l.add(i, r);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    LinkedList<int[]> list;\n    PriorityQueue<int[]> empty;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        int INF = Integer.MAX_VALUE;\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            list = new LinkedList<int[]>(); // from, to, id\n            empty = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                    public int compare(int[] a, int[] b){\n                        return a[0] - b[0];\n                    }\n                });\n            empty.add(new int[]{0, INF});\n\n            for(int i=0; i<n; i++){\n                char command = sc.next().charAt(0);\n                if(command=='R') print(sc.nextInt());\n                if(command=='W') write(sc.nextInt(), sc.nextInt());\n                if(command=='D') delete(sc.nextInt());\n            }\n            System.out.println();\n            System.gc();\n        }\n    }\n\n    void print(int idx){\n        for(int i=0; i<list.size(); i++){\n            int[] one = list.poll();\n            if(one[0]<=idx && idx<=one[1]){\n                System.out.println(one[2]);\n                list.add(one);\n                return;\n            }\n            list.add(one);\n        }\n        System.out.println(-1);\n    }\n\n    void write(int idx, int length){\n        while(length>0){\n            int[] one = empty.poll();\n            int from = one[0], to = Math.min(one[0]+length-1, one[1]);\n            list.add(new int[]{from, to, idx});\n            length -= Math.min(length, to-from+1);\n            if(to<one[1]) empty.add(new int[]{to+1, one[1]});\n        }\n    }\n\n    void delete(int idx){\n        int size = list.size();\n        for(int i=0; i<size; i++){\n            int[] one = list.poll();\n            if(one[2]==idx) empty.add(new int[]{one[0], one[1]});\n            else list.add(one);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tArrayList<Integer> from = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> to = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> idlist = new ArrayList<Integer>();\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint id, S;\n\t\t\t\tchar command = in.next().charAt(0);\n\t\t\t\tswitch(command) {\n\t\t\t\tcase 'W':\n//\t\t\t\t\tSystem.out.println(\"----------Write---------\");\n\t\t\t\t\tid = in.nextInt(); S = in.nextInt();\n\t\t\t\t\tint idx = 0;\n\t\t\t\t\twhile (S > 0) {\n//\t\t\t\t\t\tSystem.out.println(idx + \" \" + S);\n\t\t\t\t\t\tint min = idx + S, cur = -1;\n\t\t\t\t\t\tfor (int j = 0; j < from.size(); j++) {\n\t\t\t\t\t\t\tif (idx < to.get(j) && min > from.get(j)) {\n\t\t\t\t\t\t\t\tmin = from.get(j);\n\t\t\t\t\t\t\t\tcur = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cur != -1) {\n//\t\t\t\t\t\t\tSystem.out.println(\"cur = else\");\n\t\t\t\t\t\t\tif (idx < min) {\n\t\t\t\t\t\t\t\tfrom.add(idx);\n\t\t\t\t\t\t\t\tto.add(min - 1);\n\t\t\t\t\t\t\t\tidlist.add(id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tS -= min - idx;\n\t\t\t\t\t\t\tidx = to.get(cur) + 1;\n\t\t\t\t\t\t} else {\n//\t\t\t\t\t\t\tSystem.out.println(\"cur = -1\");\n\t\t\t\t\t\t\tfrom.add(idx);\n\t\t\t\t\t\t\tto.add(idx + S - 1);\n\t\t\t\t\t\t\tidlist.add(id);\n\t\t\t\t\t\t\tS = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n//\t\t\t\t\tSystem.out.println(Arrays.toString(idlist.toArray(new Integer[0])));\n//\t\t\t\t\tSystem.out.println(Arrays.toString(from.toArray(new Integer[0])));\n//\t\t\t\t\tSystem.out.println(Arrays.toString(to.toArray(new Integer[0])));\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n//\t\t\t\t\tSystem.out.println(\"---------Delete---------\");\n\t\t\t\t\tid = in.nextInt();\n\t\t\t\t\tfor (int j = idlist.size() - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (idlist.get(j) == id) {\n\t\t\t\t\t\t\tfrom.remove(j);\n\t\t\t\t\t\t\tto.remove(j);\n\t\t\t\t\t\t\tidlist.remove(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n//\t\t\t\t\tSystem.out.println(Arrays.toString(idlist.toArray(new Integer[0])));\n//\t\t\t\t\tSystem.out.println(Arrays.toString(from.toArray(new Integer[0])));\n//\t\t\t\t\tSystem.out.println(Arrays.toString(to.toArray(new Integer[0])));\n//\t\t\t\t\tSystem.out.println();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n//\t\t\t\t\tSystem.out.println(\"--------Read----------\");\n\t\t\t\t\tid = in.nextInt();\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor (int j = 0; j < idlist.size(); j++) {\n\t\t\t\t\t\tint f = from.get(j), t = to.get(j);\n\t\t\t\t\t\tif (f <= id && id <= t) {\n\t\t\t\t\t\t\tSystem.out.println(idlist.get(j));\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (flag) System.out.println(-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tLinkedList<Segment> list = new LinkedList<Segment>();\n\t\t\tlist.add(new Segment(-1, 0));\n\t\t\tlist.add(new Segment(-2, 1000000001));\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tchar command = sc.next().charAt(0);\n\t\t\t\tif (command == 'W') {\n\t\t\t\t\tint I = sc.nextInt();\n\t\t\t\t\tint S = sc.nextInt();\n\t\t\t\t\tListIterator<Segment> itr = list.listIterator();\n\t\t\t\t\tSegment cur = itr.next();\n\t\t\t\t\twhile (S > 0) {\n\t\t\t\t\t\tSegment next = itr.next();\n\t\t\t\t\t\tif (cur.i == -1) {\n\t\t\t\t\t\t\tif (next.pos - cur.pos <= S) {\n\t\t\t\t\t\t\t\tcur.i = I;\n\t\t\t\t\t\t\t\tS -= next.pos - cur.pos;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titr.previous();\n\t\t\t\t\t\t\t\titr.previous();\n\t\t\t\t\t\t\t\titr.add(new Segment(I, cur.pos));\n\t\t\t\t\t\t\t\tcur.pos += S;\n\t\t\t\t\t\t\t\tS = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t}\n\t\t\t\t} else if (command == 'D') {\n\t\t\t\t\tint I = sc.nextInt();\n\t\t\t\t\tListIterator<Segment> itr = list.listIterator();\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tSegment cur = itr.next();\n\t\t\t\t\t\tif (cur.i == I) {\n\t\t\t\t\t\t\tcur.i = -1;\n\t\t\t\t\t\t\titr.previous();\n\t\t\t\t\t\t\tif (itr.hasPrevious()) {\n\t\t\t\t\t\t\t\tSegment prev = itr.previous();\n\t\t\t\t\t\t\t\titr.next();\n\t\t\t\t\t\t\t\titr.next();\n\t\t\t\t\t\t\t\tif (prev.i == -1) {\n\t\t\t\t\t\t\t\t\titr.remove();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titr.next();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (itr.hasNext() && itr.next().i == -1) {\n\t\t\t\t\t\t\t\titr.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint P = sc.nextInt();\n\t\t\t\t\tListIterator<Segment> itr = list.listIterator();\n\t\t\t\t\tSegment cur = itr.next();\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tSegment next = itr.next();\n\t\t\t\t\t\tif (P < next.pos) {\n\t\t\t\t\t\t\tSystem.out.println(cur.i);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcur = next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic class Segment {\n\t\tint i, pos;\n\n\t\tpublic Segment(int i, int pos) {\n\t\t\tthis.i = i;\n\t\t\tthis.pos = pos;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n \n \npublic class Main{\n\tpublic static class File{\n\t\tint identifer;\n\t\tint start;\n\t\tint size;\n\t\t\n\t\tpublic File(int identifer, int start, int size) {\n\t\t\tsuper();\n\t\t\tthis.identifer = identifer;\n\t\t\tthis.start = start;\n\t\t\tthis.size = size;\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn this.identifer + \" \" + this.start + \"->\" + (this.start + this.size - 1);\n\t\t}\n\t}\n\t\n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \twhile(true){\n    \t\tfinal int N = sc.nextInt();\n    \t\t\n    \t\tif(N == 0){\n    \t\t\tbreak;\n    \t\t}\n    \t\t\n    \t\tLinkedList<File> files = new LinkedList<File>();\n    \t\t\n    \t\tfor(int i = 0; i < N; i++){\n    \t\t\tString ops = sc.next();\n    \t\t\t\n    \t\t\t//System.out.println(files);\n    \t\t\t\n    \t\t\tif(\"W\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\tfinal int S = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tint rest = S;\n    \t\t\t\tint pos = 0;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(pos < file.start){\n    \t\t\t\t\t\titer.previous();\n    \t\t\t\t\t\titer.add(new File(l, pos, file.start - pos));\n    \t\t\t\t\t\trest -= file.start - pos;\n    \t\t\t\t\t\titer.next();\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tpos = file.start + file.size;\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(rest > 0){\n    \t\t\t\t\tfiles.add(new File(l, pos, rest));\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"D\".equals(ops)){\n    \t\t\t\tfinal int l = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.identifer == l){\n    \t\t\t\t\t\titer.remove();\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t}else if(\"R\".equals(ops)){\n    \t\t\t\tfinal int P = sc.nextInt();\n    \t\t\t\t\n    \t\t\t\tboolean found = false;\n    \t\t\t\tfor(ListIterator<File> iter = files.listIterator(); iter.hasNext(); ){\n    \t\t\t\t\tFile file = iter.next();\n    \t\t\t\t\t\n    \t\t\t\t\tif(file.start <= P && P < file.start + file.size){\n    \t\t\t\t\t\tSystem.out.println(file.identifer);\n    \t\t\t\t\t\tfound = true;\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}else if(file.start > P){\n    \t\t\t\t\t\tbreak;\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(!found){\n    \t\t\t\t\tSystem.out.println(-1);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tSystem.out.println();\n    \t\t\n    \t}\n    \t\n    \t\n    \t\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n \nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n \npublic class Main {\n \n    int INF = 1 << 28;\n    int MAX = 1000000000;\n    void run() {\n        Scanner sc = new Scanner(System.in);\n        for(;;) {\n            int n = sc.nextInt();\n            if( n == 0 ) break;\n             \n            LinkedList<Seg> list = new LinkedList<Seg>();\n            for(int i=0;i<n;i++) {\n//              for(Seg seg: list) debug(seg.id, seg.s, seg.e);\n//              debug(\" \");\n                switch ( sc.next().charAt(0) ) {\n                case 'W':\n                    int l = sc.nextInt();\n                    int mem = sc.nextInt();\n                    LinkedList<Seg> tmp = new LinkedList<Seg>();\n                 \n                    long s = 0; long e = mem;\n                    for(;!list.isEmpty();) {\n                        Seg seg = list.removeFirst();\n                        if(mem == 0) {\n                            tmp.add(seg);\n                            for(;!list.isEmpty();)\n                                tmp.addLast(list.removeFirst());\n                            break;\n                        }\n                        if( seg.s > s ) {\n                            e = min(s + mem, seg.s);\n                            mem -= (e-s);\n                            tmp.addLast(new Seg(l, s, e));\n                            tmp.addLast(seg);\n                        }\n                        else {\n                            tmp.addLast(seg);\n                        }\n                        s = seg.e;\n                    }\n                    if(mem != 0) tmp.addLast(new Seg(l, s, s+mem));\n                    list.clear();\n                    list.addAll(tmp);\n                    break;\n                 \n                case 'D':\n                    l = sc.nextInt();\n                    tmp = new LinkedList<Seg>();\n                    for(;!list.isEmpty();) {\n                        Seg seg = list.removeFirst();\n                        if(seg.id == l);\n                        else tmp.addLast(seg);\n                    }\n                     \n                    list.clear();\n                    list.addAll(tmp);\n                    break;\n                 \n                case 'R':\n                    int p = sc.nextInt();\n                    boolean flg = false;\n                    for(Seg seg: list) {\n                        if( seg.s <= p && p < seg.e ) {\n                            flg = true;\n                            System.out.println(seg.id);\n                        }\n                    }\n                    if(!flg) System.out.println(-1);\n                }\n            }\n            System.out.println();\n        }\n    }\n     \n    class Seg {\n        long id, s, e;\n        Seg(long id, long s, long e) {\n            this.s = s;\n            this.id = id;\n            this.e = e;\n        }\n    }\n \n    public static void main(String[] args) {\n        new Main().run();\n    }\n \n    void debug(Object... os) {\n        System.err.println(Arrays.deepToString(os));\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Task{\n\t\tchar key;\n\t\tint e1=-1,e2=-1;\n\t\tTask(char _key,int _e1,int _e2){\n\t\t\tkey=_key;e1=_e1;e2=_e2;\n\t\t}\n\t}\n\n\tint N,M,L;\n\tpublic void run() {\n\t\tHashMap<Integer,Integer> hash=new HashMap<Integer, Integer>();\n\n\t\tCase:while(true){\n\t\t\tN=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tTask[] tasks=new Task[N];\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tchar k=sc.next().charAt(0);\n\t\t\t\tswitch(k){\n\t\t\t\tcase 'W':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),sc.nextInt());\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),-1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\ttasks[i]=new Task(k,sc.nextInt(),-1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<N;i++)if(tasks[i].key=='R'){\n\t\t\t\tint p=tasks[i].e1+1;\n\t\t\t\tint e=-1;\n\t\t\t\tint count=0;\n\t\t\t\thash.clear();\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tswitch(tasks[j].key){\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tif(count+tasks[j].e2>=p && e==-1)\n\t\t\t\t\t\t\te=tasks[j].e1;\n\n\t\t\t\t\t\tint v=0;\n\t\t\t\t\t\tif(count+tasks[j].e2>=p)v=count+tasks[j].e2-p;\n\t\t\t\t\t\telse v+=tasks[j].e2;\n\t\t\t\t\t\tif(hash.containsKey(tasks[j].e1))\n\t\t\t\t\t\t\thash.put(tasks[j].e1,hash.get(tasks[j].e1)+v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\thash.put(tasks[j].e1,v);\n\n\t\t\t\t\t\tcount=min(count+tasks[j].e2,p);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\tif(tasks[j].e1==e)\n\t\t\t\t\t\t\te=-1;\n\n\t\t\t\t\t\tif(hash.containsKey(tasks[j].e1)){\n\t\t\t\t\t\t\tint c=hash.get(tasks[j].e1);\n\t\t\t\t\t\t\tcount-=c;\n\t\t\t\t\t\t\thash.remove(tasks[j].e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tln(e);\n\t\t\t}\n\t\t\tln();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class S : IComparable\n{\n    public int from { get; set; }\n    public int to { get; set; }\n    public int id { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (S)obj;\n        if (this.from > x.from) return 1;\n        else if (this.from == x.from) return 0;\n        else return -1;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var first = true;  \n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var ss = new List<S>();\n            ss.Add(new S { from = 0, to = 1000000000 ,id = -1});\n            var wh1= true;\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var cmd = line[0];\n                if (cmd == \"W\")\n                {\n                    var id = int.Parse(line[1]);\n                    var a = int.Parse(line[2]);\n                    cmdW(ss, id, a);\n                }\n                else if (cmd == \"D\")\n                {\n                    var id = int.Parse(line[1]);\n                    cmdD(ss, id);\n                }\n                else\n                {\n                    var p = int.Parse(line[1]);\n                    if (first && wh1) { first = false; wh1 = false; }\n                    else if (!first && wh1) { wh1 = false; Console.WriteLine(); }\n                    Console.WriteLine(cmdR(ss,p ));\n                }\n            }\n        }\n    }\n    public static int cmdR (List<S> ss, int p )\n    {\n        var a = ss.Where(x => x.from <= p && x.to >= p).First();\n        return a.id;\n    }\n    public static void cmdD (List<S> ss, int id)\n    {\n        foreach (var x in ss.Where(y => y.id == id))\n            x.id = -1;\n    }\n    public static void cmdW (List<S> ss , int id , int a)\n    {\n        var w = new S();\n        var write = false;\n        foreach (var x in ss.Where(y =>y.id == -1))\n        {\n            if (x.to - x.from + 1 > a)\n            {\n                w.to = x.to;\n                x.to = x.from + a - 1;\n                w.id = x.id;\n                x.id = id;\n                w.from = x.to + 1;\n                write = true;\n                break;\n            }\n            else if (x.to - x.from + 1 == a) { x.id = id; break; }\n            else { x.id = id; a -= x.to - x.from + 1; }\n        }\n        if (write) ss.Add(w);\n        ss.Sort();\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class S : IComparable\n{\n    public int from { get; set; }\n    public int to { get; set; }\n    public int id { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (S)obj;\n        if (this.from > x.from) return 1;\n        else if (this.from == x.from) return 0;\n        else return -1;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var first = true;  \n        while (true)\n        {\n            if (first) first = false;\n            else Console.WriteLine();\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var ss = new List<S>();\n            ss.Add(new S { from = 0, to = 1000000000 ,id = -1});\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var cmd = line[0];\n                if (cmd == \"W\")\n                {\n                    var id = int.Parse(line[1]);\n                    var a = int.Parse(line[2]);\n                    cmdW(ss, id, a);\n                }\n                else if (cmd == \"D\")\n                {\n                    var id = int.Parse(line[1]);\n                    cmdD(ss, id);\n                }\n                else\n                {\n                    var p = int.Parse(line[1]);\n                    Console.WriteLine(cmdR(ss,p ));\n                }\n            }\n        }\n    }\n    public static int cmdR (List<S> ss, int p )\n    {\n        var a = ss.Where(x => x.from <= p && x.to >= p).First();\n        return a.id;\n    }\n    public static void cmdD (List<S> ss, int id)\n    {\n        foreach (var x in ss.Where(y => y.id == id))\n            x.id = -1;\n    }\n    public static void cmdW (List<S> ss , int id , int a)\n    {\n        var w = new S();\n        var write = false;\n        foreach (var x in ss.Where(y =>y.id == -1))\n        {\n            if (x.to - x.from + 1 > a)\n            {\n                w.to = x.to;\n                x.to = x.from + a - 1;\n                w.id = x.id;\n                x.id = id;\n                w.from = x.to + 1;\n                write = true;\n                break;\n            }\n            else if (x.to - x.from + 1 == a) { x.id = id; break; }\n            else { x.id = id; a -= x.to - x.from + 1; }\n        }\n        if (write) ss.Add(w);\n        ss.Sort();\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class S : IComparable\n{\n    public int from { get; set; }\n    public int to { get; set; }\n    public int id { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (S)obj;\n        if (this.from > x.from) return 1;\n        else if (this.from == x.from) return 0;\n        else return -1;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var first = true;  \n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var ss = new List<S>();\n            ss.Add(new S { from = 0, to = 1000000000 ,id = -1});\n            var wh1= true;\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var cmd = line[0];\n                if (cmd == \"W\")\n                {\n                    var id = int.Parse(line[1]);\n                    var a = int.Parse(line[2]);\n                    cmdW(ss, id, a);\n                }\n                else if (cmd == \"D\")\n                {\n                    var id = int.Parse(line[1]);\n                    cmdD(ss, id);\n                }\n                else\n                {\n                    var p = int.Parse(line[1]);\n                    if (first && wh1) { first = false; wh1 = false; }\n                    else if (!first && wh1) { wh1 = false; Console.WriteLine(); }\n                    Console.WriteLine(cmdR(ss,p ));\n                }\n            }\n        }\n    }\n    public static int cmdR (List<S> ss, int p )\n    {\n        var a = ss.Where(x => x.from <= p && x.to >= p).First();\n        return a.id;\n    }\n    public static void cmdD (List<S> ss, int id)\n    {\n        foreach (var x in ss.Where(y => y.id == id))\n            x.id = -1;\n    }\n    public static void cmdW (List<S> ss , int id , int a)\n    {\n        var w = new S();\n        var write = false;\n        foreach (var x in ss.Where(y =>y.id == -1))\n        {\n            if (x.to - x.from + 1 > a)\n            {\n                w.to = x.to;\n                x.to = x.from + a - 1;\n                w.id = x.id;\n                x.id = id;\n                w.from = x.to + 1;\n                write = true;\n                break;\n            }\n            else if (x.to - x.from + 1 == a) { x.id = id; break; }\n            else x.id = id;\n        }\n        if (write) ss.Add(w);\n        ss.Sort();\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class S : IComparable\n{\n    public int from { get; set; }\n    public int to { get; set; }\n    public int id { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (S)obj;\n        if (this.from > x.from) return 1;\n        else if (this.from == x.from) return 0;\n        else return -1;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var first = true;  \n        while (true)\n        {\n            if (first) first = false;\n            else Console.WriteLine();\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var ss = new List<S>();\n            ss.Add(new S { from = 0, to = 1000000000 ,id = -1});\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var cmd = line[0];\n                if (cmd == \"W\")\n                {\n                    var id = int.Parse(line[1]);\n                    var a = int.Parse(line[2]);\n                    cmdW(ss, id, a);\n                }\n                else if (cmd == \"D\")\n                {\n                    var id = int.Parse(line[1]);\n                    cmdD(ss, id);\n                }\n                else\n                {\n                    var p = int.Parse(line[1]);\n                    Console.WriteLine(cmdR(ss,p ));\n                }\n            }\n        }\n    }\n    public static int cmdR (List<S> ss, int p )\n    {\n        var a = ss.Where(x => x.from <= p && x.to >= p).First();\n        return a.id;\n    }\n    public static void cmdD (List<S> ss, int id)\n    {\n        foreach (var x in ss.Where(y => y.id == id))\n            x.id = -1;\n    }\n    public static void cmdW (List<S> ss , int id , int a)\n    {\n        var w = new S();\n        var write = false;\n        foreach (var x in ss.Where(y =>y.id == -1))\n        {\n            if (x.to - x.from + 1 > a)\n            {\n                w.to = x.to;\n                x.to = x.from + a - 1;\n                w.id = x.id;\n                x.id = id;\n                w.from = x.to + 1;\n                write = true;\n                break;\n            }\n            else if (x.to - x.from + 1 == a) { x.id = id; break; }\n            else { x.id = id; a -= x.to - x.from + 1; }\n        }\n        if (write) { ss.Add(w); ss.Sort(); }\n    }\n}\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "def min_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] < $heap[x][0]\n    minimum = l\n  else\n    minimum = x\n  end\n  if r <= $n && $heap[r][0] < $heap[minimum][0]\n    minimum = r\n  end\n  if minimum != x\n    $heap[x], $heap[minimum] = $heap[minimum], $heap[x]\n    min_heapify(minimum)\n  end\nend\n\ndef extract(x)\n  key = $heap[x]\n  $heap[x] = $heap[$n]\n  $n -= 1\n  min_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n   i = $n\n  while i > 1 && $heap[i/2][0] > $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef find(sec)\n  (1..$n).each do |x|\n    top, size, _ = $heap[x]\n    return x if top <= sec && sec - top < size\n  end\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  $n = 0\n  $heap = []\n  insert([0, 1000000001, -1])\n  table = {}\n  n.times do\n    l = gets.split\n    cmd = l.shift\n    case cmd\n    when \"W\"\n      x, s = l.map(&:to_i)\n      pos = 1\n      table[x] = []\n      while s > 0\n        if $heap[pos][2] == -1\n          top, size, _ = extract(pos)\n          if size > s\n            insert([top, s, x])\n            insert([top + s, size - s, -1])\n          else\n            insert([top, size, x])\n          end\n          table[x] << top\n          s -= size\n        end\n        pos += 1\n      end\n    when \"D\"\n      x = l[0].to_i\n      table[x].each do |top|\n        top, size, id = extract(find(top))\n        insert([top, size, -1])\n      end\n      table[x] = []\n    when \"R\"\n      sec = l[0].to_i\n      p $heap[find(sec)][2]\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\t\n\tsegments = { -1 => [[0, Float::INFINITY]] }\t\n\n\tn.times do\n\t\tcommand, i, s = gets.chomp.split\n\t\ti = i.to_i\n\n\t\tif command == \"W\"\n\t\t\ts = s.to_i\n\t\t\tnext if s <= 0\n\t\t\t\n\t\t\tseg = []\n\t\t\tloop do\n\t\t\t\temp = segments[-1].shift\n\t\t\t\tstart, len = emp\n\t\t\t\tif s < len\n\t\t\t\t\temp[0] += s\n\t\t\t\t\temp[1] -= s\n\t\t\t\t\tseg << [start, s]\n\t\t\t\t\tsegments[-1].unshift emp\n\t\t\t\t\tbreak\n\t\t\t\telse \n\t\t\t\t\ts -= len\n\t\t\t\t\tseg << emp\n\t\t\t\tend\n\t\t\tend\n\t\t\tsegments[i] = seg\n\n\t\telsif command == \"D\"\n\t\t\tmerged = []\n\t\t\te_segs = segments[-1]\n\t\t\td_segs = segments[i]\n\n\t\t\tloop do\n\t\t\t\tif e_segs.empty? || d_segs.empty?\n\t\t\t\t\tmerged += d_segs + e_segs\n\t\t\t\t\tbreak\n\t\t\t\tend\n\n\t\t\t\ttarget = nil\n\t\t\t\tif e_segs[0][0] < d_segs[0][0]\n\t\t\t\t\ttarget = e_segs.shift\t\n\t\t\t\telse\n\t\t\t\t\ttarget = d_segs.shift\t\n\t\t\t\tend\n\n\t\t\t\tif !merged.empty? && merged[-1][0] + merged[-1][1] == target[0]\n\t\t\t\t\tmerged[-1][1] += target[1]\n\t\t\t\telse\n\t\t\t\t\tmerged << target\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tsegments[-1] = merged\n\t\t\tsegments.delete(i)\n\n\t\telse\n\t\t\tsegments.each do |k, arr|\n\t\t\t\tstart, len = arr.bsearch_last_item {|start, len| start <= i}\n\t\t\t\tif start && i < start + len\n\t\t\t\t\tputs k\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tputs\nend"
  },
  {
    "language": "Ruby",
    "code": "while n = gets.to_i\n  break if n == 0\n  arr = []\n  arr << [0, 1000000001, -1]\n  n.times do\n    l = gets.split\n    cmd = l.shift\n    case cmd\n    when \"W\"\n      x, s = l.map(&:to_i)\n      arr.size.times do |i|\n        p, size, y = arr[i]\n        if y == -1\n          arr[i][2] = x\n          if size <= s\n            s -= size\n          else\n            arr[i][1] = s\n            arr.insert(i + 1, [p + s, size - s, -1])\n            break\n          end\n        end\n      end\n    when \"D\"\n      x = l[0].to_i\n      arr.size.times do |i|\n        arr[i][2] = -1 if arr[i][2] == x\n      end\n    when \"R\"\n      sec = l[0].to_i\n      arr.size.times do |i|\n        p, size, y = arr[i]\n        if p <= sec && sec - p < size\n          p y\n          break\n        end\n      end\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "while n = gets.to_i\n  break if n == 0\n  arr = []\n  arr << [0, 1000000001, -1]\n  n.times do\n    l = gets.split\n    cmd = l.shift\n    case cmd\n    when \"W\"\n      x, s = l.map(&:to_i)\n      pos = 0\n      loop do\n        p, size, y = arr[pos]\n        if y == -1\n          arr[pos][2] = x\n          if size <= s\n            s -= size\n          else\n            arr[pos][1] = s\n            arr.insert(pos + 1, [p + s, size - s, -1])\n            break\n          end\n        end\n        pos += 1\n      end\n    when \"D\"\n      x = l[0].to_i\n      arr.size.times do |i|\n        arr[i][2] = -1 if arr[i][2] == x\n      end\n    when \"R\"\n      sec = l[0].to_i\n      arr.size.times do |i|\n        p, size, y = arr[i]\n        p y if p <= sec && sec - p < size\n      end\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "while n = gets.to_i\n  break if n == 0\n  arr = []\n  arr << [0, 1000000001, -1]\n  n.times do\n    l = gets.split\n    cmd = l.shift\n    case cmd\n    when \"W\"\n      x, s = l.map(&:to_i)\n      pos = 0\n      loop do\n        p, size, y = arr[pos]\n        if y == -1\n          arr[pos][2] = x\n          if size <= s\n            s -= size\n          else\n            arr[pos][1] = s\n            arr.insert(pos + 1, [p + s, size - s, -1])\n            break\n          end\n        end\n        pos += 1\n      end\n    when \"D\"\n      x = l[0].to_i\n      arr.size.times do |i|\n        arr[i][2] = -1 if arr[i][2] == x\n      end\n    when \"R\"\n      sec = l[0].to_i\n      arr.size.times do |i|\n        p, size, y = arr[i]\n        if p <= sec && sec - p < size\n          p y\n          break\n        end\n      end\n    end\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\t\n\tsegments = { -1 => [[0, Float::INFINITY]] }\t\n\n\tn.times do\n\t\tcommand, i, s = gets.chomp.split\n\t\ti = i.to_i\n\n\t\tif command == \"W\"\n\t\t\ts = s.to_i\n\t\t\tnext if s <= 0\n\t\t\t\n\t\t\tseg = []\n\t\t\tloop do\n\t\t\t\temp = segments[-1].shift\n\t\t\t\tstart, len = emp\n\t\t\t\tif s < len\n\t\t\t\t\temp[0] += s\n\t\t\t\t\temp[1] -= s\n\t\t\t\t\tseg << [start, s]\n\t\t\t\t\tsegments[-1].unshift emp\n\t\t\t\t\tbreak\n\t\t\t\telse \n\t\t\t\t\ts -= len\n\t\t\t\t\tseg << emp\n\t\t\t\tend\n\t\t\tend\n\t\t\tsegments[i] = seg\n\n\t\telsif command == \"D\"\n\t\t\tmerged = []\n\t\t\te_segs = segments[-1]\n\t\t\td_segs = segments[i]\n\n\t\t\tloop do\n\t\t\t\tif e_segs.empty? || d_segs.empty?\n\t\t\t\t\tmerged += d_segs + e_segs\n\t\t\t\t\tbreak\n\t\t\t\tend\n\n\t\t\t\ttarget = nil\n\t\t\t\tif e_segs[0][0] < d_segs[0][0]\n\t\t\t\t\ttarget = e_segs.shift\t\n\t\t\t\telse\n\t\t\t\t\ttarget = d_segs.shift\t\n\t\t\t\tend\n\n\t\t\t\tif !merged.empty? && merged[-1][0] + merged[-1][1] == target[0]\n\t\t\t\t\tmerged[-1][1] += target[1]\n\t\t\t\telse\n\t\t\t\t\tmerged << target\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tsegments[-1] = merged\n\t\t\tsegments.delete(i)\n\n\t\telse\n\t\t\tsegments.each do |k, arr|\n\t\t\t\tif arr.bsearch_first_index {|start, len| start <= i && i < start + len}\n\t\t\t\t\tputs k\n\t\t\t\t\tbreak\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\tputs\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\nimport std.random;\n\nclass S {\n    int from, to;\n    int id;\n    int size() { return to - from; }\n    this(int from, int to, int id) {\n        this.from = from;\n        this.to = to;\n        this.id = id;\n    }\n    override string toString() const {\n        return format(\"S(%s,%s,%s)\", from, to, id);\n    }\n}\n\nconst M = cast(int)1e9 + 1;\n\nvoid main() {\n    int N;\n    while (scanf(\"%d\\n\", &N), N > 0) {\n        //stderr.writeln(t);\n        int id, size;\n        auto buf = new char[16];\n        auto init = new S(0, M, -1);\n        auto D = [init];\n        BinaryHeap!(Array!S, \"a.from > b.from\") PQ;\n        PQ.insert(init);\n        foreach (i; 0 .. N) {\n            scanf(\"%s %d\", buf.ptr, &id);\n            switch (buf[0]) {\n                case 'W': \n                    scanf(\"%d\", &size);\n                    while (size > 0) {\n                        auto s = PQ.front; PQ.removeFront;\n                        if (s.size > size) {\n                            s.from += size;\n                            D ~= new S(s.from - size, s.from, id);\n                            PQ.insert(s);\n                            size = 0;\n                        } else {\n                            s.id = id;\n                            size -= s.size;\n                        }\n                    }\n                    break;\n                case 'R':\n                    foreach (ref d; D) {\n                        if (d.from <= id && id < d.to) {\n                            writeln(d.id);\n                            break;\n                        }\n                    }\n                    break;\n                case 'D':\n                    foreach (d; D) {\n                        if (d.id == id) {\n                            d.id = -1;\n                            PQ.insert(d);\n                        }\n                    }\n                    break;\n                default: assert(0);\n            }\n            //writeln(D);\n        }\n        writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\nimport std.random;\n\nstruct S {\n    int from, to;\n    int id;\n    int size() { return to - from; }\n}\n\nconst M = cast(int)1e9 + 1;\n\nvoid main() {\n    int N;\n    while (scanf(\"%d\\n\", &N), N > 0) {\n        int id, size;\n        auto buf = new char[16];\n        S[] D = [ S(0, M, -1) ];\n        foreach (i; 0 .. N) {\n            scanf(\"%s %d\", buf.ptr, &id);\n            switch (buf[0]) {\n                case 'W': \n                    scanf(\"%d\", &size);\n                    while (size > 0) {\n                        auto index = countUntil!\"a.id == -1\"(D);\n                        S* p = &D[index];\n                        if (p.size > size) {\n                            p.from += size;\n                            D.insertInPlace(index, S(p.from - size, p.from, id));\n                            size = 0;\n                        } else {\n                            p.id = id;\n                            size -= p.size;\n                        }\n                    }\n                    break;\n                case 'R':\n                    foreach (ref d; D) {\n                        if (d.from <= id && id < d.to) {\n                            writeln(d.id);\n                            break;\n                        }\n                    }\n                    break;\n                case 'D':\n                    foreach (ref d; D) {\n                        if (d.id == id) d.id = -1;\n                    }\n                    break;\n                default: assert(0);\n            }\n            //writeln(D);\n        }\n        writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        ss = [[int(c) if i > 0 else c for c,i in zip(LS(),range(3))] for _ in range(n)]\n        r = []\n        a = [(0, -1)]\n        ds = set()\n        for s in ss:\n            if s[0] == 'R':\n                bi = bisect.bisect_left(a, (s[1], inf))\n                t = a[bi-1][1]\n                if t in ds:\n                    t = -1\n                r.append(t)\n            elif s[0] == 'W':\n                i = s[1]\n                c = s[2]\n                ai = 0\n                al = len(a)\n                while c > 0:\n                    if a[ai][1] >= 0 and a[ai][1] not in ds:\n                        ai += 1\n                        continue\n                    if ai == al - 1:\n                        a[-1:] = [(a[ai][0], i), (a[ai][0]+c, -1)]\n                        break\n                    aic = a[ai+1][0] - a[ai][0]\n                    if aic <= c:\n                        a[ai] = (a[ai][0], i)\n                        c -= aic\n                    else:\n                        a[ai:ai+1] = [(a[ai][0], i), (a[ai][0]+c, -1)]\n                        break\n            else: # 'D'\n                ds.add(s[1])\n        return r\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        rr.extend(f(n))\n        # print(rr[-1])\n        rr.append('')\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "while(True):\n    N = int(input())\n    if N == 0:\n        quit()\n    data = []\n    emp = [[0,2 * 10**9]]\n    for _____ in range(N):\n        tmp = input().split()\n        if tmp[0] == \"W\":\n            c,k = int(tmp[1]),int(tmp[2])\n            while(k):\n                if (emp[0][1]-emp[0][0]) > k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    emp[0] = [emp[0][0]+k,emp[0][1]]\n                    break\n                elif (emp[0][1]-emp[0][0]) == k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    del(emp[0])\n                    break\n                else:\n                    data.append([c,emp[0]])\n                    k -= (emp[0][1]-emp[0][0])\n                    del(emp[0])\n        elif tmp[0] == \"D\":\n            for i in range(len(data)):\n                emp += [i[1] for i in data if i[0] == int(tmp[1])]\n                data = [i for i in data if i[0] != int(tmp[1])]\n                emp.sort()\n        else:\n            ans = True\n            s = int(tmp[1])\n            for i in data:\n                if i[1][0]<=s<i[1][1]:\n                    print(i[0])\n                    ans = False\n                    break\n            if ans:\n                print(-1)\n    print()\n\n"
  },
  {
    "language": "Python",
    "code": "while(True):\n    N = int(input())\n    if N == 0:\n        quit()\n    data = []\n    emp = [[0,10**9]]\n    for _____ in range(N):\n        tmp = input().split()\n        if tmp[0] == \"W\":\n            c,k = int(tmp[1]),int(tmp[2])\n            while(k):\n                if (emp[0][1]-emp[0][0]) > k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    emp[0] = [emp[0][0]+k,emp[0][1]]\n                    print(emp)\n                    break\n                elif (emp[0][1]-emp[0][0]) == k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    del(emp[0])\n                    break\n                else:\n                    data.append([c,emp[0]])\n                    k -= (emp[0][1]-emp[0][0])\n                    del(emp[0])\n        elif tmp[0] == \"D\":\n            for i in range(len(data)):\n                ifdata = [i[1] for i in data if i[0] == int(tmp[1])]\n                data = [i for i in data if i[0] != int(tmp[1])]\n                emp += ifdata\n                emp.sort()\n        else:\n            ans = -1\n            s = int(tmp[1])\n            for i in data:\n                if i[1][0]<=s<i[1][1]:\n                    ans = i[0]\n            print(ans)\n    print()\n\n"
  },
  {
    "language": "Python",
    "code": "#教室内の位置は右*中央\n#問題は「Restrictive Filesystem」(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152)\n#ところでコメントを今までより詳しく書くことにしました(説明が簡単なので)\n\nwhile(True):\n    #とりあえず複数のデータセットに対して行えるようにします\n    N = int(input())\n    #終了判定\n    if N == 0:\n        quit()\n\n    #方針として、ヒントにもあるように[識別子,[セクタ範囲]]というデータ構造を作ります(以下の「data」)\n    #工夫として、例えばセクタ3、4、5に同じ数字が入っている時、セクタ範囲を[3,6]とします\n    #これによって、その範囲に同じ数字がいくつ入っているかをカウントするのが容易になります\n    #また、これとは別に、Nullになっているセクタの範囲を記したデータ構造を作ります(以下の「emp」)\n    #empに空のセクタを集めておくことで、どのセクタにどの識別子を入れているかの判別が簡単になり、\n    #なおかつdeleteした時の空セクタを簡単に取り扱うことができます\n    #commandはせいぜい10000個なのでセクタ範囲の分割もせいぜい10000個であり、これで間に合うことがわかります(最大でソートのO(NlogN))\n    #以下実装\n\n    data = []\n    emp = [[0,1+10**9]] #empは最初セクタ0~セクタ10**9。\n    for _____ in range(N): #N回の命令。\n        tmp = input().split()\n        if tmp[0] == \"W\":#書き込みの時\n            c,k = int(tmp[1]),int(tmp[2]) #cが識別子、kが個数\n            while(k): #empのうち、セクタ範囲が小さい順から順番に入れていけばいいことがわかります\n                      #この操作のために、empが増えた時にはsortし、常にセクタ範囲が小さい順になるようにします\n                      #入りきらなかった場合は、とりあえずその分を入れて残りを入れればいいので、whileループを回します\n                if (emp[0][1]-emp[0][0]) > k: #最初の空な範囲のなかに識別子が全て入ってしまうとき。\n                    data.append([c,[emp[0][0],emp[0][0]+k]]) #dataに書き込んだ分を追加\n                    emp[0] = [emp[0][0]+k,emp[0][1]] #代わりにempの最初のセクタ範囲が入れた分だけ減ります\n                    break\n                else:\n                    data.append([c,emp[0]])\n                    k -= (emp[0][1]-emp[0][0])\n                    del(emp[0])\n        elif tmp[0] == \"D\": #消すとき\n            emp += [i[1] for i in data if i[0] == int(tmp[1])] #消したい識別子と一致するような範囲を全てempに足します\n            data = [i for i in data if i[0] != int(tmp[1])] #dataは消したい識別子以外の識別子の範囲だけになります\n            emp.sort() #empの範囲が小さい順になるようにsort。ちなみに理屈から分かる通り範囲がかぶることはないので安心です\n        else: #読み込みの時\n            ans = True\n            s = int(tmp[1]) #sは読み込みたいセクタ範囲\n            for i in data:\n                if i[1][0]<=s<i[1][1]: #sが空でないdataのセクタとして書いてあればその識別子を書いておしまいです\n                    print(i[0])\n                    ans = False\n                    break\n            if ans: #どこにも書いてなければ-1を書いて終わり。\n                print(-1)\n    print() #データセットごとに改行。\n\n"
  },
  {
    "language": "Python",
    "code": "#教室内の位置は右*中央\n#問題は「Restrictive Filesystem」(http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2152)\n#ところでコメントを今までより詳しく書くことにしました(説明が簡単なので)\n\nwhile(True):\n    #とりあえず複数のデータセットに対して行えるようにします\n    N = int(input())\n    #終了判定\n    if N == 0:\n        quit()\n\n    #方針として、ヒントにもあるように[識別子,[セクタ範囲]]というデータ構造を作ります(以下の「data」)\n    #工夫として、例えばセクタ3、4、5に同じ数字が入っている時、セクタ範囲を[3,6]とします\n    #これによって、その範囲に同じ数字がいくつ入っているかをカウントするのが容易になります\n    #また、これとは別に、Nullになっているセクタの範囲を記したデータ構造を作ります(以下の「emp」)\n    #empに空のセクタを集めておくことで、どのセクタにどの識別子を入れているかの判別が簡単になり、\n    #なおかつdeleteした時の空セクタを簡単に取り扱うことができます\n    #commandはせいぜい10000個なのでセクタ範囲の分割もせいぜい10000個であり、これで間に合うことがわかります(最大でソートのO(NlogN))\n    #以下実装\n\n    data = []\n    emp = [[0,1+10**9]] #empは最初セクタ0~セクタ10**9。\n    for _____ in range(N): #N回の命令。\n        tmp = input().split()\n        if tmp[0] == \"W\":#書き込みの時\n            c,k = int(tmp[1]),int(tmp[2]) #cが識別子、kが個数\n            while(k): #empのうち、セクタ範囲が小さい順から順番に入れていけばいいことがわかります\n                      #この操作のために、empが増えた時にはsortし、常にセクタ範囲が小さい順になるようにします\n                      #入りきらなかった場合は、とりあえずその分を入れて残りを入れればいいので、whileループを回します\n                if (emp[0][1]-emp[0][0]) > k: #最初の空な範囲のなかに識別子が全て入ってしまうとき。\n                    data.append([c,[emp[0][0],emp[0][0]+k]]) #dataに書き込んだ分を追加\n                    emp[0] = [emp[0][0]+k,emp[0][1]] #代わりにempの最初のセクタ範囲が入れた分だけ減ります\n                    break\n                else: #ぴったり入るか、入りきらない場合\n                    data.append([c,emp[0]]) #とりあえず最初のとこに入るだけ入れちゃいます\n                    k -= (emp[0][1]-emp[0][0]) #入れた分だけ残りの入れる分を消します\n                    del(emp[0]) #空な範囲の最初の部分が消える。\n        elif tmp[0] == \"D\": #消すとき\n            emp += [i[1] for i in data if i[0] == int(tmp[1])] #消したい識別子と一致するような範囲を全てempに足します\n            data = [i for i in data if i[0] != int(tmp[1])] #dataは消したい識別子以外の識別子の範囲だけになります\n            emp.sort() #empの範囲が小さい順になるようにsort。ちなみに理屈から分かる通り範囲がかぶることはないので安心です\n        else: #読み込みの時\n            ans = True\n            s = int(tmp[1]) #sは読み込みたいセクタ範囲\n            for i in data:\n                if i[1][0]<=s<i[1][1]: #sが空でないdataのセクタとして書いてあればその識別子を書いておしまいです\n                    print(i[0])\n                    ans = False\n                    break\n            if ans: #どこにも書いてなければ-1を書いて終わり。\n                print(-1)\n    print() #データセットごとに改行。\n\n"
  },
  {
    "language": "Python",
    "code": "while(True):\n    N = int(input())\n    if N == 0:\n        quit()\n    data = []\n    emp = [[0,10**9]]\n    for _____ in range(N):\n        tmp = input().split()\n        if tmp[0] == \"W\":\n            c,k = int(tmp[1]),int(tmp[2])\n            while(k):\n                if (emp[0][1]-emp[0][0]) > k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    emp[0] = [emp[0][0]+k,emp[0][1]]\n                    break\n                elif (emp[0][1]-emp[0][0]) == k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    del(emp[0])\n                    break\n                else:\n                    data.append([c,emp[0]])\n                    k -= (emp[0][1]-emp[0][0])\n                    del(emp[0])\n        elif tmp[0] == \"D\":\n            emp += [i[1] for i in data if i[0] == int(tmp[1])]\n            data = [i for i in data if i[0] != int(tmp[1])]\n            emp.sort()\n        else:\n            ans = True\n            s = int(tmp[1])\n            for i in data:\n                if i[1][0]<=s<i[1][1]:\n                    print(i[0])\n                    ans = False\n                    break\n            if ans:\n                print(-1)\n    print()\n\n"
  },
  {
    "language": "Python",
    "code": "query = int(input())\nwhile query != 0:\n    data = {}\n    for q in range(query):\n        temp = input().split(' ')\n        if temp[0] == 'W':\n            write,index = 0,0\n            while write < int(temp[2]):\n                if data.get(int(index),None) == None:\n                    data[index] = temp[1]\n                    write += 1\n                    index += 1\n                else:\n                    index += 1\n        elif temp[0] == 'D':\n            for k,v in data.items():\n                if v == temp[1]:\n                    data[k] = None\n        else:\n            print(data.get(int(temp[1])-1,-1))\n    else:\n        print('')\n        query = int(input())"
  },
  {
    "language": "Python",
    "code": "while(True):\n    N = int(input())\n    if N == 0:\n        quit()\n    data = []\n    emp = [[0,10**9]]\n    for _____ in range(N):\n        tmp = input().split()\n        if tmp[0] == \"W\":\n            c,k = int(tmp[1]),int(tmp[2])\n            while(k):\n                if (emp[0][1]-emp[0][0]) > k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    emp[0] = [emp[0][0]+k,emp[0][1]]\n                    break\n                elif (emp[0][1]-emp[0][0]) == k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    del(emp[0])\n                    break\n                else:\n                    data.append([c,emp[0]])\n                    k -= (emp[0][1]-emp[0][0])\n                    del(emp[0])\n        elif tmp[0] == \"D\":\n            for i in range(len(data)):\n                ifdata = [i[1] for i in data if i[0] == int(tmp[1])]\n                data = [i for i in data if i[0] != int(tmp[1])]\n                emp += ifdata\n                emp.sort()\n        else:\n            ans = -1\n            s = int(tmp[1])\n            for i in data:\n                if i[1][0]<=s<i[1][1]:\n                    ans = i[0]\n            print(ans)\n    print()\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom bisect import bisect_right\nwhile True:\n    N = int(input())\n    if N==0:\n        break\n    mem = []  # (l, r, id)\n    for _ in range(N):\n        command = input().split()\n        if command[0]==\"W\":\n            Id, S = map(int, command[1:])\n            subS = S\n            idx_mem = 0\n            idx = 0\n            while idx_mem < len(mem):\n                l, r, _ = mem[idx_mem]\n                if idx != l:\n                    space = l - idx\n                    assert space > 0, (mem, l, idx)\n                    if subS <= space:\n                        mem.insert(idx_mem, [idx, idx+subS, Id])\n                        subS = 0\n                        break\n                    else:\n                        mem.insert(idx_mem, [idx, idx+space, Id])\n                        subS -= space\n                        idx_mem += 1\n                idx = r\n                idx_mem += 1\n            else:\n                mem.append([idx, idx+subS, Id])\n\n        elif command[0]==\"D\":\n            Id = int(command[1])\n            for idx_mem in range(len(mem)-1, -1, -1):\n                if mem[idx_mem][2] == Id:\n                    del mem[idx_mem]\n        else:\n            P = int(command[1])\n            idx_mem = bisect_right(mem, [P, 100000000000000, -1]) - 1\n            #print(mem, idx_mem)\n            if idx_mem==-1:\n                print(-1)\n            else:\n                l, r, id_ = mem[idx_mem]\n                if P < r:\n                    print(id_)\n                else:\n                    print(-1)\n    print()\n\n"
  },
  {
    "language": "Python",
    "code": "while(True):\n    N = int(input())\n    if N == 0:\n        quit()\n    data = []\n    emp = [[0,2 * 10**9]]\n    for _____ in range(N):\n        tmp = input().split()\n        if tmp[0] == \"W\":\n            c,k = int(tmp[1]),int(tmp[2])\n            while(k):\n                if (emp[0][1]-emp[0][0]) > k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    emp[0] = [emp[0][0]+k,emp[0][1]]\n                    break\n                elif (emp[0][1]-emp[0][0]) == k:\n                    data.append([c,[emp[0][0],emp[0][0]+k]])\n                    del(emp[0])\n                    break\n                else:\n                    data.append([c,emp[0]])\n                    k -= (emp[0][1]-emp[0][0])\n                    del(emp[0])\n        elif tmp[0] == \"D\":\n            for i in range(len(data)):\n                emp += [i[1] for i in data if i[0] == int(tmp[1])]\n                data = [i for i in data if i[0] != int(tmp[1])]\n                emp.sort()\n        else:\n            ans = True\n            s = int(tmp[1])\n            for i in data:\n                if i[1][0]<=s<i[1][1]:\n                    print(i[0])\n                    ans = False\n                    break\n            if ans:\n                print(-1)\n    print()\n\n"
  }
]