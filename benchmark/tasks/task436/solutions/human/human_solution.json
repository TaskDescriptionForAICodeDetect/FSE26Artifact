[
  {
    "language": "C++",
    "code": "/*\n * 2435.cc: Zero Division Checker\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<bitset>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_M = 100;\nconst int BN = 256;\n\n/* typedef */\n\ntypedef bitset<BN> bb;\ntypedef map<string,int> msi;\n\n/* global variables */\n\nbb vrs[MAX_M];\nmsi vmap;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m;\n  cin >> m;\n\n  for (int i = 0; i < m; i++) {\n    string name;\n    int lb, ub;\n    cin >> name >> lb >> ub;\n\n    vrs[i].reset();\n    for (int j = lb; j <=ub; j++) vrs[i].set(j);\n    vmap[name] = i;\n  }\n\n  int n;\n  cin >> n;\n\n  stack<bb> st;\n  bool ok = true;\n\n  for (int i = 0; i < n; i++) {\n    string e;\n    cin >> e;\n\n    msi::iterator mit = vmap.find(e);\n    if (mit != vmap.end())\n      st.push(vrs[mit->second]);\n    else if (e[0] < '0' || e[0] > '9') {\n      bb b = st.top(); st.pop();\n      bb a = st.top(); st.pop();\n      bb r(0);\n      \n      for (int bi = 0; bi < BN; bi++) {\n\tif (! b.test(bi)) continue;\n\n\tif (bi == 0 && e[0] == '/') {\n\t  ok = false;\n\t  break;\n\t}\n\n\tfor (int ai = 0; ai < BN; ai++) {\n\t  if (! a.test(ai)) continue;\n\n\t  int ri;\n\t  if (e[0] == '+') ri = (ai + bi) % BN;\n\t  else if (e[0] == '-') ri = (ai + BN - bi) % BN;\n\t  else if (e[0] == '*') ri = (ai * bi) % BN;\n\t  else ri = (ai / bi) % BN;\n\n\t  r.set(ri);\n\t}\n      }\n      if (! ok) break;\n\n      st.push(r);\n    }\n    else {\n      int k = atoi(e.c_str());\n      bb r(0);\n      r.set(k);\n      st.push(r);\n    }\n  }\n\n  cout << (ok ? \"correct\" : \"error\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned char uchar;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int M; cin >> M;\n  map<string, pair<uchar,uchar>> var;\n  REP(i,M){\n\tstring s; int lb, ub;\n\tcin >> s >> lb >> ub;\n\tvar[s] = MP(lb,ub);\n  }\n\n  int N; cin >> N;\n  bool ans = true;\n  stack<vector<bool>> s;\n  while(N-- && ans){\n\tif(!s.empty()){/*\n\t  auto tmp = s.top();\n\t  cout << \"top: \";\n\t  REP(i,256) if(tmp[i]) cout << i << \" \";\n\t  cout << endl;*/\n\t}\n\t\n\tstring term; cin >> term;\n\t//cout<<term <<endl;\n\tif('0' <= term[0] && term[0] <= '9'){\n\t  uchar x = atoi(term.c_str());\n\t  vector<bool> r(256,false);\n\t  r[x] = true;\n\t  s.push(r);\n\t}\n\telse if(term == \"+\"){\n\t  auto b = s.top(); s.pop();\n\t  auto a = s.top(); s.pop();\n\t  vector<bool> r(256, false);\n\t  for(uchar a_=0;;++a_){\n\t\tif(a[a_])\n\t\t  for(uchar b_=0;;++b_){\n\t\t\tuchar x = a_+b_;\n\t\t\tif(b[b_]) r[x] = true;\n\t\t\tif(b_ == 255) break;\n\t\t  }\n\t\tif(a_ == 255) break;\n\t  }\n\t  s.push(r);\n\t}\n\telse if(term == \"-\"){\n\t  auto b = s.top(); s.pop();\n\t  auto a = s.top(); s.pop();\n\t  vector<bool> r(256, false);\n\t  for(uchar a_=0;;++a_){\n\t\tif(a[a_])\n\t\t  for(uchar b_=0;;++b_){\n\t\t\tuchar x = a_ - b_;\n\t\t\tif(b[b_]) r[x] = true;\n\t\t\tif(b_ == 255) break;\n\t\t  }\n\t\tif(a_ == 255) break;\n\t  }\n\t  s.push(r);\n\t}\n\telse if(term == \"*\"){\n\t  auto b = s.top(); s.pop();\n\t  auto a = s.top(); s.pop();\n\t  vector<bool> r(256, false);\n\t  for(uchar a_=0;;++a_){\n\t\tif(a[a_])\n\t\t  for(uchar b_=0;;++b_){\n\t\t\tuchar x = a_*b_;\n\t\t\tif(b[b_]) r[x] = true;\n\t\t\tif(b_ == 255) break;\n\t\t  }\n\t\tif(a_ == 255) break;\n\t  }\n\t  s.push(r);\n\t}\n\telse if(term == \"/\"){\n\t  auto b = s.top(); s.pop();\n\t  auto a = s.top(); s.pop();\n\t  if(b[0]){\n\t\tans = false;\n\t\tbreak;\n\t  }\n\n\t  vector<bool> r(256, false);\n\t  for(uchar a_=0;;++a_){\n\t\tif(a[a_])\n\t\t  for(uchar b_=1;;++b_){\n\t\t\tuchar x = a_/b_;\n\t\t\tif(b[b_]) r[x] = true;\n\t\t\tif(b_ == 255) break;\n\t\t  }\n\t\tif(a_ == 255) break;\n\t  }\n\t  s.push(r);\n\t}\n\telse{\n\t  auto p = var[term];\n\t  vector<bool> r(256,false);\n\t  for(uchar i=p.first;i<p.second;++i)\n\t\tr[i] = true;\n\t  r[p.second] = true;\n\t  s.push(r);\n\t}\n  }\n\n  cout << (ans? \"correct\": \"error\") << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  \n\t\t  C.insert(((*it_a)/(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nint n,m;\nmain(){\n\tint i,j,k;\n\tstring s;\n\tmap<string, bitset<256> > var;\n\tcin >> m;\n\tfor(i=0;i<m;i++){\n\t\tstring c;\n\t\tint lb, ub;\n\t\tcin >> s >> lb >> ub;\n\t\tvar[s] = 0;\n\t\tfor(j=lb;j<=ub;j++) var[s][j] = 1;\n\t}\n\tstack<bitset<256> > st;\n\tfor(cin>>n;n--;){\n\t\tcin >> s;\n\t\tif(isdigit(s[0])){\n\t\t\tbitset<256> ret(0);\n\t\t\tret[atoi(s.c_str())] = 1;\n\t\t\tst.push(ret);\n\t\t}else if(s[0] == '+' || s[0] == '-' || s[0] == '*' || s[0] == '/'){\n\t\t\tbitset<256> b=st.top();st.pop();\n\t\t\tbitset<256> a=st.top();st.pop();\n\t\t\tbitset<256> ans(0);\n\t\t\tfor(i=0;i<256;i++){\n\t\t\t\tif(!a[i]) continue;\n\t\t\t\tfor(j=0;j<256;j++){\n\t\t\t\t\tif(!b[j]) continue;\n\t\t\t\t\tif(s[0] == '+') ans[(i+j)%256] = 1;\n\t\t\t\t\tif(s[0] == '-') ans[(i-j+256)%256] = 1;\n\t\t\t\t\tif(s[0] == '*') ans[(i*j)%256] = 1;\n\t\t\t\t\tif(s[0] == '/'){\n\t\t\t\t\t\tif(!j){\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans[(i/j)%256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ans);\n\t\t}else{\n\t\t\tst.push(var[s]);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n\nint main() {\n\tint m;\n\tcin >> m;\n\tvector<string> c(m);\n\tvector<int> l(m), r(m);\n\tmap<string, int> p;\n\tp[\"+\"] = -1;\n\tp[\"-\"] = -1;\n\tp[\"*\"] = -1;\n\tp[\"/\"] = -1;\n\trep(i, m) {\n\t\tcin >> c[i] >> l[i] >> r[i];\n\t\tp[c[i]] = i;\n\t}\n\tvector<vector<int>> d(m);\n\trep(i, m) {\n\t\tfor (int j = l[i]; j <= r[i]; j++) {\n\t\t\td[i].push_back(j);\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tvector<int> v;\n\tstack<vector<int>> s;\n\trep(k, n) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tif (p.count(t)) {\n\t\t\tif (p[t] == -1) {\n\t\t\t\tauto b = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tauto a = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tset<int> se;\n\t\t\t\teach(i, b)each(j, a) {\n\t\t\t\t\tif (t == \"+\") {\n\t\t\t\t\t\tse.insert((j + i) % 256);\n\t\t\t\t\t}\n\t\t\t\t\tif (t == \"-\") {\n\t\t\t\t\t\tse.insert((j - i + 256) % 256);\n\t\t\t\t\t}\n\t\t\t\t\tif (t == \"*\") {\n\t\t\t\t\t\tse.insert((j * i) % 256);\n\t\t\t\t\t}\n\t\t\t\t\tif (t == \"/\") {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tse.insert((j / i) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<int> v;\n\t\t\t\teach(i, se) {\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t}\n\t\t\t\ts.push(v);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.push(d[p[t]]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ts.push(vector<int>(1, atoi(t.c_str())));\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl;\n#define CNO cout<<\"No\"<<endl;\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n;\n  cin >> n;\n  map<string,pair<int,int>> mp;\n  rep(i,n){\n    string s;\n    int l,r;\n    cin >> s >> l >> r;\n    mp[s]={l,r};\n  }\n  cin >> n;\n  stack<bitset<256>> st;\n  bitset<256> a,b;\n  rep(i,n){\n    string s;\n    cin >> s;\n    if(mp.find(s)==mp.end()){\n      if(s==\"+\"){\n        b=st.top();st.pop();a=st.top();st.pop();\n        bitset<256> bit;\n        rep(i,256){\n          if(!a.test(i)) continue;\n          rep(j,256){\n            if(!b.test(j)) continue;\n            bit.set((i+j)%256);\n          }\n        }\n        st.push(bit);\n      }else if(s==\"-\"){\n        b=st.top();st.pop();a=st.top();st.pop();\n        bitset<256> bit;\n        rep(i,256){\n          if(!a.test(i)) continue;\n          rep(j,256){\n            if(!b.test(j)) continue;\n            bit.set((i-j+256)%256);\n          }\n        }\n        st.push(bit);\n      }else if(s==\"*\"){\n        b=st.top();st.pop();a=st.top();st.pop();\n        bitset<256> bit;\n        rep(i,256){\n          if(!a.test(i)) continue;\n          rep(j,256){\n            if(!b.test(j)) continue;\n            bit.set((i*j)%256);\n          }\n        }\n        st.push(bit);\n      }else if(s==\"/\"){\n        b=st.top();st.pop();a=st.top();st.pop();\n        if(b.test(0)){\n          cout << \"error\" << endl;\n          return 0;\n        }\n        bitset<256> bit;\n        rep(i,256){\n          if(!a.test(i)) continue;\n          rep(j,256){\n            if(!b.test(j)) continue;\n            bit.set((i/j)%256);\n          }\n        }\n        st.push(bit);\n      }else{\n        int num=stoi(s);\n        bitset<256> bit;\n        bit.set(num);\n        st.push(bit);\n      }\n    }else{\n      auto p = mp[s];\n      bitset<256> bit;\n      repp(i,p.first,p.second+1) bit.set(i);\n      st.push(bit);\n    }\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    using p = array<bool, 255>;\n    stack<p> s;\n    map<string, p> v;\n    int m;\n    cin >> m;\n    for (int i = 0; i < m; ++i) {\n        string x; int a, b;\n        cin >> x >> a >> b;\n        p k{};\n        for (int j = a; j <= b; ++j) {\n            k[j] = true;\n        }\n        v[x] = k;\n    }\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        string t;\n        cin >> t;\n        if(v.count(t)){\n            s.emplace(v[t]);\n        }else if(t.size() == 1 && (t[0] < '0' || t[0] > '9')){\n            p b = s.top(); s.pop(); p a = s.top(); s.pop();\n            p c{};\n            if(t[0] == '+'){\n                for (int j = 0; j < 256; ++j) {\n                    if(!a[j]) continue;\n                    for (int k = 0; k < 256; ++k) {\n                        if(!b[k]) continue;\n                        c[(j+k)%256] = true;\n                    }\n                }\n            }else if(t[0] == '-'){\n                for (int j = 0; j < 256; ++j) {\n                    if(!a[j]) continue;\n                    for (int k = 0; k < 256; ++k) {\n                        if(!b[k]) continue;\n                        c[(j+256-k)%256] = true;\n                    }\n                }\n            }else if(t[0] == '*'){\n                for (int j = 0; j < 256; ++j) {\n                    if(!a[j]) continue;\n                    for (int k = 0; k < 256; ++k) {\n                        if(!b[k]) continue;\n                        c[(j*k)%256] = true;\n                    }\n                }\n            }else {\n                for (int j = 0; j < 256; ++j) {\n                    if(!a[j]) continue;\n                    for (int k = 0; k < 256; ++k) {\n                        if(!b[k]) continue;\n                        if(k == 0) {\n                            puts(\"error\");\n                            return 0;\n                        }\n                        c[(j/k)%256] = true;\n                    }\n                }\n            }\n            s.emplace(c);\n        }else {\n            int k = stoi(t);\n            p x{};\n            x[k] = true;\n            s.emplace(x);\n        }\n    }\n    puts(\"correct\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define MOD 256\n\ndeque<string> q;\nunordered_map<string, S> mp;\nint nameLength = 21;\n\nbool isDigit(string s) {\n    return '0' <= s[0] && s[0] <= '9';\n}\n\nbool calc(int op) {\n    string a, b;\n    b = q.back(), q.pop_back();\n    a = q.back(), q.pop_back();\n    bool aa = isDigit(a), bb = isDigit(b);\n    if (aa && bb) {\n        if (op == 0) q.push_back(to_string((stoi(a) + stoi(b)) % MOD));\n        else if (op == 1) q.push_back(to_string((stoi(a) - stoi(b) + MOD) % MOD));\n        else if (op == 2) q.push_back(to_string((stoi(a) * stoi(b)) % MOD));\n        else {\n            if (stoi(b) != 0) q.push_back(to_string((stoi(a) / stoi(b)) % MOD));\n            else return false;\n        }\n    } else if (!aa && !bb) {\n        S c;\n        if (op == 0) each(i, mp[a])each(j, mp[b]) c.insert((i + j) % MOD);\n        else if (op == 1) each(i, mp[a])each(j, mp[b]) c.insert((i - j + MOD) % MOD);\n        else if (op == 2) each(i, mp[a])each(j, mp[b]) c.insert((i * j) % MOD);\n        else  each(i, mp[a])each(j, mp[b]) {\n            if (j != 0) c.insert((i / j) % MOD);\n            else return false;\n        }\n        string newStr(nameLength++, 'a');\n        q.push_back(newStr);\n        mp[newStr] = c;\n    } else if (!aa) {\n        S c;\n        int d = stoi(b);\n        if (op == 0) each(i, mp[a]) c.insert((i + d) % MOD);\n        else if (op == 1) each(i, mp[a]) c.insert((i - d + MOD) % MOD);\n        else if (op == 2) each(i, mp[a]) c.insert((i * d) % MOD);\n        else each(i, mp[a]) {\n            if (d != 0) c.insert((i / d) % MOD);\n            else return false;\n        }\n        string newStr(nameLength++, 'a');\n        q.push_back(newStr);\n        mp[newStr] = c;\n    } else {\n        S c;\n        int d = stoi(a);\n        if (op == 0) each(i, mp[b]) c.insert((d + i) % MOD);\n        else if (op == 1) each(i, mp[b]) c.insert((d - i + MOD) % MOD);\n        else if (op == 2) each(i, mp[b]) c.insert((d * i) % MOD);\n        else each(i, mp[b]) {\n            if (i != 0) c.insert((d / i) % MOD);\n            else return false;\n        }\n        string newStr(nameLength++, 'a');\n        q.push_back(newStr);\n        mp[newStr] = c;\n    }\n    return true;\n}\n\nbool decode(string s) {\n    bool ret = true;\n    if (s[0] == '+') {\n        ret = calc(0);\n    } else if (s[0] == '-') {\n        ret = calc(1);\n    } else if (s[0] == '*') {\n        ret = calc(2);\n    } else if (s[0] == '/') {\n        ret = calc(3);\n    } else {\n        q.push_back(s);\n    }\n    return ret;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n, m;\n    cin >> m;\n    rep(i, m) {\n        string s;\n        int l, u;\n        cin >> s >> l >> u;\n        S st;\n        repl(j, l, u + 1) st.insert(j);\n        mp[s] = st;\n    }\n\n    cin >> n;\n    bool ok = true;\n    rep(i, n) {\n        string s;\n        cin >> s;\n        ok = decode(s);\n        if (!ok) break;\n    }\n\n    if (ok) cout << \"correct\" << endl;\n    else cout << \"error\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<unsigned char, unsigned char> P;\ntypedef vector<unsigned char> nv;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nbool calc_form(string op,nv a,nv b,nv& res){\n  if(op==\"/\"){\n    rep(i,b.size()){\n      if(b[i]==0)return false;\n    }\n  }\n  rep(i,a.size())rep(j,b.size()){\n    unsigned char add;\n    if(op==\"+\"){\n      add=a[i]+b[j];\n    }else if(op==\"-\"){\n      add=a[i]-b[j];\n    }else if(op==\"*\"){\n      add=a[i]*b[j];\n    }else{\n      add=a[i]/b[j];\n    }\n    res.push_back(add);\n  }\n  sort(all(res));\n  uni(res);\n  return true;\n}\n\nint n,m;\nmap<string,P> h;\nstack<nv> st;\nvector<string> form;\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>m;\n  rep(i,m){\n    string name; int a,b;\n    cin>>name>>a>>b;\n    h[name]=P(a,b);\n  }\n  cin>>n;\n  rep(i,n){\n    string a;\n    cin>>a;\n    form.push_back(a);\n  }\n  rep(i,n){\n    string a=form[i];\n    if(a==\"+\"||a==\"-\"||a==\"*\"||a==\"/\"){\n      nv n2=st.top(); st.pop();\n      nv n1=st.top(); st.pop();\n      nv tmp;\n      if(!calc_form(a,n1,n2,tmp)){\n        cout<<\"error\"<<endl;\n        return 0;\n      }\n      st.push(tmp);\n    }else if(h.count(a)){\n      nv tmp;\n      repl(i,h[a].fi,h[a].se+1){\n        tmp.push_back(i);\n      }\n      st.push(tmp);\n    }else{\n      nv tmp;\n      tmp.push_back(stoi(a));\n      st.push(tmp);\n    }\n  }\n  cout<<\"correct\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nmap<string, set<int> > mp;\n\nint f(string s) {\n    //cerr << s << endl;\n    if(s.size() == 1) return s[0] - '0';\n    return 10 * f(s.substr(0, s.size() - 1)) + s.back() - '0';\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int m;\n    cin >> m;\n    while(m--) {\n        string s;\n        cin >> s;\n        int l, u;\n        cin >> l >> u;\n        for(int i = l; i <= u; i++) mp[s].insert(i);\n    }\n    string NEWVAL;\n    for(int i = 1; i <= 21; i++) NEWVAL.push_back('A');\n    int n;\n    cin >> n;\n    stack<string> sta;\n    while(n--) {\n        string s;\n        cin >> s;\n        NEWVAL[0]++;\n        if(s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\") {\n            string a = sta.top();\n            sta.pop();\n            string b = sta.top();\n            sta.pop();\n            for(auto itr = mp[a].begin(); itr != mp[a].end(); itr++) {\n                for(auto itr2 = mp[b].begin(); itr2 != mp[b].end(); itr2++) {\n                    if(s == \"/\" && *itr == 0) {\n                        cout << \"error\" << endl;\n                        return 0;\n                    }\n                    if(s == \"+\") mp[NEWVAL].insert((*itr2 + *itr) % 256);\n                    if(s == \"-\") mp[NEWVAL].insert((*itr2 - *itr + 256) % 256);\n                    if(s == \"*\") mp[NEWVAL].insert(*itr * *itr2 % 256);\n                    if(s == \"/\") mp[NEWVAL].insert(*itr2 / *itr % 256);\n                }\n            }\n            sta.push(NEWVAL);\n            continue;\n        }\n        if(!mp[s].empty()) {\n            sta.push(s);\n        } else {\n            /*\n            cerr << \"nmb: \" << s << endl;\n            cerr << f(s) << endl;\n            */\n            mp[NEWVAL].insert(f(s));\n            sta.push(NEWVAL);\n        }\n    }\n    cout << \"correct\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  time_t start=clock();\n  srand(unsigned(time));\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.7&&!f){\n    stack<uc> sc;\n    for(int i=0;!f&&i<n;i++){\n      //cout<<i<<\":\"<<ss[i]<<endl;\n      if(ms.find(ss[i])!=ms.end()){ \n\tint j=ms[ss[i]],k=(l[j]+(rand()%(r[j]-l[j])));\n\t//cout<<ss[i]<<\":\"<<k<<endl;\n\tsc.push(k);\n      }else if(isdigit(ss[i][0])){\n\tuc a=0;\n\tfor(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n\tsc.push(a);\n      }else{\n\tuc a,b;\n\tb=sc.top();sc.pop();\n\ta=sc.top();sc.pop();\n\tif(ss[i]==\"+\") sc.push(a+b);\n\tif(ss[i]==\"-\") sc.push(a-b);\n\tif(ss[i]==\"*\") sc.push(a*b);\n\tif(ss[i]==\"/\"){\n\t  if(b) sc.push(a/b);\n\t  else{\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nbool isDigits(char c) {return c>='0'&&c<='9';}\n\nbool isAllDigits(string s) {\n\tfor(auto& c : s) {\n\t\tif(!isDigits(c)) return false;\n\t}\n\treturn true;\n}\nll StoLL(const string& s) {\n\tll ret = 0LL;\n\tfor(auto& c : s) ret = ret*10 + (c-'0');\n\treturn ret;\n}\n\n//[l, r] wo merge\nset<pii> mergeSegment(const set<pii>& st) {\n\tset<pii> ret;\n\tif(st.size() == 0) return ret;\n\tauto p = *st.begin();\n\tauto it = st.begin();\n\tit++;\n\twhile(it != st.end()) {\n\t\tauto tmp = *it;\n\t\tif(p.se+1 >= tmp.fi) {\n\t\t\tp.fi = min(p.fi, tmp.fi);\n\t\t\tp.se = max(p.se, tmp.se);\n\t\t}\n\t\telse{\n\t\t\tret.insert(p);\n\t\t\tp = tmp;\n\t\t}\n\t\tit++;\n\t}\n\tret.insert(p);\n\treturn ret;\n}\nstack<set<pii>> st;\n\nvoid plus_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tpii p;\n\n\t\t\tp.fi = (a.fi + b.fi)%256;\n\t\t\tp.se = (a.se + b.se)%256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid minus_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi - b.se + 256) % 256;\n\t\t\tp.se = (a.se - b.fi + 256) % 256;\n\t\t\tif((a.fi - b.se < 0) ^ (a.se - b.fi < 0)) {\n\t\t\t\tret.insert({0, min(p.fi, p.se)});\n\t\t\t\tret.insert({max(p.fi, p.se), 255});\n\t\t\t}\n\t\t\telse if(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid mult_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\t// pii p;\n\t\t\t// p.fi = (a.fi * b.fi)%256;\n\t\t\t// p.se = (a.se * b.se)%256;\n\t\t\t// if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tret.insert({aa*bb%256,aa*bb%256});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nbool div_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tif(b.fi == 0) return false;\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi / b.se)%256;\n\t\t\tp.se = (a.se / b.fi)%256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n\treturn true;\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tmap<string, pii> mp;\n\trep(i, m) {\n\t\tstring s;\n\t\tint l, r;\n\t\tcin >> s >> l >> r;\n\t\tmp[s] = {l, r};\n\t}\n\tint n;\n\tcin >> n;\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(isAllDigits(s)) {\n\t\t\tint num = StoLL(s);\n\t\t\tdump(num);\n\t\t\tset<pii>tmp;\n\t\t\ttmp.insert({num, num});\n\t\t\tst.push(tmp);\n\t\t}\n\t\telse if(s == \"+\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tplus_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"-\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tminus_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"*\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tmult_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"/\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tif(!div_st_pii(a, b)) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse {\n\t\t\tset<pii> tmp;\n\t\t\ttmp.insert(mp[s]);\n\t\t\tst.push(tmp);\n\n\t\t\tdumpV(tmp);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\nusing namespace std;\n\ntypedef vector<bool> V;\ntypedef pair<int,int> P;\n\nint stoi(string x){\n  int r=0;\n  for(int i=0;i<x.size();i++){\n    r *= 10; r += x[i]-'0';\n  }\n  return r;\n}\n\ninline int cal(int a,int b,string op){\n  int res;\n  if(op == \"+\")res = a+b;\n  else if(op == \"-\")res = a-b;\n  else if(op == \"*\")res = a*b;\n  else res = a/b;\n  return (res + 256) % 256;\n}\n\nint main(){\n  string s,c[100];\n  int m,n,a,b;\n  map<string,P> h;\n  V t1(256),t2(256),t3(256);\n\n\n  cin >> m;\n  for(int i=0;i<m;i++){\n    cin >> s >> a >> b;\n    h[s] = P(a,b);\n  }\n\n  cin >> n;\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  stack<V> p;\n  for(int i=0;i<n;i++){\n    if(c[i] == \"+\" || c[i] == \"-\" || c[i] == \"*\" || c[i] == \"/\"){\n      t2 = p.top(); p.pop();\n      t1 = p.top(); p.pop();\n      fill(t3.begin(),t3.end(),false);\n      for(int j=0;j<256;j++)\n\tfor(int k=0;k<256;k++)\n\t  if(t1[j] && t2[k])\n\t    if(!k && c[i] == \"/\"){\n\t      cout << \"error\\n\";\n\t      return 0;\n\t    }else t3[cal(j,k,c[i])] = true;\n      p.push(t3);\n    }else if(h.find(c[i]) != h.end()){\n      fill(t3.begin(),t3.end(),false);\n      a = h[c[i]].first; b = h[c[i]].second;\n      for(int j=a;j<=b;j++)t3[j] = true;\n      p.push(t3);\n    }else{\n      fill(t3.begin(),t3.end(),false);\n      t3[stoi(c[i])] = true;\n      p.push(t3);\n    }\n  }\n  cout << \"correct\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2435&lang=jp\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint m; cin >> m;\n\tstring op = \"+-/*\";\n\tmap<string, int> name_idx;\n\tvector<pair<int, int>> name(m + 1);\n\tfor (int i = 1; i <= m; i++) {\n\t\tstring _name; int lb, ub;\n\t\tcin >> _name >> lb >> ub;\n\t\tname_idx[_name] = i;\n\t\tname[i].first = lb; name[i].second = ub;\n\t}\n\tint n; cin >> n;\n\tstack<int> st_idx;\n\tvector<vector<int>> st(n, vector<int>(256, 0));\n\tfor (int i = 0; i < n;i++) {\n\t\tstring e; cin >> e;\n\t\tcout << e << endl;\n\t\t/* +-/* or value */\n\t\tif (name_idx[e] == 0) {\n\t\t\tif (e == \"+\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a + b) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"-\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a - b + 256) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"*\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a*b) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"/\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tif (b == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tst[i][(a / b) % 256] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[i][atoi(e.c_str())] = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tauto pii = name[name_idx[e]];\n\t\t\tfor (int v = pii.first; v <= pii.second;v++) {\n\t\t\t\tst[i][v] = 1;\n\t\t\t}\n\t\t}\n\t\tst_idx.push(i);\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nbool isDigits(char c) {return c>='0'&&c<='9';}\n\nbool isAllDigits(string s) {\n\tfor(auto& c : s) {\n\t\tif(!isDigits(c)) return false;\n\t}\n\treturn true;\n}\nll StoLL(const string& s) {\n\tll ret = 0LL;\n\tfor(auto& c : s) ret = ret*10 + (c-'0');\n\treturn ret;\n}\n\n//[l, r] wo merge\nset<pii> mergeSegment(const set<pii>& st) {\n\tset<pii> ret;\n\tif(st.size() == 0) return ret;\n\tauto p = *st.begin();\n\tauto it = st.begin();\n\tit++;\n\twhile(it != st.end()) {\n\t\tauto tmp = *it;\n\t\tif(p.se >= tmp.fi) {\n\t\t\tp.fi = min(p.fi, tmp.fi);\n\t\t\tp.se = max(p.se, tmp.se);\n\t\t}\n\t\telse{\n\t\t\tret.insert(p);\n\t\t\tp = tmp;\n\t\t}\n\t\tit++;\n\t}\n\tret.insert(p);\n\treturn ret;\n}\nstack<set<pii>> st;\n\nvoid plus_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi + b.fi)%256;\n\t\t\tp.se = (a.se + b.se)%256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid minus_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi - b.se + 256) % 256;\n\t\t\tp.se = (a.se - b.fi + 256) % 256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid mult_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\t// pii p;\n\t\t\t// p.fi = (a.fi * b.fi)%256;\n\t\t\t// p.se = (a.se * b.se)%256;\n\t\t\t// if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tret.insert({aa*bb%256,aa*bb%256});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nbool div_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tif(b.fi == 0) return false;\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi / b.se)%256;\n\t\t\tp.se = (a.se / b.fi)%256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n\treturn true;\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tmap<string, pii> mp;\n\trep(i, m) {\n\t\tstring s;\n\t\tint l, r;\n\t\tcin >> s >> l >> r;\n\t\tmp[s] = {l, r};\n\t}\n\tint n;\n\tcin >> n;\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(isAllDigits(s)) {\n\t\t\tint num = StoLL(s);\n\t\t\tdump(num);\n\t\t\tset<pii>tmp;\n\t\t\ttmp.insert({num, num});\n\t\t\tst.push(tmp);\n\t\t}\n\t\telse if(s == \"+\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tplus_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"-\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tminus_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"*\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tmult_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"/\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tif(!div_st_pii(a, b)) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse {\n\t\t\tset<pii> tmp;\n\t\t\ttmp.insert(mp[s]);\n\t\t\tst.push(tmp);\n\n\t\t\tdumpV(tmp);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    int m; cin >> m;\n    using Data = bitset<256>;\n    map<string,Data> mp;\n    REP(i, m) {\n        string name; int lb, ub;\n        cin >> name >> lb >> ub;\n        FOR(k, lb, ub+1) {\n            mp[name].set(k);\n        }\n    }\n    int n; cin >> n;\n    vector<string> e(n);\n    REP(i, n) cin >> e[i];\n\n    stack<Data> stk;\n\n    auto check = [&]() {\n        REP(i, n) {\n            if ('0' <= e[i][0] and e[i][0] <= '9') {\n                Data num;\n                num.set(stoi(e[i]));\n                stk.push(num);\n            } else if (e[i] == \"+\") {\n                Data r = stk.top();\n                stk.pop();\n                Data l = stk.top();\n                stk.pop();\n                Data num;\n                REP(a, 256) {\n                    REP(b, 256) {\n                        if (l[a] and r[b]) {\n                            num.set((a + b) % 256);\n                        }\n                    }\n                }\n                stk.push(num);\n            } else if (e[i] == \"-\") {\n                Data r = stk.top();\n                stk.pop();\n                Data l = stk.top();\n                stk.pop();\n                Data num;\n                REP(a, 256) {\n                    REP(b, 256) {\n                        if (l[a] and r[b]) {\n                            num.set((a - b + 256) % 256);\n                        }\n                    }\n                }\n                stk.push(num);\n            } else if (e[i] == \"*\") {\n                Data r = stk.top();\n                stk.pop();\n                Data l = stk.top();\n                stk.pop();\n                Data num;\n                REP(a, 256) {\n                    REP(b, 256) {\n                        if (l[a] and r[b]) {\n                            num.set((a * b) % 256);\n                        }\n                    }\n                }\n                stk.push(num);\n            } else if (e[i] == \"/\") {\n                Data r = stk.top();\n                stk.pop();\n                Data l = stk.top();\n                stk.pop();\n                Data num;\n                REP(a, 256) {\n                    REP(b, 256) {\n                        if (l[a] and r[b]) {\n                            if (b == 0) {\n                                return false;\n                            }\n                            num.set((a / b) % 256);\n                        }\n                    }\n                }\n                stk.push(num);\n            }\n            else {\n                stk.push(mp[e[i]]);\n            }\n        }\n        return true;\n    };\n\n    bool ans = check();\n    cout << (ans ? \"correct\" : \"error\") << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbool calc(set<int>& B,set<int>& A,string& ope,stack<set<int> >& ele,map<string,set<int> >& index)\n{\n  set<int> C;\n  for(set<int>::iterator it_A = A.begin();it_A != A.end();it_A++)\n    {\n      for(set<int>::iterator it_B = B.begin();it_B != B.end();it_B++)\n\t{\n\t  if(ope == \"+\")\n\t    {\n\t      C.insert(((*it_A)+(*it_B))%256);\n\t    }\n\t  else if(ope == \"-\")\n\t    {\n\t      C.insert(((*it_A)-(*it_B)+256)%256);\n\t    }\n\t  else if(ope == \"*\")\n\t    {\n\t      C.insert(((*it_A)*(*it_B))%256);\n\t    }\n\t  else if(ope == \"/\")\n\t    {\n\t      if(!(*it_B))\n\t\t{\n\t\n\t\t  return false; \n\t\t}\n\t      C.insert(((*it_A)/(*it_B))%256);\n\t    }\n\t  else \n\t    assert(false);\n\t}\n    }\n  index[My] = C;\n  ele.push(C);\n  return true;\n}\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<set<int> > ele;\n  deque<string> st;\n  bool fin = false;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      //cout <<\"e = \" << e << endl;\n      if(fin)\n\tcontinue;\n      if(e != \"/\" && e != \"*\" && e != \"-\" && e != \"+\")\n\t{\n\t  if(index.find(e) != index.end())\n\t    {\n\t      ele.push(index[e]);\n\t    }\n\t  else\n\t    {\n\t      set<int> FAGS;\n\t      FAGS.insert((atoi)(e.c_str()));\n\t      ele.push(FAGS);\n\t    }\n\t}\n      else \n\t{\n\t  set<int> A,B;\n\t  if(ele.empty())\n\t    {\n\t      fin = true;\n\t      continue;\n\t    }\n\t  B = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      fin = true;\n\t      continue;\n\t    }\n\t  A = ele.top(),ele.pop();\n\t  if(!calc(B,A,e,ele,index))\n\t    fin = true;\t    \n\t}\n\n    }\n\n  if(fin)\n    {\n      cout << \"error\" << endl;\n      return 0;\n    }\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <complex>\n#define rep(i, b) for(int i = 0; i < (b); i++)\n#define repi(i, a, b) for(int i = (a); i < (b); i++)\n#define repd(i, a, b) for(int i = (a); i >= (b); i--)\n#define ALL(u) (u).begin(), (u).end()\n#define INF 100000000\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tint n, m;\n\tcin >> n;\n\tvector<int> lb(n), ub(n);\n\tmap<char, int> id;\n\trep(i, n) {\n\t\tchar name;\n\t\tcin >> name >> lb[i] >> ub[i];\n\t\tid[name] = i;\n\t}\n\tcin >> m;\n\tvector<string> e(m);\n\trep(i, m) cin >> e[i];\n\t\n\tvector<int> val(n);\n\trep(i, n) val[i] = lb[i];\n\tbool end = false;\n\tint a, b;\n\t\n\twhile(!end){\n\t\tvector<int> stk;\n\t\trep(j, m){\n\t\t\t//rep(k, stk.size()) cout << stk[k] << \" \";\n\t\t\t//cout << endl;\n\t\t\tif(e[j][0] == '+' && e[j].size() == 1) {\n\t\t\t\tb = stk.back(); stk.pop_back();\n\t\t\t\ta = stk.back(); stk.pop_back();\n\t\t\t\tstk.push_back((a+b)%256);\n\t\t\t}else if(e[j][0] == '-' && e[j].size() == 1) {\n\t\t\t\tb = stk.back(); stk.pop_back();\n\t\t\t\ta = stk.back(); stk.pop_back();\n\t\t\t\tstk.push_back((a-b+256)%256);\n\t\t\t}else if(e[j][0] == '*') {\n\t\t\t\tb = stk.back(); stk.pop_back();\n\t\t\t\ta = stk.back(); stk.pop_back();\n\t\t\t\tstk.push_back((a*b)%256);\n\t\t\t}else if(e[j][0] == '/') {\n\t\t\t\tb = stk.back(); stk.pop_back();\n\t\t\t\ta = stk.back(); stk.pop_back();\n\t\t\t\tif(b == 0){\n\t\t\t\t\tcout << \"error\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tstk.push_back((a/b)%256);\n\t\t\t}else if((e[j][0] >= '0' && e[j][0] <= '9')||(e[j].size() > 1 && (e[j][1] >= '0' && e[j][1] <= '9'))) {\n\t\t\t\tstk.push_back(atoi(e[j].c_str()));\n\t\t\t}else {\n\t\t\t\tstk.push_back(val[id[e[j][0]]]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tval[0]++;\n\t\tint i = 0;\n\t\twhile(val[i] > ub[i]){\n\t\t\tif(i >= n-1) {\n\t\t\t\tend = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tval[i] = lb[i];\n\t\t\tval[i+1]++;\n\t\t\ti++;\n\t\t}\n\t}\n\tcout << \"correct\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstring in[100];\n\nint main() {\n  int m;\n  cin >> m;\n  map<string, pii> mp;\n  REP(i,m) {\n    string name;\n    cin >> name;\n    int a, b;\n    cin >> a >> b;\n    mp[name] = pii(a,b);\n  }\n  int n;\n  cin >> n;\n  REP(i,n)cin >> in[i];\n  stack<set<int> > stk;\n  int mod = 256;\n  REP(i,n) {\n    string s = in[i];\n    if (mp.count(s)) {\n      pii p = mp[s];\n      set<int> se;\n      for (int j=p.first; j<=p.second; ++j) {\n        se.insert(j);\n      }\n      stk.push(se);\n    } else if (s.size() == 1 && !isdigit(s[0])) {\n      assert(stk.size());\n      set<int> b = stk.top();\n      stk.pop();\n      assert(stk.size());\n      set<int> a = stk.top();\n      stk.pop();\n      set<int> se;\n      FOR(it, a) {\n        FOR(jt, b) {\n          if (s==\"+\") se.insert((*it + *jt)%mod);\n          else if (s==\"-\") se.insert((*it - *jt + mod)%mod);\n          else if (s==\"*\") se.insert((*it * *jt) %mod);\n          else {\n            if (*jt == 0) {\n              puts(\"error\");\n              return 0;\n            }\n            se.insert(*it / *jt % mod);\n          }\n        }\n      }\n      stk.push(se);\n    } else {\n      set<int> se;\n      se.insert((atoi(s.c_str()) % mod + mod) % mod);\n      stk.push(se);\n    }\n    //FOR(it, stk.top()) cout << *it << \" \";cout << endl;\n  }\n  puts(\"correct\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int m;\n  cin >> m;\n  map<string, vector<bool>> mp;\n  for (int i = 0; i < m; i++){\n    string name;\n    int lb, ub;\n    cin >> name >> lb >> ub;\n    mp[name] = vector<bool>(256, false);\n    for (int j = lb; j <= ub; j++){\n      mp[name][j] = true;\n    }\n  }\n  int n;\n  cin >> n;\n  bool ok = true;\n  stack<vector<bool>> st;\n  for (int i = 0; i < n; i++){\n    string S;\n    cin >> S;\n    if (mp.count(S)){\n      st.push(mp[S]);\n    } else if ('0' <= S[0] && S[0] <= '9'){\n      vector<bool> tmp(256, false);\n      tmp[stoi(S)] = true;\n      st.push(tmp);\n    } else {\n      vector<bool> b = st.top();\n      st.pop();\n      vector<bool> a = st.top();\n      st.pop();\n      if (S == \"/\" && b[0]){\n        ok = false;\n        break;\n      }\n      vector<bool> r(256, false);\n      for (int i = 0; i < 256; i++){\n        for (int j = 0; j < 256; j++){\n          if (a[i] && b[j]){\n            if (S == \"+\"){\n              r[(i + j) % 256] = true;\n            }\n            if (S == \"-\"){\n              r[(i - j + 256) % 256] = true;\n            }\n            if (S == \"*\"){\n              r[i * j % 256] = true;\n            }\n            if (S == \"/\"){\n              r[i / j] = true;\n            }\n          }\n        }\n      }\n      st.push(r);\n    }\n  }\n  if (ok){\n    cout << \"correct\" << endl;\n  } else {\n    cout << \"error\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint getNum(string a){\n  int res=0;\n  for(int i=0;i<a.size();i++) res=res*10+a[i]-'0';\n  return res;\n}\n\nmap<string,P> val;\nvector<string> el;\nint n;\n\nset<stack<int> > S[101];\nbool calc(stack<int> s,int idx){\n  if(idx==n||S[idx].count(s)) return 0;\n  S[idx].insert(s);\n  \n  string e=el[idx];\n  if(isdigit(e[0])){\n    s.push(getNum(e));\n    return calc(s,idx+1);\n  }\n\n  if(isalpha(e[0])){\n    int l=val[e].first,r=val[e].second;\n    for(int i=l;i<=r;i++){\n      s.push(i);\n      if(calc(s,idx+1))return 1;\n      s.pop();\n    }\n    return 0;\n  }\n  \n  int b=s.top();s.pop();\n  int a=s.top();s.pop();\n  int r;\n  if(e[0]=='+')r=a+b;\n  if(e[0]=='-')r=a-b;\n  if(e[0]=='*')r=a*b;\n  if(e[0]=='/'){\n    if(b==0) return 1;\n    r=a/b;\n  }\n    s.push((r+256)%256);\n    return calc(s,idx+1);\n}\n\nint main(){\n  int m;\n  cin>>m;\n  for(int i=0,a,b;i<m;i++){\n    string t;\n    cin>>t>>a>>b;\n    val[t] = P(a,b);\n  }\n  cin>>n;\n  el.resize(n);\n  for(int i=0;i<n;i++) cin>>el[i];\n  cout<<(!calc(stack<int>(),0)?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline int setbit(int n) { return (1 << n) - 1; }\ninline bool contains(int x, int min, int max) { return x >= min && x < max; } // max含まない\n\nvoid solve()\n{\n\tint testcases = 1;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, M);\n\t\tmap<string, vector<bool>> var;\n\t\tREP(i, M)\n\t\t{\n\t\t\tREAD(string, name); READ(int, lb, ub);\n\t\t\tvector<bool> range(256);\n\t\t\tfill(partof(range, lb, ub - lb + 1), true);\n\t\t\tvar.insert(make_pair(name, range));\n\t\t}\n\n\t\tbool ok = true;\n\t\tvector<vector<bool>> stack;\n\t\tREAD(int, N);\n\t\tREP(_, N)\n\t\t{\n\t\t\tREAD(string, e);\n\t\t\tif (isdigit((unsigned)e[0]))\n\t\t\t{\n\t\t\t\tvector<bool> range(256);\n\t\t\t\trange[atoi(e.c_str())] = true;\n\t\t\t\tstack.push_back(range);\n\t\t\t}\n\t\t\telse if (e == \"+\")\n\t\t\t{\n\t\t\t\tvector<bool> r2 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r1 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r0(256);\n\t\t\t\tREP(i, 256) if (r1[i]) REP(j, 256) if (r2[j]) r0[(i + j) % 256] = true;\n\t\t\t\tstack.push_back(r0);\n\t\t\t}\n\t\t\telse if (e == \"-\")\n\t\t\t{\n\t\t\t\tvector<bool> r2 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r1 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r0(256);\n\t\t\t\tREP(i, 256) if (r1[i]) REP(j, 256) if (r2[j]) r0[(i - j + 256) % 256] = true;\n\t\t\t\tstack.push_back(r0);\n\t\t\t}\n\t\t\telse if (e == \"*\")\n\t\t\t{\n\t\t\t\tvector<bool> r2 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r1 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r0(256);\n\t\t\t\tREP(i, 256) if (r1[i]) REP(j, 256) if (r2[j]) r0[(i * j) % 256] = true;\n\t\t\t\tstack.push_back(r0);\n\t\t\t}\n\t\t\telse if (e == \"/\")\n\t\t\t{\n\t\t\t\tvector<bool> r2 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r1 = stack.back(); stack.pop_back();\n\t\t\t\tvector<bool> r0(256);\n\t\t\t\tif (r2[0]) { ok = false; break; }\n\t\t\t\tREP(i, 256) if (r1[i]) REP(j, 256) if (r2[j]) r0[(i / j) % 256] = true;\n\t\t\t\tstack.push_back(r0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstack.push_back(var[e]);\n\t\t\t}\n\t\t}\n\t\tWRITE(ok ? \"correct\" : \"error\");\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nbool num[128][256];\nint m, n;\nmap<string,pair<int,int> > bound;\nstring op = \"+-*/\";\n\nint main()\n{\n    memset(num,0,sizeof(num));\n    cin >> m;\n    rep(i,m){\n\tstring name;\n\tint lb, ub;\n\tcin >> name >> lb >> ub;\n\tbound[name] = mp(lb,ub);\n    }    \n    cin >> n;\n    stack<int> st;\n    rep(i,n){\n\tstring e;\n\tcin >> e;\n\tif(op.find(e) == string::npos){\n\t    st.push(i);\n\t    if(bound.find(e) != bound.end())\n\t\tfor(int j = bound[e].first; j <= bound[e].second; j++)\n\t\t    num[i][j] = true;\n\t    else\n\t\tnum[i][atoi(e.c_str())] = true;\n\t}else{\n\t    int b = st.top(); st.pop();\n\t    int a = st.top(); st.pop();\n\t    if(e == \"+\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j + k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"-\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j - k + 256) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"*\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j * k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"/\"){\n\t\tif(num[b][0]) {\n\t\t    cout << \"error\\n\";\n\t\t    return 0;\n\t\t}\n\t\trep(j,256)repi(k,1,256){\n\t\t    num[i][(j / k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t}\n\tst.push(i);\n    }\n    cout << \"correct\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define MOD 256\n\ndeque<string> q;\nunordered_map<string, S> mp;\nint nameLength = 21;\n\nbool isDigit(string s) {\n    return '0' <= s[0] && s[0] <= '9';\n}\n\nbool calc(int op) {\n    string a, b;\n    a = q.back(), q.pop_back();\n    b = q.back(), q.pop_back();\n    swap(a, b);\n    bool aa = isDigit(a), bb = isDigit(b);\n    if (aa && bb) {\n        if (op == 0) q.push_back(to_string((stoi(a) + stoi(b)) % MOD));\n        else if (op == 1) q.push_back(to_string((stoi(a) - stoi(b) + MOD) % MOD));\n        else if (op == 2) q.push_back(to_string((stoi(a) * stoi(b)) % MOD));\n        else {\n            if (stoi(b) != 0) q.push_back(to_string((stoi(a) / stoi(b)) % MOD));\n            else return false;\n        }\n    } else if (!aa && !bb) {\n        S c;\n        if (op == 0) each(i, mp[a])each(j, mp[b]) c.insert((i + j) % MOD);\n        else if (op == 1) each(i, mp[a])each(j, mp[b]) c.insert((i - j + MOD) % MOD);\n        else if (op == 2) each(i, mp[a])each(j, mp[b]) c.insert((i * j) % MOD);\n        else  each(i, mp[a])each(j, mp[b]) {\n            if (j != 0) c.insert((i / j) % MOD);\n            else return false;\n        }\n        string newStr('a', nameLength++);\n        q.push_back(newStr);\n        mp[newStr] = c;\n    } else {\n        if (!aa) swap(a, b);\n        S c;\n        int d = stoi(a);\n        if (op == 0) each(i, mp[b]) c.insert((d + i) % MOD);\n        else if (op == 1) each(i, mp[b]) c.insert((d - i + MOD) % MOD);\n        else if (op == 2) each(i, mp[b]) c.insert((d * i) % MOD);\n        else each(i, mp[b]) {\n            if (i != 0) c.insert((d / i) % MOD);\n            else return false;\n        }\n        string newStr('a', nameLength++);\n        q.push_back(newStr);\n        mp[newStr] = c;\n    }\n    return true;\n}\n\nbool decode(string s) {\n    bool ret = true;\n    if (s[0] == '+') {\n        ret = calc(0);\n    } else if (s[0] == '-') {\n        ret = calc(1);\n    } else if (s[0] == '*') {\n        ret = calc(2);\n    } else if (s[0] == '/') {\n        ret = calc(3);\n    } else {\n        q.push_back(s);\n    }\n    return ret;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n, m;\n    cin >> m;\n    rep(i, m) {\n        string s;\n        int l, u;\n        cin >> s >> l >> u;\n        S st;\n        repl(j, l, u + 1) st.insert(j);\n        mp[s] = st;\n    }\n\n    cin >> n;\n    bool ok = true;\n    rep(i, n) {\n        string s;\n        cin >> s;\n        ok = decode(s);\n        if (!ok) break;\n    }\n\n    if (ok) cout << \"correct\" << endl;\n    else cout << \"error\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  int M, N;\n  map< string, pair< int, int > > mp;\n  stack< int > s;\n  bool v[100][256] = {{}};\n  \n  cin >> M;\n  for(int i = 0; i < M; i++) {\n    string name;\n    int lb, rb;\n    cin >> name >> lb >> rb;\n    mp[name] = {lb, rb};\n  }\n  \n  cin >> N;\n\n  for(int i = 0; i < N; i++) {\n    string e;\n    cin >> e;\n    \n    if(string(\"+-*/\").find(e[0]) == string::npos) {\n      if(mp.find(e) == mp.end()) {\n        v[i][stoi(e)] = true;\n      } else {\n        auto p = mp[e];\n        for(int j = p.first; j <= p.second; j++) v[i][j] = true;\n      }\n    } else {\n      int b = s.top(); s.pop();\n      int a = s.top(); s.pop();\n      if(e[0] == '+') {\n        for(int j = 0; j < 256; j++)\n          for(int k = 0; k < 256; k++)\n            v[i][(j + k) % 256] |= v[a][j] & v[b][k];\n      } else if(e[0] == '-') {\n        for(int j = 0; j < 256; j++)\n          for(int k = 0; k < 256; k++)\n            v[i][(j - k + 256) % 256] |= v[a][j] & v[b][k];\n      } else if(e[0] == '*') {\n        for(int j = 0; j < 256; j++)\n          for(int k = 0; k < 256; k++)\n            v[i][(j * k) % 256] |= v[a][j] & v[b][k];\n      } else {\n        if(v[b][0]) {\n          cout << \"error\" << endl;\n          exit(0);\n        } else {\n          for(int j = 0; j < 256; j++)\n            for(int k = 1; k < 256; k++)\n              v[i][j / k] |= v[a][j] & v[b][k]; \n        }\n      }\n    }\n    s.push(i);\n  }\n  \n  cout << \"correct\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<map>\n#include<vector>\n#include<stdlib.h>\n#define f first\n#define s second\nusing namespace std;\n\nint main()\n{\n  int m,n,a,b;\n  string s,ans=\"correct\";\n  map<string,pair<int,int> > M;\n  stack<vector<int> > S;\n\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>a>>b;\n    M[s].f=a;\n    M[s].s=b;\n  }\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>s;\n    if(s==\"+\" || s==\"-\" || s==\"*\" || s==\"/\"){\n      vector<int> V1=S.top();S.pop();\n      vector<int> V2=S.top();S.pop();\n      vector<int> V3;\n      if(s==\"+\"){\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    int c=(V2[j]+V1[i])%256;\n\t    for(int k=0;k<V3.size();k++)if(V3[k]==c)continue;\n\t    V3.push_back(c);\n\t  }\n\t}\n      }\n      else if(s==\"-\"){\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    int c=(V2[j]-V1[i]+256)%256;\n\t    for(int k=0;k<V3.size();k++)if(V3[k]==c)continue;\n\t    V3.push_back(c);\n\t  }\n\t}\n      }\n      else if(s==\"*\"){\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    int c=(V2[j]*V1[i])%256;\n\t    for(int k=0;k<V3.size();k++)if(V3[k]==c)continue;\n\t    V3.push_back(c);\n\t  }\n\t}\n      }\n      else {\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    if(V1[i]==0){\n\t      ans=\"error\";\n\t      continue;\n\t    }\n\t    int c=(V2[j]/V1[i])%256;\n\t    //cout<<c<<endl;\n\t    for(int k=0;k<V3.size();k++)if(V3[k]==c)continue;\n\t    V3.push_back(c);\n\t  }\n\t}\n      }\n      S.push(V3);\n    }\n    else {\n      pair<int,int> p=M[s];\n      vector<int> V;\n      if(p.f!=0 && p.s!=0){\n\tfor(int i=p.f;i<=p.s;i++)V.push_back(i);\n      }\n      else V.push_back(atoi(s.c_str()));\n      S.push(V);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 256\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint calc(int a, int op, int b)\n{    \n    if (op == 0) {\n        return (a + b) % 256;\n    } else if (op == 1) {\n        return (a - b + 256) % 256;\n    } else if (op == 2) {\n        return (a * b) % 256;\n    } else {\n        return (b == 0 ? MAX : (a / b) % 256);\n    }\n}\n\nbool zero_division_checker()\n{\n    stack<vector<int>> st;\n    for (int i = 0; i < n; i++) {\n        if (isdigit(e[i][0])) {\n            st.push({s2i(e[i])});\n        } else {\n            vector<int> v;\n            int op = op_num(e[i][0]);            \n            if (op >= 0) {\n                vector<int> vb = st.top(); st.pop();\n                vector<int> va = st.top(); st.pop();\n                for (int j = 0; j < (int)va.size(); j++) {\n                    for (int k = 0; k < (int)vb.size(); k++) {\n                        int res = calc(va[j], op, vb[k]);\n                        if (res == MAX) {\n                            return 0;\n                        }\n                        v.push_back(res);\n                    }\n                }\n                sort(v.begin(), v.end());\n                v.erase(unique(v.begin(), v.end()), v.end());\n                st.push(v);\n            } else {\n                pii p = mp[e[i]];\n                for (int j = p.first; j <= p.second; j++) {\n                    v.push_back(j);\n                }\n                st.push(v);                \n            }\n        }\n    }\n    return 1;\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    cout << (zero_division_checker() ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass ParseError{};\nclass ZeroDivisionError{};\n\nvector<bool> Var(string S,map<string,pair<int,int>>& m,map<string,bool>& isVar){\n    vector<bool> res(256,false);\n    if(isVar[S]){\n        for(int i = m[S].first;i <= m[S].second;i++){\n            res[i] = true;\n        }\n    }else{\n        res[stoi(S)] = true;\n    }\n    return res;\n}\n\nvector<bool> operate(vector<bool>& arg1,vector<bool>& arg2,string op){\n    vector<bool> res(256,false);\n    if(op == \"+\"){\n         for(int i = 0;i < 256;i++){\n            for(int j = 0;j < 256;j++){\n                if(arg1[i] && arg2[j]){\n                    res[(i+j)%256] = true;\n                }\n            }\n        }\n        return res;\n    }\n    if(op == \"-\"){\n        for(int i = 0;i < 256;i++){\n            for(int j = 0;j < 256;j++){\n                if(arg1[i] && arg2[j]){\n                    res[(i-j+256)%256] = true;\n                }\n            }\n        }\n        return res;\n    }\n    if(op == \"*\"){\n        for(int i = 0;i < 256;i++){\n            for(int j = 0;j < 256;j++){\n                if(arg1[i] && arg2[j]){\n                    res[(i*j)%256] = true;\n                }\n            }\n        }\n        return res;\n    }\n    if(op == \"/\"){\n        for(int i = 0;i < 256;i++){\n            for(int j = 0;j < 256;j++){\n                if(arg1[i] && arg2[j]){\n                    if(j == 0){\n                        throw ZeroDivisionError();\n                    }\n                    res[(i/j)%256] = true;\n                }\n            }\n        }\n        return res;\n    }\n    throw ParseError();\n}\n\nint main(){\n    int M;\n    cin >> M;\n    map<string,pair<int,int>> m;\n    map<string,bool> isVar;\n    for(int i = 0;i < M;i++){\n        string name;\n        int lb,ub;\n        cin >> name >> lb >> ub;\n        m[name] = make_pair(lb,ub);\n        isVar[name] = true;\n    }\n    int n;\n    cin >> n;\n    stack<vector<bool>> s;\n    for(int i = 0;i < n;i++){\n        string tmp;\n        cin >> tmp;\n        if(tmp != \"+\" && tmp != \"-\" && tmp != \"*\" && tmp != \"/\"){\n            s.push(Var(tmp,m,isVar));\n        }else{\n            auto b = s.top();\n            s.pop();\n            auto a = s.top();\n            s.pop();\n            try{\n                auto res = operate(a,b,tmp);\n                s.push(res);\n            }catch(ZeroDivisionError err){\n                cout << \"error\" << endl;\n                return 0;\n            }catch(ParseError err){\n                cerr << \"unexpected operator:\" << tmp << endl;\n                return 1;\n            }\n        }\n    }\n    cout << \"correct\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\n\nbool isNumber(string s)\n{\n    rep(i,s.size())\n    {\n        if(!('0'<=s[i] && s[i]<='9')) return false;\n    }\n    return true;\n}\n\nstring solve()\n{\n    int m;\n    cin >>m;\n\n    map<string,vi> var;\n\n    rep(i,m)\n    {\n        string name;\n        int lb,rb;\n        cin >>name >>lb >>rb;\n\n        vi valid(256,0);\n        for(int j=lb; j<=rb; ++j) valid[j]=1;\n\n        var[name] = valid;\n    }\n\n    int n;\n    cin >>n;\n    vector<string> e(n);\n    rep(i,n) cin >>e[i];\n\n    string res=\"temporary_variable_for_calculation\";\n    int res_ct=0;\n    stack<string> st;\n    rep(i,n)\n    {\n        if(e[i]==\"+\" || e[i]==\"-\" || e[i]==\"*\" || e[i]==\"/\")\n        {\n            if(st.size()<2) return \"error\";\n\n            string B=st.top();\n            st.pop();\n            string A=st.top();\n            st.pop();\n\n            // cout << A << \" \" << e[i] << \" \" << B << '\\n';\n\n            vi valA(256,0),valB(256,0);\n            if(isNumber(A))\n            {\n                int tmp = atoi(A.c_str());\n                valA[tmp] = 1;\n            }\n            else valA = var[A];\n            if(isNumber(B))\n            {\n                int tmp = atoi(B.c_str());\n                valB[tmp] = 1;\n            }\n            else valB = var[B];\n\n\n            if(e[i]==\"/\")\n            {\n                if(valB[0]==1) return \"error\";\n            }\n\n            vi valC(256,0);\n            rep(a,256)rep(b,256)if(valA[a] && valB[b])\n            {\n                int c=0;\n                if(e[i]==\"+\") c=a+b;\n                else if(e[i]==\"-\") c=a-b;\n                else if(e[i]==\"*\") c=a*b;\n                else if(e[i]==\"/\") c=a/b;\n\n                c = (c+256)%256;\n                valC[c] = 1;\n            }\n\n            st.push(res+to_string(res_ct));\n            var[res+to_string(res_ct)] = valC;\n            ++res_ct;\n        }\n        else st.push(e[i]);\n    }\n\n    return \"correct\";\n}\n\nint main()\n{\n    cin.tie(0);ios::sync_with_stdio(false);\n    cout << solve() << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <stack>\n#include <string>\nusing namespace std;\n\nbool is_valiable(string e){\n  for(int i = 0; i < (int)e.length(); ++i){\n    if(e[i] < '0' || e[i] > '9') return true;\n  }\n  return false;\n}\n\nint main(){\n  int m, mod = 256;\n  cin >> m;\n  string name;\n  int lb, ub;\n  map<string, vector<int> > M;\n  for(int i = 0; i < m; ++i){\n    cin >> name >> lb >> ub;\n    vector<int> t(mod,0);\n    for(int j = lb; j <= ub; ++j){\n      t[j] = 1;\n    }\n    M[name] = t;\n  }\n  \n  int n;\n  cin >> n;\n  string e, o = \"+-*/\";\n  stack<string> st;\n  for(int i = 0; i < n; ++i){\n    cin >> e;\n    if(o.find(e) < 4){\n      string b = st.top();st.pop();\n      string a = st.top();st.pop();\n      //cout << a << \" \" << b << endl;\n      if(e == \"+\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  //st.push(to_string((j+k)%mod));\n\t\t  t[(j+k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j+B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A+j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod+stoi(b)%mod)%mod));\n\t  }\n\t}\n      }else if(e == \"-\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j-k+mod)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j-B+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A-j+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod-stoi(b)%mod+mod)%mod));\n\t  }\n\t}\n      }else if(e == \"*\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j*k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j*B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A*j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string(((stoi(a)%mod)*(stoi(b)%mod))%mod));\n\t  }\n\t}\n      }else if(e == \"/\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  if(k == 0){\n\t\t    cout << \"error\" << endl;\n\t\t    return 0;\n\t\t  }\n\t\t  t[((j%mod)/(k%mod))%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n   \t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j/B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tif(j == 0){\n\t\t  cout << \"error\" << endl;\n\t\t  return 0;\n\t\t}\n\t\tt[(A/j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    st.push(to_string((stoi(a)/stoi(b))%mod));\n\t  }\n\t}\n      }\n    }else{\n      st.push(e);\n    }\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n符号なしなので引き算して値がマイナスになったら符号を正にもどさないといけないっぽい\n*/\n#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(abs((*it_a)-(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(double)(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX_N = 256;\nusing E = array<bool, MAX_N>;\n\nmap<string,E> table;\nbool error = false;\n\nE add(E a, E b){\n    E res;\n    res.fill(false);\n    for(int i=0;i<MAX_N;i++){\n        for(int j=0;j<MAX_N;j++){\n            if(a[i]&&b[j]){\n                res[(i+j)%MAX_N] = true;\n            }\n        }\n    }\n    return res;\n}\n\nE sub(E a, E b){\n    E res;\n    res.fill(false);\n    for(int i=0;i<MAX_N;i++){\n        for(int j=0;j<MAX_N;j++){\n            if(a[i]&&b[j]){\n                res[(i-j+MAX_N)%MAX_N] = true;\n            }\n        }\n    }\n    return res;\n}\n\nE mul(E a, E b){\n    E res;\n    res.fill(false);\n    for(int i=0;i<MAX_N;i++){\n        for(int j=0;j<MAX_N;j++){\n            if(a[i]&&b[j]){\n                res[(i*j)%MAX_N] = true;\n            }\n        }\n    }\n    return res;\n}\n\nE div(E a, E b){\n    if(b[0]) error = true;\n    E res;\n    res.fill(false);\n    for(int i=0;i<MAX_N;i++){\n        for(int j=1;j<MAX_N;j++){\n            if(a[i]&&b[j]){\n                res[(i/j)%MAX_N] = true;\n            }\n        }\n    }\n    return res;\n}\n\nint solve(){\n    int m, n;\n    cin >> m;\n    for(int i=0;i<m;i++){\n        string name;\n        int l, u;\n        cin >> name >> l >> u;\n        E var;\n        var.fill(false);\n        for(int j=l;j<=u;j++){\n            var[j] = true;\n        }\n        table[name] = var;\n    }\n    stack<E> s;\n    cin >> n;\n    for(int i=0;i<n;i++){\n        string e;\n        cin >> e;\n        if(isdigit(e.front())){\n            int x = stoi(e);\n            E num;\n            num.fill(false);\n            num[x] = true;\n            s.push(num);\n        }else if(isalpha(e.front())){\n            E var = table[e];\n            s.push(var);\n        }else{\n            E a, b;\n            b = s.top(); s.pop();\n            a = s.top(); s.pop();\n            if(e == \"+\"){\n                s.push(add(a,b));\n            }else if(e == \"-\"){\n                s.push(sub(a,b));\n            }else if(e == \"*\"){\n                s.push(mul(a,b));\n            }else{\n                s.push(div(a,b));\n            }\n        }\n    }\n    cout << (error ? \"error\" : \"correct\") << endl;\n    return 0;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  time_t start=clock();\n  srand((unsigned)time(NULL));\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.7&&!f){\n    stack<uc> sc;\n    for(int i=0;!f&&i<n;i++){\n      //cout<<i<<\":\"<<ss[i]<<endl;\n      if(ms.find(ss[i])!=ms.end()){ \n\tint j=ms[ss[i]],k=(l[j]+(rand()%(r[j]-l[j])));\n\t//cout<<ss[i]<<\":\"<<k<<endl;\n\tsc.push(k);\n      }else if(isdigit(ss[i][0])){\n\tuc a=0;\n\tfor(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n\tsc.push(a);\n      }else{\n\tuc a,b;\n\tb=sc.top();sc.pop();\n\ta=sc.top();sc.pop();\n\tif(ss[i]==\"+\") sc.push(a+b);\n\tif(ss[i]==\"-\") sc.push(a-b);\n\tif(ss[i]==\"*\") sc.push(a*b);\n\tif(ss[i]==\"/\"){\n\t  if(b) sc.push(a/b);\n\t  else{\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint M, N, LB, UB;\nstring NAME;\nmap<string, pii> p;\nstack<int*> stk;\n\nint main(void) {\n  cin >> M;\n  REP(i, 0, M) {\n    cin >> NAME >> LB >> UB;\n    p[NAME] = pii(LB, UB);\n  }\n\n  cin >> N;\n  while(N--) {\n    cin >> NAME;\n    if(NAME == \"+\" || NAME == \"-\" || NAME == \"/\" || NAME == \"*\") {\n      int *op2 = stk.top(); stk.pop();\n      int *op1 = stk.top(); stk.pop();\n      int *ret = new int[256];\n      REP(i, 0, 256) ret[i] = 0;\n\n      // cout << \"{ \";\n      // REP(i, 0, 256) if(op1[i] == 1) cout << i << \" \";\n      // cout << \"} \" << NAME << \" { \";\n      // REP(i, 0, 256) if(op2[i] == 1) cout << i << \" \";\n      // cout << \"}\";\n\n      switch(NAME[0]) {\n        case '+':\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i + j) % 256] = 1;\n          break;\n        case '-':\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i - j + 256) % 256] = 1;\n          break;\n        case '*':\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i * j) % 256] = 1;\n          break;\n        case '/':\n          if(op2[0] == 1) {\n            cout << \"error\" << endl;\n            return 0;\n          }\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i / j)] = 1;\n          break;\n      }\n\n      // cout << \" = { \";\n      // REP(i, 0, 256) if(ret[i] == 1) cout << i << \" \";\n      // cout << \"}\" << endl;\n\n      stk.push(ret);\n    } else if(p.count(NAME)) {\n      int *ret = new int[256];\n      REP(i, 0, 256) ret[i] = 0;\n      REP(i, p[NAME].fi, p[NAME].se + 1) ret[i] = 1;\n      stk.push(ret);\n    } else {\n      int val = stoi(NAME);\n      int *ret = new int[256];\n      REP(i, 0, 256) ret[i] = 0;\n      ret[val] = 1;\n      stk.push(ret);\n    }\n  }\n  cout << \"correct\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nmap<string, P> mp;\ntypedef bitset<256> bs;\nint main(){\n\tbool zerodiv = false;\n\tint n, m; cin >> n;\n\trep(i, n) {\n\t\tstring s; int le, ri; cin >> s >> le >> ri;\n\t\tmp[s] = { le,ri };\n\t}\n\tstack<bitset<256>> q;\n\tcin >> m;\n\trep(i, m) {\n\t\tstring s; cin >> s;\n\t\tif (zerodiv)continue;\n\t\tbs b = 0;\n\t\tif ('0' <= s[0] && s[0] <= '9') {\n\t\t\tint u = stoi(s);\n\t\t\tb[u] = 1;\n\t\t\tq.push(b);\n\t\t}\n\t\telse if (s == \"+\") {\n\t\t\tbs c;\n\t\t\tc = q.top(); q.pop();\n\t\t\tb = q.top(); q.pop();\n\t\t\tbs nex = 0;\n\t\t\trep(j, 256) {\n\t\t\t\tif (!b[j])continue;\n\t\t\t\trep(k, 256) {\n\t\t\t\t\tif (!c[k])continue;\n\t\t\t\t\tnex[(j + k) % 256] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push(nex);\n\t\t}\n\t\telse if (s == \"-\") {\n\t\t\tbs c;\n\t\t\tc = q.top(); q.pop();\n\t\t\tb = q.top(); q.pop();\n\t\t\tbs nex = 0;\n\t\t\trep(j, 256) {\n\t\t\t\tif (!b[j])continue;\n\t\t\t\trep(k, 256) {\n\t\t\t\t\tif (!c[k])continue;\n\t\t\t\t\tnex[(j - k+256) % 256] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push(nex);\n\t\t}\n\t\telse if (s == \"*\") {\n\t\t\tbs c;\n\t\t\tc = q.top(); q.pop();\n\t\t\tb = q.top(); q.pop();\n\t\t\tbs nex = 0;\n\t\t\trep(j, 256) {\n\t\t\t\tif (!b[j])continue;\n\t\t\t\trep(k, 256) {\n\t\t\t\t\tif (!c[k])continue;\n\t\t\t\t\tnex[j*k % 256] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push(nex);\n\t\t}\n\t\telse if (s == \"/\") {\n\t\t\tbs c;\n\t\t\tc = q.top(); q.pop();\n\t\t\tb = q.top(); q.pop();\n\t\t\tif (c[0]) {\n\t\t\t\tzerodiv = true; continue;\n\t\t\t}\n\t\t\tbs nex = 0;\n\t\t\trep(j, 256) {\n\t\t\t\tif (!b[j])continue;\n\t\t\t\trep(k, 256) {\n\t\t\t\t\tif (!c[k])continue;\n\t\t\t\t\tnex[j/k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.push(nex);\n\t\t}\n\t\telse {\n\t\t\tRep1(j, mp[s].first, mp[s].second) {\n\t\t\t\tb[j] = 1;\n\t\t\t}\n\t\t\tq.push(b);\n\t\t}\n\t}\n\tif (zerodiv)cout << \"error\" << endl;\n\telse cout << \"correct\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n#include<array>\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n\ntypedef long long ll;\nmap<string,array<int,256> >data;\nconst int INF=1e9+7;\nint main(){\n\tint m;\n\tbool f=true;\n\tcin>>m;\n\trep(i,m){\n\t\tstring str;\n\t\tcin>>str;\n\t\tint l,u;\n\t\tcin>>l>>u;\n\t\tFOR(i,l,u+1){\n\t\t\tdata[str][i]=1;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tstack<array<int,256> > st;\n\trep(k,n){\n\t\tstring str;\n\t\tcin>>str;\n\t\tif(str==\"0\" || atoi(str.c_str())>0){\n\t\t\tint num=atoi(str.c_str());\n\t\t\tarray<int,256>num_a;\n\t\t\trep(i,256)num_a[i]=0;\n\t\t\tnum_a[num]=1;\n\t\t\tst.push(num_a);\n\t\t}\n\t\telse if(str==\"+\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i+j)%256]|=(r[i]&l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"-\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i-j+256)%256]|=(l[i]&r[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"*\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256)rep(j,256)ne[(i*j)%256]|=(r[i]&l[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"/\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\tif(r[0]==1){\n\t\t\t\tf=false;\n\t\t\t\tcout<<k<<endl;\n\t\t\t}\n\t\t\trep(i,256)FOR(j,1,256)ne[(i/j)%256]|=(l[i]&r[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse {\n\t\t\tst.push(data[str]);\n\t\t}\n\t}\n\tif(f)cout<<\"correct\"<<endl;\n\telse cout<<\"error\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = + 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = + 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = - 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = - 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = * 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = * 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = / 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = / 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      //cout << \"error = / 3\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 500\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX];\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n    int v = (st.empty() ? n : st.top());\n    if (memo[x][v] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res &= zero_division_checker(x+1, st);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return memo[x][v] = res;\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n符号なしなので引き算して値がマイナスになったら符号を正にもどさないといけないっぽい\n*/\n#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(abs((*it_a)-(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(double)(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\nbool isnum(string a)\n{\n\treturn ('0' <= a[0] && a[0] <= '9');\n}\n\nint tonum(string a)\n{\n\tint ret = 0;\n\trep(i, 0, a.length()) ret = ret * 10 + a[i] - '0';\n\treturn ret;\n}\n\nstring solve()\n{\n\tint m; cin >> m;\n\tmap<string, set<int>> name;\n\trep(i, 0, m)\n\t{\n\t\tstring s; cin >> s;\n\t\tint lb, ub; cin >> lb >> ub;\n\t\trep(i, lb, ub + 1) name[s].insert(i);\n\t}\n\n\tint n; cin >> n;\n\tint index = 0;\n\tstack<string> stk;\n\trep(_n, 0, n)\n\t{\n\t\tstring s; cin >> s;\n\n\t\tif ((s[0] == '+' || s[0] == '-') || (s[0] == '*' || s[0] == '/'))\n\t\t{\n\t\t\tstring b = stk.top(); stk.pop();\n\t\t\tstring a = stk.top(); stk.pop();\n\n\t\t\tset<int> aa, bb, cc;\n\n\t\t\tif (isnum(a))\n\t\t\t\taa.insert(tonum(a));\n\t\t\telse\n\t\t\t\tfor (int i : name[a]) aa.insert(i);\n\n\t\t\tif (isnum(b))\n\t\t\t\tbb.insert(tonum(b));\n\t\t\telse\n\t\t\t\tfor (int i : name[b]) bb.insert(i);\n\n\t\t\tif (s[0] == '/')\n\t\t\t{\n\t\t\t\tfor (int i : bb) if (i == 0) return \"error\";\n\t\t\t}\n\n\t\t\tfor (int aaa : aa) for (int bbb : bb)\n\t\t\t{\n\t\t\t\tint c;\n\t\t\t\tswitch (s[0])\n\t\t\t\t{\n\t\t\t\tcase '+': c = (aaa + bbb) % 256; break;\n\t\t\t\tcase '-': c = (aaa - bbb + 256) % 256; break;\n\t\t\t\tcase '*': c = (aaa * bbb) % 256; break;\n\t\t\t\tcase '/': c = (aaa / bbb) % 256; break;\n\t\t\t\t}\n\t\t\t\tcc.insert(c);\n\t\t\t}\n\n\t\t\tstring next = \"_\" + to_string(index);\n\t\t\tindex++;\n\t\t\tstk.push(next);\n\t\t\tname[next] = cc;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstk.push(s);\n\t\t}\n\t}\n\n\treturn \"correct\";\n}\n\nint main()\n{\n\tcout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvector<bool> add(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i + j) % 256] = true;\n\treturn c;\n}\n\nvector<bool> sub(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i - j + 256) % 256] = true;\n\treturn c;\n}\n\nvector<bool> mul(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i * j) % 256] = true;\n\treturn c;\n}\n\nvector<bool> div(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i / j) % 256] = true;\n\treturn c;\n}\n\nint main() {\n\tint m; cin >> m;\n\tvector<string> name(m);\n\tvector<int> lb(m), ub(m);\n\tfor (int j = 0; j < m; j++)\n\t\tcin >> name[j] >> lb[j] >> ub[j];\n\tstack< vector<bool> > s;\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tstring e; cin >> e;\n\t\tif (e == \"+\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\ts.push(add(a, b));\n\t\t}\n\t\telse if (e == \"-\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\ts.push(sub(a, b));\n\t\t}\n\t\telse if (e == \"*\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\ts.push(mul(a, b));\n\t\t}\n\t\telse if (e == \"/\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\tif (b[0]) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts.push(div(a, b));\n\t\t}\n\t\telse {\n\t\t\tvector<bool> a(256);\n\t\t\tint _j = -1;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (name[j] == e) _j = j;\n\t\t\tif (_j == -1) {\n\t\t\t\tint i = stoi(e);\n\t\t\t\ta[i] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = lb[_j]; i <= ub[_j]; i++)\n\t\t\t\t\ta[i] = true;\n\t\t\t}\n\t\t\ts.push(a);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <queue>\n#include <set>\n#include <stack>\nusing namespace std;\n\nstruct Number{\n  vector<int> cand;\n  Number(int s, int e){\n    for(int i = s; i <= e; i++)\n      cand.push_back(i);\n  }\n  Number(int n){\n    cand.push_back(n);\n  }\n  Number(){}\n};\n\nNumber operator + (const Number &lhs, const Number &r\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    ret.cand.push_back((lhs.cand[i] + rhs.cand[j]) %\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.\n  }\n  return ret;\n}\n\nNumber operator - (const Number &lhs, const Number &r\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    ret.cand.push_back((lhs.cand[i] - rhs.cand[j] + 2\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.\n  }\n  return ret;\n}\n\nNumber operator * (const Number &lhs, const Number &r\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    ret.cand.push_back((lhs.cand[i] * rhs.cand[j]) %\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.\n  }\n  return ret;\n}\n\nNumber operator / (const Number &lhs, const Number &r\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    if(rhs.cand[j] == 0) throw 0;\n    ret.cand.push_back((lhs.cand[i] / rhs.cand[j]) %\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.\n  }\n  return ret;\n}\n\nint main(){\n  stack<Number> st;\n  const int m = getInt();\n  map<string, Number> v;\n\n  REP(i,m){\n    char buff[256];\n    int lb, ub;\n    scanf(\"%s%d%d\", buff, &lb, &ub);\n    v[buff] = Number(lb, ub);\n  }\n\n  const int n = getInt();\n\n  try{\n    REP(i,n){\n      char buff[256];\n      scanf(\"%s\", buff);\n      if(v.count(buff)){\n        st.push(v[buff]);\n      }else if(!isdigit(*buff)){\n        const Number rhs = st.top(); st.pop();\n        const Number lhs = st.top(); st.pop();\n        switch(*buff){\n        case '+': st.push(lhs + rhs); break;\n        case '-': st.push(lhs - rhs); break;\n        case '*': st.push(lhs * rhs); break;\n        case '/': st.push(lhs / rhs); break;\n        }\n      }else{\n        int d; sscanf(buff, \"%d\", &d);\n        st.push(d);\n      }\n    }\n    puts(\"correct\");\n  }catch(int e){\n    puts(\"error\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <stack>\n#include <map>\nusing namespace std;\nmap<string, vector<bool>> mp;\nint main() {\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tstring name;\n\t\tint l, u;\n\t\tcin >> name >> l >> u;\n\t\tvector<bool> v;\n\t\tfor (int i = 0; i <= 255; i++) {\n\t\t\tv.push_back(l <= i && i <= u);\n\t\t}\n\t\tmp[name] = v;\n\t}\n\tint n;\n\tcin >> n;\n\tstack<vector<bool>> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring e;\n\t\tcin >> e;\n\t\tif (mp.find(e) != mp.end()) {\n\t\t\ts.push(mp[e]);\n\t\t}\n\t\telse if(isdigit(e[0])) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 0; j < e.size(); j++) {\n\t\t\t\tval *= 10;\n\t\t\t\tval += e[j] - '0';\n\t\t\t}\n\t\t\tvector<bool> v;\n\t\t\tfor (int j = 0; j <= 255; j++) {\n\t\t\t\tv.push_back(j == val);\n\t\t\t}\n\t\t\ts.push(v);\n\t\t}\n\t\telse {\n\t\t\tvector<bool> op1, op2, res;\n\t\t\top2 = s.top(); s.pop();\n\t\t\top1 = s.top(); s.pop();\n\t\t\tfor (int j = 0; j <= 255; j++) res.push_back(0);\n\t\t\tfor (int j = 0; j <= 255; j++) {\n\t\t\t\tif (!op1[j]) continue;\n\t\t\t\tfor (int k = 0; k <= 255; k++) {\n\t\t\t\t\tif (!op2[k]) continue;\n\t\t\t\t\tif (e[0] == '+') {\n\t\t\t\t\t\tres[(j + k) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (e[0] == '-') {\n\t\t\t\t\t\tres[(j - k + 256) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (e[0] == '*') {\n\t\t\t\t\t\tres[j*k % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres[j / k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nbool isOp(string& s){\n\treturn s.size() == 1 and not isalpha(s[0]) and not isdigit(s[0]);\n}\n\nset<int> getNumbers(map<string, pair<int,int>>& var, string& a){\n\tset<int> res;\n\trange(i, var[a].first, var[a].second + 1){\n\t\tres.emplace(i);\n\t}\n\treturn res;\n}\n\nbool f;\nset<int> cul(set<int>& a, set<int>& b, string op){\n\tset<int> res;\n\tfor(auto i : a){\n\t\tfor(auto j : b){\n\t\t\t//cout << i << ' ' << j << endl;\n\t\t\tif(op == \"+\") res.emplace((i + j) % 256);\n\t\t\telse if(op == \"-\") res.emplace((i - j + 256) % 256);\n\t\t\telse if(op == \"*\") res.emplace((i * j) % 256);\n\t\t\telse if(op == \"/\"){\n\t\t\t\tif(j == 0) f = false;\n\t\t\t\telse res.emplace((i / j) % 256);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\tint m;\n\tcin >> m;\n\n\tmap<string, pair<int, int>> var;\n\trep(i,m){\n\t\tstring name;\n\t\tint l, r;\n\t\tcin >> name >> l >> r;\n\t\tvar[name] = make_pair(l, r);\n\t}\n\n\tint n;\n\tcin >> n;\n\n\tstack<set<int>> st;\n\tf = true;\n\trep(i,n){\n\t\tstring s;\n\t\tcin >> s;\n\n\t\tif(isOp(s)){\n\t\t\tset<int> b = st.top(); st.pop();\n\t\t\tset<int> a = st.top(); st.pop();\n\t\t\tst.emplace(cul(a, b, s));\n\t\t}else{\n\t\t\tif(var.count(s)){\n\t\t\t\tst.emplace(getNumbers(var, s));\n\t\t\t}else{\n\t\t\t\tst.emplace(set<int>{stoi(s)});\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << (f ? \"correct\" : \"error\") << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<cctype>\n\nusing namespace std;\n\nint main(){\n  int m;\n  cin>>m;\n  map<string,set<unsigned char> > mp;\n  while(m--){\n    string name;\n    int lb,ub;\n    cin>>name>>lb>>ub;\n    set<unsigned char> s;\n    for(int i=lb;i<=ub;i++){\n      s.insert(i);\n    }\n    mp[name]=s;\n  }\n  int n;\n  cin>>n;\n  bool zd=false;\n  stack<set<unsigned char> > s;\n  while(n--){\n    string e;\n    cin>>e;\n    if(isdigit(e[0])){\n      s.push({atoi(e.c_str())});\n    }else if(isalpha(e[0])){\n      s.push(mp[e]);\n    }else{\n      auto b=s.top();\n      s.pop();\n      auto a=s.top();\n      s.pop();\n      set<unsigned char> r;\n      for(auto aa:a){\n\tfor(auto bb:b){\n\t  if(e[0]=='/'&&bb==0){\n\t    zd=true;\n\t  }else{\n\t    if(e[0]=='+'){\n\t      r.insert(aa+bb);\n\t    }else if(e[0]=='-'){\n\t      r.insert(aa-bb);\n\t    }else if(e[0]=='*'){\n\t      r.insert(aa*bb);\n\t    }else{\n\t      r.insert(aa/bb);\n\t    }\n\t  }\n\t}\n      }\n      s.push(r);\n    }\n  }\n  cout<<(zd?\"error\":\"correct\")<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  time_t start=clock();\n  srand(unsigned(time));\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.7&&!f){\n    stack<uc> sc;\n    for(int i=0;!f&&i<n;i++){\n      //cout<<i<<\":\"<<ss[i]<<endl;\n      if(ms.find(ss[i])!=ms.end()){ \n\tint j=ms[ss[i]],k=(l[j]+(rand()%(r[j]-l[j])));\n\t//cout<<ss[i]<<\":\"<<k<<endl;\n\tsc.push(k);\n      }else if(isdigit(ss[i][0])){\n\tuc a=0;\n\tfor(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n\tsc.push(a);\n      }else{\n\tuc a,b;\n\tb=sc.top();sc.pop();\n\ta=sc.top();sc.pop();\n\tif(ss[i]==\"+\") sc.push(a+b);\n\tif(ss[i]==\"-\") sc.push(a-b);\n\tif(ss[i]==\"*\") sc.push(a*b);\n\tif(ss[i]==\"/\"){\n\t  if(b) sc.push(a/b);\n\t  else{\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n;\nvector<string> e;\nmap<string, pii> mp;\n\nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n\nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res &= zero_division_checker(x+1, st);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main() {\n  int n,m,mod=256;\n  cin >> n;\n  map<string,P> ma;\n  for(int i=0; i<n; i++) {\n    string s;\n    P p;\n    cin >> s >> p.first >> p.second;\n    ma[s]=p;\n  }\n  queue<vector<int> > que;\n  cin >> m;\n  for(int i=0; i<m; i++) {\n    string s;\n    cin >> s;\n    vector<int> a(mod);\n    fill(a.begin(),a.end(),0);\n    if(s[0]=='+') a[0]=2;\n    else if(s[0]=='-') a[0]=3;\n    else if(s[0]=='*') a[0]=4;\n    else if(s[0]=='/') a[0]=5;\n    else if(isdigit(s[0])) {\n      stringstream ss;\n      ss << s;\n      int x;\n      ss >> x;\n      a[x%mod]=1;\n    } else {\n      for(int i=ma[s].first; i<=ma[s].second; i++) a[i]=1;\n    }\n    que.push(a);\n  }\n  stack<vector<int> > s;\n  while(!que.empty()) {\n    vector<int> c=que.front();que.pop();\n    if(c[0]>=2) {\n      vector<int> a,b,d(mod);\n      fill(d.begin(),d.end(),0);\n      b=s.top();s.pop();\n      a=s.top();s.pop();\n      for(int i=0; i<mod; i++) {\n\tfor(int j=0; j<mod; j++) {\n\t  if(!a[i] || !b[j]) continue;\n\t  if(c[0]==2) d[(i+j)%mod]=1;\n\t  if(c[0]==3) d[(i-j+mod)%mod]=1;\n\t  if(c[0]==4) d[(i*j)%mod]=1;\n\t  if(c[0]==5) {\n\t    if(j==0) {\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    } else d[(i/j)%mod]=1;\n\t  }\n\t}\n      }\n      s.push(d); \n    } else s.push(c);\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<stack>\nusing namespace std;\nint n,m;\nmap<string,int>M;\nvector<int>a[100];\nbool flag;\nint cal(int x,int y,char c)\n{\n\tif(c=='+')return(x+y)%256;\n\telse if(c=='-')return(x-y+256)%256;\n\telse if(c=='*')return x*y%256;\n\telse\n\t{\n\t\tif(y)return x/y%256;\n\t\telse return flag=true;\n\t}\n}\nmain()\n{\n\tcin>>m;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tstring s;int L,R;\n\t\tcin>>s>>L>>R;\n\t\tM[s]=i;\n\t\tfor(int j=L;j<=R;j++)a[i].push_back(j);\n\t}\n\tcin>>n;\n\tstack<int>S;\n\tfor(;n--;)\n\t{\n\t\tstring s;cin>>s;\n\t\tif(s[0]>='0'&&s[0]<='9')\n\t\t{\n\t\t\tint now=0;\n\t\t\tfor(int i=0;i<s.size();i++)now=(now*10+s[i]-48)%256;\n\t\t\tS.push(now);\n\t\t}\n\t\telse if(M.find(s)!=M.end())\n\t\t{\n\t\t\tS.push(~M[s]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x,y;\n\t\t\ty=S.top();S.pop();\n\t\t\tx=S.top();S.pop();\n\t\t\tif(x>=0&&y>=0)S.push(cal(x,y,s[0]));\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector<int>tmp;\n\t\t\t\tif(x>=0)\n\t\t\t\t{\n\t\t\t\t\tfor(int Y:a[~y])tmp.push_back(cal(x,Y,s[0]));\n\t\t\t\t\tsort(tmp.begin(),tmp.end());\n\t\t\t\t\ttmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());\n\t\t\t\t\ta[~y]=tmp;\n\t\t\t\t\tS.push(y);\n\t\t\t\t}\n\t\t\t\telse if(y>=0)\n\t\t\t\t{\n\t\t\t\t\tfor(int X:a[~x])tmp.push_back(cal(X,y,s[0]));\n\t\t\t\t\tsort(tmp.begin(),tmp.end());\n\t\t\t\t\ttmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());\n\t\t\t\t\ta[~x]=tmp;\n\t\t\t\t\tS.push(x);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfor(int X:a[~x])for(int Y:a[~y])tmp.push_back(cal(X,Y,s[0]));\n\t\t\t\t\tsort(tmp.begin(),tmp.end());\n\t\t\t\t\ttmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());\n\t\t\t\t\ta[~x]=tmp;\n\t\t\t\t\tS.push(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(flag?\"error\":\"correct\")<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nbool isDigits(char c) {return c>='0'&&c<='9';}\n\nbool isAllDigits(string s) {\n\tfor(auto& c : s) {\n\t\tif(!isDigits(c)) return false;\n\t}\n\treturn true;\n}\nll StoLL(const string& s) {\n\tll ret = 0LL;\n\tfor(auto& c : s) ret = ret*10 + (c-'0');\n\treturn ret;\n}\n\n//[l, r] wo merge\nset<pii> mergeSegment(const set<pii>& st) {\n\tset<pii> ret;\n\tif(st.size() == 0) return ret;\n\tauto p = *st.begin();\n\tauto it = st.begin();\n\tit++;\n\twhile(it != st.end()) {\n\t\tauto tmp = *it;\n\t\tif(p.se+1 >= tmp.fi) {\n\t\t\tp.fi = min(p.fi, tmp.fi);\n\t\t\tp.se = max(p.se, tmp.se);\n\t\t}\n\t\telse{\n\t\t\tret.insert(p);\n\t\t\tp = tmp;\n\t\t}\n\t\tit++;\n\t}\n\tret.insert(p);\n\treturn ret;\n}\nstack<set<pii>> st;\n\nvoid plus_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\t// pii p;\n\n\t\t\t// p.fi = (a.fi + b.fi)%256;\n\t\t\t// p.se = (a.se + b.se)%256;\n\t\t\t// if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tret.insert({(aa+bb)%256,(aa+bb)%256});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid minus_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\t// pii p;\n\t\t\t// p.fi = (a.fi - b.se + 256) % 256;\n\t\t\t// p.se = (a.se - b.fi + 256) % 256;\n\t\t\t// if((a.fi - b.se < 0) ^ (a.se - b.fi < 0)) {\n\t\t\t// \tret.insert({0, min(p.fi, p.se)});\n\t\t\t// \tret.insert({max(p.fi, p.se), 255});\n\t\t\t// }\n\t\t\t// else if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tret.insert({(aa-bb+256)%256,(aa-bb+256)%256});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid mult_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\t// pii p;\n\t\t\t// p.fi = (a.fi * b.fi)%256;\n\t\t\t// p.se = (a.se * b.se)%256;\n\t\t\t// if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tret.insert({aa*bb%256,aa*bb%256});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nbool div_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tif(b.fi == 0) return false;\n\t\t\t// pii p;\n\t\t\t// p.fi = (a.fi / b.se)%256;\n\t\t\t// p.se = (a.se / b.fi)%256;\n\t\t\t// if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tif(bb == 0) return false;\n\t\t\t\t\tret.insert({aa/bb,aa/bb});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n\treturn true;\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tmap<string, pii> mp;\n\trep(i, m) {\n\t\tstring s;\n\t\tint l, r;\n\t\tcin >> s >> l >> r;\n\t\tmp[s] = {l, r};\n\t}\n\tint n;\n\tcin >> n;\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(isAllDigits(s)) {\n\t\t\tint num = StoLL(s);\n\t\t\tdump(num);\n\t\t\tset<pii>tmp;\n\t\t\ttmp.insert({num, num});\n\t\t\tst.push(tmp);\n\t\t}\n\t\telse if(s == \"+\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tplus_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"-\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tminus_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"*\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tmult_st_pii(a, b);\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse if(s == \"/\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\n\t\t\tdump(s);\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);\n\t\t\tif(!div_st_pii(a, b)) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t\telse {\n\t\t\tset<pii> tmp;\n\t\t\ttmp.insert(mp[s]);\n\t\t\tst.push(tmp);\n\n\t\t\tdumpV(tmp);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvoid unq(vi& v)\n{\n\tsort(ALL(v));\n\tauto it = unique(ALL(v));\n\tv.erase(it, v.end());\n}\n\nint main()\n{\n\tint m, n;\n\tunordered_map<string, vi> mp;\n\tcin >> m;\n\tREP(i, m)\n\t{\n\t\tstring c; int a, b; cin >> c >> a >> b;\n\t\tvi v;\n\t\tFOR(i, a, b + 1) v.push_back(i);\n\t\tmp[c] = v;\n\t}\n\tstack<vi> st;\n\tcin >> n;\n\tbool f = true;\n\tREP(i, n)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (s == \"+\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] + a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"-\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] - a[j] + 256) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"*\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] * a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"/\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size())\n\t\t\t{\n\t\t\t\tif (a[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\telse v.push_back((b[i] / a[j]) % 256);\n\t\t\t}\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (isalpha(s[0]))\n\t\t{\n\t\t\tst.push(mp[s]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint n = stoi(s);\n\t\t\tvi v = { n };\n\t\t\tst.push(v);\n\t\t}\n\t}\nend:;\n\tputs(f ? \"correct\" : \"error\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 256\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint calc(int a, int op, int b)\n{    \n    if (op == 0) {\n        return (a + b) % 256;\n    } else if (op == 1) {\n        return (a - b + 256) % 256;\n    } else if (op == 2) {\n        return (a * b) % 256;\n    } else {\n        return (b == 0 ? MAX : (a / b) % 256);\n    }\n}\n\nbool zero_division_checker()\n{\n    stack<vector<int>> st;\n    for (int i = 0; i < n; i++) {\n        if (isdigit(e[i][0])) {\n            st.push({s2i(e[i])});\n        } else {\n            vector<int> v;\n            int op = op_num(e[i][0]);            \n            if (op >= 0) {\n                vector<int> vb = st.top(); st.pop();\n                vector<int> va = st.top(); st.pop();\n                for (int j = 0; j < (int)va.size(); j++) {\n                    for (int k = 0; k < (int)vb.size(); k++) {\n                        int res = calc(va[j], op, vb[k]);\n                        if (res == MAX) {\n                            return 0;\n                        }\n                        v.push_back(res);\n                    }\n                }\n                sort(v.begin(), v.end());\n                v.erase(unique(v.begin(), v.end()), v.end());\n                st.push(v);\n            } else {\n                pii p = mp[e[i]];\n                for (int j = p.first; j <= p.second; j++) {\n                    v.push_back(j);\n                }\n                st.push(v);                \n            }\n        }\n    }\n    return 1;\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    cout << (zero_division_checker() ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\nstring zero(256,'0');\nmap<string ,string>ma;\n\nstring ch(string r){\n\tstring t=zero;\n\tt[stoi(r)]='1';\n\treturn t;\n}\nstack<string> st;\n\nstring tasu(string s,string t){\n\tstring f=zero;\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i+j)%256]='1';\n\t}\n\treturn f;\n}\n\nstring hiku(string s,string t){\n\tstring f=zero;\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i-j+256)%256]='1';\n\t}\n\treturn f;\n}\n\nstring kake(string s,string t){\n\tstring f=zero;\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i*j)%256]='1';\n\t}\n\treturn f;\n}\n\nstring waru(string s,string t){\n\tstring f=zero;\n\tif(t[0]=='1'){\n\t\tcout<<\"error\"<<endl;\n\t\texit(0);\n\t}\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i/j)%256]='1';\n\t}\n\treturn f;\n}\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint m,n;\n \tcin>>m;\n \t\n \tfor(int i=0;i<m;i++){\n \t\tstring t;\n \t\tint y1,y2;\n \t\tcin>>t>>y1>>y2;\n \t\tstring f=zero;\n \t\tfor(int j=y1;j<=y2;j++)f[j]='1';\n \t\tma[t]=f;\n \t}\n \t\n \tcin>>n;\n \t\n \tfor(int i=0;i<n;i++){\n \t\tstring t;\n \t\tcin>>t;\n \t\tif(t==\"+\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(tasu(s1,s2));\n \t\t}\n \t\t\n \t\telse if(t==\"*\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(kake(s1,s2));\n \t\t}\n \t\t\n \t\t\n \t\telse if(t==\"-\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(hiku(s1,s2));\n \t\t}\n \t\t\n \t\telse if(t==\"/\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(waru(s1,s2));\n \t\t}\n \t\telse if(ma.count(t)){\n \t\t\tst.push(ma[t]);\n \t\t}\n \t\telse st.push(ch(t));\n \t}\n \t\n \tcout<<\"correct\"<<endl;\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = + 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = + 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = - 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = - 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = * 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = * 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = / 1\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      //cout << \"error = / 2\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvoid unq(vi& v)\n{\n\tsort(ALL(v));\n\tauto it = unique(ALL(v));\n\tv.erase(it, v.end());\n}\n\nint main()\n{\n\tint m, n;\n\tunordered_map<char, vi> mp;\n\tcin >> m;\n\tREP(i, m)\n\t{\n\t\tchar c; int a, b; cin >> c >> a >> b;\n\t\tvi v;\n\t\tFOR(i, a, b + 1) v.push_back(i);\n\t\tmp[c] = v;\n\t}\n\tstack<vi> st;\n\tcin >> n;\n\tbool f = true;\n\tREP(i, n)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (s == \"+\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] + a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"-\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] - a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"*\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] * a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"/\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size())\n\t\t\t{\n\t\t\t\tif (a[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\telse v.push_back((b[i] / a[j]) % 256);\n\t\t\t}\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (isalpha(s[0]))\n\t\t{\n\t\t\tst.push(mp[s[0]]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint n = stoi(s);\n\t\t\tvi v = { n };\n\t\t\tst.push(v);\n\t\t}\n\t}\nend:;\n\tputs(f ? \"correct\" : \"error\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    int M;\n    map< string, bitset<256> > V;\n    int N;\n    vector<string> F;\n    void input() {\n        cin >> M;\n        V.clear();\n        for (int i = 0; i < M; i++) {\n            string name; int lb, ub;\n            cin >> name >> lb >> ub;\n            bitset<256> bit(0LL);\n            for (int i = lb; i <= ub; i++) bit[i] = true;\n            V[name] = bit;\n        }\n        cin >> N;\n        F.clear(); F.resize(N);\n        for (int i = 0; i < N; i++) cin >> F[i];\n    }\n\n    bool integer(const string& s) {\n        return isdigit(s[0]);\n    }\n\n    int to_i(const string& s) {\n        istringstream is(s);\n        int n; is >> n;\n        return n;\n    }\n\n    typedef bitset<256> B;\n\n    bool check() {\n        vector<B> stack;\n        for (int i = 0; i < N; i++) {\n            if (integer(F[i])) {\n                int x = to_i(F[i]);\n                B bit(0LL); bit[x] = true;\n                stack.push_back(bit);\n            } else if (V.count(F[i])) {\n                stack.push_back(V[ F[i] ]);\n            } else {\n                B b = stack.back(); stack.pop_back();\n                B a = stack.back(); stack.pop_back();\n                B c(0);\n                switch (F[i][0]) {\n                    case '+':\n                        for (int x = 0; x < 256; x++) {\n                            for (int y = 0; y < 256; y++) {\n                                if (a[x] && b[y]) {\n                                    c[(x + y) % 256] = true;\n                                }\n                            }\n                        }\n                        stack.push_back(c);\n                        break;\n                    case '-':\n                        for (int x = 0; x < 256; x++) {\n                            for (int y = 0; y < 256; y++) {\n                                if (a[x] && b[y]) {\n                                    c[(x - y + 256) % 256] = true;\n                                }\n                            }\n                        }\n                        stack.push_back(c);\n                        break;\n                    case '*':\n                        for (int x = 0; x < 256; x++) {\n                            for (int y = 0; y < 256; y++) {\n                                if (a[x] && b[y]) {\n                                    c[x * y % 256] = true;\n                                }\n                            }\n                        }\n                        stack.push_back(c);\n                        break;\n                    case '/':\n                        if (b[0]) return false;\n                        for (int x = 0; x < 256; x++) {\n                            for (int y = 0; y < 256; y++) {\n                                if (a[x] && b[y]) {\n                                    c[x / y] = true;\n                                }\n                            }\n                        }\n                        stack.push_back(c);\n                        break;\n                    default: assert(0);\n                }\n            }\n        }\n        return true;\n    }\n\n    void solve() {\n        cout << (check() ? \"correct\" : \"error\") << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nbool is_number(const string &s){\n  REP(i, s.size()) if(!isdigit(s[i])) return false;\n  return true;\n}\n\nint main(){\n  int m, n;\n  string name;\n  map<string, int> L, R;\n  \n  cin >> m;\n  REP(i, m){\n    cin >> name;\n    cin >> L[name] >> R[name];\n  }\n\n  cin >> n;\n  stack<vector<int> > st;\n    \n  REP(i, n){\n    string exp;\n    vector<int> vec(256, 0);\n    \n    cin >> exp;\n    if(is_number(exp)){\n      vec[atoi(exp.c_str())] = 1;\n    }else if(L.find(exp) != L.end()){\n      for(int i = L[exp]; i <= R[exp]; i++) vec[i] = 1;\n    }else{\n      vector<int> b = st.top(); st.pop();\n      vector<int> a = st.top(); st.pop();\n\n      REP(i, 256)REP(j, 256)if(a[i] && b[j]){\n        if(exp == \"+\") vec[(a[i]+b[j])%256] = 1;\n        if(exp == \"-\") vec[(a[i]-b[j]+256)%256] = 1;\n        if(exp == \"*\") vec[(a[i]*b[j]) % 256] = 1;\n        if(exp == \"/\"){\n          \n          if(j == 0) {\n            cout << \"error\" << endl;\n            return 0;\n          }\n          \n          vec[a[i]/b[j]] = 1;\n        }\n      }\n    }\n    st.push(vec);\n  }\n\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<stack>\n#include<map>\n#include<sstream>\nusing namespace std;\n\ntypedef vector<bool> V;\ntypedef pair<int,int> P;\n\nint stoi(string x){\n  stringstream ss(x);\n  int r; ss >> r;\n  return r;\n}\n\nint cal(int a,int b,string op){\n  int res;\n  if(op == \"+\")res = a+b;\n  else if(op == \"-\")res = a-b;\n  else if(op == \"*\")res = a*b;\n  else res = a/b;\n  return (res + 256) % 256;\n}\n\nint main(){\n  string s,c[100];\n  int m,n,a,b;\n  map<string,P> h;\n  V t1(256),t2(256),t3(256);\n\n  cin >> m;\n  for(int i=0;i<m;i++){\n    cin >> s >> a >> b;\n    h[s] = P(a,b);\n  }\n\n  cin >> n;\n  for(int i=0;i<n;i++)cin >> c[i];\n\n  stack<V> p;\n  for(int i=0;i<n;i++){\n    if(c[i] == \"+\" || c[i] == \"-\" || c[i] == \"*\" || c[i] == \"/\"){\n      t2 = p.top(); p.pop();\n      t1 = p.top(); p.pop();\n      for(int j=0;j<256;j++)t3[j] = false;\n      for(int j=0;j<256;j++)\n\tfor(int k=0;k<256;k++)\n\t  if(t1[j] && t2[k]){\n\t    if(!k && c[i] == \"/\"){\n\t      cout << \"error\\n\";\n\t      return 0;\n\t    }else t3[cal(j,k,c[i])] = true;\n\t  }\n      p.push(t3);\n    }else if(h.find(c[i]) != h.end()){\n      for(int j=0;j<256;j++)t3[j] = false;\n      a = h[c[i]].first; b = h[c[i]].second;\n      for(int j=a;j<=b;j++)t3[j] = true;\n      p.push(t3);\n    }else{\n      for(int j=0;j<256;j++)t3[j] = false;\n      t3[stoi(c[i])] = true;\n      p.push(t3);\n    }\n  }\n  cout << \"correct\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tmap<string, int>l;\n\tmap<string, int>r;\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tcin >> L >> R;\n\t\tl[s] = L;\n\t\tr[s] = R;\n\t}\n\tcin >> N;\n\tstack<bitset<256>>st;\n\tfor (int i = 0; i < N; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\t//cout << i << endl;\n\t\t//if (!st.empty())cout << st.top().to_string() << endl;\n\t\tif (s[0] == '+') {\n\t\t\tauto b = st.top();\n\t\t\tst.pop();\n\t\t\tauto a = st.top();\n\t\t\tst.pop();\n\t\t\tbitset<256>ret;\n\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\tfor (int k = 0; k < 256; k++) {\n\t\t\t\t\tif (a.test(j) && b.test(k)) {\n\t\t\t\t\t\tret.set((j + k) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ret);\n\t\t}\n\t\telse if (s[0] == '-') {\n\t\t\tauto b = st.top();\n\t\t\tst.pop();\n\t\t\tauto a = st.top();\n\t\t\tst.pop();\n\t\t\tbitset<256>ret;\n\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\tfor (int k = 0; k < 256; k++) {\n\t\t\t\t\tif (a.test(j) && b.test(k)) {\n\t\t\t\t\t\tret.set((j - k + 256) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ret);\n\t\t}\n\t\telse if (s[0] == '*') {\n\t\t\tauto b = st.top();\n\t\t\tst.pop();\n\t\t\tauto a = st.top();\n\t\t\tst.pop();\n\t\t\tbitset<256>ret;\n\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\tfor (int k = 0; k < 256; k++) {\n\t\t\t\t\tif (a.test(j) && b.test(k)) {\n\t\t\t\t\t\tret.set((j * k) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ret);\n\t\t}\n\t\telse if(s[0]=='/'){\n\t\t\tauto b = st.top();\n\t\t\tst.pop();\n\t\t\tauto a = st.top();\n\t\t\tst.pop();\n\t\t\tbitset<256>ret;\n\t\t\tif (b.test(0)) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\tfor (int k = 0; k < 256; k++) {\n\t\t\t\t\tif (a.test(j) && b.test(k)) {\n\t\t\t\t\t\tret.set((j / k) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ret);\n\t\t}\n\t\telse if (s[0] <= '9'&&s[0] >= '0') {\n\t\t\tint num = stoi(s);\n\t\t\tbitset<256>ret;\n\t\t\tret.set(num);\n\t\t\tst.push(ret);\n\t\t}\n\t\telse {\n\t\t\tbitset<256>ret;\n\t\t\tfor (int i = l[s]; i <= r[s]; i++) {\n\t\t\t\tret.set(i);\n\t\t\t}\n\t\t\tst.push(ret);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbool calc(set<int>& B,set<int>& A,string ope,stack<set<int> >& ele)\n{\n  set<int> C;\n  for(set<int>::iterator it_B = B.begin();it_B != B.end();it_B++)\n    {\n      for(set<int>::iterator it_A = A.begin();it_A != A.end();it_A++)\n\t{\n\t  if(ope == \"+\")\n\t    {\n\t      C.insert(((*it_A)+(*it_B))%256);\n\t    }\n\t  else if(ope == \"-\")\n\t    {\n\t      C.insert(((*it_A)-(*it_B)+256)%256);\n\t    }\n\t  else if(ope == \"*\")\n\t    {\n\t      C.insert(((*it_A)*(*it_B))%256);\n\t    }\n\t  else if(ope == \"/\")\n\t    {\n\t      if(!(*it_B))\n\t\t{\n\t\t  cout << \"error\" << endl;\n\t\t  return false; \n\t\t}\n\t      C.insert(((*it_A)/(*it_B))%256);\n\t    }\n\t  else \n\t    assert(false);\n\t}\n    }\n  ele.push(C);\n  return true;\n}\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<set<int> > ele;\n  deque<string> st;\n  bool fin = false;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n     \n      if(e != \"/\" && e != \"*\" && e != \"-\" && e != \"+\")\n\t{\n\t  if(index.find(e) != index.end())\n\t    {\n\t      ele.push(index[e]);\n\t    }\n\t  else\n\t    {\n\t      set<int> FAGS;\n\t      FAGS.insert((atoi)(e.c_str()));\n\t      ele.push(FAGS);\n\t    }\n\t}\n      else \n\t{\n\t  set<int> A,B;\n\t  B = ele.top(),ele.pop();\n\t  A = ele.top(),ele.pop();\n\t  if(!calc(B,A,e,ele))\n\t    fin = true;\n\t    \n\t}\n\n    }\n\n  if(fin)\n    return 0;\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <map>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nstruct elem{\n    bool isPossible[256];\n    elem(){\n        fill(isPossible,isPossible+256,false);\n    }\n    elem(int lb,int ub){\n        fill(isPossible,isPossible+256,false);\n        for(int i=lb;i<=ub;i++)isPossible[i]=true;\n    }\n};\n\nint main(){\n    int m;\n    cin>>m;\n    map<string,elem> M;\n    for(int i=0;i<m;i++){\n        string name;\n        int lb,ub;\n        cin>>name>>lb>>ub;\n        M[name]=elem(lb,ub);\n    }\n    int n;\n    cin>>n;\n    stack<elem, vector<elem>> S;\n    for(int i=0;i<n;i++){\n        string str;\n        cin>>str;\n        stringstream ss(str);\n        if('0'<=str[0]&&str[0]<='9'){\n            int val;\n            ss>>val;\n            S.emplace(val,val);\n            continue;\n        }\n        if(str[0]=='+'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=0;b<256;b++){\n                    if(B.isPossible[b])C.isPossible[(a+b)&0b11111111]=true;\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        if(str[0]=='-'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=0;b<256;b++){\n                    if(B.isPossible[b])C.isPossible[(a-b)&0b11111111]=true;\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        if(str[0]=='*'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=0;b<256;b++){\n                    if(B.isPossible[b])C.isPossible[(a*b)&0b11111111]=true;\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        if(str[0]=='/'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            if(B.isPossible[0]){\n                cout<<\"error\"<<endl;\n                return 0;\n            }\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=1;b<256;b++){\n                    if(B.isPossible[b])C.isPossible[a/b]=true;\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        S.push(M[str]);\n    }\n    cout<<\"correct\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nset<int> calc(set<int> a,set<int> b,string op)\n{\n\tset<int> s;\n\tfor(int x:a) for(int y:b){\n\t\tswitch(op[0]){\n\t\tcase '+': s.insert((x+y)%256);     break;\n\t\tcase '-': s.insert((x-y+256)%256); break;\n\t\tcase '*': s.insert((x*y)%256);     break;\n\t\tcase '/': if(y==0) throw \"error\"; else s.insert(x/y);\n\t\t}\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tfor(int m;cin>>m && m!=-1;){\n\t\tmap<string,pii> ntor; // name -> range\n\t\trep(i,m){\n\t\t\tstring s; int a,b; cin>>s>>a>>b;\n\t\t\tntor[s]=mp(a,b);\n\t\t}\n\t\tint n; cin>>n;\n\t\tvs ts(n);\n\t\trep(i,n) cin>>ts[i];\n\t\t\n\t\ttry{\n\t\t\tstack<set<int>> st;\n\t\t\tfor(string t:ts){\n\t\t\t\tif(t==\"*\" || t==\"+\" || t==\"-\" || t==\"/\"){\n\t\t\t\t\tset<int> b=st.top(); st.pop();\n\t\t\t\t\tset<int> a=st.top(); st.pop();\n\t\t\t\t\tst.push(calc(a,b,t));\n\t\t\t\t}\n\t\t\t\telse if(isdigit(t[0])){\n\t\t\t\t\tset<int> s; s.insert(atoi(t.c_str()));\n\t\t\t\t\tst.push(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpii r=ntor[t];\n\t\t\t\t\tset<int> s;\n\t\t\t\t\trepi(i,r.first,r.second+1) s.insert(i);\n\t\t\t\t\tst.push(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<\"correct\"<<endl;\n\t\t}\n\t\tcatch(...){\n\t\t\tcout<<\"error\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint main() {\n  int n,m,mod=256;\n  cin >> n;\n  map<string,P> ma;\n  for(int i=0; i<n; i++) {\n    string s;\n    P p;\n    cin >> s >> p.first >> p.second;\n    ma[s]=p;\n  }\n  queue<vector<int> > que;\n  cin >> m;\n  for(int i=0; i<m; i++) {\n    string s;\n    cin >> s;\n    vector<int> a(mod);\n    fill(a.begin(),a.end(),0);\n    if(s[0]=='+') a[0]=2;\n    else if(s[0]=='-') a[0]=3;\n    else if(s[0]=='*') a[0]=4;\n    else if(s[0]=='/') a[0]=5;\n    else if(isdigit(s[0])) {\n      stringstream ss;\n      ss << s;\n      int x;\n      ss >> x;\n      a[x%mod]=1;\n    } else {\n      for(int i=ma[s].first; i<=ma[s].second; i++) a[i]=1;\n    }\n    que.push(a);\n  }\n  stack<vector<int> > s;\n  while(!que.empty()) {\n    vector<int> c=que.front();que.pop();\n    if(c[0]>=2) {\n      vector<int> a,b,d(mod);\n      fill(d.begin(),d.end(),0);\n      b=s.top();s.pop();\n      a=s.top();s.pop();\n      for(int i=0; i<mod; i++) {\n\tfor(int j=0; j<mod; j++) {\n\t  if(!a[i] || !b[j]) continue;\n\t  if(c[0]==2) d[(i+j)%mod]=1;\n\t  if(c[0]==3) d[(i-j)%mod]=1;\n\t  if(c[0]==4) d[(i*j)%mod]=1;\n\t  if(c[0]==5) {\n\t    if(j==0) {\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    } else d[(i/j)%mod]=1;\n\t  }\n\t}\n      }\n      s.push(d); \n    } else s.push(c);\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  \n\t\t  C.insert(((int)ceil((double)(*it_a)/(double)(*it_b)))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nbool solve(vector<string> &ops, map<string, P> &vs){\n  vector< set<int> > v;\n  for(string s : ops){\n    set<int> tmp;\n    if(vs.find(s) != vs.end()) FOR(i, vs[s].first, vs[s].second + 1) tmp.insert(i);\n    else if(isdigit(s[0])) tmp.insert(atoi(s.c_str()));\n    else if(s == \"+\") {\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x + y;\n          while(n >= 256) n -= 256;\n          tmp.insert(n);\n        }\n      }\n    } else if(s == \"-\"){\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x - y;\n          while(n < 0) n += 256;\n          tmp.insert(n);\n        }\n      }\n    } else if(s == \"*\"){\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x * y;\n          while(n >= 256) n -= 256;\n          tmp.insert(n);\n        }\n      }\n    } else if(s == \"/\"){\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          if(y == 0) return false;\n          int n = x / y;\n          while(n >= 256) n -= 256;\n          tmp.insert(n);\n        }\n      }\n    }\n    v.push_back(tmp);\n  }\n  return true;\n}\n\nint main() {\n  int M; cin >>M;\n  map<string, P> vs;\n  REP(i, M){\n    string s; cin >>s;\n    int l, u; cin >>l >>u;\n    vs[s] = P(l, u);\n  }\n  int N; cin >>N;\n  vector<string> ops(N);\n  REP(i, N) cin >>ops[i];\n  cout <<(solve(ops, vs) ? \"correct\" : \"error\")  <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <stack>\n#include <string>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\nstack<vi> st;\nmap<string,vi> mp;\nint main(){\n\tint m,n;\n\tcin>>m;\n\trep(i,m){\n\t\tstring name;\n\t\tint lb,ub;\n\t\tcin>>name>>lb>>ub;\n\t\tfor(int k=lb;k<=ub;k++) mp[name].pb(k);\n\t}\n\tcin>>n;\n\trep(i,n){\n\t\tstring c;\n\t\tcin>>c;\n\t\tif(c==\"+\"){\n\t\t\tvi b=st.top();st.pop();\n\t\t\tvi a=st.top();st.pop();\n\t\t\tvi r;\n\t\t\trep(i,a.size()) rep(j,b.size()) r.pb((a[i]+b[j])%256);\n\t\t\tsort(all(r));\n\t\t\tr.erase(unique(all(r)),r.end());\n\t\t\tst.push(r);\n\t\t}else if(c==\"-\"){\n\t\t\tvi b=st.top();st.pop();\n\t\t\tvi a=st.top();st.pop();\n\t\t\tvi r;\n\t\t\trep(i,a.size()) rep(j,b.size()) r.pb((a[i]-b[j]+256)%256);\n\t\t\tsort(all(r));\n\t\t\tr.erase(unique(all(r)),r.end());\n\t\t\tst.push(r);\n\t\t}else if(c==\"*\"){\n\t\t\tvi b=st.top();st.pop();\n\t\t\tvi a=st.top();st.pop();\n\t\t\tvi r;\n\t\t\trep(i,a.size()) rep(j,b.size()) r.pb((a[i]*b[j])%256);\n\t\t\tsort(all(r));\n\t\t\tr.erase(unique(all(r)),r.end());\n\t\t\tst.push(r);\n\t\t}else if(c==\"/\"){\n\t\t\tvi b=st.top();st.pop();\n\t\t\tvi a=st.top();st.pop();\n\t\t\tvi r;\n\t\t\trep(j,b.size()) if(b[j]==0){\n\t\t\t\tcout << \"error\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\trep(i,a.size()) rep(j,b.size()) r.pb((a[i]/b[j])%256);\n\t\t\tsort(all(r));\n\t\t\tr.erase(unique(all(r)),r.end());\n\t\t\tst.push(r);\n\t\t}else if(mp.count(c)){\n\t\t\tst.push(mp[c]);\n\t\t}else{\n\t\t\tst.push(vi(1,stoi(c)));\n\t\t}\n\t}\n\tcout << \"correct\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvoid unq(vi& v)\n{\n\tsort(ALL(v));\n\tauto it = unique(ALL(v));\n\tv.erase(it, v.end());\n}\n\nint main()\n{\n\tint m, n;\n\tunordered_map<string, vi> mp;\n\tcin >> m;\n\tREP(i, m)\n\t{\n\t\tstring c; int a, b; cin >> c >> a >> b;\n\t\tvi v;\n\t\tFOR(i, a, b + 1) v.push_back(i);\n\t\tmp[c] = v;\n\t}\n\tstack<vi> st;\n\tcin >> n;\n\tbool f = true;\n\tREP(i, n)\n\t{\n\t\tstring s; cin >> s;\n\t\tif (s == \"+\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] + a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"-\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] - a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"*\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size()) v.push_back((b[i] * a[j]) % 256);\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (s == \"/\")\n\t\t{\n\t\t\tvi a = st.top(); st.pop();\n\t\t\tvi b = st.top(); st.pop();\n\t\t\tvi v;\n\t\t\tREP(i, b.size())REP(j, a.size())\n\t\t\t{\n\t\t\t\tif (a[j] == 0)\n\t\t\t\t{\n\t\t\t\t\tf = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\telse v.push_back((b[i] / a[j]) % 256);\n\t\t\t}\n\t\t\tunq(v);\n\t\t\tst.push(v);\n\t\t}\n\t\telse if (isalpha(s[0]))\n\t\t{\n\t\t\tst.push(mp[s]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint n = stoi(s);\n\t\t\tvi v = { n };\n\t\t\tst.push(v);\n\t\t}\n\t}\nend:;\n\tputs(f ? \"correct\" : \"error\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef pair<int,int>P;\n#define r(i,n) for(int i=0;i<n;i++)\nmap<string,P>M;\nint m,low,high;\nstring name,s;\nstack<vector<int> >st;\nvoid END(){\n  cout<<\"error\"<<endl;\n  exit(0);\n}\nvoid in_num(){\n  vector<int>v;\n  int res=0;\n  r(i,s.size())res=res*10+(s[i]-'0'),res=res%256;\n  v.push_back(res);\n  st.push(v);\n}\nvoid in_string(){\n  vector<int>v;\n  int t1=M[s].first;\n  int t2=M[s].second;\n  for(int i=t1;i<=t2;i++)v.push_back(i);\n  st.push(v);\n}\nvoid sol1(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]+v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol2(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]-v2[j];\n      t=(t+256)%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol3(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]*v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol4(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      if(v2[j]==0)END();\n      int t=v1[i]/v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nint main(){\n  cin>>m;\n  r(i,m){\n    cin>>name>>low>>high;\n    M[name]=P(low,high);\n  }\n  cin>>m;\n  while(m--){\n    cin>>s;\n    if(isdigit(s[0]))in_num();\n    else if(isalpha(s[0]))in_string();\n    else{\n      if(s==\"+\")sol1();\n      if(s==\"-\")sol2();\n      if(s==\"*\")sol3();\n      if(s==\"/\")sol4();\n    }\n  }\n  cout<<\"correct\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nmap<string, int> id;\nint n, m, l[100], r[100];\n\nint main(){\n\tstring s;\n\tcin >> n;\n\trep(i, n){\n\t\tcin >> s >> l[i] >> r[i];\n\t\tid[s] = i;\n\t}\n\tcin >> m;\n\tvector<vector<bool> >st;\n\twhile(m--){\n\t\tcin >> s;\n\t\tif(id.count(s)){\n\t\t\tvector<bool> v(256);\n\t\t\tfor(int i = l[id[s]]; i <= r[id[s]]; i++) v[i] = 1;\n\t\t\tst.pb(v);\n\t\t}\n\t\telse if(s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\"){\n\t\t\tvector<bool> a, b, v(256);\n\t\t\tb = st.back(); st.pop_back();\n\t\t\ta = st.back(); st.pop_back();\n\t\t\trep(i, 256) if(a[i]) rep(j, 256) if(b[j]){\n\t\t\t\tif(s == \"+\") v[(i + j) % 256] = 1;\n\t\t\t\telse if(s == \"-\") v[(i - j + 256) % 256] = 1;\n\t\t\t\telse if(s == \"*\") v[i * j % 256] = 1;\n\t\t\t\telse{\n\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tv[i / j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.pb(v);\n\t\t}\n\t\telse{\n\t\t\tvector<bool> v(256);\n\t\t\tint i;\n\t\t\tsscanf(s.c_str(), \"%d\", &i);\n\t\t\tv[i] = 1;\n\t\t\tst.pb(v);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 500\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX];\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n    int v = (st.empty() ? MAX-1 : st.top());\n    if (memo[x][v] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res = zero_division_checker(x+1, st);\n            st.pop();\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return (memo[x][v] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 500\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l <= 1 ? MAX-1 : vec[l-2]);\n    int v2 = (l == 0 ? MAX-1 : vec[l-1]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n            \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.find(ele_a) == index.end())\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.find(ele_b) == index.end())\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.find(ele_a) == index.end())\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.find(ele_b) == index.end())\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.find(ele_a) == index.end())\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.find(ele_b) == index.end())\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.find(ele_a) == index.end())\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.find(ele_b) == index.end())\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  \n\t\t  C.insert(((*it_a)/(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <stack>\n#include <stdexcept>\n\nstd::set<int> apply(\n    const std::set<int> &lhs, const std::set<int> &rhs, char op) {\n\n  std::set<int> res;\n  for (int lx: lhs)\n    for (int rx: rhs) {\n      if (op == '+') {\n        res.insert((lx+rx)&255);\n      } else if (op == '-') {\n        res.insert((lx-rx)&255);\n      } else if (op == '*') {\n        res.insert((lx*rx)&255);\n      } else if (op == '/') {\n        if (rx == 0) throw std::logic_error(\"division by zero\");\n        res.insert(lx/rx);\n      }\n    }\n\n  return res;\n}\n\nint main() {\n  size_t m;\n  scanf(\"%zu\", &m);\n\n  std::map<std::string, std::set<int>> vars;\n  for (size_t i=0; i<m; ++i) {\n    char buf[32];\n    int lb, ub;\n    scanf(\"%s %d %d\", buf, &lb, &ub);\n    std::string s=buf;\n    std::set<int> tmp;\n    for (int i=lb; i<=ub; ++i)\n      tmp.insert(i);\n\n    vars[s] = std::move(tmp);\n  }\n\n  size_t n;\n  scanf(\"%zu\", &n);\n  std::stack<std::set<int>> st;\n  for (size_t i=0; i<n; ++i) {\n    char buf[32];\n    scanf(\"%s\", buf);\n    std::string s=buf;\n    if (isdigit(s[0])) {\n      st.push({stoi(s)});\n    } else if (isalpha(s[0])) {\n      st.push(vars.at(s));\n    } else {\n      std::set<int> b=st.top();\n      st.pop();\n      std::set<int> a=st.top();\n      st.pop();\n      try {\n        st.push(apply(a, b, s[0]));\n      } catch (std::logic_error &e) {\n        printf(\"error\\n\");\n        return 0;\n      }\n    }\n  }\n  printf(\"correct\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\nusing namespace std;\n\nint calc(int a, int b, string op){\n    if(op == \"+\") return (a + b) % 256;\n    if(op == \"-\") return (a - b + 256) % 256;\n    if(op == \"*\") return (a * b) % 256;\n    if(op == \"/\") return (a / b) % 256;\n    return -1;\n}\n\nint main(){\n    int m;\n    cin >> m;\n    map<string, bitset<256> > v;\n    for(int i=0; i<m; i++){\n        string name;\n        int lb, ub;\n        cin >> name >> lb >> ub;\n        bitset<256> r;\n        for(int j=lb; j<=ub; j++){\n            r[j] = 1;\n        }\n        v[name] = r;\n    }\n    map<string, bool> number;\n    for(int i=0; i<256; i++){\n        bitset<256> a;\n        a[i] = 1;\n        v[to_string(i)] = a;\n        number[to_string(i)] = true;\n    }   \n\n    int n;\n    cin >> n;\n    stack<string> s;\n    bool success = true;\n    for(int i=0; i<n; i++){\n        string str;\n        cin >> str;\n        if(!success) continue;\n        if(str == \"+\" || str == \"-\" || str == \"*\" || str == \"/\"){\n            string b = s.top();\n            s.pop();\n            string a = s.top();\n            s.pop();\n            if(str == \"/\" && v[b][0]==1){\n                success = false;\n                continue;\n            }\n            if(number.count(a)!=0 && number.count(b)!=0){\n                s.push(to_string(calc(stoi(a), stoi(b), str)));\n            }else{\n                bitset<256> newrange;\n                string newname;\n                if(number.count(a)==0) newname = a;\n                else newname = b;\n                for(int j=0; j<256; j++){\n                    if(v[a][j]==0) continue;\n                    for(int k=0; k<256; k++){\n                        if(v[b][k]==1) newrange[calc(j, k, str)] = 1;\n                    }\n                }\n                v[newname] = newrange;\n                s.push(newname);\n            }\n        }else{\n            s.push(str);\n        }   \n    }\n\n    if(success){\n        cout << \"correct\" << endl;\n    }else{\n        cout << \"error\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef vector<bool> V;\n\nV r2v(int lb, int ub) {\n    V v(256, false);\n    for (int x=lb; x<=ub; x++) {\n        v[x] = true;\n    }\n    return v;\n}\n\nV s2v(string e) {\n    int x = atoi(e.c_str());\n    return r2v(x, x);\n}\n\nbool isnum(string e) {\n    if (e.find_first_not_of(\"1234567890\") != string::npos) {\n        return false;\n    }\n    return true;\n}\n\nV plus_(pair<V, V> operand) {\n    V res = V(256, false);\n    V v1 = operand.first;\n    V v2 = operand.second;\n    for (int x1=0; x1<256; x1++) {\n        if (!v1[x1]) {\n            continue;\n        }\n        for (int x2=0; x2<256; x2++) {\n            if (v2[x2]) {\n                int y = (x1+x2)%256;\n                res[y] = true;\n            }\n        }\n    }\n    return res;\n}\n\nV minus_(pair<V, V> operand) {\n    V res = V(256, false);\n    V v1 = operand.first;\n    V v2 = operand.second;\n    for (int x1=0; x1<256; x1++) {\n        if (!v1[x1]) {\n            continue;\n        }\n        for (int x2=0; x2<256; x2++) {\n            if (v2[x2]) {\n                int y = (x1-x2+256)%256;\n                res[y] = true;\n            }\n        }\n    }\n    return res;\n}\n\nV multiply_(pair<V, V> operand) {\n    V res = V(256, false);\n    V v1 = operand.first;\n    V v2 = operand.second;\n    for (int x1=0; x1<256; x1++) {\n        if (!v1[x1]) {\n            continue;\n        }\n        for (int x2=0; x2<256; x2++) {\n            if (v2[x2]) {\n                int y = (x1*x2)%256;\n                res[y] = true;\n            }\n        }\n    }\n    return res;\n}\n\nV divide_(pair<V, V> operand) {\n    V res = V(256, false);\n    V v1 = operand.first;\n    V v2 = operand.second;\n    if (v2[0]) {\n        return V();\n    }\n    for (int x1=0; x1<256; x1++) {\n        if (!v1[x1]) {\n            continue;\n        }\n        for (int x2=0; x2<256; x2++) {\n            if (v2[x2]) {\n                int y = (x1/x2)%256;\n                res[y] = true;\n            }\n        }\n    }\n    return res;\n}\n\npair<V, V> pull(stack<V> &memory) {\n    V v1, v2;\n\n    v2 = memory.top();\n    memory.pop();\n    v1 = memory.top();\n    memory.pop();\n\n    return pair<V, V>(v1, v2);\n}\n\nint main() {\n    int m, lb, ub, n;\n    string name, e;\n    map<string, V> variable;\n    stack<V> memory;\n    bool is_valid = true;\n\n    cin >> m;\n    for (int i=0; i<m; i++) {\n        cin >> name >> lb >> ub;\n        variable[name] = r2v(lb, ub);\n    }\n    cin >> n;\n    for (int i=0; i<n; i++) {\n        cin >> e;\n        if (isnum(e)) {\n            V v = s2v(e);\n            memory.push(v);\n        }\n        else if (e == \"+\") {\n            memory.push(plus_(pull(memory)));\n        }\n        else if (e == \"-\") {\n            memory.push(minus_(pull(memory)));\n        }\n        else if (e == \"*\") {\n            memory.push(multiply_(pull(memory)));\n        }\n        else if (e == \"/\") {\n            memory.push(divide_(pull(memory)));\n            if (memory.top().size() == 0) {\n                is_valid = false;\n                break;\n            }\n        }\n        else {\n            memory.push(variable[e]);\n            variable.erase(e);\n        }\n    }\n    if (is_valid) {\n        cout << \"correct\" << endl;\n    }\n    else {\n        cout << \"error\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<string,set<int> > mp;\n\nstring random2(){\n\tstring w;\n\tfor(int i = 0 ; i < 100 ; i++)\n\t\tw += rand() % 26 + 'a';\n\treturn w;\n}\n\nstring itos(int n){\n\tstringstream ss;\n\tss << n;\n\treturn ss.str();\n}\nbool inte(string s){\n\treturn '0' <= s[0] && s[0] <= '9';\n}\nbool ope(string s){\n\treturn s == \"+\" || s == \"*\" || s == \"/\" || s == \"-\";\n}\nbool var(string s){\n\treturn !inte(s) && !ope(s);\n}\nset<int> val(string s){\n\tif( inte(s) ) return set<int>{atoi(s.c_str())};\n\treturn mp[s];\n}\nset<int> operator + (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A+B)%256);\n\t\t}\n\t}\n\treturn C;\n}\nset<int> operator / (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A/B)%256);\n\t\t}\n\t}\n\treturn C;\n}\n\nset<int> operator * (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A*B)%256);\n\t\t}\n\t}\n\treturn C;\n}\n\nset<int> operator - (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A-B+256)%256);\n\t\t}\n\t}\n\treturn C;\n}\n\n\n\nbool calc(vector<string> e){\n\tstack<string> s;\n\tfor( int i = 0 ; i < e.size() ; i++){\n\t  if( inte(e[i]) ){\n\t\ts.push(e[i]);\n\t  }\n\t  if( var(e[i]) ){\n\t\ts.push(e[i]);\n\t  }\n\t  if( ope(e[i]) ){\n\t\tstring b = s.top(); s.pop();\n\t\tstring a = s.top(); s.pop();\n\t\tset<int> B = val(b);\n\t\tset<int> A = val(a);\n\t\tset<int> R;\n\t\tif( e[i] == \"+\" ){\n\t\t\tR = A+B;\n\t\t}else if( e[i] == \"-\" ){\n\t\t\tR = A-B;\n\t\t}else if( e[i] == \"*\" ){\n\t\t\tR = A*B;\n\t\t}else if( e[i] == \"/\" ){\n\t\t\tif( B.count(0) ) return 0;\n\t\t\tR = A/B;\n\t\t}\n\t\tstring name = random2();\n\t\tmp[name] = R;\n\t\ts.push(name);\n\t  }\n\t}\n\treturn 1;\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tstring s;\n\t\tint x,y;\n\t\tcin >> s >> x >> y;\n\t\tfor(int j = x ; j <= y ; j++) mp[s].insert(x);\n\t}\n\tint n;\n\tcin >> n;\n\tvector<string> e;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\te.push_back(s);\n\t}\n\tif( calc(e) ){\n\t\tcout << \"correct\" << endl;\n\t}else{\n\t\tcout << \"error\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\nstring zero(256,'0');\nmap<string ,string>ma;\n\nstring ch(string r){\n\tstring t=zero;\n\tt[stoi(r)]='1';\n\treturn t;\n}\nstack<string> st;\n\nstring tasu(string s,string t){\n\tstring f=zero;\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i+j)%256]='1';\n\t}\n\treturn f;\n}\n\nstring hiku(string s,string t){\n\tstring f=zero;\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i-j+256)%256]='1';\n\t}\n\treturn f;\n}\n\nstring kake(string s,string t){\n\tstring f=zero;\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i*j)%256]='1';\n\t}\n\treturn f;\n}\n\nstring waru(string s,string t){\n\tstring f=zero;\n\tif(t[0]=='1'){\n\t\tcout<<\"error\"<<endl;\n\t\texit(0);\n\t}\n\tfor(int i=0;i<256;i++)if(s[i]=='1')for(int j=0;j<256;j++)if(t[j]=='1'){\n\t\tf[(i+j)%256]='1';\n\t}\n\treturn f;\n}\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint m,n;\n \tcin>>m;\n \t\n \tfor(int i=0;i<m;i++){\n \t\tstring t;\n \t\tint y1,y2;\n \t\tcin>>t>>y1>>y2;\n \t\tstring f=zero;\n \t\tfor(int j=y1;j<=y2;j++)f[j]='1';\n \t\tma[t]=f;\n \t}\n \t\n \tcin>>n;\n \t\n \tfor(int i=0;i<n;i++){\n \t\tstring t;\n \t\tcin>>t;\n \t\tif(t==\"+\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(tasu(s1,s2));\n \t\t}\n \t\t\n \t\telse if(t==\"*\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(kake(s1,s2));\n \t\t}\n \t\t\n \t\t\n \t\telse if(t==\"-\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(hiku(s1,s2));\n \t\t}\n \t\t\n \t\telse if(t==\"/\"){\n \t\t\tstring s1,s2;\n \t\t\ts2=st.top();\n \t\t\tst.pop();\n \t\t\ts1=st.top();\n \t\t\tst.pop();\n \t\t\tst.push(waru(s1,s2));\n \t\t}\n \t\telse if(ma.count(t)){\n \t\t\tst.push(ma[t]);\n \t\t}\n \t\telse st.push(ch(t));\n \t}\n \t\n \tcout<<\"correct\"<<endl;\n \treturn 0;\n  }\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nbool is_number(const string &s){\n  REP(i, s.size()) if(!isdigit(s[i])) return false;\n  return true;\n}\n\nint main(){\n  int m, n;\n  string name;\n  map<string, int> L, R;\n  \n  cin >> m;\n  REP(i, m){\n    cin >> name;\n    cin >> L[name] >> R[name];\n  }\n\n  cin >> n;\n\n  stack<vector<int> > st;\n    \n  REP(i, n){\n    string exp;\n    vector<int> vec(256, 0);\n    \n    cin >> exp;\n    \n    if(L.find(exp) != L.end()){\n      for(int i = L[exp]; i <= R[exp]; i++) vec[i] = 1;\n    }else if(is_number(exp)){\n      vec[atoi(exp.c_str())] = 1;\n      \n    }else{\n      vector<int> b = st.top(); st.pop();\n      vector<int> a = st.top(); st.pop();\n\n      REP(i, 256)REP(j, 256)if(a[i] && b[j]){\n        if(exp == \"+\") vec[(a[i]+b[j])%256] = 1;\n        if(exp == \"-\") vec[(a[i]-b[j]+256)%256] = 1;\n        if(exp == \"*\") vec[(a[i]*b[j]) % 256] = 1;\n        if(exp == \"/\"){\n          if(j == 0) {\n            cout << \"error\" << endl;\n            return 0;\n          }\n          vec[a[i]/b[j]] = 1;\n        }\n      }\n    }\n    st.push(vec);\n  }\n\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2435&lang=jp\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint m; cin >> m;\n\tstring op = \"+-/*\";\n\tmap<string, int> name_idx;\n\tvector<pair<int, int>> name(m + 1);\n\tfor (int i = 1; i <= m; i++) {\n\t\tstring _name; int lb, ub;\n\t\tcin >> _name >> lb >> ub;\n\t\tname_idx[_name] = i;\n\t\tname[i].first = lb; name[i].second = ub;\n\t}\n\tint n; cin >> n;\n\tstack<int> st_idx;\n\tvector<vector<int>> st(n, vector<int>(256, 0));\n\tfor (int i = 0; i < n;i++) {\n\t\tstring e; cin >> e;\n\t\t/* +-/* or value */\n\t\tif (name_idx[e] == 0) {\n\t\t\tif (e == \"+\") {\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a + b) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"-\") {\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a - b + 256) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"*\") {\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a*b) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"/\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tif (b == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tst[i][(a / b) % 256] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[i][atoi(e.c_str())] = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tauto pii = name[name_idx[e]];\n\t\t\tfor (int v = pii.first; v <= pii.second;v++) {\n\t\t\t\tst[i][v] = 1;\n\t\t\t}\n\t\t}\n\t\tst_idx.push(i);\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nbool is_number(const string &s){\n  REP(i, s.size()) if(!isdigit(s[i])) return false;\n  return true;\n}\n\nint main(){\n  int m, n;\n  string name;\n  map<string, int> L, R;\n  \n  cin >> m;\n  REP(i, m){\n    cin >> name ;\n    cin >>  L[name] >> R[name];\n  }\n  \n  cin >> n;\n  stack<vector<int> > st;\n    \n  REP(i, n){\n    string exp;\n    vector<int> vec(256, 0);\n    \n    cin >> exp;\n    \n    if(is_number(exp)){\n      vec[atoi(exp.c_str())] = 1;\n    }else if(L.find(exp) != L.end()){\n      for(int i = L[exp]; i <= R[exp]; i++) vec[i] = 1;\n    }else{\n      vector<int> b = st.top(); st.pop();\n      vector<int> a = st.top(); st.pop();\n\n      REP(i, 256)REP(j, 256)if(a[i] && b[j]){\n        \n        if(exp == \"+\") vec[(i+j)%256] = 1;\n        if(exp == \"-\") vec[(i-j+256)%256] = 1;\n        if(exp == \"*\") vec[(i*j)%256] = 1;\n        if(exp == \"/\"){\n          if(j == 0) {\n            cout << \"error\" << endl;\n            return 0;\n          }\n          vec[(i/j)%256] = 1;\n        }\n      }\n    }\n    \n    st.push(vec);\n  }\n\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 1000\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX];\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n    int v = (st.empty() ? n : st.top());\n    if (memo[x][v] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res &= zero_division_checker(x+1, st);\n            st.pop();\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return (memo[x][v] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<map>\n#include<vector>\n#include<stdlib.h>\n#define f first\n#define s second\nusing namespace std;\n\nint main()\n{\n  int m,n,a,b;\n  string s,ans=\"correct\";\n  map<string,pair<int,int> > M;\n  stack<vector<int> > S;\n\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>a>>b;\n    M[s].f=a;\n    M[s].s=b;\n  }\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>s;\n    if(s==\"+\" || s==\"-\" || s==\"*\" || s==\"/\"){\n      vector<int> V1=S.top();S.pop();\n      vector<int> V2=S.top();S.pop();\n      vector<int> V3;\n      bool flag[256];\n      for(int i=0;i<256;i++)flag[i]=false;\n      if(s==\"+\"){\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    int c=(V2[j]+V1[i])%256;\n\t    if(flag[c])continue;\n\t    V3.push_back(c);\n\t    flag[c]=true;\n\t  }\n\t}\n      }\n      else if(s==\"-\"){\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    int c=(V2[j]-V1[i]+256)%256;\n       \t    if(flag[c])continue;\n\t    V3.push_back(c);\n\t    flag[c]=true;\n\t  }\n\t}\n      }\n      else if(s==\"*\"){\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    int c=(V2[j]*V1[i])%256;\n\t    if(flag[c])continue;\n\t    V3.push_back(c);\n\t    flag[c]=true;\n\t  }\n\t}\n      }\n      else {\n\tfor(int i=0;i<V1.size();i++){\n\t  for(int j=0;j<V2.size();j++){\n\t    if(V1[i]==0){\n\t      ans=\"error\";\n\t      break;\n\t    }\n\t    int c=(V2[j]/V1[i])%256;\n\t    if(flag[c])continue;\n\t    V3.push_back(c);\n\t    flag[c]=true;\n\t  }\n\t}\n      }\n      S.push(V3);\n    }\n    else {\n      pair<int,int> p=M[s];\n      vector<int> V;\n      if(p.f!=0 || p.s!=0){\n\tfor(int i=p.f;i<=p.s;i++)V.push_back(i);\n      }\n      else {\n\tV.push_back(atoi(s.c_str()));\n      }\n      S.push(V);\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,P> range;\nstack<set<int> > num;\n\nint getNum(string s){\n  int res=0;\n  for(int i=0;i<s.size();i++)\n    res=res*10+s[i]-'0';\n  return res;\n}\n\nint main(){\n  int n,m,a,b;\n  string s;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>a>>b;\n    range[s]=P(a,b);\n  }\n  bool ans=false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>s;\n    set<int> x;\n    if('0'<=s[0]&&s[0]<='9'){\n      x.insert(getNum(s));\n      num.push(x);\n    }\n    else if('a'<=s[0]&&s[0]<='z'){\n      P r=range[s];\n      for(int j=r.first;j<=r.second;j++)\n\tx.insert(j);\n      num.push(x);\n    }else{\n      set<int> B=num.top(); num.pop();\n      set<int> A=num.top(); num.pop();\n      set<int> C;\n      set<int>::iterator i1=A.begin();\n      while(i1!=A.end()){\n\tset<int>::iterator i2=B.begin();\n\twhile(i2!=B.end()){\n\t  int n1=(*i1),n2=(*i2);\n\t  if(s==\"+\")C.insert((n1+n2)%256);\n\t  if(s==\"-\")C.insert((n1-n2+256)%256);\n\t  if(s==\"*\")C.insert((n1*n2)%256);\n\t  if(s==\"/\"){\n\t    if(!n2){\n\t      ans=true;\n\t      break;\n\t    }\n\t    C.insert((n1/n2)%256);\n\t  }\n\t  i2++;\n\t}\n\tif(ans)break;\n\ti1++;\n      }\n      if(ans)break;\n      num.push(C);\n    }\n  }\n  if(ans)cout<<\"error\"<<endl;\n  else cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) { if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\n\nint main()\n{\n    int m;\n    cin >> m;\n    map<string, vector<int> > var;\n    for (int i = 0; i < m; ++i)\n    {\n        string s;\n        int l, u;\n        cin >> s >> l >> u;\n        for (int j = l; j <= u; ++j)\n            var[s].push_back(j);\n    }\n\n    int n;\n    cin >> n;\n    stack<vector<int> > s;\n    for (int i = 0; i < n; ++i)\n    {\n        string in;\n        cin >> in;\n\n        if (var.count(in))\n        {\n            s.push(var[in]);\n        }\n        else if (isdigit(in[0]))\n        {\n            vector<int> t;\n            t.push_back(to_T<int>(in));\n            s.push(t);\n        }\n        else\n        {\n            vector<int> a, b;\n            b = s.top(); s.pop();\n            a = s.top(); s.pop();\n\n            vector<int> c;\n            for (int i = 0; i < a.size(); ++i)\n            {\n                for (int j = 0; j < b.size(); ++j)\n                {\n                    if (in[0] == '+')\n                        c.push_back((a[i] + b[j]) % 256);\n                    else if (in[0] == '-')\n                        c.push_back((a[i] - b[j] + 256) % 256);\n                    else if (in[0] == '*')\n                        c.push_back((a[i] * b[j]) % 256);\n                    else\n                    {\n                        if (b[j] == 0)\n                        {\n                            cout << \"error\" << endl;\n                            return 0;\n                        }\n\n                        c.push_back((a[i] / b[j]) % 256);\n                    }\n                }\n            }\n\n            sort_unique(c);\n            s.push(c);\n        }\n    }\n\n    cout << \"correct\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint M, N;\nmap<string, pii> m;\n\nsigned main() {\n    cin >> M;\n    rep(i,0,M) {\n        string s; int l, r;\n        cin >> s >> l >> r;\n        m[s] = pii(l, r);\n    }\n\n    cin >> N;\n    stack< vector<int> > st;\n    string pat = \"+-*/\";\n    rep(i,0,N) {\n        string s; cin >> s;\n        vector<int> v(256);\n        if(m.count(s)) {\n            // variable\n            repq(x,m[s].first,m[s].second) v[x] = 1;\n            st.push(v);\n        }\n        else if(s == \"+\") {\n            vector<int> a, b, nx(256);\n            b = st.top(); st.pop();\n            a = st.top(); st.pop();\n            rep(p,0,256) rep(q,0,256) {\n                if(a[p] && b[q]) nx[ (p+q) % 256 ] = 1;\n            }\n            st.push(nx);\n        }\n        else if(s == \"-\") {\n            vector<int> a, b, nx(256);\n            b = st.top(); st.pop();\n            a = st.top(); st.pop();\n            rep(p,0,256) rep(q,0,256) {\n                if(a[p] && b[q]) nx[ (p-q+256) % 256 ] = 1;\n            }\n            st.push(nx);\n        }\n        else if(s == \"*\") {\n            vector<int> a, b, nx(256);\n            b = st.top(); st.pop();\n            a = st.top(); st.pop();\n            rep(p,0,256) rep(q,0,256) {\n                if(a[p] && b[q]) nx[ (p*q) % 256 ] = 1;\n            }\n            st.push(nx);\n        }\n        else if(s == \"/\") {\n            vector<int> a, b, nx(256);\n            b = st.top(); st.pop();\n            a = st.top(); st.pop();\n            rep(p,0,256) rep(q,0,256) {\n                if(a[p] && b[q]) {\n                    // printf(\"p = %lld, q = %lld\\n\", p, q);\n                    if(q == 0) {\n                        cout << \"error\" << endl;\n                        return 0;\n                    }\n                    nx[ (p/q) % 256 ] = 1;\n                }\n            }\n            st.push(nx);\n        }\n        else {\n            // number\n            int val = 0;\n            rep(j,0,s.length()) val = val * 10 + (s[j] - '0');\n            v[val] = 1;\n            st.push(v);\n        }\n    }\n    cout << \"correct\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint main() {\n  int m;\n  while(cin >> m) {\n    map<string, pii> mp;\n    REP(i,m) {\n      string name;\n      cin >> name;\n      int a, b;\n      cin >> a >> b;\n      mp[name] = pii(a,b);\n    }\n    int n;\n    cin >> n;\n    stack<set<int> > stk;\n    int mod = 256;\n    REP(i,n) {\n      string s;\n      cin >> s;\n      if (mp.count(s)) {\n        pii p = mp[s];\n        set<int> se;\n        for (int j=p.first; j<=p.second; ++j) {\n          se.insert(j);\n        }\n        stk.push(se);\n      } else if (s.size() == 1 && !isdigit(s[0])) {\n        assert(stk.size());\n        set<int> b = stk.top();\n        stk.pop();\n        assert(stk.size());\n        set<int> a = stk.top();\n        stk.pop();\n        set<int> se;\n        FOR(it, a) {\n          FOR(jt, b) {\n            if (s==\"+\") se.insert((*it + *jt)%mod);\n            else if (s==\"-\") se.insert((*it - *jt + mod)%mod);\n            else if (s==\"*\") se.insert((*it * *jt) %mod);\n            else {\n              if (*jt == 0) goto error;\n              se.insert(*it / *jt % mod);\n            }\n          }\n        }\n        stk.push(se);\n      } else {\n        set<int> se;\n        se.insert((atoi(s.c_str()) % mod + mod) % mod);\n        stk.push(se);\n      }\n      //FOR(it, stk.top()) cout << *it << \" \";cout << endl;\n    }\n    puts(\"correct\");\n    continue;\n  error:;\n    puts(\"error\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<stdlib.h>\nusing namespace std;\nchar str[100][21];\nint l[100];\nint r[100];\nstruct wolf{\n\tint c[256];\n\twolf(){\n\t\tfor(int i=0;i<256;i++)c[i]=0;\n\t}\n};\nchar p[100][21];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s%d%d\",str[i],l+i,r+i);\n\t}\n\tint b;\n\tscanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%s\",p[i]);\n\t}\n\tstack<wolf> S;\n\tbool ret=false;\n\tfor(int i=0;i<b;i++){\n\t\tbool OK=true;\n\t\tfor(int j=0;p[i][j];j++)if(p[i][j]<'0'||p[i][j]>'9')OK=false;\n\t\tif(OK){\n\t\t\twolf w;\n\t\t\tw.c[atoi(p[i])]=1;\n\t\t\tS.push(w);\n\t\t}else if(p[i][0]!='+'&&p[i][0]!='-'&&p[i][0]!='*'&&p[i][0]!='/'){\n\t\t\twolf w;\n\t\t\tint at=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;str[k][j]||p[i][j];j++)if(str[k][j]!=p[i][j])ok=false;\n\t\t\t\tif(ok)at=k;\n\t\t\t}\n\t\t//\tprintf(\"%d %d\\n\",i,at);\n\t\t\tfor(int i=l[at];i<=r[at];i++)w.c[i]=1;\n\t\t\tS.push(w);\n\t\t}else{\n\t\t\twolf B=S.top();\n\t\t\tS.pop();\n\t\t\twolf A=S.top();\n\t\t\tS.pop();\n\t\t\twolf w;\n\t\t\tif(p[i][0]=='+'){\n\t\t\t\tfor(int k=0;k<256;k++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[k]&&B.c[j])w.c[(k+j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='-'){\n\t\t\t\tfor(int k=0;k<256;k++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[k]&&B.c[j])w.c[(k-j+256)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='*'){\n\t\t\t\tfor(int k=0;k<256;k++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[k]&&B.c[j])w.c[(k*j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='/'){\n\t\t\t\tfor(int k=0;k<256;k++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[k]&&B.c[j]){\n\t\t\t\t\t\t\tif(j==0)ret=true;\n\t\t\t\t\t\t\telse w.c[(k/j)%256]=1;\n\t\t\t\t\t\t}\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t//\tprintf(\"%d: \",i);\n\t\t//\tfor(int i=0;i<230;i++)printf(\"%d\",w.c[i]);\n\t\t//\tprintf(\"\\n\");\n\t\t}\n\t}\n\tif(ret)printf(\"error\\n\");\n\telse printf(\"correct\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct Num{\n\tvector<bool>potes;\n\tNum() :potes(256) {\n\t}\n\tNum(int l, int r):potes(256) {\n\t\tfor (int i = l; i <= r; ++i) {\n\t\t\tpotes[i] = true;\n\t\t}\n\t}\n\tNum operator +(const Num& r) {\n\t\tNum nnum;\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\tif (potes[i] && r.potes[j]) {\n\t\t\t\t\tnnum.potes[(i + j)%256] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nnum;\n\t}\n\tNum operator -(const Num& r) {\n\t\tNum nnum;\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\tif (potes[i] && r.potes[j]) {\n\t\t\t\t\tnnum.potes[(256+ i - j) % 256] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nnum;\n\t}\n\tNum operator *(const Num& r) {\n\t\tNum nnum;\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\tif (potes[i] && r.potes[j]) {\n\t\t\t\t\tnnum.potes[(i * j) % 256] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nnum;\n\t}\n\tNum operator /(const Num& r) {\n\t\tif (r.potes[0]) {\n\t\t\tthrow(0);\n\t\t}\n\t\tNum nnum;\n\t\tfor (int i = 0; i < 256; ++i) {\n\t\t\tfor (int j = 0; j < 256; ++j) {\n\t\t\t\t\n\t\t\t\tif (potes[i] && r.potes[j]) {\n\t\t\t\t\tnnum.potes[(i / j) % 256] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nnum;\n\t}\n};\n\nmap<string, Num>mp;\n\nvoid input() {\n\tvector<Num>stack;\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring ch; cin >> ch;\n\n\t\tif (ch == \"+\"|| ch ==\"-\"|| ch ==\"*\"|| ch ==\"/\") {\n\t\t\tNum b(stack.back());\n\t\t\tstack.pop_back();\n\t\t\tNum a(stack.back());\n\t\t\tstack.pop_back();\n\t\t\tNum next;\n\t\t\tif (ch == \"+\") {\n\t\t\t\tnext = a+b;\n\t\t\t}\n\t\t\tif (ch == \"-\") {\n\t\t\t\tnext =a-b;\n\t\t\t}\n\t\t\tif (ch == \"*\") {\n\t\t\t\tnext =a*b;\n\t\t\t}\n\t\t\tif (ch == \"/\") {\n\t\t\t\tnext = a/b;\n\t\t\t}\n\t\t\tstack.push_back(next);\n\t\t}\n\t\telse if (ch[0] >= '0'&&ch[0] <= '9') {\n\t\t\tint chnum = stoi(ch);\n\t\t\tNum anum(chnum, chnum);\n\t\t\tstack.push_back(anum);\n\t\t}\n\t\telse {\n\t\t\tstack.push_back(mp[ch]);\n\t\t}\n\t}\n}\n\nint main() {\n\tint m; cin >> m;\n\tfor (int i = 0; i < m; ++i) {\n\t\tstring name; int l, r; cin >> name >> l >> r;\n\t\tmp[name] = Num(l, r);\n\t}\n\tbool ok = true;\n\ttry {\n\t\tinput();\n\t}\n\tcatch (...) {\n\t\tok = false;\n\t}\n\tif (ok) {\n\t\tcout << \"correct\" << endl;\n\n\t}\n\telse {\n\t\tcout << \"error\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 256\nusing namespace std;\n\nlong long m, n;\nvector<string> e;\nmap<string, set<int>> mp;\nstack<set<int>> st;\n\nbool solve();\n\nint main() {\n  cin >> m;\n  for(int i = 0; i < m; ++i) {\n    string s;\n    int l, r;\n    cin >> s >> l >> r;\n    for(int i = l; i <= r; ++i) mp[s].insert(i);\n  }\n  cin >> n;\n  e.resize(n);\n  for(int i = 0; i < n; ++i) cin >> e[i];\n  if(solve())\n    cout << \"correct\" << endl;\n  else\n    cout << \"error\" << endl;\n  return 0;\n}\n\nbool solve() {\n  for(int i = 0; i < n; ++i) {\n    set<int> a, b, c;\n    if(e[i] == \"+\") {\n      b = st.top();\n      st.pop();\n      a = st.top();\n      st.pop();\n      for(int x : a)\n        for(int y : b) c.insert((x + y) % MOD);\n      st.push(c);\n    }\n    else if(e[i] == \"-\") {\n      b = st.top();\n      st.pop();\n      a = st.top();\n      st.pop();\n      for(int x : a)\n        for(int y : b) c.insert((x - y + MOD) % MOD);\n      st.push(c);\n    }\n    else if(e[i] == \"*\") {\n      b = st.top();\n      st.pop();\n      a = st.top();\n      st.pop();\n      for(int x : a)\n        for(int y : b) c.insert((x * y) % MOD);\n      st.push(c);\n    }\n    else if(e[i] == \"/\") {\n      b = st.top();\n      st.pop();\n      a = st.top();\n      st.pop();\n      for(int x : a)\n        for(int y : b) {\n          if(y == 0) return 0;\n          c.insert((x / y) % MOD);\n        }\n      st.push(c);\n    }\n    else if(isdigit(e[i][0])) {\n      a.insert(stoi(e[i]) % MOD);\n      st.push(a);\n    }\n    else\n      st.push(mp[e[i]]);\n  }\n  return 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<stdlib.h>\nusing namespace std;\nchar str[100][21];\nint l[100];\nint r[100];\nstruct wolf{\n\tint c[256];\n\twolf(){\n\t\tfor(int i=0;i<256;i++)c[i]=0;\n\t}\n};\nchar p[100][21];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s%d%d\",str[i],l+i,r+i);\n\t}\n\tint b;\n\tscanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%s\",p[i]);\n\t}\n\tstack<wolf> S;\n\tbool ret=false;\n\tfor(int i=0;i<b;i++){\n\t\tbool OK=true;\n\t\tfor(int j=0;p[i][j];j++)if(p[i][j]<'0'||p[i][j]>'9')OK=false;\n\t\tif(OK){\n\t\t\twolf w;\n\t\t\tw.c[atoi(p[i])]=1;\n\t\t\tS.push(w);\n\t\t}else if(p[i][0]!='+'&&p[i][0]!='-'&&p[i][0]!='*'&&p[i][0]!='/'){\n\t\t\twolf w;\n\t\t\tint at=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;str[k][j]||p[i][j];j++)ok=false;\n\t\t\t\tif(ok)at=k;\n\t\t\t}\n\t\t\tfor(int i=l[at];i<=r[at];i++)w.c[i]=1;\n\t\t\tS.push(w);\n\t\t}else{\n\t\t\twolf B=S.top();\n\t\t\tS.pop();\n\t\t\twolf A=S.top();\n\t\t\tS.pop();\n\t\t\tif(p[i][0]=='+'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i+j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='-'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i-j+256)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='*'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i*j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='/'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j]){\n\t\t\t\t\t\t\tif(j==0)ret=true;\n\t\t\t\t\t\t\telse w.c[(i/j)%256]=1;\n\t\t\t\t\t\t}\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t}\n\t}\n\tif(ret)printf(\"error\\n\");\n\telse printf(\"correct\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    int m, n;\n    cin >> m;\n    map<string, bitset<256>> mp;\n    for (int i = 0; i < m; ++i) {\n        string s;\n        int l, r;\n        cin >> s >> l >> r;\n        bitset<256> bs;\n        for (int j = l; j <= r; ++j)\n            bs.set(j);\n\n        mp[s] = bs;\n    }\n    for (int i = 0; i < 256; ++i) {\n        bitset<256> bs;\n        bs.set(i);\n        mp[to_string(i)] = bs;\n    }\n    cin >> n;\n    stack<bitset<256>> st;\n    for (int i = 0; i < n; ++i) {\n        string s;\n        cin >> s;\n        switch (s[0]) {\n            case '+':\n            case '-':\n            case '*':\n            case '/':\n            {\n                bitset<256> b = st.top();\n                st.pop();\n                if (s[0] == '/' && b[0]) {\n                    puts(\"error\");\n                    return 0;\n                }\n                bitset<256> a = st.top();\n                st.pop();\n                bitset<256> bs;\n                for (int i = 0; i < 256; ++i) {\n                    if (!a[i]) continue;\n                    for (int j = 0; j < 256; ++j) {\n                        if (!b[j]) continue;\n                        switch (s[0]) {\n                            case '+':\n                                bs.set((i + j) % 256);\n                                break;\n                            case '-':\n                                bs.set((i - j + 256) % 256);\n                                break;\n                            case '*':\n                                bs.set((i * j) % 256);\n                                break;\n                            case '/':\n                                bs.set((i / j) % 256);\n                                break;\n                        }\n                    }\n                }\n                st.push(bs);\n                break;\n            }\n            default:\n                st.push(mp[s]);\n                break;\n        }\n    }\n    puts(\"correct\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\n \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(double)(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,P> range;\nstack<set<int> > num;\n\nint getNum(string s){\n  int res=0;\n  for(int i=0;i<s.size();i++)\n    res=res*10+s[i]-'0';\n  return res;\n}\n\nint main(){\n  int n,m,a,b;\n  string s;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>a>>b;\n    range[s]=P(a,b);\n  }\n  bool ans=false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>s;\n    set<int> x;\n    if('0'<=s[0]&&s[0]<='9'){\n      x.insert(getNum(s));\n      num.push(x);\n    }\n    else if('a'<=s[0]&&s[0]<='z'){\n      P r=range[s];\n      for(int j=r.first;j<=r.second;j++)\n\tx.insert(j);\n      num.push(x);\n    }else{\n      set<int> B=num.top(); num.pop();\n      set<int> A=num.top(); num.pop();\n      set<int> C;\n      set<int>::iterator i1=A.begin();\n      set<int>::iterator i2=B.begin();\n      while(i1!=A.end()){\n\twhile(i2!=B.end()){\n\t  int n1=(*i1),n2=(*i2);\n\t  if(s[0]=='+')C.insert((n1+n2)%256);\n\t  if(s[0]=='-')C.insert((n1-n2+256)%256);\n\t  if(s[0]=='*')C.insert((n1*n2)%256);\n\t  if(s[0]=='/'){\n\t    if(!n2){\n\t      ans=true;\n\t      break;\n\t    }\n\t    C.insert((n1/n2)%256);\n\t  }\n\t  i2++;\n\t}\n\tif(ans)break;\n\ti1++;\n      }\n      if(ans)break;\n      num.push(C);\n    }\n  }\n  if(ans)cout<<\"error\"<<endl;\n  else cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nset<int> calc(set<int> a,set<int> b,string op)\n{\n\tset<int> s;\n\tfor(int x:a) for(int y:b){\n\t\tint z;\n\t\tswitch(op[0]){\n\t\tcase '*': z=x*y; break;\n\t\tcase '+': z=x+y; break;\n\t\tcase '-': z=x-y; break;\n\t\tcase '/': if(y==0) throw \"error\"; else z=x/y;\n\t\t}\n\t\twhile(z<0) z+=256;\n\t\twhile(z>=256) z-=256;\n\t\ts.insert(z);\n\t}\n\treturn s;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tmap<string,pii> ntor; // name -> range\n\t\trep(i,n){\n\t\t\tstring s; int a,b; cin>>s>>a>>b;\n\t\t\tntor[s]=mp(a,b);\n\t\t}\n\t\tint m; cin>>m;\n\t\tvs ts(m);\n\t\trep(i,m) cin>>ts[i];\n\t\t\n\t\ttry{\n\t\t\tdeque<set<int>> st;\n\t\t\tfor(string t:ts){\n\t\t\t\tif(t==\"*\" || t==\"+\" || t==\"-\" || t==\"/\"){\n\t\t\t\t\tset<int> a=st[1],b=st[0]; st.erase(begin(st),begin(st)+2);\n\t\t\t\t\tst.push_front(calc(a,b,t));\n\t\t\t\t}\n\t\t\t\telse if(isdigit(t[0])){\n\t\t\t\t\tset<int> s; s.insert(atoi(t.c_str()));\n\t\t\t\t\tst.push_front(s);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tpii r=ntor[t];\n\t\t\t\t\tset<int> s;\n\t\t\t\t\trepi(i,r.first,r.second+1) s.insert(i);\n\t\t\t\t\tst.push_front(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<\"correct\"<<endl;\n\t\t}\n\t\tcatch(...){\n\t\t\tcout<<\"error\"<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n  int m;\n  cin>>m;\n  map<string,bitset<256>> val;\n  REP(i,m) {\n    string name;\n    int minv, maxv;\n    cin>>name>>minv>>maxv;\n    bitset<256> bs;\n    REP(j,256)\n      bs[j] = false;\n    FOR(j,minv,maxv+1)\n      bs[j] = true;\n    val[name] = bs;\n  }\n  stack<bitset<256>> stk;\n  int n;\n  cin>>n;\n  bool flag = false;\n  REP(i,n) {\n    string str;\n    cin>>str;\n    if(val.find(str) != val.end())\n      stk.push(val[str]);\n    else if(str == \"/\") {\n      if(stk.top()[0]) {\n        flag = true;\n        break;\n      }else{\n        bitset<256> bs,lhs,rhs;\n        REP(j,256)bs[j] = false;\n        rhs = stk.top();stk.pop();\n        lhs = stk.top();stk.pop();\n        REP(j,256)REP(k,256) {\n          if(lhs[j] && rhs[k])\n          bs[(j/k)%256] = true;\n        }\n        stk.push(bs);\n      }\n    }else if(str == \"*\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j*k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"+\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j+k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"-\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(256+j-k)%256] = true;\n      }\n      stk.push(bs);\n    } else {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      bs[atoi(str.c_str())] = true;\n      stk.push(bs);\n    }\n  }\n  if(flag)\n    cout<<\"error\"<<endl;\n  else\n    cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <map>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nstruct elem{\n    bool isPossible[256];\n    elem(){\n        fill(isPossible,isPossible+256,false);\n    }\n    elem(int lb,int ub){\n        fill(isPossible,isPossible+256,false);\n        for(int i=lb;i<=ub;i++)isPossible[i]=true;\n    }\n};\n\nint main(){\n    int m;\n    cin>>m;\n    map<string,elem> M;\n    for(int i=0;i<m;i++){\n        string name;\n        int lb,ub;\n        cin>>name>>lb>>ub;\n        M[name]=elem(lb,ub);\n    }\n    int n;\n    cin>>n;\n    stack<elem, vector<elem>> S;\n    for(int i=0;i<n;i++){\n        string str;\n        cin>>str;\n        stringstream ss(str);\n        if('0'<=str[0]&&str[0]<='9'){\n            int val;\n            ss>>val;\n            S.emplace(val,val);\n            continue;\n        }\n        if(str[0]=='+'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=0;b<256;b++){\n                    C.isPossible[(uint8_t)(a+b)]=B.isPossible[b];\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        if(str[0]=='-'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=0;b<256;b++){\n                    C.isPossible[(uint8_t)(a-b)]=B.isPossible[b];\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        if(str[0]=='*'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=0;b<256;b++){\n                    C.isPossible[(uint8_t)(a*b)]=B.isPossible[b];\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        if(str[0]=='/'){\n            elem B=S.top();S.pop();\n            elem A=S.top();S.pop();\n            if(B.isPossible[0]){\n                cout<<\"error\"<<endl;\n                return 0;\n            }\n            elem C;\n            for(int a=0;a<256;a++){\n                if(A.isPossible[a]==false) continue;\n                for(int b=1;b<256;b++){\n                    C.isPossible[(uint8_t)a/(uint8_t)b]=B.isPossible[b];\n                }\n            }\n            S.push(C);\n            continue;\n        }\n        S.push(M[str]);\n    }\n    cout<<\"correct\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nbool num[128][256];\nint m, n;\nmap<string,pair<int,int> > bound;\nstring op = \"+-*/\";\n\nint main()\n{\n    memset(num,0,sizeof(num));\n    cin >> m;\n    rep(i,m){\n\tstring name;\n\tint lb, ub;\n\tcin >> name >> lb >> ub;\n\tbound[name] = mp(lb,ub);\n    }    \n    cin >> n;\n    stack<int> st;\n    rep(i,n){\n\tstring e;\n\tcin >> e;\n\tif(op.find(e) == string::npos){\n\t    st.push(i);\n\t    if(bound.find(e) != bound.end())\n\t\tfor(int j = bound[e].first; j <= bound[e].second; j++)\n\t\t    num[i][j] = true;\n\t    else\n\t\tnum[i][atoi(e.c_str()) & 255] = true;\n\t}else{\n\t    int b = st.top(); st.pop();\n\t    int a = st.top(); st.pop();\n\t    if(e == \"+\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j + k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"-\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j - k + 256) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"*\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j * k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"/\"){\n\t\tif(num[b][0]) {\n\t\t    cout << \"error\\n\";\n\t\t    return 0;\n\t\t}\n\t\trep(j,256)repi(k,1,256){\n\t\t    num[i][(j / k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t}\n\tst.push(i);\n    }\n    cout << \"correct\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\n\nint main() {\n  int n;\n  cin >> n;\n  map<string,P> ma;\n  for(int i=0; i<n; i++) {\n    string s;\n    cin >> s;\n    cin >> ma[s].F >> ma[s].S;\n  }\n  stack<vector<int> > st;\n  cin >> n;\n  while(n--) {\n    string t;\n    cin >> t;\n    if(isalpha(t[0])) {\n      vector<int> a(256);\n      for(int i=ma[t].F; i<=ma[t].S; i++) a[i]=1;\n      st.push(a);\n    } else if(isdigit(t[0])) {\n      stringstream ss;\n      int x;\n      ss << t;\n      ss >> x;\n      x%=256;\n      vector<int> a(256);\n      a[x]=1;\n      st.push(a);\n    } else {\n      vector<int> b=st.top();st.pop();\n      vector<int> a=st.top();st.pop();\n      vector<int> c(256);\n      for(int i=0; i<256; i++) {\n        for(int j=0; j<256; j++) {\n          if(!a[i]||!b[j]) continue;\n          if(t==\"+\") c[(i+j)%256]=1;\n          else if(t==\"-\") c[(i-j+256)%256]=1;\n          else if(t==\"*\") c[(i*j)%256]=1;\n          else {\n            if(!j) {\n              cout << \"error\" << endl;\n              return 0;\n            }\n            c[(i/j)%256]=1;\n          }\n        }\n      }\n      st.push(c);\n    }\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  time_t start=clock();\n  srand(unsigned(time));\n  while(((double)(clock()-start)/CLOCKS_PER_SEC)<1.7&&!f){\n    stack<uc> sc;\n    for(int i=0;!f&&i<n;i++){\n      //cout<<i<<\":\"<<ss[i]<<endl;\n      if(ms.find(ss[i])!=ms.end()){ \n\tint j=ms[ss[i]],k=(l[j]+(rand()%(r[j]-l[j])));\n\t//cout<<ss[i]<<\":\"<<k<<endl;\n\tsc.push(k);\n      }else if(isdigit(ss[i][0])){\n\tuc a=0;\n\tfor(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n\tsc.push(a);\n      }else{\n\tuc a,b;\n\tb=sc.top();sc.pop();\n\ta=sc.top();sc.pop();\n\tif(ss[i]==\"+\") sc.push(a+b);\n\tif(ss[i]==\"-\") sc.push(a-b);\n\tif(ss[i]==\"*\") sc.push(a*b);\n\tif(ss[i]==\"/\"){\n\t  if(b) sc.push(a/b);\n\t  else{\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n#include<array>\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n\ntypedef long long ll;\nmap<string,array<int,256> >data;\nconst int INF=1e9+7;\nint main(){\n\tint m;\n\tbool f=true;\n\tcin>>m;\n\trep(i,m){\n\t\tstring str;\n\t\tcin>>str;\n\t\tint l,u;\n\t\tcin>>l>>u;\n\t\tFOR(i,l,u+1){\n\t\t\tdata[str][i]=1;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tstack<array<int,256> > st;\n\trep(l,n){\n\t\tstring str;\n\t\tcin>>str;\n\t\tif(str==\"0\" || atoi(str.c_str())>0){\n\t\t\tint num=atoi(str.c_str());\n\t\t\tarray<int,256>num_a;\n\t\t\trep(i,256)num_a[i]=0;\n\t\t\tnum_a[num]=1;\n\t\t\tst.push(num_a);\n\t\t}\n\t\telse if(str==\"+\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i+j)%256]|=(r[i]&l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"-\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i-j+256)%256]|=(r[i]&l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"*\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256)rep(j,256)ne[(i*j)%256]|=(r[i]&l[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"/\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\tif(r[0]==1)f=false;\n\t\t\trep(i,256)FOR(j,1,256)ne[(i/j)%256]|=(r[i]&l[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse {\n\t\t\tst.push(data[str]);\n\t\t}\n\t}\n\tif(f)cout<<\"correct\"<<endl;\n\telse cout<<\"error\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  \n\t\t  C.insert(((int)ceil((double)(*it_a)/(double)(*it_b)))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nbool isCorrect();\n\nint main()\n{\n\tif (isCorrect()) puts(\"correct\");\n\telse puts(\"error\");\n\n\treturn 0;\n}\n\nbool isCorrect()\n{\n\tconstexpr int mod{1 << 8};\n\tstd::map<std::string, std::pair<int, int>> lub;\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i{}; i < m; i++)\n\t{\n\t\tstd::string name;\n\t\tint lb, ub;\n\t\tstd::cin >> name >> lb >> ub;\n\t\tlub[name] = {lb, ub};\n\t}\n\tusing i8b = std::array<bool, mod>;\n\tstd::stack<i8b> st;\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i{}; i < n; i++)\n\t{\n\t\tstd::string expression;\n\t\tstd::cin >> expression;\n\t\tint size{(int)expression.size()};\n\t\tif (isdigit(expression.front()))\n\t\t{\n\t\t\tint num{std::stoi(expression)};\n\t\t\ti8b tmp{};\n\t\t\ttmp[num] = true;\n\t\t\tst.push(tmp);\n\t\t}\n\t\telse if (size == 1 && expression.front() == '+')\n\t\t{\n\t\t\ti8b next{};\n\t\t\ti8b rhs{st.top()};\n\t\t\tst.pop();\n\t\t\ti8b lhs{st.top()};\n\t\t\tst.pop();\n\t\t\tfor (int i{}; i < mod; i++)\n\t\t\t{\n\t\t\t\tif (!lhs[i]) continue;\n\t\t\t\tfor (int j{}; j < mod; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!rhs[j]) continue;\n\t\t\t\t\tnext[(i + j) % mod] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(next);\n\t\t}\n\t\telse if (size == 1 && expression.front() == '-')\n\t\t{\n\t\t\ti8b next{};\n\t\t\ti8b rhs{st.top()};\n\t\t\tst.pop();\n\t\t\ti8b lhs{st.top()};\n\t\t\tst.pop();\n\t\t\tfor (int i{}; i < mod; i++)\n\t\t\t{\n\t\t\t\tif (!lhs[i]) continue;\n\t\t\t\tfor (int j{}; j < mod; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!rhs[j]) continue;\n\t\t\t\t\tnext[(i - j + mod) % mod] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(next);\n\t\t}\n\t\telse if (size == 1 && expression.front() == '*')\n\t\t{\n\t\t\ti8b next{};\n\t\t\ti8b rhs{st.top()};\n\t\t\tst.pop();\n\t\t\ti8b lhs{st.top()};\n\t\t\tst.pop();\n\t\t\tfor (int i{}; i < mod; i++)\n\t\t\t{\n\t\t\t\tif (!lhs[i]) continue;\n\t\t\t\tfor (int j{}; j < mod; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!rhs[j]) continue;\n\t\t\t\t\tnext[(i * j) % mod] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(next);\n\t\t}\n\t\telse if (size == 1 && expression.front() == '/')\n\t\t{\n\t\t\ti8b next{};\n\t\t\ti8b rhs{st.top()};\n\t\t\tst.pop();\n\t\t\ti8b lhs{st.top()};\n\t\t\tst.pop();\n\t\t\tif (rhs[0]) return false;\n\t\t\tfor (int i{}; i < mod; i++)\n\t\t\t{\n\t\t\t\tif (!lhs[i]) continue;\n\t\t\t\tfor (int j{}; j < mod; j++)\n\t\t\t\t{\n\t\t\t\t\tif (!rhs[j]) continue;\n\t\t\t\t\tnext[i / j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(next);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti8b next{};\n\t\t\tint lb{lub[expression].first}, ub{lub[expression].second};\n\t\t\tfor (int i{lb}; i <= ub; i++)\n\t\t\t\tnext[i] = true;\n\t\t\tst.push(next);\n\t\t}\n\t}\n\treturn true;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l == 0 ? MAX-1 : vec[l-1]);\n    int v2 = (l == 0 ? MAX-1 : vec[0]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n            \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nrandom_device rnd;\nmt19937 mt(rnd());\n\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1e9 + 7;\nint main()\n{\n    map<string, vector<bool>> mp;\n    int m;\n    cin >> m;\n    rep(i, m)\n    {\n        string c;\n        cin >> c;\n        int a, b;\n        cin >> a >> b;\n        mp[c] = vector<bool>(256, false);\n        rep(j, a, b + 1)\n        {\n            mp[c][j] = true;\n        }\n    }\n    int n;\n    cin >> n;\n    vector<string> e(n);\n    rep(i, n)\n    {\n        cin >> e[i];\n    }\n    vector<vector<bool>> st;\n    for (auto &&token : e)\n    {\n        if (isdigit(token[0]))\n        {\n            int num = atoi(token.c_str());\n            vector<bool> p(256, false);\n            p[num] = true;\n            st.push_back(p);\n        }\n        else\n        {\n            if (token == \"+\")\n            {\n                vector<bool> b = st.back();\n                st.pop_back();\n                vector<bool> a = st.back();\n                st.pop_back();\n                vector<bool> c(256, false);\n                rep(i, 256)\n                {\n                    rep(j, 256)\n                    {\n                        if (a[i] && b[j])\n                        {\n                            c[(i + j) % 256] = true;\n                        }\n                    }\n                }\n                st.push_back(c);\n            }\n            else if (token == \"-\")\n            {\n                vector<bool> b = st.back();\n                st.pop_back();\n                vector<bool> a = st.back();\n                st.pop_back();\n                vector<bool> c(256, false);\n                rep(i, 256)\n                {\n                    rep(j, 256)\n                    {\n                        if (a[i] && b[j])\n                        {\n                            c[(i - j + 256) % 256] = true;\n                        }\n                    }\n                }\n                st.push_back(c);\n            }\n            else if (token == \"/\")\n            {\n                vector<bool> b = st.back();\n                st.pop_back();\n                vector<bool> a = st.back();\n                st.pop_back();\n                vector<bool> c(256, false);\n\n                rep(i, 256)\n                {\n                    rep(j, 256)\n                    {\n                        if (a[i] && b[j])\n                        {\n                            if (j == 0)\n                            {\n                                cout << \"error\" << endl;\n                                return 0;\n                            }\n                            c[i / j] = true;\n                        }\n                    }\n                }\n                st.push_back(c);\n            }\n            else if (token == \"*\")\n            {\n                vector<bool> b = st.back();\n                st.pop_back();\n                vector<bool> a = st.back();\n                st.pop_back();\n                vector<bool> c(256, false);\n\n                rep(i, 256)\n                {\n                    rep(j, 256)\n                    {\n                        if (a[i] && b[j])\n                        {\n                            c[(i * j) % 256] = true;\n                        }\n                    }\n                }\n                st.push_back(c);\n            }\n            else\n            {\n                st.push_back(mp[token]);\n            }\n        }\n    }\n    cout << \"correct\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <iostream>\n#include <stack>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing namespace std;\n\nint main() {\n    // input\n    int m; cin >> m;\n    vector<string> name(m);\n    vector<int> l(m), r(m); // [l, r]\n    repeat (i, m) {\n        cin >> name[i] >> l[i] >> r[i];\n    }\n    int n; cin >> n;\n    vector<string> es(n);\n    repeat (i, n) {\n        cin >> es[i];\n    }\n    // solve\n    bool result = true;\n    stack<bitset<256> > stk;\n    for (string e : es) {\n        if (isdigit(e[0])) {\n            bitset<256> num = {};\n            num[stoi(e)] = true;\n            stk.push(num);\n        } else if (isalpha(e[0])) {\n            int i = whole(find, name, e) - name.begin();\n            bitset<256> var = {};\n            repeat_from (j, l[i], r[i] + 1) {\n                var[j] = true;\n            }\n            stk.push(var);\n        } else {\n            bitset<256> b = stk.top(); stk.pop();\n            bitset<256> a = stk.top(); stk.pop();\n            if (e == \"/\" and b[0]) {\n                result = false;\n                break;\n            }\n            bitset<256> c = {};\n            repeat (i, 256) if (a[i]) {\n                repeat (j, 256) if (b[j]) {\n                    if (e == \"+\") {\n                        c[(i + j) % 256] = true;\n                    } else if (e == \"-\") {\n                        c[(i - j + 256) % 256] = true;\n                    } else if (e == \"*\") {\n                        c[i * j % 256] = true;\n                    } else if (e == \"/\") {\n                        c[i / j] = true;\n                    }\n                }\n            }\n            stk.push(c);\n        }\n    }\n    // output\n    cout << (result ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n#include<array>\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n\ntypedef long long ll;\nmap<string,array<int,256> >data;\nconst int INF=1e9+7;\nint main(){\n\tint m;\n\tbool f=true;\n\tcin>>m;\n\trep(i,m){\n\t\tstring str;\n\t\tcin>>str;\n\t\tint l,u;\n\t\tcin>>l>>u;\n\t\tFOR(i,l,u+1){\n\t\t\tdata[str][i]=1;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tstack<array<int,256> > st;\n\trep(l,n){\n\t\tstring str;\n\t\tcin>>str;\n\t\tif(str==\"0\" || atoi(str.c_str())>0){\n\t\t\tint num=atoi(str.c_str());\n\t\t\tarray<int,256>num_a;\n\t\t\trep(i,256)num_a[i]=0;\n\t\t\tnum_a[num]=1;\n\t\t\tst.push(num_a);\n\t\t}\n\t\telse if(str==\"+\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i+j)%256]|=(r[i]&l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"-\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i-j+256)%256]|=(r[i]&l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"*\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256)rep(j,256)ne[(i*j)%256]|=(r[i]&l[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"/\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\tif(r[0]==1)f=false;\n\t\t\trep(i,256)FOR(j,1,256)ne[(i/j)%256]|=(r[i]&l[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse {\n\t\t\tst.push(data[str]);\n\t\t}\n\t}\n\tif(f)cout<<\"correct\"<<endl;\n\telse cout<<\"error\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nbool solve(vector<string> &ops, map<string, P> &vs){\n  vector< vector<int> > v;\n  for(string s : ops){\n    vector<int> tmp;\n    if(vs.find(s) != vs.end()) FOR(i, vs[s].first, vs[s].second + 1) tmp.push_back(i);\n    else if(isdigit(s[0])) tmp.push_back(atoi(s.c_str()));\n    else if(s == \"+\") {\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x + y;\n          while(n >= 256) n -= 256;\n          tmp.push_back(n);\n        }\n      }\n    } else if(s == \"-\"){\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x - y;\n          while(n < 0) n += 256;\n          tmp.push_back(n);\n        }\n      }\n    } else if(s == \"*\"){\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x * y;\n          while(n >= 256) n -= 256;\n          tmp.push_back(n);\n        }\n      }\n    } else if(s == \"/\"){\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          if(y == 0) return false;\n          int n = x / y;\n          while(n >= 256) n -= 256;\n          tmp.push_back(n);\n        }\n      }\n    }\n    v.push_back(tmp);\n  }\n  return true;\n}\n\nint main() {\n  int M; cin >>M;\n  map<string, P> vs;\n  REP(i, M){\n    string s; cin >>s;\n    int l, u; cin >>l >>u;\n    vs[s] = P(l, u);\n  }\n  int N; cin >>N;\n  vector<string> ops(N);\n  REP(i, N) cin >>ops[i];\n  cout <<(solve(ops, vs) ? \"correct\" : \"error\")  <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n\nsigned main() {\n  int m;\n  cin >> m;\n  map<string, pair<int, int>> range;\n  rep(i, m) {\n    string name;\n    int lb, ub;\n    cin >> name >> lb >> ub;\n    range[name] = {lb, ub};\n  }\n  int n;\n  cin >> n;\n  vector<string> es(n);\n  rep(i, n) cin >> es[i];\n  stack<bitset<256>> sets;\n  for (auto &&e : es) {\n    bitset<256> top;\n    if (isdigit(e[0])) {\n      top[stoi(e)] = true;\n    } else if (isalpha(e[0])) {\n      loop(i, range[e].first, range[e].second + 1) top[i] = true;\n    } else {\n      bitset<256> y = sets.top();\n      sets.pop();\n      bitset<256> x = sets.top();\n      sets.pop();\n      rep(i, 256) rep(j, 256) if (x[i] && y[j]) {\n        if (e == \"+\") top[(i + j) % 256] = true;\n        if (e == \"-\") top[(i - j + 256) % 256] = true;\n        if (e == \"*\") top[(i * j) % 256] = true;\n        if (e == \"/\") {\n          if (j == 0) return cout << \"error\" << endl, 0;\n          top[(i / j) % 256] = true;\n        }\n      }\n    }\n    sets.emplace(top);\n  }\n  cout << \"correct\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nmap<string, int> id;\nint n, m, l[100], r[100];\n\nint main(){\n\tstring s;\n\tcin >> n;\n\trep(i, n){\n\t\tcin >> s >> l[i] >> r[i];\n\t\tid[s] = i;\n\t}\n\tcin >> m;\n\tvector<vector<bool> >st;\n\twhile(m--){\n\t\tcin >> s;\n\t\tif(id.count(s)){\n\t\t\tvector<bool> v(256);\n\t\t\tfor(int i = l[id[s]]; i <= r[id[s]]; i++) v[i] = 1;\n\t\t\tst.pb(v);\n\t\t}\n\t\telse if(s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\"){\n\t\t\tvector<bool> a, b, v(256);\n\t\t\tb = st.back(); st.pop_back();\n\t\t\ta = st.back(); st.pop_back();\n\t\t\trep(i, 256) if(a[i]) rep(j, 256) if(b[i]){\n\t\t\t\tif(s == \"+\") v[(i + j) % 256] = 1;\n\t\t\t\telse if(s == \"-\") v[(i - j + 256) % 256] = 1;\n\t\t\t\telse if(s == \"*\") v[i * j % 256] = 1;\n\t\t\t\telse{\n\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tv[i / j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.pb(v);\n\t\t}\n\t\telse{\n\t\t\tvector<bool> v(256);\n\t\t\tint i;\n\t\t\tsscanf(s.c_str(), \"%d\", &i);\n\t\t\tv[i] = 1;\n\t\t\tst.pb(v);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n       \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(double)(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <string>\n#include <utility>\n#include <stack>\n#include <stdlib.h>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct range{\n\tbool a[256];\n\trange(){\n\t\tfor(int i = 0; i < 256; i++) a[i] = false;\n\t}\n\trange(int v){\n\t\tfor(int i = 0; i < 256; i++) a[i] = (v == i);\n\t}\n\trange(int u, int v){\n\t\tfor(int i = 0; i < 256; i++) a[i] = (i >= u && i <= v);\n\t}\n\trange operator+(const range& ope){\n\t\trange ret;\n\t\tfor(int i = 0; i < 256; i++){\n\t\t\tfor(int j = 0; j < 256; j++){\n\t\t\t\tif(this->a[i] && ope.a[j]) ret.a[(i+j)%256] = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\trange operator-(const range& ope){\n\t\trange ret;\n\t\tfor(int i = 0; i < 256; i++){\n\t\t\tfor(int j = 0; j < 256; j++){\n\t\t\t\tif(this->a[i] && ope.a[j]) ret.a[(i+256-j)%256] = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\trange operator*(const range& ope){\n\t\trange ret;\n\t\tfor(int i = 0; i < 256; i++){\n\t\t\tfor(int j = 0; j < 256; j++){\n\t\t\t\tif(this->a[i] && ope.a[j]) ret.a[(i*j)%256] = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\trange operator/(const range& ope){\n\t\trange ret;\n\t\tfor(int i = 0; i < 256; i++){\n\t\t\tfor(int j = 0; j < 256; j++){\n\t\t\t\tif(this->a[i] && ope.a[j]) ret.a[(i/j)%256] = true;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n};\n\nint m, n;\nmap<string, range> mp;\nstack<range> stk;\n\nint main(void)\n{\n\tcin >> m;\n\t\n\trange tmp;\n\tstring name; int lb, ub;\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> name >> lb >> ub;\n\t\tfor(int j = 0; j < 256; j++){\n\t\t\tmp[name] = range(lb, ub);\n\t\t}\n\t}\n\t\n\tstring s;\n\trange ope1, ope2;\n\tbool ans = true;\n\t\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> s;\n\t\t\n\t\tint v = atoi(s.c_str());\n\t\tif(v != 0) stk.push(range(v));\n\t\telse if(v == 0 && s == \"0\") stk.push(range(0));\n\t\telse{\n\t\t\t\n\t\t\tif(s == \"+\"){\n\t\t\t\tope2 = stk.top(); stk.pop();\n\t\t\t\tope1 = stk.top(); stk.pop();\n\t\t\t\tstk.push(ope1 + ope2);\n\t\t\t}else if(s == \"-\"){\n\t\t\t\tope2 = stk.top(); stk.pop();\n\t\t\t\tope1 = stk.top(); stk.pop();\n\t\t\t\tstk.push(ope1 - ope2);\n\t\t\t}else if(s == \"*\"){\n\t\t\t\tope2 = stk.top(); stk.pop();\n\t\t\t\tope1 = stk.top(); stk.pop();\n\t\t\t\tstk.push(ope1 * ope2);\n\t\t\t}else if(s == \"/\"){\n\t\t\t\tope2 = stk.top();\n\t\t\t\tif(ope2.a[0]){\n\t\t\t\t\tans = false;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tstk.pop();\n\t\t\t\tope1 = stk.top(); stk.pop();\n\t\t\t\tstk.push(ope1 / ope2);\n\t\t\t}else{\n\t\t\t\tstk.push( mp[s] );\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tend:;\n\tif(ans) cout << \"correct\" << endl;\n\telse cout << \"error\" << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n#define F first\n#define S second\ntypedef vector<bool> vb;\n\ninline int toInt(string s) {\n\tint v;\n\tistringstream sin(s);\n\tsin >> v; return v;\n}\n\nint main()\n{\n\tmap<string, pii> table;\n\tint m; cin >> m;\n\tREP(_, m) {\n\t\tstring name;\n\t\tint lb, ub;\n\t\tcin >> name >> lb >> ub;\n\t\ttable[name] = make_pair(lb, ub);\n\t}\n\tstack<vb> stack;\n\tint n; cin >> n;\n\tREP(_, n) {\n\t\tstring input; cin >> input;\n\t\tvb term(256, false);\n\t\tif('0' <= input[0] && input[0] <= '9') {\n\t\t\tint val = toInt(input);\n\t\t\tterm[val % 256] = true;\n\t\t\tstack.push(term);\n\t\t} else {\n\t\t\tvb a, b;\n\t\t\tswitch(input[0]) {\n\t\t\t\tcase '+':\n\t\t\t\t\tb = stack.top(); stack.pop(); a = stack.top(); stack.pop();\n\t\t\t\t\tREP(i, 256) {\n\t\t\t\t\t\tREP(j, 256) {\n\t\t\t\t\t\t\tif (a[i] && b[j]) {\n\t\t\t\t\t\t\t\tterm[(i + j) % 256] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(term);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\tb = stack.top(); stack.pop(); a = stack.top(); stack.pop();\n\t\t\t\t\tREP(i, 256) {\n\t\t\t\t\t\tREP(j, 256) {\n\t\t\t\t\t\t\tif (a[i] && b[j]) {\n\t\t\t\t\t\t\t\tterm[(i - j + 256) % 256] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(term);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\tb = stack.top(); stack.pop(); a = stack.top(); stack.pop();\n\t\t\t\t\tREP(i, 256) {\n\t\t\t\t\t\tREP(j, 256) {\n\t\t\t\t\t\t\tif (a[i] && b[j]) {\n\t\t\t\t\t\t\t\tterm[(i * j) % 256] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(term);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\tb = stack.top(); stack.pop(); a = stack.top(); stack.pop();\n\t\t\t\t\tREP(i, 256) {\n\t\t\t\t\t\tREP(j, 256) {\n\t\t\t\t\t\t\tif (a[i] && b[j]) {\n\t\t\t\t\t\t\t\tif (j == 0) goto ERROR;\n\t\t\t\t\t\t\t\tterm[(i / j) % 256] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(term);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tFOR(i, table[input].F, table[input].S + 1) {\n\t\t\t\t\t\tterm[i] = true;\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(term);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\nERROR:\n\tcout << \"error\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define each(i,n) for(auto i : n)\n\nint main() {\n\tint m;\n\tcin >> m;\n\tvector<char> c(m);\n\tvector<int> l(m), r(m);\n\tmap<string, int> p;\n\tp[\"+\"] = -1;\n\tp[\"-\"] = -1;\n\tp[\"*\"] = -1;\n\tp[\"/\"] = -1;\n\trep(i, m) {\n\t\tcin >> c[i] >> l[i] >> r[i];\n\t\tp[string(1,c[i])] = i;\n\t}\n\tvector<vector<int>> d(m);\n\trep(i, m) {\n\t\tfor (int j = l[i]; j <= r[i]; j++) {\n\t\t\td[i].push_back(j);\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tvector<int> v;\n\tstack<vector<int>> s;\n\trep(k, n) {\n\t\tstring t;\n\t\tcin >> t;\n\t\tif (p.count(t)) {\n\t\t\tif (p[t] == -1) {\n\t\t\t\tauto b = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tauto a = s.top();\n\t\t\t\ts.pop();\n\t\t\t\tset<int> se;\n\t\t\t\teach(i, b)each(j, a) {\n\t\t\t\t\tif (t == \"+\") {\n\t\t\t\t\t\tse.insert((j + i) % 256);\n\t\t\t\t\t}\n\t\t\t\t\tif (t == \"-\") {\n\t\t\t\t\t\tse.insert((j - i + 256) % 256);\n\t\t\t\t\t}\n\t\t\t\t\tif (t == \"*\") {\n\t\t\t\t\t\tse.insert((j * i) % 256);\n\t\t\t\t\t}\n\t\t\t\t\tif (t == \"/\") {\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tse.insert((j / i) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvector<int> v;\n\t\t\t\teach(i, se) {\n\t\t\t\t\tv.push_back(i);\n\t\t\t\t}\n\t\t\t\ts.push(v);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.push(d[p[t]]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ts.push(vector<int>(1, atoi(t.c_str())));\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing RInt=array<int,256>;\nint main(){\n    int m;\n    cin>>m;\n    map<string,RInt> var;\n    for(int i=0;i<m;i++){\n        string name;\n        int lb,ub;\n        cin>>name>>lb>>ub;\n        for(int j=0;j<lb;j++) var[name][j]=0;\n        for(int j=lb;j<=ub;j++) var[name][j]=1;\n        for(int j=ub+1;j<256;j++) var[name][j]=0;\n    }\n    int n;\n    cin>>n;\n    vector<string> ord(n);\n    for(int i=0;i<n;i++) cin>>ord[i];\n    stack<RInt> st;\n    for(int i=0;i<n;i++){\n        if(var.count(ord[i])){\n            st.push(var[ord[i]]);\n        }\n        else if(ord[i]==\"+\"){\n            RInt b=st.top(); st.pop();\n            RInt a=st.top(); st.pop();\n            RInt res;\n            fill(res.begin(),res.end(),0);\n            for(int i=0;i<256;i++){\n                for(int j=0;j<256;j++){\n                    if(a[i] && b[j]){\n                        res[(i+j)%256]=1;\n                    }\n                }\n            }\n            st.push(res);\n        }\n        else if(ord[i]==\"-\"){\n            RInt b=st.top(); st.pop();\n            RInt a=st.top(); st.pop();\n            RInt res;\n            fill(res.begin(),res.end(),0);\n            for(int i=0;i<256;i++){\n                for(int j=0;j<256;j++){\n                    if(a[i] && b[j]){\n                        res[(i+256-j)%256]=1;\n                    }\n                }\n            }\n            st.push(res);\n        }\n        else if(ord[i]==\"*\"){\n            RInt b=st.top(); st.pop();\n            RInt a=st.top(); st.pop();\n            RInt res;\n            fill(res.begin(),res.end(),0);\n            for(int i=0;i<256;i++){\n                for(int j=0;j<256;j++){\n                    if(a[i] && b[j]){\n                        res[(i*j)%256]=1;\n                    }\n                }\n            }\n            st.push(res);\n        }\n        else if(ord[i]==\"/\"){\n            RInt b=st.top(); st.pop();\n            RInt a=st.top(); st.pop();\n            if(b[0]){\n                cout<<\"error\"<<endl;\n                return 0;\n            }\n            RInt res;\n            fill(res.begin(),res.end(),0);\n            for(int i=0;i<256;i++){\n                for(int j=0;j<256;j++){\n                    if(a[i] && b[j]){\n                        res[(i/j)%256]=1;\n                    }\n                }\n            }\n            st.push(res);\n        }\n        else{\n            RInt tmp;\n            fill(tmp.begin(),tmp.end(),0);\n            tmp[stoi(ord[i])]=true;\n            st.push(tmp);\n        }\n    }\n    cout<<\"correct\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 300\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n \nint memo[MAX][MAX][MAX];\n \nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l-2 < 0 ? MAX-1 : vec[l-2]);\n    int v2 = (l-1 < 0 ? MAX-1 : vec[l-1]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            if (l < 2) {\n                return false;\n            }\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n              \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n   \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2435&lang=jp\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint m; cin >> m;\n\tstring op = \"+-/*\";\n\tmap<string, int> name_idx;\n\tvector<pair<int, int>> name(m + 1);\n\tfor (int i = 1; i <= m; i++) {\n\t\tstring _name; int lb, ub;\n\t\tcin >> _name >> lb >> ub;\n\t\tname_idx[_name] = i;\n\t\tname[i].first = lb; name[i].second = ub;\n\t}\n\tint n; cin >> n;\n\tstack<int> st_idx;\n\tvector<vector<int>> st(n, vector<int>(256, 0));\n\tfor (int i = 0; i < n;i++) {\n\t\tstring e; cin >> e;\n\t\t/* +-/* or value */\n\t\tif (name_idx[e] == 0) {\n\t\t\tif (e == \"+\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a + b) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"-\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a - b + 256) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"*\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tst[i][(a*b) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e == \"/\") {\n\t\t\t\tint b_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tint a_idx = st_idx.top(); st_idx.pop();\n\t\t\t\tfor (int a = 0; a < 256;a++) {\n\t\t\t\t\tif (st[a_idx][a] == 0) continue;\n\t\t\t\t\tfor (int b = 0; b < 256; b++) {\n\t\t\t\t\t\tif (st[b_idx][b] == 0) continue;\n\t\t\t\t\t\tif (b == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tst[i][(a / b) % 256] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst[i][atoi(e.c_str())] = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tauto pii = name[name_idx[e]];\n\t\t\tfor (int v = pii.first; v <= pii.second;v++) {\n\t\t\t\tst[i][v] = 1;\n\t\t\t}\n\t\t}\n\t\tst_idx.push(i);\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(double)(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <stack>\n#include <map>\nusing namespace std;\nmap<string, vector<bool>> mp;\nint main() {\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tstring name;\n\t\tint l, u;\n\t\tcin >> name >> l >> u;\n\t\tvector<bool> v;\n\t\tfor (int i = 0; i <= 255; i++) {\n\t\t\tv.push_back(l <= i && i <= u);\n\t\t}\n\t\tmp[name] = v;\n\t}\n\tint n;\n\tcin >> n;\n\tstack<vector<bool>> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring e;\n\t\tcin >> e;\n\t\tif (mp.find(e) != mp.end()) {\n\t\t\ts.push(mp[e]);\n\t\t}\n\t\telse if(isdigit(e[0])) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 0; j < e.size(); j++) {\n\t\t\t\tval *= 10;\n\t\t\t\tval += e[j] - '0';\n\t\t\t}\n\t\t\tvector<bool> v;\n\t\t\tfor (int j = 0; j <= 255; j++) {\n\t\t\t\tv.push_back(j == val);\n\t\t\t}\n\t\t\ts.push(v);\n\t\t}\n\t\telse {\n\t\t\tvector<bool> op1, op2, res;\n\t\t\top2 = s.top(); s.pop();\n\t\t\top1 = s.top(); s.pop();\n\t\t\tfor (int j = 0; j <= 255; j++) res.push_back(0);\n\t\t\tfor (int j = 0; j <= 255; j++) {\n\t\t\t\tif (!op1[j]) continue;\n\t\t\t\tfor (int k = 0; k <= 255; k++) {\n\t\t\t\t\tif (!op2[k]) continue;\n\t\t\t\t\tif (e[0] == '+') {\n\t\t\t\t\t\tres[(j + k) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (e[0] == '-') {\n\t\t\t\t\t\tres[(j - k + 256) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (e[0] == '*') {\n\t\t\t\t\t\tres[j*k % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres[j / k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.push(res);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<stdlib.h>\nusing namespace std;\nchar str[100][21];\nint l[100];\nint r[100];\nstruct wolf{\n\tint c[256];\n\twolf(){\n\t\tfor(int i=0;i<256;i++)c[i]=0;\n\t}\n};\nchar p[100][21];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s%d%d\",str[i],l+i,r+i);\n\t}\n\tint b;\n\tscanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%s\",p[i]);\n\t}\n\tstack<wolf> S;\n\tbool ret=false;\n\tfor(int i=0;i<b;i++){\n\t\tif('0'<=p[i][0]&&p[i][0]<='9'){\n\t\t\twolf w;\n\t\t\tw.c[atoi(p[i])]=1;\n\t\t\tS.push(w);\n\t\t}else if(p[i][0]!='+'&&p[i][0]!='-'&&p[i][0]!='*'&&p[i][0]!='/'){\n\t\t\twolf w;\n\t\t\tint at=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;str[k][j]||p[i][j];j++)ok=false;\n\t\t\t\tif(ok)at=k;\n\t\t\t}\n\t\t\tfor(int i=l[at];i<=r[at];i++)w.c[i]=1;\n\t\t\tS.push(w);\n\t\t}else{\n\t\t\twolf B=S.top();\n\t\t\tS.pop();\n\t\t\twolf A=S.top();\n\t\t\tS.pop();\n\t\t\tif(p[i][0]=='+'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i+j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='-'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i-j+256)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='*'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i*j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='/'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j]){\n\t\t\t\t\t\t\tif(j==0)ret=true;\n\t\t\t\t\t\t\telse w.c[(i/j)%256]=1;\n\t\t\t\t\t\t}\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t}\n\t}\n\tif(ret)printf(\"error\\n\");\n\telse printf(\"correct\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\ninline ll uku(ll a){a%=256; if(a<0){a+=256;} return a;}\n\nusing Bit=bitset<256>;\n\nvoid solve(){\n  ll M,N;\n  cin>>M;\n  map<string,pll> A;\n  for(int i=0;i<M;i++){\n    string s;\n    cin>>s;\n    ll lf,rg;\n    cin>>lf>>rg;\n    A[s]={lf,rg};\n  }\n  cin>>N;\n  stack<Bit> S;\n  bool ans=true;\n  for(int i=0;i<N;i++){\n    string str;\n    cin>>str;\n    //cout<<i<<\" \"<<str<<endl;\n    Bit b;\n    b.reset();\n    if(str[0]=='+'){\n      Bit x=S.top(); S.pop();\n      Bit y=S.top(); S.pop();\n      for(int i=0;i<256;i++){\n        for(int j=0;j<256;j++){\n          if(x[i] && y[j]){b[uku(j+i)]=true;}\n        }\n      }\n    }\n    else if(str[0]=='-'){\n      Bit x=S.top(); S.pop();\n      Bit y=S.top(); S.pop();\n      for(int i=0;i<256;i++){\n        for(int j=0;j<256;j++){\n          if(x[i] && y[j]){b[uku(j-i)]=true;}\n        }\n      }\n    }\n    else if(str[0]=='*'){\n      Bit x=S.top(); S.pop();\n      Bit y=S.top(); S.pop();\n      for(int i=0;i<256;i++){\n        for(int j=0;j<256;j++){\n          if(x[i] && y[j]){b[uku(j*i)]=true;}\n        }\n      }\n    }\n    else if(str[0]=='/'){\n      Bit x=S.top(); S.pop();\n      Bit y=S.top(); S.pop();\n      for(int i=0;i<256;i++){\n        for(int j=0;j<256;j++){\n          if(x[i] && y[j]){\n            if(i==0){ans=false; continue;;}\n            b[uku(j/i)]=true;\n          }\n        }\n      }\n    }\n    else if(A.count(str)){\n      for(int i=A[str].F;i<=A[str].S;i++){b[i]=true;}\n    }\n    else{\n      ll k=0;\n      for(auto &I:str){k*=10; k+=I-'0';}\n      k%=256;\n      b[k]=true;\n    }\n    //cout<<b<<endl;\n    S.push(b);\n  }\n  cout<<(ans?\"correct\":\"error\")<<endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n  \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  if(ele.empty())\n\t    {\n\t      assert(false);\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  \n\t\t  C.insert(((int)ceil((double)(*it_a)/(double)(*it_b)))%256);\n\t\t}\n\t    }\n\n\t  index[\"NARIYOSHI_X\"] = C;\n\t  ele.push(\"NARIYOSHI_X\");\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstring in[100];\n\nint main() {\n  int m;\n  while(cin >> m) {\n    map<string, pii> mp;\n    REP(i,m) {\n      string name;\n      cin >> name;\n      int a, b;\n      cin >> a >> b;\n      mp[name] = pii(a,b);\n    }\n    int n;\n    cin >> n;\n    REP(i,n)cin >> in[i];\n    stack<set<int> > stk;\n    int mod = 256;\n    REP(i,n) {\n      string s = in[i];\n      if (mp.count(s)) {\n        pii p = mp[s];\n        set<int> se;\n        for (int j=p.first; j<=p.second; ++j) {\n          se.insert(j);\n        }\n        stk.push(se);\n      } else if (s.size() == 1 && !isdigit(s[0])) {\n        assert(stk.size());\n        set<int> b = stk.top();\n        stk.pop();\n        assert(stk.size());\n        set<int> a = stk.top();\n        stk.pop();\n        set<int> se;\n        FOR(it, a) {\n          FOR(jt, b) {\n            if (s==\"+\") se.insert((*it + *jt)%mod);\n            else if (s==\"-\") se.insert((*it - *jt + mod)%mod);\n            else if (s==\"*\") se.insert((*it * *jt) %mod);\n            else {\n              if (*jt == 0) goto error;\n              se.insert(*it / *jt % mod);\n            }\n          }\n        }\n        stk.push(se);\n      } else {\n        set<int> se;\n        se.insert((atoi(s.c_str()) % mod + mod) % mod);\n        stk.push(se);\n      }\n      //FOR(it, stk.top()) cout << *it << \" \";cout << endl;\n    }\n    puts(\"correct\");\n    continue;\n  error:\n    puts(\"error\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<pii> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l == 0 ? MAX-1 : vec[0].second);\n    int v2 = (l == 0 ? MAX-1 : vec[l-1].second); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(pii(s2i(e[x]), x));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            pii p2 = vec[l-1], p1 = vec[l-2];\n            int b = p2.first;\n            int a = p1.first;\n            vec.pop_back(); vec.pop_back();\n            \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(pii(c, x));\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(p1);\n            vec.push_back(p2);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(pii(i, x));\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<pii>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define r(i,n) for(int i=0;i<n;i++)\nmap<string,P>M;\nint m,low,high;\nstring name,s;\nstack<vector<int> >st;\nvoid END(){\n  cout<<\"error\"<<endl;\n  exit(0);\n}\nvoid in_num(){\n  vector<int>v;\n  int res=0;\n  r(i,s.size())res=res*10+(s[i]-'0'),res=res%256;\n  v.push_back(res);\n  st.push(v);\n}\nvoid in_string(){\n  vector<int>v;\n  int t1=M[s].first;\n  int t2=M[s].second;\n  for(int i=t1;i<=t2;i++)v.push_back(i);\n  st.push(v);\n}\nvoid sol1(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]+v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol2(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]-v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol3(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]*v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol4(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      if(v2[j]==0)END();\n      int t=v1[i]/v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nint main(){\n  cin>>m;\n  r(i,m){\n    cin>>name>>low>>high;\n    M[name]=P(low,high);\n  }\n  cin>>m;\n  while(m--){\n    cin>>s;\n    if(isdigit(s[0]))in_num();\n    else if(isalpha(s[0]))in_string();\n    else{\n      if(s==\"+\")sol1();\n      if(s==\"-\")sol2();\n      if(s==\"*\")sol3();\n      if(s==\"/\")sol4();\n    }\n  }\n  cout<<\"correct\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range pair<int,int>\nusing namespace std;\n\nrange range_add(range a, range b){\n    range ret(256,0);\n    int i,j;\n    for(i=a.first;i<=a.second;i++){\n        for(j=b.first;j<=b.second;j++){\n            ret.first=(ret.first<(i+j)%256)?ret.first:(i+j)%256;\n            ret.second=(ret.second>(i+j)%256)?ret.second:(i+j)%256;\n        }\n    }\n    return ret;\n}\n\nrange range_dif(range a, range b){\n    range ret(256,0);\n    int i,j;\n    for(i=a.first;i<=a.second;i++){\n        for(j=b.first;j<=b.second;j++){\n            ret.first=(ret.first<(i+256-j)%256)?ret.first:(i+256-j)%256;\n            ret.second=(ret.second>(i+256-j)%256)?ret.second:(i+256-j)%256;\n        }\n    }\n    return ret;\n}\n\nrange range_mul(range a, range b){\n    range ret(256,0);\n    int i,j;\n    for(i=a.first;i<=a.second;i++){\n        for(j=b.first;j<=b.second;j++){\n            ret.first=(ret.first<(i*j)%256)?ret.first:(i*j)%256;\n            ret.second=(ret.second>(i*j)%256)?ret.second:(i*j)%256;\n        }\n    }\n    return ret;\n}\n\nrange range_div(range a, range b){\n    range ret(256,0);\n    int i,j;\n    for(i=a.first;i<=a.second;i++){\n        for(j=b.first;j<=b.second;j++){\n            if(j==0){\n                throw 1;\n            }\n            ret.first=(ret.first<(i/j)%256)?ret.first:(i/j)%256;\n            ret.second=(ret.second>(i/j)%256)?ret.second:(i/j)%256;\n        }\n    }\n    return ret;\n}\n\nint main(void){\n    vector<range> st;\n    unordered_map<string, range> dic;\n    int n;\n    cin>>n;\n    string buf;\n    int a,b;\n    rep(i,n){\n        cin>>buf>>a>>b;\n        dic[buf]=range(a,b);\n    }\n    cin>>n;\n    try{\n        rep(i,n){\n            cin>>buf;\n            if(isdigit(buf[0])){\n                st.emplace_back(stoi(buf),stoi(buf));\n            }else if(buf[0]=='+'){\n                st[st.size()-2]=range_add(st[st.size()-2], st[st.size()-1]);\n                st.pop_back();\n            }else if(buf[0]=='-'){\n                st[st.size()-2]=range_dif(st[st.size()-2], st[st.size()-1]);\n                st.pop_back();\n            }else if(buf[0]=='*'){\n                st[st.size()-2]=range_mul(st[st.size()-2], st[st.size()-1]);\n                st.pop_back();\n            }else if(buf[0]=='/'){\n                st[st.size()-2]=range_div(st[st.size()-2], st[st.size()-1]);\n                st.pop_back();\n            }else{\n                st.push_back(dic[buf]);\n            }\n        }\n        cout<<\"correct\\n\";\n        return 0;\n    }catch (...){\n        cout<<\"error\\n\";\n        return 0;\n    }\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n    int n,m;\n    while(cin >> n){\n        map<string,vector<int> > v;\n        stack<vector<int> > s;\n        bool ans = true;\n        for(int i=0;i<n;i++){\n            string str;\n            int a,b;\n            cin >> str >> a >> b;\n            for(int j=a;j<=b;j++) v[str].push_back(j);\n        }\n        cin >> m;\n        for(int i=0;i<m;i++){\n            string str;\n            cin >> str;\n            if(!ans) continue;\n            if(str[0] >= '0' && str[0] <= '9'){\n                vector<int> v2(1,0);\n                for(int j=0;j<str.size();j++){\n                    v2[0] *= 10;\n                    v2[0] += str[j] - '0';\n                }\n                s.push(v2);\n            }\n            else if(str.size() == 1 && (str[0] == '+' || str[0] == '-' || str[0] == '*' || str[0] == '/')){\n                vector<int> a,b,c;\n                b = s.top();\n                s.pop();\n                a = s.top();\n                s.pop();\n                for(int j=0;j<a.size();j++){\n                    for(int k=0;k<b.size();k++){\n                        int res;\n                        if(str[0] == '+') res = (a[j] + b[k]) % 256;\n                        else if(str[0] == '-') res = (a[j] - b[k] + 256) % 256;\n                        else if(str[0] == '*') res = (a[j] * b[k]) % 256;\n                        else if(b[k] != 0) res = (a[j] / b[k]) % 256;\n                        else{\n                            ans = false;\n                            break;\n                        }\n                        vector<int>::iterator it = lower_bound(c.begin(),c.end(),res);\n                        if(c.empty() || *it != res) c.insert(it,res);\n                    }\n                    if(!ans) break;\n                }\n                s.push(c);\n            } else s.push(v[str]);\n        }\n        cout << (ans ? \"correct\" : \"error\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int m, n;\n  map<string, pair<int, int> > mp;\n  vector<string> es;\n\n  cin >> m;\n  rep(i, m) {\n    string name; int lb, ub;\n    cin >> name >> lb >> ub;\n    mp[name] = make_pair(lb, ub);\n  }\n  cin >> n;\n  es.resize(n);\n  rep(i, n) cin >> es[i];\n\n  string ops = \"+-*/\";\n  stack<int> stk;\n  vector< unordered_set<int> > vec(n);\n\n  rep(i, n) {\n    string e = es[i];\n\n    if(ops.find(e) == -1) {\n      if(mp.count(e) == 0) vec[i].insert(stoi(e));\n      else reps(j, mp[e].first, mp[e].second+1) vec[i].insert(j);\n    } else {\n      int bi = stk.top(); stk.pop();\n      int ai = stk.top(); stk.pop();\n      for(int a : vec[ai]) {\n\tfor(int b : vec[bi]) {\n\t  int res;\n\t  if(e == \"+\") {\n\t    res = (a + b) % 256;\n\t  } else if(e == \"-\") {\n\t    res = (a - b + 256) % 256;\n\t  } else if(e == \"*\") {\n\t    res = (a * b) % 256;\n\t  } else if(e == \"/\") {\n\t    if(b == 0) {\n\t      puts(\"error\");\n\t      return 0;\n\t    }\n\t    res = (a / b) % 256;\n\t  }\n\t  vec[i].insert(res);\n\t}\n      }\n    }\n    stk.push(i);\n  }\n\n  puts(\"correct\");\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nbool isDig(string s){\n  for(int i=0;i<(int)s.size();i++)\n    if(!(s[i]>='0'&&s[i]<='9'))return false;\n  return true;\n}\n\nmap<string,set<int> > mp;\nint main(){\n  int m;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    string s;\n    int lb,ub;\n    cin>>s>>lb>>ub;\n    set<int> v;\n    for(int j=lb;j<=ub;j++)v.insert(j);\n    mp[s]=v;\n  }\n  int n;\n  cin>>n;\n  stack<set<int> > stk;\n  for(int i=0;i<n;i++){\n    string e;\n    cin>>e;\n    if(isDig(e)){\n      int num=StringToInt(e);\n      set<int> v;v.insert(num);\n      stk.push(v);\n    }\n    else if(mp.count(e)>0)stk.push(mp[e]);\n    else{\n      set<int> v1=stk.top();stk.pop();\n      set<int> v2=stk.top();stk.pop();\n      set<int> v3;\n      for(set<int>::iterator it1=v1.begin();it1!=v1.end();it1++){\n\tfor(set<int>::iterator it2=v2.begin();it2!=v2.end();it2++){\n\t  if(e==\"+\")v3.insert((*it1+*it2)%256);\n\t  else if(e==\"-\")v3.insert((*it2-*it1+256)%256);\n\t  else if(e==\"*\")v3.insert(((*it1)*(*it2))%256);\n\t  else if(e==\"/\"){\n\t    if(*it1==0){\n\t      cout<<\"error\"<<endl;\n\t      return 0;\n\t    }\n\t    v3.insert(((*it2)/(*it1))%256);\n\t  }\n\t}\n      }\n      stk.push(v3);\n    }\n  }\n  cout<<\"correct\"<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst ll MAX_V = 256;\nconst ll inf = 5e15;\n\nbool solve() {\n    ll N, M;\n    cin >> M;\n    map<string, PLL> ranges;\n    for (ll i = 0; i < M; i++) {\n        string s;\n        ll l, u;\n        cin >> s >> l >> u;\n        ranges[s] = PLL(l, u);\n    }\n    \n    cin >> N;\n    ll vidx = 0;\n    stack<string> stk;\n    V<string> expr(N);\n    for (auto &&e : expr) cin >> e;\n    \n    auto addf = [](ll x, ll y) { return (x + y) % MAX_V; };\n    auto decf = [](ll x, ll y) { return (x - y + MAX_V) % MAX_V; };\n    auto mulf = [](ll x, ll y) { return (x * y) % MAX_V; };\n    auto divf = [](ll x, ll y) { return (x / y) % MAX_V; };\n\n    auto pop_stk = [&] {\n        auto ret = stk.top();\n        stk.pop();\n        return ret;\n    };\n\n    auto label = [&] { return to_string(vidx++); };\n    \n    for (auto &&e : expr) {\n        if (e == \"+\" || e == \"-\" || e == \"*\" || e == \"/\") {\n            string re = pop_stk();\n            string le = pop_stk();\n            if (e == \"/\") {\n                ll l, r;\n                tie(l, r) = ranges[re];\n                if (l <= 0 && 0 <= r) return false;\n            }\n            auto op = (e == \"+\" ? addf :\n                       e == \"-\" ? decf :\n                       e == \"*\" ? mulf : divf);\n            ll lb = inf, ub = -inf;\n            auto nval = label();\n            ll lrng[2], rrng[2];\n            tie(lrng[0], lrng[1]) = ranges[le];\n            tie(rrng[0], rrng[1]) = ranges[re];\n            for (ll l = lrng[0]; l <= lrng[1]; l++) for (ll r = rrng[0]; r <= rrng[1]; r++) {\n                ll val = op(l, r);\n                chmin(lb, val);\n                chmax(ub, val);\n            }\n            stk.push(nval);\n            ranges[nval] = PLL(lb, ub);\n        } else {\n            if ('a' <= e[0] && e[0] <= 'z') {\n                stk.push(e);\n            } else {\n                auto nval = label();\n                ll val = stoll(e);\n                stk.push(nval);\n                ranges[nval] = PLL(val, val);\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    cout << (solve() ? \"correct\" : \"error\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nint main()\n{\n  int m;\n  while (cin >> m) {\n    map<string, pair<int, int> > var;\n    for (int i = 0; i < m; ++i) {\n      string name;\n      int lb, ub;\n      cin >> name >> lb >> ub;\n      var[name] = make_pair(lb, ub);\n    }\n\n    int n;\n    cin >> n;\n\n    vector<string> e(n);\n    for (int i = 0; i < n; ++i)\n      cin >> e[i];\n\n    bool correct = true;\n    stack<vector<int> > stk;\n    for (int k = 0; k < n; ++k) {\n      if (isdigit(e[k][0])) {\n        stk.push(vector<int>(1, atoi(e[k].c_str())));\n      } else if (isalpha(e[k][0])) {\n        vector<int> tmp;\n        for (int i = var[e[k]].first; i <= var[e[k]].second; ++i)\n          tmp.push_back(i);\n        stk.push(tmp);\n      } else {\n        vector<int> b = stk.top();\n        stk.pop();\n        vector<int> a = stk.top();\n        stk.pop();\n\n        set<int> s;\n        if (e[k] == \"+\") {\n          for (unsigned int i = 0; i < a.size(); ++i) {\n            for (unsigned int j = 0; j < b.size(); ++j)\n              s.insert((a[i] + b[j]) % 256);\n          }\n        } else if (e[k] == \"-\") {\n          for (unsigned int i = 0; i < a.size(); ++i) {\n            for (unsigned int j = 0; j < b.size(); ++j)\n              s.insert((a[i] - b[j] + 256) % 256);\n          }        \n        } else if (e[k] == \"*\") {\n          for (unsigned int i = 0; i < a.size(); ++i) {\n            for (unsigned int j = 0; j < b.size(); ++j)\n              s.insert((a[i] * b[j]) % 256);\n          }\n        } else {\n          for (unsigned int i = 0; i < a.size(); ++i) {\n            for (unsigned int j = 0; j < b.size(); ++j) {\n              if (b[j] == 0) {\n                correct = false;\n                goto END;\n              }\n              s.insert((a[i] / b[j]) % 256);\n            }\n          }\n        }\n\n        vector<int> r;\n        for (set<int>::iterator it = s.begin(); it != s.end(); ++it)\n          r.push_back(*it);\n        stk.push(r);\n      }\n    }\n\n  END:\n    if (correct)\n      cout << \"correct\" << endl;\n    else\n      cout << \"error\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<stdlib.h>\nusing namespace std;\nchar str[100][21];\nint l[100];\nint r[100];\nstruct wolf{\n\tint c[256];\n\twolf(){\n\t\tfor(int i=0;i<256;i++)c[i]=0;\n\t}\n};\nchar p[100][21];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s%d%d\",str[i],l+i,r+i);\n\t}\n\tint b;\n\tscanf(\"%d\",&b);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%s\",p[i]);\n\t}\n\tstack<wolf> S;\n\tbool ret=false;\n\tfor(int i=0;i<b;i++){\n\t\tbool OK=true;\n\t\tfor(int j=0;p[i][j];j++)if(p[i][j]<'0'||p[i][j]>'9')OK=false;\n\t\tif(OK){\n\t\t\twolf w;\n\t\t\tw.c[atoi(p[i])]=1;\n\t\t\tS.push(w);\n\t\t}else if(p[i][0]!='+'&&p[i][0]!='-'&&p[i][0]!='*'&&p[i][0]!='/'){\n\t\t\twolf w;\n\t\t\tint at=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;str[k][j]||p[i][j];j++)ok=false;\n\t\t\t\tif(ok)at=k;\n\t\t\t}\n\t\t\tfor(int i=l[at];i<=r[at];i++)w.c[i]=1;\n\t\t\tS.push(w);\n\t\t}else{\n\t\t\twolf B=S.top();\n\t\t\tS.pop();\n\t\t\twolf A=S.top();\n\t\t\tS.pop();\n\t\t\tif(p[i][0]=='+'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i+j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='-'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i-j+256)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='*'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j])w.c[(i*j)%256]=1;\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t\tif(p[i][0]=='/'){\n\t\t\t\twolf w;\n\t\t\t\tfor(int i=0;i<256;i++)\n\t\t\t\t\tfor(int j=0;j<256;j++)\n\t\t\t\t\t\tif(A.c[i]&&B.c[j]){\n\t\t\t\t\t\t\tif(j==0)ret=true;\n\t\t\t\t\t\t\telse w.c[(i/j)%256]=1;\n\t\t\t\t\t\t}\n\t\t\t\tS.push(w);\n\t\t\t}\n\t\t}\n\t}\n\tif(ret)printf(\"error\\n\");\n\telse printf(\"correct\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nbool is_valiable(string e){\n  for(int i = 0; i < (int)e.length(); ++i){\n    if(e[i] < '0' || e[i] > '9') return true;\n  }\n  return false;\n}\n\nint main(){\n  int m, mod = 256;\n  cin >> m;\n  string name;\n  int lb, ub;\n  map<string, vector<int> > M;\n  for(int i = 0; i < m; ++i){\n    cin >> name >> lb >> ub;\n    vector<int> t(mod,0);\n    for(int j = lb; j <= ub; ++j){\n      t[j] = 1;\n    }\n    M[name] = t;\n  }\n  \n  int n;\n  cin >> n;\n  string e, o = \"+-*/\";\n  stack<string> st;\n  for(int i = 0; i < n; ++i){\n    cin >> e;\n    if(o.find(e) < 4){\n      string b = st.top();st.pop();\n      string a = st.top();st.pop();\n      //cout << a << \" \" << b << endl;\n      if(e == \"+\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  //st.push(to_string((j+k)%mod));\n\t\t  t[(j+k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j+B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A+j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod+stoi(b)%mod)%mod));\n\t  }\n\t}\n      }else if(e == \"-\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j-k+mod)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j-B+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A-j+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod-stoi(b)%mod+mod)%mod));\n\t  }\n\t}\n      }else if(e == \"*\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j*k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j*B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A*j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string(((stoi(a)%mod)*(stoi(b)%mod))%mod));\n\t  }\n\t}\n      }else if(e == \"/\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  if(k == 0){\n\t\t    cout << \"error\" << endl;\n\t\t    return 0;\n\t\t  }\n\t\t  t[((j%mod)/(k%mod))%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n   \t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j/B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tif(j == 0){\n\t\t  cout << \"error\" << endl;\n\t\t  return 0;\n\t\t}\n\t\tt[(A/j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    st.push(to_string((stoi(a)/stoi(b))%mod));\n\t  }\n\t}\n      }\n    }else{\n      st.push(e);\n    }\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n\tint m;\n\tcin >> m;\n\tmap<string, pair<int, int> > var;\n\tstring v;\n\tint mn, mx;\n\tfor(int i = 0;i < m;i++) {\n\t\tcin >> v >> mn >> mx;\n\t\tvar[v] = pair<int, int>(mn, mx);\n\t}\n\tint n;\n\tcin >> n;\n\tvector<string> input(n);\n\tfor(int i = 0;i < n;i++) {\n\t\tcin >> input[i];\n\t}\n\tstack<vector<int> > st;\n\tfor(int i = 0;i < n;i++) {\n\t\tif(input[i][0] >= '0' && input[i][0] <= '9') {\n\t\t\tvector<int> tmp(256,0);\n\t\t\ttmp[stoi(input[i])] = 1;\n\t\t\tst.push(tmp);\n\t\t} else if(input[i] == \"+\") {\n\t\t\tvector<int> b = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> a = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> tmp(256, 0);\n\t\t\tfor(int k = 0;k < 256;k++) {\n\t\t\t\tfor(int j = 0;j < 256;j++) {\n\t\t\t\t\tif(a[k] == 1 && b[j] == 1){\n\t\t\t\t\t\ttmp[(a[k] + b[j]) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(tmp);\n\t\t} else if(input[i] == \"-\") {\n\t\t\tvector<int> b = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> a = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> tmp(256, 0);\n\t\t\tfor(int k = 0;k < 256;k++) {\n\t\t\t\tfor(int j = 0;j < 256;j++) {\n\t\t\t\t\tif(a[k] == 1 && b[j] == 1) {\n\t\t\t\t\t\ttmp[(256 + a[k] - b[j]) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(tmp);\n\t\t} else if(input[i] == \"*\") {\n\t\t\tvector<int> b = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> a = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> tmp(256, 0);\n\t\t\tfor(int k = 0;k < 256;k++) {\n\t\t\t\tfor(int j = 0;j < 256;j++) {\n\t\t\t\t\tif(a[k] == 1 && b[j] == 1) {\n\t\t\t\t\t\ttmp[(a[k] * b[j]) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(tmp);\n\t\t} else if(input[i] == \"/\") {\n\t\t\tvector<int> b = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> a = st.top();\n\t\t\tst.pop();\n\t\t\tvector<int> tmp(256, 0);\n\t\t\tif(b[0] == 1) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor(int k = 0;k < 256;k++) {\n\t\t\t\tfor(int j = 0;j < 256;j++) {\n\t\t\t\t\tif(a[k] == 1 && b[j] == 1) {\n\t\t\t\t\t\ttmp[(a[k] / b[j]) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(tmp);\n\t\t} else {\n\t\t\tvector<int> tmp(256, 0);\n\t\t\tfor(int j = var[input[i]].first;j <= var[input[i]].second;j++) {\n\t\t\t\ttmp[j] = 1;\n\t\t\t}\n\t\t\tst.push(tmp);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<stack>\n#include<cctype>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint m; scanf(\"%d\",&m);\n\tchar name[100][21];\n\tint lb[100],ub[100];\n\trep(i,m) scanf(\"%s%d%d\",name[i],lb+i,ub+i);\n\n\tint n; scanf(\"%d\",&n);\n\tstack< set<int> > S;\n\twhile(n--){\n\t\tchar s[21]; scanf(\"%s\",s);\n\t\tint i;\n\t\tfor(i=0;i<m;i++) if(strcmp(s,name[i])==0) break;\n\t\tif(i<m){ // 変数\n\t\t\tset<int> A;\n\t\t\tfor(int x=lb[i];x<=ub[i];x++) A.insert(x);\n\t\t\tS.push(A);\n\t\t}\n\t\telse if(isdigit(s[0])){ // 定数\n\t\t\tset<int> A;\n\t\t\tA.insert(atoi(s));\n\t\t\tS.push(A);\n\t\t}\n\t\telse{ // 演算子\n\t\t\tset<int> B=S.top(); S.pop();\n\t\t\tset<int> A=S.top(); S.pop();\n\t\t\tset<int> C;\n\t\t\tset<int>::iterator it,jt;\n\t\t\tfor(it=A.begin();it!=A.end();++it) for(jt=B.begin();jt!=B.end();++jt) {\n\t\t\t\tswitch(s[0]){\n\t\t\t\t\tcase '+': C.insert(((*it)+(*jt))%256);     break;\n\t\t\t\t\tcase '-': C.insert(((*it)-(*jt)+256)%256); break;\n\t\t\t\t\tcase '*': C.insert(((*it)*(*jt))%256);     break;\n\t\t\t\t\tcase '/': if(*jt==0){ puts(\"error\"); return 0; }\n\t\t\t\t\t\t\t  C.insert(((*it)/(*jt))%256);\n\t\t\t\t}\n\t\t\t}\n\t\t\tS.push(C);\n\t\t}\n\t}\n\n\tputs(\"correct\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef pair<int, int> pii;\n\nclass Error {};\n\nmap<string, pii> vars;\n\nvoid calc(vs& factor) {\n    stack<pii> stk;\n    for (const string& f : factor) {\n        if (isdigit(f[0])) {\n            int m = stoi(f);\n            stk.push({m, m});\n        } else if (isalpha(f[0])) {\n            stk.push(vars[f]);\n        } else {\n            pii b = stk.top(); stk.pop();\n            pii a = stk.top(); stk.pop();\n            int ma = 0, mi = 255;\n            int r;\n            switch (f[0]) {\n            case '+':\n                FOR(A, a.first, a.second+1) {\n                    FOR(B, b.first, b.second+1) {\n                        r = (A + B) % 256;\n                        ma = max(ma, r);\n                        mi = min(mi, r);\n                    }\n                }\n                break;\n            case '-':\n                FOR(A, a.first, a.second+1) {\n                    FOR(B, b.first, b.second+1) {\n                        r = (A - B + 256) % 256;\n                        ma = max(ma, r);\n                        mi = min(mi, r);\n                    }\n                }\n                break;\n            case '*':\n                FOR(A, a.first, a.second+1) {\n                    FOR(B, b.first, b.second+1) {\n                        r = (A * B) % 256;\n                        ma = max(ma, r);\n                        mi = min(mi, r);\n                    }\n                }\n                break;\n            case '/':\n                if (b.first == 0) throw Error();\n                FOR(A, a.first, a.second+1) {\n                    FOR(B, b.first, b.second+1) {\n                        r = (A / B) % 256;\n                        ma = max(ma, r);\n                        mi = min(mi, r);\n                    }\n                }\n                break;\n            }\n            stk.push({mi, ma});\n        }\n    }\n}\n\nint main() {\n    int m;\n    cin >> m;\n    REP(i, m) {\n        string name;\n        int a, b;\n        cin >> name >> a >> b;\n        vars[name] = {a, b};\n    }\n    int n;\n    cin >> n;\n    vs factor(n);\n    REP(i, n) cin >> factor[i];\n    try {\n        calc(factor);\n        cout << \"correct\" << endl;\n    } catch (Error e) {\n        cout << \"error\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 300\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nbool isdigits(string &s)\n{\n    for (int i = 0; i < (int)s.size(); i++) {\n        if (!isdigit(s[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n \nint memo[MAX][MAX][MAX];\n \nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l-2 < 0 ? MAX-1 : vec[l-2]);\n    int v2 = (l-1 < 0 ? MAX-1 : vec[l-1]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigits(e[x])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            if (l < 2) {\n                return false;\n            }\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n              \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            if (mp.count(e[x]) == 0) {\n                return false;\n            }\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n   \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l <= 1 ? MAX-1 : vec[l-2]);\n    int v2 = (l == 0 ? MAX-1 : vec[l-1]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n            \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef set<int> S;\ntypedef S::iterator Sit;\n\nint getNum(string a){\n  int res=0;\n  for(int i=0;i<a.size();i++) res=res*10+a[i]-'0';\n  return res;\n}\n\nmap<string,P> val;\nvector<string> el;\nint n;\n\nint calc(){\n  stack <S> stk;\n  for(int i=0;i<n;i++){\n    string e=el[i];\n    S t;\n    if(isdigit(e[0]))t.insert(getNum(e));\n    else if(isalpha(e[0])){\n      int l=val[e].first,r=val[e].second;\n      while(l<=r)t.insert(l++);\n    }\n    else {\n      S B=stk.top();stk.pop();\n      S A=stk.top();stk.pop();\n      for(Sit i=A.begin();i!=A.end();i++)\n\tfor(Sit j=B.begin();j!=B.end();j++){\n\t  int a=*i,b=*j,r;\n\t  if(e[0]=='+')r=(a+b)%256;\n\t  if(e[0]=='-')r=(a-b+256)%256;\n\t  if(e[0]=='*')r=(a*b)%256;\n\t  if(e[0]=='/'){\n\t    if(!b) return 0;\n\t    r=(a/b)%256;\n\t  }\n\t  t.insert(r);\n\t}\n    }\n    stk.push(t);\n  }\n  return 1;\n}\n\nint main(){\n  int m;\n  cin>>m;\n  for(int i=0,a,b;i<m;i++){\n    string t;\n    cin>>t>>a>>b;\n    val[t]=P(a,b);\n  }\n  cin>>n;\n  el.resize(n);\n  for(int i=0;i<n;i++) cin>>el[i];\n  cout<<(calc()?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nmap<string,vi> variable;\n\nint main(void){\n\tint n,m;\n\tcin >> m;\n\trep(i,m){\n\t\tstring var;cin >> var;\n\t\tint lb,rb;cin >> lb >> rb;\n\t\tvi in(256,0);\n\t\tfor(int i=lb;i<=rb;++i) in[i]=1;\n\t\tvariable[var]=in;\n\t}\n\tbool ok=true;\n\tcin >> n;\n\tstack<vi> stk;\n\trep(loop,n){\n\t\tstring e; cin >> e;\n\t\tif(isdigit(e[0])){vi in(256,0);int num=stoi(e);in[num]=1;stk.push(in);}\n\t\telse if(isalpha(e[0])){vi in=variable[e];stk.push(in);}\n\t\telse{\n\t\t\tvi a,b,res(256,0);\n\t\t\tb=stk.top();stk.pop();a=stk.top();stk.pop();\n\t\t\tswitch(e[0]){\n\t\t\t\tcase '+':\n\t\t\t\t\trep(i,256)rep(j,256) if(a[i]&&b[j]) res[(i+j)%256]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '-':\n\t\t\t\t\trep(i,256)rep(j,256) if(a[i]&&b[j]) res[(i-j+256)%256]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '*':\n\t\t\t\t\trep(i,256)rep(j,256) if(a[i]&&b[j]) res[(i*j)%256]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '/':\n\t\t\t\t\trep(i,256)rep(j,256){\n\t\t\t\t\t\tif(a[i]&&b[j]){\n\t\t\t\t\t\t\tif(j==0){ok=false; continue;}\n\t\t\t\t\t\t\tres[(i/j)%256]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstk.push(res);\n\t\t}\n\t}\n\tif(ok)\n\t\tputs(\"correct\");\n\telse\n\t\tputs(\"error\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n    int n,m;\n    while(cin >> n){\n        map<string,vector<int> > v;\n        stack<vector<int> > s;\n        bool ans = true;\n        for(int i=0;i<n;i++){\n            string str;\n            int a,b;\n            cin >> str >> a >> b;\n            for(int j=a;j<=b;j++) v[str].push_back(j);\n        }\n        cin >> m;\n        for(int i=0;i<m;i++){\n            string str;\n            cin >> str;\n            if(!ans) continue;\n            if(str[0] >= '0' && str[0] <= '9'){\n                vector<int> v2(1,0);\n                for(int j=0;j<str.size();j++){\n                    v2[0] *= 10;\n                    v2[0] += str[j] - '0';\n                }\n                s.push(v2);\n            }\n            else if(str.size() == 1 && (str[0] == '+' || str[0] == '-' || str[0] == '*' || str[0] == '/')){\n                vector<int> a,b,c;\n                b = s.top();\n                s.pop();\n                a = s.top();\n                s.pop();\n                for(int j=0;j<a.size();j++){\n                    for(int k=0;k<b.size();k++){\n                        int res;\n                        if(str[0] == '+') res = a[j] + b[k];\n                        else if(str[0] == '-') res = a[j] - b[k];\n                        else if(str[0] == '*') res = a[j] * b[k];\n                        else if(b[k] != 0) res = a[j] / b[k];\n                        else{\n                            ans = false;\n                            break;\n                        }\n                        vector<int>::iterator it = lower_bound(c.begin(),c.end(),res);\n                        if(c.empty() || *it != res) c.insert(it,res);\n                    }\n                    if(!ans) break;\n                }\n                s.push(c);\n            } else s.push(v[str]);\n        }\n        cout << (ans ? \"correct\" : \"error\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return P(imag(a),-real(a));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\nint s2i(string& a){stringstream ss(a);int r;ss>>r;return r;}\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    iscrs(a,b)?0.:\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\nint main(int argc, char *argv[])\n{\n  int m;\n  cin >> m;\n  map<string,set<int> > env;\n  rep(i,m){\n    string name;\n    int a,b;\n    cin >> name >> a >> b;\n    rep(i,b-a+1) env[name].insert(i+a);\n  }\n  int n;\n  cin >> n;\n  stack<set<int> > st;\n  rep(i,n){\n    set<int> a,b;\n    string in;\n    cin >> in;\n    if(isdigit(in[0])){\n      set<int> e;\n      e.insert(s2i(in));\n      st.push(e);\n    }else if(isalpha(in[0])) st.push(env[in]);\n    else{\n      b=st.top();st.pop();\n      a=st.top();st.pop();\n      set<int> ne;\n      FOR(ia,a)FOR(ib,b){\n\tif(in[0]=='+') ne.insert(*ia+*ib&255);\n\tif(in[0]=='-') ne.insert(*ia-*ib&255);\n\tif(in[0]=='*') ne.insert(*ia**ib&255);\n\tif(in[0]=='/') {\n\t  if(*ib==0){\n\t    cout << \"error\" << endl;\n\t    return 0;\n\t  }\n\t  ne.insert(*ia/ *ib&255);\n\t}\n      }\n      st.push(ne);\n    }\n\n  }\n  cout << \"correct\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntypedef bitset<256>bs;\n\nint N;\nstring name[100];\nbs latte[100];\nsigned main(){\n    cin>>N;\n    rep(i,N){\n        cin>>name[i];\n        int l,r;\n        cin>>l>>r;\n        for(int j=l;j<=r;j++)latte[i][j]=1;\n    }\n\n    stack<bs>st;\n    int m;cin>>m;\n    while(m--){\n        string s;\n        cin>>s;\n        if(isdigit(s[0])){\n            int d;stringstream ss(s);ss>>d;\n            bs b;b[d]=1;\n            st.push(b);\n            continue;\n        }\n        if(isalpha(s[0])){\n            int d=find(name,name+N,s)-name;\n            st.push(latte[d]);\n            continue;\n        }\n\n        bs a,b;\n        b=st.top();st.pop();\n        a=st.top();st.pop();\n\n        if(s==\"/\"&&b[0]){\n            cout<<\"error\"<<endl;\n            return 0;\n        }\n        bs c;\n        rep(i,256)rep(j,256){\n            if(a[i]==0||b[j]==0)continue;\n            int t;\n            if(s==\"+\")t=(i+j)%256;\n            else if(s==\"-\")t=(i-j+256)%256;\n            else if(s==\"*\")t=i*j%256;\n            else if(s==\"/\")t=i/j;\n            c[t]=1;\n        }\n        st.push(c);\n    }\n    cout<<\"correct\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,P> range;\nstack<set<int> > num;\n\nint getNum(string s){\n  int res=0;\n  for(int i=0;i<s.size();i++)\n    res=res*10+s[i]-'0';\n  return res;\n}\n\nint main(){\n  int n,m,a,b;\n  string s;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s>>a>>b;\n    range[s]=P(a,b);\n  }\n  bool ans=false;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>s;\n    set<int> x;\n    if('0'<=s[0]&&s[0]<='9'){\n      x.insert(getNum(s));\n      num.push(x);\n    }\n    else if('a'<=s[0]&&s[0]<='z'){\n      P r=range[s];\n      for(int j=r.first;j<=r.second;j++)\n\tx.insert(j);\n      num.push(x);\n    }else{\n      set<int> B=num.top(); num.pop();\n      set<int> A=num.top(); num.pop();\n      set<int> C;\n      set<int>::iterator i1=A.begin();\n      set<int>::iterator i2=B.begin();\n      while(i1!=A.end()){\n\twhile(i2!=B.end()){\n\t  int n1=(*i1),n2=(*i2);\n\t  if(s==\"+\")C.insert((n1+n2)%256);\n\t  if(s==\"-\")C.insert((n1-n2+256)%256);\n\t  if(s==\"*\")C.insert((n1*n2)%256);\n\t  if(s==\"/\"){\n\t    if(!n2){\n\t      ans=true;\n\t      break;\n\t    }\n\t    C.insert((n1/n2)%256);\n\t  }\n\t  i2++;\n\t}\n\tif(ans)break;\n\ti1++;\n      }\n      if(ans)break;\n      num.push(C);\n    }\n  }\n  if(ans)cout<<\"error\"<<endl;\n  else cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint m;\nmap<string, bitset<256>> mp;\nint n;\nstring e[100];\n\nint main()\n{\n\tcin >> m;\n\tfor (int i = 0; i < m; i++){\n\t\tstring na;\n\t\tint lb, ub;\n\t\tcin >> na >> lb >> ub;\n\t\tbitset<256> bs;\n\t\tfor (int i = lb; i <= ub; i++){\n\t\t\tbs.set(i);\n\t\t}\n\t\tmp[na] = bs;\n\t}\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> e[i];\n\t}\n\t\n\tstack<bitset<256>> st;\n\tfor (int i = 0; i < n; i++){\n\t\tif (mp.count(e[i])){\n\t\t\tst.push(mp[e[i]]);\n\t\t}\n\t\telse if (isdigit(e[i][0])){\n\t\t\tbitset<256> r;\n\t\t\tr.set(atoi(e[i].c_str()));\n\t\t\tst.push(r);\n\t\t}\n\t\telse {\n\t\t\tbitset<256> b = st.top(); st.pop();\n\t\t\tbitset<256> a = st.top(); st.pop();\n\t\t\tbitset<256> r;\n\t\t\tfor (int j = 0; j < 256; j++){\n\t\t\t\tfor (int k = 0; k < 256; k++){\n\t\t\t\t\tif (!a.test(j) || !b.test(k)) continue;\n\t\t\t\t\tif (e[i] == \"+\") r.set((j + k) % 256);\n\t\t\t\t\telse if (e[i] == \"-\") r.set((j - k + 256) % 256);\n\t\t\t\t\telse if (e[i] == \"*\") r.set(j * k % 256);\n\t\t\t\t\telse if (e[i] == \"/\"){\n\t\t\t\t\t\tif (!k){\n\t\t\t\t\t\t\tcout << \"error\\n\";\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr.set(j / k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(r);\n\t\t}\n\t}\n\t\n\tbitset<256> bs = st.top();\n\tcout << \"correct\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <stack>\n#include <string>\nusing namespace std;\n\nbool is_valiable(string e){\n  for(int i = 0; i < (int)e.length(); ++i){\n    if(e[i] < '0' || e[i] > '9') return true;\n  }\n  return false;\n}\n\nint main(){\n  int m, mod = 256;\n  cin >> m;\n  string name;\n  int lb, ub;\n  map<string, vector<int> > M;\n  for(int i = 0; i < m; ++i){\n    cin >> name >> lb >> ub;\n    vector<int> t(mod,0);\n    for(int j = lb; j <= ub; ++j){\n      t[j] = 1;\n    }\n    M[name] = t;\n  }\n  \n  int n;\n  cin >> n;\n  string e, o = \"+-*/\";\n  stack<string> st;\n  for(int i = 0; i < n; ++i){\n    cin >> e;\n    if(o.find(e) < 4){\n      string b = st.top();st.pop();\n      string a = st.top();st.pop();\n      //cout << a << \" \" << b << endl;\n      if(e == \"+\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  //st.push(to_string((j+k)%mod));\n\t\t  t[(j+k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j+B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A+j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod+stoi(b)%mod)%mod));\n\t  }\n\t}\n      }else if(e == \"-\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j-k+mod)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j-B+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A-j+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod-stoi(b)%mod+mod)%mod));\n\t  }\n\t}\n      }else if(e == \"*\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j*k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j*B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A*j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string(((stoi(a)%mod)*(stoi(b)%mod))%mod));\n\t  }\n\t}\n      }else if(e == \"/\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  if(k == 0){\n\t\t    cout << \"error\" << endl;\n\t\t    return 0;\n\t\t  }\n\t\t  t[((j%mod)/(k%mod))%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n   \t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j/B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tif(j == 0){\n\t\t  cout << \"error\" << endl;\n\t\t  return 0;\n\t\t}\n\t\tt[(A/j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    st.push(to_string((stoi(a)/stoi(b))%mod));\n\t  }\n\t}\n      }\n    }else{\n      st.push(e);\n    }\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nmap<string, int> lbs;\nmap<string, int> ubs;\n\ntypedef vector<int> Number;\n\nNumber add(Number &a, Number &b) {\n  Number res(256);\n\n  for (int i=0; i<256; i++)\n    for (int j=0; j<256; j++)\n      if (a[i] && b[j]) res[(i+j)%256] = 1;\n\n  return res;\n}\n\nNumber sub(Number &a, Number &b) {\n  Number res(256);\n\n  for (int i=0; i<256; i++)\n    for (int j=0; j<256; j++)\n      if (a[i] && b[j]) res[(i-j+256)%256] = 1;\n\n  return res;\n}\n\nNumber mul(Number &a, Number &b) {\n  Number res(256);\n\n  for (int i=0; i<256; i++)\n    for (int j=0; j<256; j++)\n      if (a[i] && b[j]) res[(i*j)%256] = 1;\n\n  return res;\n}\n\nNumber div(Number &a, Number &b) {\n  Number res(256);\n\n  if (b[0]) {\n    puts(\"error\");\n    exit(0);\n  }\n\n  for (int i=0; i<256; i++)\n    for (int j=0; j<256; j++)\n      if (a[i] && b[j]) res[(i/j)%256] = 1;\n\n  return res;\n}\n\nbool isNumber(string s) {\n  for(char c : s) {\n    if (!isdigit(c)) return false;\n  }\n  return true;\n}\n\nNumber create(int l, int r) {\n  Number res(256);\n  for (int i=l; i<=r; i++) res[i] = 1;\n  return res;\n}\n\n\nint main(){\n  int N, M;\n\n  cin >> M;\n\n  for (int i=0; i<M; i++) {\n    string name;\n    int lb, ub;\n    cin >> name >> lb >> ub;\n    lbs[name] = lb;\n    ubs[name] = ub;\n  }\n\n  cin >> N;\n\n  stack<Number> st;\n\n  for (int i=0; i<N; i++) {\n    string e;\n    cin >> e;\n\n    if (e == \"+\" || e == \"-\" || e == \"*\" || e == \"/\") {\n      Number b = st.top(); st.pop();\n      Number a = st.top(); st.pop();\n\n      if (e == \"+\") st.push(add(a, b));\n      if (e == \"-\") st.push(sub(a, b));\n      if (e == \"*\") st.push(mul(a, b));\n      if (e == \"/\") st.push(div(a, b));\n    } else if (isNumber(e)){\n      int num = stoi(e);\n      st.push(create(num, num));\n    } else {\n      st.push(create(lbs[e], ubs[e]));\n    }\n  }\n\n  puts(\"correct\");\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nmap<string,set<int> > mp;\n\nstring random2(){\n\tstring w;\n\tfor(int i = 0 ; i < 100 ; i++)\n\t\tw += rand() % 26 + 'a';\n\treturn w;\n}\n\nstring itos(int n){\n\tstringstream ss;\n\tss << n;\n\treturn ss.str();\n}\nbool inte(string s){\n\treturn '0' <= s[0] && s[0] <= '9';\n}\nbool ope(string s){\n\treturn s == \"+\" || s == \"*\" || s == \"/\" || s == \"-\";\n}\nbool var(string s){\n\treturn !inte(s) && !ope(s);\n}\nset<int> val(string s){\n\tif( inte(s) ) return set<int>{atoi(s.c_str())};\n\treturn mp[s];\n}\nset<int> operator + (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A+B)%256);\n\t\t}\n\t}\n\treturn C;\n}\nset<int> operator / (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A/B)%256);\n\t\t}\n\t}\n\treturn C;\n}\n\nset<int> operator * (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A*B)%256);\n\t\t}\n\t}\n\treturn C;\n}\n\nset<int> operator - (set<int> a,set<int> b){\n\tset<int> C;\n\tfor( auto A : a ){\n\t\tfor( auto B : b ){\n\t\t\tC.insert((A-B+256)%256);\n\t\t}\n\t}\n\treturn C;\n}\n\n\n\nbool calc(vector<string> e){\n\tstack<string> s;\n\tfor( int i = 0 ; i < e.size() ; i++){\n\t  if( inte(e[i]) ){\n\t\ts.push(e[i]);\n\t  }\n\t  if( var(e[i]) ){\n\t\ts.push(e[i]);\n\t  }\n\t  if( ope(e[i]) ){\n\t\tstring b = s.top(); s.pop();\n\t\tstring a = s.top(); s.pop();\n\t\tset<int> B = val(b);\n\t\tset<int> A = val(a);\n\t\tset<int> R;\n\t\tif( e[i] == \"+\" ){\n\t\t\tR = A+B;\n\t\t}else if( e[i] == \"-\" ){\n\t\t\tR = A-B;\n\t\t}else if( e[i] == \"*\" ){\n\t\t\tR = A*B;\n\t\t}else if( e[i] == \"/\" ){\n\t\t\tif( B.count(0) ) return 0;\n\t\t\tR = A/B;\n\t\t}\n\t\tstring name = random2();\n\t\tmp[name] = R;\n\t\ts.push(name);\n\t  }\n\t}\n\treturn 1;\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tstring s;\n\t\tint x,y;\n\t\tcin >> s >> x >> y;\n\t\tfor(int j = x ; j <= y ; j++) mp[s].insert(j);\n\t}\n\tint n;\n\tcin >> n;\n\tvector<string> e;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\te.push_back(s);\n\t}\n\t\n\tif( calc(e) ){\n\t\tcout << \"correct\" << endl;\n\t}else{\n\t\tcout << \"error\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tleast = most = number = -1;\n\t\tisVariable = false;\n\t}\n\tInfo(int arg_least,int arg_most,int arg_number,bool arg_is_val){\n\t\tleast = arg_least;\n\t\tmost = arg_most;\n\t\tnumber = arg_number;\n\t\tisVariable = arg_is_val;\n\t}\n\n\tchar name[21];\n\tint least,most,number;\n\tbool isVariable;\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n\nint main(){\n\n\tint num,N;\n\tscanf(\"%d\",&num);\n\tInfo vals[num];\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%s %d %d\",vals[i].name,&vals[i].least,&vals[i].most);\n\t}\n\n\tstack<Info> S;\n\n\tscanf(\"%d\",&N);\n\n\tint tmp,least,most;\n\tchar buf[21];\n\tbool correct = true;\n\tInfo op1,op2;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\n\t\tif(buf[0] == '+' || buf[0] == '*' || buf[0] == '/' || buf[0] == '-'){\n\t\t\tif(S.empty()){\n\t\t\t\tcorrect = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top2 = S.top();\n\t\t\tS.pop();\n\t\t\tif(S.empty()){\n\t\t\t\tcorrect = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\top1 = S.top();\n\t\t\tS.pop();\n\n\t\t\tswitch(buf[0]){\n\t\t\tcase '+':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number+op2.number)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k+p)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k+p)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k+op1.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k+op1.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k+op2.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k+op2.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tif(op2.number == 0){\n\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number/op2.number)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tif(op2.least == 0){\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k/p)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k/p)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tif(op2.least == 0){\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(op1.number/k)%256);\n\t\t\t\t\t\t\tmost = max(most,(op1.number/k)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tif(op2.number == 0){\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k/op2.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k/op2.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number-op2.number+256)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k-p+256)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k-p+256)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(op1.number-k+256)%256);\n\t\t\t\t\t\t\tmost = max(most,(op1.number-k+256)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k-op2.number+256)%256);\n\t\t\t\t\t\t\tmost = max(most,(k-op2.number+256)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number*op2.number)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k*p)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k*p)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(op1.number*k)%256);\n\t\t\t\t\t\t\tmost = max(most,(op1.number*k)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k*op2.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k*op2.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tInfo info;\n\t\t\t\tinfo.isVariable = false;\n\t\t\t\tinfo.number = tmp;\n\t\t\t\tS.push(info);\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\t\tif(strCmp(buf,vals[k].name)){\n\t\t\t\t\t\tInfo info;\n\t\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\t\tinfo.least = vals[k].least;\n\t\t\t\t\t\tinfo.most = vals[k].most;\n\t\t\t\t\t\tstrcpy(info.name,buf);\n\t\t\t\t\t\tS.push(info);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!correct)break;\n\t}\n\n\tif(correct){\n\t\tprintf(\"correct\\n\");\n\t}else{\n\t\tprintf(\"error\\n\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>P;\n#define r(i,n) for(int i=0;i<n;i++)\nmap<string,P>M;\nint m,low,high;\nstring name,s;\nstack<vector<int> >st;\nvoid END(){\n  cout<<\"error\"<<endl;\n  exit(0);\n}\nvoid in_num(){\n  vector<int>v;\n  int res=0;\n  r(i,s.size())res=res*10+(s[i]-'0'),res=res%256;\n  v.push_back(res);\n  st.push(v);\n}\nvoid in_string(){\n  vector<int>v;\n  int t1=M[s].first;\n  int t2=M[s].second;\n  for(int i=t1;i<=t2;i++)v.push_back(i);\n  st.push(v);\n}\nvoid sol1(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]+v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol2(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]-v2[j];\n      t=(t+256)%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol3(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]*v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol4(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      if(v2[j]==0)END();\n      int t=v1[i]/v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nint main(){\n  cin>>m;\n  r(i,m){\n    cin>>name>>low>>high;\n    M[name]=P(low,high);\n  }\n  cin>>m;\n  while(m--){\n    cin>>s;\n    if(isdigit(s[0]))in_num();\n    else if(isalpha(s[0]))in_string();\n    else{\n      if(s==\"+\")sol1();\n      if(s==\"-\")sol2();\n      if(s==\"*\")sol3();\n      if(s==\"/\")sol4();\n    }\n  }\n  cout<<\"correct\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nbool solve(vector<string> &ops, map<string, P> &vs){\n  vector< set<int> > v;\n  for(string s : ops){\n    set<int> tmp;\n    if(vs.find(s) != vs.end()) FOR(i, vs[s].first, vs[s].second + 1) tmp.insert(i);\n    else if(isdigit(s[0])) tmp.insert(atoi(s.c_str()));\n    else if(s == \"+\") {\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x + y;\n          while(n >= 256) n -= 256;\n          tmp.insert(n);\n        }\n      }\n    } else if(s == \"-\"){\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x - y;\n          while(n < 0) n += 256;\n          tmp.insert(n);\n        }\n      }\n    } else if(s == \"*\"){\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x * y;\n          while(n >= 256) n -= 256;\n          tmp.insert(n);\n        }\n      }\n    } else if(s == \"/\"){\n      set<int> b = v.back(); v.pop_back();\n      set<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          if(y == 0) return false;\n          int n = x / y;\n          while(n >= 256) n -= 256;\n          tmp.insert(n);\n        }\n      }\n    }\n    v.push_back(tmp);\n  }\n  return true;\n}\n\nint main() {\n  int M; cin >>M;\n  map<string, P> vs;\n  REP(i, M){\n    string s; cin >>s;\n    int l, u; cin >>l >>u;\n    vs[s] = P(l, u);\n  }\n  int N; cin >>N;\n  vector<string> ops(N);\n  REP(i, N) cin >>ops[i];\n  cout <<(solve(ops, vs) ? \"correct\" : \"error\")  <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\ntypedef vector<uc> vec;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  stack<vec> sc;\n  for(int i=0;!f&&i<n;i++){\n    //cout<<i<<\":\"<<ss[i]<<endl;\n    if(ms.find(ss[i])!=ms.end()){ \n      int j=ms[ss[i]];\n      vec t;\n      for(int k=l[j];k<=r[j];k++) t.push_back((uc)k);\n      sc.push(t);\n    }else if(isdigit(ss[i][0])){\n      uc a=0;\n      for(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n      sc.push(vec(1,a));\n    }else{\n      vec t,a,b;\n      b=sc.top();sc.pop();\n      a=sc.top();sc.pop();\n      for(int j=0;!f&&j<(int)b.size();j++){\n\tfor(int k=0;!f&&k<(int)a.size();k++){\n\t  if(ss[i]==\"+\") t.push_back(a[k]+b[j]);\n\t  if(ss[i]==\"-\") t.push_back(a[k]-b[j]);\n\t  if(ss[i]==\"*\") t.push_back(a[k]*b[j]);\n\t  if(ss[i]==\"/\"){\n\t    if(b[j]) t.push_back(a[k]/b[j]);\n\t    else{\n\t      f=1;\n\t      break;\n\t    }\n\t  }\n\t}\n      }\n      sort(t.begin(),t.end());\n      t.erase(unique(t.begin(),t.end()),t.end());\n      sc.push(t);\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);--i)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();++i)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nbool num[128][256];\nint m, n;\nmap<string,pair<int,int> > bound;\nstring op = \"+-*/\";\n\nint main()\n{\n    memset(num,0,sizeof(num));\n    cin >> m;\n    rep(i,m){\n\tstring name;\n\tint lb, ub;\n\tcin >> name >> lb >> ub;\n\tbound[name] = mp(lb,ub);\n    }    \n    cin >> n;\n    stack<int> st;\n    rep(i,n){\n\tstring e;\n\tcin >> e;\n\tif(op.find(e) == string::npos){\n\t    if(bound.find(e) != bound.end())\n\t\tfor(int j = bound[e].first; j <= bound[e].second; j++)\n\t\t    num[i][j] = true;\n\t    else\n\t\tnum[i][atoi(e.c_str()) & 255] = true;\n\t}else{\n\t    int b = st.top(); st.pop();\n\t    int a = st.top(); st.pop();\n\t    if(e == \"+\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j + k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"-\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j - k + 256) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"*\"){\n\t\trep(j,256)rep(k,256){\n\t\t    num[i][(j * k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t    if(e == \"/\"){\n\t\tif(num[b][0]) {\n\t\t    cout << \"error\\n\";\n\t\t    return 0;\n\t\t}\n\t\trep(j,256)repi(k,1,256){\n\t\t    num[i][(j / k) % 256] |= num[a][j] & num[b][k];\n\t\t}\n\t    }\n\t}\n\tst.push(i);\n    }\n    cout << \"correct\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <stack>\n#include <map>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct A{\n\tbool a[256];\n\tA(){\n\t\tfor(int i = 0; i < 256; i++) a[i] = false;\n\t}\n\tA(llint x){\n\t\tfor(int i = 0; i < 256; i++) a[i] = false;\n\t\ta[x] = true;\n\t}\n};\n\nllint m, n;\nmap<string, P> mp;\nstack<A> stk;\n\nA add(A a, A b)\n{\n\tA ret;\n\tfor(int i = 0; i < 256; i++){\n\t\tfor(int j = 0; j < 256; j++){\n\t\t\tif(a.a[i] && b.a[j]) ret.a[(i+j)%256] = true;\n\t\t}\n\t}\n\treturn ret;\n}\nA sub(A a, A b)\n{\n\tA ret;\n\tfor(int i = 0; i < 256; i++){\n\t\tfor(int j = 0; j < 256; j++){\n\t\t\tif(a.a[i] && b.a[j]) ret.a[(i-j+256)%256] = true;\n\t\t}\n\t}\n\treturn ret;\n}\nA mul(A a, A b)\n{\n\tA ret;\n\tfor(int i = 0; i < 256; i++){\n\t\tfor(int j = 0; j < 256; j++){\n\t\t\tif(a.a[i] && b.a[j]) ret.a[(i*j)%256] = true;\n\t\t}\n\t}\n\treturn ret;\n}\nA divi(A a, A b)\n{\n\tA ret;\n\tfor(int i = 0; i < 256; i++){\n\t\tfor(int j = 0; j < 256; j++){\n\t\t\tif(a.a[i] && b.a[j]) ret.a[(i/j)%256] = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> m;\n\tllint lb, ub; string s;\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> s >> lb >> ub;\n\t\tmp[s] = P(lb, ub);\n\t}\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> s;\n\t\t//cout << s << endl;\n\t\tif(s == \"+\"){\n\t\t\tA b = stk.top(); stk.pop();\n\t\t\tA a = stk.top(); stk.pop();\n\t\t\tstk.push(add(a, b));\n\t\t}\n\t\telse if(s == \"-\"){\n\t\t\tA b = stk.top(); stk.pop();\n\t\t\tA a = stk.top(); stk.pop();\n\t\t\tstk.push(sub(a, b));\n\t\t}\n\t\telse if(s == \"*\"){\n\t\t\tA b = stk.top(); stk.pop();\n\t\t\tA a = stk.top(); stk.pop();\n\t\t\tstk.push(mul(a, b));\n\t\t}\n\t\telse if(s == \"/\"){\n\t\t\tA b = stk.top(); stk.pop();\n\t\t\tA a = stk.top(); stk.pop();\n\t\t\tif(b.a[0]){\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstk.push(divi(a, b));\n\t\t}\n\t\telse if(s[0] >= '0' && s[0] <= '9'){\n\t\t\tllint x = atoi(s.c_str());\n\t\t\tstk.push(A(x % 256));\n\t\t}\n\t\telse{\n\t\t\tllint lb = mp[s].first, ub = mp[s].second;\n\t\t\tA a;\n\t\t\tfor(int j = lb; j <= ub; j++) a.a[j] = true;\n\t\t\tstk.push(a);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  time_t start=clock();\n  srand((unsigned)time(NULL));\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.7&&!f){\n    stack<uc> sc;\n    for(int i=0;!f&&i<n;i++){\n      //cout<<i<<\":\"<<ss[i]<<endl;\n      if(ms.find(ss[i])!=ms.end()){ \n\tint j=ms[ss[i]],k=l[j];\n\tif(r[j]!=l[j]) k+=(rand()%(r[j]-l[j]));\n\t//cout<<ss[i]<<\":\"<<k<<endl;\n\tsc.push(k);\n      }else if(isdigit(ss[i][0])){\n\tuc a=0;\n\tfor(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n\tsc.push(a);\n      }else{\n\tuc a,b;\n\tb=sc.top();sc.pop();\n\ta=sc.top();sc.pop();\n\tif(ss[i]==\"+\") sc.push(a+b);\n\tif(ss[i]==\"-\") sc.push(a-b);\n\tif(ss[i]==\"*\") sc.push(a*b);\n\tif(ss[i]==\"/\"){\n\t  if(b) sc.push(a/b);\n\t  else{\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tmap<string, pair<int, int>> variables;\n\tREP(i, n) {\n\t\tstring a;\n\t\tint b, c;\n\t\tcin >> a >> b >> c;\n\t\tvariables[a] = mp(b, c);\n\t}\n\tstack<set<int>> now_stack;\n\tint m;\n\tcin >> m;\n\tREP(te, m) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s[0] >= '0' && s[0] <= '9') {\n\t\t\tnow_stack.push(set<int>{stoll(s)});\n\t\t}\n\t\telse if(variables.find(s) != variables.end()) {\n\t\t\tset<int> geko;\n\t\t\tfor (int q = variables[s].first; q <= variables[s].second; ++q) {\n\t\t\t\tgeko.insert(q);\n\t\t\t}\n\t\t\tnow_stack.push(geko);\n\t\t}\n\t\telse {\n\t\t\tset<int> now[2];\n\t\t\tnow[0] = now_stack.top();\n\t\t\tnow_stack.pop();\n\t\t\tnow[1] = now_stack.top();\n\t\t\tnow_stack.pop();\n\t\t\tset<int> result;\n\t\t\tfor (auto x : now[1]) {\n\t\t\t\tfor (auto y : now[0]) {\n\t\t\t\t\tif (s == \"+\") {\n\t\t\t\t\t\tresult.insert((x + y) % 256);\n\t\t\t\t\t}\n\t\t\t\t\telse if (s == \"-\") {\n\t\t\t\t\t\tresult.insert((x - y + 256) % 256);\n\t\t\t\t\t}\n\t\t\t\t\telse if (s == \"*\") {\n\t\t\t\t\t\tresult.insert((x * y) % 256);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (y == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.insert((x / y) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnow_stack.push(result);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <map>\n#include <sstream>\n#include <iostream>\n#include <stack>\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nmap<string,P> data;\nstring str[101];\nstruct var{\n\tstring str;\n\tbool a[257];\n};\n\nbool check(){\n\tstack<var> s;\n\tfor(int i=0;i<n;i++){\n\t\tif(data.find(str[i])!=data.end()){\n\t\t\tvar da;\n\t\t\tda.str=\"\";\n\t\t\tmemset(da.a,false,sizeof(da.a));\n\t\t\tfor(int j=data[str[i]].first;j<=data[str[i]].second;j++){\n\t\t\t\tda.a[j]=true;\n\t\t\t}\n\t\t\ts.push(da);\n\t\t}else{\n\t\t\tif(str[i][0]>='0' && str[i][0]<='9'){\n\t\t\t\tvar da;\n\t\t\t\tda.str=\"\";\n\t\t\t\tmemset(da.a,false,sizeof(da.a));\n\t\t\t\tint num=0;\n\t\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\t\tnum=(num*10+str[i][j]-'0')%256;\n\t\t\t\t}\n\t\t\t\tda.a[num]=true;\n\t\t\t\ts.push(da);\n\t\t\t}else if(str[i]==\"+\"){\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar b=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar a=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tvar next;\n\t\t\t\tmemset(next.a,false,sizeof(next.a));\n\t\t\t\tfor(int j=0;j<256;j++){\n\t\t\t\t\tif(!b.a[j])continue;\n\t\t\t\t\tfor(int k=0;k<256;k++){\n\t\t\t\t\t\tif(!a.a[k])continue;\n\t\t\t\t\t\tnext.a[(j+k)%256]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.push(next);\n\n\t\t\t}else if(str[i]==\"-\"){\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar b=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar a=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tvar next;\n\t\t\t\tmemset(next.a,false,sizeof(next.a));\n\t\t\t\tfor(int j=0;j<256;j++){\n\t\t\t\t\tif(!b.a[j])continue;\n\t\t\t\t\tfor(int k=0;k<256;k++){\n\t\t\t\t\t\tif(!a.a[k])continue;\n\t\t\t\t\t\tnext.a[(k-j+256)%256]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.push(next);\n\n\t\t\t}else if(str[i]==\"*\"){\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar b=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar a=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tvar next;\n\t\t\t\tmemset(next.a,false,sizeof(next.a));\n\t\t\t\tfor(int j=0;j<256;j++){\n\t\t\t\t\tif(!b.a[j])continue;\n\t\t\t\t\tfor(int k=0;k<256;k++){\n\t\t\t\t\t\tif(!a.a[k])continue;\n\t\t\t\t\t\tnext.a[(k*j+256)%256]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.push(next);\n\n\t\t\t}else if(str[i]==\"/\"){\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar b=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tif(s.size()==0)return false;\n\t\t\t\tvar a=s.top();\n\t\t\t\ts.pop();\n\t\t\t\tvar next;\n\t\t\t\tmemset(next.a,false,sizeof(next.a));\n\t\t\t\tfor(int j=0;j<256;j++){\n\t\t\t\t\tif(!b.a[j])continue;\n\t\t\t\t\tfor(int k=0;k<256;k++){\n\t\t\t\t\t\tif(!a.a[k])continue;\n\t\t\t\t\t\tif(j==0)return false;\n\t\t\t\t\t\tnext.a[(k/j)%256]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d%*c\",&m);\n\tfor(int i=0;i<m;i++){\n\t\tstring inp;\n\t\tint l=0,r=0;\n\t\tcin >> inp >> l >> r;\n\t\tdata[inp]=P(l,r);\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tcin >> str[i];\n\t}\n\tprintf(\"%s\\n\",check()?\"correct\":\"error\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <stack>\n#include <string>\nusing namespace std;\n\nbool is_valiable(string e){\n  for(int i = 0; i < (int)e.length(); ++i){\n    if(e[i] < '0' || e[i] > '9') return true;\n  }\n  return false;\n}\n\nint main(){\n  int m, mod = 256;\n  cin >> m;\n  string name;\n  int lb, ub;\n  map<string, vector<int> > M;\n  for(int i = 0; i < m; ++i){\n    cin >> name >> lb >> ub;\n    vector<int> t(mod,0);\n    for(int j = lb; j <= ub; ++j){\n      t[j] = 1;\n    }\n    M[name] = t;\n  }\n  \n  int n;\n  cin >> n;\n  string e, o = \"+-*/\";\n  stack<string> st;\n  for(int i = 0; i < n; ++i){\n    cin >> e;\n    if(o.find(e) < 4){\n      string b = st.top();st.pop();\n      string a = st.top();st.pop();\n      //cout << a << \" \" << b << endl;\n      if(e == \"+\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  //st.push(to_string((j+k)%mod));\n\t\t  t[(j+k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j+B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A+j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod+stoi(b)%mod)%mod));\n\t  }\n\t}\n      }else if(e == \"-\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j-k+mod)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j-B+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A-j+mod)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string((stoi(a)%mod-stoi(b)%mod+mod)%mod));\n\t  }\n\t}\n      }else if(e == \"*\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  t[(j*k)%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j*B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tt[(A*j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    st.push(to_string(((stoi(a)%mod)*(stoi(b)%mod))%mod));\n\t  }\n\t}\n      }else if(e == \"/\"){\n\tif(is_valiable(a)){\n\t  if(is_valiable(b)){\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      for(int k = 0; k < mod; ++k){\n\t\tif(M[a][j] && M[b][k]){\n\t\t  if(k == 0){\n\t\t    cout << \"error\" << endl;\n\t\t    return 0;\n\t\t  }\n\t\t  t[((j%mod)/(k%mod))%mod] = 1;\n\t\t}\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    int B = stoi(b)%mod;\n\t    vector<int> t(mod,0);\n   \t    for(int j = 0; j < mod; ++j){\n\t      if(M[a][j]){\n\t\tt[(j/B)%mod] = 1;\n\t      }\n\t    }\n\t    M[a] = t;\n\t    st.push(a);\n\t  }\n\t}else{\n\t  if(is_valiable(b)){\n\t    int A = stoi(a)%mod;\n\t    vector<int> t(mod,0);\n\t    for(int j = 0; j < mod; ++j){\n\t      if(M[b][j]){\n\t\tif(j == 0){\n\t\t  cout << \"error\" << endl;\n\t\t  return 0;\n\t\t}\n\t\tt[(A/j)%mod] = 1;\n\t      }\n\t    }\n\t    M[b] = t;\n\t    st.push(b);\n\t  }else{\n\t    if(b == \"0\"){\n\t      cout << \"error\" << endl;\n\t      return 0;\n\t    }\n\t    st.push(to_string((stoi(a)/stoi(b))%mod));\n\t  }\n\t}\n      }\n    }else{\n      st.push(e);\n    }\n  }\n  cout << \"correct\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l <= 1 ? MAX-1 : vec[l-2]);\n    int v2 = (l == 0 ? MAX-1 : vec[l-1]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n            \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int64_t Int;\n#define all(x) (x).begin(), (x).end()\n \nconst double EPS = 1e-10;\nconst Int INF = 1e18;\nconst int inf = 1e9;\nconst Int mod = 1e9+7;\n\nbool print_space_enable = false;\nvoid print() { \n    cout << endl; \n    print_space_enable = false;\n}\n\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n    if (print_space_enable) cout << \" \";\n    cout << fixed << setprecision(15) << head;\n    print_space_enable = true;\n    print(std::forward<Tail>(tail)...);\n}\n\ntemplate<typename T>\nvoid print(vector<T> v) {\n    for (size_t i = 0; i < v.size(); i++) {\n        if (i > 0) std::cout << \" \";\n        std::cout << v[i];\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    Int m;\n    cin >> m;\n    map<string, pair<Int, Int>> mp;\n    for (Int i = 0; i < (Int)m; i++) {\n        string a;\n        Int x, y;\n        cin >> a >> x >> y;\n        mp[a] = {x, y};\n    }\n    Int n;\n    cin >> n;\n    stack<vector<bool>> st;\n    for (Int i = 0; i < (Int)n; i++) {\n        string s;\n        cin >> s;\n        vector<bool> v(256, false);\n        if (isdigit(s[0])) {\n            v[stoll(s)] = true;\n            st.push(v);\n        } else if (isalpha(s[0])) {\n            for (Int j = mp[s].first; j <= (Int)mp[s].second; j++) {\n                v[j] = true;\n            }\n            st.push(v);\n        } else {\n            vector<bool> b = st.top();\n            st.pop();\n            vector<bool> a = st.top();\n            st.pop();\n            if (s[0] == '+') {\n                for (Int j = 0; j < (Int)256; j++) {\n                    if (not a[j]) continue;\n                    for (Int k = 0; k < (Int)256; k++) {\n                        if (not b[k]) continue;\n                        v[(j + k) % 256] = true;\n                    }\n                }\n            }\n            if (s[0] == '-') {\n                for (Int j = 0; j < (Int)256; j++) {\n                    if (not a[j]) continue;\n                    for (Int k = 0; k < (Int)256; k++) {\n                        if (not b[k]) continue;\n                        v[(j - k + 256) % 256] = true;\n                    }\n                }\n            }   \n            if (s[0] == '*') {\n                for (Int j = 0; j < (Int)256; j++) {\n                    if (not a[j]) continue;\n                    for (Int k = 0; k < (Int)256; k++) {\n                        if (not b[k]) continue;\n                        v[(j * k) % 256] = true;\n                    }\n                }\n            }\n            if (s[0] == '/') {\n                for (Int j = 0; j < (Int)256; j++) {\n                    if (not a[j]) continue;\n                    for (Int k = 0; k < (Int)256; k++) {\n                        if (not b[k]) continue;\n                        if (k == 0) {\n                            print(\"error\");\n                            return 0;\n                        }\n                        v[(j / k) % 256] = true;\n                    }\n                }\n            }\n            st.push(v);\n        }\n    }\n    print(\"correct\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(abs((*it_a)-(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(double)(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 500\ntypedef long long ll;\ntypedef pair<ll, ll> pii;\n \nll n;\nvector<string> e;\nmap<string, pii> mp;\n \nll op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nll s2i(string &s)\n{\n    ll res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nll memo[MAX][MAX];\n\nbool zero_division_checker(ll x, stack<ll> st)\n{\n    if (x == n) {\n        return true;\n    }\n    ll v = (st.empty() ? n : st.top());\n    if (memo[x][v] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        ll op = op_num(e[x][0]);\n        if (op >= 0) {\n            ll b = st.top(); st.pop();\n            ll a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res &= zero_division_checker(x+1, st);\n        } else {\n            pii p = mp[e[x]];\n            for (ll i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return (memo[x][v] = res);\n}\n \nint main()\n{\n    ll m;\n    cin >> m;\n    string name;\n    ll lb, ub;\n    for (ll i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (ll i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<ll>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n    int v = (st.empty() ? n : st.top());\n    int s = st.size();\n    if (memo[x][v][s] != -1) {\n        return memo[x][v][s];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res &= zero_division_checker(x+1, st);\n            st.pop();\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return (memo[x][v][s] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 101;\nint m, n;\nmap<string, int> lb, ub;\nstring e[MAXN];\n\nint main() {\n  while(cin >> m) {\n    lb.clear(); ub.clear();\n    for(int i = 0; i < m; ++i) {\n      string name; cin >> name;\n      cin >> lb[name] >> ub[name];\n    }\n    cin >> n;\n    for(int i = 0; i < n; ++i) cin >> e[i];\n    try {\n      stack<vector<int> > stk;\n      for(int i = 0; i < n; ++i) {\n        const string &s = e[i];\n        if(isdigit(s[0])) {\n          vector<int> v(256);\n          v[atoi(s.c_str())] = 1;\n          stk.push(v);\n        } else if(isalpha(s[0])) {\n          vector<int> v(256);\n          for(int i = lb[s]; i <= ub[s]; ++i) v[i] = 1;\n          stk.push(v);\n        } else {\n          vector<int> a, b, v(256);\n          b = stk.top(); stk.pop();\n          a = stk.top(); stk.pop();\n          for(int i = 0; i < a.size(); ++i) {\n            if(!a[i]) continue;\n            for(int j = 0; j < b.size(); ++j) {\n              if(!b[j]) continue;\n              if(s[0] == '+') {\n                v[(i+j)%256] = 1;\n              } else if(s[0] == '-') {\n                v[(i-j+256)%256] = 1;\n              } else if(s[0] == '*') {\n                v[i*j%256] = 1;\n              } else if(s[0] == '/') {\n                if(j == 0) throw 0;\n                v[i/j] = 1;\n              }\n            }\n          }\n          stk.push(v);\n        }\n      }\n      cout << \"correct\" << endl;\n    } catch(...) {\n      cout << \"error\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n  int m;\n  cin>>m;\n  map<string,bitset<256> > val;\n  REP(i,m) {\n    string name;\n    int minv, maxv;\n    cin>>name>>minv>>maxv;\n    bitset<256> bs;\n    REP(j,256)\n      bs[j] = false;\n    FOR(j,minv,maxv+1)\n      bs[j] = true;\n    val[name] = bs;\n  }\n  stack<bitset<256> > stk;\n  int n;\n  cin>>n;\n  bool flag = false;\n  REP(i,n) {\n    string str;\n    cin>>str;\n    if(val.find(str) != val.end())\n      stk.push(val[str]);\n    else if(str == \"/\") {\n      if(stk.top()[0]) {\n        flag = true;\n        break;\n      }else{\n        bitset<256> bs,lhs,rhs;\n        REP(j,256)bs[j] = false;\n        rhs = stk.top();stk.pop();\n        lhs = stk.top();stk.pop();\n        REP(j,256)REP(k,256) {\n          if(lhs[j] && rhs[k])\n          bs[(j/k)%256] = true;\n        }\n        stk.push(bs);\n      }\n    }else if(str == \"*\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j*k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"+\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j+k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"-\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(256+j-k)%256] = true;\n      }\n      stk.push(bs);\n    } else {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      bs[atoi(str.c_str())] = true;\n      stk.push(bs);\n    }\n  }\n  if(flag)\n    cout<<\"error\"<<endl;\n  else\n    cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\nusing namespace std;\n\nint calc(int a, int b, string op){\n    if(op == \"+\") return (a + b) % 256;\n    if(op == \"-\") return (a - b + 256) % 256;\n    if(op == \"*\") return (a * b) % 256;\n    if(op == \"/\") return (a / b) % 256;\n    return -1;\n}\n\nint main(){\n    int m;\n    cin >> m;\n    map<string, bitset<256> > v;\n    for(int i=0; i<m; i++){\n        string name;\n        int lb, ub;\n        cin >> name >> lb >> ub;\n        bitset<256> r;\n        for(int j=lb; j<=ub; j++){\n            r[j] = 1;\n        }\n        v[name] = r;\n    }\n    map<string, bool> number;\n    for(int i=0; i<256; i++){\n        bitset<256> a;\n        a[i] = 1;\n        v[to_string(i)] = a;\n        number[to_string(i)] = true;\n    }   \n\n    int n;\n    cin >> n;\n    stack<string> s;\n    bool success = true;\n    for(int i=0; i<n; i++){\n        string str;\n        cin >> str;\n        if(!success) continue;\n        if(str == \"+\" || str == \"-\" || str == \"*\" || str == \"/\"){\n            string b = s.top();\n            s.pop();\n            string a = s.top();\n            s.pop();\n            if(str == \"/\" && v[b][0]==1){\n                success = false;\n                continue;\n            }\n            if(number.count(a)!=0 && number.count(b)!=0){\n                s.push(to_string(calc(stoi(a), stoi(b), str)));\n            }else{\n                bitset<256> newrange;\n                string newname;\n                if(number.count(a)==0) newname = a;\n                else newname = b;\n                for(int j=0; j<256; j++){\n                    for(int k=0; k<256; k++){\n                        if(v[a][j]==1 && v[b][k]==1){\n                            newrange[calc(j, k, str)] = 1;\n                        }\n                    }\n                }\n                v[newname] = newrange;\n                s.push(newname);\n            }\n        }else{\n            s.push(str);\n        }   \n    }\n\n    if(success){\n        cout << \"correct\" << endl;\n    }else{\n        cout << \"error\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<stack>\n#include<array>\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n\ntypedef long long ll;\nmap<string,array<int,256> >data;\nconst int INF=1e9+7;\nint main(){\n\tint m;\n\tbool f=true;\n\tcin>>m;\n\trep(i,m){\n\t\tstring str;\n\t\tcin>>str;\n\t\tint l,u;\n\t\tcin>>l>>u;\n\t\tFOR(i,l,u+1){\n\t\t\tdata[str][i]=1;\n\t\t}\n\t}\n\tint n;\n\tcin>>n;\n\tstack<array<int,256> > st;\n\trep(k,n){\n\t\tstring str;\n\t\tcin>>str;\n\t\tif(str==\"0\" || atoi(str.c_str())>0){\n\t\t\tint num=atoi(str.c_str());\n\t\t\tarray<int,256>num_a;\n\t\t\trep(i,256)num_a[i]=0;\n\t\t\tnum_a[num]=1;\n\t\t\tst.push(num_a);\n\t\t}\n\t\telse if(str==\"+\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i+j)%256]|=(r[i]&l[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"-\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256){\n\t\t\t\trep(j,256){\n\t\t\t\t\tne[(i-j+256)%256]|=(l[i]&r[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"*\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\trep(i,256)rep(j,256)ne[(i*j)%256]|=(r[i]&l[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse if(str==\"/\"){\n\t\t\tarray<int,256> ne,l,r;\n\t\t\tfill(ne.begin(),ne.end(),0);\n\t\t\tr=st.top();st.pop();\n\t\t\tl=st.top();st.pop();\n\t\t\tif(r[0]==1){\n\t\t\t\tf=false;\n\t\t\t}\n\t\t\trep(i,256)FOR(j,1,256)ne[(i/j)%256]|=(l[i]&r[j]);\n\t\t\tst.push(ne);\n\t\t}\n\t\telse {\n\t\t\tst.push(data[str]);\n\t\t}\n\t}\n\tif(f)cout<<\"correct\"<<endl;\n\telse cout<<\"error\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <queue>\n#include <set>\n#include <stack>\nusing namespace std;\n\nstruct Number{\n  vector<int> cand;\n  Number(int s, int e){\n    for(int i = s; i <= e; i++)\n      cand.push_back(i);\n  }\n  Number(int n){\n    cand.push_back(n);\n  }\n  Number(){}\n};\n\nNumber operator + (const Number &lhs, const Number &rhs){\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    ret.cand.push_back((lhs.cand[i] + rhs.cand[j]) % 256);\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.end()), ret.cand.end());\n  }\n  return ret;\n}\n\nNumber operator - (const Number &lhs, const Number &rhs){\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    ret.cand.push_back((lhs.cand[i] - rhs.cand[j] + 256) % 256);\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.end()), ret.cand.end());\n  }\n  return ret;\n}\n\nNumber operator * (const Number &lhs, const Number &rhs){\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    ret.cand.push_back((lhs.cand[i] * rhs.cand[j]) % 256);\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.end()), ret.cand.end());\n  }\n  return ret;\n}\n\nNumber operator / (const Number &lhs, const Number &rhs){\n  Number ret;\n  REP(i,lhs.cand.size()) REP(j,rhs.cand.size()){\n    if(rhs.cand[j] == 0) throw 0;\n    ret.cand.push_back((lhs.cand[i] / rhs.cand[j]) % 256);\n    sort(ret.cand.begin(), ret.cand.end());\n    ret.cand.erase(unique(ret.cand.begin(), ret.cand.end()), ret.cand.end());\n  }\n  return ret;\n}\n\nint main(){\n  stack<Number> st;\n  const int m = getInt();\n  map<string, Number> v;\n\n  REP(i,m){\n    char buff[256];\n    int lb, ub;\n    scanf(\"%s%d%d\", buff, &lb, &ub);\n    v[buff] = Number(lb, ub);\n  }\n\n  const int n = getInt();\n\n  try{\n    REP(i,n){\n      char buff[256];\n      scanf(\"%s\", buff);\n      if(v.count(buff)){\n        st.push(v[buff]);\n      }else if(!isdigit(*buff)){\n        const Number rhs = st.top(); st.pop();\n        const Number lhs = st.top(); st.pop();\n        switch(*buff){\n        case '+': st.push(lhs + rhs); break;\n        case '-': st.push(lhs - rhs); break;\n        case '*': st.push(lhs * rhs); break;\n        case '/': st.push(lhs / rhs); break;\n        }\n      }else{\n        int d; sscanf(buff, \"%d\", &d);\n        st.push(d);\n      }\n    }\n    puts(\"correct\");\n  }catch(int e){\n    puts(\"error\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Pi = pair < int, int >;\n\nint main()\n{\n        int m;\n        map < string , bitset < 256 > > variable;\n        string op = \"+-*/\";\n\n        cin >> m;\n        for ( int i = 0; i < m; i++ ) {\n                string name;\n                int l, r;\n                cin >> name >> l >> r;\n                for ( int i = l; i <= r; i++ ) {\n                        variable[name][i] = true;\n                }\n        }\n\n        int n;\n        stack < bitset <256> > dat;     \n        cin >> n;\n        for ( int i = 0; i < n; i++ ) {\n                string q;\n                cin >> q;\n                if ( op.find(q) != string::npos ) {\n                        bitset <256>b = dat.top(); dat.pop();\n                        bitset <256>a = dat.top(); dat.pop();\n                        bitset <256>c = 0;\n                        if ( q == \"+\" ) {\n                                for ( int j = 0; j < 256; j++ ) {\n                                        for ( int k = 0; k < 256; k++ ) {\n                                                int idx = (j + k) % 256;\n                                                c[idx] = (c[idx] | a[j] & b[k]);\n                                        }\n                                }\n                        } else if ( q == \"-\" ) {\n                                for ( int j = 0; j < 256; j++ ) {\n                                        for ( int k = 0; k < 256; k++ ) {\n                                                int idx = (j - k + 256) % 256;\n                                                c[idx] = (c[idx] | a[j] & b[k]);\n                                        }\n                                }\n                        } else if ( q == \"*\" ) {\n                                for ( int j = 0; j < 256; j++ ) {\n                                        for ( int k = 0; k < 256; k++ ) {\n                                                int idx = (j * k) % 256;\n                                                c[idx] = (c[idx] | a[j] & b[k]);\n                                        }\n                                }\n                        } else if ( q == \"/\" ) {\n                                if ( b[0] == true ) {\n                                        cout << \"error\" << endl;\n                                        return ( 0 );\n                                }\n                                for ( int j = 0; j < 256; j++ ) {\n                                        for ( int k = 1; k < 256; k++ ) {\n                                                int idx = (j / k) % 256;\n                                                c[idx] = (c[idx] | a[j] & b[k]);\n                                        }\n                                }\n                        }\n                        //cout << c << endl;\n                        dat.push(c);\n                } else {\n                        if ( isdigit(q[0]) ) {\n                                int value = stoi(q);\n                                //cout << value << endl;\n                                bitset < 256 > d;\n                                d[value] = true;\n                                dat.push(d);\n                        } else {\n                                dat.push(variable[q]);\n                                //cout << variable[q] << endl;\n                        }\n                }\n        }       \n        \n        cout << \"correct\" << endl;\n\n        return ( 0 );\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn operate(a: &[bool; 256], b: &[bool; 256], op: char) -> Option<[bool; 256]> {\n    let mut ans = [false; 256];\n    macro_rules! exhaust {\n        ($op:expr) => {\n            for i in 0 .. 256 {\n                if a[i] {\n                    for j in 0 .. 256 {\n                        if b[j] {\n                            ans[$op(i, j)] = true;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    match op {\n        '+' => exhaust!(|i, j| (i + j) % 256),\n        '-' => exhaust!(|i, j| (i + 256 - j) % 256),\n        '*' => exhaust!(|i, j| (i * j) % 256),\n        '/' => {\n            if b[0] {\n                return None;\n            }\n            exhaust!(|i, j| i / j);\n        },\n        _ => panic!(),\n    }\n    Some(ans)\n}\n\nfn solve() {\n    let m = get();\n    let mut hm = HashMap::new();\n    for _ in 0 .. m {\n        let name = get_word();\n        let lb: usize = get();\n        let ub: usize = get();\n        hm.insert(name, (lb, ub));\n    }\n    let n = get();\n    let e: Vec<String> = (0 .. n).map(|_| get_word()).collect();\n    let mut stack = Vec::new();\n    let mut mess = false;\n    for e in &e {\n        match e.parse::<usize>() {\n            Ok(num) => {\n                let mut t = [false; 256];\n                t[num % 256] = true;\n                stack.push(t);\n            },\n            Err(_) => {\n                match hm.get(e) {\n                    Some(&(lb, ub)) => {\n                        let mut ans = [false; 256];\n                        for i in lb .. ub + 1 {\n                            ans[i] = true;\n                        }\n                        stack.push(ans);\n                    },\n                    None => {\n                        let b = stack.pop().unwrap();\n                        let a = stack.pop().unwrap();\n                        if let Some(res) = operate(&a, &b, e.chars().nth(0).unwrap()) {\n                            stack.push(res);\n                        } else {\n                            mess = true;\n                            break;\n                        }\n                    },\n                }\n            }\n        }\n    }\n    println!(\"{}\", if mess { \"error\" } else { \"correct\" });\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nbool solve(vector<string> &ops, map<string, P> &vs){\n  vector< vector<int> > v;\n  for(string s : ops){\n    vector<int> tmp;\n    if(vs.find(s) != vs.end()) FOR(i, vs[s].first, vs[s].second + 1) tmp.push_back(i);\n    else if(isdigit(s[0])) tmp.push_back(atoi(s.c_str()));\n    else if(s == \"+\") {\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x + y;\n          while(n >= 256) n -= 256;\n          tmp.push_back(n);\n        }\n      }\n    } else if(s == \"-\"){\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x - y;\n          while(n < 0) n += 256;\n          tmp.push_back(n);\n        }\n      }\n    } else if(s == \"*\"){\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          int n = x * y;\n          while(n >= 256) n -= 256;\n          tmp.push_back(n);\n        }\n      }\n    } else if(s == \"/\"){\n      vector<int> b = v.back(); v.pop_back();\n      vector<int> a = v.back(); v.pop_back();\n      for(int x : a){\n        for(int y : b){\n          if(y == 0) return false;\n          int n = x / y;\n          while(n >= 256) n -= 256;\n          tmp.push_back(n);\n        }\n      }\n    }\n    v.push_back(tmp);\n  }\n  return true;\n}\n\nint main() {\n  int M; cin >>M;\n  map<string, P> vs;\n  REP(i, M){\n    string s; cin >>s;\n    int l, u; cin >>l >>u;\n    vs[s] = P(l, u);\n  }\n  int N; cin >>N;\n  vector<string> ops(N);\n  REP(i, N) cin >>ops[i];\n  cout <<(solve(ops, vs) ? \"correct\" : \"error\")  <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <map>\n#include <utility>\n#include <bitset>\n#include <cctype>\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef bitset<256> bs256;\n\nbool is_number(const string &s){\n\tfor(int i = 0; i < s.size(); ++i){\n\t\tif(!isdigit(s[i])){ return false; }\n\t}\n\treturn true;\n}\nint to_number(const string &s){\n\tunsigned int x = 0;\n\tfor(int i = 0; i < s.size(); ++i){ x = (x * 10) + (s[i] - '0'); }\n\treturn x & 0xff;\n}\n\nmap<string, pii> range;\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0; i < m; ++i){\n\t\tstring name;\n\t\tint lower, upper;\n\t\tcin >> name >> lower >> upper;\n\t\trange[name] = pii(lower, upper);\n\t}\n\tint n;\n\tcin >> n;\n\tstack<bs256> stk;\n\tbool answer = true;\n\tfor(int i = 0; i < n; ++i){\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(is_number(s)){\n\t\t\tbs256 bs;\n\t\t\tbs[to_number(s)] = true;\n\t\t\tstk.push(bs);\n\t\t}else if(range.find(s) != range.end()){\n\t\t\tpii p = range[s];\n\t\t\tbs256 bs;\n\t\t\tfor(int i = p.first; i <= p.second; ++i){ bs[i] = true; }\n\t\t\tstk.push(bs);\n\t\t}else{\n\t\t\tbs256 b = stk.top(); stk.pop();\n\t\t\tbs256 a = stk.top(); stk.pop();\n\t\t\tif(s == \"/\" && b[0]){ answer = false; break; }\n\t\t\tbs256 c;\n\t\t\tfor(int j = 0; j < 256; ++j){\n\t\t\t\tif(!a[j]){ continue; }\n\t\t\t\tfor(int k = 0; k < 256; ++k){\n\t\t\t\t\tif(!b[k]){ continue; }\n\t\t\t\t\tint x = 0;\n\t\t\t\t\tif(s == \"+\"){\n\t\t\t\t\t\tx = (j + k) & 0xff;\n\t\t\t\t\t}else if(s == \"-\"){\n\t\t\t\t\t\tx = (j - k) & 0xff;\n\t\t\t\t\t}else if(s == \"*\"){\n\t\t\t\t\t\tx = (j * k) & 0xff;\n\t\t\t\t\t}else if(s == \"/\"){\n\t\t\t\t\t\tx = (j / k) & 0xff;\n\t\t\t\t\t}\n\t\t\t\t\tc[x] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstk.push(c);\n\t\t}\n\t}\n\tcout << (answer ? \"correct\" : \"error\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n  int m;\n  cin>>m;\n  map<string,bitset<256> > val;\n  REP(i,m) {\n    string name;\n    int minv, maxv;\n    cin>>name>>minv>>maxv;\n    bitset<256> bs;\n    REP(j,256)\n      bs[j] = false;\n    FOR(j,minv,maxv+1)\n      bs[j] = true;\n    val[name] = bs;\n  }\n  stack<bitset<256> > stk;\n  int n;\n  cin>>n;\n  bool flag = false;\n  REP(i,n) {\n    string str;\n    cin>>str;\n    if(val.find(str) != val.end())\n      stk.push(val[str]);\n    else if(str == \"/\") {\n      if(stk.top()[0]) {\n        flag = true;\n        break;\n      }else{\n        bitset<256> bs,lhs,rhs;\n        REP(j,256)bs[j] = false;\n        rhs = stk.top();stk.pop();\n        lhs = stk.top();stk.pop();\n        REP(j,256)REP(k,256) {\n          if(lhs[j] && rhs[k])\n          bs[(j/k)%256] = true;\n        }\n        stk.push(bs);\n      }\n    }else if(str == \"*\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j*k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"+\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j+k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"-\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(256+j-k)%256] = true;\n      }\n      stk.push(bs);\n    } else {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      bs[atoi(str.c_str())] = true;\n      stk.push(bs);\n    }\n  }\n  if(flag)\n    cout<<\"error\"<<endl;\n  else\n    cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef pair<int,int>P;\n#define r(i,n) for(int i=0;i<n;i++)\nmap<string,P>M;\nint m,low,high;\nstring name,s;\nstack<vector<int> >st;\nvoid END(){\n  cout<<\"error\"<<endl;\n  exit(0);\n}\nvoid in_num(){\n  vector<int>v;\n  int res=0;\n  r(i,s.size())res=res*10+(s[i]-'0'),res=res%256;\n  v.push_back(res);\n  st.push(v);\n}\nvoid in_string(){\n  vector<int>v;\n  int t1=M[s].first;\n  int t2=M[s].second;\n  for(int i=t1;i<=t2;i++)v.push_back(i);\n  st.push(v);\n}\nvoid sol1(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]+v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol2(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]-v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol3(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      int t=v1[i]*v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nvoid sol4(){\n  set<int>se;\n  vector<int>v2=st.top();st.pop();\n  vector<int>v1=st.top();st.pop();\n  vector<int>v;\n  r(i,v1.size()){\n    r(j,v2.size()){\n      if(v2[j]==0)END();\n      int t=v1[i]/v2[j];\n      t=t%256;\n      if(!se.count(t)){\n\tv.push_back(t);\n\tse.insert(t);\n      }\n    }\n  }\n  st.push(v);\n}\nint main(){\n  cin>>m;\n  r(i,m){\n    cin>>name>>low>>high;\n    M[name]=P(low,high);\n  }\n  cin>>m;\n  while(m--){\n    cin>>s;\n    if(isdigit(s[0]))in_num();\n    else if(isalpha(s[0]))in_string();\n    else{\n      if(s==\"+\")sol1();\n      if(s==\"-\")sol2();\n      if(s==\"*\")sol3();\n      if(s==\"/\")sol4();\n    }\n  }\n  cout<<\"correct\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n// 0 除算があったかどうか\nbool flag = false;\n\n// string -> int\nint s_to_i(string s){\n\tint n = 0;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tn *= 10;\n\t\tn += s[i] - '0';\n\t}\n\treturn n;\n}\n\n// int -> string\nstring i_to_s(int n){\n\tstring s;\n\tdo{\n\t\ts.push_back( (n%10) + '0' );\n\t\tn /= 10;\n\t}while(n!=0);\n\treverse(s.begin(),s.end());\n\treturn s;\n}\n\n// 演算子かどうか返す.\nbool is_op(const string& s){\n\treturn ( s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\" );\n}\n\n// 数値かどうか返す.\nbool is_number(const string& s){\n\treturn ( '0' <= s[0] && s[0] <= '9' );\n}\n\n// a op b の結果を返す. 0除算があったらフラグをたてる.\nint op(int a, int b, char op){\n\tint r;\n\t// 0 除算のとき\n\tif( b == 0 && op == '/' ){\n\t\tflag = true;\n\t\treturn 0;\n\t}\n\t// 演算結果を返す\n\tif( op == '+' ){\n\t\tr = ( a + b ) % 256;\n\t}else if( op == '-' ){\n\t\tr = ( a - b + 256 ) % 256;\n\t}else if( op == '*' ){\n\t\tr = ( a * b ) % 256;\n\t}else if( op == '/' ){\n\t\tr = ( a / b ) % 256;\n\t}\n\t\n\treturn r;\n}\n\nint main(){\n\tint m, n;\n\tmap<string,P> value;\n\tstack< set<int> > st;\n\t\n\tcin >> m;\n\tfor(int i = 0 ; i < m ; i++ ){\n\t\tstring name;\n\t\tint lb, ub;\n\t\tcin >> name >> lb >> ub;\n\t\tvalue[name] = P(lb,ub);\n\t}\n\t\n\tcin >> n;\n\tvector<string> e(n);\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\tcin >> e[i];\n\t}\n\tfor(int i = 0 ; i < n ; i++ ){\n\t\t// 0 除算があるとき\n\t\tif( flag ){\n\t\t\tbreak;\n\t\t}\n\t\tif( is_number(e[i]) ){ // e[i] が数値のとき\n\t\t\tset<int> s;\n\t\t\ts.insert(s_to_i(e[i]));\n\t\t\tst.push(s);\n\t\t}else if( is_op(e[i]) ){ // e[i] が演算子のとき\n\t\t\tset<int> b = st.top();\n\t\t\tst.pop();\n\t\t\tset<int> a = st.top();\n\t\t\tst.pop();\n\t\t\t\n\t\t\tset<int> next;\n\t\t\t\n\t\t\t// 数値の候補をすべて計算する (数値は[0,255])\n\t\t\tfor(set<int>::iterator x = b.begin() ; x != b.end() ; ++x ){\n\t\t\t\tfor(set<int>::iterator y = a.begin() ; y != a.end() ; ++y ){\n\t\t\t\t\tint r = op( *y, *x , e[i][0] );\n\t\t\t\t\tnext.insert(r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst.push(next);\n\t\t\t\n\t\t}else{ // e[i] が変数のとき\n\t\t\tint l = value[e[i]].first;\n\t\t\tint r = value[e[i]].second;\n\t\t\tset<int> next;\n\t\t\t\n\t\t\t// {l, l+1, ... , r } をスタックに入れる\n\t\t\tfor(int i = l ; i <= r ; i++ ){\n\t\t\t\tnext.insert(i);\n\t\t\t}\n\t\t\tst.push(next);\n\t\t}\n\t}\n\t// 解の出力\n\tif( !flag ){\n\t\tcout << \"correct\" << endl;\n\t}else{\n\t\tcout << \"error\" << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned char uc;\nint main(){\n  int m;\n  cin>>m;\n  int l[m],r[m];\n  map<string,int> ms;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    ms[s]=i;\n  }\n  int n;\n  cin>>n;\n  string ss[n];\n  for(int i=0;i<n;i++) cin>>ss[i];\n  bool f=0;\n  time_t start=clock();\n  srand(unsigned(time));\n  while((double)(clock()-start)/CLOCKS_PER_SEC<1.7&&!f){\n    stack<uc> sc;\n    for(int i=0;!f&&i<n;i++){\n      //cout<<i<<\":\"<<ss[i]<<endl;\n      if(ms.find(ss[i])!=ms.end()){ \n\tint j=ms[ss[i]],k=(l[j]+(rand()%(r[j]-l[j])));\n\t//cout<<ss[i]<<\":\"<<k<<endl;\n\tsc.push(k);\n      }else if(isdigit(ss[i][0])){\n\tuc a=0;\n\tfor(int j=0;j<(int)ss[i].size();j++) a=(uc)(a*10+ss[i][j]-'0');\n\tsc.push(a);\n      }else{\n\tuc a,b;\n\tb=sc.top();sc.pop();\n\ta=sc.top();sc.pop();\n\tif(ss[i]==\"+\") sc.push(a+b);\n\tif(ss[i]==\"-\") sc.push(a-b);\n\tif(ss[i]==\"*\") sc.push(a*b);\n\tif(ss[i]==\"/\"){\n\t  if(b) sc.push(a/b);\n\t  else{\n\t    f=1;\n\t    break;\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<(!f?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <stack>\nusing namespace std;\n\nbool isop(const string &s) {\n  return s == \"+\" || s == \"*\" || s == \"-\" || s == \"/\";\n}\n\nint main() {\n  map<string, set<int> > idx;\n  int n,m,lb,ub;\n  string name;\n  cin>>m;\n  for (int i=0; i<m; ++i) {\n    cin>>name>>lb>>ub;\n    set<int> s;\n    for (int j=lb; j<=ub; ++j) s.insert(j);\n    idx[name] = s;\n  }\n\n  cin>>n;\n  stack<set<int> > st;\n  string exp;\n  bool error = false;\n  for (int i=0; i<n; ++i) {\n    cin>>exp;\n    if (error) continue;\n    if (isop(exp)) {\n      if (st.size() < 2) {\n        error = true;\n        continue;\n      }\n      set<int> right = st.top(); st.pop();\n      set<int> left = st.top(); st.pop();\n      set<int> v;\n      for (set<int>::iterator l=left.begin(); l!=left.end(); ++l) {\n        for (set<int>::iterator r=right.begin(); r!=right.end(); ++r) {\n          if (exp == \"+\") v.insert((*l+*r)%256);\n          if (exp == \"-\") v.insert((*l-*r+256)%256);\n          if (exp == \"*\") v.insert(((*l) * (*r))%256);\n          if (exp == \"/\") {\n            if (*r == 0) error = true;\n            else v.insert(((*l)/(*r))%256);\n          }\n        }\n      }\n      st.push(v);\n    } else if (idx.find(exp) != idx.end()) {\n      st.push(idx[exp]);\n    } else {\n      set<int> v; v.insert(atoi(exp.c_str()));\n      st.push(v);\n    }\n  }\n  if (error) cout<<\"error\"<<endl;\n  else cout<<\"correct\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l-2 < 0 ? MAX-1 : vec[l-2]);\n    int v2 = (l-1 < 0 ? MAX-1 : vec[l-1]); \n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n             \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=105;\nconst ll INF=1LL<<50;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int M;cin>>M;\n        map<string,vector<bool>> MA;\n        for(int i=0;i<M;i++){\n            string S;\n            int a,b;cin>>S>>a>>b;\n            vector<bool> A(256);\n            for(int j=a;j<=b;j++) A[j]=1;\n            \n            MA[S]=A;\n        }\n        \n        int N;cin>>N;\n        bool ans=true;\n        stack<vector<bool>> ST;\n        \n        for(int i=0;i<N;i++){\n            string S;cin>>S;\n            if(S==\"+\"||S==\"-\"||S==\"*\"||S==\"/\"){\n                vector<bool> ne(256),A,B;\n                B=ST.top();\n                ST.pop();\n                A=ST.top();\n                ST.pop();\n                \n                for(int j=0;j<256;j++){\n                    for(int k=0;k<256;k++){\n                        if(A[j]&&B[k]){\n                            if(k==0&&S==\"/\"){\n                                ans=false;\n                                continue;\n                            }\n                            \n                            if(S==\"+\"){\n                                ne[(j+k)%256]=1;\n                            }else if(S==\"-\"){\n                                ne[(256+j-k)%256]=1;\n                            }else if(S==\"*\"){\n                                ne[j*k%256]=1;\n                            }else{\n                                ne[j/k]=1;\n                            }\n                        }\n                    }\n                }\n                \n                ST.push(ne);\n            }else if('0'<=S[0]&&S[0]<='9'){\n                int a=stoi(S);\n                vector<bool> ne(256);\n                ne[a]=1;\n                ST.push(ne);\n            }else{\n                vector<bool> ne=MA[S];\n                ST.push(ne);\n            }\n        }\n        \n        if(ans) cout<<\"correct\"<<endl;\n        else cout<<\"error\"<<endl;\n        \n        break;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0, 0,-1,1,-1, 1,-1};\nint dy[]={0,1,-1, 0,1,-1,-1, 1};\n\n\n\nint main(){\n    int m;cin >> m;\n    vector<string> s(m);\n    vector<int> l(m),r(m);\n    unordered_map<string,vector<bool>> val;\n    for (int i = 0; i < m; i++) {\n        cin >> s[i] >> l[i] >> r[i];\n        r[i]++;\n        vector<bool> v(256,false);\n        for (int j = l[i]; j < r[i]; j++) {\n            v[j] = true;\n        }\n        val[s[i]] = v;\n    }\n    int n;cin >> n;\n    stack<string> st;\n    bool f = false;\n    vector<int> c(10,0);\n    for (int i = 0; i < n; i++) {\n        string t;cin >> t;\n        if(t[0]=='+'){\n            string q = st.top();st.pop();\n            string p = st.top();st.pop();\n            vector<bool> v(256,false);\n            for (int j = 0; j < 256; j++) {\n                if(!val[p][j]) continue;\n                for (int k = 0; k < 256; k++) {\n                    if(!val[q][k]) continue;\n                    v[(j+k)%256] = true;\n                }\n            }\n            val[p] = v;\n            st.push(p);\n        }\n        else if(t[0]=='-'){\n            string q = st.top();st.pop();\n            string p = st.top();st.pop();\n            vector<bool> v(256,false);\n            for (int j = 0; j < 256; j++) {\n                if(!val[p][j]) continue;\n                for (int k = 0; k < 256; k++) {\n                    if(!val[q][k]) continue;\n                    v[(j-k+256)%256] = true;\n                }\n            }\n            val[p] = v;\n            st.push(p);\n        }\n        else if(t[0]=='*'){\n            string q = st.top();st.pop();\n            string p = st.top();st.pop();\n            vector<bool> v(256,false);\n            for (int j = 0; j < 256; j++) {\n                if(!val[p][j]) continue;\n                for (int k = 0; k < 256; k++) {\n                    if(!val[q][k]) continue;\n                    v[(j*k)%256] = true;\n                }\n            }\n            val[p] = v;\n            st.push(p);\n        }\n        else if(t[0]=='/'){\n            string q = st.top();st.pop();\n            string p = st.top();st.pop();\n            vector<bool> v(256,false);\n            for (int j = 0; j < 256; j++) {\n                if(!val[p][j]) continue;\n                for (int k = 0; k < 256; k++) {\n                    if(!val[q][k]) continue;\n                    if(k==0){\n                        puts(\"error\");\n                        return 0;\n                    }\n                    v[j/k] = true;\n                }\n            }\n            val[p] = v;\n            st.push(p);\n        }\n        else{\n            if(0<=t[0]-'0'&&t[0]-'0'<10){\n                vector<bool> v(256,false);\n                v[stoi(t)] = true;\n                t += to_string(c[t[0] - '0']++);\n                val[t] = v;\n            }\n            st.push(t);\n        }\n    }\n    puts(\"correct\");\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <stack>\n#include <map>\nusing namespace std;\nmap<string, vector<bool>> mp;\nint main() {\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tstring name;\n\t\tint l, u;\n\t\tcin >> name >> l >> u;\n\t\tvector<bool> v;\n\t\tfor (int i = 0; i <= 255; i++) {\n\t\t\tv.push_back(l <= i && i <= u);\n\t\t}\n\t\tmp[name] = v;\n\t}\n\tint n;\n\tcin >> n;\n\tstack<vector<bool>> s;\n\tfor (int i = 0; i < n; i++) {\n\t\tstring e;\n\t\tcin >> e;\n\t\tif (mp.find(e) != mp.end()) {\n\t\t\ts.push(mp[e]);\n\t\t}\n\t\telse if(isdigit(e[0])) {\n\t\t\tint val = 0;\n\t\t\tfor (int j = 0; j < e.size(); j++) {\n\t\t\t\tval *= 10;\n\t\t\t\tval += e[j] - '0';\n\t\t\t}\n\t\t\tvector<bool> v;\n\t\t\tfor (int j = 0; j <= 255; j++) {\n\t\t\t\tv.push_back(j == val);\n\t\t\t}\n\t\t\ts.push(v);\n\t\t}\n\t\telse {\n\t\t\tvector<bool> op1, op2, res;\n\t\t\top2 = s.top(); s.pop();\n\t\t\top1 = s.top(); s.pop();\n\t\t\tfor (int j = 0; j <= 255; j++) res.push_back(0);\n\t\t\tfor (int j = 0; j <= 255; j++) {\n\t\t\t\tif (!op1[j]) continue;\n\t\t\t\tfor (int k = 0; k <= 255; k++) {\n\t\t\t\t\tif (!op2[k]) continue;\n\t\t\t\t\tif (e[0] == '+') {\n\t\t\t\t\t\tres[(j + k) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (e[0] == '-') {\n\t\t\t\t\t\tres[(j - k + 256) % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (e[0] == '*') {\n\t\t\t\t\t\tres[j*k % 256] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tres[j / k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int m,n=inf;\n    cin >> m;\n    vector<string> name(m);\n    vector<unsigned char> lb(m),ub(m);\n    rep(i,0,m){\n        int tmp1,tmp2;\n        cin >> name[i] >> tmp1 >> tmp2;\n        lb[i]=tmp1;\n        ub[i]=tmp2;\n    }\n    cin >> n;\n\n    stack<unsigned char> stk1,stk2;\n    rep(i,0,n){\n        string e;\n        cin >> e;\n        if(e==\"+\" or e==\"-\" or e==\"*\" or e==\"/\"){\n            const unsigned char lb2=stk1.top();\n            const unsigned char ub2=stk2.top();\n            stk1.pop();\n            stk2.pop();\n            const unsigned char lb1=stk1.top();\n            const unsigned char ub1=stk2.top();\n            stk1.pop();\n            stk2.pop();\n            if(e==\"+\"){\n                const unsigned char tmp1=lb1+lb2,tmp2=lb1+ub2,tmp3=ub1+lb2,tmp4=ub1+ub2;\n                stk1.push(min({tmp1,tmp2,tmp3,tmp4}));\n                stk2.push(max({tmp1,tmp2,tmp3,tmp4}));\n            }\n            if(e==\"-\"){\n                const unsigned char tmp1=lb1-lb2,tmp2=lb1-ub2,tmp3=ub1-lb2,tmp4=ub1-ub2;\n                stk1.push(min({tmp1,tmp2,tmp3,tmp4}));\n                stk2.push(max({tmp1,tmp2,tmp3,tmp4}));\n            }\n            if(e==\"*\"){\n                const unsigned char tmp1=lb1*lb2,tmp2=lb1*ub2,tmp3=ub1*lb2,tmp4=ub1*ub2;\n                stk1.push(min({tmp1,tmp2,tmp3,tmp4}));\n                stk2.push(max({tmp1,tmp2,tmp3,tmp4}));\n            }\n            if(e==\"/\"){\n                if(lb2==0){\n                    cout << \"error\" << endl;\n                    return;\n                }\n                stk1.push(lb1/ub2);\n                stk2.push(ub2/lb2);\n            }\n            continue;\n        }\n        bool flag=true;\n        rep(j,0,m) if(name[j]==e){\n            stk1.push(lb[j]);\n            stk2.push(ub[j]);\n            flag=false;\n            break;\n        }\n        if(flag){\n            const unsigned char val=stoi(e);\n            stk1.push(val);\n            stk2.push(val);\n        }\n    }\n    cout << \"correct\" << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vs = vector<string>;\nusing msi = map<string, int>;\nusing mii = map<int, int>;\nusing psi = pair<string, int>;\nusing pii = pair<int, int>;\nusing vlai = valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF (ll)1E9\n#define EPS 1E-9\n#define MOD 1000000007\n#define PI 3.1415926535897932384\n\ntemplate <class T>ostream &operator<<(std::ostream &o, const vector<T> &v)\n{\n\trep(i, v.size()) {\n\t\to << (i > 0 ? \" \" : \"\") << v[i];\n\t}\n\treturn o;\n}\n\n//int dx[]={1,1,1,0,-1,-1,-1,0},dy[8]={1,0,-1,-1,-1,0,1,1,1};\n\n//constexpr ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n\nvoid solve(int m) {\n\tvs name(m);\n\tint low, high;\n\tvector<vector<bool>> val(m, vector<bool>(256, false));\n\trep(i, m) {\n\t\tcin >> name[i] >> low >> high;\n\t\trep(j, 256) {\n\t\t\tif (low <= j&&j <= high)val[i][j] = true;\n\t\t}\n\t}\n\tint n;\n\tcin >> n;\n\tstring c;\n\tvs ex;\n\trep(i, n) {\n\t\tcin >> c;\n\t\tex.push_back(c);\n\t}\n\n\n\tstack<vector<bool>> s;\n\trep(i, n) {\n\t\t//cout << ex[i] << endl;\n\t\tif (ex[i][0] - '0' >= 0 && ex[i][0] - '0' <= 9) {\n\t\t\tint num = stoi(ex[i]);\n\t\t\tvector<bool> vb(256, false);\n\t\t\tvb[num] = true;\n\t\t\ts.push(vb);\n\t\t}\n\t\telse if (ex[i][0]=='+') {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\tvector<bool> r(256,false);\n\t\t\trep(j, 256) {\n\t\t\t\tif (a[j]) {\n\t\t\t\t\trep(k, 256) {\n\t\t\t\t\t\tif (b[k]) {\n\t\t\t\t\t\t\tr[(j + k) % 256] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.push(r);\n\t\t}\n\t\telse if (ex[i][0] == '-') {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\tvector<bool> r(256, false);\n\t\t\trep(j, 256) {\n\t\t\t\tif (a[j]) {\n\t\t\t\t\trep(k, 256) {\n\t\t\t\t\t\tif (b[k]) {\n\t\t\t\t\t\t\tr[(j - k+256) % 256] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.push(r);\n\t\t}\n\t\telse if (ex[i][0] == '*') {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\tvector<bool> r(256, false);\n\t\t\trep(j, 256) {\n\t\t\t\tif (a[j]) {\n\t\t\t\t\trep(k, 256) {\n\t\t\t\t\t\tif (b[k]) {\n\t\t\t\t\t\t\tr[(j * k + 256) % 256] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.push(r);\n\t\t}\n\t\telse if (ex[i][0] == '/') {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\tvector<bool> r(256, false);\n\t\t\trep(j, 256) {\n\t\t\t\tif (a[j]) {\n\t\t\t\t\trep(k, 256) {\n\t\t\t\t\t\tif (b[k]) {\n\t\t\t\t\t\t\tif (k == 0) {\n\t\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tr[(j / k + 256) % 256] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.push(r);\n\t\t}\n\t\telse {//val\n\t\t\trep(j, m){\n\t\t\t\tif (ex[i] == name[j]) {\n\t\t\t\t\ts.push(val[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}\n\nint main(void) {\n\tint n;\n\twhile(cin>>n){\n\t\tsolve(n);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbool calc(set<int>& B,set<int>& A,string ope,stack<set<int> >& ele)\n{\n  set<int> C;\n  for(set<int>::iterator it_B = B.begin();it_B != B.end();it_B++)\n    {\n      for(set<int>::iterator it_A = A.begin();it_A != A.end();it_A++)\n\t{\n\t  if(ope == \"+\")\n\t    {\n\t      C.insert(((*it_A)+(*it_B))%256);\n\t    }\n\t  else if(ope == \"-\")\n\t    {\n\t      C.insert(((*it_A)-(*it_B)+256)%256);\n\t    }\n\t  else if(ope == \"*\")\n\t    {\n\t      C.insert(((*it_A)*(*it_B))%256);\n\t    }\n\t  else if(ope == \"/\")\n\t    {\n\t      if(!(*it_B))\n\t\t{\n\t\t  cout << \"error\" << endl;\n\t\t  return false; \n\t\t}\n\t      C.insert(((*it_A)/(*it_B))%256);\n\t    }\n\t  else \n{\ncerr << \"error rrrrr\" << endl;\n\t    assert(false);\n}\n\t}\n    }\n  ele.push(C);\n  return true;\n}\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<set<int> > ele;\n  deque<string> st;\n  bool fin = false;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n     \n      if(e != \"/\" && e != \"*\" && e != \"-\" && e != \"+\")\n\t{\n\t  if(index.find(e) != index.end())\n\t    {\n\t      ele.push(index[e]);\n\t    }\n\t  else\n\t    {\n\t      set<int> FAGS;\n\t      FAGS.insert((atoi)(e.c_str()));\n\t      ele.push(FAGS);\n\t    }\n\t}\n      else \n\t{\n\t  set<int> A,B;\n\t  B = ele.top(),ele.pop();\n\t  A = ele.top(),ele.pop();\n\t  if(!calc(B,A,e,ele))\n\t    fin = true;\n\t    \n\t}\n\n    }\n\n  if(fin)\n    return 0;\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<int> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v  = (l == 0 ? MAX-1 : vec[0]);\n    int v2 = (l-1 < 0 ? MAX-1 : vec[l-1]);\n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(s2i(e[x]));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = vec[l-1];\n            int a = vec[l-2];\n            vec.pop_back(); vec.pop_back();\n             \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(c);\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(a);\n            vec.push_back(b);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(i);\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tleast = most = number = -1;\n\t\tisVariable = false;\n\t}\n\tInfo(int arg_least,int arg_most,int arg_number,bool arg_is_val){\n\t\tleast = arg_least;\n\t\tmost = arg_most;\n\t\tnumber = arg_number;\n\t\tisVariable = arg_is_val;\n\t}\n\n\tchar name[21];\n\tint least,most,number;\n\tbool isVariable;\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\n\nint main(){\n\n\tint num,N;\n\tscanf(\"%d\",&num);\n\tInfo vals[num];\n\n\tfor(int i = 0; i < num; i++){\n\t\tscanf(\"%s %d %d\",vals[i].name,&vals[i].least,&vals[i].most);\n\t}\n\n\tstack<Info> S;\n\n\tscanf(\"%d\",&N);\n\n\tint tmp,least,most;\n\tchar buf[21];\n\tbool correct = true;\n\tInfo op1,op2;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s\",buf);\n\n\t\tif(buf[0] == '+' || buf[0] == '*' || buf[0] == '/' || buf[0] == '-'){\n\t\t\top2 = S.top();\n\t\t\tS.pop();\n\t\t\top1 = S.top();\n\t\t\tS.pop();\n\n\t\t\tswitch(buf[0]){\n\t\t\tcase '+':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number+op2.number)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k+p)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k+p)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k+op1.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k+op1.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k+op2.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k+op2.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tif(op2.number == 0){\n\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number/op2.number)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tif(op2.least == 0){\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k/p)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k/p)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tif(op2.least == 0){\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(op1.number/k)%256);\n\t\t\t\t\t\t\tmost = max(most,(op1.number/k)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tif(op2.number == 0){\n\t\t\t\t\t\t\tcorrect = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k/op2.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k/op2.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '-':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number-op2.number+256)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k-p+256)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k-p+256)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(op1.number-k)%256);\n\t\t\t\t\t\t\tmost = max(most,(op1.number-k)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k-op2.number+256)%256);\n\t\t\t\t\t\t\tmost = max(most,(k-op2.number+256)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '*':\n\t\t\t\tif(op1.isVariable == false && op2.isVariable == false){\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = false;\n\t\t\t\t\tinfo.number = (op1.number*op2.number)%256;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}else{\n\t\t\t\t\tif(op1.isVariable == true && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tfor(int p = op2.least; p <= op2.most; p++){\n\t\t\t\t\t\t\t\tleast = min(least,(k*p)%256);\n\t\t\t\t\t\t\t\tmost = max(most,(k*p)%256);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(op1.isVariable == false && op2.isVariable == true){\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op2.least; k <= op2.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(op1.number*k)%256);\n\t\t\t\t\t\t\tmost = max(most,(op1.number*k)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{ //op1.isVariable == true && op2.isVariable = false;\n\t\t\t\t\t\tleast = 256,most = -1;\n\t\t\t\t\t\tfor(int k = op1.least; k <= op1.most; k++){\n\t\t\t\t\t\t\tleast = min(least,(k*op2.number)%256);\n\t\t\t\t\t\t\tmost = max(most,(k*op2.number)%256);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tInfo info;\n\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\tinfo.least = least;\n\t\t\t\t\tinfo.most = most;\n\t\t\t\t\tS.push(info);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(buf[0] >= '0' && buf[0] <= '9'){\n\t\t\t\ttmp = 0;\n\t\t\t\tfor(int k = 0; buf[k] != '\\0'; k++){\n\t\t\t\t\ttmp = 10*tmp + buf[k] - '0';\n\t\t\t\t}\n\t\t\t\tInfo info;\n\t\t\t\tinfo.isVariable = false;\n\t\t\t\tinfo.number = tmp;\n\t\t\t\tS.push(info);\n\t\t\t}else{\n\t\t\t\tfor(int k = 0; k < num; k++){\n\t\t\t\t\tif(strCmp(buf,vals[k].name)){\n\t\t\t\t\t\tInfo info;\n\t\t\t\t\t\tinfo.isVariable = true;\n\t\t\t\t\t\tinfo.least = vals[k].least;\n\t\t\t\t\t\tinfo.most = vals[k].most;\n\t\t\t\t\t\tstrcpy(info.name,buf);\n\t\t\t\t\t\tS.push(info);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!correct)break;\n\t}\n\n\tif(correct){\n\t\tprintf(\"correct\\n\");\n\t}else{\n\t\tprintf(\"error\\n\");\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint s2i(string s){\n  stringstream ss;\n  int res;\n  ss<<s;\n  ss>>res;\n  return res;\n}\n\nint m,n;\nmap<string,int> t;\nint l[100],r[100];\n\n\nvector<int> change(int x){\n  vector<int> res(256);\n  for(int i=l[x];i<=r[x];i++)res[i]=1;\n  return res;\n}\n\nvector<int> change(string s){\n  vector<int> res(256);\n  res[s2i(s)]=1;\n  return res;\n}\n\nbool solve(){\n  string str,tmp;\n  getline(cin,str);\n  stringstream ss(str);\n\n  stack< vector<int> > st;\n  \n  while(ss>>tmp){\n    if(tmp==\"+\"){\n      vector<int> a,b,c;\n      b=st.top();st.pop();\n      a=st.top();st.pop();\n      c.resize(256);\n      for(int i=0;i<256;i++){\n        if(a[i]==0)continue;\n        for(int j=0;j<256;j++){\n          if(b[j]==0)continue;\n          c[(i+j)%256]=1;\n        }\n      }\n      st.push(c);\n    }else if(tmp==\"-\"){\n      vector<int> a,b,c;\n      b=st.top();st.pop();\n      a=st.top();st.pop();\n      c.resize(256);\n      for(int i=0;i<256;i++){\n        if(a[i]==0)continue;\n        for(int j=0;j<256;j++){\n          if(b[j]==0)continue;\n          c[(i-j+256)%256]=1;\n        }\n      }\n      st.push(c);\n    }else if(tmp==\"*\"){\n      vector<int> a,b,c;\n      b=st.top();st.pop();\n      a=st.top();st.pop();\n      c.resize(256);\n      for(int i=0;i<256;i++){\n        if(a[i]==0)continue;\n        for(int j=0;j<256;j++){\n          if(b[j]==0)continue;\n          c[(i*j)%256]=1;\n        }\n      }\n      st.push(c);\n    }else if(tmp==\"/\"){\n      vector<int> a,b,c;\n      b=st.top();st.pop();\n      a=st.top();st.pop();\n      c.resize(256);\n      for(int i=0;i<256;i++){\n        if(a[i]==0)continue;\n        for(int j=0;j<256;j++){\n          if(b[j]==0)continue;\n          if(j==0)return false;\n          c[i/j]=1;\n        }\n      }\n      st.push(c);\n    }else if(t.count(tmp)){\n      st.push( change( t[tmp] ) );\n    }else{\n      st.push( change(tmp) );\n    }\n  }\n  \n  return true;\n}\n\nint main(){\n  cin>>m;\n  for(int i=0;i<m;i++){\n    string s;\n    cin>>s>>l[i]>>r[i];\n    t[s]=i;\n  }\n  cin>>n;\n  cin.ignore();\n  cout<<(solve()?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <cassert>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 256;\narray<array<int, N>, N> val;\narray<int, N> ope;\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tmap<string, int> mp;\n\trep(i, 4) ope[\"+-*/\"[i]] = 1;\n\n\tint m;\n\tcin >> m;\n\trep(i, m){\n\t\tstring s;\n\t\tint lb, ub;\n\t\tcin >> s >> lb >> ub;\n\t\tmp[s] = i;\n\t\tfor (int j = lb; j <= ub; ++j) val[i][j] = 1;\n\t}\n\n\tint n;\n\tcin >> n;\n\tstack<array<int, N>> st;\n\tbool ok = true;\n\trep(i, n){\n\t\tstring s;\n\t\tcin >> s;\n\t\tarray<int, N> ele = {};\n\t\tif ('0' <= s[0] && s[0] <= '9'){\n\t\t\tele[stoi(s)] = 1;\n\t\t\tst.push(ele);\n\t\t}\n\t\telse if(ope[s[0]]){\n\t\t\tarray<int, N> lhs, rhs, res = {};\n\t\t\trhs = st.top(); st.pop();\n\t\t\tlhs = st.top(); st.pop();\n\t\t\trep(i, N) rep(j, N){\n\t\t\t\tunsigned char r;\n\t\t\t\tif (lhs[i] && rhs[j]){\n\t\t\t\t\tswitch (s[0]){\n\t\t\t\t\tcase '+':\n\t\t\t\t\t\tr = i + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '-':\n\t\t\t\t\t\tr = i - j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '*':\n\t\t\t\t\t\tr = i*j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tif (!j) ok = false;\n\t\t\t\t\t\telse r = i / j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tres[r] = 1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tst.push(res);\n\t\t}\n\t\telse{\n\t\t\tst.push(val[mp[s]]);\n\t\t}\n\t}\n\n\tcout << (ok ? \"correct\" : \"error\") << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbool calc(set<int>& B,set<int>& A,string ope,stack<set<int> >& ele,map<string,set<int> >& index)\n{\n  set<int> C;\n  for(set<int>::iterator it_B = B.begin();it_B != B.end();it_B++)\n    {\n      for(set<int>::iterator it_A = A.begin();it_A != A.end();it_A++)\n\t{\n\t  if(ope == \"+\")\n\t    {\n\t      C.insert(((*it_A)+(*it_B))%256);\n\t    }\n\t  else if(ope == \"-\")\n\t    {\n\t      C.insert(((*it_A)-(*it_B)+256)%256);\n\t    }\n\t  else if(ope == \"*\")\n\t    {\n\t      C.insert(((*it_A)*(*it_B))%256);\n\t    }\n\t  else if(ope == \"/\")\n\t    {\n\t      if(!(*it_B))\n\t\t{\n\t\n\t\t  return false; \n\t\t}\n\t      C.insert(((*it_A)/(*it_B))%256);\n\t    }\n\t  else \n\t    assert(false);\n\t}\n    }\n  index[My] = C;\n  ele.push(C);\n  return true;\n}\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<set<int> > ele;\n  deque<string> st;\n  bool fin = false;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n     \n      if(e != \"/\" && e != \"*\" && e != \"-\" && e != \"+\")\n\t{\n\t  if(index.find(e) != index.end())\n\t    {\n\t      ele.push(index[e]);\n\t    }\n\t  else\n\t    {\n\t      set<int> FAGS;\n\t      FAGS.insert((atoi)(e.c_str()));\n\t      ele.push(FAGS);\n\t    }\n\t}\n      else \n\t{\n\t  set<int> A,B;\n\t  B = ele.top(),ele.pop();\n\t  A = ele.top(),ele.pop();\n\t  if(!calc(B,A,e,ele,index))\n\t    fin = true;\t    \n\t}\n\n    }\n\n  if(fin)\n    {\n      cout << \"error\" << endl;\n      return 0;\n    }\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 500\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX];\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n    int v = (st.empty() ? n : st.top());\n    if (memo[x][v] != -1) {\n        return memo[x][v];\n    }\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        for (int j = 0; j < e[x].size(); j++) {\n            if (!isdigit(e[x][j])) {\n                for (; ; ) {\n                    \n                }\n            }\n        }\n\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res = zero_division_checker(x+1, st);\n            st.pop();\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return (memo[x][v] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\n\nint main(){\n  int M, N;\n  while(cin>>M){\n    map<string, P> val;\n    REP(i, M){\n      string s; int a, b;\n      cin>>s>>a>>b;\n      val[s] = P(a, b);\n    }\n    cin>>N;\n    stack< set<int> > stk;\n    bool correct = true;\n    REP(iter, N){\n      string s;\n      cin>>s;\n      if(val.count(s)){\n        set<int> st;\n        int a = val[s].first, b = val[s].second;\n        for(int i = a; i <= b; i++){\n          st.insert(i);\n        }\n        stk.push(st);\n      }else if(s == \"+\"){\n        set<int> b = stk.top(); stk.pop();\n        set<int> a = stk.top(); stk.pop();\n        set<int> res;\n        FORIT(ai, a)FORIT(bi, b){\n          int r = (*ai + *bi) % 256;\n          res.insert(r);\n        }\n        stk.push(res);\n      }else if(s == \"-\"){\n        set<int> b = stk.top(); stk.pop();\n        set<int> a = stk.top(); stk.pop();\n        set<int> res;\n        FORIT(ai, a)FORIT(bi, b){\n          int r = (*ai - *bi + 256) % 256;\n          res.insert(r);\n        }\n        stk.push(res);\n      }else if(s == \"*\"){\n        set<int> b = stk.top(); stk.pop();\n        set<int> a = stk.top(); stk.pop();\n        set<int> res;\n        FORIT(ai, a)FORIT(bi, b){\n          int r = (*ai * *bi) % 256;\n          res.insert(r);\n        }\n        stk.push(res);\n      }else if(s == \"/\"){\n        set<int> b = stk.top(); stk.pop();\n        set<int> a = stk.top(); stk.pop();\n        set<int> res;\n        FORIT(ai, a)FORIT(bi, b){\n          if(*bi != 0){\n            int r = (*ai / *bi) % 256;\n            res.insert(r);\n          }else{\n            correct = false;\n          }\n        }\n        stk.push(res);\n      }else{\n        int n = atoi(s.c_str());\n        set<int> st;\n        st.insert(n);\n        stk.push(st);\n      }\n    }\n    if(correct) cout<<\"correct\"<<endl;\n    else cout<<\"error\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"tune=native\")\n#pragma GCC target(\"avx\")\n// #pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = i64(1e18)+MOD;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int m;\n    input(m);\n    vector<string> c(m);\n    vector<int> l(m), r(m);\n    unordered_map<string, pair<int,int>> ma;\n    pararell_input(m, c, l, r);\n    for(auto& x : r)\n        ++x;\n    for(int i = 0; i < m; ++i)\n        ma[c[i]] = make_pair(l[i], r[i]);\n    int n;\n    input(n);\n    vector<string> v(n);\n    input(v);\n    vector<string> op{\"+\", \"-\", \"*\", \"/\"};\n\n    using bs = bitset<256>;\n    stack<bs> st;\n\n    for(int i = 0; i < n; ++i){\n        if(ma.find(v[i]) != ma.end()){\n            bs s;\n            auto p = ma[v[i]];\n            for(int j = p.first; j < p.second; ++j)\n                s.set(j);\n            st.push(s);\n        }else if(find(op.begin(), op.end(), v[i]) != op.end()){\n\n            if(st.size() < 2){\n                cout << \"error\" << endl;\n                return 0;\n            }\n            bs b = st.top();\n            st.pop();\n            bs a = st.top();\n            st.pop();\n\n            bs ans;\n\n            for(int j = 0; j < 256; ++j)\n                for(int k = 0; k < 256; ++k){\n                    if(!a[j] || !b[k])\n                        continue;\n                    if(v[i] == \"+\"){\n                        int val = (j + k) % 256;\n                        ans.set(val);\n                    }\n                    if(v[i] == \"-\"){\n                        int val = (j - k + 256) % 256;\n                        ans.set(val);\n                    }\n                    if(v[i] == \"*\"){\n                        int val = (j * k) % 256;\n                        ans.set(val);\n                    }\n                    if(v[i] == \"/\"){\n                        if(k == 0){\n                            cout << \"error\" << endl;\n                            return 0;\n                        }\n                        int val = j / k;\n                        ans.set(val);\n                    }\n                }\n\n            st.push(ans);\n\n        }else{\n            int val = stoi(v[i]);\n            bs s;\n            s.set(val);\n            st.push(s);\n        }\n    }\n\n    if(st.size() == 1)\n        cout << \"correct\" << endl;\n    else\n        cout << \"error\" << endl;\n\n    return false;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint n;\n\tmap<string,pii>ma;\n\tstring w=\"+-*/\";\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tint a,b;cin>>s>>a>>b;\n\t\tma[s]={a,b+1};\n\t}\n\tcin>>n;\n\tbool h=true;\n\tvvi in;\n\trep(i,n){\n\t\tstring s;cin>>s;\n\t\tif(w.find(s[0])!=string::npos){\n\t\t\tint m=in.size();\n\t\t\tvi ne(256);\n\t\t\trep(j,256)rep(k,256)if(in[m-2][j]&&in[m-1][k]){\n\t\t\t\tif(s==\"+\")ne[(j+k)%256]=true;\n\t\t\t\tif(s==\"-\")ne[(j-k+256)%256]=true;\n\t\t\t\tif(s==\"*\")ne[(j*k)%256]=true;\n\t\t\t\tif(s==\"/\"){\n\t\t\t\t\tif(k==0)h=false;\n\t\t\t\t\telse ne[j/k]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tin.erase(in.begin()+m-1);\n\t\t\tin[m-2]=ne;\n\t\t}else{\n\t\t\tvi t(256);\n\t\t\tif(ma.count(s)){\n\t\t\t\tpii a=ma[s];\n\t\t\t\tloop(j,a.first,a.second)t[j]=true;\n\t\t\t}else{\n\t\t\t\tt[stoi(s)]=true;\n\t\t\t}\n\t\t\tin.pb(t);\n\t\t}\n\t}\n\tif(h)cout<<\"correct\"<<endl;\n\telse cout<<\"error\"<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int m,n=inf;\n    cin >> m;\n    vector<string> name(m);\n    vector<set<int>> vs(m);\n    rep(i,0,m){\n        int lb,ub;\n        cin >> name[i] >> lb >> ub;\n        rep(j,lb,ub+1) vs[i].insert(j);\n    }\n    cin >> n;\n\n    stack<set<int>> stk;\n    rep(i,0,n){\n        string e;\n        cin >> e;\n        if(e==\"+\" or e==\"-\" or e==\"*\" or e==\"/\"){\n            set<int> s2=stk.top(); stk.pop();\n            set<int> s1=stk.top(); stk.pop();\n            set<int> tmp;\n            for(auto a:s1) for(auto b:s2){\n                if(e==\"+\") tmp.insert((a+b)%256);\n                if(e==\"-\") tmp.insert((a-b+256)%256);\n                if(e==\"*\") tmp.insert(a*b%256);\n                if(e==\"/\"){\n                    if(b==0){\n                        cout << \"error\" << endl;\n                        return;\n                    }\n                    tmp.insert(a/b);\n                }\n            }\n            stk.push(tmp);\n            continue;\n        }\n\n        bool flag=true;\n        rep(j,0,m) if(name[j]==e){\n            stk.push(vs[j]);\n            flag=false;\n            break;\n        }\n        if(flag){\n            set<int> tmp;\n            tmp.insert(stoi(e));\n            stk.push(tmp);\n        }\n    }\n    cout << \"correct\" << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout << fixed << setprecision(8);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\nint main(void){\n    int m; cin >> m;\n    map<string, pii> s2d;\n    rep(i, m){\n        string name; cin >> name;\n        cin >> s2d[name].first >> s2d[name].second;\n    }\n\n    int n; cin >> n;\n    stack<vi> stk;\n    rep(loop, n){\n        string op; cin >> op;\n        \n        if(op == \"+\" or op == \"-\" or op == \"*\" or op == \"/\"){\n            if(stk.size() < 2){\n                cout << \"error\" << endl;\n                return 0;\n            }\n            vi b = stk.top(); stk.pop();\n            vi a = stk.top(); stk.pop();\n\n            vi c(256);\n            rep(i, 256){\n                rep(j, 256){\n                    if(a[i] and b[j]){\n                        int res;\n                        if(op == \"+\") res = (i + j) & 255;\n                        if(op == \"-\") res = (i - j) & 255;\n                        if(op == \"*\") res = (i * j) & 255;\n                        if(op == \"/\"){\n                            if(j == 0){\n                                cout << \"error\" << endl;\n                                return 0;\n                            }\n                            res = (i / j) & 255;\n                        }\n                        c[res] = true;\n                    }\n                }\n            }\n            stk.push(c);\n        }\n        else {\n            vi a(256);\n            if(s2d.find(op) != end(s2d)){\n                range(i, s2d[op].first, s2d[op].second + 1){\n                    a[i] = true;\n                }\n            }\n            else {\n                stringstream ss(op);\n                int num; ss >> num;\n                a[num] = true;\n            }\n\n            stk.push(a);\n        }\n    }\n\n    if(stk.size() != 1){\n        cout << \"error\" << endl;\n        return 0;\n    }\n\n    cout << \"correct\" << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint m, n;\nmap<string, pii> mp;\nstring e[110];\nint dp[110][110][256];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    string name;\n    int lb, ub;\n    cin >> name >> lb >> ub;\n    mp[name] = pii(lb, ub);\n  }\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> e[i];\n  }\n\n  stack<pii> st;\n  for (int i = 0; i < n; i++) {\n    if (isdigit(e[i][0])) {\n      dp[i][i][stoi(e[i])] = 1;\n      st.emplace(i, i);\n    } else if (isalpha(e[i][0])) {\n      pii r = mp[e[i]];\n      for (int j = 0; j < 256; j++) {\n        dp[i][i][j] = (r.first <= j && j <= r.second);\n      }\n      st.emplace(i, i);\n    } else {\n      if (st.size() < 2) {\n        cout << \"error\" << endl;\n        return 0;\n      }\n      pii a, b;\n      b = st.top(); st.pop();\n      a = st.top(); st.pop();\n      if (e[i] == \"+\") {\n        for (int j = 0; j < 256; j++) {\n          for (int k = 0; k < 256; k++) {\n            dp[a.first][i][(j+k)%256] |= (dp[a.first][a.second][j] && dp[b.first][b.second][k]);\n          }\n        }\n      } else if (e[i] == \"-\") {\n        for (int j = 0; j < 256; j++) {\n          for (int k = 0; k < 256; k++) {\n            dp[a.first][i][(j-k+256)%256] |= (dp[a.first][a.second][j] && dp[b.first][b.second][k]);\n          }\n        }\n      } else if (e[i] == \"*\") {\n        for (int j = 0; j < 256; j++) {\n          for (int k = 0; k < 256; k++) {\n            dp[a.first][i][(j*k)%256] |= (dp[a.first][a.second][j] && dp[b.first][b.second][k]);\n          }\n        }\n      } else if (e[i] == \"/\") {\n        if (dp[b.first][b.second][0]) {\n          cout << \"error\" << endl;\n          return 0;\n        }\n        for (int j = 0; j < 256; j++) {\n          for (int k = 1; k < 256; k++) {\n            dp[a.first][i][(j/k)%256] |= (dp[a.first][a.second][j] && dp[b.first][b.second][k]);\n          }\n        }\n      }\n      st.emplace(a.first, i);\n    }\n  }\n  cout << \"correct\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstring>\n#include <climits>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m;\nmap<string,P> hensu;\nstring t[102];\nbool op[102], h[102], d[102];\n\nbool dp[102][102][256];\n\nbool solve(){\n  memset(dp, 0, sizeof(dp));\n\n  int size = 0;\n\n  for(int i = 0; i < m; i++){\n    if(d[i]){\n      int x = atoi(t[i].c_str());\n\n      dp[i + 1][size][x] = true;\n      size++;\n\n      for(int j = 0; j < size - 1; j++){\n        for(int k = 0; k < 256; k++){\n          dp[i + 1][j][k] = dp[i][j][k];\n        }\n      }\n    }\n    else if(h[i]){\n      int from = hensu[t[i]].first;\n      int to = hensu[t[i]].second;\n\n      for(int j = from; j <= to; j++){\n        dp[i + 1][size][j] = true;\n      }\n\n      size++;\n\n      for(int j = 0; j < size - 1; j++){\n        for(int k = 0; k < 256; k++){\n          dp[i + 1][j][k] = dp[i][j][k];\n        }\n      }\n    }\n    else{\n      size--;\n\n      int cal;\n\n      for(int j = 0; j < 256; j++){ //ue\n        for(int k = 0; k < 256; k++){ //shita\n          if(!dp[i][size][j] || !dp[i][size - 1][k]) continue;\n\n          if(t[i] == \"+\"){\n            cal = (k + j) % 256;\n          }\n          else if(t[i] == \"-\"){\n            cal = (k - j + 256) % 256;\n          }\n          else if(t[i] == \"*\"){\n            cal = (k * j) % 256;\n          }\n          else{\n            if(j == 0){\n              return false;\n            }\n\n            cal = (k / j) % 256;\n          }\n\n          dp[i + 1][size - 1][cal] = true;\n        }\n      }\n\n      for(int j = 0; j < size - 1; j++){\n        for(int k = 0; k < 256; k++){\n          dp[i + 1][j][k] = dp[i][j][k];\n        }\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i <= m; i++){\n    for(int j = 0; j < 3; j++){\n      for(int k = 0; k <= 20; k++){\n        printf(\"%d \", dp[i][j][k]);\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n  }\n  */\n\n  return true;\n}\n\nint main(){\n  while(cin >> n){\n    for(int i = 0; i < n; i++){\n      string name;\n      P p;\n      cin >> name >> p.first >> p.second;\n      hensu[name] = p;\n    }\n\n    memset(op, 0, sizeof(op));\n    memset(h, 0, sizeof(h));\n    memset(d, 0, sizeof(d));\n\n    cin >> m;\n\n    for(int i = 0; i < m; i++){\n      cin >> t[i];\n\n      if(t[i][0] == '+' || t[i][0] == '-' || t[i][0] == '/' || t[i][0] == '*'){\n        op[i] = true;\n      }\n      else if(isdigit(t[i][0])){\n        d[i] = true;\n      }\n      else{\n        h[i] = true;\n      }\n    }\n\n    if(solve()) cout << \"correct\\n\";\n    else        cout << \"error\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t  \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\t  \n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\n\t  ele_b = ele.top(),ele.pop();\n\t  if(ele.empty())\n\t    {\n\t      cout << \"error\" << endl;\n\t      return 0; \n\t    }\t  \n\t  ele_a = ele.top(),ele.pop();\n\t \n\t  set<int> A,B,C;\n\t  if(index.count(ele_a) == 0)\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(index.count(ele_b) == 0)\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  C.insert((int)ceil((double)(*it_a)/(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[ele_b] = C;\n\t  ele.push(ele_b);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool solve() {\n\tint m; cin >> m;\n\tmap<string, pair<int, int>> range;\n\twhile(m--) {\n\t\tstring name; cin >> name;\n\t\tint lb, ub; cin >> lb >> ub;\n\t\trange[name] = {lb, ub};\n\t}\n\tint n; cin >> n;\n\tstack<set<int>> num;\n\twhile(n--) {\n\t\tstring e; cin >> e;\n\t\tset<int> st;\n\t\tif(range.count(e)) {\n\t\t\tfor(int i = range[e].first; i <= range[e].second; ++i) {\n\t\t\t\tst.insert(i);\n\t\t\t}\n\t\t} else if(e == \"+\" or e == \"-\" or e == \"*\" or e == \"/\") {\n\t\t\tauto st2 = num.top();\n\t\t\tnum.pop();\n\t\t\tauto st1 = num.top();\n\t\t\tnum.pop();\n\t\t\tfor(auto lhs : st1) {\n\t\t\t\tfor(auto rhs : st2) {\n\t\t\t\t\tif(e == \"+\") st.insert((lhs + rhs) % 256);\n\t\t\t\t\tif(e == \"-\") st.insert((lhs - rhs + 256) % 256);\n\t\t\t\t\tif(e == \"*\") st.insert((lhs * rhs) % 256);\n\t\t\t\t\tif(e == \"/\") {\n\t\t\t\t\t\tif(rhs == 0) return false;\n\t\t\t\t\t\tst.insert((lhs / rhs) % 256);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint tmp = 0;\n\t\t\tfor(char c : e) {\n\t\t\t\ttmp *= 10;\n\t\t\t\ttmp += c - '0';\n\t\t\t}\n\t\t\tst.insert(tmp);\n\t\t}\n\t\tnum.push(st);\n\t}\n\treturn true;\n}\n\nint main() {\n\tcout << (solve() ? \"correct\" : \"error\") << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<unsigned char, unsigned char> P;\ntypedef vector<unsigned char> nv;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nbool calc_form(string op,nv a,nv b,nv& res){\n  if(op==\"/\"){\n    rep(i,b.size()){\n      if(b[i]==0)return false;\n    }\n  }\n  rep(i,a.size())rep(j,b.size()){\n    unsigned char add;\n    if(op==\"+\"){\n      add=a[i]+b[j];\n    }else if(op==\"-\"){\n      add=a[i]-b[j];\n    }else if(op==\"*\"){\n      add=a[i]*b[j];\n    }else{\n      add=a[i]/b[j];\n    }\n    res.push_back(add);\n  }\n  sort(all(res));\n  uni(res);\n  return true;\n}\n\nint n,m;\nmap<string,P> h;\nstack<nv> st;\nvector<string> form;\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>m;\n  rep(i,m){\n    string name; int a,b;\n    cin>>name>>a>>b;\n    h[name]=P(a,b);\n  }\n  cin>>n;\n  rep(i,n){\n    string a;\n    cin>>a;\n    form.push_back(a);\n  }\n  rep(i,n){\n    string a=form[i];\n    if(a==\"+\"||a==\"-\"||a==\"*\"||a==\"/\"){\n      nv n2=st.top(); st.pop();\n      nv n1=st.top(); st.pop();\n      nv tmp;\n      if(!calc_form(a,n1,n2,tmp)){\n        cout<<\"error\"<<endl;\n        return 0;\n      }\n      st.push(tmp);\n    }else if(h.count(a)){\n      nv tmp;\n      repl(i,h[a].fi,h[a].se+1){\n        tmp.push_back(i);\n      }\n      st.push(tmp);\n    }else{\n      nv tmp;\n      tmp.push_back(stoi(a));\n      st.push(tmp);\n    }\n  }\n  cout<<\"correct\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbool calc(set<int>& B,set<int>& A,string ope,stack<set<int> >& ele)\n{\n  set<int> C;\n  for(set<int>::iterator it_B = B.begin();it_B != B.end();it_B++)\n    {\n      for(set<int>::iterator it_A = A.begin();it_A != A.end();it_A++)\n\t{\n\t  if(ope == \"+\")\n\t    {\n\t      C.insert(((*it_A)+(*it_B))%256);\n\t    }\n\t  else if(ope == \"-\")\n\t    {\n\t      C.insert(((*it_A)-(*it_B)+256)%256);\n\t    }\n\t  else if(ope == \"*\")\n\t    {\n\t      C.insert(((*it_A)*(*it_B))%256);\n\t    }\n\t  else if(ope == \"/\")\n\t    {\n\t      if(!(*it_B))\n\t\t{\n\t\n\t\t  return false; \n\t\t}\n\t      C.insert(((*it_A)/(*it_B))%256);\n\t    }\n\t  else \n\t    assert(false);\n\t}\n    }\n  index[My] = C;\n  ele.push(C);\n  return true;\n}\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<set<int> > ele;\n  deque<string> st;\n  bool fin = false;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n     \n      if(e != \"/\" && e != \"*\" && e != \"-\" && e != \"+\")\n\t{\n\t  if(index.find(e) != index.end())\n\t    {\n\t      ele.push(index[e]);\n\t    }\n\t  else\n\t    {\n\t      set<int> FAGS;\n\t      FAGS.insert((atoi)(e.c_str()));\n\t      ele.push(FAGS);\n\t    }\n\t}\n      else \n\t{\n\t  set<int> A,B;\n\t  B = ele.top(),ele.pop();\n\t  A = ele.top(),ele.pop();\n\t  if(!calc(B,A,e,ele))\n\t    fin = true;\t    \n\t}\n\n    }\n\n  if(fin)\n    {\n      cout << \"error\" << endl;\n      return 0;\n    }\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int m;\n    cin >> m;\n    map<string, set<int>> range;\n    for(int i=0; i<m; ++i) {\n        string name;\n        int lb, ub;\n        cin >> name >> lb >> ub;\n        set<int>& s = range[name];\n        for(int j=lb; j<=ub; ++j) {\n            s.insert(j);\n        }\n    }\n\n    int n;\n    cin >> n;\n    vector<string> e(n);\n    for(int i=0; i<n; ++i) {\n        cin >> e[i];\n    }\n    stack<set<int>> st;\n    bool f = false;\n    for(int i=0; i<n; ++i) {\n        if(isdigit(e[i][0])) {\n            int num = stoi(e[i]);\n            set<int> s = {num};\n            st.push(s);\n        } else if(e[i][0] == '+') {\n            set<int> s1 = st.top(); st.pop();\n            set<int> s2 = st.top(); st.pop();\n            set<int> s;\n            for(auto y : s1) {\n                for(auto x : s2) {\n                    s.insert((x + y) % 256);\n                }\n            }\n            st.push(s);\n        } else if(e[i][0] == '-') {\n            set<int> s1 = st.top(); st.pop();\n            set<int> s2 = st.top(); st.pop();\n            set<int> s;\n            for(auto y : s1) {\n                for(auto x : s2) {\n                    s.insert((x - y + 256) % 256);\n                }\n            }\n            st.push(s);\n        } else if(e[i][0] == '/') {\n            set<int> s1 = st.top(); st.pop();\n            set<int> s2 = st.top(); st.pop();\n            set<int> s;\n            if(s1.count(0) == 1) {\n                f = true;\n                break;\n            }\n            for(auto y : s1) {\n                for(auto x : s2) {\n                    s.insert((x / y) % 256);\n                }\n            }\n            st.push(s);\n        } else if(e[i][0] == '*') {\n            set<int> s1 = st.top(); st.pop();\n            set<int> s2 = st.top(); st.pop();\n            set<int> s;\n            for(auto y : s1) {\n                for(auto x : s2) {\n                    s.insert((x * y) % 256);\n                }\n            }\n            st.push(s);\n        } else {\n            st.push(range[e[i]]);\n        }\n    }\n\n    if(f) {\n        cout << \"error\" << endl;\n    } else {\n        cout << \"correct\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 256\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint calc(int a, int op, int b)\n{    \n    if (op == 0) {\n        return (a + b) % 256;\n    } else if (op == 1) {\n        return (a - b + 256) % 256;\n    } else if (op == 2) {\n        return (a * b) % 256;\n    } else {\n        return (b == 0 ? MAX : (a / b) % 256);\n    }\n}\n\nbool zero_division_checker()\n{\n    stack<vector<int>> st;\n    for (int i = 0; i < n; i++) {\n        if (isdigit(e[i][0])) {\n            vector<int> v = {s2i(e[i])};\n            st.push(v);\n        } else {\n            int op = op_num(e[i][0]);\n            if (op >= 0) {\n                vector<int> vb = st.top(); st.pop();\n                vector<int> va = st.top(); st.pop();\n                vector<int> v;\n                for (int j = 0; j < (int)va.size(); j++) {\n                    for (int k = 0; k < (int)vb.size(); k++) {\n                        int res = calc(va[j], op, vb[k]);\n                        if (res == MAX) {\n                            return 0;\n                        }\n                        v.push_back(res);\n                    }\n                }\n                sort(v.begin(), v.end());\n                v.erase(unique(v.begin(), v.end()), v.end());\n                st.push(v);\n            } else {\n                vector<int> v;\n                pii p = mp[e[i]];\n                for (int j = p.first; j <= p.second; j++) {\n                    v.push_back(j);\n                }\n                st.push(v);                \n            }\n        }\n    }\n    return 1;\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    cout << (zero_division_checker() ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 256\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint calc(int a, int op, int b)\n{\n    if (op == 0) {\n        return (a + b) % 256;\n    } else if (op == 1) {\n        return (a - b + 256) % 256;\n    } else if (op == 2) {\n        return (a * b) % 256;\n    } else {\n        return (a / b) % 256;\n    }\n}\n\nbool zero_division_checker()\n{\n    stack<int> st;\n    stack<vector<int>> st2;\n    for (int i = 0; i < n; i++) {\n        if (isdigit(e[i][0])) {            \n            st.push(s2i(e[i]));\n        } else {\n            int op = op_num(e[i][0]);\n            if (op >= 0) {\n                int b = st.top(); st.pop();\n                int a = st.top(); st.pop();\n                vector<int> v;\n                if (a == MAX) {\n                    if (b == MAX) {\n                        vector<int> vb = st2.top(); st2.pop();\n                        vector<int> va = st2.top(); st2.pop();\n                        for (int j = 0; j < (int)va.size(); j++) {\n                            for (int k = 0; k < (int)vb.size(); k++) {\n                                if (op == 3 && vb[k] == 0) {\n                                    return false;\n                                }\n                                v.push_back(calc(va[j], op, vb[k]));\n                            }\n                        }\n                    } else {\n                        if (op == 3 && b == 0) {\n                            return false;\n                        }\n                        vector<int> va = st2.top(); st2.pop();\n                        for (int j = 0; j < (int)va.size(); j++) {\n                            v.push_back(calc(va[j], op, b));\n                        }                        \n                    }\n                    sort(v.begin(), v.end());\n                    v.erase(unique(v.begin(), v.end()), v.end());\n                    st.push(MAX);\n                    st2.push(v);\n                } else {\n                    if (b == MAX) {\n                        vector<int> vb = st2.top(); st2.pop();\n                        for (int j = 0; j < (int)vb.size(); j++) {\n                            if (op == 3 && vb[j] == 0) {\n                                return false;\n                            }\n                            v.push_back(calc(a, op, vb[j]));\n                        }\n                        sort(v.begin(), v.end());\n                        v.erase(unique(v.begin(), v.end()), v.end());\n                        st.push(MAX);\n                        st2.push(v);\n                    } else {\n                        if (op == 3 && b == 0) {\n                            return false;\n                        }\n                        st.push(calc(a, op, b));       \n                    }\n                }                    \n            } else {\n                vector<int> v;\n                pii p = mp[e[i]];\n                for (int j = p.first; j <= p.second; j++) {\n                    v.push_back(j);\n                }\n                st.push(MAX);\n                st2.push(v);                \n            }\n        }\n    }\n    return true;\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    cout << (zero_division_checker() ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 256\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M, n;\nstring str;\nmap<string,P> m;\nstack<vector<int> > st;\nvector<int> tmp, n1, n2;\nint dp[100][256];\nbool ok = true;\n\nvector<int> calc(int x, vector<int> v1, vector<int> v2){\n\t/*\n\tcout << x << endl;\n\trep(i,v1.size()) cout << v1[i] << \" \";\n\tcout << endl;\n\trep(i,v2.size()) cout << v2[i] << \" \";\n\tcout << endl;\n\t*/\n\tvector<int> ret;\n\trep(i,v1.size()) rep(j,v2.size()){\n\t\tif(x == 0) ret.push_back((v1[i]*v2[j])%MOD);\n\t\tif(x == 1) ret.push_back((v1[i]+v2[j])%MOD);\n\t\tif(x == 2) ret.push_back((v1[i]-v2[j]+MOD)%MOD);\n\t\tif(x == 3){\n\t\t\tif(v2[j] == 0){\n\t\t\t\tret.clear();\n\t\t\t\treturn ret;\n\t\t\t} else{\n\t\t\t\tret.push_back(v1[i]/v2[j]);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ret.begin(),ret.end());\n\tret.erase(unique(ret.begin(),ret.end()),ret.end());\n\treturn ret;\n}\n\nint main(){\n\tcin >> M;\n\trep(i,M){\n\t\tstring str;\n\t\tint s, e;\n\t\tcin >> str >> s >> e;\n\t\tm[str] = P(s,e);\n\t}\n\tcin >> n;\n\trep(i,n){\n\t\tcin >> str;\n\t\tif(str==\"*\"){\n\t\t\tn1 = st.top();\n\t\t\tst.pop();\n\t\t\tn2 = st.top();\n\t\t\tst.pop();\n\t\t\tst.push(calc(0,n2,n1));\n\t\t} else if(str==\"+\"){\n\t\t\tn1 = st.top();\n\t\t\tst.pop();\n\t\t\tn2 = st.top();\n\t\t\tst.pop();\n\t\t\tst.push(calc(1,n2,n1));\n\t\t} else if(str==\"-\"){\n\t\t\tn1 = st.top();\n\t\t\tst.pop();\n\t\t\tn2 = st.top();\n\t\t\tst.pop();\n\t\t\tst.push(calc(2,n2,n1));\n\t\t} else if(str==\"/\"){\n\t\t\tn1 = st.top();\n\t\t\tst.pop();\n\t\t\tn2 = st.top();\n\t\t\tst.pop();\n\t\t\tst.push(calc(3,n2,n1));\n\t\t\tn2 = st.top();\n\t\t\tif(n2.size() == 0){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if(m.count(str)==0){\n\t\t\tint num = atoi(str.c_str());\n\t\t\ttmp.clear();\n\t\t\ttmp.push_back(num);\n\t\t\tst.push(tmp);\n\t\t} else{\n\t\t\tP p = m[str];\n\t\t\ttmp.clear();\n\t\t\tfor(int j = p.first; j <= p.second; j++){\n\t\t\t\ttmp.push_back(j);\n\t\t\t}\n\t\t\tst.push(tmp);\n\t\t}\n\t}\n\tif(!ok) puts(\"error\");\n\telse puts(\"correct\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\n#define MAX 300\ntypedef pair<int, int> pii;\n \nint n;\nvector<string> e;\nmap<string, pii> mp;\n \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, vector<pii> vec)\n{\n    if (x == n) {\n        return true;\n    }\n    int l = vec.size();\n    int v = MAX-1, v2 = MAX-1;\n    \n    if (l >= 2) {\n        v = vec[0].second;\n        v2 = vec[l-1].second;\n    }\n    if (memo[x][v][v2] != -1) {\n        return memo[x][v][v2];\n    }        \n\n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        vec.push_back(pii(s2i(e[x]), x));\n        res = zero_division_checker(x+1, vec);\n        vec.pop_back();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            pii p2 = vec[l-1], p1 = vec[l-2];\n            int b = p2.first;\n            int a = p1.first;\n            vec.pop_back(); vec.pop_back();\n            \n            int c = -1;\n            if (op == 0) {\n                c = (a + b) % 256;\n            } else if (op == 1) {\n                c = (a - b + 256) % 256;\n            } else if (op == 2) {\n                c = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                c = (a / b) % 256;\n            }\n            vec.push_back(pii(c, x));\n            res = zero_division_checker(x+1, vec);\n            vec.pop_back();\n            vec.push_back(p1);\n            vec.push_back(p2);\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                vec.push_back(pii(i, x));\n                res &= zero_division_checker(x+1, vec);\n                vec.pop_back();\n            }\n        }\n    }\n    return (memo[x][v][v2] = res);\n}\n \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, vector<pii>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n#define MOD 256\n\ndeque<string> q;\nunordered_map<string, S> mp;\nint nameLength = 21;\n\nbool isDigit(string s) {\n    return '0' <= s[0] && s[0] <= '9';\n}\n\nbool calc(int op) {\n    string a, b;\n    a = q.back(), q.pop_back();\n    b = q.back(), q.pop_back();\n    bool aa = isDigit(a), bb = isDigit(b);\n    if (aa && bb) {\n        if (op == 0) q.push_back(to_string((stoi(a) + stoi(b)) % MOD));\n        else if (op == 1) q.push_back(to_string((stoi(a) - stoi(b) + MOD) % MOD));\n        else if (op == 2) q.push_back(to_string((stoi(a) * stoi(b)) % MOD));\n        else {\n            if (stoi(b) != 0) q.push_back(to_string((stoi(a) / stoi(b)) % MOD));\n            else return false;\n        }\n    } else if (!aa && !bb) {\n        S c;\n        if (op == 0) each(i, mp[a])each(j, mp[b]) c.insert((i + j) % MOD);\n        else if (op == 1) each(i, mp[a])each(j, mp[b]) c.insert((i - j + MOD) % MOD);\n        else if (op == 2) each(i, mp[a])each(j, mp[b]) c.insert((i * j) % MOD);\n        else  each(i, mp[a])each(j, mp[b]) {\n            if (j != 0) c.insert((i / j) % MOD);\n            else return false;\n        }\n        string newStr('a', nameLength++);\n        q.push_back(newStr);\n        mp[newStr] = c;\n    } else {\n        if (!aa) swap(a, b);\n        S c;\n        int d = stoi(a);\n        if (op == 0) each(i, mp[b]) c.insert((d + i) % MOD);\n        else if (op == 1) each(i, mp[b]) c.insert((d - i + MOD) % MOD);\n        else if (op == 2) each(i, mp[b]) c.insert((d * i) % MOD);\n        else each(i, mp[b]) {\n            if (i != 0) c.insert((d / i) % MOD);\n            else return false;\n        }\n        string newStr('a', nameLength++);\n        q.push_back(newStr);\n        mp[newStr] = c;\n    }\n    return true;\n}\n\nbool decode(string s) {\n    bool ret = true;\n    if (s[0] == '+') {\n        ret = calc(0);\n    } else if (s[0] == '-') {\n        ret = calc(1);\n    } else if (s[0] == '*') {\n        ret = calc(2);\n    } else if (s[0] == '/') {\n        ret = calc(3);\n    } else {\n        q.push_back(s);\n    }\n    return ret;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n, m;\n    cin >> m;\n    rep(i, m) {\n        string s;\n        int l, u;\n        cin >> s >> l >> u;\n        S st;\n        repl(j, l, u + 1) st.insert(j);\n        mp[s] = st;\n    }\n\n    cin >> n;\n    bool ok = true;\n    rep(i, n) {\n        string s;\n        cin >> s;\n        ok = decode(s);\n        if (!ok) break;\n    }\n\n    if (ok) cout << \"correct\" << endl;\n    else cout << \"error\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n#define exist(c, v) (find((c).begin(), (c).end(), (v)) != (c).end())\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\ninline int stoi(const string& s) {\n\tistringstream is(s);\n\tint res;\n\tis >> res;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tconst int mod = 256;\n\n\tint m;\n\tcin >> m;\n\n\tmap<string, set<int> > memo;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint l, r;\n\t\tstring name;\n\t\tcin >> name >> l >> r;\n\n\t\tset<int> s;\n\t\tfor(int i = l; i <= r; ++i)\n\t\t\ts.insert(i);\n\n\t\tmemo[name] = s;\n\t}\n\n\n\tint n;\n\tcin >> n;\n\n\tstack<set<int> > sta;\n\tfor(int i = 0; i < n; ++i) {\n\t\tstring e;\n\t\tcin >> e;\n\n\t\tif(memo.count(e))\n\t\t\tsta.push(memo[e]);\n\n\t\telse if(e == \"+\" || e == \"-\" || e == \"*\" || e == \"/\") {\n\t\t\tconst set<int> b = sta.top();\n\t\t\tsta.pop();\n\n\t\t\tconst set<int> a = sta.top();\n\t\t\tsta.pop();\n\n\t\t\tset<int> result;\n\t\t\tFOR(it, a) {\n\t\t\t\tFOR(it2, b) {\n\t\t\t\t\tif(e == \"+\")\n\t\t\t\t\t\tresult.insert(((*it) + (*it2)) % mod);\n\n\t\t\t\t\telse if(e == \"-\")\n\t\t\t\t\t\tresult.insert(((*it) - (*it2) + mod) % mod);\n\n\t\t\t\t\telse if(e == \"*\")\n\t\t\t\t\t\tresult.insert(((*it) * (*it2)) % mod);\n\n\t\t\t\t\telse {\n\t\t\t\t\t\tif((*it2) == 0) {\n\t\t\t\t\t\t\tcout << \"error\" << endl;\n\t\t\t\t\t\t\treturn EXIT_SUCCESS;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult.insert((*it) / (*it2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsta.push(result);\n\t\t}\n\n\t\telse {\n\t\t\tset<int> s;\n\t\t\ts.insert(stoi(e));\n\t\t\tsta.push(s);\n\t\t}\n\t}\n\n\tcout << \"correct\" << endl;\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct num{\n  int d[256];\n  num(){ memset(d,0,sizeof(d)); }\n  num(int flag){\n    if( flag == -1 ) memset(d,-1,sizeof(d));\n  }\n};\n\nnum tas( num a,num b){\n  num ret;\n  for(int i=0;i<256;i++)\n    for(int j=0;j<256;j++)\n      if( a.d[i] == 1 && b.d[j] == 1 )\n\tret.d[(i+j)%256] = 1;\n  return ret;\n}\n\nnum mina(num a,num b){\n  num ret;\n  for(int i=0;i<256;i++)\n    for(int j=0;j<256;j++)\n      if( a.d[i] == 1 && b.d[j] == 1 )\n\tret.d[(i-j+256)%256] = 1;\n  return ret;\n}\n\n\nnum kake(num a,num b){\n  num ret;\n  for(int i=0;i<256;i++)\n    for(int j=0;j<256;j++)\n      if( a.d[i] == 1 && b.d[j] == 1 )\n\tret.d[(i*j)%256] = 1;\n  return ret;\n}\n\nnum waru(num a,num b){\n  num ret;\n  for(int i=0;i<256;i++){\n    for(int j=0;j<256;j++){\n      if( a.d[i] == 1 && b.d[j] == 1 ){\n\tif( j == 0 ) return num(-1);\n\tret.d[(i/j)%256] = 1;\n      }\n    }\n  }\n  return ret;\n}\n\n\nint M,N;\nmap<string,num> fie;\n\nint main(){\n\n  cin >> M;\n  for(int i=0;i<M;i++){\n    string name;\n    int u,b;\n    cin >> name >> u >> b;\n    for(int i=u;i<=b;i++)\n      fie[name].d[i] = 1;\n  }\n\n  cin >> N;\n  stack<num> st;\n  bool f = false;\n  for(int i=0;i<N;i++){\n    string s;\n    cin >> s;\n    if( s == \"+\" ) {\n      num b = st.top(); st.pop();\n      num a = st.top(); st.pop();\n      st.push( tas(a,b) );\n    } else if (  s== \"-\" ){\n      num b = st.top(); st.pop();\n      num a = st.top(); st.pop();\n      st.push( mina(a,b) );\n    } else if ( s==\"/\" ){\n      num b = st.top(); st.pop();\n      num a = st.top(); st.pop();\n      num tmp = waru(a,b);\n      if( tmp.d[0] == -1 ) f = true;\n      st.push( tmp );      \n    } else if ( s==\"*\" ){\n      num b = st.top(); st.pop();\n      num a = st.top(); st.pop();\n      st.push( kake(a,b) );\n    } else if ( '0' <= s[0] && s[0] <= '9' ){\n      stringstream sin(s);\n      int at;\n      sin >> at;\n      num tmp; tmp.d[at] = 1;\n      st.push( tmp );\n    } else {\n      st.push( fie[s] );\n    }\n  }\n \n  cout << (f?\"error\":\"correct\") << endl; \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nbool isDigits(char c) {return c>='0'&&c<='9';}\n\nbool isAllDigits(string s) {\n\tfor(auto& c : s) {\n\t\tif(!isDigits(c)) return false;\n\t}\n\treturn true;\n}\nll StoLL(const string& s) {\n\tll ret = 0LL;\n\tfor(auto& c : s) ret = ret*10 + (c-'0');\n\treturn ret;\n}\n\n//[l, r] wo merge\nset<pii> mergeSegment(const set<pii>& st) {\n\tset<pii> ret;\n\tif(st.size() == 0) return ret;\n\tauto p = *st.begin();\n\tauto it = st.begin();\n\tit++;\n\twhile(it != st.end()) {\n\t\tauto tmp = *it;\n\t\tif(p.se >= tmp.fi) {\n\t\t\tp.fi = min(p.fi, tmp.fi);\n\t\t\tp.se = max(p.se, tmp.se);\n\t\t}\n\t\telse{\n\t\t\tret.insert(p);\n\t\t\tp = tmp;\n\t\t}\n\t\tit++;\n\t}\n\tret.insert(p);\n\treturn ret;\n}\nstack<set<pii>> st;\n\nvoid plus_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi + b.fi)%256;\n\t\t\tp.se = (a.se + b.se)%256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid minus_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi - b.fi + 256) % 256;\n\t\t\tp.se = (a.se - b.se + 256) % 256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nvoid mult_st_pii(set<pii> A, set<pii> B){\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\t// pii p;\n\t\t\t// p.fi = (a.fi * b.fi)%256;\n\t\t\t// p.se = (a.se * b.se)%256;\n\t\t\t// if(p.se < p.fi) {\n\t\t\t// \tret.insert({0, p.se});\n\t\t\t// \tret.insert({p.fi, 255});\n\t\t\t// }\n\t\t\t// else ret.insert(p);\n\t\t\tREP(aa, a.fi, a.se+1) {\n\t\t\t\tREP(bb , b.fi, b.se+1) {\n\t\t\t\t\tret.insert({aa*bb%256,aa*bb%256});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n}\n\nbool div_st_pii(set<pii> A, set<pii> B) {\n\tset<pii> ret;\n\tfor(auto a : A) {\n\t\tfor(auto b : B) {\n\t\t\tif(b.fi == 0) return false;\n\t\t\tpii p;\n\t\t\tp.fi = (a.fi / b.fi)%256;\n\t\t\tp.se = (a.se / b.se)%256;\n\t\t\tif(p.se < p.fi) {\n\t\t\t\tret.insert({0, p.se});\n\t\t\t\tret.insert({p.fi, 255});\n\t\t\t}\n\t\t\telse ret.insert(p);\n\t\t}\n\t}\n\tret = mergeSegment(ret);\n\tst.push(ret);\n\treturn true;\n}\n\nint main(){\n\tint m;\n\tcin >> m;\n\tmap<string, pii> mp;\n\trep(i, m) {\n\t\tstring s;\n\t\tint l, r;\n\t\tcin >> s >> l >> r;\n\t\tmp[s] = {l, r};\n\t}\n\tint n;\n\tcin >> n;\n\trep(i, n) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif(isAllDigits(s)) {\n\t\t\tint num = StoLL(s);\n\t\t\tdump(num);\n\t\t\tset<pii>tmp;\n\t\t\ttmp.insert({num, num});\n\t\t\tst.push(tmp);\n\t\t}\n\t\telse if(s == \"+\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tplus_st_pii(a, b);\n\t\t}\n\t\telse if(s == \"-\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tminus_st_pii(a, b);\n\t\t}\n\t\telse if(s == \"*\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tmult_st_pii(a, b);\n\n\t\t\tdumpV(a);\n\t\t\tdumpV(b);STOP;\n\n\t\t}\n\t\telse if(s == \"/\") {\n\t\t\tauto b = st.top();\tst.pop();\n\t\t\tauto a = st.top();\tst.pop();\n\t\t\tif(!div_st_pii(a, b)) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tset<pii> tmp;\n\t\t\ttmp.insert(mp[s]);\n\t\t\tst.push(tmp);\n\n\t\t\tauto c = st.top();\n\t\t\tdumpV(c);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint n;\n\nbool calc(map<string, bitset<256>> &mp, vector<string> &e)\n{\n    stack<bitset<256>> st;\n    for (int i = 0; i < n; i++)\n    {\n        if (e[i] == \"+\")\n        {\n            bitset<256> b = st.top();\n            st.pop();\n            bitset<256> a = st.top();\n            st.pop();\n            bitset<256> r;\n            for (int j = 0; j < 256; j++)\n            {\n                for (int k = 0; k < 256; k++)\n                {\n                    if (a[j] && b[k])\n                    {\n                        r.set((j + k) % 256);\n                    }\n                }\n            }\n            st.push(r);\n        }\n        else if (e[i] == \"-\")\n        {\n            bitset<256> b = st.top();\n            st.pop();\n            bitset<256> a = st.top();\n            st.pop();\n            bitset<256> r;\n            for (int j = 0; j < 256; j++)\n            {\n                for (int k = 0; k < 256; k++)\n                {\n                    if (a[j] && b[k])\n                    {\n                        r.set((j - k + 256) % 256);\n                    }\n                }\n            }\n            st.push(r);\n        }\n        else if (e[i] == \"*\")\n        {\n            bitset<256> b = st.top();\n            st.pop();\n            bitset<256> a = st.top();\n            st.pop();\n            bitset<256> r;\n            for (int j = 0; j < 256; j++)\n            {\n                for (int k = 0; k < 256; k++)\n                {\n                    if (a[j] && b[k])\n                    {\n                        r.set((j * k) % 256);\n                    }\n                }\n            }\n            st.push(r);\n        }\n        else if (e[i] == \"/\")\n        {\n            bitset<256> b = st.top();\n            st.pop();\n            bitset<256> a = st.top();\n            st.pop();\n            bitset<256> r;\n            for (int j = 0; j < 256; j++)\n            {\n                for (int k = 0; k < 256; k++)\n                {\n                    if (a[j] && b[k])\n                    {\n                        if (k == 0)\n                            return false;\n                        r.set((j / k) % 256);\n                    }\n                }\n            }\n            st.push(r);\n        }\n        else\n        {\n            st.push(mp[e[i]]);\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int m;\n    cin >> m;\n    map<string, bitset<256>> mp;\n    for (int i = 0; i < m; i++)\n    {\n        string name;\n        int lb, ub;\n        cin >> name >> lb >> ub;\n        bitset<256> bs;\n        for (int i = lb; i <= ub; i++)\n        {\n            bs.set(i);\n        }\n        mp[name] = bs;\n    }\n    cin >> n;\n    vector<string> e(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> e[i];\n        if ('0' <= e[i][0] && e[i][0] <= '9')\n        {\n            int num = stoi(e[i]);\n            bitset<256> bs;\n            bs.set(num);\n            mp[e[i]] = bs;\n        }\n    }\n    if (calc(mp, e))\n    {\n        cout << \"correct\" << endl;\n    }\n    else\n    {\n        cout << \"error\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n&#160;&#160;&#160;\nusing namespace std;\n&#160;&#160;&#160;\n&#160;\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n&#160;\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n&#160;&#160;&#160;\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n&#160;\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n&#160;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n&#160;&#160;&#160;\ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;&#160; }\n&#160;&#160;\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n&#160;&#160;\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n&#160;&#160;&#160;\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {&#160;&#160;&#160; if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n&#160;&#160;&#160;\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n&#160;&#160;\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n&#160;&#160;\nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n&#160;\n&#160;\n&#160;\n&#160;\nint main()\n{\n&#160;&#160;&#160;&#160;int m;\n&#160;&#160;&#160;&#160;cin >> m;\n&#160;&#160;&#160;&#160;map<string, vector<int> > var;\n&#160;&#160;&#160;&#160;for (int i = 0; i < m; ++i)\n&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string s;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int l, u;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin >> s >> l >> u;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int j = l; j <= u; ++j)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;var[s].push_back(j);\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;int n;\n&#160;&#160;&#160;&#160;cin >> n;\n&#160;&#160;&#160;&#160;stack<vector<int> > s;\n&#160;&#160;&#160;&#160;for (int i = 0; i < n; ++i)\n&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;string in;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cin >> in;\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (var.count(in))\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s.push(var[in]);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (isdigit(in[0]))\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector<int> t;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.push_back(to_T<int>(in));\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s.push(t);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector<int> a, b;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;b = s.top(); s.pop();\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;a = s.top(); s.pop();\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;vector<int> c;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int i = 0; i < a.size(); ++i)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for (int j = 0; j < b.size(); ++j)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (in[0] == '+')\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c.push_back((a[i] + b[j]) % 256);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (in[0] == '-')\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c.push_back((a[i] - b[j] + 256) % 256);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else if (in[0] == '*')\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c.push_back((a[i] * b[j]) % 256);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if (b[j] == 0)\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout << \"error\" << endl;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return 0;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;c.push_back((a[i] / b[j]) % 256);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;sort_unique(c);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;s.push(c);\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}\n&#160;&#160;&#160;&#160;}\n&#160;\n&#160;&#160;&#160;&#160;cout << \"correct\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cxxabi.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    ((ll)1ll<60)\n#define INF     ((int)1<<30)\n#define EPS     (1e-9)\n#define MOD     (1000000007)\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool b=1;for(auto s:t)os<<(exchange(b,0)||strlen(abi::__cxa_demangle(typeid(S).name(),0,0,0))>20?\"\":\" \")<<s;return os<<endl;}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\tusing val=bitset<256>;\n\t\n\tint n;\n\tcin>>n;\n\tmap<string,val> num;\n\trep(_,n){\n\t    val v(0);\n\t    string s; cin>>s; \n\t    int l,r; cin>>l>>r;\n\t    range(i,l,r+1)v[i]=true;\n\t    num[s]=v;\n\t}\n\trep(i,256){\n\t    val v(0); v[i]=1;\n\t    num[to_string(i)]=v;\n\t}\n\tint m; cin>>m;\n\tbool ok=true;\n\tstack<val> vs;\n\trep(_,m){\n\t    string s; cin>>s;\n\t    val v(0);\n\t    if(s==\"+\"){\n\t        auto b=vs.top(); vs.pop();\n\t        auto a=vs.top(); vs.pop();\n\t        rep(i,256)rep(j,256){\n\t            if(a[i] and b[j]) v[(i+j)%256]=1;\n\t        }\n\t        vs.push(v);\n\t    }else if(s==\"-\"){\n\t        auto b=vs.top(); vs.pop();\n\t        auto a=vs.top(); vs.pop();\n\t        rep(i,256)rep(j,256){\n\t            if(a[i] and b[j]) v[(i-j+256)%256]=1;\n\t        }\n\t        vs.push(v);\n\t    }else if(s==\"*\"){\n\t        auto b=vs.top(); vs.pop();\n\t        auto a=vs.top(); vs.pop();\n\t        rep(i,256)rep(j,256){\n\t            if(a[i] and b[j]) v[(i*j)%256]=1;\n\t        }\n\t        vs.push(v);\n\t    }else if(s==\"/\"){\n\t        auto b=vs.top(); vs.pop();\n\t        auto a=vs.top(); vs.pop();\n\t        if(b[0]==1) {\n\t            ok=false;\n\t            break;\n\t        }\n\t        rep(i,256)rep(j,256){\n\t            if(a[i] and b[j]) v[(i/j)]=1;\n\t        }\n\t        vs.push(v);\n\t    }else{\n\t        vs.push(num[s]);\n\t    }\n\t}\n\tcout<<(ok?\"correct\":\"error\")<<endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <map>\n#include <stack>\n#include <vector>\n#include <cctype>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint n, m, last;\nmap<string, P> var;\nstack<set<int> > st;\nvector<string> input;\n\nbool solve(){\n   for(int i=0;i<input.size();i++){\n      bool f = true;\n      for(int j=0;j<input[i].size();j++){\n\t if(!(input[i][j] >= '0' && input[i][j] <= '9')) f = false;\n      }\n      if(f){\n\t int tmp = atoi(input[i].c_str());\n\t set<int> tmp1;\n\t tmp1.insert(tmp);\n\t st.push(tmp1);\n      }else if(input[i] == \"+\" || input[i] == \"-\" || input[i] == \"*\" || input[i] == \"/\"){\n\t set<int> s1, s2, s3;\n\t s2 = st.top();\n\t st.pop();\n\t s1 = st.top();\n\t st.pop();\n\t for(set<int>::iterator ite1 = s1.begin();ite1!=s1.end();ite1++){\n\t    for(set<int>::iterator ite2 = s2.begin();ite2!=s2.end();ite2++){\n//\t       cout << *ite1 << ' ' << *ite2 << endl;\n\t       if(input[i] == \"+\"){\n\t\t  s3.insert(((*ite1) + (*ite2)) % 256);\n\t       }else if(input[i] == \"-\"){\n\t\t  s3.insert(((*ite1) - (*ite2) + 256) % 256);\n\t       }else if(input[i] == \"*\"){\n\t\t  s3.insert(((*ite1) * (*ite2)) % 256);\n\t       }else if(input[i] == \"/\"){\n\t\t  if((*ite2) == 0) return false;\n\t\t  s3.insert(((*ite1) / (*ite2)) % 256);\n\t       }\n\t    }\n\t }\n\t st.push(s3);\n      }else{\n\t set<int> tmp;\n\t for(int j=var[input[i]].first;j<=var[input[i]].second;j++){\n\t    tmp.insert(j);\n\t }\n\t st.push(tmp);\n      }\n   }\n   return true;\n}\n\nmain(){\n   cin >> m;\n   for(int i=0;i<m;i++){\n      string name;\n      int a, b;\n      cin >> name >> a >> b;\n      var[name] = P(a, b);\n   }\n   cin >> n;\n   for(int i=0;i<n;i++){\n      string in;\n      cin >> in;\n      input.push_back(in);\n   }\n   cout << (solve() ? \"correct\" : \"error\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nmap<string, bitset<256> > variable;\n\nbitset<256> setValue(const string& s)\n{\n    if(variable.find(s) != variable.end())\n        return variable[s];\n\n    istringstream iss(s);\n    int a;\n    iss >> a;\n    bitset<256> bs;\n    bs[a] = true;\n    return bs;\n}\n\nbool solve()\n{\n    int m;\n    cin >> m;\n    for(int i=0; i<m; ++i){\n        string s;\n        int lb, ub;\n        cin >> s >> lb >> ub;\n\n        bitset<256> bs;\n        for(int i=lb; i<=ub; ++i)\n            bs[i] = true;\n        variable[s] = bs;\n    }\n\n    int n;\n    cin >> n;\n    stack<bitset<256> > stk;\n    for(int i=0; i<n; ++i){\n        string s;\n        cin >> s;\n        if(isalnum(s[0])){\n            stk.push(setValue(s));\n        }else{\n            bitset<256> b = stk.top();\n            stk.pop();\n            bitset<256> a = stk.top();\n            stk.pop();\n\n            bitset<256> c;\n            if(s[0] == '+'){\n                for(int i=0; i<256; ++i){\n                    for(int j=0; j<256; ++j){\n                        if(a[i] && b[j])\n                            c[(i+j)%256] = true;\n                    }\n                }\n            }else if(s[0] == '-'){\n                for(int i=0; i<256; ++i){\n                    for(int j=0; j<256; ++j){\n                        if(a[i] && b[j])\n                            c[(i-j+256)%256] = true;\n                    }\n                }\n            }else if(s[0] == '*'){\n                for(int i=0; i<256; ++i){\n                    for(int j=0; j<256; ++j){\n                        if(a[i] && b[j])\n                            c[(i*j)%256] = true;\n                    }\n                }\n            }else{\n                if(b[0])\n                    return false;\n                for(int i=0; i<256; ++i){\n                    for(int j=0; j<256; ++j){\n                        if(a[i] && b[j])\n                            c[(i/j)%256] = true;\n                    }\n                }\n            }\n            stk.push(c);\n        }\n    }\n\n    return true;\n}\n\nint main()\n{\n    if(solve())\n        cout << \"correct\" << endl;\n    else\n        cout << \"error\" << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <stack>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint M, N, LB, UB;\nstring NAME;\nmap<string, pii> p;\nstack<int*> stk;\n\nint main(void) {\n  cin >> M;\n  REP(i, 0, M) {\n    cin >> NAME >> LB >> UB;\n    p[NAME] = pii(LB, UB);\n  }\n\n  cin >> N;\n  while(N--) {\n    cin >> NAME;\n    if(NAME == \"+\" || NAME == \"-\" || NAME == \"/\" || NAME == \"*\") {\n      int *op1 = stk.top(), *op2 = stk.top();\n      stk.pop(); stk.pop();\n      int *ret = new int[256];\n      REP(i, 0, 256) ret[i] = 0;\n      switch(NAME[0]) {\n        case '+':\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i + j) % 256] = 1;\n          break;\n        case '-':\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i - j + 256) % 256] = 1;\n          break;\n        case '*':\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i * j) % 256] = 1;\n          break;\n        case '/':\n          if(op2[0] == 1) {\n            cout << \"error\" << endl;\n            return 0;\n          }\n          REP(i, 0, 256) if(op1[i] == 1) REP(j, 0, 256) if(op2[j] == 1) ret[(i / j)] = 1;\n          break;\n      }\n      stk.push(ret);\n    } else if(p.count(NAME)) {\n      int *ret = new int[256];\n      REP(i, 0, 256) ret[i] = 0;\n      REP(i, p[NAME].fi, p[NAME].se + 1) ret[i] = 1;\n      stk.push(ret);\n    } else {\n      int val = stoi(NAME);\n      int *ret = new int[256];\n      REP(i, 0, 256) ret[i] = 0;\n      ret[val] = 1;\n      stk.push(ret);\n    }\n  }\n  cout << \"correct\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvector<bool> add(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i + j) % 256] = true;\n\treturn c;\n}\n\nvector<bool> sub(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i - j + 256) % 256] = true;\n\treturn c;\n}\n\nvector<bool> mul(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i * j) % 256] = true;\n\treturn c;\n}\n\nvector<bool> div(vector<bool>& a, vector<bool>& b) {\n\tvector<bool> c(256);\n\tfor (int i = 0; i < 256; i++)\n\t\tfor (int j = 0; j < 256; j++)\n\t\t\tif (a[i] && b[j])\n\t\t\t\tc[(i / j) % 256] = true;\n\treturn c;\n}\n\nint main() {\n\tint m; cin >> m;\n\tvector<string> name(m);\n\tvector<int> lb(m), ub(m);\n\tfor (int j = 0; j < m; j++)\n\t\tcin >> name[j] >> lb[j] >> ub[j];\n\tstack< vector<bool> > s;\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tstring e; cin >> e;\n\t\tif (e == \"+\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\ts.push(add(a, b));\n\t\t}\n\t\telse if (e == \"-\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\ts.push(sub(a, b));\n\t\t}\n\t\telse if (e == \"*\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\ts.push(mul(a, b));\n\t\t}\n\t\telse if (e == \"/\") {\n\t\t\tvector<bool> b = s.top(); s.pop();\n\t\t\tvector<bool> a = s.top(); s.pop();\n\t\t\tif (b[0]) {\n\t\t\t\tcout << \"error\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ts.push(div(a, b));\n\t\t}\n\t\telse {\n\t\t\tvector<bool> a(256);\n\t\t\tint _j = -1;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (name[j] == e) _j = j;\n\t\t\tif (_j == -1) {\n\t\t\t\tint i = stoi(e);\n\t\t\t\ta[i] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = lb[_j]; i <= ub[_j]; i++)\n\t\t\t\t\ta[i] = true;\n\t\t\t}\n\t\t\ts.push(a);\n\t\t}\n\t}\n\tcout << \"correct\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<string> ele;\n  deque<string> st;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n      st.push_back(e);\n    }\n\n\n  while(!st.empty())\n    {\n      string p = st.front(); st.pop_front();\n      //cout << \"p = \" << p << endl;\n      if(p == \"+\")\n\t{\n\t  string ele_a,ele_b;\n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(isdigit(ele_a[0]))\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(isdigit(ele_b[0]))\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)+(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"-\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(isdigit(ele_a[0]))\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\t  \n\t  if(ele_b[0])\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\t  \n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)-(*it_b)+256)%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"*\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\n\t  set<int> A,B,C;\n\t  if(isdigit(ele_a[0]))\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(isdigit(ele_b[0]))\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  C.insert(((*it_a)*(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else if(p == \"/\")\n\t{\n\t  string ele_a,ele_b;\n\t  \n\t  ele_b = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_b : \" << ele_b << endl;\n\t  ele_a = ele.top(),ele.pop();\n\t  //cout << \"pop! ele_a : \" << ele_a << endl;\n\t  set<int> A,B,C;\n\t  if(isdigit(ele_a[0]))\n\t    A.insert((atoi)(ele_a.c_str()));\n\t  else \n\t    A = index[ele_a];\n\n\t  if(isdigit(ele_b[0]))\n\t    B.insert((atoi)(ele_b.c_str()));\n\t  else \n\t    B = index[ele_b];\n\n\t  //index[ele_a].clear(),index[ele_b].clear();\n\n\t  for(set<int>::iterator it_a = A.begin();it_a != A.end();it_a++)\n\t    {\n\t      for(set<int>::iterator it_b = B.begin(); it_b != B.end();it_b++)\n\t\t{\n\t\t  if((*it_b) == 0)\n\t\t    {\n\t\t      cout << \"error\" << endl;\n\t\t      return 0;\n\t\t    }\n\t\t  \n\t\t  C.insert(((*it_a)/(*it_b))%256);\n\t\t}\n\t    }\n\n\t  index[My] = C;\n\t  ele.push(My);\n\n\t}\n      else \n\t{\n\t  //cout << \"push! -> \" << p << endl;\n\t  ele.push(p);\n\t}\n\n    }\n\n  if(!st.empty())\n    assert(false);\n\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef set<int> S;\n\nint getNum(string a){\n  int res=0;\n  for(int i=0;i<a.size();i++) res=res*10+a[i]-'0';\n  return res;\n}\n\nmap<string,P> val;\nvector<string> el;\nint n;\n\nint calc(){\n  stack <S> stk;\n  for(int i=0;i<n;i++){\n    string e=el[i];\n    S t;\n    if(isdigit(e[0]))t.insert(getNum(e));\n    else if(isalpha(e[0])){\n      int l=val[e].first,r=val[e].second;\n      while(l<=r)t.insert(l++);\n    }\n    else {\n      S B=stk.top();stk.pop();\n      S A=stk.top();stk.pop();\n      for(S::iterator i=A.begin();i!=A.end();i++)\n\tfor(S::iterator j=B.begin();j!=B.end();j++){\n\t  int a=*i,b=*j,r;\n\t  if(e[0]=='+')r=(a+b)%256;\n\t  if(e[0]=='-')r=(a-b+256)%256;\n\t  if(e[0]=='*')r=(a*b)%256;\n\t  if(e[0]=='/'){\n\t    if(!b) return 0;\n\t    r=(a/b)%256;\n\t  }\n\t  t.insert(r);\n\t}\n      \n    }\n    stk.push(t);\n  }\n  return 1;\n}\n\n\n\nint main(){\n  int m;\n  cin>>m;\n  for(int i=0,a,b;i<m;i++){\n    string t;\n    cin>>t>>a>>b;\n    val[t]=P(a,b);\n  }\n  cin>>n;\n  el.resize(n);\n  for(int i=0;i<n;i++) cin>>el[i];\n  cout<<(calc()?\"correct\":\"error\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n \n#define MAX 300\ntypedef pair<int, int> pii;\n  \nint n;\nvector<string> e;\nmap<string, pii> mp;\n  \nint op_num(char c)\n{\n    switch (c) {\n        case '+':\n            return 0;\n        case '-':\n            return 1;\n        case '*':\n            return 2;\n        case '/':\n            return 3;\n    }\n    return -1;\n}\n  \nint s2i(string &s)\n{\n    int res;\n    stringstream ss(s);\n    ss >> res;\n    return res;\n}\n\nint memo[MAX][MAX][MAX];\n\nbool zero_division_checker(int x, stack<int> st)\n{\n    if (x == n) {\n        return true;\n    }\n\n    int s = st.size();\n    int v = (s == 0 ? MAX-1 : st.top());\n\n    if (memo[x][s][v] != -1) {\n        return memo[x][s][v];\n    }\n    \n    bool res = 1;\n    if (isdigit(e[x][0])) {\n        st.push(s2i(e[x]));\n        res = zero_division_checker(x+1, st);\n        st.pop();\n    } else {\n        int op = op_num(e[x][0]);\n        if (op >= 0) {\n            int b = st.top(); st.pop();\n            int a = st.top(); st.pop();\n            if (op == 0) {\n                a = (a + b) % 256;\n            } else if (op == 1) {\n                a = (a - b + 256) % 256;\n            } else if (op == 2) {\n                a = (a * b) % 256;\n            } else {\n                if (b == 0) {\n                    return false;\n                }\n                a = (a / b) % 256;\n            }\n            st.push(a);\n            res = zero_division_checker(x+1, st);\n            st.pop();\n        } else {\n            pii p = mp[e[x]];\n            for (int i = p.first; i <= p.second; i++) {\n                st.push(i);\n                res &= zero_division_checker(x+1, st);\n                st.pop();\n            }\n        }\n    }\n    return (memo[x][s][v] = res);\n}\n  \nint main()\n{\n    int m;\n    cin >> m;\n    string name;\n    int lb, ub;\n    for (int i = 0; i < m; i++) {\n        cin >> name >> lb >> ub;\n        mp[name] = pii(lb, ub);\n    }\n    cin >> n;\n    e.resize(n);\n    for (int i = 0; i < n; i++) {\n        cin >> e[i];\n    }\n    memset(memo, -1, sizeof(memo));\n    cout << (zero_division_checker(0, stack<int>()) ? \"correct\" : \"error\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<functional>\n#include<cstdlib>\n#include<stdexcept>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define ppins(a,b,c,d) PP(P(a,b),P(c,d))\n#define pb push_back\n#define My \"NARIYOSHI_XX\"\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nbool calc(set<int>& B,set<int>& A,string ope,stack<set<int> >& ele)\n{\n  set<int> C;\n  for(set<int>::iterator it_B = B.begin();it_B != B.end();it_B++)\n    {\n      for(set<int>::iterator it_A = A.begin();it_A != A.end();it_A++)\n\t{\n\t  if(ope == \"+\")\n\t    {\n\t      C.insert(((*it_A)+(*it_B))%256);\n\t    }\n\t  else if(ope == \"-\")\n\t    {\n\t      C.insert(((*it_A)-(*it_B)+256)%256);\n\t    }\n\t  else if(ope == \"*\")\n\t    {\n\t      C.insert(((*it_A)*(*it_B))%256);\n\t    }\n\t  else if(ope == \"/\")\n\t    {\n\t      if(!(*it_B))\n\t\t{\n\t\n\t\t  return false; \n\t\t}\n\t      C.insert(((*it_A)/(*it_B))%256);\n\t    }\n\t  else \n\t    assert(false);\n\t}\n    }\n  ele.push(C);\n  return true;\n}\n\nint main(){\n  int m,n;\n  map<string,set<int> > index;\n  stack<set<int> > ele;\n  deque<string> st;\n  bool fin = false;\n\n  cin >> m;\n  for(int i=0;i<m;i++)\n    {\n      string name;\n      int lb,ub;\n      cin >> name >> lb >> ub;\n      for(int j = lb;j <= ub;j++)\n\tindex[name].insert(j);\n    }\n\n  cin >> n;\n  for(int i=0;i<n;i++)\n    {\n      string e;\n      cin >> e;\n     \n      if(e != \"/\" && e != \"*\" && e != \"-\" && e != \"+\")\n\t{\n\t  if(index.find(e) != index.end())\n\t    {\n\t      ele.push(index[e]);\n\t    }\n\t  else\n\t    {\n\t      set<int> FAGS;\n\t      FAGS.insert((atoi)(e.c_str()));\n\t      ele.push(FAGS);\n\t    }\n\t}\n      else \n\t{\n\t  set<int> A,B;\n\t  B = ele.top(),ele.pop();\n\t  A = ele.top(),ele.pop();\n\t  if(!calc(B,A,e,ele))\n\t    fin = true;\t    \n\t}\n\n    }\n\n  if(fin)\n    {\n      cout << \"error\" << endl;\n      return 0;\n    }\n  \n    cout << \"correct\" << endl;\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint main() {\n  int m;\n  while(cin >> m) {\n    map<string, pii> mp;\n    REP(i,m) {\n      string name;\n      cin >> name;\n      int a, b;\n      cin >> a >> b;\n      mp[name] = pii(a,b);\n    }\n    int n;\n    cin >> n;\n    stack<set<int> > stk;\n    int mod = 256;\n    REP(i,n) {\n      string s;\n      cin >> s;\n      if (mp.count(s)) {\n        pii p = mp[s];\n        set<int> se;\n        for (int i=p.first; i<=p.second; ++i) {\n          se.insert(i);\n        }\n        stk.push(se);\n      } else if (s.size() == 1 && !isdigit(s[0])) {\n        assert(stk.size());\n        set<int> b = stk.top();\n        stk.pop();\n        assert(stk.size());\n        set<int> a = stk.top();\n        stk.pop();\n        set<int> se;\n        FOR(it, a) {\n          FOR(jt, b) {\n            if (s==\"+\") se.insert((*it+*jt)%mod);\n            else if (s==\"-\") se.insert((*it-*jt+mod)%mod);\n            else if (s==\"*\") se.insert((*it * *jt) %mod);\n            else {\n              if (*jt == 0) goto error;\n              se.insert(*it / *jt % mod);\n            }\n          }\n        }\n        stk.push(se);\n      } else {\n        set<int> se;\n        se.insert(atoi(s.c_str()));\n        stk.push(se);\n      }\n      //FOR(it, stk.top()) cout << *it << \" \";cout << endl;\n    }\n    puts(\"correct\");\n    continue;\n  error:;\n    puts(\"error\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<cctype>\n\nusing namespace std;\n\nint main(){\n  int m;\n  cin>>m;\n  map<string,set<unsigned char> > mp;\n  while(m--){\n    string name;\n    int lb,ub;\n    cin>>name>>lb>>ub;\n    set<unsigned char> s;\n    for(int i=lb;i<=ub;i++){\n      s.insert(i);\n    }\n    mp[name]=s;\n  }\n  int n;\n  cin>>n;\n  bool zd=false;\n  stack<set<unsigned char> > s;\n  while(n--){\n    string e;\n    cin>>e;\n    if(isdigit(e[0])){\n      s.push({(unsigned char)atoi(e.c_str())});\n    }else if(isalpha(e[0])){\n      s.push(mp[e]);\n    }else{\n      auto b=s.top();\n      s.pop();\n      auto a=s.top();\n      s.pop();\n      set<unsigned char> r;\n      for(auto aa:a){\n\tfor(auto bb:b){\n\t  if(e[0]=='/'&&bb==0){\n\t    zd=true;\n\t  }else{\n\t    if(e[0]=='+'){\n\t      r.insert(aa+bb);\n\t    }else if(e[0]=='-'){\n\t      r.insert(aa-bb);\n\t    }else if(e[0]=='*'){\n\t      r.insert(aa*bb);\n\t    }else{\n\t      r.insert(aa/bb);\n\t    }\n\t  }\n\t}\n      }\n      s.push(r);\n    }\n  }\n  cout<<(zd?\"error\":\"correct\")<<endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define sz size()\n#define pb push_back\n#define mp make_pair\n#define ALL(X) (X).begin(),(X).end()\n\nusing namespace std;\n\nconst int INF = 1000000000;\nconst double eps = 1e-8;\n\nint main(void) {\n  int m;\n  cin>>m;\n  map<string,bitset<256>> val;\n  REP(i,m) {\n    string name;\n    int minv, maxv;\n    cin>>name>>minv>>maxv;\n    bitset<256> bs;\n    REP(j,256)\n      bs[j] = false;\n    FOR(j,minv,maxv+1)\n      bs[j] = true;\n    val[name] = bs;\n  }\n  stack<bitset<256>> stk;\n  int n;\n  cin>>n;\n  bool flag = false;\n  REP(i,n) {\n    string str;\n    cin>>str;\n    if(val.find(str) != val.end())\n      stk.push(val[str]);\n    else if(str == \"/\") {\n      if(stk.top()[0]) {\n        flag = true;\n        break;\n      }else{\n        bitset<256> bs,lhs,rhs;\n        REP(j,256)bs[j] = false;\n        rhs = stk.top();stk.pop();\n        lhs = stk.top();stk.pop();\n        REP(j,256)REP(k,256) {\n          if(lhs[j] && rhs[k])\n          bs[(j/k)%256] = true;\n        }\n        stk.push(bs);\n      }\n    }else if(str == \"*\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j*k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"+\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(j+k)%256] = true;\n      }\n      stk.push(bs);\n    }else if(str == \"-\") {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      rhs = stk.top();stk.pop();\n      lhs = stk.top();stk.pop();\n      REP(j,256)REP(k,256) {\n        if(lhs[j] && rhs[k])\n        bs[(256+j-k)%256] = true;\n      }\n      stk.push(bs);\n    } else {\n      bitset<256> bs,lhs,rhs;\n      REP(j,256)bs[j] = false;\n      bs[atoi(str.c_str())] = true;\n      stk.push(bs);\n    }\n  }\n  if(flag)\n    cout<<\"error\"<<endl;\n  else\n    cout<<\"correct\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2435\n  Title:  Zero Division Checker\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jb;\nchar variable[100][21];\nchar expression[100][4];\n\nint m,n;\nstruct uplow {\n  unsigned long long usll[4];\n}var[100],stack[100];\nint sp;\n\nvoid clear_val(struct uplow *x)\n{\n  x->usll[0]=x->usll[1]=x->usll[2]=x->usll[3]=0ULL;\n}\n\nvoid set_val(struct uplow *x,unsigned char num)\n{\n  x->usll[num/64] |= (1ULL<<(num % 64));\n}\nint is_val(struct uplow x,unsigned char num)\n{\n  int ret= (x.usll[num/64] & (1ULL<<(num % 64)))?1:0;\n  return(ret);\n}\nvoid show_val(struct uplow x)\n{\n  int i;\n  for(i=0;i<=255;i++)\n    if(is_val(x,(unsigned char)i))\n      printf(\"%d:\",i);\n  printf(\"\\n\");\n}\nvoid dump_stack()\n{\n  int i;\n  for(i=0;i<sp;i++)\n    show_val(stack[i]);\n}\nvoid dump_variable()\n{\n  int i;\n  printf(\"%d variables\\n\",n);\n  for(i=0;i<n;i++)\n    show_val(var[i]);\n}\n\nint is_number(char *s)\n{\n  while(*s)\n    {\n      if(*s >= '0' && *s <= '9')\n\t s++;\n      else\n\treturn(0); \n    }\n  return(1);\n}\nint is_variable(char *s)\n{\n  while(*s)\n    {\n      if(isalpha(*s))\n\t s++;\n      else\n\treturn(0); \n    }\n  return(1);\n}\n\nstruct uplow bin_operator(struct uplow arg1,struct uplow arg2,char op)\n{\n  struct uplow ret;\n  int i,j;\n  unsigned char res;\n\n  if(op=='/' && is_val(arg2,0)) //div by zero\n    longjmp(jb,1);\n  clear_val(&ret);\n  \n  for(i=0;i<256;i++)\n    if(is_val(arg1,(unsigned char)i))\n      for(j=0;j<256;j++)\n\tif(is_val(arg2,(unsigned char)j))\n\t  {\n\t    if(op=='+')\n\t      res=i+j;\n\t    else if(op=='-')\n\t      res=i-j;\n\t    else if(op=='*')\n\t      res=i*j;\n\t    else if(op=='/')\n\t      res=i/j;\n\t    set_val(&ret,res);\n\t  }\n  return(ret);\n}\n\nchar operator[]=\"+-*/\";\n\nvoid eval_forth()\n{\n  int i,j,opn;\n  char *el;\n  struct uplow work,work1,work2;\n\n  for(i=0;i<m;i++)\n    {\n      el=&expression[i][0];\n      if(is_number(el))\n\t{\n\t  clear_val(&work);\n\t  set_val(&work,atoi(el));\n\t  stack[sp]=work;\n\t  sp++;\n\t}\n      else if(is_variable(el))\n\t{\n\t  for(j=0;j<n;j++)\n\t    if(0==strcmp(&variable[j][0],el))\n\t      {\n\t\twork = var[j]; \n\t\tstack[sp]=work;\n\t\tsp++;\n\t      }\n\t}\n      else\n\t{\n\t  work1=stack[sp-2];\n\t  work2=stack[sp-1];\n  \n\t  work=bin_operator(work1,work2,*el);\n\t  sp--;\n\t  stack[sp-1]=work;\n\t}\n    }\n}\n\nint solve()\n{\n  sp=0;\n  if(setjmp( jb ) == 0 ) \n    eval_forth();\n  else\n    return(0);\n    \n  return(1);\n}\nmain()\n{\n  int i,ret,a,b;\n  unsigned char j;\n\n  memset(var,0,sizeof(long long)*4*100);\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%s %d %d\",&variable[i][0],&a,&b);\n      for(j=a;j<=b;j++)\n\tset_val(&var[i],j);\n    }\n  //dump_variable();\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%s\",&expression[i][0]);\n  \n  ret=solve();\n  //dump_stack();\n  printf(\"%s\\n\",ret?\"correct\":\"error\");\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n\tchar arierukamo[256];\n} num_t;\n\nnum_t create_num(int l,int u) {\n\tnum_t ret;\n\tint i;\n\tfor(i=0;i<256;i++)ret.arierukamo[i]=(l<=i && i<=u)?1:0;\n\treturn ret;\n}\n\ntypedef int (*p_op)(int,int);\n\nint add(int a,int b){return a+b;}\nint sub(int a,int b){return a-b+256;}\nint mul(int a,int b){return a*b;}\nint waru(int a,int b){return a/b;}\n\nnum_t calc_num(const num_t *a,const num_t *b,p_op op) {\n\tnum_t ret;\n\tint i,j;\n\tfor(i=0;i<256;i++)ret.arierukamo[i]=0;\n\tfor(i=0;i<256;i++) {\n\t\tfor(j=0;j<256;j++) {\n\t\t\tif(a->arierukamo[i] && b->arierukamo[j]) {\n\t\t\t\tret.arierukamo[op(i,j)%256]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tint m,n,i;\n\tchar names[100][32];\n\tnum_t vars[100];\n\tnum_t stack[100];\n\tint stack_pos=0;\n\tint error_flag=0;\n\tif(scanf(\"%d\",&m)!=1)return 1;\n\tfor(i=0;i<m;i++) {\n\t\tint l,u;\n\t\tif(scanf(\"%s%d%d\",names[i],&l,&u)!=3)return 1;\n\t\tvars[i]=create_num(l,u);\n\t}\n\tif(scanf(\"%d\",&n)!=1)return 1;\n\tfor(i=0;i<n;i++) {\n\t\tchar data[1024];\n\t\tchar* end;\n\t\tint num;\n\t\tif(scanf(\"%s\",data)!=1)return 1;\n\t\tif(error_flag)continue;\n\t\tnum=(int)strtol(data,&end,10);\n\t\tif(*end=='\\0') {\n\t\t\tstack[stack_pos++]=create_num(num,num);\n\t\t} else if(strcmp(data,\"+\")==0) {\n\t\t\tif(stack_pos<2)error_flag=1;\n\t\t\telse {\n\t\t\t\tstack_pos--;\n\t\t\t\tstack[stack_pos-1]=calc_num(&stack[stack_pos-1],&stack[stack_pos],add);\n\t\t\t}\n\t\t} else if(strcmp(data,\"-\")==0) {\n\t\t\tif(stack_pos<2)error_flag=1;\n\t\t\telse {\n\t\t\t\tstack_pos--;\n\t\t\t\tstack[stack_pos-1]=calc_num(&stack[stack_pos-1],&stack[stack_pos],sub);\n\t\t\t}\n\t\t} else if(strcmp(data,\"*\")==0) {\n\t\t\tif(stack_pos<2)error_flag=1;\n\t\t\telse {\n\t\t\t\tstack_pos--;\n\t\t\t\tstack[stack_pos-1]=calc_num(&stack[stack_pos-1],&stack[stack_pos],mul);\n\t\t\t}\n\t\t} else if(strcmp(data,\"/\")==0) {\n\t\t\tif(stack_pos<2 || stack[stack_pos-1].arierukamo[0]!=0)error_flag=1;\n\t\t\telse {\n\t\t\t\tstack_pos--;\n\t\t\t\tstack[stack_pos-1]=calc_num(&stack[stack_pos-1],&stack[stack_pos],waru);\n\t\t\t}\n\t\t} else {\n\t\t\tint j;\n\t\t\tint index=-1;\n\t\t\tfor(j=0;j<m;j++) {\n\t\t\t\tif(strcmp(data,names[j])==0) {\n\t\t\t\t\tindex=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(index<0)error_flag=1; else stack[stack_pos++]=vars[j];\n\t\t}\n\t}\n\tif(stack_pos!=1)error_flag=1;\n\tputs(error_flag?\"error\":\"correct\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2435: Zero Division Checker\n// 2017.9.26 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define NUM 1\n#define VAR 2\n\ntypedef struct { char nm[22]; int l, u; } T;\nT var[102]; int m;\n\ntypedef struct { int id, n; char v[256]; } Q;\t// n: ?????°??¨???v: ?????°??¨\nQ q[102]; int top;\n\nint main()\n{\n\tint n, i, j, k;\n\tQ a, b, c;\n\tchar bf[25];\n\n\tscanf(\"%d\", &m);\n\tfor (i = 0; i < m; i++)\tscanf(\"%s%d%d\", var[i].nm, &var[i].l, &var[i].u);\n\n\tscanf(\"%d\", &n);\n\ttop = 0;\t\t\t\t\t// ????????????????????\\??¬????????§???\n\twhile (n-- > 0) {\n\t\tscanf(\"%s\", bf);\n\n\t\tif (*bf == '+' || *bf == '-' || *bf == '*' || *bf == '/') {\n\t\t\tint a1, a2, b1, b2;\n\t\t\tif (top < 2) goto ERR;\n\t\t\tb = q[--top], a = q[--top];\n\t\t\tif (a.id == NUM) a1 = a2 = a.n, a.v[a1] = 1;\n\t\t\telse             a1 = 0, a2 = 255;\n\t\t\tif (b.id == NUM) b1 = b2 = b.n, b.v[b1] = 1;\n\t\t\telse             b1 = 0, b2 = 255;\n\t\t\tmemset(c.v, 0, sizeof(c.v));\n\n\t\t\tfor (i = a1; i <= a2; i++) if (a.v[i]) for (j = b1; j <= b2; j++) if (b.v[j]) {\n\n\t\t\t\tif      (*bf == '+') k = i + j;\n\t\t\t\telse if (*bf == '-') k = 256 + i - j;\n\t\t\t\telse if (*bf == '*') k = i * j;\n\t\t\t\telse { if (j == 0) goto ERR;\t\t// '/'\n\t\t\t\t\t\t\t\t\t k = i / j;\n\t\t\t\t}\n\t\t\t\tc.v[k & 0xff] = 1;\n\t\t\t}\n\t\t\tc.id = VAR;\n\t\t\tq[top++] = c;\n\t\t} else if (isdigit(*bf)) {\n\t\t\tq[top].id = NUM, q[top].n = atoi(bf) & 0xff;\n\t\t\ttop++;\n\t\t} else {\n\t\t\tfor (i = 0; i < m; i++)\n\t\t\t\tif (!strcmp(bf, var[i].nm)) break;\n\t\t\tif (i >= m) goto ERR;\n\t\t\tq[top].id = VAR;\n\t\t\tmemset(q[top].v, 0, sizeof(q[top].v));\n\t\t\tfor (j = var[i].l; j <= var[i].u; j++) q[top].v[j] = 1;\n\t\t\ttop++;\n\t\t}\n\t}\n\tif (top == 1) puts(\"correct\");\n\telse {\nERR:\tputs(\"error\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2435\n  Title:  Zero Division Checker\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jb;\nchar variable[100][21];\nchar expression[100][21];\n\nint m,n;\nstruct uplow {\n  unsigned long long usll[4];\n}var[100],stack[100];\nint sp;\n\nvoid clear_val(struct uplow *x)\n{\n  x->usll[0]=x->usll[1]=x->usll[2]=x->usll[3]=0ULL;\n}\n\nvoid set_val(struct uplow *x,unsigned char num)\n{\n  x->usll[num/64] |= (1ULL<<(num % 64));\n}\nint is_val(struct uplow x,unsigned char num)\n{\n  int ret= (x.usll[num/64] & (1ULL<<(num % 64)))?1:0;\n  return(ret);\n}\nvoid show_val(struct uplow x)\n{\n  int i;\n  for(i=0;i<=255;i++)\n    if(is_val(x,(unsigned char)i))\n      printf(\"%d:\",i);\n  printf(\"\\n\");\n}\nvoid dump_stack()\n{\n  int i;\n  for(i=0;i<sp;i++)\n    show_val(stack[i]);\n}\nvoid dump_variable()\n{\n  int i;\n  printf(\"%d variables\\n\",n);\n  for(i=0;i<n;i++)\n    show_val(var[i]);\n}\n\nint is_number(char *s)\n{\n  while(*s)\n    {\n      if(*s >= '0' && *s <= '9')\n\t s++;\n      else\n\treturn(0); \n    }\n  return(1);\n}\nint is_variable(char *s)\n{\n  while(*s)\n    {\n      if(isalpha(*s))\n\t s++;\n      else\n\treturn(0); \n    }\n  return(1);\n}\n\nstruct uplow bin_operator(struct uplow arg1,struct uplow arg2,char op)\n{\n  struct uplow ret;\n  int i,j;\n  unsigned char res;\n\n  if(op=='/' && is_val(arg2,0)) //div by zero\n    longjmp(jb,1);\n  clear_val(&ret);\n  \n  for(i=0;i<256;i++)\n    if(is_val(arg1,(unsigned char)i))\n      for(j=0;j<256;j++)\n\tif(is_val(arg2,(unsigned char)j))\n\t  {\n\t    if(op=='+')\n\t      res=i+j;\n\t    else if(op=='-')\n\t      res=i-j;\n\t    else if(op=='*')\n\t      res=i*j;\n\t    else if(op=='/')\n\t      res=i/j;\n\t    set_val(&ret,res);\n\t  }\n  return(ret);\n}\n\nchar operator[]=\"+-*/\";\n\nvoid eval_forth()\n{\n  int i,j,opn;\n  char *el;\n  struct uplow work,work1,work2;\n\n  for(i=0;i<m;i++)\n    {\n      el=&expression[i][0];\n      //printf(\"%d:%s %d\\n\",i,el,sp);\n      if(is_number(el))\n\t{\n\t  clear_val(&work);\n\t  set_val(&work,atoi(el));\n\t  stack[sp]=work;\n\t  sp++;\n\t}\n      else if(is_variable(el))\n\t{\n\t  for(j=0;j<n;j++)\n\t    if(0==strcmp(&variable[j][0],el))\n\t      {\n\t\twork = var[j]; \n\t\tstack[sp]=work;\n\t\tsp++;\n\t      }\n\t}\n      else\n\t{\n\t  work1=stack[sp-2];\n\t  work2=stack[sp-1];\n  \n\t  work=bin_operator(work1,work2,*el);\n\t  sp--;\n\t  stack[sp-1]=work;\n\t}\n    }\n}\n\nint solve()\n{\n  sp=0;\n  if(setjmp( jb ) == 0 ) \n    eval_forth();\n  else\n    return(0);\n    \n  return(1);\n}\nmain()\n{\n  int i,j,ret,a,b;\n\n  memset(var,0,sizeof(long long)*4*100);\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%s %d %d\",&variable[i][0],&a,&b);\n      for(j=a;j<=b;j++)\n\tset_val(&var[i],(unsigned char)j);\n    }\n  //dump_variable();\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%s\",&expression[i][0]);\n  \n  ret=solve();\n  //printf(\"solve end sp=%d\\n\",sp);\n  //dump_stack();\n  printf(\"%s\\n\",ret?\"correct\":\"error\");\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2435\n  Title:  Zero Division Checker\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#include <setjmp.h>\n\njmp_buf jb;\nchar variable[100][21];\nchar expression[100][4];\n\nint m,n;\nstruct uplow {\n  unsigned long long usll[4];\n}var[100],stack[100];\nint sp;\n\nvoid clear_val(struct uplow *x)\n{\n  x->usll[0]=x->usll[1]=x->usll[2]=x->usll[3]=0ULL;\n}\n\nvoid set_val(struct uplow *x,unsigned char num)\n{\n  x->usll[num/64] |= (1ULL<<(num % 64));\n}\nint is_val(struct uplow x,unsigned char num)\n{\n  int ret= (x.usll[num/64] & (1ULL<<(num % 64)))?1:0;\n  return(ret);\n}\nvoid show_val(struct uplow x)\n{\n  int i;\n  for(i=0;i<=255;i++)\n    if(is_val(x,(unsigned char)i))\n      printf(\"%d:\",i);\n  printf(\"\\n\");\n}\nvoid dump_stack()\n{\n  int i;\n  for(i=0;i<sp;i++)\n    show_val(stack[i]);\n}\nvoid dump_variable()\n{\n  int i;\n  printf(\"%d variables\\n\",n);\n  for(i=0;i<n;i++)\n    show_val(var[i]);\n}\n\nint is_number(char *s)\n{\n  while(*s)\n    {\n      if(*s >= '0' && *s <= '9')\n\t s++;\n      else\n\treturn(0); \n    }\n  return(1);\n}\nint is_variable(char *s)\n{\n  while(*s)\n    {\n      if(isalpha(*s))\n\t s++;\n      else\n\treturn(0); \n    }\n  return(1);\n}\n\nstruct uplow bin_operator(struct uplow arg1,struct uplow arg2,char op)\n{\n  struct uplow ret;\n  int i,j;\n  unsigned char res;\n\n  if(op=='/' && is_val(arg2,0)) //div by zero\n    longjmp(jb,1);\n  clear_val(&ret);\n  \n  for(i=0;i<256;i++)\n    if(is_val(arg1,(unsigned char)i))\n      for(j=0;j<256;j++)\n\tif(is_val(arg2,(unsigned char)j))\n\t  {\n\t    if(op=='+')\n\t      res=i+j;\n\t    else if(op=='-')\n\t      res=i-j;\n\t    else if(op=='*')\n\t      res=i*j;\n\t    else if(op=='/')\n\t      res=i/j;\n\t    set_val(&ret,res);\n\t  }\n  return(ret);\n}\n\nchar operator[]=\"+-*/\";\n\nvoid eval_forth()\n{\n  int i,j,opn;\n  char *el;\n  struct uplow work,work1,work2;\n\n  for(i=0;i<m;i++)\n    {\n      el=&expression[i][0];\n      if(is_number(el))\n\t{\n\t  clear_val(&work);\n\t  set_val(&work,atoi(el));\n\t  stack[sp]=work;\n\t  sp++;\n\t}\n      else if(is_variable(el))\n\t{\n\t  for(j=0;j<n;j++)\n\t    if(0==strcmp(&variable[j][0],el))\n\t      {\n\t\twork = var[j]; \n\t\tstack[sp]=work;\n\t\tsp++;\n\t      }\n\t}\n      else\n\t{\n\t  work1=stack[sp-2];\n\t  work2=stack[sp-1];\n  \n\t  work=bin_operator(work1,work2,*el);\n\t  sp--;\n\t  stack[sp-1]=work;\n\t}\n    }\n}\n\nint solve()\n{\n  sp=0;\n  if(setjmp( jb ) == 0 ) \n    eval_forth();\n  else\n    return(0);\n    \n  return(1);\n}\nmain()\n{\n  int i,j,ret,a,b;\n\n  memset(var,0,sizeof(long long)*4*100);\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%s %d %d\",&variable[i][0],&a,&b);\n      for(j=a;j<=b;j++)\n\tset_val(&var[i],(unsigned char)j);\n    }\n  //dump_variable();\n  scanf(\"%d\",&m);\n  for(i=0;i<m;i++)\n    scanf(\"%s\",&expression[i][0]);\n  \n  ret=solve();\n  //dump_stack();\n  printf(\"%s\\n\",ret?\"correct\":\"error\");\n  \n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t//0127 cording\n\t//0148 cording end\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint m = sc.nextInt();\n\t\t\tHashMap<String, HashSet<Integer>> map = new HashMap<String, HashSet<Integer>>();\n\t\t\tfor(int i  = 0 ;  i < m; i++){\n\t\t\t\tString c = sc.next();\n\t\t\t\tint first = sc.nextInt();\n\t\t\t\tint end = sc.nextInt();\n\t\t\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\t\t\tfor(int j = first; j <= end; j++){\n\t\t\t\t\tset.add(j);\n\t\t\t\t}\n\t\t\t\tmap.put(c, set);\n\t\t\t}\n\t\t\t\n\t\t\tint n = sc.nextInt();\n\t\t\tLinkedList<HashSet<Integer>> stack = new LinkedList<HashSet<Integer>>();\n\t\t\tString [] data = new String[n];\n\t\t\tboolean isC = true;\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tdata[i] = sc.next();\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tString s = data[i];\n\t\t\t\tif(Character.isDigit(s.charAt(0))){\n\t\t\t\t\tHashSet<Integer> se = new HashSet<Integer>();\n\t\t\t\t\tse.add(Integer.parseInt(s));\n\t\t\t\t\tstack.push(se);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tchar c = s.charAt(0);\n\t\t\t\t\tif(c =='+' || c == '-' || c =='/' || c=='*'){\n\t\t\t\t\t\tHashSet<Integer> b = stack.pop();\n\t\t\t\t\t\tHashSet<Integer> a = stack.pop();\n\t\t\t\t\t\tHashSet<Integer> r = new HashSet<Integer>();\n\t\t\t\t\t\tif(c == '+'){\n\t\t\t\t\t\t\tfor(int vb: b){\n\t\t\t\t\t\t\t\tfor(int va: a){\n\t\t\t\t\t\t\t\t\tint res = (vb + va) % 256;\n\t\t\t\t\t\t\t\t\tr.add(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(c == '-'){\n\t\t\t\t\t\t\tfor(int vb: b){\n\t\t\t\t\t\t\t\tfor(int va: a){\n\t\t\t\t\t\t\t\t\tint res = (va - vb + 256) % 256;\n\t\t\t\t\t\t\t\t\tr.add(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(c =='*'){\n\t\t\t\t\t\t\tfor(int vb: b){\n\t\t\t\t\t\t\t\tfor(int va: a){\n\t\t\t\t\t\t\t\t\tint res = (va * vb) % 256;\n\t\t\t\t\t\t\t\t\tr.add(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(b.contains(0)){\n\t\t\t\t\t\t\t\tisC = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int vb: b){\n\t\t\t\t\t\t\t\tfor(int va: a){\n\t\t\t\t\t\t\t\t\tint res = (va / vb) % 256;\n\t\t\t\t\t\t\t\t\tr.add(res);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(r);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tstack.push(map.get(s));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isC){\n\t\t\t\tSystem.out.println(\"correct\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"error\");\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew C();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tfor(int j = i + 2; j < n; j++){\n\t\t\t\t\t\tif(i== 0 && j == n-1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(issame(ans, now)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdouble EPS = 1.0e-08;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0,min=256;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>256)\tbreak;\n\t\t\t\t\t\t\t\t\tif(aa*bb==256){\n\t\t\t\t\t\t\t\t\t\tz=true;\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t\tmin=min(min,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo/b.hi)), max(0, (a.hi/b.lo)), a.zero));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n    public static void main(String[] args) throws IOException {\n    \tScanner sc = new Scanner(System.in);\n    \t\n    \tfinal int m = sc.nextInt();\n    \t\n    \tHashMap<String, ArrayList<Boolean>> v_map = new HashMap<String, ArrayList<Boolean>>();\n        \n    \tfor(int i = 0; i < m; i++){\n    \t\tfinal String name = sc.next();\n    \t\tfinal int low = sc.nextInt();\n    \t\tfinal int high = sc.nextInt();\n    \t\t\n    \t\tArrayList<Boolean> list = new ArrayList<Boolean>(256);\n    \t\tfor(int j = 0; j < 256; j++){\n    \t\t\tif(j < low || j > high){\n    \t\t\t\tlist.add(false);\n    \t\t\t}else{\n    \t\t\t\tlist.add(true);\n    \t\t\t}\n    \t\t}\n    \t\t\n    \t\tv_map.put(name, list);    \t\t\n    \t}\n    \t\n    \tfinal int n = sc.nextInt();\n    \t\n    \tLinkedList<ArrayList<Boolean>> stack = new LinkedList<ArrayList<Boolean>>();\n    \t\n    \tfor(int i = 0; i < n; i++){\n    \t\tfinal String input = sc.next();\n    \t\t\n    \t\t//System.out.println(stack);\n    \t\t\n    \t\ttry{\n    \t\t\tint num = Integer.parseInt(input);\n    \t\t\t\n    \t\t\tArrayList<Boolean> list = new ArrayList<Boolean>(256);\n        \t\tfor(int j = 0; j < 256; j++){\n        \t\t\tif(j == num){\n        \t\t\t\tlist.add(true);\n        \t\t\t}else{\n        \t\t\t\tlist.add(false);\n        \t\t\t}\n        \t\t}\n        \t\t\n        \t\tstack.push(list);\n    \t\t\t\n    \t\t}catch(NumberFormatException e){\n    \t\t\tif(\"+\".equals(input)){\n    \t\t\t\tArrayList<Boolean> b = stack.poll();\n    \t\t\t\tArrayList<Boolean> a = stack.poll();\n    \t\t\t\tArrayList<Boolean> ans = new ArrayList<Boolean>(256);\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tans.add(false);\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tif(!a.get(j)){\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tfor(int k = 0; k < 256; k++){\n    \t\t\t\t\t\tif(!b.get(k)){\n    \t\t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tans.set((j + k) % 256 , true);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tstack.push(ans);\n    \t\t\t}else if(\"-\".equals(input)){\n    \t\t\t\tArrayList<Boolean> b = stack.poll();\n    \t\t\t\tArrayList<Boolean> a = stack.poll();\n    \t\t\t\tArrayList<Boolean> ans = new ArrayList<Boolean>(256);\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tans.add(false);\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tif(!a.get(j)){\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tfor(int k = 0; k < 256; k++){\n    \t\t\t\t\t\tif(!b.get(k)){\n    \t\t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tans.set((j - k + 256) % 256 , true);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tstack.push(ans);\n    \t\t\t}else if(\"/\".equals(input)){\n    \t\t\t\tArrayList<Boolean> b = stack.poll();\n    \t\t\t\tArrayList<Boolean> a = stack.poll();\n    \t\t\t\tArrayList<Boolean> ans = new ArrayList<Boolean>(256);\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tans.add(false);\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tif(!a.get(j)){\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tfor(int k = 0; k < 256; k++){\n    \t\t\t\t\t\tif(!b.get(k)){\n    \t\t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tif(k == 0){\n    \t\t\t\t\t\t\tSystem.out.println(\"error\");\n    \t\t\t\t\t\t\treturn;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tans.set((j / k) % 256 , true);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tstack.push(ans);\n    \t\t\t}else if(\"*\".equals(input)){\n    \t\t\t\tArrayList<Boolean> b = stack.poll();\n    \t\t\t\tArrayList<Boolean> a = stack.poll();\n    \t\t\t\tArrayList<Boolean> ans = new ArrayList<Boolean>(256);\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tans.add(false);\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tfor(int j = 0; j < 256; j++){\n    \t\t\t\t\tif(!a.get(j)){\n    \t\t\t\t\t\tcontinue;\n    \t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\tfor(int k = 0; k < 256; k++){\n    \t\t\t\t\t\tif(!b.get(k)){\n    \t\t\t\t\t\t\tcontinue;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\t\n    \t\t\t\t\t\tans.set((j * k) % 256 , true);\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tstack.push(ans);\n    \t\t\t}else{\n    \t\t\t\tstack.push(v_map.get(input));\n    \t\t\t}\n    \t\t\t\n    \t\t\t\n    \t\t}\n    \t}\n    \t//System.out.println(stack);\n    \tSystem.out.println(\"correct\");\n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.*;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew C();\n\t}\n\t\n\tclass B{\n\t\tB(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tPoint2D [] plist = new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> llist = new ArrayList<Line2D>();\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tfor(int j = i + 2; j < n; j++){\n\t\t\t\t\t\tif(i== 0 && j == n-1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tllist.add(new Line2D.Double(plist[i], plist[j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flg = true;\n\t\t\t\tPoint2D ans = null;\n\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n\t\t\t\t\tfor(int j = i + 1; j < llist.size(); j++){\n\t\t\t\t\t\tPoint2D now = intersect(llist.get(i), llist.get(j));\n\t\t\t\t\t\tif(ans == null){\n\t\t\t\t\t\t\tans = now;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(issame(ans, now)){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(! flg ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//debug\n//\t\t\t\tfor(int i = 0 ; i < llist.size(); i++){\n//\t\t\t\t\tSystem.out.println(llist.get(i).getP1() + \" \" + llist.get(i).getP2() );\n//\t\t\t\t}\n\t\t\t\tif(ans != null && flg){\n\t\t\t\t\t//System.out.println(ans);\n\t\t\t\t\tSystem.out.printf(\"%f %f\\n\", ans.getX() , ans.getY());\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NA\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tdouble EPS = 1.0e-08;\n\n\t\tprivate boolean issame(Point2D p1, Point2D p2) {\n\t\t\tif(Math.abs(p1.getX() - p2.getX()) < EPS && Math.abs(p1.getY() - p2.getY()) < EPS){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate Point2D intersect(Line2D l, Line2D m) {\n\t\t\tPoint2D lv = sub(l.getP2(), l.getP1());\n\t\t\tPoint2D mv = sub(m.getP2(), m.getP1());\n\t\t\tPoint2D mlv = sub(m.getP1(), l.getP1());\n\t\t\tdouble a = cross(mlv, lv);\n\t\t\tdouble b = cross(lv, mv);\n\t\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\t\treturn l.getP1();\n\t\t\t}\n\t\t\tdouble t = a / b;\n\t\t\tdouble resx = m.getX1() + t * mv.getX();\n\t\t\tdouble resy = m.getY1() + t * mv.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(resx, resy);\n\t\t}\n\n\t\tprivate double cross(Point2D p1, Point2D p2) {\n\t\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\t\treturn res;\n\t\t}\n\n\t\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\t\tdouble x = p2.getX() - p1.getX();\n\t\t\tdouble y = p2.getY() - p1.getY();\n\t\t\t\n\t\t\treturn new Point2D.Double(x,y);\n\t\t}\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// TODO debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num(min(255,(a.lo+b.lo)), min(255,(a.hi+b.hi)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num(max(0, (a.lo-b.hi)), max(0, (a.hi-b.lo)), z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\tint max=0;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tif(aa*bb>=256){\n\t\t\t\t\t\t\t\t\t\tz|=(aa*bb==256);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmax=max(max,aa*bb);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif(max==255 && z)\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min(max, a.lo*b.lo), max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\t// TODO debug\n\t\t\t\t\t\t\t\t//System.out.println(\"ER\"+i);\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint max=0,min=255;\n\t\t\t\t\t\t\tboolean z=a.zero;\n\t\t\t\t\t\t\tfor(int aa=a.lo; aa<=a.hi; aa++){\n\t\t\t\t\t\t\t\tfor(int bb=b.lo; bb<=b.hi; bb++){\n\t\t\t\t\t\t\t\t\tmax=max(max, aa/bb);\n\t\t\t\t\t\t\t\t\tmin=min(min, aa/bb);\n\t\t\t\t\t\t\t\t\tz|=(aa/bb==0);\n\t\t\t\t\t\t\t\t\tif(aa/bb<=0)\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num(min, max, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"(LO\"+lo+\" HI\"+hi+\" z-\"+zero+\")\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Stack;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"src/T2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tboolean ans = true;\n\t\n\tclass Elem {\n\t\tboolean[] can = new boolean[256];\n\n\t\tElem() { }\n\t\t\n\t\tElem(int lower, int upper) {\n\t\t\tfor (int i = lower; i <= upper; i++) {\n\t\t\t\tcan[i%256] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid set(int x) {\n\t\t\tcan[x%256] = true;\n\t\t}\n\n\t\tElem add(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tres.set(i+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tElem sub(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tres.set(i-j+256);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tElem mult(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tcan[(i*j) % 256] = true;\n\t\t\t\t\tres.set(i*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tElem div(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tans = false; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.set(i/j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tpublic void solve() {\t\n\t\tint n = in.nextInt();\n\t\tHashMap<String, Elem> map = new HashMap<String, Elem>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString name = in.next();\n\t\t\tint lower = in.nextInt(), upper = in.nextInt();\n\t\t\tmap.put(name, new Elem(lower, upper));\n\t\t}\n\t\t\n\t\tint m = in.nextInt();\n\t\tStack<Elem> stack = new Stack<Elem>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString next = in.next();\n\t\t\tchar c = next.charAt(0);\n\t\t\tif (c == '+') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.add(e1));\n\t\t\t} else if (c == '-') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.sub(e1));\t\t\t\t\n\t\t\t} else if (c == '*') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.mult(e1));\t\t\t\t\n\t\t\t} else if (c == '/') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.div(e1));\n\t\t\t\tif (!ans) break;\n\t\t\t} else if (Character.isDigit(c)) {\n\t\t\t\tint val = Integer.valueOf(next);\n\t\t\t\tstack.push(new Elem(val, val));\n\t\t\t} else if (Character.isLetter(c)) {\n\t\t\t\tstack.push(map.get(next));\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans ? \"correct\" : \"error\");\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew C();\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\tint M=sc.nextInt();\n\t\t\tHashMap<String, Num> map=new HashMap<String, Num>();\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tint a=sc.nextInt(),b=sc.nextInt();\n\t\t\t\tmap.put(str, new Num(a, b, false, (a==0||b==0)));\n\t\t\t}\n\t\t\tint N=sc.nextInt();\n\t\t\tString[] e=new String[N];\n\t\t\tfor(int i=0; i<N; i++)\te[i]=sc.next();\n\t\t\t\n\t\t\t// debug\n\t\t\t//System.out.println(Arrays.toString(e));\n\t\t\t\n\t\t\tboolean er=false;\n\t\t\tLinkedList<Num> s=new LinkedList<Num>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t// debug\n\t\t\t\t//System.out.println(s);\n\t\t\t\t\n\t\t\t\tif(map.containsKey(e[i])){\n\t\t\t\t\ts.push(map.get(e[i]));\n\t\t\t\t}else{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tint tmp=Integer.parseInt(e[i]);\n\t\t\t\t\t\ts.push(new Num(tmp,tmp,true,tmp==0));\n\t\t\t\t\t}catch(Exception ex){\n\t\t\t\t\t\tNum b=s.pop(),a=s.pop();\n\t\t\t\t\t\tif(e[i].equals(\"+\")){\n\t\t\t\t\t\t\tboolean z=(a.hi+b.hi)>255;\n\t\t\t\t\t\t\ts.push(new Num((a.lo+b.lo)%256, (a.hi+b.hi)%256, a.c&&b.c, z));\n\t\t\t\t\t\t}else if(e[i].equals(\"-\")){\n\t\t\t\t\t\t\tboolean z=(a.lo-b.hi)<=0;\n\t\t\t\t\t\t\ts.push(new Num((a.lo-b.hi+256)%256, (a.hi-b.lo+256)%256, a.c&&b.c, z));\n\t\t\t\t\t\t}else if(e[i].equals(\"*\")){\n\t\t\t\t\t\t\tboolean z=a.zero||b.zero;\n\t\t\t\t\t\t\ts.push(new Num((a.lo*b.lo)%256, (a.hi*b.hi)%256, a.c&&b.c, z));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(e[i].equals(\"/\")){\n\t\t\t\t\t\t\tif(b.zero){\n\t\t\t\t\t\t\t\ter=true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new Num((a.lo/b.hi)%256, (a.hi/b.lo)%256, a.c&&b.c, false));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(er?\"error\":\"correct\");\n\t\t}\n\t\tclass Num{\n\t\t\tint lo,hi;\n\t\t\tboolean c,zero;\n\t\t\tNum(int lo,int hi,boolean c,boolean zero){\n\t\t\t\tthis.lo=lo;\n\t\t\t\tthis.hi=hi;\n\t\t\t\tthis.c=c;\n\t\t\t\tthis.zero=zero || lo==0 || hi==0;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn \"LO\"+lo+\" HI\"+hi+\" c-\"+c+\" z-\"+zero;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m;\n\tHashMap<String, Integer> lbMap, ubMap;\n\tint n;\n\tString[] es;\n\n\tvoid run(){\n\t\tm=sc.nextInt();\n\t\tlbMap=new HashMap<String, Integer>();\n\t\tubMap=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tString name=sc.next();\n\t\t\tint lb=sc.nextInt();\n\t\t\tint ub=sc.nextInt();\n\t\t\tlbMap.put(name, lb);\n\t\t\tubMap.put(name, ub);\n\t\t}\n\t\tn=sc.nextInt();\n\t\tes=new String[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tes[i]=sc.next();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint M=256;\n\t\tLinkedList<int[]> stack=new LinkedList<int[]>();\n\t\tboolean correct=true;\n\t\tfor(int k=0; k<n; k++){\n//\t\t\tdebug(k);\n\t\t\tchar c=es[k].charAt(0);\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tint[] a=new int[M];\n\t\t\t\ta[Integer.parseInt(es[k])]=1;\n\t\t\t\tstack.push(a);\n\t\t\t}else if(Character.isLetter(c)){\n\t\t\t\tint[] a=new int[M];\n\t\t\t\tint lb=lbMap.get(es[k]);\n\t\t\t\tint ub=ubMap.get(es[k]);\n\t\t\t\tfor(int i=lb; i<=ub; i++){\n\t\t\t\t\ta[i]=1;\n\t\t\t\t}\n\t\t\t\tstack.push(a);\n\t\t\t}else{\n\t\t\t\tint[] b=stack.pop();\n\t\t\t\tint[] a=stack.pop();\n\t\t\t\tint[] r=new int[M];\n\t\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\t\tif(a[i]==0||b[j]==0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res;\n\t\t\t\t\t\tif(c=='+'){\n\t\t\t\t\t\t\tres=(i+j)%256;\n\t\t\t\t\t\t}else if(c=='-'){\n\t\t\t\t\t\t\tres=(i-j+256)%256;\n\t\t\t\t\t\t}else if(c=='*'){\n\t\t\t\t\t\t\tres=(i*j)%256;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(j==0){\n\t\t\t\t\t\t\t\tres=0;\n\t\t\t\t\t\t\t\tcorrect=false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tres=(i/j)%256;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr[res]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.push(r);\n\t\t\t}\n\t\t}\n\n\t\tprintln(correct?\"correct\":\"error\");\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] arg) {\n\t\tHashMap<String, Var> map = new HashMap<String, Var>();\n\t\tint M = sc.nextInt();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tString name = sc.next();\n\t\t\tint lb = sc.nextInt();\n\t\t\tint ub = sc.nextInt();\n\t\t\tmap.put(name, new Var(lb, ub));\n\t\t}\n\t\tint N = sc.nextInt();\n\t\tboolean result = true;\n\t\tArrayList<Var> stack = new ArrayList<Var>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tString elem = sc.next();\n\t\t\tif (elem.equals(\"+\")) {\n\t\t\t\tVar v1 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar v2 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar nv = new Var();\n\t\t\t\tfor (int j = 0; j <= 255; ++j) {\n\t\t\t\t\tif (!v1.v[j]) continue;\n\t\t\t\t\tfor (int k = 0; k <= 255; ++k) {\n\t\t\t\t\t\tif (!v2.v[k]) continue;\n\t\t\t\t\t\tnv.v[(k + j) % 256] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.add(nv);\n\t\t\t} else if (elem.equals(\"-\")) {\n\t\t\t\tVar v1 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar v2 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar nv = new Var();\n\t\t\t\tfor (int j = 0; j <= 255; ++j) {\n\t\t\t\t\tif (!v1.v[j]) continue;\n\t\t\t\t\tfor (int k = 0; k <= 255; ++k) {\n\t\t\t\t\t\tif (!v2.v[k]) continue;\n\t\t\t\t\t\tnv.v[(k - j + 256) % 256] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.add(nv);\n\t\t\t} else if (elem.equals(\"*\")) {\n\t\t\t\tVar v1 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar v2 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar nv = new Var();\n\t\t\t\tfor (int j = 0; j <= 255; ++j) {\n\t\t\t\t\tif (!v1.v[j]) continue;\n\t\t\t\t\tfor (int k = 0; k <= 255; ++k) {\n\t\t\t\t\t\tif (!v2.v[k]) continue;\n\t\t\t\t\t\tnv.v[(k * j) % 256] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.add(nv);\n\t\t\t} else if (elem.equals(\"/\")) {\n\t\t\t\tVar v1 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tVar v2 = stack.get(stack.size() - 1);\n\t\t\t\tstack.remove(stack.size() - 1);\n\t\t\t\tif (v1.v[0]) {\n\t\t\t\t\tresult = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tVar nv = new Var();\n\t\t\t\tfor (int j = 0; j <= 255; ++j) {\n\t\t\t\t\tif (!v1.v[j]) continue;\n\t\t\t\t\tfor (int k = 0; k <= 255; ++k) {\n\t\t\t\t\t\tif (!v2.v[k]) continue;\n\t\t\t\t\t\tnv.v[k / j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.add(nv);\n\t\t\t} else if (map.containsKey(elem)) {\n\t\t\t\tstack.add(map.get(elem));\n\t\t\t} else {\n\t\t\t\tstack.add(new Var(Integer.parseInt(elem)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result ? \"correct\" : \"error\");\n\t}\n\n\tstatic class Var {\n\t\tboolean[] v = new boolean[256];\n\n\t\tVar(int min, int max) {\n\t\t\tfor (int i = min; i <= max; ++i) {\n\t\t\t\tv[i] = true;\n\t\t\t}\n\t\t}\n\n\t\tVar(int num) {\n\t\t\tv[num] = true;\n\t\t}\n\n\t\tVar() {}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Zero Division Checker\n// 2012/09/20\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m;\n\tHashMap<String, Integer> lbMap, ubMap;\n\tint n;\n\tString[] es;\n\n\tvoid run(){\n\t\tm=sc.nextInt();\n\t\tlbMap=new HashMap<String, Integer>();\n\t\tubMap=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tString name=sc.next();\n\t\t\tint lb=sc.nextInt();\n\t\t\tint ub=sc.nextInt();\n\t\t\tlbMap.put(name, lb);\n\t\t\tubMap.put(name, ub);\n\t\t}\n\t\tn=sc.nextInt();\n\t\tes=new String[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tes[i]=sc.next();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tint M=256;\n\t\tLinkedList<int[]> stack=new LinkedList<int[]>();\n\t\tboolean correct=true;\n\t\tfor(int k=0; k<n; k++){\n\t\t\tchar c=es[k].charAt(0);\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tint[] a=new int[M];\n\t\t\t\ta[Integer.parseInt(es[k])]=1;\n\t\t\t\tstack.push(a);\n\t\t\t}else if(Character.isLetter(c)){\n\t\t\t\tint[] a=new int[M];\n\t\t\t\tint lb=lbMap.get(es[k]);\n\t\t\t\tint ub=ubMap.get(es[k]);\n\t\t\t\tfor(int i=lb; i<=ub; i++){\n\t\t\t\t\ta[i]=1;\n\t\t\t\t}\n\t\t\t\tstack.push(a);\n\t\t\t}else{\n\t\t\t\tint[] b=stack.pop();\n\t\t\t\tint[] a=stack.pop();\n\t\t\t\tint[] r=new int[M];\n\t\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\t\tif(a[i]==0||b[j]==0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint res;\n\t\t\t\t\t\tif(c=='+'){\n\t\t\t\t\t\t\tres=(i+j)%256;\n\t\t\t\t\t\t}else if(c=='-'){\n\t\t\t\t\t\t\tres=(i-j+256)%256;\n\t\t\t\t\t\t}else if(c=='*'){\n\t\t\t\t\t\t\tres=(i*j)%256;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(j==0){\n\t\t\t\t\t\t\t\tcorrect=false;\n\t\t\t\t\t\t\t\tres=0;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tres=(i/j)%256;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr[res]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstack.push(r);\n\t\t\t}\n\t\t}\n\t\tprintln(correct?\"correct\":\"error\");\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.lang.ArithmeticException;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Zero Division Checker\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tMap<String, Mono> vars = new HashMap<>();\n\n\t\t//\n\t\tint m = parseInt(br.readLine());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tvars.put(\n\t\t\t\t\twords[0],\n\t\t\t\t\tmain.new Mono(\n\t\t\t\t\t\t\tparseInt(words[1]),\n\t\t\t\t\t\t\tparseInt(words[2])\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//parse\n\t\tint n = parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tDeque<Exp> stack = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString e = st.nextToken();\n\t\t\tif (\"+-*/\".contains(e)) {\n\t\t\t\tExp a, b;\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tswitch (e) {\n\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Add()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Subtract()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Multiply()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Divide()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (vars.containsKey(e)) {\n\t\t\t\t\tstack.push(vars.get(e));\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Mono(parseInt(e)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tExp exp = stack.pop();\n\t\ttry {\n\t\t\texp.eval();\n\t\t\tSystem.out.println(\"correct\");\n\t\t} catch (ArithmeticException ex) {\n\t\t\tSystem.out.println(\"error\");\n\t\t}\n\t}\n\n\t//Element\n\tinterface Elm {\n\t}\n\n\t//Operator\n\tinterface Op extends Elm {\n\t\tint eval(int a, int b);\n\t}\n\n\tclass Add implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a + b) % 256;\n\t\t}\n\t}\n\n\tclass Subtract implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a - b + 256) % 256;\n\t\t}\n\t}\n\n\tclass Multiply implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a * b) % 256;\n\t\t}\n\t}\n\n\tclass Divide implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a / b) % 256;\n\t\t}\n\t}\n\n\t//\n\tinterface Exp extends Elm {\n\t\tExp eval();\n\n\t\tint lb();\n\n\t\tint ub();\n\t}\n\n\tclass Mono implements Exp {\n\t\tint lb, ub;\n\n\t\tMono(int lb) {\n\t\t\tthis(lb, lb);\n\t\t}\n\n\t\tMono(int lb, int ub) {\n\t\t\tthis.lb = lb;\n\t\t\tthis.ub = ub;\n\t\t}\n\n\t\tpublic Mono eval() {\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n\n\tclass Bino implements Exp {\n\t\tint lb = 256, ub = -1;\n\t\tExp a, b;\n\t\tOp op;\n\n\t\tBino(Exp a, Exp b, Op op) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.op = op;\n\t\t}\n\n\t\tpublic Exp eval() {\n\n\t\t\tif (a instanceof Bino) a.eval();\n\t\t\tif (b instanceof Bino) b.eval();\n\n\t\t\tint alb, aub;\n\t\t\tint blb, bub;\n\t\t\talb = a.lb();\n\t\t\taub = a.ub();\n\t\t\tblb = b.lb();\n\t\t\tbub = b.ub();\n\n\t\t\tfor (int i = alb; i <= aub; i++) {\n\t\t\t\tfor (int j = blb; j <= bub; j++) {\n\t\t\t\t\tint r = op.eval(i, j);\n\t\t\t\t\tlb = Math.min(lb, r);\n\t\t\t\t\tub = Math.max(ub, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Mono(lb, ub);\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.util.Stack;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"src/T2\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tboolean ans = true;\n\t\n\tclass Elem {\n\t\tboolean[] can = new boolean[256];\n\n\t\tElem() { }\n\t\t\n\t\tElem(int lower, int upper) {\n\t\t\tfor (int i = lower; i <= upper; i++) {\n\t\t\t\tcan[i%256] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid set(int x) {\n\t\t\tcan[x%256] = true;\n\t\t}\n\n\t\tElem add(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tres.set(i+j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tElem sub(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tres.set(i-j+256);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tElem mult(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tcan[(i*j) % 256] = true;\n\t\t\t\t\tres.set(i*j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tElem div(Elem e) {\n\t\t\tElem res = new Elem();\n\t\t\tfor (int i = 0; i < 256; i++) {\n\t\t\t\tif (!can[i]) continue;\n\t\t\t\tfor (int j = 0; j < 256; j++) {\n\t\t\t\t\tif (!e.can[j]) continue;\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tans = false; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.set(i/j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tpublic void solve() {\t\n\t\tint n = in.nextInt();\n\t\tHashMap<String, Elem> map = new HashMap<String, Elem>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString name = in.next();\n\t\t\tint lower = in.nextInt(), upper = in.nextInt();\n\t\t\tmap.put(name, new Elem(lower, upper));\n\t\t}\n\t\t\n\t\tint m = in.nextInt();\n\t\tStack<Elem> stack = new Stack<Elem>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString next = in.next();\n\t\t\tchar c = next.charAt(0);\n\t\t\tif (c == '+') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.add(e1));\n\t\t\t} else if (c == '-') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.sub(e1));\t\t\t\t\n\t\t\t} else if (c == '*') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.mult(e1));\t\t\t\t\n\t\t\t} else if (c == '/') {\n\t\t\t\tElem e1 = stack.pop();\n\t\t\t\tElem e2 = stack.pop();\n\t\t\t\tstack.push(e2.div(e1));\n\t\t\t\tif (!ans) break;\n\t\t\t} else if (Character.isDigit(c)) {\n\t\t\t\tint val = Integer.valueOf(next);\n\t\t\t\tstack.push(new Elem(val, val));\n\t\t\t} else if (Character.isAlphabetic(c)) {\n\t\t\t\tstack.push(map.get(next));\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(ans ? \"correct\" : \"error\");\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.lang.ArithmeticException;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Zero Division Checker\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tMap<String, Mono> vars = new HashMap<>();\n\n\t\t//\n\t\tint m = parseInt(br.readLine());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tvars.put(\n\t\t\t\t\twords[0],\n\t\t\t\t\tmain.new Mono(\n\t\t\t\t\t\t\tparseInt(words[1]),\n\t\t\t\t\t\t\tparseInt(words[2])\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//parse\n\t\tint n = parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tDeque<Exp> stack = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString e = st.nextToken();\n\t\t\tif (\"+-*/\".contains(e)) {\n\t\t\t\tExp a, b;\n\t\t\t\tOp op;\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tswitch (e) {\n\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\top = main.new Add();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\top = main.new Subtract();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\top = main.new Multiply();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\top = main.new Divide();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\top = null;\n\t\t\t\t\t\tstack.push(main.new Bin(a, b, op));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (vars.containsKey(e)) {\n\t\t\t\t\tstack.push(vars.get(e));\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Mono(parseInt(e)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tExp exp = stack.pop();\n\t\ttry {\n\t\t\texp.eval();\n\t\t\tSystem.out.println(\"correct\");\n\t\t} catch (ArithmeticException e) {\n\t\t\tSystem.out.println(\"error\");\n\t\t}\n\t}\n\n\t//Operator\n\tinterface Op {\n\t\tint eval(int a, int b);\n\t}\n\n\tclass Add implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a + b) % 256;\n\t\t}\n\t}\n\n\tclass Subtract implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a - b + 256) % 256;\n\t\t}\n\t}\n\n\tclass Multiply implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a * b) % 256;\n\t\t}\n\t}\n\n\tclass Divide implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a / b) % 256;\n\t\t}\n\t}\n\n\t//\n\tinterface Exp {\n\t\tExp eval();\n\n\t\tint lb();\n\n\t\tint ub();\n\t}\n\n\tclass Mono implements Exp {\n\t\tint lb, ub;\n\n\t\tMono(int lb) {\n\t\t\tthis(lb, lb);\n\t\t}\n\n\t\tMono(int lb, int ub) {\n\t\t\tthis.lb = lb;\n\t\t\tthis.ub = ub;\n\t\t}\n\n\t\tpublic Mono eval() {\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n\n\tclass Bin implements Exp {\n\t\tint lb = 256, ub = -1;\n\t\tExp a, b;\n\t\tOp op;\n\n\t\tBin(Exp a, Exp b, Op op) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.op = op;\n\t\t}\n\n\t\tpublic Exp eval() {\n\n\t\t\tif (a instanceof Bin) a.eval();\n\t\t\tif (b instanceof Bin) b.eval();\n\n\t\t\tint alb = a.lb(), aub = a.ub();\n\t\t\tint blb = b.lb(), bub = b.ub();\n\n\t\t\tfor (int i = alb; i <= aub; i++) {\n\t\t\t\tfor (int j = blb; j <= bub; j++) {\n\t\t\t\t\tint r = op.eval(i, j);\n\t\t\t\t\tlb = Math.min(lb, r);\n\t\t\t\t\tub = Math.max(ub, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Mono(lb, ub);\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.lang.ArithmeticException;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Zero Division Checker\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tMap<String, Mono> vars = new HashMap<>();\n\n\t\t//\n\t\tint m = parseInt(br.readLine());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tvars.put(\n\t\t\t\t\twords[0],\n\t\t\t\t\tmain.new Mono(\n\t\t\t\t\t\t\tparseInt(words[1]),\n\t\t\t\t\t\t\tparseInt(words[2])\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//parse\n\t\tint n = parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tDeque<Exp> stack = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString e = st.nextToken();\n\t\t\tif (\"+-*/\".contains(e)) {\n\t\t\t\tExp a, b;\n\t\t\t\tOp op;\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tswitch (e) {\n\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\top = main.new Add();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\top = main.new Subtract();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\top = main.new Multiply();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\top = main.new Divide();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\top = null;\n\t\t\t\t}\n\t\t\t\tstack.push(main.new Bin(a, b, op));\n\t\t\t} else {\n\t\t\t\tif (vars.containsKey(e)) {\n\t\t\t\t\tstack.push(vars.get(e));\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Mono(parseInt(e)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tExp exp = stack.pop();\n\t\ttry {\n\t\t\texp.eval();\n\t\t\tSystem.out.println(\"correct\");\n\t\t} catch (ArithmeticException e) {\n\t\t\tSystem.out.println(\"error\");\n\t\t}\n\t}\n\n\t//Operator\n\tinterface Op {\n\t\tint eval(int a, int b);\n\t}\n\n\tclass Add implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a + b) % 256;\n\t\t}\n\t}\n\n\tclass Subtract implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a - b + 256) % 256;\n\t\t}\n\t}\n\n\tclass Multiply implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a * b) % 256;\n\t\t}\n\t}\n\n\tclass Divide implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a / b) % 256;\n\t\t}\n\t}\n\n\t//\n\tinterface Exp {\n\t\tExp eval();\n\n\t\tint lb();\n\n\t\tint ub();\n\t}\n\n\tclass Mono implements Exp {\n\t\tint lb, ub;\n\n\t\tMono(int lb) {\n\t\t\tthis(lb, lb);\n\t\t}\n\n\t\tMono(int lb, int ub) {\n\t\t\tthis.lb = lb;\n\t\t\tthis.ub = ub;\n\t\t}\n\n\t\tpublic Mono eval() {\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n\n\tclass Bin implements Exp {\n\t\tint lb = 256, ub = -1;\n\t\tExp a, b;\n\t\tOp op;\n\n\t\tBin(Exp a, Exp b, Op op) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.op = op;\n\t\t}\n\n\t\tpublic Exp eval() {\n\n\t\t\tif (a instanceof Bin) a.eval();\n\t\t\tif (b instanceof Bin) b.eval();\n\n\t\t\tint alb = a.lb(), aub = a.ub();\n\t\t\tint blb = b.lb(), bub = b.ub();\n\n\t\t\tfor (int i = alb; i <= aub; i++) {\n\t\t\t\tfor (int j = blb; j <= bub; j++) {\n\t\t\t\t\tint r = op.eval(i, j);\n\t\t\t\t\tlb = Math.min(lb, r);\n\t\t\t\t\tub = Math.max(ub, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Mono(lb, ub);\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Stack;\n\n//Zero Division Checker\npublic class Main{\n\n\tclass R{\n\t\tboolean[] p;\n\t\tpublic R() {\n\t\t\tp = new boolean[256];\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();\n\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\tint[] lb = new int[m], ub = new int[m];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tref.put(sc.next(), i);\n\t\t\tlb[i] = sc.nextInt(); ub[i] = sc.nextInt();\n\t\t}\n\t\tint n = sc.nextInt();\n\t\tboolean res = true;\n\t\tStack<R> r = new Stack<R>();\n\t\twhile(n--!=0){\n\t\t\tString s = sc.next();\n\t\t\tR v = new R();\n\t\t\tif(ref.containsKey(s)){\n\t\t\t\tint id = ref.get(s);\n\t\t\t\tfor(int i=lb[id];i<=ub[id];i++)v.p[i] = true;\n\t\t\t}\n\t\t\telse if(\"/\".equals(s)){\n\t\t\t\tR b = r.pop(), a = r.pop();\n\t\t\t\tif(b.p[0]){\n\t\t\t\t\tres = false; break;\n\t\t\t\t}\n\t\t\t\tfor(int x=0;x<256;x++)if(a.p[x])for(int y=0;y<256;y++)if(b.p[y])v.p[(x/y)%256] = true;\n\t\t\t}\n\t\t\telse if(\"+\".equals(s)){\n\t\t\t\tR b = r.pop(), a = r.pop();\n\t\t\t\tfor(int x=0;x<256;x++)if(a.p[x])for(int y=0;y<256;y++)if(b.p[y])v.p[(x+y)%256] = true;\n\t\t\t}\n\t\t\telse if(\"-\".equals(s)){\n\t\t\t\tR b = r.pop(), a = r.pop();\n\t\t\t\tfor(int x=0;x<256;x++)if(a.p[x])for(int y=0;y<256;y++)if(b.p[y])v.p[(x-y+256)%256] = true;\n\t\t\t}\n\t\t\telse if(\"*\".equals(s)){\n\t\t\t\tR b = r.pop(), a = r.pop();\n\t\t\t\tfor(int x=0;x<256;x++)if(a.p[x])for(int y=0;y<256;y++)if(b.p[y])v.p[(x*y)%256] = true;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tv.p[Integer.parseInt(s)] = true;\n\t\t\t}\n\t\t\tr.add(v);\n\t\t}\n\t\tSystem.out.println(res?\"correct\":\"error\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.lang.ArithmeticException;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Zero Division Checker\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\tMap<String, Mono> vars = new HashMap<>();\n\n\t\t//\n\t\tint m = parseInt(br.readLine());\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tvars.put(\n\t\t\t\t\twords[0],\n\t\t\t\t\tmain.new Mono(\n\t\t\t\t\t\t\tparseInt(words[1]),\n\t\t\t\t\t\t\tparseInt(words[2])\n\t\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t//parse\n\t\tint n = parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tDeque<Exp> stack = new ArrayDeque<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString e = st.nextToken();\n\t\t\tif (\"+-*/\".contains(e)) {\n\t\t\t\tExp a, b;\n\t\t\t\tb = stack.pop();\n\t\t\t\ta = stack.pop();\n\t\t\t\tswitch (e) {\n\t\t\t\t\tcase \"+\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Add()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"-\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Subtract()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"*\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Multiply()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"/\":\n\t\t\t\t\t\tstack.push(main.new Bino(a, b, main.new Divide()));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (vars.containsKey(e)) {\n\t\t\t\t\tstack.push(vars.get(e));\n\t\t\t\t} else {\n\t\t\t\t\tstack.push(main.new Mono(parseInt(e)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tExp exp = stack.pop();\n\t\ttry {\n\t\t\texp.eval();\n\t\t\tSystem.out.println(\"correct\");\n\t\t} catch (ArithmeticException ex) {\n\t\t\tSystem.out.println(\"error\");\n\t\t}\n\t}\n\n\t//Element\n\tinterface Elm {\n\t}\n\n\t//Operator\n\tinterface Op extends Elm {\n\t\tint eval(int a, int b);\n\t}\n\n\tclass Add implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a + b) % 256;\n\t\t}\n\t}\n\n\tclass Subtract implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a - b + 256) % 256;\n\t\t}\n\t}\n\n\tclass Multiply implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a * b) % 256;\n\t\t}\n\t}\n\n\tclass Divide implements Op {\n\t\t@Override\n\t\tpublic int eval(int a, int b) {\n\t\t\treturn (a / b) % 256;\n\t\t}\n\t}\n\n\t//\n\tinterface Exp extends Elm {\n\t\tExp eval();\n\n\t\tint lb();\n\n\t\tint ub();\n\t}\n\n\tclass Mono implements Exp {\n\t\tint lb, ub;\n\n\t\tMono(int lb) {\n\t\t\tthis(lb, lb);\n\t\t}\n\n\t\tMono(int lb, int ub) {\n\t\t\tthis.lb = lb;\n\t\t\tthis.ub = ub;\n\t\t}\n\n\t\tpublic Mono eval() {\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n\n\tclass Bino implements Exp {\n\t\tint lb, ub;\n\t\tExp a, b;\n\t\tOp op;\n\n\t\tBino(Exp a, Exp b, Op op) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.op = op;\n\t\t}\n\n\t\tpublic Exp eval() {\n\n\t\t\tif (a instanceof Bino) a.eval();\n\t\t\tif (b instanceof Bino) b.eval();\n\n\t\t\tint alb, aub;\n\t\t\tint blb, bub;\n\t\t\talb = a.lb();\n\t\t\taub = a.ub();\n\t\t\tblb = b.lb();\n\t\t\tbub = b.ub();\n\n\t\t\tfor (int i = alb; i <= aub; i++) {\n\t\t\t\tfor (int j = blb; j <= bub; j++) {\n\t\t\t\t\tint r = op.eval(i, j);\n\t\t\t\t\tlb = Math.min(lb, r);\n\t\t\t\t\tub = Math.max(ub, r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new Mono(lb, ub);\n\t\t}\n\n\t\tpublic int lb() {\n\t\t\treturn lb;\n\t\t}\n\n\t\tpublic int ub() {\n\t\t\treturn ub;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\t%w( + - * / % ).each do |op|\n\t\tdefine_method op do |other|\n\t\t\tproduct(other).map{|x, y| x.send(op, y) % 256}.flatten.uniq \n\t\tend\n\tend\nend\n\nn = gets.to_i\nvar = {}\nn.times do\n\tname, l, u = gets.chomp.split\n\tvar[name] = (l.to_i..u.to_i).to_a\nend\n\ngets\nstack = []\n\nbegin \n\tgets.chomp.split.each do |x|\n\t\tcase x\n\t\twhen /[+-\\/*%]/\n\t\t\trhs, lhs = stack.pop, stack.pop\n\t\t\tstack << lhs.send(x, rhs)\n\t\twhen /^\\d+$/\n\t\t\tstack << [x.to_i]\n\t\telse\n\t\t\tstack << var[x]\n\t\tend\n\tend\t\n\tputs 'correct'\nrescue\n\tputs 'error'\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\t%w( + - * / % ).each do |op|\n\t\torig = \"orig_\" + op\n\t\talias_method orig, op\n\t\tdefine_method op do |other|\n\t\t\treturn send(orig, other).send(\"orig_%\", 256) if other.class == Fixnum\t\n\t\t\tother.map{|x| send(orig, x).send(\"orig_%\", 256)}.uniq\n\t\tend\n\tend\nend\n\nclass Array\n\t%w( + - * / % ).each do |op|\n\t\tdefine_method op do |other|\n\t\t\tif other.class == Fixnum\n\t\t\t\treturn map{|x| x.send(op, other)}.uniq\n\t\t\tend\n\n\t\t\tmap{|x| x.send(op, other)}.flatten.uniq \n\t\tend\n\tend\nend\n\nn = gets.to_i\nvar = {}\nn.times do\n\tname, l, u = gets.chomp.split\n\tvar[name] = (l.to_i..u.to_i).to_a\nend\n\ngets\nstack = []\n\nbegin \n\tgets.chomp.split.each do |x|\n\t\tcase x\n\t\twhen /[+-\\/*%]/\n\t\t\trhs, lhs = stack.pop, stack.pop\n\t\t\tp [lhs, x, rhs]\n\t\t\tstack << lhs.send(x, rhs)\n\t\twhen /^\\d+$/\n\t\t\tstack << x.to_i\n\t\telse\n\t\t\tstack << var[x]\n\t\tend\n\tend\t\n\tputs 'correct'\nrescue\n\tputs 'error'\nend"
  },
  {
    "language": "Ruby",
    "code": "class Fixnum\n\t%w( + - * / % ).each do |op|\n\t\torig = \"orig_\" + op\n\t\talias_method orig, op\n\t\tdefine_method op do |other|\n\t\t\treturn send(orig, other).send(\"orig_%\", 256) if other.class == Fixnum\t\n\t\t\tother.map{|x| send(orig, x).send(\"orig_%\", 256)}.uniq\n\t\tend\n\tend\nend\n\nclass Array\n\t%w( + - * / % ).each do |op|\n\t\tdefine_method op do |other|\n\t\t\tif other.class == Fixnum\n\t\t\t\treturn map{|x| x.send(op, other)}.uniq\n\t\t\tend\n\n\t\t\tmap{|x| x.send(op, other)}.flatten.uniq \n\t\tend\n\tend\nend\n\nn = gets.to_i\nvar = {}\nn.times do\n\tname, l, u = gets.chomp.split\n\tvar[name] = (l.to_i..u.to_i).to_a\nend\n\ngets\nstack = []\n\nbegin \n\tgets.chomp.split.each do |x|\n\t\tcase x\n\t\twhen /[+-\\/*%]/\n\t\t\trhs, lhs = stack.pop, stack.pop\n\t\t\tstack << lhs.send(x, rhs)\n\t\twhen /^\\d+$/\n\t\t\tstack << x.to_i\n\t\telse\n\t\t\tstack << var[x]\n\t\tend\n\tend\t\n\tputs 'correct'\nrescue\n\tputs 'error'\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.array;\n\nbool[] makeRange( int from, int to ) {\n  bool ans[] = new bool[ 256 ];\n  ans[] = false;\n  foreach ( i; from .. to + 1 ) {\n\tans[ i ] = true;\n  }\n  return ans;\n}\n\nbool[] makeNumber( int i ) {\n  bool ans[] = new bool[ 256 ];\n  ans[] = false;\n  ans[ i ] = true;\n  return ans;\n}\n\nbool[] makeAdd( bool[] a, bool[] b ) {\n  bool[] ans = new bool[ 256 ];\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i + j ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nbool[] makeSub( bool[] a, bool[] b ) {\n  bool[] ans = new bool[ 256 ];\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i - j + 256 ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nbool[] makeMult( bool[] a, bool[] b ) {\n  bool[] ans = new bool[ 256 ];\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i * j ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nbool[] makeDiv( bool[] a, bool[] b ) {\n  bool[] ans = new bool[ 256 ];\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i / j ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nvoid main()\n{\n  int m = to!int( strip( readln ) );\n  bool[][ string ] table;\n  foreach ( i; 0 .. m ) {\n\tauto token = split( strip( readln ) );\n\ttable[ token[ 0 ] ] = makeRange( to!int( token[ 1 ] ), to!int( token[ 2 ] ) );\n  }\n  int n = to!int( strip( readln ) );\n  auto tokenArray = split( strip( readln ) );\n  if ( solve( table, tokenArray ) ) {\n\twriteln( \"correct\" );\n  } else {\n\twriteln( \"error\" );\n  }\n}\n\nbool solve ( bool[][ string ] table, string[] tokenArray ) {\n  auto ary = new bool[ 256 ][ 256 ];\n  int index = 0;\n  foreach ( t; tokenArray ) {\n\tif ( isNumeric( t ) ) {\n\t  ary[ index++ ][] = makeNumber( to!int( t ) );\n\t} else if ( t in table ) {\n\t  ary[ index++ ][] = table[ t ];\n\t} else {\n\t  auto b = ary[ --index ];\n\t  auto a = ary[ --index ];\n\t  if ( t == \"+\" ) {\n\t\tary[ index++ ][] = makeAdd( a, b );\n\t  } else if ( t == \"-\" ) {\n\t\tary[ index++ ][] = makeSub( a, b );\n\t  } else if ( t == \"*\" ) {\n\t\tary[ index++ ][] = makeMult( a, b );\n\t  } else if ( t == \"/\" ) {\n\t\tif ( b[ 0 ] ) {\n\t\t  return false;\n\t\t} else {\n\t\t  ary[ index++ ][] = makeDiv( a, b );\n\t\t}\n\t  } else {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.conv, std.string, std.array;\n\nbool[] makeRange( int from, int to ) {\n  bool[] ans = new bool[]( 256 );\n  ans[] = false;\n  foreach ( i; from .. to + 1 ) {\n\tans[ i ] = true;\n  }\n  return ans;\n}\n\nbool[] makeNumber( int i ) {\n  bool[] ans = new bool[]( 256 );\n  // bool ans[] = new bool[ 256 ];\n  ans[] = false;\n  ans[ i ] = true;\n  return ans;\n}\n\nbool[] makeAdd( bool[] a, bool[] b ) {\n  bool[] ans = new bool[]( 256 );\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i + j ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nbool[] makeSub( bool[] a, bool[] b ) {\n  bool[] ans = new bool[]( 256 );\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i - j + 256 ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nbool[] makeMult( bool[] a, bool[] b ) {\n  bool[] ans = new bool[]( 256 );\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 0 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i * j ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nbool[] makeDiv( bool[] a, bool[] b ) {\n  bool[] ans = new bool[]( 256 );\n  foreach ( i; 0 .. 256 ) {\n\tforeach ( j; 1 .. 256 ) {\n\t  if ( a[ i ] && b[ j ] ) {\n\t\tans[ ( i / j ) % 256 ] = true;\n\t  }\n\t}\n  }\n  return ans;\n}\n\nvoid main()\n{\n  int m = to!int( strip( readln ) );\n  bool[][ string ] table;\n  foreach ( i; 0 .. m ) {\n\tauto token = split( strip( readln ) );\n\ttable[ token[ 0 ] ] = makeRange( to!int( token[ 1 ] ), to!int( token[ 2 ] ) );\n  }\n  int n = to!int( strip( readln ) );\n  auto tokenArray = split( strip( readln ) );\n  if ( solve( table, tokenArray ) ) {\n\twriteln( \"correct\" );\n  } else {\n\twriteln( \"error\" );\n  }\n}\n\nbool solve ( bool[][ string ] table, string[] tokenArray ) {\n  auto ary = new bool[][]( 256, 256 );\n  int index = 0;\n  foreach ( t; tokenArray ) {\n\tif ( isNumeric( t ) ) {\n\t  ary[ index++ ][] = makeNumber( to!int( t ) );\n\t} else if ( t in table ) {\n\t  ary[ index++ ][] = table[ t ];\n\t} else {\n\t  auto b = ary[ --index ];\n\t  auto a = ary[ --index ];\n\t  if ( t == \"+\" ) {\n\t\tary[ index++ ][] = makeAdd( a, b );\n\t  } else if ( t == \"-\" ) {\n\t\tary[ index++ ][] = makeSub( a, b );\n\t  } else if ( t == \"*\" ) {\n\t\tary[ index++ ][] = makeMult( a, b );\n\t  } else if ( t == \"/\" ) {\n\t\tif ( b[ 0 ] ) {\n\t\t  return false;\n\t\t} else {\n\t\t  ary[ index++ ][] = makeDiv( a, b );\n\t\t}\n\t  } else {\n\t\treturn false;\n\t  }\n\t}\n  }\n  return true;\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN = input()\n\nm = {}\n\nfor loop in range(N):\n    s, p1, p2 = raw_input().split()\n    m[s] = (int(p1), int(p2))\n\nN = input()\nlst = raw_input().replace('/', '//').split()\nsta = []\n\nfor s in lst:\n    hoge = [0 for i in range(256)]\n    if s in m:\n        p = m[s]\n        for i in range(p[0], p[1] + 1):\n            hoge[i] = 1\n        sta.append(hoge)\n    elif s in ['+', '-', '*', '//']:\n        n2 = sta.pop()\n        n1 = sta.pop()\n        #print s,n1, n2\n        for i in range(256):\n            for j in range(256):\n                if n1[i] and n2[j]:\n                    try:\n                        index = eval(str(i) + s + str(j))\n                        hoge[index % 256] = 1\n                    except:\n                        print \"error\"\n                        exit()\n        #print hoge\n        sta.append(hoge)\n    else:\n        hoge[int(s)] = 1\n        sta.append(hoge)\n\nprint \"correct\"\n    \n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nN = input()\n\nm = {}\n\nfor loop in range(N):\n    s, p1, p2 = raw_input().split()\n    m[s] = (int(p1), int(p2))\n\nN = input()\nlst = raw_input().replace('/', '//').split()\nsta = []\n\nfor s in lst:\n    hoge = [0 for i in range(256)]\n    if s in m:\n        p = m[s]\n        for i in range(p[0], p[1] + 1):\n            hoge[i] = 1\n        sta.append(hoge)\n    elif s in ['+', '-', '*', '//']:\n        n2 = sta.pop()\n        n1 = sta.pop()\n        #print s,n1, n2\n        for i in xrange(256):\n            for j in xrange(256):\n                if n1[i] and n2[j]:\n                    try:\n                        index = eval(str(i) + s + str(j))\n                        hoge[index % 256] = 1\n                    except:\n                        print \"error\"\n                        exit()\n        #print hoge\n        sta.append(hoge)\n    else:\n        hoge[int(s)] = 1\n        sta.append(hoge)\n\nprint \"correct\"\n    \n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    def f(n):\n        d = {}\n        for _ in range(n):\n            c,a,b = LS()\n            s = set()\n            for i in range(int(a),int(b)+1):\n                s.add(i)\n            d[c] = s\n        m = I()\n        aa = LS()\n        st = []\n        for c in aa:\n            if re.match(r'^\\d+$', c):\n                st.append(set([int(c)]))\n            elif c in d:\n                st.append(d[c])\n            else:\n                a,b = st[-2:]\n                st = st[:-2]\n                t = set()\n                if c == '/':\n                    if 0 in b:\n                        return 'error'\n                    for ai in a:\n                        for bi in b:\n                            t.add((ai//bi) % 256)\n                elif c == '+':\n                    for ai in a:\n                        for bi in b:\n                            t.add((ai+bi) % 256)\n                elif c == '-':\n                    for ai in a:\n                        for bi in b:\n                            t.add((ai-bi) % 256)\n                else:\n                    for ai in a:\n                        for bi in b:\n                            t.add((ai*bi) % 256)\n                st.append(t)\n        return 'correct'\n\n\n\n    while True:\n        n = I()\n        rr.append(f(n))\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn operate(a: &[bool; 256], b: &[bool; 256], op: char) -> Option<[bool; 256]> {\n    let mut ans = [false; 256];\n    macro_rules! exhaust {\n        ($op:expr) => {\n            for i in 0 .. 256 {\n                if a[i] {\n                    for j in 0 .. 256 {\n                        if b[j] {\n                            ans[$op(i, j)] = true;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    match op {\n        '+' => exhaust!(|i, j| (i + j) % 256),\n        '-' => exhaust!(|i, j| (i + 256 - j) % 256),\n        '*' => exhaust!(|i, j| (i * j) % 256),\n        '/' => {\n            if b[0] {\n                return None;\n            }\n            exhaust!(|i, j| i / j);\n        },\n        _ => panic!(),\n    }\n    Some(ans)\n}\n\nfn solve() {\n    let m = get();\n    let mut hm = HashMap::new();\n    for _ in 0 .. m {\n        let name = get_word();\n        let lb: usize = get();\n        let ub: usize = get();\n        hm.insert(name, (lb, ub));\n    }\n    let n = get();\n    let e: Vec<String> = (0 .. n).map(|_| get_word()).collect();\n    let mut stack = Vec::new();\n    let mut mess = false;\n    for e in &e {\n        match e.parse::<usize>() {\n            Ok(num) => {\n                let mut t = [false; 256];\n                t[num % 256] = true;\n                stack.push(t);\n            },\n            Err(_) => {\n                match hm.get(e) {\n                    Some(&(lb, ub)) => {\n                        let mut ans = [false; 256];\n                        for i in lb .. ub + 1 {\n                            ans[i] = true;\n                        }\n                        stack.push(ans);\n                    },\n                    None => {\n                        let b = stack.pop().unwrap();\n                        let a = stack.pop().unwrap();\n                        if let Some(res) = operate(&a, &b, e.chars().nth(0).unwrap()) {\n                            stack.push(res);\n                        } else {\n                            mess = true;\n                            break;\n                        }\n                    },\n                }\n            }\n        }\n    }\n    println!(\"{}\", if mess { \"error\" } else { \"correct\" });\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn operate(a: &[bool; 256], b: &[bool; 256], op: char) -> Option<[bool; 256]> {\n    let mut ans = [false; 256];\n    macro_rules! exhaust {\n        ($op:expr) => {\n            for i in 0 .. 256 {\n                if a[i] {\n                    for j in 0 .. 256 {\n                        if b[j] {\n                            ans[$op(i, j)] = true;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    match op {\n        '+' => exhaust!(|i, j| (i + j) % 256),\n        '-' => exhaust!(|i, j| (i + 256 - j) % 256),\n        '*' => exhaust!(|i, j| (i * j) % 256),\n        '/' => {\n            if b[0] {\n                return None;\n            }\n            exhaust!(|i, j| i / j);\n        },\n        _ => panic!(),\n    }\n    Some(ans)\n}\n\nfn solve() {\n    let m = get();\n    let mut hm = HashMap::new();\n    for _ in 0 .. m {\n        let name = get_word();\n        let lb: usize = get();\n        let ub: usize = get();\n        hm.insert(name, (lb, ub));\n    }\n    let n = get();\n    let e: Vec<String> = (0 .. n).map(|_| get_word()).collect();\n    let mut stack = Vec::new();\n    let mut mess = false;\n    for e in &e {\n        match e.parse::<usize>() {\n            Ok(num) => {\n                let mut t = [false; 256];\n                t[num % 256] = true;\n                stack.push(t);\n            },\n            Err(_) => {\n                match hm.get(e) {\n                    Some(&(lb, ub)) => {\n                        let mut ans = [false; 256];\n                        for i in lb .. ub + 1 {\n                            ans[i] = true;\n                        }\n                        stack.push(ans);\n                    },\n                    None => {\n                        let b = stack.pop().unwrap();\n                        let a = stack.pop().unwrap();\n                        if let Some(res) = operate(&a, &b, e.chars().nth(0).unwrap()) {\n                            stack.push(res);\n                        } else {\n                            mess = true;\n                        }\n                    },\n                }\n            }\n        }\n    }\n    println!(\"{}\", if mess { \"error\" } else { \"correct\" });\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  }
]