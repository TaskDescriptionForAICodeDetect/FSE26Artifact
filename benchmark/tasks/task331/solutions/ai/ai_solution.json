[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n#define MAX_COMMANDS 1000\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef enum {\n    UP, RIGHT, DOWN, LEFT\n} Direction;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool simulate(int h, int w, char grid[MAX_SIZE][MAX_SIZE], Position start, Position master, \n              char commands[MAX_COMMANDS], int num_commands, bool reverse, bool flip) {\n    Position current = start;\n    Direction dir = UP;\n    int command_index;\n\n    for (command_index = 0; command_index < num_commands; ++command_index) {\n        int cmd_index = reverse ? (num_commands - 1 - command_index) : command_index;\n        char cmd = commands[cmd_index];\n\n        if (flip) {\n            if (cmd == 'L') cmd = 'R';\n            else if (cmd == 'R') cmd = 'L';\n        }\n\n        if (cmd == 'L') {\n            dir = (dir - 1 + 4) % 4;\n        } else if (cmd == 'R') {\n            dir = (dir + 1) % 4;\n        }\n\n        while (1) {\n            int nx = current.x + dx[dir];\n            int ny = current.y + dy[dir];\n\n            if (nx < 0 || nx >= h || ny < 0 || ny >= w || grid[nx][ny] == '#') {\n                break;\n            }\n\n            current.x = nx;\n            current.y = ny;\n\n            if (current.x == master.x && current.y == master.y) {\n                if (!reverse) {\n                    return simulate(h, w, grid, master, start, commands, num_commands, true, true);\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int h, w;\n    char grid[MAX_SIZE][MAX_SIZE];\n    Position kitchen, master;\n    int num_commands;\n    char commands[MAX_COMMANDS];\n\n    while (1) {\n        scanf(\"%d %d\", &h, &w);\n        if (h == 0 && w == 0) break;\n\n        for (int i = 0; i < h; ++i) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < w; ++j) {\n                if (grid[i][j] == 'K') {\n                    kitchen.x = i;\n                    kitchen.y = j;\n                } else if (grid[i][j] == 'M') {\n                    master.x = i;\n                    master.y = j;\n                }\n            }\n        }\n\n        scanf(\"%d\", &num_commands);\n        for (int i = 0; i < num_commands; ++i) {\n            scanf(\" %c\", &commands[i]);\n        }\n\n        if (simulate(h, w, grid, kitchen, master, commands, num_commands, false, false)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nenum Direction { UP, RIGHT, DOWN, LEFT };\n\npair<bool, bool> solve(int H, int W, vector<string>& house) {\n    int kx = -1, ky = -1, mx = -1, my = -1, dx = -1, dy = -1;\n    Direction dir;\n    \n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (house[i][j] == 'K') {\n                kx = i;\n                ky = j;\n            } else if (house[i][j] == 'M') {\n                mx = i;\n                my = j;\n            } else if (house[i][j] == 'D') {\n                dx = i;\n                dy = j;\n                if (i == 0) dir = DOWN;\n                else if (i == H - 1) dir = UP;\n                else if (j == 0) dir = RIGHT;\n                else if (j == W - 1) dir = LEFT;\n            }\n        }\n    }\n    \n    vector<pair<int, int>> path;\n    vector<Direction> dirs;\n    int x = dx, y = dy;\n    \n    while (x != mx || y != my) {\n        path.emplace_back(x, y);\n        dirs.push_back(dir);\n        \n        int nx = x, ny = y;\n        if (dir == UP) nx--;\n        else if (dir == DOWN) nx++;\n        else if (dir == LEFT) ny--;\n        else if (dir == RIGHT) ny++;\n        \n        if (nx < 0 || nx >= H || ny < 0 || ny >= W || house[nx][ny] == '#') {\n            break;\n        }\n        x = nx;\n        y = ny;\n    }\n    \n    if (x != mx || y != my) {\n        return make_pair(false, false);\n    }\n    path.emplace_back(x, y);\n    \n    bool canReachMaster = true;\n    for (int i = 0; i < path.size(); ++i) {\n        if (house[path[i].first][path[i].second] == '#') {\n            canReachMaster = false;\n            break;\n        }\n    }\n    if (!canReachMaster) {\n        return make_pair(false, false);\n    }\n    \n    vector<Direction> revDirs = dirs;\n    reverse(revDirs.begin(), revDirs.end());\n    for (auto& d : revDirs) {\n        if (d == UP) d = DOWN;\n        else if (d == DOWN) d = UP;\n        else if (d == LEFT) d = RIGHT;\n        else if (d == RIGHT) d = LEFT;\n    }\n    \n    x = mx;\n    y = my;\n    for (auto d : revDirs) {\n        dir = d;\n        int nx = x, ny = y;\n        if (dir == UP) nx--;\n        else if (dir == DOWN) nx++;\n        else if (dir == LEFT) ny--;\n        else if (dir == RIGHT) ny++;\n        \n        if (nx < 0 || nx >= H || ny < 0 || ny >= W || house[nx][ny] == '#') {\n            return make_pair(true, false);\n        }\n        x = nx;\n        y = ny;\n    }\n    \n    if (x != kx || y != ky) {\n        return make_pair(true, false);\n    }\n    \n    return make_pair(true, true);\n}\n\nint main() {\n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<string> house(H);\n        for (int i = 0; i < H; ++i) {\n            cin >> house[i];\n        }\n        \n        auto res = solve(H, W, house);\n        if (res.first && res.second) {\n            cout << \"YES\" << endl;\n        } else if (res.first) {\n            cout << \"NO\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class KarakuriDoll {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int W = scanner.nextInt();\n            int H = scanner.nextInt();\n            if (W == 0 && H == 0) break;\n            char[][] house = new char[H][W];\n            int startX = -1, startY = -1;\n            int masterX = -1, masterY = -1;\n            for (int i = 0; i < H; i++) {\n                String line = scanner.next();\n                for (int j = 0; j < W; j++) {\n                    house[i][j] = line.charAt(j);\n                    if (house[i][j] == 'K') {\n                        startX = j;\n                        startY = i;\n                    } else if (house[i][j] == 'M') {\n                        masterX = j;\n                        masterY = i;\n                    }\n                }\n            }\n            String commands = scanner.next();\n            boolean canReachMaster = simulate(house, startX, startY, masterX, masterY, commands, false);\n            boolean canReturn = false;\n            if (canReachMaster) {\n                String reversedCommands = reverseCommands(commands);\n                canReturn = simulate(house, masterX, masterY, startX, startY, reversedCommands, true);\n            }\n            System.out.println(canReachMaster && canReturn ? \"YES\" : \"NO\");\n        }\n        scanner.close();\n    }\n\n    private static boolean simulate(char[][] house, int startX, int startY, int targetX, int targetY, String commands, boolean reverse) {\n        int x = startX;\n        int y = startY;\n        int dir = 0; // 0: up, 1: right, 2: down, 3: left\n        for (int i = 0; i < commands.length(); i++) {\n            char cmd = commands.charAt(i);\n            if (cmd == 'L') {\n                dir = (dir - 1 + 4) % 4;\n            } else if (cmd == 'R') {\n                dir = (dir + 1) % 4;\n            }\n            while (true) {\n                int nx = x, ny = y;\n                if (dir == 0) ny--;\n                else if (dir == 1) nx++;\n                else if (dir == 2) ny++;\n                else if (dir == 3) nx--;\n                if (nx < 0 || ny < 0 || nx >= house[0].length || ny >= house.length || house[ny][nx] == '#') {\n                    break;\n                }\n                x = nx;\n                y = ny;\n                if (x == targetX && y == targetY) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private static String reverseCommands(String commands) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = commands.length() - 1; i >= 0; i--) {\n            char c = commands.charAt(i);\n            if (c == 'L') sb.append('R');\n            else if (c == 'R') sb.append('L');\n        }\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-05 21:08:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class KarakuriDoll {\n    public static void solve(Scanner scanner) {\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int sy = scanner.nextInt() - 1;\n        int sx = scanner.nextInt() - 1;\n        int gy = scanner.nextInt() - 1;\n        int gx = scanner.nextInt() - 1;\n        \n        char[][] maze = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            maze[i] = scanner.next().toCharArray();\n        }\n        \n        int K = scanner.nextInt();\n        char[] commands = scanner.next().toCharArray();\n        \n        boolean canReachMaster = simulatePath(maze, sy, sx, gy, gx, commands, false);\n        boolean canReturnToKitchen = simulatePath(maze, gy, gx, sy, sx, flipCommands(commands), true);\n        \n        System.out.println(canReachMaster && canReturnToKitchen ? \"Yes\" : \"No\");\n    }\n    \n    private static boolean simulatePath(char[][] maze, int startY, int startX, \n                                         int goalY, int goalX, char[] commands, boolean reversed) {\n        int H = maze.length;\n        int W = maze[0].length;\n        int y = startY;\n        int x = startX;\n        int dir = 0;\n        int[] dy = {-1, 0, 1, 0};\n        int[] dx = {0, 1, 0, -1};\n        \n        for (char cmd : commands) {\n            if (cmd == 'L') {\n                dir = (dir - 1 + 4) % 4;\n            } else if (cmd == 'R') {\n                dir = (dir + 1) % 4;\n            }\n            \n            while (true) {\n                int ny = y + dy[dir];\n                int nx = x + dx[dir];\n                \n                if (ny < 0 || ny >= H || nx < 0 || nx >= W || maze[ny][nx] == '#') {\n                    break;\n                }\n                \n                y = ny;\n                x = nx;\n                \n                if (y == goalY && x == goalX) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private static char[] flipCommands(char[] commands) {\n        char[] flipped = new char[commands.length];\n        for (int i = commands.length - 1; i >= 0; i--) {\n            flipped[commands.length - 1 - i] = commands[i] == 'L' ? 'R' : 'L';\n        }\n        return flipped;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n        \n        for (int t = 0; t < T; t++) {\n            solve(scanner);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:08:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_COMMANDS 100\n#define MAX_GRID 100\n\ntypedef struct {\n    int x, y;\n    int dx, dy;\n} Position;\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n\n    while (T--) {\n        int H, W;\n        scanf(\"%d %d\", &H, &W);\n\n        char grid[MAX_GRID][MAX_GRID];\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n\n        int num_commands;\n        scanf(\"%d\", &num_commands);\n\n        char commands[MAX_COMMANDS];\n        scanf(\"%s\", commands);\n\n        Position doll = {0, 0, 0, 0};\n        bool found_master = false;\n\n        // Find doll's starting position\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 'S') {\n                    doll.x = i;\n                    doll.y = j;\n                    break;\n                }\n            }\n        }\n\n        // Initial direction facing right\n        doll.dx = 0;\n        doll.dy = 1;\n\n        // Move to master's location\n        for (int i = 0; i < num_commands; i++) {\n            if (commands[i] == 'L') {\n                int temp = doll.dx;\n                doll.dx = -doll.dy;\n                doll.dy = temp;\n            } else {\n                int temp = doll.dx;\n                doll.dx = doll.dy;\n                doll.dy = -temp;\n            }\n\n            while (true) {\n                int nx = doll.x + doll.dx;\n                int ny = doll.y + doll.dy;\n\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == '#') {\n                    break;\n                }\n\n                doll.x = nx;\n                doll.y = ny;\n\n                if (grid[doll.x][doll.y] == 'M') {\n                    found_master = true;\n                    break;\n                }\n            }\n\n            if (found_master) break;\n        }\n\n        // Reverse path back to kitchen\n        if (found_master) {\n            bool returned = true;\n            for (int i = num_commands - 1; i >= 0; i--) {\n                if (commands[i] == 'L') {\n                    int temp = doll.dx;\n                    doll.dx = doll.dy;\n                    doll.dy = -temp;\n                } else {\n                    int temp = doll.dx;\n                    doll.dx = -doll.dy;\n                    doll.dy = temp;\n                }\n\n                while (true) {\n                    int nx = doll.x + doll.dx;\n                    int ny = doll.y + doll.dy;\n\n                    if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == '#') {\n                        break;\n                    }\n\n                    doll.x = nx;\n                    doll.y = ny;\n\n                    if (grid[doll.x][doll.y] == 'S') {\n                        break;\n                    }\n                }\n            }\n\n            printf(\"%s\\n\", returned ? \"YES\" : \"NO\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Position {\n    int x, y;\n    int direction; // 0: North, 1: East, 2: South, 3: West\n};\n\nbool canReachDestination(vector<vector<char>>& house, Position& start, Position& master, vector<char>& commands) {\n    Position current = start;\n    vector<char> path;\n\n    for (char cmd : commands) {\n        if (cmd == 'L') {\n            current.direction = (current.direction - 1 + 4) % 4;\n        } else if (cmd == 'R') {\n            current.direction = (current.direction + 1) % 4;\n        }\n\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, 1, 0, -1};\n\n        while (true) {\n            int nx = current.x + dx[current.direction];\n            int ny = current.y + dy[current.direction];\n\n            if (nx < 0 || nx >= house.size() || ny < 0 || ny >= house[0].size() || house[nx][ny] == '#') {\n                break;\n            }\n\n            current.x = nx;\n            current.y = ny;\n            path.push_back(current.direction);\n\n            if (current.x == master.x && current.y == master.y) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nbool canReturnToKitchen(vector<vector<char>>& house, Position& start, Position& master, vector<char>& commands) {\n    Position current = master;\n    vector<char> returnPath;\n\n    for (int i = commands.size() - 1; i >= 0; --i) {\n        char cmd = commands[i];\n        if (cmd == 'L') {\n            current.direction = (current.direction + 1) % 4;\n        } else if (cmd == 'R') {\n            current.direction = (current.direction - 1 + 4) % 4;\n        }\n\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, 1, 0, -1};\n\n        while (true) {\n            int nx = current.x + dx[current.direction];\n            int ny = current.y + dy[current.direction];\n\n            if (nx < 0 || nx >= house.size() || ny < 0 || ny >= house[0].size() || house[nx][ny] == '#') {\n                break;\n            }\n\n            current.x = nx;\n            current.y = ny;\n            returnPath.push_back(current.direction);\n\n            if (current.x == start.x && current.y == start.y) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int T;\n    cin >> T;\n\n    while (T--) {\n        int H, W;\n        cin >> H >> W;\n\n        vector<vector<char>> house(H, vector<char>(W));\n        Position start, master;\n\n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                cin >> house[i][j];\n                if (house[i][j] == 'S') {\n                    start = {i, j, 0};\n                }\n                if (house[i][j] == 'M') {\n                    master = {i, j, 0};\n                }\n            }\n        }\n\n        int K;\n        cin >> K;\n        vector<char> commands(K);\n        for (int i = 0; i < K; ++i) {\n            cin >> commands[i];\n        }\n\n        bool canReachMaster = canReachDestination(house, start, master, commands);\n        bool canReturn = canReturnToKitchen(house, start, master, commands);\n\n        if (canReachMaster && canReturn) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Doll:\n    def __init__(self, house, start, master, commands):\n        self.house = house\n        self.start = start\n        self.master = master\n        self.commands = commands\n        self.direction = (0, 1)  # Start facing 'right'\n        self.directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up\n        self.position = self.start\n    \n    def is_within_bounds(self, position):\n        r, c = position\n        if 0 <= r < len(self.house) and 0 <= c < len(self.house[0]):\n            return self.house[r][c] != '#'\n        return False\n    \n    def move_until_wall(self):\n        r, c = self.position\n        dr, dc = self.direction\n        while self.is_within_bounds((r + dr, c + dc)):\n            r += dr\n            c += dc\n        self.position = (r, c)\n    \n    def apply_commands(self, forward=True):\n        cmds = self.commands if forward else reversed(self.commands)\n        for cmd in cmds:\n            if cmd == 'turn left':\n                idx = self.directions.index(self.direction)\n                idx = (idx - 1) % 4 if forward else (idx + 1) % 4\n                self.direction = self.directions[idx]\n            elif cmd == 'turn right':\n                idx = self.directions.index(self.direction)\n                idx = (idx + 1) % 4 if forward else (idx - 1) % 4\n                self.direction = self.directions[idx]\n            self.move_until_wall()\n    \n    def move_to_master(self):\n        self.position = self.start\n        self.direction = (0, 1)\n        self.apply_commands(forward=True)\n        return self.position == self.master\n    \n    def move_to_kitchen(self):\n        return_position = self.master\n        self.position = return_position\n        self.direction = (0, -1)  # Start facing 'left'\n        self.apply_commands(forward=False)\n        return self.position == self.start\n\n\ndef process_house_layouts(house_layouts):\n    results = []\n    for house, start, master, commands in house_layouts:\n        doll = Doll(house, start, master, commands)\n        reach_master = doll.move_to_master()\n        reach_kitchen = doll.move_to_kitchen() if reach_master else False\n        results.append((reach_master, reach_kitchen))\n    return results\n\n\n# Example use case\nhouse_layouts = [\n    (\n        [\n            ['.', '.', '.', '#', '.', '.'],\n            ['.', '#', '.', '#', '.', '#'],\n            ['.', '#', '.', '.', '.', '.'],\n            ['#', '.', '#', '.', '#', '.'],\n            ['.', '.', '.', '#', '.', '.']\n        ],\n        (0, 0),\n        (2, 2),\n        ['turn right', 'turn right', 'turn left', 'turn left']\n    )\n]\n\nresults = process_house_layouts(house_layouts)\nfor can_reach_master, can_return_kitchen in results:\n    print(f\"Can reach master: {can_reach_master}, Can return to kitchen: {can_return_kitchen}\")",
    "timestamp": "2025-08-13 05:03:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass KarakuriDoll {\n    // Directions representation: 0 = North, 1 = East, 2 = South, 3 = West\n    private static final int[] dx = { -1, 0, 1, 0 };\n    private static final int[] dy = { 0, 1, 0, -1 };\n\n    public static boolean canReachMasterAndReturn(char[][] house, int[] kitchen, int[] master, List<String> commands) {\n        if (!canReach(house, kitchen, master, commands)) {\n            return false;\n        }\n        // Reverse commands for returning to kitchen\n        Collections.reverse(commands);\n        for (int i = 0; i < commands.size(); i++) {\n            commands.set(i, commands.get(i).equals(\"turn left\") ? \"turn right\" : \"turn left\");\n        }\n        return canReach(house, master, kitchen, commands);\n    }\n\n    private static boolean canReach(char[][] house, int[] start, int[] end, List<String> commands) {\n        int x = start[0], y = start[1];\n        int direction = 0; // Starting facing North\n\n        for (String command : commands) {\n            if (command.equals(\"turn left\")) {\n                direction = (direction + 3) % 4;\n            } else if (command.equals(\"turn right\")) {\n                direction = (direction + 1) % 4;\n            }\n\n            while (true) {\n                int newX = x + dx[direction];\n                int newY = y + dy[direction];\n                if (isWall(house, newX, newY)) break;\n                x = newX;\n                y = newY;\n                if (x == end[0] && y == end[1]) return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isWall(char[][] house, int x, int y) {\n        return x < 0 || y < 0 || x >= house.length || y >= house[0].length || house[x][y] == '#';\n    }\n\n    public static void main(String[] args) {\n        char[][] house = {\n                {' ', ' ', ' ', '#', ' '},\n                {'#', ' ', '#', '#', ' '},\n                {' ', ' ', ' ', ' ', ' '},\n                {' ', '#', '#', ' ', ' '},\n                {' ', ' ', ' ', ' ', '#'}\n        };\n        int[] kitchen = {0, 0};\n        int[] master = {4, 4};\n        List<String> commands = Arrays.asList(\"turn right\", \"turn right\", \"turn left\");\n\n        System.out.println(canReachMasterAndReturn(house, kitchen, master, commands)); // Expected output: true / false\n    }\n}",
    "timestamp": "2025-08-13 05:04:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_PATH 1000\n#define MAX_GRID 50\n\ntypedef struct {\n    int x, y;\n    char dir; // 'N', 'E', 'S', 'W' for north, east, south, west\n} Position;\n\n// Define direction movements\nconst int dx[] = {0, 1, 0, -1}; // N, E, S, W\nconst int dy[] = {-1, 0, 1, 0}; // N, E, S, W\n\n// Convert direction to index\nint dir_to_index(char dir) {\n    switch (dir) {\n        case 'N': return 0;\n        case 'E': return 1;\n        case 'S': return 2;\n        case 'W': return 3;\n        default: return -1;\n    }\n}\n\nPosition execute_commands(Position pos, char *commands, char house[MAX_GRID][MAX_GRID]) {\n    int dir_index = dir_to_index(pos.dir);\n    int len = strlen(commands);\n\n    for (int i = 0; i < len; i++) {\n        if (commands[i] == 'L') {\n            dir_index = (dir_index + 3) % 4; // turn left\n        } else if (commands[i] == 'R') {\n            dir_index = (dir_index + 1) % 4; // turn right\n        }\n\n        // Move until a wall is hit\n        while (1) {\n            int new_x = pos.x + dx[dir_index];\n            int new_y = pos.y + dy[dir_index];\n            if (new_x < 0 || new_y < 0 || new_x >= MAX_GRID || new_y >= MAX_GRID || house[new_y][new_x] == '#') {\n                break; // Wall hit\n            }\n            pos.x = new_x;\n            pos.y = new_y;\n        }\n    }\n    pos.dir = \"NESW\"[dir_index];\n    return pos;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        int n, m;\n        // Read house dimensions\n        scanf(\"%d %d\", &n, &m);\n\n        char house[MAX_GRID][MAX_GRID];\n        Position kitchen, master;\n        \n        // Read house layout\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", house[i]);\n            for (int j = 0; j < m; j++) {\n                if (house[i][j] == 'K') {\n                    kitchen = (Position){j, i, 'E'};\n                    house[i][j] = '.';\n                } else if (house[i][j] == 'M') {\n                    master = (Position){j, i, 'E'};\n                    house[i][j] = '.';\n                }\n            }\n        }\n\n        char commands[MAX_PATH];\n        // Read movement commands\n        scanf(\"%s\", commands);\n\n        // Execute commands to reach master\n        Position to_master = execute_commands(kitchen, commands, house);\n        \n        // Reverse and flip commands for return\n        int len = strlen(commands);\n        char reverse_commands[MAX_PATH];\n        for (int i = 0; i < len; i++) {\n            reverse_commands[i] = (commands[len - 1 - i] == 'L') ? 'R' : 'L';\n        }\n        reverse_commands[len] = '\\0';\n\n        // Execute commands to return to kitchen\n        Position back_to_kitchen = execute_commands(master, reverse_commands, house);\n\n        int can_reach_master = (to_master.x == master.x && to_master.y == master.y);\n        int can_return_kitchen = (back_to_kitchen.x == kitchen.x && back_to_kitchen.y == kitchen.y);\n\n        printf(\"%s\\n\", (can_reach_master && can_return_kitchen) ? \"YES\" : \"NO\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 05:04:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_reach_master_and_return(grid, commands):\n    def is_valid_move(x, y):\n        return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] != '#'\n\n    def move(x, y, direction):\n        dx = [-1, 0, 1, 0]\n        dy = [0, 1, 0, -1]\n        while is_valid_move(x + dx[direction], y + dy[direction]):\n            x += dx[direction]\n            y += dy[direction]\n        return x, y\n\n    def find_start_and_master():\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 'S':\n                    start = (i, j)\n                if grid[i][j] == 'M':\n                    master = (i, j)\n        return start, master\n\n    start, master = find_start_and_master()\n    x, y = start[0], start[1]\n    direction = 0  # 0: North, 1: East, 2: South, 3: West\n\n    path = []\n    for cmd in commands:\n        if cmd == 'L':\n            direction = (direction - 1) % 4\n        elif cmd == 'R':\n            direction = (direction + 1) % 4\n        \n        new_x, new_y = move(x, y, direction)\n        path.append((new_x, new_y, direction))\n        x, y = new_x, new_y\n\n    if (x, y) != master:\n        return False\n\n    # Return journey\n    x, y = master[0], master[1]\n    direction = path[-1][2]\n    \n    for cmd in reversed(commands):\n        if cmd == 'L':\n            direction = (direction + 1) % 4\n        elif cmd == 'R':\n            direction = (direction - 1) % 4\n        \n        new_x, new_y = move(x, y, direction)\n        x, y = new_x, new_y\n\n    return x == start[0] and y == start[1]\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        R, C = map(int, input().split())\n        grid = [list(input().strip()) for _ in range(R)]\n        commands = input().strip()\n        \n        result = can_reach_master_and_return(grid, commands)\n        print(\"Yes\" if result else \"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:04:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    T = int(data[idx])\n    idx += 1\n    for _ in range(T):\n        H, W = map(int, data[idx:idx+2])\n        idx +=2\n        grid = []\n        for _ in range(H):\n            grid.append(data[idx])\n            idx +=1\n        N = int(data[idx])\n        idx +=1\n        commands = data[idx:idx+N]\n        idx +=N\n        \n        # Find initial position (kitchen is 'K')\n        k_pos = None\n        m_pos = None\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == 'K':\n                    k_pos = (i, j)\n                elif grid[i][j] == 'M':\n                    m_pos = (i, j)\n        \n        # Directions: up, right, down, left (clockwise)\n        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n        current_dir = 0  # starts facing up\n        x, y = k_pos\n        \n        # Simulate forward path to master\n        reached_master = False\n        path = []\n        for cmd in commands:\n            if cmd == 'left':\n                current_dir = (current_dir - 1) % 4\n            elif cmd == 'right':\n                current_dir = (current_dir + 1) % 4\n            path.append(current_dir)\n            dx, dy = directions[current_dir]\n            while True:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '#':\n                    x, y = nx, ny\n                    if (x, y) == m_pos:\n                        reached_master = True\n                        break\n                else:\n                    break\n            if reached_master:\n                break\n        \n        if not reached_master:\n            print(\"unreachable\")\n            continue\n        \n        # Simulate return path to kitchen\n        can_return = False\n        # Reverse the commands and flip directions\n        reversed_commands = commands[::-1]\n        # Flip left and right in reversed commands\n        flipped_commands = []\n        for cmd in reversed_commands:\n            if cmd == 'left':\n                flipped_commands.append('right')\n            elif cmd == 'right':\n                flipped_commands.append('left')\n        \n        current_dir = path[-1]  # direction when reached master\n        x, y = m_pos\n        reached_kitchen = False\n        for cmd in flipped_commands:\n            if cmd == 'left':\n                current_dir = (current_dir - 1) % 4\n            elif cmd == 'right':\n                current_dir = (current_dir + 1) % 4\n            dx, dy = directions[current_dir]\n            while True:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] != '#':\n                    x, y = nx, ny\n                    if (x, y) == k_pos:\n                        reached_kitchen = True\n                        break\n                else:\n                    break\n            if reached_kitchen:\n                break\n        \n        if reached_kitchen:\n            print(\"reachable\")\n        else:\n            print(\"unreachable\")\n\nsolve()",
    "timestamp": "2025-08-13 05:05:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nenum Direction { NORTH, EAST, SOUTH, WEST };\n\n// Function to turn the direction left\nDirection turnLeft(Direction dir) {\n    return static_cast<Direction>((dir + 3) % 4);\n}\n\n// Function to turn the direction right\nDirection turnRight(Direction dir) {\n    return static_cast<Direction>((dir + 1) % 4);\n}\n\n// Function to move the doll in the current direction until it hits a wall\npair<int, int> moveUntilWall(vector<vector<char>> &house, pair<int, int> position, Direction dir) {\n    pair<int, int> newPos = position;\n    while (true) {\n        int x = newPos.first;\n        int y = newPos.second;\n        if (dir == NORTH) x--;\n        else if (dir == EAST) y++;\n        else if (dir == SOUTH) x++;\n        else if (dir == WEST) y--;\n\n        if (x < 0 || x >= house.size() || y < 0 || y >= house[0].size() || house[x][y] == '#') {\n            break;\n        }\n        newPos = {x, y};\n    }\n    return newPos;\n}\n\n// Function to execute commands and compute the final position\npair<int, int> executeCommands(vector<vector<char>> &house, pair<int, int> start, Direction startDir, const vector<string> &commands) {\n    pair<int, int> position = start;\n    Direction dir = startDir;\n\n    for (const string &command : commands) {\n        position = moveUntilWall(house, position, dir);\n        if (command == \"turn left\") {\n            dir = turnLeft(dir);\n        } else if (command == \"turn right\") {\n            dir = turnRight(dir);\n        }\n    }\n\n    return position;\n}\n\n// Function to evaluate both forward and return journey\nbool canReachAndReturn(vector<vector<char>> &house, pair<int, int> kitchen, pair<int, int> master, const vector<string> &commands) {\n    pair<int, int> finalPosition = executeCommands(house, kitchen, NORTH, commands);\n    if (finalPosition != master) {\n        return false;\n    }\n\n    vector<string> reversedCommands(commands.rbegin(), commands.rend());\n    for (string &cmd : reversedCommands) {\n        if (cmd == \"turn left\") cmd = \"turn right\";\n        else if (cmd == \"turn right\") cmd = \"turn left\";\n    }\n\n    pair<int, int> returnPosition = executeCommands(house, master, SOUTH, reversedCommands);\n    return returnPosition == kitchen;\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m) {\n        vector<vector<char>> house(n, vector<char>(m));\n        pair<int, int> kitchen, master;\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                cin >> house[i][j];\n                if (house[i][j] == 'K') {\n                    kitchen = {i, j};\n                } else if (house[i][j] == 'M') {\n                    master = {i, j};\n                }\n            }\n        }\n\n        int commandCount;\n        cin >> commandCount;\n        vector<string> commands(commandCount);\n        \n        cin.ignore(); // Ignore the newline character after the number of commands\n        for (int i = 0; i < commandCount; ++i) {\n            getline(cin, commands[i]);\n        }\n\n        if (canReachAndReturn(house, kitchen, master, commands)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:49"
  }
]