[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\n#define track() cout<<\"######\"<<endl;\n\nint h,w;\nstring grid[16];\nbool used[16][64][4][16][64][4];\nbool flag1,flag2;\nint sy,sx,sd,ty,tx,td;\n\nint up(int d){return ((d+0)%4);}\nint left(int d){return ((d+1)%4);}\nint down(int d){return ((d+2)%4);}\nint right(int d){return ((d+3)%4);}\n\nvector<pair<pii,pii> > steps;\n\nvoid rec(int ky,int kx,int kd,int my,int mx,int md){\n\n  if(used[ky][kx][kd][my][mx][md])return;\n  used[ky][kx][kd][my][mx][md] = true;\n\n  int nky=ky,nkx=kx;\n  while(1){\n    if(grid[nky+dy[kd]][nkx+dx[kd]]=='#')break;\n    nky = nky + dy[kd];\n    nkx = nkx + dx[kd];\n  }\n  if(my==0){\n    if(nky==ty && nkx==tx)flag1=true;\n    rec(nky,nkx,left(kd),0,0,0);\n    rec(nky,nkx,right(kd),0,0,0);\n    return;\n  }\n\n  int nmy=my,nmx=mx; \n  while(1){\n    if(grid[nmy+dy[ left(md)  ]][nmx+dx[ left(md)  ]]=='#' &&\n       grid[nmy+dy[ right(md) ]][nmx+dx[ right(md) ]]=='.' ){\n      rec(nky,nkx,right(kd),nmy,nmx,right(md));\n    }\n    if(grid[nmy+dy[ right(md) ]][nmx+dx[ right(md) ]]=='#' &&\n       grid[nmy+dy[ left(md)  ]][nmx+dx[ left(md)  ]]=='.' ){\n      rec(nky,nkx,left(kd),nmy,nmx,left(md));\n    }  \n\n    if(grid[nmy+dy[ down(md) ]][nmx+dx[ down(md) ]]=='#'){ \n      if(grid[nmy+dy[ right(md) ]][nmx+dx[ right(md) ]]=='#' &&\n         grid[nmy+dy[ left(md)  ]][nmx+dx[ left(md)  ]]=='#' ){\n        rec(nky,nkx,right(kd),nmy,nmx,right(md));\n        rec(nky,nkx,left(kd),nmy,nmx,left(md));\n      }\n    }\n    \n    if(grid[nmy+dy[ md ]][nmx+dx[ md ]]=='#'){ \n      if(grid[nmy+dy[ right(md) ]][nmx+dx[ right(md) ]]=='#' &&\n         grid[nmy+dy[ left(md)  ]][nmx+dx[ left(md)  ]]=='#' ){\n        rec(nky,nkx,right(kd),nmy,nmx,right(md));\n        rec(nky,nkx,left(kd),nmy,nmx,left(md));\n      }\n      break;\n    }\n    nmy = nmy + dy[md];\n    nmx = nmx + dx[md];\n  }\n  if(nky==ty && nkx==tx && nmy==ty && nmx==tx && md==(td+2)%4)flag2 = true;\n}\n\nstring solve(){\n  memset(used,0,sizeof(used));\n  flag1 = false;\n  flag2 = false;\n  FOR(i,0,h){\n    FOR(j,0,w){\n      if(grid[i][j]=='K'){\n        sy = i;\n        sx = j;\n        grid[i][j]='.';\n        FOR(k,0,4)\n          if(grid[sy+dy[k]][sx+dx[k]]=='.')sd = k;\n      }\n      if(grid[i][j]=='M'){\n        ty = i;\n        tx = j;\n        grid[i][j]='.';\n        FOR(k,0,4)\n          if(grid[ty+dy[k]][tx+dx[k]]=='.')td = k;\n      }\n    }\n  }\n  FOR(i,0,4)rec(sy,sx,sd,sy,sx,i);\n  if(flag2)return \"He can accomplish his mission.\";\n  rec(sy,sx,sd,0,0,0);\n  if(flag1)return \"He cannot return to the kitchen.\";\n  return \"He cannot bring tea to his master.\";\n}\n\nint main()\n{\n  while(cin>>w>>h && w){\n    FOR(i,0,h)cin>>grid[i];\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nbool visit2[16][64][4][16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nvoid rec2(int x1, int y1, int dir1, int x2, int y2, int dir2)\n{\n\tif (!visit2[y1][x1][dir1][y2][x2][dir2])\n\t{\n\t\tvisit2[y1][x1][dir1][y2][x2][dir2] = true;\n\n\t\twhile (M[y1 + dy[dir1]][x1 + dx[dir1]] != '#')\n\t\t{\n\t\t\tx1 += dx[dir1];\n\t\t\ty1 += dy[dir1];\n\t\t}\n\n\t\twhile (M[y2 + dy[dir2]][x2 + dx[dir2]] != '#')\n\t\t{\n\t\t\tx2 += dx[dir2];\n\t\t\ty2 += dy[dir2];\n\t\t}\n\n\t\trec2(x1, y1, (dir1 + 3) % 4, x2, y2, (dir2 + 1) % 4);\n\t\trec2(x1, y1, (dir1 + 1) % 4, x2, y2, (dir2 + 3) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, sd, mx, my, md;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\n\t\t\t\t\tfor (int d = 0; d < 4; d++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (M[i + dy[d]][j + dx[d]] != '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsd = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\n\t\t\t\t\tfor (int d = 0; d < 4; d++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (M[i + dy[d]][j + dx[d]] != '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmd = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, sd);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec2(sx, sy, sd, mx, my, md);\n\n\t\t\tok = false;\n\t\t\t\n\t\t\tfor (int dir1 = 0; dir1 < 4; dir1++)\n\t\t\t{\n\t\t\t\tfor (int dir2 = 0; dir2 < 4; dir2++)\n\t\t\t\t{\n\t\t\t\t\tok = ok || visit2[mx][my][dir1][sx][sy][dir2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <string>\n#include <iostream>\n#include <cstdio>\n#include <stack>\nusing namespace std;\n\nint gen;\nint vis[1 << 24];\nint dpt[1<<24];\nchar ch[1<<24];\nqueue<int> q;\ninline void addq(int d2, int d1, int y2, int x2, int y1, int x1){\n\tint st = (d2 & 3) << 22 | (d1 & 3) << 20 | y2 << 16 | x2 << 10 |\n\t         y1 << 6 | x1;\n\tif(vis[st] != gen){\n\t\tvis[st] = gen;\n\t\tq.push(st);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tint dy[] = {-1, 0, 1, 0};\n\tint dx[] = {0, -1, 0, 1};\n\tint h, w;\n\twhile(cin >> w >> h, h){\n\t\t++gen;\n\t\tvector<string> v(h);\n\t\tint kd = -1, ky = -1, kx = -1, md = -1, my = -1, mx = -1;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(v[i][j] == 'K'){\n\t\t\t\t\tfor(kd = 0; v[i + dy[kd]][j + dx[kd]] == '#'; ++kd);\n\t\t\t\t\tky = i;\n\t\t\t\t\tkx = j;\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'M'){\n\t\t\t\t\tfor(md = 0; v[i + dy[md]][j + dx[md]] == '#'; ++md);\n\t\t\t\t\tmy = i;\n\t\t\t\t\tmx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint d2 = kd, d1 = kd, y2 = ky, x2 = kx, y1 = ky, x1 = kx;\n\t\taddq(d2 + 1, d1, y2, x2, y1, x1);\n\t\taddq(d2 + 3, d1, y2, x2, y1, x1);\n\t\twhile(v[y2][x2] != '#'){\n\t\t\taddq(d2, d1, y2, x2, y1, x1);\n\t\t\ty2 += dy[d2];\n\t\t\tx2 += dx[d2];\n\t\t}\n\t\taddq(0, d1, 0, 0, y1, x1);\n\t\tint ans = 0;\n\t\twhile(!q.empty()){\n\t\t\tint st = q.front();\n\t\t\tq.pop();\n\n\t\t\td2 = st >> 22 & 3;\n\t\t\td1 = st >> 20 & 3;\n\t\t\ty2 = st >> 16 & 15;\n\t\t\tx2 = st >> 10 & 63;\n\t\t\ty1 = st >> 6 & 15;\n\t\t\tx1 = st & 63;\n\n\t\t\twhile(v[y1 + dy[d1]][x1 + dx[d1]] != '#'){\n\t\t\t\ty1 += dy[d1];\n\t\t\t\tx1 += dx[d1];\n\t\t\t}\n\n\t\t\tif(y1 == my && x1 == mx){\n\t\t\t\tans |= 1;\n\t\t\t\tif(y2 == my && x2 == mx && (d2 + 1 & 3) == md){\n\t\t\t\t\tans = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y2){\n\t\t\t\tif(v[y2 + dy[d2 + 1 & 3]][x2 + dx[d2 + 1 & 3]] == '#'){\n\t\t\t\t\tint ny2 = y2, nx2 = x2;\n\t\t\t\t\twhile(v[ny2][nx2] != '#'){\n\t\t\t\t\t\taddq(d2 + 3, d1 + 3, ny2, nx2, y1, x1);\n\t\t\t\t\t\tny2 += dy[d2 + 3 & 3];\n\t\t\t\t\t\tnx2 += dx[d2 + 3 & 3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(v[y2 + dy[d2 + 3 & 3]][x2 + dx[d2 + 3 & 3]] == '#'){\n\t\t\t\t\tint ny2 = y2, nx2 = x2;\n\t\t\t\t\twhile(v[ny2][nx2] != '#'){\n\t\t\t\t\t\taddq(d2 + 1, d1 + 1, ny2, nx2, y1, x1);\n\t\t\t\t\t\tny2 += dy[d2 + 1 & 3];\n\t\t\t\t\t\tnx2 += dx[d2 + 1 & 3];\n\t\t\t\t\t\tif(y1 == my && x1 == mx && ny2 == my && nx2 == mx && (d2 + 3 & 3) == md){\n\t\t\t\t\t\t\tans = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddq(0, d1 + 1, 0, 0, y1, x1);\n\t\t\t\taddq(0, d1 + 3, 0, 0, y1, x1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ans == 3){\n\t\t\tputs(\"He can accomplish his mission.\");\n\t\t}\n\t\telse if(ans == 1){\n\t\t\tputs(\"He cannot return to the kitchen.\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"He cannot bring tea to his master.\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') y += dy[dir], x += dx[dir];\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = 1;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int x, int y) {\n\trep(i, 4) {\n\t\tif (in[y + dy[i]][x + dx[i]] == ',')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h!=0&&w!=0) {\n\t\trep(i, h) cin >> in[i];\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\n// direction\n// 0: N, 1: E, 2:S, 3:W\nconstexpr int dx[4] = {0, 1, 0, -1};\nconstexpr int dy[4] = {-1, 0, 1, 0};\nconstexpr int dd[2] = {1, 3}; // turn right, left\n\nbool reach1[16][64][4]; // only go to kitchen\nbool reach[16][64][4][16][64][4];\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        memset(reach1, false, sizeof(reach1));\n        memset(reach, false, sizeof(reach));\n        vector<string> v(h);\n        for(auto& s : v) cin >> s;\n\n        int sy = -1, sx = -1, sd = -1, gy = -1, gx = -1;\n        for(int i = 0; i < h; ++i) {\n            for(int j = 0; j < w; ++j) {\n                if(v[i][j] == '#') continue;\n                if(v[i][j] == 'K') {\n                    sy = i, sx = j;\n                    for(int d = 0; d < 4; ++d) {\n                        if(v[sy + dy[d]][sx + dx[d]] == '#') continue;\n                        sd = d;\n                    }\n                }\n                if(v[i][j] == 'M') {\n                    gy = i, gx = j;\n                }\n            }\n        }\n\n        function<bool(int, int, int)> go_to_kitchen = [&] (int y, int x, int d) {\n            if(reach1[y][x][d]) return false;\n            reach1[y][x][d] = true;\n            if(y == gy && x == gx) return true;\n            bool res = false;\n            if(v[y + dy[d]][x + dx[d]] != '#') {\n                res = go_to_kitchen(y + dy[d], x + dx[d], d);\n            } else {\n                res = go_to_kitchen(y, x, (d + 1) % 4);\n                res |= go_to_kitchen(y, x, (d + 3) % 4);\n            }\n            return res;\n        };\n        function<bool(int, int, int, int, int, int)> dfs = [&] (int y1, int x1, int d1, int y2, int x2, int d2) {\n            if(reach[y1][x1][d1][y2][x2][d2]) return false;\n            //cout << y1 << ' ' << x1 << ' ' << d1 << ' ' << y2 << ' ' << x2 << ' ' << d2 << endl;\n            reach[y1][x1][d1][y2][x2][d2] = true;\n            if(gy == y2 && gx == x2 && gy == y1 && gx == x1\n               && v[y2 - dy[d2]][x2 - dx[d2]] != '#' && v[y1 + dy[d1]][x1 + dx[d1]] == '#') {\n                return true;\n            }\n            bool res = false;\n            if(v[y1 + dy[d1]][x1 + dx[d1]] != '#') {\n                res = dfs(y1 + dy[d1], x1 + dx[d1], d1, y2, x2, d2);\n            } else { // can turn\n                for(int i = 0; i < 2; ++i) {\n                    const int nd1 = (d1 + dd[i]) % 4, nd2 = (d2 + dd[i]) % 4;\n                    if(v[y2 - dy[nd2]][x2 - dx[nd2]] != '#') continue; // front must be wall\n                    res |= dfs(y1, x1, nd1, y2, x2, nd2);\n                }\n            }\n            if(v[y2 + dy[d2]][x2 + dx[d2]] != '#') {\n                res |= dfs(y1, x1, d1, y2 + dy[d2], x2 + dx[d2], d2);\n            }\n            return res;\n        };\n\n        bool ac = false;\n        for(int d = 0; d < 4; ++d) {\n            ac |= dfs(sy, sx, sd, sy, sx, d);\n        }\n\n        if(ac) {\n            cout << \"He can accomplish his mission.\" << endl;\n        } else if(go_to_kitchen(sy, sx, sd)) {\n            cout << \"He cannot return to the kitchen.\" << endl;\n        } else {\n            cout << \"He cannot bring tea to his master.\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct state{\n\tint i,j,k; // 行きの y 座標, x 座標, 向き\n};\n\nstruct state2{\n\tint i,j,k,y,x,d; // 行きの y 座標, x 座標, 向き, 帰りの y 座標, x 座標, 向き\n};\n\nint h,w;\nchar B[16][65];\n\nvoid go_straight(int i,int j,int k,int &i2,int &j2){\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j;\n}\n\nvoid turn_left(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+1)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nvoid turn_right(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+3)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='K') sx=j, sy=i, B[i][j]='.';\n\t\t\tif(B[i][j]=='M') gx=j, gy=i, B[i][j]='.';\n\t\t}\n\t\tint gk;\n\t\trep(k,4) if(B[gy+dy[k]][gx+dx[k]]=='.') gk=k;\n\n\t\tbool ok1=false;\n\t\t{\n\t\t\tstatic bool vis[16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) vis[i][j][k]=false;\n\n\t\t\tqueue<state> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\tvis[yy][xx][k]=true;\n\t\t\t\t\tQ.push((state){yy,xx,k});\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k;\n\n\t\t\t\tif(i==gy && j==gx){ ok1=true; break; }\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok2=false;\n\t\t{\n\t\t\tstatic bool vis[16][64][4][16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) rep(y,h) rep(x,w) rep(d,4) vis[i][j][k][y][x][d]=false;\n\n\t\t\tqueue<state2> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\trep(kk,4) if(kk!=k) {\n\t\t\t\t\t\tvis[yy][xx][k][sy][sx][kk]=true;\n\t\t\t\t\t\tQ.push((state2){yy,xx,k,sy,sx,kk});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate2 S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k,y=S.y,x=S.x,d=S.d;\n\n\t\t\t\tif(i==gy && j==gx){\n\t\t\t\t\tint yy,xx;\n\t\t\t\t\tgo_straight(gy,gx,gk,yy,xx);\n\t\t\t\t\tif(y==yy && x==xx && d==gk){ ok2=true; break; }\n\t\t\t\t}\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\trep(y2,h) rep(x2,w) rep(d2,4) if(B[y2][x2]=='.') {\n\t\t\t\t\tint yy,xx,dd;\n\t\t\t\t\tturn_right(y2,x2,d2,yy,xx,dd);\n\t\t\t\t\tif(yy==y && xx==x && dd==d && !vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\trep(y2,h) rep(x2,w) rep(d2,4) if(B[y2][x2]=='.') {\n\t\t\t\t\tint yy,xx,dd;\n\t\t\t\t\tturn_left(y2,x2,d2,yy,xx,dd);\n\t\t\t\t\tif(yy==y && xx==x && dd==d && !vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif     (ok2) puts(\"He can accomplish his mission.\");\n\t\telse if(ok1) puts(\"He cannot return to the kitchen.\");\n\t\telse         puts(\"He cannot bring tea to his master.\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_M, wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_M = wall_dir_at_K = vector< int >();\n\t\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\tif (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\tif (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\tfor_(d,0,4) {\n\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\tif (home_map[y][x] == 'M') wall_dir_at_M.push_back(d);\n\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\tgoal_dir = d;\n\t\t\t\t} else {\n\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\tstart_dir = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nstruct State {\n\tint id, dir;\n\tint rev_id, rev_dir;\n};\n\nbool vis[1024][4][1024][4];\n\nbool canReachMaster() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tque.push(State{start_id, start_dir});\n\tvis[start_id][start_dir][0][0] = true;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c);\n\t\t\tif (!vis[nxt_id][nxt_dir][0][0]) {\n\t\t\t\tvis[nxt_id][nxt_dir][0][0] = true;\n\t\t\t\tque.push(State{nxt_id, nxt_dir});\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = false;\n\tfor (int f : wall_dir_at_M) flag |= vis[1023][f][0][0];\n\treturn flag;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(State{start_id, start_dir, 0, d});\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c), nxt_rev_dir = changeDirection(s.rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[s.rev_id][s.rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(State{nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ans = false;\n\tfor (int f : wall_dir_at_M) ans |= vis[1023][f][goal_id][goal_dir];\n\treturn ans;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canDo()) {\n\t\tputs(\"He can accomplish his mission.\");\n\t} else {\n\t\tif (canReachMaster()) puts(\"He cannot return to the kitchen.\");\n\t\telse puts(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nenum {NG, HF, OK};\nenum {TO, BACK};\n\nconst string message[] = {\n\t\"He cannot bring tea to his master.\",\n\t\"He cannot return to the kitchen.\",\n\t\"He can accomplish his mission.\"\n};\n\nstruct state {\n\tint x, y, d;\n\tstate(int x_, int y_, int d_):x(x_), y(y_), d(d_) {}\n};\n\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 64;\nconstexpr int D = sizeof(dx) / sizeof(int);\nconstexpr int HF_X = 1;\nconstexpr int HF_Y = MAX_H + 1;\n\nint h, w;\nstring field[MAX_H + 3];\n\nint sx, sy, sd;\nint gd;\nbool visited[MAX_W][MAX_H][D][MAX_W][MAX_H + 3][D];\n\nvector<state> move_back(state s, int turn) {\n\tconst int dir = (s.d + 2) % D;\n\ts.d = (s.d + turn + D) % D;\n\n\tvector<state> res;\n\tdo {\n\t\tif(field[s.y + dy[s.d]][s.x + dx[s.d]] == '#') {\n\t\t\tres.emplace_back(s);\n\t\t}\n\n\t\ts.x += dx[dir];\n\t\ts.y += dy[dir];\n\n\t} while(field[s.y][s.x] != '#');\n\n\tres.emplace_back(state(HF_X, HF_Y, s.d));\n\treturn res;\n}\n\nint bfs() {\n\tint res = NG;\n\n\tqueue<array<state, 2>> que;\n\tfor(int bd = 0; bd < 4; ++bd) {\n\t\tvisited[sy][sx][sd][sy][sx][bd] = true;\n\t\tque.push({{state(sx, sy, sd), state(sx, sy, bd)}});\n\t}\n\n\twhile(!que.empty()) {\n\t\tauto ss = que.front();\n\t\tque.pop();\n\n\t\tconst state tmp_back = ss[BACK];\n\n\t\tint sign = 1;\n\t\tfor(auto &s : ss) {\n\t\t\twhile(field[s.y + dy[s.d] * sign][s.x + dx[s.d] * sign] != '#') {\n\t\t\t\ts.x += dx[s.d] * sign;\n\t\t\t\ts.y += dy[s.d] * sign;\n\t\t\t}\n\t\t\tsign = -sign;\n\t\t}\n\n\t\tif(field[ss[TO].y][ss[TO].x] == 'M') {\n\t\t\tif(field[ss[BACK].y][ss[BACK].x] == 'M' && ss[BACK].d == gd) return OK;\n\t\t\tres = HF;\n\t\t}\n\n\t\tfor(int turn = -1; turn <= 1; turn += 2) {\n\t\t\tstate sa(ss[TO]);\n\t\t\tsa.d = (sa.d + turn + D) % D;\n\n\t\t\tfor(const auto &sb : move_back(tmp_back, turn)) {\n\t\t\t\tif(!visited[sa.x][sa.y][sa.d][sb.x][sb.y][sb.d]) {\n\t\t\t\t\tque.push({{sa, sb}});\n\t\t\t\t\tvisited[sa.x][sa.y][sa.d][sb.x][sb.y][sb.d] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfield[MAX_H]     = \"###\";\n\tfield[MAX_H + 1] = \"#.#\";\n\tfield[MAX_H + 2] = \"###\";\n\n\twhile(cin >> w >> h && w) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tfor(int i = 1; i < h - 1; ++i) {\n\t\t\tfor(int j = 1; j < w - 1; ++j) {\n\t\t\t\tif(field[i][j] == 'K') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\n\t\t\t\t\tfor(int d = 0; d < D; ++d) {\n\t\t\t\t\t\tif(field[i + dy[d]][j + dx[d]] != '#') {\n\t\t\t\t\t\t\tsd = d;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'M') {\n\t\t\t\t\tfor(int d = 0; d < D; ++d) {\n\t\t\t\t\t\tif(field[i + dy[d]][j + dx[d]] != '#') {\n\t\t\t\t\t\t\tgd = d;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << message[bfs()] << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef vector<int> pos;\ntypedef pair<int,int> P;\n\nint w,h;\nstring g[16];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nbool vis[16][64][4][16][64][4];\n\nint main(){\n  int cnt=0;\n  while(cin >> w >> h,w){\n    cnt++;\n    rep(i,h)cin >> g[i];\n    memset(vis,0,sizeof(vis));\n\n    int sy,sx,sd, gy,gx,gd;\n    rep(i,h){\n      rep(j,w){\n\tif(g[i][j] == 'K'){\n\t  rep(k,4){\n\t    int ny = i+dy[k], nx = j+dx[k];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(g[ny][nx] == '.'){\n\t      sy = i; sx = j; sd = k;\n\t    }\n\t  }\n\t}\n\tif(g[i][j] == 'M'){\n\t  rep(k,4){\n\t    int ny = i+dy[k], nx = j+dx[k];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(g[ny][nx] == '.'){\n\t      gy = i; gx = j; gd = k;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    stack<pos> s;\n    pos p(6);\n    p[0] = sy; p[1] = sx; p[2] = sd;\n    p[3] = sy; p[4] = sx;\n\n    rep(i,4){\n      vis[sy][sx][sd][sy][sx][i] = true;\n      p[5] = i;\n      s.push(p);\n    }\n\n    while(s.size()){\n      p = s.top(); s.pop();\n\n      int d1 = p[2], y1 = p[0]+dy[d1], x1 = p[1]+dx[d1];\n      while(g[y1][x1]!='#'){\n\ty1+=dy[d1]; x1+=dx[d1];\n      }\n      y1-=dy[d1]; x1-=dx[d1];\n\n      int d2 = p[5], y2 = p[3], x2 = p[4];\n      while(g[y2][x2]!='#'){\n\tint rd = (p[5]+1)%4, ry = y2+dy[rd], rx = x2+dx[rd];\n\tint ld = (p[5]+3)%4, ly = y2+dy[ld], lx = x2+dx[ld];\n\n\tif(g[ry][rx]=='#' || g[ly][lx]=='#'){\n\t  if(!vis[y1][x1][d1][y2][x2][d2]){\n\t    vis[y1][x1][d1][y2][x2][d2] = true;\n\t    if(g[ry][rx]=='#'){\n\t      pos tmp(6);\n\t      tmp[0] = y1; tmp[1] = x1; tmp[2] = (d1+1)%4;\n\t      tmp[3] = y2; tmp[4] = x2; tmp[5] = rd;\n\t      s.push(tmp);\n\t    }\n\n\t    if(g[ly][lx]=='#'){\n\t      pos tmp(6);\n\t      tmp[0] = y1; tmp[1] = x1; tmp[2] = (d1+3)%4;\n\t      tmp[3] = y2; tmp[4] = x2; tmp[5] = ld;\n\t      s.push(tmp);\n\t    }\n\t  }\n\t}\n\ty2-=dy[d2]; x2-=dx[d2];\n      }\n    }\n    bool f1=false;\n    rep(i,4){\n      if(vis[gy][gx][i][gy][gx][gd])f1 = true;\n    }\n\n    if(f1)cout << \"He can accomplish his mission.\" << endl;\n    else{\n      memset(vis,0,sizeof(vis));\n      p.resize(3);\n      p[0] = sy; p[1] = sx; p[2] = sd;\n      s.push(p);\n\n      while(s.size()){\n\tp = s.top(); s.pop();\n\t\n\tint ny = p[0]+dy[p[2]], nx = p[1]+dx[p[2]];\n\twhile(g[ny][nx]!='#'){\n\t  ny += dy[p[2]]; nx += dx[p[2]];\n\t}\n\tny -= dy[p[2]]; nx -= dx[p[2]];\n\t\n\tif(vis[ny][nx][p[2]][0][0][0])continue;\n\tvis[ny][nx][p[2]][0][0][0] = true;\n\trep(d,2){\n\t  int nd = (p[2] + 2*d+1)%4;\n\t  pos tmp(3);\n\t  tmp[0] = ny; tmp[1] = nx; tmp[2] = nd;\n\t  s.push(tmp);\n\t}\n      }\t  \n      \n      bool f2=false;\n      rep(i,4){\n\tif(vis[gy][gx][i][0][0][0])f2 = true;\n      }\n      if(f2)cout << \"He cannot return to the kitchen.\" << endl;\n      else cout << \"He cannot bring tea to his master.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\tcout << x << \" \" << y << endl;\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tcout << \"i:\" << i << endl;\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf_s(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tcout << sy << \" \" << sx << endl;\n\t\tcout << gy << \" \" << gx << endl;\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint H,W;\nchar c[17][65];\nint dy[] = {0,1,0,-1};\nint dx[] = {1,0,-1,0};\n\npi nx[17][65][4];\nvector<pi> from[17][65][4];\nbool used[17][65][4][17][65][4];\nint gy,gx,gd,ans;\nint gy2,gx2;\n\nvoid f(int y0,int x0,int d0,int y1,int x1,int d1){\n\tif(ans == 2 || used[y0][x0][d0][y1][x1][d1])return;\n\tused[y0][x0][d0][y1][x1][d1] = 1;\n\tif(y0 == gy && x0 == gx && y1 == gy2 && x1 == gx2 && d1 == gd){\n\t\tans = 2;\n\t\treturn;\n\t}\n\tif(y0 == gy && x0 == gx) ans = 1;\n\trep(i,sz(from[y1][x1][d1])+1)for(int dd=1;dd<=3;dd+=2){\n\t\tint nd0 = (d0 + dd) % 4;\n\t\tint nd1 = (d1 + dd) % 4;\n\t\tpi &p = nx[y0][x0][nd0];\n\t\tif(i == sz(from[y1][x1][d1])){\n\t\t\tf(p.fir,p.sec,nd0,H+1,0,0);\n\t\t\tcontinue;\n\t\t}\n\t\tpi &q = from[y1][x1][d1][i];\n\t\tif(c[q.fir + dy[nd1]][q.sec + dx[nd1]] == '#'){\n\t\t\tf(p.fir,p.sec,nd0,q.fir,q.sec,nd1);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>W>>H && W){\n\t\trep(i,H+1)rep(j,W)rep(d,4)from[i][j][d].clear();\n\t\tint sy=-1,sx=-1,sd=-1;\n\t\tgy = gx = gd = -1;\n\t\trep(i,H)rep(j,W){\n\t\t\tcin>>c[i][j];\n\t\t}\n\t\trep(i,H)rep(j,W){\n\t\t\tif(c[i][j] == 'K'){\n\t\t\t\tsy = i, sx = j;\n\t\t\t\trep(d,4){\n\t\t\t\t\tif(c[i+dy[d]][j+dx[d]] == '.'){\n\t\t\t\t\t\tsd = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i][j] = '.';\n\t\t\t}\n\t\t\tif(c[i][j] == 'M'){\n\t\t\t\tgy = i, gx = j;\n\t\t\t\trep(d,4){\n\t\t\t\t\tif(c[i+dy[d]][j+dx[d]] == '.'){\n\t\t\t\t\t\tgd = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i][j] = '.';\n\t\t\t}\n\t\t}\n\t\trep(i,H)rep(j,W)if(c[i][j] == '.')rep(d,4){\n\t\t\tint y = i, x = j;\n\t\t\twhile(c[y+dy[d]][x+dx[d]] == '.'){\n\t\t\t\ty += dy[d], x += dx[d];\n\t\t\t}\n\t\t\tnx[i][j][d] = mp(y,x);\n\t\t\tfrom[y][x][d].pb(mp(i,j));\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tans = 0;\n\t\tpi s2 = nx[sy][sx][sd];\n\t\tif(s2.fir == gy && s2.sec == gx){\n\t\t\tcout<<\"He can accomplish his mission.\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tpi g2 = nx[gy][gx][gd];\n\t\tgy2 = g2.fir, gx2 = g2.sec;\n\t\trep(d,4)f(s2.fir,s2.sec,sd,sy,sx,d);\n\t\tif(ans==2)cout<<\"He can accomplish his mission.\"<<endl;\n\t\telse if(ans==1)cout<<\"He cannot return to the kitchen.\"<<endl;\n\t\telse cout<<\"He cannot bring tea to his master.\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <unordered_set>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n#define F(x, y, d) while (f[x+dx[d]][y+dy[d]] != '#') x+=dx[d], y+=dy[d]\ninline int h(int x, int y, int d) { return (x<<8) | (y<<2) | d; }\ninline int h(int x1, int y1, int d1, int x2, int y2, int d2) {\n    return (h(x1, y1, d1) << 16) | h(x2, y2, d2);\n}\n\nint H, W;\nchar f[16][64];\nint sx, sy, sd, tx, ty, td;\nstd::unordered_set<int> h1, h2;\n\nbool reach(int x, int y, int d) {\n    F(x, y, d);\n    if (x == tx && y == ty) return true;\n    if (!h1.insert(h(x, y, d)).second) return false;\n    if (reach(x, y, (d+1)%4)) return true;\n    if (reach(x, y, (d+3)%4)) return true;\n    return false;\n}\n\nbool acc(int cx, int cy, int cd, int x, int y, int d) {\n    if (f[x+dx[d]][y+dy[d]] != '#') return false;\n    F(cx, cy, cd);\n    const bool p = cx == tx && cy == ty && d == td;\n    while (f[x][y] != '#') {\n        if (!h2.insert(h(cx, cy, cd, x, y, d)).second) break;\n        if (p && x == tx && y == ty) return true;\n        if (acc(cx, cy, (cd+1)%4, x, y, (d+1)%4)) return true;\n        if (acc(cx, cy, (cd+3)%4, x, y, (d+3)%4)) return true;\n        x -= dx[d], y -= dy[d];\n    }\n    return false;\n}\n\nvoid solve() {\n    h1.clear();\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') sx = i, sy = j, sd = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') tx = i, ty = j, td = d;\n    }\n    if (!reach(sx, sy, sd)) puts(\"He cannot bring tea to his master.\");\n    else {\n        h2.clear();\n        rep (d, 4) if (acc(sx, sy, sd, sx, sy, d)) {\n            puts(\"He can accomplish his mission.\");\n            return ;\n        }\n        puts(\"He cannot return to the kitchen.\");\n    }\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nusing P = pair<int, int>;\nusing PP = pair<P, int>;\nint W, H;\nint sy, sx, sd;\nint gy, gx;\nbool field[16][64];\nbool used[16][64][4][16][64][4];\nbool used2[16][64][4];\n\nvoid init()\n{\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 64; j++) {\n            for (int k = 0; k < 4; k++) {\n                for (int l = 0; l < 16; l++) {\n                    for (int m = 0; m < 64; m++) {\n                        for (int n = 0; n < 4; n++) {\n                            used[i][j][k][l][m][n] = false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nP front(const int y, const int x, const int d)\n{\n    if (d == 0) {\n        int Y = y;\n        for (; field[Y - 1][x]; Y--) {\n        }\n        return {Y, x};\n    } else if (d == 1) {\n        int X = x;\n        for (; field[y][X + 1]; X++) {\n        }\n        return {y, X};\n    } else if (d == 2) {\n        int Y = y;\n        for (; field[Y + 1][x]; Y++) {\n        }\n        return {Y, x};\n    } else {\n        int X = x;\n        for (; field[y][X - 1]; X--) {\n        }\n        return {y, X};\n    }\n}\n\nvector<PP> back(const int y, const int x, const int d)\n{\n    vector<PP> ans;\n    constexpr int R = 1;\n    constexpr int L = 3;\n    if (d == 0) {\n        int Y = y;\n        for (; field[Y][x]; Y--) {\n            if (not field[Y][x + 1]) {\n                ans.push_back({{Y, x}, L});\n            } else if (not field[Y][x - 1]) {\n                ans.push_back({{Y, x}, R});\n            }\n        }\n    } else if (d == 1) {\n        int X = x;\n        for (; field[y][X]; X++) {\n            if (not field[y + 1][X]) {\n                ans.push_back({{y, X}, L});\n            } else if (not field[y - 1][X]) {\n                ans.push_back({{y, X}, R});\n            }\n        }\n    } else if (d == 2) {\n        int Y = y;\n        for (; field[Y][x]; Y++) {\n            if (not field[Y][x + 1]) {\n                ans.push_back({{Y, x}, R});\n            } else if (not field[Y][x - 1]) {\n                ans.push_back({{Y, x}, L});\n            }\n        }\n    } else {\n        int X = x;\n        for (; field[y][X]; X--) {\n            if (not field[y + 1][X]) {\n                ans.push_back({{y, X}, R});\n            } else if (not field[y - 1][X]) {\n                ans.push_back({{y, X}, L});\n            }\n        }\n    }\n    return ans;\n}\n\nbool dfs(int fy, int fx, int fd, int by, int bx, int bd)\n{\n    if (fy == gy and fx == gx and by == gy and bx == gx) {\n        return true;\n    } else if (by == gy and bx == gx) {\n        return false;\n    }\n\n    tie(fy, fx) = front(fy, fx, fd);\n    vector<PP> cand = back(by, bx, bd);\n    for (const auto& next : cand) {\n        const int div = next.second;\n        by = next.first.first;\n        bx = next.first.second;\n        const int newfd = (fd + div) % 4;\n        const int newbd = (bd + div) % 4;\n        if (not used[fy][fx][newfd][by][bx][newbd]) {\n            used[fy][fx][newfd][by][bx][newbd] = true;\n            const bool sub = dfs(fy, fx, newfd, by, bx, newbd);\n            if (sub) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool dfs(int fy, int fx, int fd)\n{\n    if (fy == gy and fx == gx) {\n        return true;\n    }\n    tie(fy, fx) = front(fy, fx, fd);\n    for (int i = -1; i <= 1; i += 2) {\n        const int nd = (fd + i + 4) % 4;\n        if (not used2[fy][fx][nd]) {\n            used2[fy][fx][nd] = true;\n            if (dfs(fy, fx, nd)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while (true) {\n        cin >> W >> H;\n        if (W == 0 and H == 0) {\n            break;\n        }\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c;\n                cin >> c;\n                field[i][j] = c != '#';\n                if (c == 'K') {\n                    sy = i;\n                    sx = j;\n                } else if (c == 'M') {\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n        constexpr int dx[] = {0, 1, 0, -1};\n        constexpr int dy[] = {-1, 0, 1, 0};\n        for (int i = 0; i < 4; i++) {\n            if (field[sy + dy[i]][sx + dx[i]]) {\n                sd = i;\n                break;\n            }\n        }\n        bool ans = false;\n        for (int gd = 0; gd < 4; gd++) {\n            if (gd > 0) {\n                init();\n            }\n            used[sy][sx][sd][sy][sx][gd] = true;\n            if (dfs(sy, sx, sd, sy, sx, gd)) {\n                ans = true;\n                break;\n            }\n        }\n        if (ans) {\n            cout << \"He can accomplish his mission.\" << endl;\n        } else {\n            for (int i = 0; i < 16; i++) {\n                for (int j = 0; j < 64; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        used2[i][j][k] = false;\n                    }\n                }\n            }\n            used2[sy][sx][sd] = true;\n            if (dfs(sy, sx, sd)) {\n                cout << \"He cannot return to the kitchen.\" << endl;\n            } else {\n                cout << \"He cannot bring tea to his master.\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\n\t\t\tvisited[y][x][dir] = true;\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, mx, my;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, 0);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec(sx, sy, 0);\n\n\t\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (n); i ++)\n\nstatic const int dy[] = { -1, 0, 1, 0 }, dx[] = { 0, -1, 0, 1 };\nint h, w, sy, sx, gy, gx, sd, gd;\nvector<string> M;\nbool used2[16][64][4][16][64][4];\nbool used[16][64];\n\nstruct point {\n        int y, x;\n        point (int yy = -1, int xx = -1) : y(yy), x(xx) {}\n};\n\nbool cango() {\n        memset(used, 0, sizeof(used));\n        queue<point> q;\n        q.push((point){sy, sx});\n        used[sy][sx] = true;\n        while (!q.empty()) {\n                point p = q.front(); q.pop();\n                if (p.y == gy && p.x == gx) { \n                        return true;\n                }\n                for (int d = 0; d < 4; d ++) {\n                        int xx = p.x, yy = p.y;\n                        while (M[yy + dy[d]][xx + dx[d]] != '#') yy += dy[d], xx += dx[d];\n                        if (!used[yy][xx]) {\n                                used[yy][xx] = true;\n                                q.push({yy, xx});\n                        }\n                }\n        }\n        return false;\n}\n\nbool canreturn() {\n        memset(used2, 0, sizeof(used2));\n        queue<pair<pair<point, int>, pair<point, int>>> q;\n        for (int d = 0; d < 4; d ++) {\n                point s(sy, sx);\n                used2[sy][sx][sd][sy][sx][d] = true;\n                q.push(make_pair(make_pair(s, sd), make_pair(s, d)));\n        }\n        while (!q.empty()) {\n\t\tint y1, x1, d1, y2, x2, d2;\n\t\ty1 = q.front().first.first.y, x1 = q.front().first.first.x;\n\t\ty2 = q.front().second.first.y, x2 = q.front().second.first.x;\n\t\td1 = q.front().first.second, d2 = q.front().second.second;\n\t\tq.pop();\n\t\twhile (M[y1 + dy[d1]][x1 + dx[d1]] != '#') y1 += dy[d1], x1 += dx[d1];\n                while (1) {\n                        for (int i = 1; i < 4; i += 2) {\n                                int nd1 = (d1 + i) % 4, nd2 = (d2 + i) % 4;\n                                if (M[y2 + dy[nd2]][x2 + dx[nd2]] == '#') {\n                                        if (!used2[y1][x1][nd1][y2][x2][nd2]) {\n                                                used2[y1][x1][nd1][y2][x2][nd2] = true;\n                                                q.push(make_pair(make_pair((point){y1, x1}, nd1), make_pair((point){y2, x2}, nd2)));\n                                        }\n                                }\n                        }\n                        if (M[y2 - dy[d2]][x2 - dx[d2]] == '#') break;\n                        y2 -= dy[d2], x2 -= dx[d2];\n                }\n                if (M[y1][x1] == 'M' && M[y2][x2] == 'M' && d2 == gd) return true;\n        }\n        return false;\n}\n\nint main() {\n        while (cin >> w >> h && h) {\n                M.resize(h);\n                for (int i = 0; i < h; i ++) cin >> M[i];\n                for (int i = 0; i < h; i ++) {\n                        for (int j = 0; j < w; j ++) {\n                                if (M[i][j] == 'K') {\n                                        sy = i, sx = j;\n                                        for (int d = 0; d < 4; d ++) {\n                                                int ny = i + dy[d], nx = j + dx[d];\n                                                if (M[ny][nx] != '#') sd = d;\n                                        }\n                                }\n                                if (M[i][j] == 'M') {\n                                        gy = i, gx = j;\n                                        for (int d = 0; d < 4; d ++) {\n                                                int ny = i + dy[d], nx = j + dx[d];\n                                                if (M[ny][nx] != '#') gd = d;\n                                        }\n                                }\n                        }\n                }             \n                if (cango() && canreturn()) cout << \"He can accomplish his mission.\" << endl;\n                else if (cango()) cout << \"He cannot return to the kitchen.\" << endl;\n                else cout << \"He cannot bring tea to his master.\" << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf_s(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pag;\ntypedef pair<pag,pag> sit;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n// »ÝÌÊu©çßéÆ«ÉAæè¤éOÌêðñ\nvector<pag> backTable[2][4][16][64];\n// »ÝÌÊu©çiÞÆ«ÉAæè¤éÌê\npag goTable[2][4][16][64];\n// ·ÅÉÊßµ½ê\nbool vis[4][16][64][4][16][64];\n// ¡ÌóÔ©çS[Ößêé©\nbool isGoal[4][16][64];\n\nint H,W;\nchar field[101][101];\nint sx,sy;\nint sag;\nint gx,gy;\nint gag;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nvoid calcGoAndBackTable(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<4;k++){\n                // ¶©EÉûü]·µÄAOiµ½ ÆÌêðßé\n                // ¶\n                {\n                    int nag=(k-1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[0][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // E\n                {\n                    int nag=(k+1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[1][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // »ÝÌü«Ì½ÎÖßÁ½ãûü]··é\n                int backAg=(k+2)%4;\n                int ny=i;\n                int nx=j;\n                while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                    // ±±Å¶ÉûüðÏ¦éêÆEÉûüðÏ¦éêÅêí¯\n                    // ¶\n                    {\n                        int nag=(k-1+4)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[0][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    // E\n                    {\n                        int nag=(k+1)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[1][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    ny+=dy[backAg];\n                    nx+=dx[backAg];\n                }\n            }\n        }\n    }\n}\n// X^[gn_©çÔÉvZµÄ¢­\nint bfs(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return 2;\n    for(int cnt=0;cnt<4;cnt++){\n    memset(vis,0,sizeof(vis));\n    priority_queue<sit> pq;\n    // X^[gn_ðpush\n    pq.push(sit(pag(pii(psy,psx),pang),pag(pii(sy,sx),(cnt))));\n    vis[pang][psy][psx][sag][sy][sx]=true;\n    while(pq.size()){\n        sit cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.first.second;\n        int gpy=cur.first.first.first;\n        int gang=cur.first.second;\n        int bpx=cur.second.first.second;\n        int bpy=cur.second.first.first;\n        int bang=cur.second.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            res=max(res,1);\n            if(isGoal[bang][bpy][bpx]){\n                res=max(res,2);\n            }\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            // ßéÓ¾¯vZ\n            for(int j=0;j<backTable[i][bang][bpy][bpx].size();j++){\n                pag nbpag=backTable[i][bang][bpy][bpx][j];\n                // ngpagÆnbpagÌîñ©çÉ¢¯éê\n                if(vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second])\n                    continue;\n                vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second]=true;\n                pq.push(sit(ngpag,nbpag));\n            }\n        }\n    }\n    }\n    // 3ÂÌÇÌóÔÉÈé©`FbN\n    return res;\n}\n\nbool used[4][101][101];\nbool bfs2(int psy,int psx,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==sy&&gx==sx)return true;\n    memset(used,0,sizeof(used));\n    priority_queue<pag> pq;\n    // X^[gn_ðpush\n    pq.push(pag(pii(psy,psx),pang));\n    used[pang][psy][psx]=true;\n    while(pq.size()){\n        pag cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.second;\n        int gpy=cur.first.first;\n        int gang=cur.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            return true;\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            if(used[ngpag.second][ngpag.first.first][ngpag.first.second])\n                continue;\n            used[ngpag.second][ngpag.first.first][ngpag.first.second]=true;\n            pq.push(ngpag);\n        }\n    }\n    return false;\n}\n\nvoid input(){\n    // startÆgoalÌÊuðè\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>field[i][j];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='K'){\n                field[i][j]='.';\n                sy=i;sx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')sag=k;\n                }\n            }\n            else if(field[i][j]=='M'){\n                field[i][j]='.';\n                gy=i;gx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')gag=k;\n                }\n            }\n        }\n    }\n}\nvoid init(){\n    memset(isGoal,0,sizeof(isGoal));\n    for(int i=0;i<2;i++)for(int j=0;j<4;j++)\n        for(int k=0;k<16;k++)for(int l=0;l<64;l++)\n            backTable[i][j][k][l].clear();\n}\nint main(){\n    while(cin>>W>>H&&(W|H)){\n        // ú»\n        init();\n        input();\n        calcGoAndBackTable();\n        // S[ÖßêéêðvZ\n        {\n            int cy=gy;\n            int cx=gx;\n            int cag=gag;\n            while(field[cy][cx]!='#'){\n                isGoal[cag][cy][cx]=true;\n                cy+=dy[gag];\n                cx+=dx[gag];\n            }\n        }\n        // startn_©ç··ßÄ¨­\n        int psy=sy;\n        int psx=sx;\n        int pang=sag;\n        while(psy>=0&&psx>=0&&psy<H&&psx<W&&field[psy][psx]!='#'){\n            psy+=dy[sag];\n            psx+=dx[sag];\n        }\n        // ß·\n        psy-=dy[sag];\n        psx-=dx[sag];\n        int res=bfs(psx,psy,pang);\n        res=max(res,(int)bfs2(psx,psy,pang));\n        if(res==0)\n            cout<<\"He cannot bring tea to his master.\"<<endl;\n        else if(res==1)\n            cout<<\"He cannot return to the kitchen.\"<<endl;\n        else if(res==2)\n            cout<<\"He can accomplish his mission.\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nbool memo[64][16][4][64][16][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint fway;\n\tint tx;\n\tint ty;\n\tint tway;\n};\nint gx, gy;\n\nvector<aa>astack;\n\nbool cangoal;\n\nint gway;\n\nbool check(int fx, int fy,int fway, int tx, int ty, int tway) {\n\n\tif (memo[fx][fy][fway][tx][ty][tway])return false;\n\tmemo[fx][fy][fway][tx][ty][tway] =true;\n\t\n\t//else{\n\n\t\tint nfy = fy + dy[fway];\n\t\tint nfx = fx + dx[fway];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (mp[nfy][nfx]) {\n\t\t\t\tnfx -= dx[fway];\n\t\t\t\tnfy -= dy[fway];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[fway];\n\t\t\tnfx = nfx + dx[fway];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (mp[nty][ntx]) {\n\t\t\t\tntx -= dx[tway];\n\t\t\t\tnty -= dy[tway];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\t\tint afway = (fway + 3) % 4;\n\t\t\t\tint atway = (tway + 3) % 4;\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\t\tcangoal = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\t\tint afway = (fway + 1) % 4;\n\t\t\t\tint atway = (tway + 1) % 4;\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\t\tcangoal = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnty = nty + dy[tway];\n\t\t\tntx = ntx + dx[tway];\n\t\t}\n\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\tint afway = (fway + 3) % 4;\n\t\t\tint atway = (tway + 3) % 4;\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\t\t}\n\n\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\tint atway = (tway + 1) % 4;\n\t\t\tint afway = (fway + 1) % 4;\n\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\t\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\n\t\t\t}\n\t\t}\n\n\t//}\n\treturn false;\n}\n\nint main() {\n\twhile (1) {\n\t\tcangoal = false;\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tastack.clear();\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\t\tmp.resize(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tmp[i].resize(W);\n\t\t}\n\n\t\tint sx, sy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t\tif (mp[gy + dy[i]][gx + dx[i]] == 0) {\n\t\t\t\tgway = i;\n\t\t\t}\n\t\t}\n\t\tbool perf = false;\n\t\tfor (int i = 0; i < 4;++i)\n\t\t\tastack.push_back(aa{ sx,sy,sway,sx,sy,i });\n\n\t\twhile (!astack.empty()) {\n\t\t\taa atop(astack.back());\n\t\t\tastack.pop_back();\n\t\t\tif (check(atop.fx, atop.fy,atop.fway, atop.tx, atop.ty, atop.tway)) {\n\t\t\t\tperf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (perf) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (cangoal) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl\n#define double long double\nusing namespace std;\nconst int INF = 1e9;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int H = 17;\nconst int W = 65;\n\nint h,w;\nvector<string> mp;\n\nint used[W][H][4][W][H][4];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar getChar(int x,int y,int dir){return mp[y + dy[dir]][x + dx[dir]];}\nvoid getNx(int &x,int &y,int dir){while(getChar(x, y, dir) != '#') x += dx[dir],y += dy[dir];}\nint getDir(int x,int y){for(int i=0;i<4;i++) if(getChar(x, y, i) != '#') return i;}\n\nint bfs(int sx,int sy,int gx,int gy,int flag = 0){\n  memset(used,0,sizeof(used));\n  int sdir = getDir(sx, sy);\n  int gdir = getDir(gx, gy);\n  \n  struct dat{\n    int x, y, dir1, a, b, dir2;\n    dat();\n    dat(int x,int y,int dir1,int a,int b,int dir2):\n      x(x), y(y), dir1(dir1), a(a), b(b), dir2(dir2){}\n  };\n  \n  queue<dat> Q;\n  \n  auto Push=[&](int nx,int ny,int ndir1,int a,int b,int ndir2){\n    \n    if(flag) {\n      if(used[nx][ny][ndir1][0][0][0]++ == 0) Q.push(dat(nx,ny,ndir1, 0,0,0));\n      return;\n    }\n\n    if(getChar(a, b, ndir2) != '#') return;\n    int na = a, nb = b;\n    while(mp[nb][na] != '#'){\n      int flag = getChar(na,nb,(ndir2+1)%4) == '#' || getChar(na, nb, (ndir2+3)%4) == '#';\n      if(flag && used[nx][ny][ndir1][na][nb][ndir2]++ == 0) Q.push(dat(nx,ny,ndir1, na,nb,ndir2));\n      na += dx[(ndir2+2)%4];\n      nb += dy[(ndir2+2)%4];\n    }\n  };\n  \n  for(int i=0;i<4;i++){\n    int nx = sx, ny = sy; getNx(nx, ny, sdir);\n    if(getChar(sx, sy, i) == '#') Push(nx,ny,sdir,sx,sy,i);\n  }\n\n  int res = 0;\n  while(!Q.empty()){\n    auto t = Q.front(); Q.pop();\n    int x = t.x, y = t.y, dir1 = t.dir1;\n    int a = t.a, b = t.b, dir2 = t.dir2;\n    if(x == gx && y == gy) res = 1;\n    if(x == gx && y == gy && a == gx && b == gy && dir2 == gdir) return 2;\n    \n    \n    {//右に曲がる\n      int nx = x, ny = y, ndir1 = (dir1 + 1) % 4; getNx(nx, ny, ndir1);\n      int ndir2 = (dir2 + 1) % 4;\n      Push(nx, ny, ndir1, a, b, ndir2);\n    }\n\n    {//左に曲がる。\n      int nx = x, ny = y, ndir1 = (dir1 + 3) % 4; getNx(nx, ny, ndir1);\n      int ndir2 = (dir2 + 3) % 4;\n      Push(nx, ny, ndir1, a, b, ndir2);\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>w>>h;\n    if(h == 0 && w == 0) return 0;\n    \n    mp.clear();\n    mp.resize(h);\n    cin>>mp;\n  \n    int sx,sy,gx,gy;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n        if(mp[i][j] == 'K') sx = j, sy = i;\n        if(mp[i][j] == 'M') gx = j, gy = i;\n      }\n\n    int ans = bfs(gx, gy, sx, sy);\n    if(ans != 2) ans = bfs(sx, sy, gx, gy, 1);\n    if(ans == 0) cout<<\"He cannot bring tea to his master.\"<<endl;\n    else if(ans == 1) cout<<\"He cannot return to the kitchen.\"<<endl;\n    else cout<<\"He can accomplish his mission.\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_K;\n\nvoid constructTransition() {\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_K = vector< int >();\n\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\telse if (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\telse if (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tint cnt = 0;\n\tfor_(y,0,H) {\n\t\tfor_(x,0,W) {\n\t\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\t\tfor_(d,0,4) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tgoal_dir = d;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tstart_dir = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt == 2) break;\n\t\t}\n\t\tif (cnt == 2) break;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nint SHIFT = 16, MASK = (1 << 16) - 1;\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\ninline int makeState(int id, int dir) { return (id | (dir << SHIFT)); }\ninline int getID(int state) { return (state & MASK); }\ninline int getDIR(int state) { return (state >> SHIFT); }\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< int > que;\n\tque.push(makeState(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tint s = que.front(); que.pop();\n\t\tint id = getID(s), dir = getDIR(s);\n\t\tif (id == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(makeState(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< pii > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(pii(makeState(start_id, start_dir), makeState(0, d)));\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint id = getID(p.first), dir = getDIR(p.first);\n\t\tint rev_id = getID(p.second), rev_dir = getDIR(p.second);\n\t\tif (id == 1023 && rev_id == goal_id && rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c), nxt_rev_dir = changeDirection(rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[rev_id][rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(pii(makeState(nxt_id, nxt_dir), makeState(nxt_rev_id, nxt_rev_dir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  /*\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n  */\nvis[R-1][C-1][DIR-1][R-1][C-1][DIR-1]=false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pag;\ntypedef pair<pag,pag> sit;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n// »ÝÌÊu©çßéÆ«ÉAæè¤éOÌêðñ\nvector<pag> backTable[2][4][16][64];\n// »ÝÌÊu©çiÞÆ«ÉAæè¤éÌê\npag goTable[2][4][16][64];\n// ·ÅÉÊßµ½ê\nbool vis[4][16][64][4][16][64];\n// ¡ÌóÔ©çS[Ößêé©\nbool isGoal[4][16][64];\nbool used[4][101][101];\n\nint H,W;\nchar field[101][101];\nint sx,sy;\nint sag;\nint gx,gy;\nint gag;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nvoid calcGoAndBackTable(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='#')continue;\n            for(int k=0;k<4;k++){\n                // ¶©EÉûü]·µÄAOiµ½ ÆÌêðßé\n                // ¶\n                {\n                    int nag=(k-1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[0][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // E\n                {\n                    int nag=(k+1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[1][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // »ÝÌü«Ì½ÎÖßÁ½ãûü]··é\n                int backAg=(k+2)%4;\n                int ny=i;\n                int nx=j;\n                while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                    // ±±Å¶ÉûüðÏ¦éêÆEÉûüðÏ¦éêÅêí¯\n                    // ¶\n                    {\n                        int nag=(k-1+4)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[0][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    // E\n                    {\n                        int nag=(k+1)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[1][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    ny+=dy[backAg];\n                    nx+=dx[backAg];\n                }\n            }\n        }\n    }\n}\n// X^[gn_©çÔÉvZµÄ¢­\nint bfs(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return 2;\n    for(int cnt=0;cnt<4;cnt++){\n        memset(vis,0,sizeof(vis));\n        priority_queue<sit> pq;\n        // X^[gn_ðpush\n        pq.push(sit(pag(pii(psy,psx),pang),pag(pii(sy,sx),(cnt))));\n        vis[pang][psy][psx][sag][sy][sx]=true;\n        while(pq.size()){\n            sit cur=pq.top();pq.pop();\n            // »ÝÌóÔðæ¾\n            int gpx=cur.first.first.second;\n            int gpy=cur.first.first.first;\n            int gang=cur.first.second;\n            int bpx=cur.second.first.second;\n            int bpy=cur.second.first.first;\n            int bang=cur.second.second;\n            // S[»è\n            if(gpy==gy&&gpx==gx){\n                res=max(res,1);\n                if(isGoal[bang][bpy][bpx]){\n                    res=max(res,2);\n                }\n            }\n            // Ì½ßðÇ¤·é©\n            for(int i=0;i<2;i++){\n                // Ìs«æ\n                pag ngpag=goTable[i][gang][gpy][gpx];\n                // ßéÓ¾¯vZ\n                for(int j=0;j<backTable[i][bang][bpy][bpx].size();j++){\n                    pag nbpag=backTable[i][bang][bpy][bpx][j];\n                    // ngpagÆnbpagÌîñ©çÉ¢¯éê\n                    if(vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second])\n                        continue;\n                    vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second]=true;\n                    pq.push(sit(ngpag,nbpag));\n                }\n            }\n        }\n    }\n    // 3ÂÌÇÌóÔÉÈé©`FbN\n    return res;\n}\n\nbool bfs2(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return true;\n    memset(used,0,sizeof(used));\n    priority_queue<pag> pq;\n    // X^[gn_ðpush\n    pq.push(pag(pii(psy,psx),pang));\n    used[pang][psy][psx]=true;\n    while(pq.size()){\n        pag cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.second;\n        int gpy=cur.first.first;\n        int gang=cur.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            return true;\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            if(used[ngpag.second][ngpag.first.first][ngpag.first.second])\n                continue;\n            used[ngpag.second][ngpag.first.first][ngpag.first.second]=true;\n            pq.push(ngpag);\n        }\n    }\n    return false;\n}\n\nvoid input(){\n    // startÆgoalÌÊuðè\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>field[i][j];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='K'){\n                field[i][j]='.';\n                sy=i;sx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')sag=k;\n                }\n            }\n            else if(field[i][j]=='M'){\n                field[i][j]='.';\n                gy=i;gx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')gag=k;\n                }\n            }\n        }\n    }\n}\nvoid init(){\n    memset(isGoal,0,sizeof(isGoal));\n    for(int i=0;i<2;i++)for(int j=0;j<4;j++)\n        for(int k=0;k<16;k++)for(int l=0;l<64;l++)\n            backTable[i][j][k][l].clear();\n}\nint main(){\n    while(cin>>W>>H&&(W|H)){\n        // ú»\n        init();\n        input();\n        calcGoAndBackTable();\n        // S[ÖßêéêðvZ\n        {\n            int cy=gy;\n            int cx=gx;\n            int cag=gag;\n            isGoal[cag][cy][cx]=true;\n            while(field[cy][cx]!='#'){\n                //isGoal[cag][cy][cx]=true;\n                cy+=dy[gag];\n                cx+=dx[gag];\n            }\n            cy-=dy[gag];\n            cx-=dx[gag];\n            isGoal[cag][cy][cx]=true;\n        }\n        // startn_©ç··ßÄ¨­\n        int psy=sy;\n        int psx=sx;\n        int pang=sag;\n        while(psy>=0&&psx>=0&&psy<H&&psx<W&&field[psy][psx]!='#'){\n            psy+=dy[sag];\n            psx+=dx[sag];\n        }\n        // ß·\n        psy-=dy[sag];\n        psx-=dx[sag];\n        int res=bfs(psx,psy,pang);\n        res=max(res,(int)bfs2(psx,psy,pang));\n        if(res==0)\n            cout<<\"He cannot bring tea to his master.\"<<endl;\n        else if(res==1)\n            cout<<\"He cannot return to the kitchen.\"<<endl;\n        else if(res==2)\n            cout<<\"He can accomplish his mission.\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[20];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tcout << \"(\" << x << \",\" << y << \")\" << endl;\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int x, int y) {\n\trep(i, 4) {\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h!=0&&w!=0) {\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\t\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nint h, w;\nvector<string> s;\nint sy, sx, sd, gy, gx, gd;\n\nint toInt(int y1, int x1, int d1, int y2, int x2, int d2)\n{\n    return ((((y1 * w + x1) * 4 + d1) * h + y2) * w + x2) * 4 + d2;\n}\n\nvector<bool> memo;\n\nbool isAccomplish(int y1, int x1, int d1, int y2, int x2, int d2)\n{\n    if(memo[toInt(y1, x1, d1, y2, x2, d2)])\n        return false;\n    memo[toInt(y1, x1, d1, y2, x2, d2)] = true;\n\n    if(s[y2+dy[d2]][x2+dx[d2]] != '#')\n        return false;\n\n    while(s[y1+dy[d1]][x1+dx[d1]] != '#'){\n        y1 += dy[d1];\n        x1 += dx[d1];\n    }\n\n    while(s[y2][x2] != '#'){\n        if(isAccomplish(y1, x1, (d1+1)%4, y2, x2, (d2+1)%4))\n            return true;\n        if(isAccomplish(y1, x1, (d1+3)%4, y2, x2, (d2+3)%4))\n            return true;\n        y2 -= dy[d2];\n        x2 -= dx[d2];\n    }\n\n    y2 += dy[d2];\n    x2 += dx[d2];\n    if(y1 == gy && x1 == gx && y2 == gy && x2 == gx && d2 == gd)\n        return true;\n\n    return false;\n}\n\nbool isBring(int y, int x, int d)\n{\n    if(y == gy && x == gx)\n        return true;\n\n    if(memo[toInt(0, 0, 0, y, x, d)])\n        return false;\n    memo[toInt(0, 0, 0, y, x, d)] = true;\n\n    while(s[y+dy[d]][x+dx[d]] != '#'){\n        y += dy[d];\n        x += dx[d];\n    }\n\n    return isBring(y, x, (d+1)%4) || isBring(y, x, (d+3)%4);\n}\n\nint main()\n{\n    for(;;){\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        s.resize(h);\n        for(int i=0; i<h; ++i)\n            cin >> s[i];\n\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                if(s[i][j] == 'K'){\n                    sy = i;\n                    sx = j;\n                    sd = 0;\n                    while(s[sy+dy[sd]][sx+dx[sd]] == '#')\n                        ++ sd;\n                }else if(s[i][j] == 'M'){\n                    gy = i;\n                    gx = j;\n                    gd = 0;\n                    while(s[gy+dy[gd]][gx+dx[gd]] == '#')\n                        ++ gd;\n                }\n\n            }\n        }\n\n        memo.assign(h * h * w * w * 4 * 4, false);\n        bool ret = false;\n        for(int i=0; i<4; ++i)\n            ret |= isAccomplish(sy, sx, sd, sy, sx, i);\n\n        if(ret)\n            cout << \"He can accomplish his mission.\" << endl;\n        else if(isBring(sy, sx, sd))\n            cout << \"He cannot return to the kitchen.\" << endl;\n        else\n            cout << \"He cannot bring tea to his master.\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_K = vector< int >();\n\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\telse if (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\telse if (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tint cnt = 0;\n\tfor_(y,0,H) {\n\t\tfor_(x,0,W) {\n\t\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\t\tfor_(d,0,4) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tgoal_dir = d;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tstart_dir = d;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt == 2) break;\n\t\t}\n\t\tif (cnt == 2) break;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nint SHIFT = 16, MASK = (1 << 10) - 1;\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\ninline int makeState(int id, int dir) { return id | (dir << SHIFT); }\ninline int getID(int state) { return state & MASK; }\ninline int getDIR(int state) { return state >> SHIFT; }\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< int > que;\n\tque.push(makeState(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tint s = que.front(); que.pop();\n\t\tint id = getID(s), dir = getDIR(s);\n\t\tif (id == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(makeState(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< pii > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(pii(makeState(start_id, start_dir), makeState(0, d)));\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint id = getID(p.first), dir = getDIR(p.first);\n\t\tint rev_id = getID(p.second), rev_dir = getDIR(p.second);\n\t\tif (id == 1023 && rev_id == goal_id && rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c), nxt_rev_dir = changeDirection(rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[rev_id][rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(pii(makeState(nxt_id, nxt_dir), makeState(nxt_rev_id, nxt_rev_dir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint d[10] = {0, -1, 0, 1, 0, -1, 0, 1, 0, -1};\nint w, h, s1, s2, t1, t2;\n\nchar ss[100][100];\nint encode(int x, int y, int d){\n\treturn x*16*4 + y*4 + d;\n}\n\nint dp[64*16*4][64*16*4];\nint dp2[64*16*4];\nint main(){\n\twhile(cin >> w >> h, w){\n\t\tREP(i, h) cin >> ss[i];\n\t\tvector<vi> g(64*16*4, vi(2, -1));\n\t\tvector<vector<vi>> invg(64*16*4, vector<vi>(2));\n\t\tREP(i, h)REP(j, w)if(ss[i][j] != '#'){\n\t\t\tREP(k, 4)if(ss[i+d[k]][j+d[k+1]] == '.'){\n\t\t\t\tint dx=j, dy=i;\n\t\t\t\twhile(ss[dy+d[k]][dx+d[k+1]] != '#'){\n\t\t\t\t\tdy+=d[k]; dx+=d[k+1];\n\t\t\t\t}\n\t\t\t\tif(ss[i][j] == 'K'){\n\t\t\t\t\ts1 = encode(dx, dy, k);\n\t\t\t\t\ts2 = encode(j, i, k);\n\t\t\t\t}\n\t\t\t\tif(ss[i][j] == 'M'){\n\t\t\t\t\tt1 = encode(j, i, k^2);\n\t\t\t\t\tt2 = encode(dx, dy, k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, 4)REP(l, 2){\n\t\t\t\tint dx=j, dy=i;\n\t\t\t\tint dir = (k+1+l*2)%4;\n\t\t\t\twhile(ss[dy+d[dir]][dx+d[dir+1]] != '#'){\n\t\t\t\t\tdy+=d[dir]; dx+=d[dir+1];\n\t\t\t\t}\n\t\t\t\tint u = encode(j, i, k);\n\t\t\t\tint v = encode(dx, dy, dir);\n\t\t\t\tinvg[v][!l].push_back(u);\n\t\t\t\tg[u][l] = v;\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tqueue<pii> q;\n\t\tREPS(i, 3) q.emplace(s1, s2^i);\n\t\tint ans = 0;\n\t\twhile(!q.empty()){\n\t\t\tint u1, u2; tie(u1, u2) = q.front(); q.pop();\n\t\t\tif((u1|3) == (t1|3)) ans = 1;\n\t\t\tif((u1|3)== (t1|3) && u2 == t2){\n\t\t\t\tans = 2; break;\n\t\t\t}\n\t\t\tREP(l, 2){\n\t\t\t\tint v1 = g[u1][l];\n\t\t\t\tif(u2 == -1 || invg[u2][l].empty()){\n\t\t\t\t\tif(!dp2[v1]){\n\t\t\t\t\t\tdp2[v1] = 1;\n\t\t\t\t\t\tq.emplace(v1, -1);\n\t\t\t\t\t}\n\t\t\t\t}else for(int v2 : invg[u2][l]){\n\t\t\t\t\tif(!dp[v1][v2]){\n\t\t\t\t\t\tdp[v1][v2] = 1;\n\t\t\t\t\t\tq.emplace(v1, v2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 0) puts(\"He cannot bring tea to his master.\");\n\t\tif(ans == 1) puts(\"He cannot return to the kitchen.\");\n\t\tif(ans == 2) puts(\"He can accomplish his mission.\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\t\n\tif (!(m[i+dy[(k+2)%4]][j+dx[(k+2)%4]] == '.'||\n\t      m[i+dy[(k+1)%4]][j+dx[(k+1)%4]] == '#'||\n\t      m[i+dy[(k+3)%4]][j+dx[(k+3)%4]] == '#')\n\t    )continue;\n\t\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t}\n      }\n    }\n  }\n}\n\nvoid output(int r,int c,int ry,int rx,int rd,int rl){\n  const char dd[]={'N','E','S','W'};\n  const char aho[]={'R','L'};\n  cout <<\"Outputbegin\"<<endl;\n  cout << aho[rl] << endl;\n  rep(i,r){\n    rep(j,c){\n      if (ry == i && rx == j)cout << dd[rd];\n      else cout << m[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl<<endl;\n}\n\nbool cango;\n\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gy,int gx,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  if (m[sy][sx] == 'M')cango=true;\n  \n  if (m[sy][sx] == 'M' &&\n      ry == gy && rx == gx && rd == gd)return true;\n\n  Edge cpy1,cpy2;\n\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\t/*\n\tif (m[sy][sx] == 'M' &&\n\t    cpy2.y == gy && cpy2.x == gx && cpy2.d == gd){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  output(r,c,sy,sx,sd,l);\n\t  //\t  cout << cpy1.y <<\" \" << cpy1.x << endl;\n\t  //\t  cout << \"final state \" << cpy2.y <<\" \" << cpy2.x  << \" \" << cpy2.d << endl;\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n\t*/\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  //output(r,c,sy,sx,sd,l);\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n      }\n    }\n  }\n  \n  return false;\n}\n\n\nbool vis2[R][C][DIR];\nbool solve_to_kit(int r,int c,int sy,int sx,int sd){\n  if (vis2[sy][sx][sd])return false;\n  vis2[sy][sx][sd]=true;\n  if (m[sy][sx] == 'M')return true;\n  \n  Edge cpy1;\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      if (solve_to_kit(r,c,cpy1.y,cpy1.x,cpy1.d))return true;\n     }\n  }\n  return false;\n}\n\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    rep(i,r)rep(j,c)rep(k,k)vis2[i][j][k]=false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n    /*\n    char TEST[]={'N','E','S','W'};\n    char TURN[]={'R','L'};\n    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,edge[i][j][k][l].size()){\n\t      cout <<\"pos \" <<  i<<\" \" << j <<\" dir \" << TEST[k] <<\" turn to \" <<\n\t\tTURN[l] ;\n\t      cout << \" will go \" << \n\t\tedge[i][j][k][l][m].y <<\" \" << edge[i][j][k][l][m].x <<\" dir \" \n\t\t   <<TEST[edge[i][j][k][l][m].d] << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n\n    /*    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout << i <<\" \" << j <<\" \" << TEST[k] <<\" \" \n\t\t   <<TURN[l] << endl; \n\t      output(r,c,rev[i][j][k][l][m].y,rev[i][j][k][l][m].x,\n\t\t     rev[i][j][k][l][m].d,l);\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n    if (solve_to_kit(r,c,iniy,inix,inidir))cango=true;\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_M, wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_M = wall_dir_at_K = vector< int >();\n\t\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\tif (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\tif (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\tfor_(d,0,4) {\n\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\tif (home_map[y][x] == 'M') wall_dir_at_M.push_back(d);\n\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\tgoal_dir = d;\n\t\t\t\t} else {\n\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\tstart_dir = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nstruct State {\n\tint id, dir;\n\tint rev_id, rev_dir;\n};\n\nbool vis[1024][4][1024][4];\n\nbool canReachMaster() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tque.push(State{start_id, start_dir});\n\tvis[start_id][start_dir][0][0] = true;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tif (s.id == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c);\n\t\t\tif (!vis[nxt_id][nxt_dir][0][0]) {\n\t\t\t\tvis[nxt_id][nxt_dir][0][0] = true;\n\t\t\t\tque.push(State{nxt_id, nxt_dir});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(State{start_id, start_dir, 0, d});\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tif (s.id == 1023 && s.rev_id == goal_id && s.rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c), nxt_rev_dir = changeDirection(s.rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[s.rev_id][s.rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(State{nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canDo()) {\n\t\tputs(\"He can accomplish his mission.\");\n\t} else {\n\t\tif (canReachMaster()) puts(\"He cannot return to the kitchen.\");\n\t\telse puts(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<string>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\n#define U 0\n#define R 1\n#define D 2\n#define L 3\nstring p = \"URDL\";\n#define MR 0\n#define ML 1\nconst int dr[] = { -1,0,1,0 };\nconst int dc[] = { 0,1,0,-1 };\n\nint rot(int d, int i,int x) {\n\tif (x == MR) {\n\t\tif (i == 0)return (d + 1) % 4;\n\t\telse return (d + 3) % 4;\n\t}\n\telse {\n\t\tif (i == 0)return (d + 3) % 4;\n\t\telse return (d + 1) % 4;\n\t}\n}\n\nint H, W, sr, sc, sd,gr, gc,gd;\nstring X[16];\nint a[1 << 15];\nint b[1 << 15];\ninline int rr(int x) { return (x>>8)&15; }\ninline int cc(int x) { return (x>>2)&63; }\ninline int dd(int x) { return x&3; }\ninline int pack(int r, int c, int d) {\n\treturn (r << 8) + (c << 2) + d;\n}\ninline void sweep(int& r, int& c, int d) {\n\tint nr, nc;\n\twhile (nr = r + dr[d], nc = c + dc[d], X[nr][nc] != '#')\n\t\tr = nr, c = nc;\n}\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<VVV> VVVV;\ntypedef vector<VVVV> VVVVV;\n\nVVVV g;\nVVVVV r_g;\n\ninline int f(int r1,int c1,int d1,int r2,int c2,int d2) {\n\tint res = r1;\n\tres <<= 6; res += c1;\n\tres <<= 2; res += d1;\n\tres <<= 4; res += r2;\n\tres <<= 6; res += c2;\n\tres <<= 2; res += d2;\n\treturn res;\n}\nvoid ff(int res, int &r1, int &c1, int &d1, int &r2, int &c2, int &d2) {\n\td2 = res & 3; res >>= 2;\n\tc2 = res & 63; res >>= 6;\n\tr2 = res & 15; res >>= 4;\n\td1 = res & 3; res >>= 2;\n\tc1 = res & 63; res >>= 6;\n\tr1 = res & 15; \n}\nbool dp[16][64][4][16][64][4];\nint main() {\n\twhile (cin >> W >> H, W + H) {\n\t\tREP(i, H)cin >> X[i];\n\t\tREP(i, H)REP(j, W) {\n\t\t\tif (X[i][j] == 'K')sr = i, sc = j;\n\t\t\tif (X[i][j] == 'M')gr = i, gc = j;\n\t\t}\n\t\tREP(i, H)REP(j, W)REP(x, 4)REP(ii, H)REP(jj, W)REP(xx, 4)\n\t\t\tdp[i][j][x][ii][jj][xx] = false;\n\t\tg.assign(H, VVV(W, VV(4, V(2, -1))));\n\t\tr_g.assign(H, VVVV(W, VVV(4, VV(2, V()))));\n\t\tint id = 0;\n\t\ta[id++] = pack(0, 0, 0);\n\t\tr_g[0][0][0][0].push_back(0);\n\t\tr_g[0][0][0][1].push_back(0);\n\t\tREP(i, H)REP(j, W)if(X[i][j]!='#')REP(k, 4) {\n\t\t\tint r, c, d;\n\t\t\tr = i, c = j, d = rot(k, 0, MR);\n\t\t\tsweep(r,c,d);\n\t\t\ta[id] = pack(i,j,k);\n\t\t\tb[id] = pack(r, c, d);\n\t\t\tg[i][j][k][MR] = id;\n\t\t\tr_g[r][c][d][ML].push_back(id);\n\t\t\tid++;\n\t\t\tr = i, c = j, d = rot(k, 0, ML);\n\t\t\tsweep(r, c, d);\n\t\t\ta[id] = pack(i, j, k);\n\t\t\tb[id] = pack(r, c, d);\n\t\t\tg[i][j][k][ML] = id;\n\t\t\tr_g[r][c][d][MR].push_back(id);\n\t\t\tid++;\n\t\t\tr_g[i][j][k][0].push_back(0);\n\t\t\tr_g[i][j][k][1].push_back(0);\n\t\t}\n\t\tint latte, malta;\n\t\tstack<int> st;\n\t\t{\n\t\t\tint r = sr, c = sc;\n\t\t\tREP(i, 4)if(X[r+dr[i]][c+dc[i]]=='.') {\n\t\t\t\tsd = i;\n\t\t\t\tsweep(r, c, sd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4) if(i!=sd){\n\t\t\t\tdp[r][c][sd][sr][sc][i] = true;\n\t\t\t\tst.push(f(r, c, sd, sr, sc, i));\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint r = gr, c = gc;\n\t\t\tREP(i, 4)if (X[r + dr[i]][c + dc[i]] == '.') {\n\t\t\t\tgd = i;\n\t\t\t\tsweep(r, c, gd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlatte = r; malta = c;\n\t\t}\n\n\t\twhile (st.size()) {\n\t\t\tint r1, c1, d1, r2, c2, d2;\n\t\t\tff(st.top(), r1, c1, d1, r2, c2, d2); st.pop();\n\n\t\t\tREP(i, 2) {\n\t\t\t\tint nxt1 = b[g[r1][c1][d1][i]];\n\t\t\t\tint nr1 = rr(nxt1);\n\t\t\t\tint nc1 = cc(nxt1);\n\t\t\t\tint nd1 = dd(nxt1);\n\t\t\t\tfor (auto &it : r_g[r2][c2][d2][i]) {\n\t\t\t\t\tint nxt2 = a[it];\n\t\t\t\t\tint nr2 = rr(nxt2);\n\t\t\t\t\tint nc2 = cc(nxt2);\n\t\t\t\t\tint nd2 = dd(nxt2);\n\t\t\t\t\tif (dp[nr1][nc1][nd1][nr2][nc2][nd2] == false) {\n\t\t\t\t\t\tdp[nr1][nc1][nd1][nr2][nc2][nd2] = true;\n\t\t\t\t\t\tst.push(f(nr1,nc1,nd1,nr2,nc2,nd2));\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tcout << r1 << c1 << p[d1] ;\n\t\t\t\t\t\tcout << r2 << c2  << p[d2] << endl;\n\t\t\t\t\t\tcout << \"->\" << endl;\n\t\t\t\t\t\tcout << nr1 << nc1  << p[nd1] ;\n\t\t\t\t\t\tcout << nr2 << nc2  << p[nd2] << endl;\n\t\t\t\t\t\tcout  << endl;\n\t\t\t\t\t\t*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tREP(i, 4)if (dp[gr][gc][i][latte][malta][gd])res = 1;\n\t\tif (res) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tREP(i, 4)REP(j, 4)REP(r,H)REP(c,W)if (dp[gr][gc][i][r][c][j])res = 1;\n\t\tif (res)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse cout << \"He cannot bring tea to his master.\" << endl;\n\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR];\n\n\nmain(){\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,C)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t}\n      }\n    }\n  }\n}\n\nbool cango;\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gy,int gx,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  \n  if (m[sy][sx] == 'M' &&\n      ry == gy && rx == gx && rd == gd)return true;\n\n  Edge cpy1,cpy2;\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\n\nbool vis2[R][C][DIR];\nbool solve_to_kit(int r,int c,int sy,int sx,int sd){\n  if (vis2[sy][sx][sd])return false;\n\n  vis2[sy][sx][sd]=true;\n  if (m[sy][sx] == 'M')return true;\n  \n  Edge cpy1;\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      cpy1=edge[sy][sx][sd][l][i];\n      if (solve_to_kit(r,c,cpy1.y,cpy1.x,cpy1.d))return true;\n     }\n  }\n  return false;\n}\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    rep(i,r)rep(j,c)rep(k,DIR)vis2[i][j][k]=false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n    if (solve_to_kit(r,c,iniy,inix,inidir))cango=true;\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nstruct S{\n  int y,x,ry,rx;\n  int d,rd;\n};\n\nint main(){\n  for(int W,H;cin>>W>>H,W;){\n    int kx,ky,mx,my;\n    char g[16][64];\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>g[i][j];\n\tif(g[i][j]=='K'){\n\t  ky=i;\n\t  kx=j;\n\t}else if(g[i][j]=='M'){\n\t  my=i;\n\t  mx=j;\n\t}\n      }\n    }\n    int d,rd;\n    static int dy[]={-1,0,1,0};\n    static int dx[]={0,1,0,-1};\n    for(int i=0;i<4;i++){\n      if(g[ky+dy[i]][kx+dx[i]]=='.'){\n\td=i;\n      }else if(g[my+dy[i]][mx+dx[i]]=='.'){\n\trd=i;\n      }\n    }\n    static bool p[16][64][4][16][64][4];\n    fill(p[0][0][0][0][0],p[16][0][0][0][0],false);\n    vector<S> v{{ky,kx,my,mx,d,rd}};\n    int a=0;\n    while(!v.empty()){\n      S cs=v.back();\n      if(cs.y==my&&cs.x==mx){\n\tif(cs.ry==ky&&cs.rx==kx){\n\t  a=max(a,2);\n\t}else{\n\t  a=max(a,1);\n\t}\n      }\n      v.pop_back();\n      if(p[cs.y][cs.x][cs.d][cs.ry][cs.rx][cs.rd]++)continue;\n      int ny=cs.y;\n      int nx=cs.x;\n      int nry=cs.ry;\n      int nrx=cs.rx;\n      auto f=[&](int &y,int &x,int d){\n\tfor(;;){\n\t  int ny=y+dy[d];\n\t  int nx=x+dx[d];\n\t  if(g[ny][nx]=='#')break;\n\t  y=ny;\n\t  x=nx;\n\t}\n      };\n      f(ny,nx,cs.d);\n      f(nry,nrx,cs.rd);\n      for(int i=1;i<=3;i+=2){\n\tint nd=(cs.d+i)%4;\n\tint nrd=(cs.rd-i+4)%4;\n\tv.push_back({ny,nx,nry,nrx,nd,nrd});\n      }\n    }\n    cout<<((a==2)?\"He can accomplish his mission.\":\n\t   (a==1)?\"He cannot return to the kitchen.\":\"He cannot bring tea to his master.\")<<endl;\n  }\n}\n\n\t    \n\t    \n\t  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n\nvis[R-1][C-1][DIR-1][R-1][C-1][DIR-1]=false;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double EPS = 1e-12;\n\nint tx[] = {+0,+1,+0,-1};\nint ty[] = {-1,+0,+1,+0};\n\nclass State {\npublic:\n  int x;\n  int y;\n  int cost;\n  int dir;\n  vector<int> commands;\n  State(int x,int y,int cost,int dir)\n    : x(x),y(y),cost(cost),dir(dir) {}\n  State(int x,int y,int cost,int dir,const vector<int>& commands)\n    : x(x),y(y),cost(cost),dir(dir),commands(commands) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int W,H;\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    char stage[20][70];\n    int sx,sy;\n    int gx,gy;\n    for(int y = 0; y < H; y++){\n      char line[70];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(stage[y][x] == 'K'){\n          sx = x;\n          sy = y;\n        }\n        if(stage[y][x] == 'M'){\n          gx = x;\n          gy = y;\n        }\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0));\n    bool visited[20][70][4] = {};\n    int flag = 0;\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(s.x == gx && s.y == gy){\n        flag |= (1<<0);\n        int dx = s.x;\n        int dy = s.y;\n        int dir = (s.dir + 2) % 4;\n        while(true){\n          if(stage[dy + ty[dir]][dx + tx[dir]] == '#'){\n            if(s.commands.size() == 0) break;\n            dir = dir + (s.commands.back() == 0 ? 1 : 3);\n            dir %= 4;\n            s.commands.pop_back();\n          }\n          else{\n            dy = dy + ty[dir];\n            dx = dx + tx[dir];\n          }\n          if(dx == sx && dy == sy){\n            flag |= (1<<1);\n            break;\n          }\n        }\n        continue;     \n      }\n\n      for(int i = 0; i < 4; i++){\n        int dx = tx[s.dir] + s.x;\n        int dy = ty[s.dir] + s.y;\n        if(dy >= H || dx >= W || dy < 0 || dx < 0) continue;\n        if(stage[dy][dx] == '#'){\n          if(!visited[s.y][s.x][(s.dir + 1) % 4]){\n            vector<int> next = s.commands;\n            next.push_back(1);\n            visited[s.y][s.x][(s.dir + 1) % 4] = true;\n            que.push(State(s.x,s.y,s.cost + 1,(s.dir + 1) % 4,next));\n          }\n          if(!visited[s.y][s.x][(s.dir + 3) % 4]){\n            vector<int> next = s.commands;\n            next.push_back(0);\n            visited[s.y][s.x][(s.dir + 3) % 4] = true;\n            que.push(State(s.x,s.y,s.cost + 1,(s.dir + 3) % 4,next));\n          }\n        }\n        else if(stage[dy][dx] == '.'\n                || stage[dy][dx] == 'K'\n                || stage[dy][dx] == 'M'){\n          visited[dy][dx][s.dir] = true;\n          que.push(State(dx,dy,s.cost + 1,s.dir,s.commands));\n        }\n      }\n    }\n\n    if(flag == (1<<2) - 1){\n      printf(\"He can accomplish his mission.\\n\");\n    }\n    else if(flag == (1<<0)){\n      printf(\"He cannot return to the kitchen.\\n\");\n    }\n    else{\n      printf(\"He cannot bring tea to his master.\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nstruct node{\n    int y1,x1,y2,x2,dir1,dir2;\n\tnode(int y1,int x1,int dir1,int y2,int x2,int dir2):y1(y1),x1(x1),dir1(dir1),y2(y2),x2(x2),dir2(dir2){}\n};\n\nstatic bool visited[16][64][4][16][64][5];\n\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int h,w;\n    while(cin>>w>>h,w|h){\n        vs f(h);\n        pii kichen,master;\n        int k_dir,m_dir;\n        REP(i,h){\n            cin>>f[i];\n\t\t}\n        REP(i,h){\n            REP(j,w){\n                if(f[i][j]=='K'){\n                    kichen=make_pair(i,j);\n                    REP(d,4){\n                        int yy=i+dy[d];\n                        int xx=j+dx[d];\n                        if(f[yy][xx]=='.'){\n                            k_dir=d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                if(f[i][j]=='M'){\n                    master=make_pair(i,j);\n                    REP(d,4){\n                        int yy=i+dy[d];\n                        int xx=j+dx[d];\n                        if(f[yy][xx]=='.'){\n                            m_dir=d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<node> q;\n\t\tint sy,sx;\n        for(int i=1;;i++){\n\t\t\tint cy=kichen.first+dy[k_dir]*(i-1);\n\t\t\tint cx=kichen.second+dx[k_dir]*(i-1);\n\t\t\tint ny=kichen.first+dy[k_dir]*i;\n\t\t\tint nx=kichen.second+dx[k_dir]*i;\n            if(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n                sy=cy;\n                sx=cx;\n                break;\n\t\t\t}\n\t\t}\n\t\tREP(i,h)REP(j,w)REP(k,4)REP(l,h)REP(m,w)REP(n,5){\n\t\t\tvisited[i][j][k][l][m][n]=0;\n\t\t}\n\t\tFOR(i,1,3+1){\n\t\t\tq.push(node(sy,sx,k_dir,kichen.first,kichen.second,(k_dir+i)%4));\n\t\t\tvisited[sy][sx][k_dir][kichen.first][kichen.second][(k_dir+i)%4]=1;\n\t\t}\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n\t\t\tfor (int d = 1; d <= 3; d+=2)\n\t\t\t{\n\t\t\t\tvector<pii> points;\n\t\t\t\tint dir1=(cnode.dir1+d)%4;\n\t\t\t\tint sy1,sx1;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint cy=cnode.y1+dy[dir1]*(i-1);\n\t\t\t\t\tint cx=cnode.x1+dx[dir1]*(i-1);\n\t\t\t\t\tint ny=cnode.y1+dy[dir1]*i;\n\t\t\t\t\tint nx=cnode.x1+dx[dir1]*i;\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n\t\t\t\t\t\tsy1=cy;\n\t\t\t\t\t\tsx1=cx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnode.dir2!=4){\n\t\t\t\t\tint dir2=(cnode.dir2+d)%4;\n\t\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\t\tint cy=cnode.y2+dy[(cnode.dir2+2)%4]*(i-1);\n\t\t\t\t\t\tint cx=cnode.x2+dx[(cnode.dir2+2)%4]*(i-1);\n\t\t\t\t\t\tint ny=cnode.y2+dy[(cnode.dir2+2)%4]*i;\n\t\t\t\t\t\tint nx=cnode.x2+dx[(cnode.dir2+2)%4]*i;\n\t\t\t\t\t\tint sidey=cy+dy[dir2%4];\n\t\t\t\t\t\tint sidex=cx+dx[dir2%4];\n\t\t\t\t\t\tif(sidey>=0&&sidex>=0&&sidey<h&&sidex<w&&f[sidey][sidex]=='#'){\n\t\t\t\t\t\t\tpoints.push_back(make_pair(cy,cx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tREP(j,points.size()){\n\t\t\t\t\t\tif(!visited[sy1][sx1][dir1][points[j].first][points[j].second][dir2]){\n\t\t\t\t\t\t\tvisited[sy1][sx1][dir1][points[j].first][points[j].second][dir2]=1;\n\t\t\t\t\t\t\tq.push(node(sy1,sx1,dir1,points[j].first,points[j].second,dir2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!visited[sy1][sx1][dir1][0][0][4]){\n\t\t\t\t\tvisited[sy1][sx1][dir1][0][0][4]=1;\n\t\t\t\t\tq.push(node(sy1,sx1,dir1,0,0,4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ac=false;\n        for(int i=1;;i++){\n\t\t\tint cy=master.first+dy[m_dir]*(i-1);\n\t\t\tint cx=master.second+dx[m_dir]*(i-1);\n\t\t\tint ny=master.first+dy[m_dir]*i;\n\t\t\tint nx=master.second+dx[m_dir]*i;\n            if(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n                sy=cy;\n                sx=cx;\n                break;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++)\n\t\t{\n\t\t\tif(visited[master.first][master.second][(m_dir+i)%4][sy][sx][m_dir]){\n\t\t\t\tac=true;\n\t\t\t}\n\t\t}\n\t\tif(ac){\n            cout<<\"He can accomplish his mission.\"<<endl;\n            goto end;\n\t\t}else{\n            bool flag=false;\n            REP(i,h)REP(j,w)REP(d,5)FOR(d1,1,4){\n\t\t\t\tif(visited[master.first][master.second][(m_dir+d1)%4][i][j][d]){\n                    flag=true;\n                    break;\n\t\t\t\t}\n\t\t\t}\n            if(flag){\n                cout<<\"He cannot return to the kitchen.\"<<endl;\n\t\t\t}else{\n                cout<<\"He cannot bring tea to his master.\"<<endl;\n\t\t\t}\n\t\t}\nend:\n        ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nbool memo[64][16][4][64][16][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint fway;\n\tint tx;\n\tint ty;\n\tint tway;\n};\nint gx, gy;\n\nvector<aa>astack;\n\nbool cangoal;\n\nint gway;\n\nbool check(int fx, int fy,int fway, int tx, int ty, int tway) {\n\n\tif (memo[fx][fy][fway][tx][ty][tway])return false;\n\tmemo[fx][fy][fway][tx][ty][tway] =1;\n\t\n\t//else{\n\n\t\tint nfy = fy + dy[fway];\n\t\tint nfx = fx + dx[fway];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (mp[nfy][nfx]) {\n\t\t\t\tnfx -= dx[fway];\n\t\t\t\tnfy -= dy[fway];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[fway];\n\t\t\tnfx = nfx + dx[fway];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (mp[nty][ntx]) {\n\t\t\t\tntx -= dx[tway];\n\t\t\t\tnty -= dy[tway];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\t\tint atway = (tway + 3) % 4;\n\t\t\t\tint afway = (fway + 3) % 4;\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\t\tint atway = (tway + 1) % 4;\n\t\t\t\tint afway = (fway + 1) % 4;\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\n\t\t\tnty = nty + dy[tway];\n\t\t\tntx = ntx + dx[tway];\n\t\t}\n\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\tint atway = (tway + 3) % 4;\n\t\t\tint afway = (fway + 3) % 4;\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\t\t}\n\n\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\tint atway = (tway + 1) % 4;\n\t\t\tint afway = (fway + 1) % 4;\n\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\t\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\n\t\t\t}\n\t\t}\n\n\t//}\n\treturn false;\n}\n\nint main() {\n\twhile (1) {\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tastack.clear();\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\t\tmp.resize(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tmp[i].resize(W);\n\t\t}\n\n\t\tint sx, sy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t\tif (mp[gy + dy[i]][gx + dx[i]] == 0) {\n\t\t\t\tgway = i;\n\t\t\t}\n\t\t}\n\t\tbool perf = false;\n\t\tfor (int i = 0; i < 4;++i)\n\t\t\tastack.push_back(aa{ sx,sy,sway,sx,sy,i });\n\n\t\twhile (!astack.empty()) {\n\t\t\taa atop(astack.back());\n\t\t\tastack.pop_back();\n\t\t\tif (check(atop.fx, atop.fy,atop.fway, atop.tx, atop.ty, atop.tway)) {\n\t\t\t\tperf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (perf) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (cangoal) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') y += dy[dir], x += dx[dir];\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int x, int y) {\n\trep(i, 4) {\n\t\tif (in[y + dy[i]][x + dx[i]] == ',')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h!=0&&w!=0) {\n\t\trep(i, h) cin >> in[i];\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct state{\n\tint i,j,k; // 行きの y 座標, x 座標, 向き\n};\n\nstruct state2{\n\tint i,j,k,y,x,d; // 行きの y 座標, x 座標, 向き, 帰りの y 座標, x 座標, 向き\n};\n\nint h,w;\nchar B[16][65];\n\nvoid go_straight(int i,int j,int k,int &i2,int &j2){\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j;\n}\n\nvoid turn_left(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+1)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nvoid turn_right(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+3)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='K') sx=j, sy=i, B[i][j]='.';\n\t\t\tif(B[i][j]=='M') gx=j, gy=i, B[i][j]='.';\n\t\t}\n\t\tint gk;\n\t\trep(k,4) if(B[gy+dy[k]][gx+dx[k]]=='.') gk=k;\n\n\t\tbool ok=false;\n\t\t{\n\t\t\tstatic bool vis[16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) vis[i][j][k]=false;\n\n\t\t\tqueue<state> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\tvis[yy][xx][k]=true;\n\t\t\t\t\tQ.push((state){yy,xx,k});\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k;\n\n\t\t\t\tif(i==gy && j==gx){ ok=true; break; }\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tputs(\"He cannot bring tea to his master.\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tok=false;\n\t\t{\n\t\t\tvector<state> from_L[16][64][4],from_R[16][64][4];\n\t\t\trep(i,h) rep(j,w) if(B[i][j]=='.') rep(k,4) {\n\t\t\t\tint y,x,d;\n\t\t\t\tturn_left (i,j,k,y,x,d); from_L[y][x][d].push_back((state){i,j,k});\n\t\t\t\tturn_right(i,j,k,y,x,d); from_R[y][x][d].push_back((state){i,j,k});\n\t\t\t}\n\n\t\t\tstatic bool vis[16][64][4][16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) rep(y,h) rep(x,w) rep(d,4) vis[i][j][k][y][x][d]=false;\n\n\t\t\tqueue<state2> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\trep(kk,4) if(kk!=k) {\n\t\t\t\t\t\tvis[yy][xx][k][sy][sx][kk]=true;\n\t\t\t\t\t\tQ.push((state2){yy,xx,k,sy,sx,kk});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate2 S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k,y=S.y,x=S.x,d=S.d;\n\n\t\t\t\tif(i==gy && j==gx){\n\t\t\t\t\tint yy,xx;\n\t\t\t\t\tgo_straight(gy,gx,gk,yy,xx);\n\t\t\t\t\tif(y==yy && x==xx && d==gk){ ok=true; break; }\n\t\t\t\t}\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\trep(t,from_R[y][x][d].size()){\n\t\t\t\t\tint y2=from_R[y][x][d][t].i;\n\t\t\t\t\tint x2=from_R[y][x][d][t].j;\n\t\t\t\t\tint d2=from_R[y][x][d][t].k;\n\t\t\t\t\tif(!vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\trep(t,from_L[y][x][d].size()){\n\t\t\t\t\tint y2=from_L[y][x][d][t].i;\n\t\t\t\t\tint x2=from_L[y][x][d][t].j;\n\t\t\t\t\tint d2=from_L[y][x][d][t].k;\n\t\t\t\t\tif(!vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ok) puts(\"He can accomplish his mission.\");\n\t\telse   puts(\"He cannot return to the kitchen.\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct seica {\n    int ky, kx, kd, my, mx, md;\n    seica(int _ky, int _kx, int _kd, int _my, int _mx, int _md){\n        ky = _ky;\n        kx = _kx;\n        kd = _kd;\n        my = _my;\n        mx = _mx;\n        md = _md;\n    }\n};\n\n\nint dp[16][64][4][16][64][4];\nP straight[16][64][4];\nint visited[16][64][4];\nint reach[16][64][4];\nint h, w, ky, kx, kd, my, mx, md, cou;\nchar mp[16][64];\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\nvector<pair<P, ll>> pre[16][64][4][4];\npair<P, ll> nxt[16][64][4][4];\nqueue<seica> q;\n\nint getStartDir(int y, int x){\n    REP(i, 4)if(mp[y + dy[i]][x + dx[i]] != '#')return i;\n    return -1;\n}\n\nP goStraight(int y, int x, int d){\n    P ret = MP(y, x);\n    while(mp[ret.FI + dy[d]][ret.SE + dx[d]] != '#'){\n        ret.FI += dy[d];\n        ret.SE += dx[d];\n    }\n    return ret;\n}\n\nvoid calNxt(){\n\tREP(i, h){\n\t\tREP(j, w){\n\t\t\tif(mp[i][j] == '#')continue;\n\t\t\tREP(k, 4) {\n\t\t\t\tstraight[i][j][k] = goStraight(i, j, k);\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, h){\n\t\tREP(j, w){\n\t\t\tif(mp[i][j] == '#')continue;\n\t\t\tREP(k, 4){\n\t\t\t\tnxt[i][j][k][1] = MP(straight[i][j][(k+1)%4], (k+1)%4);\n\t\t\t\tnxt[i][j][k][3] = MP(straight[i][j][(k+3)%4], (k+3)%4);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid calPre(){\n\tREP(i, 16)REP(j,64)REP(k, 4)REP(l, 4)pre[i][j][k][l].clear();\n\n\tqueue<pair<P, ll>> que;\n\tauto nm = straight[my][mx][md];\n\tvisited[nm.FI][nm.SE][md] = cou;\n\tque.push(MP(MP(nm.FI, nm.SE), md));\n\n\twhile(!que.empty()){\n\t\tauto y = que.front().FI.FI;\n\t\tauto x = que.front().FI.SE;\n\t\tauto d = que.front().SE;\n\t\tque.pop();\n\n\t\tnm = straight[y][x][(d+1)%4];\n\t\tpre[nm.FI][nm.SE][(d+1)%4][1].EB(MP(y, x), d);\n\t\tif(visited[nm.FI][nm.SE][(d+1)%4] != cou){\n\t\t\tvisited[nm.FI][nm.SE][(d+1)%4] = cou;\n\t\t\tque.push(MP(MP(nm.FI, nm.SE), (d+1)%4));\n\t\t}\n\t\tnm = straight[y][x][(d+3)%4];\n\t\tpre[nm.FI][nm.SE][(d+3)%4][3].EB(MP(y, x), d);\n\t\tif(visited[nm.FI][nm.SE][(d+3)%4] != cou){\n\t\t\tvisited[nm.FI][nm.SE][(d+3)%4] = cou;\n\t\t\tque.push(MP(MP(nm.FI, nm.SE), (d+3)%4));\n\t\t}\n\t}\n}\n\nvoid move(seica now, int turn){\n\tauto nk = nxt[now.ky][now.kx][now.kd][turn];\n\tauto pm = pre[now.my][now.mx][now.md][4 - turn];\n\n\tREP(i, pm.size()){\n\t\tif(dp[nk.FI.FI][nk.FI.SE][nk.SE][pm[i].FI.FI][pm[i].FI.SE][pm[i].SE] == cou)continue;\n\t\tdp[nk.FI.FI][nk.FI.SE][nk.SE][pm[i].FI.FI][pm[i].FI.SE][pm[i].SE] = cou;\n\t\tq.push(seica(nk.FI.FI, nk.FI.SE, nk.SE, pm[i].FI.FI, pm[i].FI.SE, pm[i].SE));\n\t}\n}\n\nbool canHeBringTea(){\n\tqueue<pair<P, ll>> que;\n\tauto nk = straight[ky][kx][kd];\n\treach[nk.FI][nk.SE][kd] = cou;\n\tque.push(MP(MP(nk.FI, nk.SE), kd));\n\n\twhile(!que.empty()){\n\t\tauto y = que.front().FI.FI;\n\t\tauto x = que.front().FI.SE;\n\t\tauto d = que.front().SE;\n\t\tque.pop();\n\n\t\tif(y == my && x == mx)return true;\n\n\t\tnk = straight[y][x][(d+1)%4];\n\t\tif(reach[nk.FI][nk.SE][(d+1)%4] != cou){\n\t\t\treach[nk.FI][nk.SE][(d+1)%4] = cou;\n\t\t\tque.push(MP(MP(nk.FI, nk.SE), (d+1)%4));\n\t\t}\n\t\tnk = straight[y][x][(d+3)%4];\n\t\tif(reach[nk.FI][nk.SE][(d+3)%4] != cou){\n\t\t\treach[nk.FI][nk.SE][(d+3)%4] = cou;\n\t\t\tque.push(MP(MP(nk.FI, nk.SE), (d+3)%4));\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid solve() {\n\tauto nm = straight[my][mx][md];\n\tauto nk = straight[ky][kx][kd];\n\tbool ok = false;\n\t//cout << \"doal \" << ky << \" \" << kx << \" \" << kd << \" \" << my << \" \" << mx << \" \" << md << endl;\n\t//cout << \"start \" << nm.FI << \" \" << nm.SE << endl;\n\n\tREP(i, 4){\n\t\tif(i == kd)continue;\n\t\tq.push(seica(nk.FI, nk.SE, kd, ky, kx, i));\n\t\tdp[nk.FI][nk.SE][kd][ky][kx][i] = cou;\n\t}\n\n\twhile(!q.empty()){\n\t\tauto now = q.front();q.pop();\n\n\t\t//cout << now.ky << \" \" << now.kx << \" \" << now.kd << \" \" << now.my << \" \" << now.mx << \" \" << now.md << endl;\n\n\t\tif(now.ky == my && now.kx == mx && now.my == nm.FI && now.mx == nm.SE && now.md == md){\n\t\t\tok = true;\n\t\t\twhile(!q.empty())q.pop();\n\t\t\tbreak;\n\t\t}\n\n\t\tmove(now, 1);\n\t\tmove(now, 3);\n\t}\n\n\tif(ok){\n\t\tcout << \"He can accomplish his mission.\" << endl;\n\t}\n\telse if(canHeBringTea()){\n\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\t}\n\telse {\n\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w | h){\n\t\tcou++;\n\n\t\tREP(i, h)REP(j, w){\n\t\t\tcin >> mp[i][j];\n\t\t\tif(mp[i][j] == 'K'){ky = i;kx = j;}\n\t\t\tif(mp[i][j] == 'M'){my = i;mx = j;}\n\t\t}\n\n\t\tkd = getStartDir(ky, kx);\n\t\tmd = getStartDir(my, mx);\n\n\t\tcalNxt();\n\t\tcalPre();\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\tif (!(m[i+dy[(k+2)%4]][j+dx[(k+2)%4]] == '.'||\n\t      m[i+dy[(k+1)%4]][j+dx[(k+1)%4]] == '#'||\n\t      m[i+dy[(k+3)%4]][j+dx[(k+3)%4]] == '#')\n\t    )continue;\n\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t  /*\n\t  rep(ll,2){\n\t    int nndir = (ndir+d[ll])%4;\n\t    if (m[ney+dy[nndir]][nex+dx[nndir]] == '#')\n\t      rev[ney][nex][nndir][ll].pb((Edge){i  ,  j,(ndir+2)%4});\n\t  }\n\t  */\n\n\t}\n      }\n    }\n  }\n}\n\nvoid output(int r,int c,int ry,int rx,int rd,int rl){\n  const char dd[]={'N','E','S','W'};\n  const char aho[]={'R','L'};\n  cout <<\"Outputbegin\"<<endl;\n  cout << aho[rl] << endl;\n  rep(i,r){\n    rep(j,c){\n      if (ry == i && rx == j)cout << dd[rd];\n      else cout << m[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl<<endl;\n}\n\nbool cango;\n\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gx,int gy,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  \n  if (m[sy][sx] == 'M')cango=true;\n  Edge cpy1,cpy2;\n\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      // cout << ry <<\" \" << rx <<\" \" << rd <<\" \" << rl <<\" \" <<\n      //rev[ry][rx][rd][rl].size() <<endl;\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\tif (m[sy][sx] == 'M' &&\n\t    cpy2.y == gy && cpy2.x == gx && cpy2.d == gd){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  //\t  output(r,c,sy,sx,sd,l);\n\t  //\t  cout << cpy1.y <<\" \" << cpy1.x << endl;\n\t  //\t  cout << \"final state \" << cpy2.y <<\" \" << cpy2.x  << \" \" << cpy2.d << endl;\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  //cout << \"output normal\"<<endl;\n\t  //output(r,c,sy,sx,sd,l);\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n      }\n    }\n  }\n  \n  return false;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n\n    char TEST[]={'N','E','S','W'};\n    char TURN[]={'R','L'};\n    /*\n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout <<\"pos \" <<  i<<\" \" << j <<\" dir \" << TEST[k] <<\" turn to \" <<\n\t\tTURN[l] ;\n\t      cout << \" will go \" << \n\t\trev[i][j][k][l][m].y <<\" \" << rev[i][j][k][l][m].x <<\" dir \" \n\t\t   <<TEST[rev[i][j][k][l][m].d] << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n    */\n\n\n    /*    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout << i <<\" \" << j <<\" \" << TEST[k] <<\" \" \n\t\t   <<TURN[l] << endl; \n\t      output(r,c,rev[i][j][k][l][m].y,rev[i][j][k][l][m].x,\n\t\t     rev[i][j][k][l][m].d,l);\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define max_H 16\n#define max_W 64\n\nenum DIR{\n\tNorth,\n\tEast,\n\tSouth,\n\tWest,\n};\n\nstruct Info{\n\tInfo(){\n\t\trow = 0;\n\t\tcol = 0;\n\t\tdir = North;\n\t}\n\tInfo(int arg_row,int arg_col,DIR arg_dir){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tdir = arg_dir;\n\t}\n\tvoid set(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n\tDIR dir;\n};\n\nstruct Data{\n\tData(int arg_go_row,int arg_go_col,DIR arg_go_dir,int arg_return_row,int arg_return_col,DIR arg_return_dir){\n\t\tgo_row = arg_go_row;\n\t\tgo_col = arg_go_col;\n\t\tgo_dir = arg_go_dir;\n\t\treturn_row = arg_return_row;\n\t\treturn_col = arg_return_col;\n\t\treturn_dir = arg_return_dir;\n\t}\n\tint go_row,go_col,return_row,return_col;\n\tDIR go_dir,return_dir;\n};\n\nint H,W;\n\nDIR dir_array[4] = {North,East,South,West};\nint diff_row[4] = {-1,0,1,0},diff_col[4] = {0,1,0,-1};\nchar base_map[max_H][max_W+1];\nbool first_check[max_H][max_W][4],check[max_H][max_W][4][max_H][max_W][4];\nInfo start,goal;\nvector<Info> L_ORIGIN[max_H][max_W][4],R_ORIGIN[max_H][max_W][4];\n\nInfo get_next_state(int current_row,int current_col,DIR to_dir){\n\n\tInfo ret;\n\tret.set(current_row,current_col);\n\tret.dir = to_dir;\n\n\twhile(true){\n\n\t\tif(base_map[ret.row+diff_row[to_dir]][ret.col+diff_col[to_dir]] != '.')break;\n\n\t\tret.row += diff_row[to_dir];\n\t\tret.col += diff_col[to_dir];\n\t}\n\treturn ret;\n}\n\nDIR get_Left(DIR dir){\n\n\treturn dir_array[(dir-1+4)%4];\n}\n\nDIR get_Right(DIR dir){\n\n\treturn dir_array[(dir+1)%4];\n}\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tscanf(\"%s\",base_map[row]);\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] == 'K'){\n\n\t\t\t\tstart.set(row,col);\n\t\t\t\tbase_map[row][col] = '.';\n\n\t\t\t}else if(base_map[row][col] == 'M'){\n\n\t\t\t\tgoal.set(row,col);\n\t\t\t\tbase_map[row][col] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tfirst_check[row][col][a] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo tmp;\n\tint adj_row,adj_col;\n\tqueue<Info> first_Q;\n\n\tfor(int i = 0; i < 4; i++){\n\n\t\tadj_row = start.row+diff_row[i];\n\t\tadj_col = start.col+diff_col[i];\n\n\t\tif(base_map[adj_row][adj_col] != '.')continue;\n\n\t\ttmp = get_next_state(start.row,start.col,dir_array[i]);\n\t\tfirst_check[tmp.row][tmp.col][tmp.dir] = true;\n\t\tfirst_Q.push(Info(tmp.row,tmp.col,tmp.dir));\n\t}\n\n\tbool FLG = false;\n\tDIR next_dir;\n\n\twhile(!first_Q.empty()){\n\n\t\tif(first_Q.front().row == goal.row && first_Q.front().col == goal.col){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnext_dir = get_Left(first_Q.front().dir);\n\t\ttmp = get_next_state(first_Q.front().row,first_Q.front().col,next_dir);\n\t\tif(!first_check[tmp.row][tmp.col][tmp.dir]){\n\t\t\tfirst_check[tmp.row][tmp.col][tmp.dir] = true;\n\t\t\tfirst_Q.push(Info(tmp.row,tmp.col,tmp.dir));\n\t\t}\n\n\t\tnext_dir = get_Right(first_Q.front().dir);\n\t\ttmp = get_next_state(first_Q.front().row,first_Q.front().col,next_dir);\n\t\tif(!first_check[tmp.row][tmp.col][tmp.dir]){\n\t\t\tfirst_check[tmp.row][tmp.col][tmp.dir] = true;\n\t\t\tfirst_Q.push(Info(tmp.row,tmp.col,tmp.dir));\n\t\t}\n\n\t\tfirst_Q.pop();\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\treturn;\n\t}\n\n\tDIR first_dir;\n\tfor(int i = 0; i < 4; i++){\n\n\t\tadj_row = goal.row+diff_row[i];\n\t\tadj_col = goal.col+diff_col[i];\n\t\tif(base_map[adj_row][adj_col] == '.'){\n\t\t\tfirst_dir = dir_array[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tL_ORIGIN[row][col][a].clear();\n\t\t\t\tR_ORIGIN[row][col][a].clear();\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(base_map[row][col] != '.')continue;\n\t\t\tfor(int a = 0; a < 4; a++){\n\n\t\t\t\tnext_dir = get_Left(dir_array[a]);\n\t\t\t\ttmp = get_next_state(row,col,next_dir);\n\t\t\t\tL_ORIGIN[tmp.row][tmp.col][tmp.dir].push_back(Info(row,col,dir_array[a]));\n\n\t\t\t\tnext_dir = get_Right(dir_array[a]);\n\t\t\t\ttmp = get_next_state(row,col,next_dir);\n\t\t\t\tR_ORIGIN[tmp.row][tmp.col][tmp.dir].push_back(Info(row,col,dir_array[a]));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < 4; c++){\n\t\t\t\tfor(int d = 0; d < H; d++){\n\t\t\t\t\tfor(int e = 0; e < W; e++){\n\t\t\t\t\t\tfor(int f = 0; f < 4; f++){\n\t\t\t\t\t\t\tcheck[a][b][c][d][e][f] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Data> Q;\n\tInfo go_tmp,return_tmp;\n\n\tfor(int i = 0; i < 4; i++){\n\n\t\tadj_row = start.row+diff_row[i];\n\t\tadj_col = start.col+diff_col[i];\n\t\tif(base_map[adj_row][adj_col] != '.')continue;\n\n\t\tgo_tmp = get_next_state(start.row,start.col,dir_array[i]);\n\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tif(k == i)continue;\n\n\t\t\tcheck[go_tmp.row][go_tmp.col][go_tmp.dir][start.row][start.col][dir_array[k]] = true;\n\t\t\tQ.push(Data(go_tmp.row,go_tmp.col,go_tmp.dir,start.row,start.col,dir_array[k]));\n\t\t}\n\t}\n\n\tFLG = false;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().go_row == goal.row && Q.front().go_col == goal.col){\n\n\t\t\ttmp = get_next_state(goal.row,goal.col,first_dir);\n\n\t\t\tif(Q.front().return_row == tmp.row && Q.front().return_col == tmp.col && Q.front().return_dir == tmp.dir){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnext_dir = get_Left(Q.front().go_dir);\n\t\tgo_tmp = get_next_state(Q.front().go_row,Q.front().go_col,next_dir);\n\n\t\tfor(int i = 0; i < R_ORIGIN[Q.front().return_row][Q.front().return_col][Q.front().return_dir].size(); i++){\n\n\t\t\treturn_tmp = R_ORIGIN[Q.front().return_row][Q.front().return_col][Q.front().return_dir][i];\n\n\t\t\tif(!check[go_tmp.row][go_tmp.col][go_tmp.dir][return_tmp.row][return_tmp.col][return_tmp.dir]){\n\n\t\t\t\tcheck[go_tmp.row][go_tmp.col][go_tmp.dir][return_tmp.row][return_tmp.col][return_tmp.dir] = true;\n\t\t\t\tQ.push(Data(go_tmp.row,go_tmp.col,go_tmp.dir,return_tmp.row,return_tmp.col,return_tmp.dir));\n\t\t\t}\n\t\t}\n\n\t\tnext_dir = get_Right(Q.front().go_dir);\n\t\tgo_tmp = get_next_state(Q.front().go_row,Q.front().go_col,next_dir);\n\n\t\tfor(int i = 0; i < L_ORIGIN[Q.front().return_row][Q.front().return_col][Q.front().return_dir].size(); i++){\n\n\t\t\treturn_tmp = L_ORIGIN[Q.front().return_row][Q.front().return_col][Q.front().return_dir][i];\n\n\t\t\tif(!check[go_tmp.row][go_tmp.col][go_tmp.dir][return_tmp.row][return_tmp.col][return_tmp.dir]){\n\n\t\t\t\tcheck[go_tmp.row][go_tmp.col][go_tmp.dir][return_tmp.row][return_tmp.col][return_tmp.dir] = true;\n\t\t\t\tQ.push(Data(go_tmp.row,go_tmp.col,go_tmp.dir,return_tmp.row,return_tmp.col,return_tmp.dir));\n\t\t\t}\n\t\t}\n\n\t\tQ.pop();\n\t}\n\n\tif(FLG){\n\t\tprintf(\"He can accomplish his mission.\\n\");\n\t}else{\n\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nint solve(int h, int w, vector<vector<char> > const & f) {\n    // prepare\n    const int dy[4] = { 0, -1, 0, 1 };\n    const int dx[4] = { 1, 0, -1, 0 };\n    auto r = [](int d) { return (d + 1) % 4; };\n    auto l = [](int d) { return (d - 1 + 4) % 4; };\n    int start_y, start_x, goal_y, goal_x;\n    repeat (y, h) {\n        repeat (x, w) {\n            if (f[y][x] == 'K') {\n                start_y = y;\n                start_x = x;\n            }\n            if (f[y][x] == 'M') {\n                goal_y = y;\n                goal_x = x;\n            }\n        }\n    }\n    int start_d;\n    repeat (d, 4) {\n        int y = start_y + dy[d];\n        int x = start_x + dx[d];\n        if (f[y][x] != '#') {\n            start_d = d;\n        }\n    }\n    int goal_d;\n    repeat (d, 4) {\n        int y = goal_y + dy[d];\n        int x = goal_x + dx[d];\n        if (f[y][x] != '#') {\n            goal_d = d;\n        }\n    }\n    // search\n    set<tuple<int, int, int, int, int, int> > used;\n    queue<tuple<int, int, int, int, int, int> > que;\n    repeat (d, 4) {\n        auto it = make_tuple(start_y, start_x, start_d, start_y, start_x, d);\n        used.insert(it);\n        que.push(it);\n    }\n    int result = 0;\n    auto push = [&](int y1, int x1, int d1, int y2, int x2, int d2, char prev_d2) {\n        if (y1 == goal_y and x1 == goal_x) {\n            setmax(result, 1);\n            if (y2 == goal_y and x2 == goal_x and prev_d2 == goal_d) {\n                setmax(result, 2);\n            }\n        }\n        auto it = make_tuple(y1, x1, d1, y2, x2, d2);\n        if (not used.count(it)) {\n            used.insert(it);\n            que.push(it);\n        }\n    };\n    while (not que.empty() and result != 2) {\n        int y1, x1, d1, y2, x2, d2;\n        tie(y1, x1, d1, y2, x2, d2) = que.front();\n        que.pop();\n        while (f[y1 + dy[d1]][x1 + dx[d1]] != '#') {\n            y1 += dy[d1];\n            x1 += dx[d1];\n        }\n        push(y1, x1, r(d1), -1, -1, -1, -1);\n        push(y1, x1, l(d1), -1, -1, -1, -1);\n        if (d2 == -1) continue;\n        while (f[y2][x2] != '#') {\n            if (f[y2 + dy[r(d2)]][x2 + dx[r(d2)]] == '#') {\n                push(y1, x1, r(d1), y2, x2, r(d2), d2);\n            }\n            if (f[y2 + dy[l(d2)]][x2 + dx[l(d2)]] == '#') {\n                push(y1, x1, l(d1), y2, x2, l(d2), d2);\n            }\n            y2 -= dy[d2];\n            x2 -= dx[d2];\n        }\n    }\n    return result;\n}\n\nint main() {\n    while (true) {\n        int w, h; scanf(\"%d%d\", &w, &h);\n        if (w == 0 and h == 0) break;\n        auto f = vectors(h, w, char());\n        repeat (y, h) repeat (x, w) scanf(\" %c\", &f[y][x]);\n        int result = solve(h, w, f);\n        printf(\"%s\\n\",\n                result == 0 ? \"He cannot bring tea to his master.\" :\n                result == 1 ? \"He cannot return to the kitchen.\" :\n                              \"He can accomplish his mission.\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <unordered_set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    int x, y, d;\n    S() {}\n    S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const S& p, const S& q) {\n    return (sig(p) << 16) | sig(q);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\nint sx, sy, sd, tx, ty, td;\nunordered_set<int> reach_h, acc_h;\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\nbool reach_r(const S& cur) {\n    if (cur.x == tx && cur.y == ty) return true;\n    const int si = sig(cur);\n    if (reach_h.count(si)) return false;\n    reach_h.insert(si);\n    int dd = 1;\n    rep (_, 2) {\n        if (reach_r(forward(cur.x, cur.y, (cur.d+dd)%4))) return true;\n        dd += 2;\n    }\n    return false;\n}\n\nbool reach() {\n    reach_h.clear();\n    return reach_r(forward(sx, sy, sd));\n}\n\nbool acc_r(const S& cur, const S& rev);\n\nbool move(const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return false;\n    for (;;) {\n        const int si = sig(l, S(x, y, d));\n        if (acc_h.count(si) == 0) {\n            acc_h.insert(si);\n            if (acc_r(l, S(x, y, d))) return true;\n        }\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n    return false;\n}\n\nbool acc_r(const S& cur, const S& rev) {\n    if (cur.x == tx && cur.y == ty\n            && rev.x == tx && rev.y == ty && rev.d == td) {\n        return true;\n    }\n    int dd = 1;\n    rep (_, 2) {\n        if (move(forward(cur.x, cur.y, (cur.d+dd)%4),\n                rev.x, rev.y, (rev.d+dd)%4)) return true;\n        dd += 2;\n    }\n    return false;\n}\n\nbool accomplish() {\n    acc_h.clear();\n    const S st = forward(sx, sy, sd);\n    rep (d, 4) if (move(st, sx, sy, d)) return true;\n    return false;\n}\n\nvoid solve() {\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        sx = i, sy = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') sd = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        tx = i, ty = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') td = d;\n    }\n    if (!reach()) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish()) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint h,w,kx,ky,mx,my,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nbool visited[16][64][4];\nbool can[16][64][4][16][64][4];\nbool bring,ret;\nstring board[16];\nvoid dfs(int ax,int ay,int ad,int bx,int by,int bd){\n\tif(can[ax][ay][ad][bx][by][bd]) return;\n\tcan[ax][ay][ad][bx][by][bd]=true;\n\t//printf(\"a=(%d,%d),b=(%d,%d),di=%d\\n\",ax,ay,bx,by,di);\n\tif(ax==mx&&ay==my&&ax==bx&&ay==by&&board[ax+dx[ad]][ay+dy[ad]]=='#'&&board[bx-dx[bd]][by-dy[bd]]!='#') ret=true;\n\tif(board[ax+dx[ad]][ay+dy[ad]]!='#') dfs(ax+dx[ad],ay+dy[ad],ad,bx,by,bd);\n\tif(board[bx+dx[bd]][by+dy[bd]]!='#') dfs(ax,ay,ad,bx+dx[bd],by+dy[bd],bd);\n\tif(board[ax+dx[ad]][ay+dy[ad]]=='#'){\n\t\tint d1=(bd+1)%4,d2=(bd+3)%4;\n\t\tif(board[bx+dx[d1]][by+dy[d1]]=='#') dfs(ax,ay,(ad+3)%4,bx,by,d2);\n\t\tif(board[bx+dx[d2]][by+dy[d2]]=='#') dfs(ax,ay,(ad+1)%4,bx,by,d1);\n\t}\n}\nvoid dfs1(int x,int y,int di){\n\tif(visited[x][y][di]) return;\n\tvisited[x][y][di]=true;\n\tif(x==mx&&y==my) bring=true;\n\tif(board[x+dx[di]][y+dy[di]]!='#'){\n\t\tdfs1(x+dx[di],y+dy[di],di);\n\t}else{\n\t\tdfs1(x,y,(di+1)%4);\n\t\tdfs1(x,y,(di+3)%4);\n\t}\n}\nvoid init(){\n\trep(i,h) rep(j,w) rep(ad,4) rep(k,h) rep(l,w) rep(bd,4) can[i][j][ad][k][l][bd]=false;\n\trep(i,h) rep(j,w) rep(di,4) visited[i][j][di]=false;\n\tbring=false;\n\tret=false;\n}\nint main(){\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(h==0) break;\n\t\trep(i,h) cin>>board[i];\n\t\tinit();\n\t\trep(i,h) rep(j,w){\n\t\t\tif(board[i][j]=='K') kx=i,ky=j;\n\t\t\tif(board[i][j]=='M') mx=i,my=j;\n\t\t}\n\t\tint kd;\n\t\trep(i,4) if(board[kx+dx[i]][ky+dy[i]]!='#') kd=i;\n\t\tdfs1(kx,ky,kd);\n\t\trep(i,4) dfs(kx,ky,kd,kx,ky,i);\n\t\tif(!bring) puts(\"He cannot bring tea to his master.\");\n\t\telse if(!ret) puts(\"He cannot return to the kitchen.\");\n\t\telse puts(\"He can accomplish his mission.\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int y,x,ry,rx,d,rd;\n};\n\nstruct SS{\n  int y,x,d;\n};\n\nint main(){\n  for(int W,H;cin>>W>>H,W;){\n    char g[16][64];\n    int y,x;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>g[i][j];\n\tif(g[i][j]=='K'){\n\t  y=i;\n\t  x=j;\n\t}\n      }\n    }\n    int dy[]={-1,0,1,0};\n    int dx[]={0,1,0,-1};\n    int d;\n    for(d=0;g[y+dy[d]][x+dx[d]]=='#';d++);\n    vector<S> v;\n    vector<SS> vs{{y,x,d}};\n    for(int i=0;i<4;i++){\n      v.push_back({y,x,y,x,d,i});\n    }\n    static bool p[16][64][16][64][4][4];\n    bool ps[16][64][4]={};\n    fill(p[0][0][0][0][4],p[16][0][0][0][4],false);\n    bool reach=false,ret=false;\n    while(!vs.empty()){\n      auto cs=vs.back();\n      reach|=g[cs.y][cs.x]=='M';\n      vs.pop_back();\n      if(ps[cs.y][cs.x][cs.d]++)continue;\n      int ny,nx;\n      for(ny=cs.y,nx=cs.x;g[ny+dy[cs.d]][nx+dx[cs.d]]!='#';ny+=dy[cs.d],nx+=dx[cs.d]);\n      for(int i=1;i<=3;i+=2){\n\tvs.push_back({ny,nx,(cs.d+i)%4});\n      }\n    }\n\n    while(!v.empty()){\n      S cs=v.back();\n      v.pop_back();\n      if(p[cs.y][cs.x][cs.ry][cs.rx][cs.d][cs.rd]++)continue;\n      int ny,nx;\n      for(ny=cs.y,nx=cs.x;g[ny+dy[cs.d]][nx+dx[cs.d]]!='#';ny+=dy[cs.d],nx+=dx[cs.d]);\n\n      for(int rny=cs.ry,rnx=cs.rx;g[rny][rnx]!='#';rny+=dy[cs.rd],rnx+=dx[cs.rd]){\n\tret|=g[ny][nx]=='M'&&g[rny][rnx]=='M'&&g[rny-dy[cs.rd]][rnx-dx[cs.rd]]!='#';\n\tfor(int i=1;i<=3;i+=2){\n\t  if(g[rny+dy[(cs.rd+i+2)%4]][rnx+dx[(cs.rd+i+2)%4]]=='#'){\n\t    v.push_back({ny,nx,rny,rnx,(cs.d+i)%4,(cs.rd+i)%4});\n\t  }\n\t}\n      }\n    }\n    cout<<(!reach?\"He cannot bring tea to his master.\":\n\t   !ret?\"He cannot return to the kitchen.\":\n\t   \"He can accomplish his mission.\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct state{\n\tint i,j,k; // 行きの y 座標, x 座標, 向き\n};\n\nstruct state2{\n\tint i,j,k,y,x,d; // 行きの y 座標, x 座標, 向き, 帰りの y 座標, x 座標, 向き\n};\n\nint h,w;\nchar B[16][65];\n\nvoid go_straight(int i,int j,int k,int &i2,int &j2){\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j;\n}\n\nvoid turn_left(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+1)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nvoid turn_right(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+3)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='K') sx=j, sy=i, B[i][j]='.';\n\t\t\tif(B[i][j]=='M') gx=j, gy=i, B[i][j]='.';\n\t\t}\n\t\tint gk;\n\t\trep(k,4) if(B[gy+dy[k]][gx+dx[k]]=='.') gk=k;\n\n\t\tbool ok=false;\n\t\t{\n\t\t\tstatic bool vis[16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) vis[i][j][k]=false;\n\n\t\t\tqueue<state> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\tvis[yy][xx][k]=true;\n\t\t\t\t\tQ.push((state){yy,xx,k});\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k;\n\n\t\t\t\tif(i==gy && j==gx){ ok=true; break; }\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) puts(\"He cannot bring tea to his master.\");\n\n\t\tok=false;\n\t\t{\n\t\t\tstatic bool vis[16][64][4][16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) rep(y,h) rep(x,w) rep(d,4) vis[i][j][k][y][x][d]=false;\n\n\t\t\tqueue<state2> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\trep(kk,4) if(kk!=k) {\n\t\t\t\t\t\tvis[yy][xx][k][sy][sx][kk]=true;\n\t\t\t\t\t\tQ.push((state2){yy,xx,k,sy,sx,kk});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate2 S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k,y=S.y,x=S.x,d=S.d;\n\n\t\t\t\tif(i==gy && j==gx){\n\t\t\t\t\tint yy,xx;\n\t\t\t\t\tgo_straight(gy,gx,gk,yy,xx);\n\t\t\t\t\tif(y==yy && x==xx && d==gk){ ok=true; break; }\n\t\t\t\t}\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\trep(y2,h) rep(x2,w) rep(d2,4) if(B[y2][x2]=='.') {\n\t\t\t\t\tint yy,xx,dd;\n\t\t\t\t\tturn_right(y2,x2,d2,yy,xx,dd);\n\t\t\t\t\tif(yy==y && xx==x && dd==d && !vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\trep(y2,h) rep(x2,w) rep(d2,4) if(B[y2][x2]=='.') {\n\t\t\t\t\tint yy,xx,dd;\n\t\t\t\t\tturn_left(y2,x2,d2,yy,xx,dd);\n\t\t\t\t\tif(yy==y && xx==x && dd==d && !vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ok) puts(\"He can accomplish his mission.\");\n\t\telse   puts(\"He cannot return to the kitchen.\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\tcout << x << \" \" << y << endl;\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tcout << \"i:\" << i << endl;\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tcout << sy << \" \" << sx << endl;\n\t\tcout << gy << \" \" << gx << endl;\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct State{\n    int y,x,dir;\n};\n\nusing pi = pair<int,int>;\nusing ps = pair<State,State>;\n\nconst int dx[4]={1,0,-1,0}, dy[4]={0,-1,0,1};\nconst string ng = \"He cannot bring tea to his master.\";\nconst string half = \"He cannot return to the kitchen.\";\nconst string ok = \"He can accomplish his mission.\";\n\nconst int H=16, W=64;\n\nint w,h;\nstring s[H];\n\nbool dp[H][W][4][H][W][4];\n\ninline bool IN(int y, int x)\n{\n    return 0<=y && y<h && 0<=x && x<w;\n}\n\nint main()\n{\n    while(cin >>w >>h,w)\n    {\n        rep(i,h) cin >>s[i];\n\n        State start,goal;\n        rep(i,h)rep(j,w)\n        {\n            if(s[i][j]=='K')\n            {\n                rep(k,4)if(s[i+dy[k]][j+dx[k]]=='.') start = {i,j,k};\n            }\n            if(s[i][j]=='M')\n            {\n                rep(k,4)if(s[i+dy[k]][j+dx[k]]=='.') goal = {i,j,k};\n            }\n        }\n\n        bool forward = false, backward = false;\n        memset(dp,0,sizeof(dp));\n        queue<ps> que;\n        rep(i,4)\n        {\n            dp[start.y][start.x][start.dir][start.y][start.x][(start.dir+i)%4]=true;\n            que.push({start,{start.y,start.x,(start.dir+i)%4}});\n        }\n        while(!que.empty())\n        {\n            ps now=que.front();\n            que.pop();\n\n            State p=now.fi, q=now.se;\n            // printf(\" (%d %d %d) (%d %d %d)\\n\", p.y,p.x,p.dir,q.y,q.x,q.dir);\n            while(s[p.y+dy[p.dir]][p.x+dx[p.dir]]!='#')\n            {\n                p.y += dy[p.dir];\n                p.x += dx[p.dir];\n            }\n            if(p.x==goal.x && p.y==goal.y) forward = true;\n\n            for(int dd:vector<int>({1,3}))\n            {\n                if(!dp[p.y][p.x][(p.dir+dd)%4][0][0][0])\n                {\n                    dp[p.y][p.x][(p.dir+dd)%4][0][0][0] = true;\n                    que.push({{p.y,p.x,(p.dir+dd)%4},{0,0,0}});\n                }\n            }\n\n            if(q.x!=0)\n            {\n                while(s[q.y][q.x]!='#')\n                {\n                    for(int dd:vector<int>({1,3}))\n                    {\n                        if(s[q.y+dy[(q.dir+dd)%4]][q.x+dx[(q.dir+dd)%4]]=='#')\n                        {\n                            if(!dp[p.y][p.x][(p.dir+dd)%4][q.y][q.x][(q.dir+dd)%4])\n                            {\n                                dp[p.y][p.x][(p.dir+dd)%4][q.y][q.x][(q.dir+dd)%4] = true;\n                                que.push({{p.y,p.x,(p.dir+dd)%4},{q.y,q.x,(q.dir+dd)%4}});\n                            }\n                        }\n                    }\n\n                    q.y -= dy[q.dir];\n                    q.x -= dx[q.dir];\n                    if(p.x==goal.x && p.y==goal.y && q.x==goal.x && q.y==goal.y && q.dir==goal.dir) backward = true;\n                }\n            }\n        }\n\n        string ans = ng;\n        if(forward && backward) ans = ok;\n        else if(forward) ans = half;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_M, wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_M = wall_dir_at_K = vector< int >();\n\t\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\tif (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\tif (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\tfor_(d,0,4) {\n\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\tif (home_map[y][x] == 'M') wall_dir_at_M.push_back(d);\n\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\tgoal_dir = d;\n\t\t\t\t} else {\n\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\tstart_dir = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nstruct State {\n\tint id, dir;\n\tint rev_id, rev_dir;\n};\n\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< pii > que;\n\tque.push(pii(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tif (p.first == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[p.first][p.second][c], nxt_dir = changeDirection(p.second, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(pii(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(State{start_id, start_dir, 0, d});\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tif (s.id == 1023 && s.rev_id == goal_id && s.rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c), nxt_rev_dir = changeDirection(s.rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[s.rev_id][s.rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(State{nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canDo()) {\n\t\tputs(\"He can accomplish his mission.\");\n\t} else {\n\t\tif (canReachMaster()) puts(\"He cannot return to the kitchen.\");\n\t\telse puts(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\n\t\t\tvisited[y][x][dir] = true;\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, mx, my;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, 0);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec(mx, my, 0);\n\n\t\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[sy][sx][dir];\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pag;\ntypedef pair<pag,pag> sit;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n// »ÝÌÊu©çßéÆ«ÉAæè¤éOÌêðñ\nvector<pag> backTable[2][4][16][64];\n// »ÝÌÊu©çiÞÆ«ÉAæè¤éÌê\npag goTable[2][4][16][64];\n// ·ÅÉÊßµ½ê\nbool vis[4][16][64][4][16][64];\n// ¡ÌóÔ©çS[Ößêé©\nbool isGoal[4][16][64];\nbool used[4][101][101];\n\nint H,W;\nchar field[101][101];\nint sx,sy;\nint sag;\nint gx,gy;\nint gag;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nvoid calcGoAndBackTable(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<4;k++){\n                // ¶©EÉûü]·µÄAOiµ½ ÆÌêðßé\n                // ¶\n                {\n                    int nag=(k-1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[0][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // E\n                {\n                    int nag=(k+1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[1][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // »ÝÌü«Ì½ÎÖßÁ½ãûü]··é\n                int backAg=(k+2)%4;\n                int ny=i;\n                int nx=j;\n                while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                    // ±±Å¶ÉûüðÏ¦éêÆEÉûüðÏ¦éêÅêí¯\n                    // ¶\n                    {\n                        int nag=(k-1+4)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[0][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    // E\n                    {\n                        int nag=(k+1)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[1][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    ny+=dy[backAg];\n                    nx+=dx[backAg];\n                }\n            }\n        }\n    }\n}\n// X^[gn_©çÔÉvZµÄ¢­\nint bfs(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return 2;\n    for(int cnt=0;cnt<4;cnt++){\n    memset(vis,0,sizeof(vis));\n    priority_queue<sit> pq;\n    // X^[gn_ðpush\n    pq.push(sit(pag(pii(psy,psx),pang),pag(pii(sy,sx),(cnt))));\n    vis[pang][psy][psx][sag][sy][sx]=true;\n    while(pq.size()){\n        sit cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.first.second;\n        int gpy=cur.first.first.first;\n        int gang=cur.first.second;\n        int bpx=cur.second.first.second;\n        int bpy=cur.second.first.first;\n        int bang=cur.second.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            res=max(res,1);\n            if(isGoal[bang][bpy][bpx]){\n                res=max(res,2);\n            }\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            // ßéÓ¾¯vZ\n            for(int j=0;j<backTable[i][bang][bpy][bpx].size();j++){\n                pag nbpag=backTable[i][bang][bpy][bpx][j];\n                // ngpagÆnbpagÌîñ©çÉ¢¯éê\n                if(vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second])\n                    continue;\n                vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second]=true;\n                pq.push(sit(ngpag,nbpag));\n            }\n        }\n    }\n    }\n    // 3ÂÌÇÌóÔÉÈé©`FbN\n    return res;\n}\n\nbool bfs2(int psy,int psx,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return true;\n    memset(used,0,sizeof(used));\n    priority_queue<pag> pq;\n    // X^[gn_ðpush\n    pq.push(pag(pii(psy,psx),pang));\n    used[pang][psy][psx]=true;\n    while(pq.size()){\n        pag cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.second;\n        int gpy=cur.first.first;\n        int gang=cur.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            return true;\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            if(used[ngpag.second][ngpag.first.first][ngpag.first.second])\n                continue;\n            used[ngpag.second][ngpag.first.first][ngpag.first.second]=true;\n            pq.push(ngpag);\n        }\n    }\n    return false;\n}\n\nvoid input(){\n    // startÆgoalÌÊuðè\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>field[i][j];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='K'){\n                field[i][j]='.';\n                sy=i;sx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')sag=k;\n                }\n            }\n            else if(field[i][j]=='M'){\n                field[i][j]='.';\n                gy=i;gx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')gag=k;\n                }\n            }\n        }\n    }\n}\nvoid init(){\n    memset(isGoal,0,sizeof(isGoal));\n    for(int i=0;i<2;i++)for(int j=0;j<4;j++)\n        for(int k=0;k<16;k++)for(int l=0;l<64;l++)\n            backTable[i][j][k][l].clear();\n}\nint main(){\n    while(cin>>W>>H&&(W|H)){\n        // ú»\n        init();\n        input();\n        calcGoAndBackTable();\n        // S[ÖßêéêðvZ\n        {\n            int cy=gy;\n            int cx=gx;\n            int cag=gag;\n            isGoal[cag][cy][cx]=true;\n            while(field[cy][cx]!='#'){\n                //isGoal[cag][cy][cx]=true;\n                cy+=dy[gag];\n                cx+=dx[gag];\n            }\n            cy-=dy[gag];\n            cx-=dx[gag];\n            isGoal[cag][cy][cx]=true;\n        }\n        // startn_©ç··ßÄ¨­\n        int psy=sy;\n        int psx=sx;\n        int pang=sag;\n        while(psy>=0&&psx>=0&&psy<H&&psx<W&&field[psy][psx]!='#'){\n            psy+=dy[sag];\n            psx+=dx[sag];\n        }\n        // ß·\n        psy-=dy[sag];\n        psx-=dx[sag];\n        int res=bfs(psx,psy,pang);\n        res=max(res,(int)bfs2(psx,psy,pang));\n        if(res==0)\n            cout<<\"He cannot bring tea to his master.\"<<endl;\n        else if(res==1)\n            cout<<\"He cannot return to the kitchen.\"<<endl;\n        else if(res==2)\n            cout<<\"He can accomplish his mission.\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nenum {NG, HF, OK};\nenum {TO, BACK};\n\nconst string message[] = {\n\t\"He cannot bring tea to his master.\",\n\t\"He cannot return to the kitchen.\",\n\t\"He can accomplish his mission.\"\n};\n\nstruct state {\n\tint x, y, d;\n\tstate(int x_, int y_, int d_):x(x_), y(y_), d(d_) {}\n};\n\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 64;\nconstexpr int D = sizeof(dx) / sizeof(int);\nconstexpr int HF_X = 1;\nconstexpr int HF_Y = MAX_H + 1;\n\nint h, w;\nstring field[MAX_H + 3];\n\nint sx, sy, sd;\nint gd;\nbool visited[MAX_W][MAX_H][D][MAX_W][MAX_H][D];\n\nvector<state> move_back(state s, int turn) {\n\tconst int dir = (s.d + 2) % D;\n\ts.d = (s.d + turn + D) % D;\n\n\tvector<state> res;\n\tdo {\n\t\tif(field[s.y + dy[s.d]][s.x + dx[s.d]] == '#') {\n\t\t\tres.emplace_back(s);\n\t\t}\n\n\t\ts.x += dx[dir];\n\t\ts.y += dy[dir];\n\n\t} while(field[s.y][s.x] != '#');\n\n\tres.emplace_back(state(HF_X, HF_Y, s.d));\n\treturn res;\n}\n\nint dfs(array<state, 2> ss) {\n\tconst state tmp_back = ss[BACK];\n\n\tint sign = 1;\n\tfor(auto &s : ss) {\n\t\twhile(field[s.y + dy[s.d] * sign][s.x + dx[s.d] * sign] != '#') {\n\t\t\ts.x += dx[s.d] * sign;\n\t\t\ts.y += dy[s.d] * sign;\n\t\t}\n\t\tsign = -sign;\n\t}\n\n\tif(field[ss[TO].y][ss[TO].x] == 'M' && field[ss[BACK].y][ss[BACK].x] == 'M' && ss[BACK].d == gd) return OK;\n\tif(visited[ss[TO].x][ss[TO].y][ss[TO].d][ss[BACK].x][ss[BACK].y][ss[BACK].d]) return NG;\n\tvisited[ss[TO].x][ss[TO].y][ss[TO].d][ss[BACK].x][ss[BACK].y][ss[BACK].d] = true;\n\n\tint res = (field[ss[TO].y][ss[TO].x] == 'M' ? HF : NG);\n\n\tfor(int turn = -1; turn <= 1; turn += 2) {\n\t\tstate st(ss[TO]);\n\t\tst.d = (st.d + turn + D) % D;\n\n\t\tfor(const auto &sb : move_back(tmp_back, turn)) {\n\t\t\tchmax(res, dfs({{st, sb}}));\n\t\t\tif(res == OK) return res;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint solve() {\n\tmemset(visited, false, sizeof(visited));\n\n\tint res = NG;\n\tfor(int bd = 0; bd < 4; ++bd) {\n\t\tchmax(res, dfs({{state(sx, sy, sd), state(sx, sy, bd)}}));\n\t\tif(res == OK) break;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfield[MAX_H]     = \"###\";\n\tfield[MAX_H + 1] = \"#.#\";\n\tfield[MAX_H + 2] = \"###\";\n\n\twhile(cin >> w >> h && w) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tfor(int i = 1; i < h - 1; ++i) {\n\t\t\tfor(int j = 1; j < w - 1; ++j) {\n\t\t\t\tif(field[i][j] == 'K') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\n\t\t\t\t\tfor(int d = 0; d < D; ++d) {\n\t\t\t\t\t\tif(field[i + dy[d]][j + dx[d]] != '#') {\n\t\t\t\t\t\t\tsd = d;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'M') {\n\t\t\t\t\tfor(int d = 0; d < D; ++d) {\n\t\t\t\t\t\tif(field[i + dy[d]][j + dx[d]] != '#') {\n\t\t\t\t\t\t\tgd = d;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << message[solve()] << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by ryo07 on 2018/11/15.\n//\n\n#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct state{\n    int x1,y1,d1,x2,y2,d2;\n    state(){}\n    state(int xx1,int yy1,int dd1,int xx2,int yy2,int dd2) {\n        x1 = xx1;\n        y1 = yy1;\n        d1 = dd1;\n        x2 = xx2;\n        y2 = yy2;\n        d2 = dd2;\n    }\n};\n\nint w,h;\nint fie[16][64];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool used[16][64][4][16][64][4];\nbool uk[16][64][4][16][64][4];\nvector<P> G[16][64][4];\nP to[16][64][4];\nbool used2[16][64][4];\nint sx,sy,gx,gy;\n\nvoid dfs(int cx,int cy,int d,int px,int py){\n    if(fie[cy+dy[d]][cx+dx[d]]==-1) {\n        to[py][px][d] = P(cy, cx);\n        G[cy][cx][d].push_back(P(py,px));\n        return;\n    }\n    dfs(cx+dx[d],cy+dy[d],d,px,py);\n}\n\nint solve(){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(fie[i][j]==-1)continue;\n            for(int k=0;k<4;k++){\n                G[i][j][k].clear();\n                used2[i][j][k]=false;\n            }\n            for(int k=0;k<h;k++){\n                for(int l=0;l<w;l++){\n                    if(fie[k][l]==-1)continue;\n                    for(int a=0;a<4;a++){\n                        for(int b=0;b<4;b++){\n                            used[i][j][a][k][l][b]=false;\n                            uk[i][j][a][k][l][b]=false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    for(int i=0;i<h;i++) {\n        for (int j = 0; j < w; j++) {\n            if (fie[i][j] == -1)continue;\n            for (int k = 0; k < 4; k++) {\n                dfs(j, i, k, j, i);\n            }\n        }\n    }\n    queue<state> que;\n    for(int i=0;i<4;i++) {\n        if (fie[sy + dy[i]][sx + dx[i]] == 0) {\n            for (int j = 0; j < 4; j++) {\n                que.push(state(sx, sy, i, sx, sy, j));\n                used[sy][sx][i][sy][sx][j] = true;\n            }\n        }\n    }\n    while(que.size()){\n        state s=que.front();\n        que.pop();\n       // printf(\"%d %d %d %d %d %d\\n\",s.x1,s.y1,s.d1,s.x2,s.y2,s.d2);\n        for(int i=0;i<G[s.y2][s.x2][s.d2].size();i++){\n            int nx2=G[s.y2][s.x2][s.d2][i].second;\n            int ny2=G[s.y2][s.x2][s.d2][i].first;\n            int nx1=to[s.y1][s.x1][s.d1].second;\n            int ny1=to[s.y1][s.x1][s.d1].first;\n            uk[ny1][nx1][s.d1][ny2][nx2][s.d2]=true;\n            if(!used[ny1][nx1][(s.d1+1)%4][ny2][nx2][(s.d2+1)%4]){\n                used[ny1][nx1][(s.d1+1)%4][ny2][nx2][(s.d2+1)%4]=true;\n                que.push(state(nx1,ny1,(s.d1+1)%4,nx2,ny2,(s.d2+1)%4));\n            }\n            if(!used[ny1][nx1][(s.d1+3)%4][ny2][nx2][(s.d2+3)%4]){\n                used[ny1][nx1][(s.d1+3)%4][ny2][nx2][(s.d2+3)%4]=true;\n                que.push(state(nx1,ny1,(s.d1+3)%4,nx2,ny2,(s.d2+3)%4));\n            }\n        }\n    }\n    int gd=-1;\n    for(int i=0;i<4;i++){\n        if(fie[gy+dy[i]][gx+dx[i]]==0){\n            gd=i;\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(uk[gy][gx][i][gy][gx][gd])return 1;\n    }\n\n    for(int i=0;i<4;i++) {\n        if (fie[sy + dy[i]][sx + dx[i]] == 0) {\n            que.push(state(sx, sy, i, 0,0,0));\n            used2[sy][sx][i] = true;\n        }\n    }\n    while(que.size()){\n        state s=que.front();\n        que.pop();\n        // printf(\"%d %d %d %d %d %d\\n\",s.x1,s.y1,s.d1,s.x2,s.y2,s.d2);\n        int nx1=to[s.y1][s.x1][s.d1].second;\n        int ny1=to[s.y1][s.x1][s.d1].first;\n        used2[ny1][nx1][s.d1]=true;\n        if(!used2[ny1][nx1][(s.d1+1)%4]){\n            used2[ny1][nx1][(s.d1+1)%4]=true;\n            que.push(state(nx1,ny1,(s.d1+1)%4,0,0,0));\n        }\n        if(!used2[ny1][nx1][(s.d1+3)%4]){\n            used2[ny1][nx1][(s.d1+3)%4]=true;\n            que.push(state(nx1,ny1,(s.d1+3)%4,0,0,0));\n        }\n    }\n    for(int i=0;i<4;i++){\n        if(used2[gy][gx][i])return 0;\n    }\n    return -1;\n}\n\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w==0 && h==0)break;\n        memset(fie,-1,sizeof(fie));\n        for(int i=0;i<h;i++){\n            string str;\n            cin >> str;\n            for(int j=0;j<w;j++){\n                if(str[j]!='#')fie[i][j]=0;\n                if(str[j]=='K'){\n                    sx=j;\n                    sy=i;\n                }\n                if(str[j]=='M'){\n                    gx=j;\n                    gy=i;\n                }\n            }\n        }\n        int res=solve();\n        if(res==1){\n            printf(\"He can accomplish his mission.\");\n        }\n        if(res==0){\n            printf(\"He cannot return to the kitchen.\");\n        }\n        if(res==-1){\n            printf(\"He cannot bring tea to his master.\");\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <unordered_set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    int x, y, d;\n    S() {}\n    S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const pair<S, S>& p) {\n    return (sig(p.first) << 16) | sig(p.second);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { \\\n    const int si = sig(s); \\\n    if (!vis.count(si)) vis.insert(si), q.push(s); \\\n}\n\nbool reach(const S& s, const S& t) {\n    unordered_set<int> vis;\n    queue<S> q;\n    const S st = forward(s.x, s.y, s.d);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == t.x && cur.y == t.y) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, unordered_set<int>& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish(const S& s, const S& t) {\n    unordered_set<int> vis;\n    queue<pair<S, S> > q;\n    const S st = forward(s.x, s.y, s.d);\n    rep (d, 4) push(q, vis, st, s.x, s.y, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == t.x && cur.y == t.y\n                && rev.x == t.x && rev.y == t.y && rev.d == t.d) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    S s(-1, -1, -1), t(-1, -1, -1);\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        s.x = i, s.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') s.d = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        t.x = i, t.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') t.d = d;\n    }\n    if (!reach(s, t)) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish(s, t)) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int w,int gy,int gx ) {\n\tstatic bool v[16][64][4];\n\tmemset(v, 0, sizeof(v));\n\tint sd = 0;\n\tqueue<pi> q;\n\tmp.first = sy * w + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / w, x = q.front().first%w;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') y += dy[dir], x += dx[dir];\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = 1;\n\t\t\t\tmp.first = y*w + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint h, w,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h&&w) {\n\t\trep(i, h) getline(cin, in[i]);\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tiki = solve(sy, sx, w, gy, gx);\n\t\tkaeri = solve(gy, gx, w, sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\tcout << x << \" \" << y << endl;\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tcout << \"i:\" << i << endl;\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tcout << sy << \" \" << sx << endl;\n\t\tcout << gy << \" \" << gx << endl;\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool b[70][20];\nbool a[70][20][4][70][20][4];\nint x[70][20][4];\nint y[70][20][4];\nint w,h;\n\nvoid init(vector<string> &v){\n\tfor(int i=1;i<w-1;i++){\n\t\tfor(int j=1;j<h-1;j++){\n\t\t\tif(v[j][i]=='#')continue;\n\t\t\trep(k,4){\n\t\t\t\tint p = i;\n\t\t\t\tint q = j;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(v[q+dy[k]][p+dx[k]]=='#'){\n\t\t\t\t\t\tx[i][j][k] = p;\n\t\t\t\t\t\ty[i][j][k] = q;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq += dy[k];\n\t\t\t\t\t\tp += dx[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n\n\nint main(){\n\twhile(cin >> w >> h &&w!=0){\n\t\tvector<string> v(h);\n\t\tFill(a,false);\n\t\tFill(x,-1);\n\t\tFill(y,-1);\n\t\trep(i,h){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tinit(v);\n\t\tpair<int,int> s,t;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='K'){\n\t\t\t\t\ts = MP(j,i);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='M'){\n\t\t\t\t\tt = MP(j,i);\n\t\t\t\t\tv[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint c,d;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[s.second+dy[i]][s.first+dx[i]]!='#'){\n\t\t\t\tc = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(v[t.second+dy[i]][t.first+dx[i]]!='#'){\n\t\t\t\td = i;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<pair<int,pair<int,int> >,pair<int,pair<int,int> > > > q;\n\t\tpair<int,pair<int,int> > ss,tt;\n\t\tss = MP(c,s);\n\t\ttt = MP(0,s);\n\t\tq.push(MP(ss,tt));\n\t\ttt = MP(1,s);\n\t\tq.push(MP(ss,tt));\n\t\ttt = MP(2,s);\n\t\tq.push(MP(ss,tt));\n\t\ttt = MP(3,s);\n\t\tq.push(MP(ss,tt));\n\t\tbool flag1=false,flag2=false;\n\t\twhile(!q.empty()){\n\t\t\tpair<pair<int,pair<int,int> >,pair<int,pair<int,int> > > p;\n\t\t\tp = q.front();\n\t\t\tq.pop();\n\t\t\tint c1,x1,y1,c2,x2,y2;\n\t\t\tc1 = p.first.first;\n\t\t\tx1 = p.first.second.first;\n\t\t\ty1 = p.first.second.second;\n\t\t\tc2 = p.second.first;\n\t\t\tx2 = p.second.second.first;\n\t\t\ty2 = p.second.second.second;\n\t\t\ta[x1][y1][c1][x2][y2][c2] = true;\n\t\t\t//cout << x1 << \" \" << y1 << endl;\n\t\t\tif(p.first.second==t){\n\t\t\t\tflag1 = true;\n\t\t\t}\n\t\t\tint xx1,yy1,xx2,yy2;\n\t\t\txx1 = x[x1][y1][c1];\n\t\t\tyy1 = y[x1][y1][c1];\n\t\t\tyy2 = y2;\n\t\t\txx2 = x2;\n\t\t\twhile(1){\n\t\t\t\tif(MP(xx2,yy2)==t&&d==c2&&MP(xx1,yy1)==t){\n\t\t\t\t\tflag2 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=1;i<4;i++){\n\t\t\t\t\tif(i==2)continue;\n\t\t\t\t\tif(v[yy2+dy[(c2+i)%4]][xx2+dx[(c2+i)%4]]=='#'){\n\t\t\t\t\t\tif(a[xx1][yy1][(c1+i)%4][xx2][yy2][(c2+i)%4]==false){\n\t\t\t\t\t\t\t//cout << xx1 << \" \" << yy1 << \" \" << c1+i << \" \" << xx2 << \" \" << yy2 << \" \" << c2+i << endl;\n\t\t\t\t\t\t\tq.push(MP(MP((c1+i)%4,MP(xx1,yy1)),MP((c2+i)%4,MP(xx2,yy2))));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(v[yy2-dy[c2]][xx2-dx[c2]]=='#')break;\n\t\t\t\tyy2 -=dy[c2];\n\t\t\t\txx2 -=dx[c2];\n\t\t\t}\n\t\t\tif(flag2)break;\n\t\t}\n\t\tqueue<pair<int,int> > q2;\n\t\tq2.push(s);\n\t\tFill(b,false);\n\t\twhile(!q2.empty()){\n\t\t\tpair<int,int> p2;\n\t\t\tp2 = q2.front();\n\t\t\tq2.pop();\n\t\t\tb[p2.first][p2.second]=true;\n\t\t\tif(p2==t){\n\t\t\t\tflag1 = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(b[x[p2.first][p2.second][i]][y[p2.first][p2.second][i]]==false){\n\t\t\t\t\tq2.push(MP(x[p2.first][p2.second][i],y[p2.first][p2.second][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag2){\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}else if(flag1){\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\t\t}else{\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vvvvvi=vector<vvvvi>;\nusing vvvvvvi=vector<vvvvvi>;\n\nstruct State{\n    int hk,wk;\n    int hm,wm;\n    int dirk,dirm;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nint w,h;\nint solve();\nint main(){\n    while(cin>>w>>h,w){\n        solve();\n    }\n}\nint solve(){\n\n    vector<string> f(h);\n    for(int i=0;i<h;i++){\n        cin>>f[i];\n    }        \n    \n    int ini_hk=-1,ini_wk=-1,ini_dirk=-1;\n    int ini_hm=-1,ini_wm=-1,ini_dirm=1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='K'){\n                ini_hk=i;\n                ini_wk=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirk=k;\n                    }\n                }\n            }\n            if(f[i][j]=='M'){\n                ini_hm=i;\n                ini_wm=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirm=k;\n                    }\n                }\n            }\n        }\n    }\n    /*\n    cout<<ini_hk<<\" \"<<ini_wk<<\" \"<<ini_dirk<<endl;\n    cout<<ini_hm<<\" \"<<ini_wm<<\" \"<<ini_dirm<<endl;\n    */\n    vvvvvvi dp(h,vvvvvi(w,vvvvi(h,vvvi(w,vvi(4,(vi(4,false)))))));\n    dp[ini_hk][ini_wk][ini_hm][ini_wm][ini_dirk][ini_dirm]=true;\n    queue<State> que;\n    que.push(State{ini_hk,ini_wk,ini_hm,ini_wm,ini_dirk,ini_dirm});\n    \n    while(!que.empty()){\n        auto st=que.front();\n        que.pop();\n        int hk=st.hk,wk=st.wk,dk=st.dirk;\n        int hm=st.hm,wm=st.wm,dm=st.dirm;\n        /*\n        cout<<hk<<\" \"<<wk<<\" \"<<dk<<endl;\n        cout<<hm<<\" \"<<wm<<\" \"<<dm<<endl;\n        */\n        int tohk=hk+dh[dk],towk=wk+dw[dk];\n        //cout<<tohk<<\" \"<<towk<<endl;\n        int tohm=hm+dh[dm],towm=wm+dw[dm];\n        //cout<<tohm<<\" \"<<towm<<endl;\n        char tokf=f[tohk][towk];\n        char tomf=f[tohm][towm];\n        if(tokf=='#' && tomf=='#'){\n            int todk=(dk+1)%4;\n            int todm=(dm+3)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n            todk=(dk+3)%4;\n            todm=(dm+1)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n        }\n        else if(tokf=='#'){\n            if(!dp[hk][wk][tohm][towm][dk][dm]){\n                dp[hk][wk][tohm][towm][dk][dm]=true;\n                que.push(State{hk,wk,tohm,towm,dk,dm});\n            }\n        }\n        else if(tomf=='#'){\n            if(!dp[tohk][towk][hm][wm][dk][dm]){\n                dp[tohk][towk][hm][wm][dk][dm]=true;\n                que.push(State{tohk,towk,hm,wm,dk,dm});\n            }\n        }\n        else{\n            \n            if(!dp[tohk][towk][tohm][towm][dk][dm]){\n                dp[tohk][towk][tohm][towm][dk][dm]=true;\n                que.push(State{tohk,towk,tohm,towm,dk,dm});\n            }\n        }\n        \n    }\n    bool two_way=false;\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(i!=ini_dirk && j!=ini_dirm){\n                two_way|=dp[ini_hm][ini_wm][ini_hk][ini_wk][i][j];\n            }\n        }\n    }\n\n    bool one_way=false;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int ki=0;ki<4;ki++){\n                for(int kj=0;kj<4;kj++){\n                    if(ki!=ini_dirk && kj!=ini_dirm){\n                        one_way|=dp[ini_hm][ini_wm][i][j][ki][kj];\n                    }\n                }\n            }\n        }\n    }\n    if(two_way){\n        cout<<\"He can accomplish his mission.\"<<endl;\n    }\n    else if(one_way){   \n        cout<<\"He cannot return to the kitchen.\"<<endl;\n    }\n    else{        \n        cout<<\"He cannot bring tea to his master.\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR];\n\n\nmain(){\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,C)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t}\n      }\n    }\n  }\n}\n\nbool cango;\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gy,int gx,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  \n  if (m[sy][sx] == 'M' &&\n      ry == gy && rx == gx && rd == gd)return true;\n\n  Edge cpy1,cpy2;\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\n\nbool vis2[R][C][DIR];\nbool solve_to_kit(int r,int c,int sy,int sx,int sd){\n  if (vis2[sy][sx][sd])return false;\n\n  vis2[sy][sx][sd]=true;\n  if (m[sy][sx] == 'M')return true;\n  \n  Edge cpy1;\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      cpy1=edge[sy][sx][sd][l][i];\n      if (solve_to_kit(r,c,cpy1.y,cpy1.x,cpy1.d))return true;\n     }\n  }\n  return false;\n}\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    rep(i,r)rep(j,c)rep(k,DIR)vis2[i][j][k]=false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n    if (solve_to_kit(r,c,iniy,inix,inidir))cango=true;\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_M, wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_M = wall_dir_at_K = vector< int >();\n\t\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\tif (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\tif (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tint cnt = 0;\n\tfor_(y,0,H) {\n\t\tfor_(x,0,W) {\n\t\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\t\tfor_(d,0,4) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\t\tif (home_map[y][x] == 'M') wall_dir_at_M.push_back(d);\n\t\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tgoal_dir = d;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tstart_dir = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt == 2) break;\n\t\t}\n\t\tif (cnt == 2) break;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nstruct State {\n\tint id, dir;\n\tint rev_id, rev_dir;\n};\n\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< pii > que;\n\tque.push(pii(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tif (p.first == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[p.first][p.second][c], nxt_dir = changeDirection(p.second, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(pii(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(State{start_id, start_dir, 0, d});\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tif (s.id == 1023 && s.rev_id == goal_id && s.rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c), nxt_rev_dir = changeDirection(s.rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[s.rev_id][s.rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(State{nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct State{\n    int y,x,dir;\n};\n\nusing pi = pair<int,int>;\nusing ps = pair<State,State>;\n\nconst int dx[4]={1,0,-1,0}, dy[4]={0,-1,0,1};\nconst string ng = \"He cannot bring tea to his master.\";\nconst string half = \"He cannot return to the kitchen.\";\nconst string ok = \"He can accomplish his mission.\";\n\nconst int H=16, W=64;\n\nint w,h;\nstring s[H];\n\nbool dp[H][W][4][H][W][4];\n\ninline bool IN(int y, int x)\n{\n    return 0<=y && y<h && 0<=x && x<w;\n}\n\nint main()\n{\n    while(cin >>w >>h,w)\n    {\n        rep(i,h) cin >>s[i];\n\n        State start,goal;\n        rep(i,h)rep(j,w)\n        {\n            if(s[i][j]=='K')\n            {\n                rep(k,4)if(s[i+dy[k]][j+dx[k]]=='.') start = {i,j,k};\n            }\n            if(s[i][j]=='M')\n            {\n                rep(k,4)if(s[i+dy[k]][j+dx[k]]=='.') goal = {i,j,k};\n            }\n        }\n\n        bool forward = false, backward = false;\n        memset(dp,0,sizeof(dp));\n        queue<ps> que;\n        for(int i=1; i<=3; ++i)\n        {\n            dp[start.y][start.x][start.dir][start.y][start.x][(start.dir+i)%4]=true;\n            que.push({start,{start.y,start.x,(start.dir+i)%4}});\n        }\n        while(!que.empty())\n        {\n            ps now=que.front();\n            que.pop();\n\n            State p=now.fi, q=now.se;\n\n            // printf(\" (%d %d %d) (%d %d %d)\\n\", p.y,p.x,p.dir,q.y,q.x,q.dir);\n\n            while(s[p.y+dy[p.dir]][p.x+dx[p.dir]]!='#')\n            {\n                p.y += dy[p.dir];\n                p.x += dx[p.dir];\n            }\n\n            // printf(\"NX p: (%d %d)\\n\", p.y,p.x);\n\n            for(int dd:vector<int>({1,3}))\n            {\n                if(!dp[p.y][p.x][(p.dir+dd)%4][0][0][0])\n                {\n                    dp[p.y][p.x][(p.dir+dd)%4][0][0][0] = true;\n                    que.push({{p.y,p.x,(p.dir+1)%4},{0,0,0}});\n                }\n            }\n\n            if(p.x==goal.x && p.y==goal.y) forward = true;\n\n            if(q.x!=0)\n            {\n                while(s[q.y][q.x]!='#')\n                {\n                    for(int dd:vector<int>({1,3}))\n                    {\n                        if(s[q.y+dy[(q.dir+dd)%4]][q.x+dx[(q.dir+dd)%4]]=='#')\n                        {\n                            if(!dp[p.y][p.x][(p.dir+dd)%4][q.y][q.x][(q.dir+dd)%4])\n                            {\n                                dp[p.y][p.x][(p.dir+dd)%4][q.y][q.x][(q.dir+dd)%4] = true;\n                                que.push({{p.y,p.x,(p.dir+dd)%4},{q.y,q.x,(q.dir+dd)%4}});\n                            }\n                        }\n                    }\n\n                    q.y -= dy[q.dir];\n                    q.x -= dx[q.dir];\n                    if(p.x==goal.x && p.y==goal.y && q.x==goal.x && q.y==goal.y && q.dir==goal.dir) backward = true;\n                }\n            }\n        }\n\n        string ans = ng;\n        if(forward && backward) ans = ok;\n        else if(forward) ans = half;\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nenum {NG, HF, OK};\nenum {TO, BACK};\n\nconst string message[] = {\n\t\"He cannot bring tea to his master.\",\n\t\"He cannot return to the kitchen.\",\n\t\"He can accomplish his mission.\"\n};\n\nstruct state {\n\tint x, y, d;\n\tstate(int x_, int y_, int d_):x(x_), y(y_), d(d_) {}\n};\n\nconstexpr int dx[] = {1, 0, -1, 0};\nconstexpr int dy[] = {0, 1, 0, -1};\nconstexpr int MAX_H = 16;\nconstexpr int MAX_W = 64;\nconstexpr int D = sizeof(dx) / sizeof(int);\nconstexpr int HF_X = 1;\nconstexpr int HF_Y = MAX_H + 1;\n\nint h, w;\nstring field[MAX_H + 3];\n\nint sx, sy, sd;\nint gd;\nbool visited[MAX_W][MAX_H][D][MAX_W][MAX_H + 3][D];\n\nvector<state> move_back(state s, int turn) {\n\tconst int dir = (s.d + 2) % D;\n\ts.d = (s.d + turn + D) % D;\n\n\tvector<state> res;\n\tdo {\n\t\tif(field[s.y + dy[s.d]][s.x + dx[s.d]] == '#') {\n\t\t\tres.emplace_back(s);\n\t\t}\n\n\t\ts.x += dx[dir];\n\t\ts.y += dy[dir];\n\n\t} while(field[s.y][s.x] != '#');\n\n\tres.emplace_back(state(HF_X, HF_Y, s.d));\n\treturn res;\n}\n\nint bfs() {\n\tmemset(visited, false, sizeof(visited));\n\tqueue<array<state, 2>> que;\n\n\tfor(int bd = 0; bd < 4; ++bd) {\n\t\tvisited[sx][sy][sd][sx][sy][bd] = true;\n\t\tque.push({{state(sx, sy, sd), state(sx, sy, bd)}});\n\t}\n\n\tint res = NG;\n\twhile(!que.empty()) {\n\t\tauto ss = que.front();\n\t\tque.pop();\n\n\t\tconst state tmp_back = ss[BACK];\n\n\t\tint sign = 1;\n\t\tfor(auto &s : ss) {\n\t\t\twhile(field[s.y + dy[s.d] * sign][s.x + dx[s.d] * sign] != '#') {\n\t\t\t\ts.x += dx[s.d] * sign;\n\t\t\t\ts.y += dy[s.d] * sign;\n\t\t\t}\n\t\t\tsign = -sign;\n\t\t}\n\n\t\tif(field[ss[TO].y][ss[TO].x] == 'M') {\n\t\t\tif(field[ss[BACK].y][ss[BACK].x] == 'M' && ss[BACK].d == gd) return OK;\n\t\t\tres = HF;\n\t\t}\n\n\t\tfor(int turn = -1; turn <= 1; turn += 2) {\n\t\t\tstate sa(ss[TO]);\n\t\t\tsa.d = (sa.d + turn + D) % D;\n\n\t\t\tfor(const auto &sb : move_back(tmp_back, turn)) {\n\t\t\t\tif(!visited[sa.x][sa.y][sa.d][sb.x][sb.y][sb.d]) {\n\t\t\t\t\tque.push({{sa, sb}});\n\t\t\t\t\tvisited[sa.x][sa.y][sa.d][sb.x][sb.y][sb.d] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfield[MAX_H]     = \"###\";\n\tfield[MAX_H + 1] = \"#.#\";\n\tfield[MAX_H + 2] = \"###\";\n\n\twhile(cin >> w >> h && w) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tfor(int i = 1; i < h - 1; ++i) {\n\t\t\tfor(int j = 1; j < w - 1; ++j) {\n\t\t\t\tif(field[i][j] == 'K') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\n\t\t\t\t\tfor(int d = 0; d < D; ++d) {\n\t\t\t\t\t\tif(field[i + dy[d]][j + dx[d]] != '#') {\n\t\t\t\t\t\t\tsd = d;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'M') {\n\t\t\t\t\tfor(int d = 0; d < D; ++d) {\n\t\t\t\t\t\tif(field[i + dy[d]][j + dx[d]] != '#') {\n\t\t\t\t\t\t\tgd = d;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << message[bfs()] << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W,H;\nchar fie[80][20];\n\nstruct state {\n  int px,py,pd,pm,pid;\n  state(){}\n  state(int px,int py,int pd,int pm=0,int pid=0)\n    : px(px), py(py), pd(pd), pm(pm), pid(pid) {}\n};\n\nbool F[80][20][4];\nvector<state> rev[64*16*4];\nbool dp[64*16*4+1][64][16][4];\n\nstate nex[80][20][4];\n\n// { up, right, down, left };\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nvoid init(){\n  fill(F[0][0],F[W][0],0 );\n  for(int i=0;i<H*W*4;i++)\n    rev[i].clear();\n  fill( dp[0][0][0], dp[H*W*4][0][0], 0 );  \n}\n\nint getid(int x,int y,int d){\n  return x + W * y + W * H * d;\n}\n\nvoid setnex(int x,int y,int d){\n  if( fie[x][y] == '#' ) return;\n  int px = x, py = y;\n  int nx = x + dx[d], ny = y + dy[d];\n  while( 0 <= nx && nx <= W &&\n         0 <= ny && ny <= H &&\n        fie[nx][ny] != '#' ) {\n    x = nx, y = ny;\n    nx += dx[d], ny += dy[d];\n  }\n  nex[px][py][d] = state( x, y, d );\n}\n\n\nbool bfs(int sx,int sy,int sd) {\n  queue<state> q;\n  q.emplace( sx, sy, sd );\n  F[sx][sy][sd] = true;\n  // cout << sx << \" \" << sy<< \" \" << sd << endl;\n  bool ok = false;\n  while( !q.empty() ) {\n    state p = q.front(); q.pop();\n    if( fie[p.px][p.py] == 'M' ) ok = true;\n    for(int m=-1;m<=1;m+=2){\n      int nd = (p.pd+m+4)%4;\n      state ns = nex[p.px][p.py][nd];\n      rev[ getid( ns.px, ns.py, ns.pd ) ]\n        .emplace_back( p.px, p.py, p.pd, m, getid( p.px, p.py, p.pd ) );\n      if( F[ns.px][ns.py][ns.pd] ) continue;\n      F[ns.px][ns.py][ns.pd] = true;\n      \n      q.emplace( ns.px, ns.py, ns.pd );\n    }\n  }\n  return ok;\n}\n\nbool check(int ex,int ey,int ed,int eid, int sx,int sy, int sd ){\n  queue<state> q;\n  //cout << \"check!\" << endl;\n  for(int i=0;i<4;i++){\n    q.emplace( ex, ey, ed, 0, eid+i*W*H );\n    dp[eid+i*W*H][ex][ey][ed] = true;\n  }\n  while( !q.empty() ) {\n    state p = q.front(); q.pop();\n    //cout << p.px << \" \" << p.py << \" \"<<p.pd << \" \" << p.pid << endl;\n    if( p.pid == getid( sx, sy, sd ) &&\n        fie[p.px][p.py] == 'K' ) return true;\n        \n    for( state nst : rev[p.pid] ) {\n      int nd = ( p.pd - nst.pm + 4 ) % 4;\n      state ns = nex[p.px][p.py][nd];\n      if( dp[nst.pid][ns.px][ns.py][ns.pd] ) continue;\n      dp[ nst.pid ][ ns.px ][ ns.py ][ ns.pd ] = true;\n      q.emplace( ns.px, ns.py, ns.pd, 0, nst.pid );      \n    }    \n  }\n  return false;\n}\n\nint main(){\n  while( cin >> W >> H && (W||H) ) {\n    init();\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        cin >> fie[j][i];\n      }\n    }\n    int sx,sy,sd,ex,ey,ed,eid;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        for(int d=0;d<4;d++){\n          setnex( j, i, d );\n          if( fie[j][i] == 'K' &&\n              ( nex[j][i][d].px != j || nex[j][i][d].py != i ) ) {\n            sx = nex[j][i][d].px;\n            sy = nex[j][i][d].py;\n            sd = d;\n          }\n          if( fie[j][i] == 'M' &&\n              ( nex[j][i][d].px != j || nex[j][i][d].py != i ) ) {\n            ex = nex[j][i][d].px;\n            ey = nex[j][i][d].py;\n            ed = d;\n            eid = getid(j,i,0);\n          }\n        }\n      }\n    }\n    //cout << \"start\" << endl;\n    //cout << sx<< \" \" <<sy << \" \" << sd << endl;\n    //cout<< ex << \" \" << ey << \" \" << ed << \" \" << eid << endl;\n     \n\n    if( bfs( sx, sy, sd ) ) {\n      if( check( ex, ey, ed, eid, sx, sy, sd ) )\n        cout << \"He can accomplish his mission.\" << endl;\n      else\n        cout << \"He cannot return to the kitchen.\" << endl;\n    } else\n      cout << \"He cannot bring tea to his master.\" << endl;              \n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nint memo[64][16][4][64][16][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint fway;\n\tint tx;\n\tint ty;\n\tint tway;\n};\nint gx, gy;\n\nvector<aa>astack;\n\nbool cangoal;\n\nint gway;\n\nbool check(int fx, int fy,int fway, int tx, int ty, int tway) {\n\n\tif (memo[fx][fy][fway][tx][ty][tway])return false;\n\tmemo[fx][fy][fway][tx][ty][tway] =1;\n\t\n\t//else{\n\n\t\tint nfy = fy + dy[fway];\n\t\tint nfx = fx + dx[fway];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (mp[nfy][nfx]) {\n\t\t\t\tnfx -= dx[fway];\n\t\t\t\tnfy -= dy[fway];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[fway];\n\t\t\tnfx = nfx + dx[fway];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (mp[nty][ntx]) {\n\t\t\t\tntx -= dx[tway];\n\t\t\t\tnty -= dy[tway];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\t\tint atway = (tway + 3) % 4;\n\t\t\t\tint afway = (fway + 3) % 4;\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\t\tint atway = (tway + 1) % 4;\n\t\t\t\tint afway = (fway + 1) % 4;\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\n\t\t\tnty = nty + dy[tway];\n\t\t\tntx = ntx + dx[tway];\n\t\t}\n\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\tint atway = (tway + 3) % 4;\n\t\t\tint afway = (fway + 3) % 4;\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\t\t}\n\n\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\tint atway = (tway + 1) % 4;\n\t\t\tint afway = (fway + 1) % 4;\n\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\t\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\n\t\t\t}\n\t\t}\n\n\t//}\n\treturn false;\n}\n\nint main() {\n\twhile (1) {\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tastack.clear();\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\t\tmp.resize(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tmp[i].resize(W);\n\t\t}\n\n\t\tint sx, sy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t\tif (mp[gy + dy[i]][gx + dx[i]] == 0) {\n\t\t\t\tgway = i;\n\t\t\t}\n\t\t}\n\t\tbool perf = false;\n\t\tfor (int i = 0; i < 4;++i)\n\t\t\tastack.push_back(aa{ sx,sy,sway,sx,sy,i });\n\n\t\twhile (!astack.empty()) {\n\t\t\taa atop(astack.back());\n\t\t\tastack.pop_back();\n\t\t\tif (check(atop.fx, atop.fy,atop.fway, atop.tx, atop.ty, atop.tway)) {\n\t\t\t\tperf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (perf) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (cangoal) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\n\t\t\tvisited[y][x][dir] = true;\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, mx, my;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, 0);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec(sx, sy, 0);\n\n\t\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_K;\n\nvoid constructTransition() {\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_K = vector< int >();\n\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\telse if (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\telse if (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tint cnt = 0;\n\tfor_(y,0,H) {\n\t\tfor_(x,0,W) {\n\t\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\t\tfor_(d,0,4) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tgoal_dir = d;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tstart_dir = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt == 2) break;\n\t\t}\n\t\tif (cnt == 2) break;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nconst int SHIFT = 16;\nconst int MASK = (1 << 16) - 1;\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\ninline int makeState(int id, int dir) { return (id | (dir << SHIFT)); }\ninline int getID(int state) { return (state & MASK); }\ninline int getDIR(int state) { return (state >> SHIFT); }\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< int > que;\n\tque.push(makeState(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tint s = que.front(); que.pop();\n\t\tint id = getID(s), dir = getDIR(s);\n\t\tif (id == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(makeState(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nconst int SHIFT_A = 10, MASK_A = (1 << 10) - 1;\nconst int SHIFT_B = 16, MASK_B = (1 << 6) - 1;\nconst int SHIFT_C = 26, MASK_C = (1 << 10) - 1;\n\ninline int makeState(int id, int dir, int rev_id, int rev_dir) {\n\treturn (id | (dir << SHIFT_A) | (rev_id << SHIFT_B) | (rev_dir << SHIFT_C));\n}\n\ninline int getCurID(int state) { return (state & MASK_A); }\ninline int getCurDIR(int state) { return ((state >> SHIFT_A) & MASK_B); }\ninline int getRevID(int state) { return ((state >> SHIFT_B) & MASK_C); }\ninline int getRevDIR(int state) { return (state >> SHIFT_C); }\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< int > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(makeState(start_id, start_dir, 0, d));\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tint s = que.front(); que.pop();\n\t\tint id = getCurID(s), dir = getCurDIR(s);\n\t\tint rev_id = getRevID(s), rev_dir = getRevDIR(s);\n\t\tif (id == 1023 && rev_id == goal_id && rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c), nxt_rev_dir = changeDirection(rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[rev_id][rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(makeState(nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int w,int gy,int gx ) {\n\tstatic bool v[16][64][4];\n\tmemset(v, 0, sizeof(v));\n\tint sd = 0;\n\tqueue<pi> q;\n\tmp.first = sy * w + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / w, x = q.front().first%w;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') y += dy[dir], x + dx[dir];\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = 1;\n\t\t\t\tmp.first = y*w + x;\n\t\t\t\tmp.second = dir;\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint h, w,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h&&w) {\n\t\trep(i, h) getline(cin, in[i]);\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tiki = solve(sy, sx, w, gy, gx);\n\t\tkaeri = solve(gy, gx, w, sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint d[10] = {0, -1, 0, 1, 0, -1, 0, 1, 0, -1};\nint w, h, s1, s2, t1, t2;\n\nchar ss[100][100];\nint encode(int x, int y, int d){\n\treturn x*16*4 + y*4 + d;\n}\n\nunsigned char dp[64*16*4][64*16*4];\nunsigned char dp2[64*16*4];\nint main(){\n\tfor(int t=1;cin >> w >> h, w;t++){\n\t\tREP(i, h) cin >> ss[i];\n\t\tvector<vi> g(64*16*4, vi(2, -1));\n\t\tvector<vector<vi>> invg(64*16*4, vector<vi>(2));\n\t\tREP(i, h)REP(j, w)if(ss[i][j] != '#'){\n\t\t\tREP(k, 4)if(ss[i+d[k]][j+d[k+1]] == '.'){\n\t\t\t\tint dx=j, dy=i;\n\t\t\t\twhile(ss[dy+d[k]][dx+d[k+1]] != '#'){\n\t\t\t\t\tdy+=d[k]; dx+=d[k+1];\n\t\t\t\t}\n\t\t\t\tif(ss[i][j] == 'K'){\n\t\t\t\t\ts1 = encode(dx, dy, k);\n\t\t\t\t\ts2 = encode(j, i, k);\n\t\t\t\t}\n\t\t\t\tif(ss[i][j] == 'M'){\n\t\t\t\t\tt1 = encode(j, i, k^2);\n\t\t\t\t\tt2 = encode(dx, dy, k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, 4)REP(l, 2){\n\t\t\t\tint dx=j, dy=i;\n\t\t\t\tint dir = (k+1+l*2)%4;\n\t\t\t\twhile(ss[dy+d[dir]][dx+d[dir+1]] != '#'){\n\t\t\t\t\tdy+=d[dir]; dx+=d[dir+1];\n\t\t\t\t}\n\t\t\t\tint u = encode(j, i, k);\n\t\t\t\tint v = encode(dx, dy, dir);\n\t\t\t\tinvg[v][!l].push_back(u);\n\t\t\t\tg[u][l] = v;\n\t\t\t}\n\t\t}\n\t\tqueue<pii> q;\n\t\tREPS(i, 3) q.emplace(s1, s2^i);\n\t\tint ans = 0;\n\t\twhile(!q.empty()){\n\t\t\tint u1, u2; tie(u1, u2) = q.front(); q.pop();\n\t\t\tif((u1|3) == (t1|3)) ans = 1;\n\t\t\tif((u1|3)== (t1|3) && u2 == t2){\n\t\t\t\tans = 2; break;\n\t\t\t}\n\t\t\tREP(l, 2){\n\t\t\t\tint v1 = g[u1][l];\n\t\t\t\tif(u2 == -1 || invg[u2][l].empty()){\n\t\t\t\t\tif(dp2[v1] != t){\n\t\t\t\t\t\tdp2[v1] = t;\n\t\t\t\t\t\tq.emplace(v1, -1);\n\t\t\t\t\t}\n\t\t\t\t}else for(int v2 : invg[u2][l]){\n\t\t\t\t\tif(dp[v1][v2] != t){\n\t\t\t\t\t\tdp[v1][v2] = t;\n\t\t\t\t\t\tq.emplace(v1, v2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 0) puts(\"He cannot bring tea to his master.\");\n\t\tif(ans == 1) puts(\"He cannot return to the kitchen.\");\n\t\tif(ans == 2) puts(\"He can accomplish his mission.\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nchar ba[16][64];\npii iki[16][64][4];\nvector<pii> kaeri[16][64][4];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint w, h;\nbool visited[16][64][4];\n\nvoid make_graph(pii now, int d, int nest) {\n  int yy = now.first;\n  int xx = now.second;\n  \n  if (visited[yy][xx][d]) return;\n  visited[yy][xx][d] = 1;\n  \n  while (1) {\n    yy += dy[d];\n    xx += dx[d];\n    if (ba[yy][xx] == '#') break;\n  }\n  yy-=dy[d];\n  xx-=dx[d];\n\n  //printf(\"(%d,%d)%d -> (%d,%d)\\n\", now.second,now.first,d,xx,yy);\n  iki[now.first][now.second][d] = pii(yy,xx);\n  kaeri[yy][xx][d].push_back(pii(now.first,now.second));\n\n  // REP(i, 4) {\n  //   make_graph(pii(yy,xx), i, nest+1);\n  // }\n\n  make_graph(pii(yy,xx), (d+1)%4, nest+1);\n  make_graph(pii(yy,xx), (d+3)%4, nest+1);\n}\n\nint dd[2];\n\nstruct P {\n  int sy,sx,d1,ty,tx,d2;\n  P(int sy, int sx, int d1, int ty, int tx, int d2) :\n    sy(sy),sx(sx),d1(d1),ty(ty),tx(tx),d2(d2) {}\n};\n\nbool visited2[16][64][4][16][64][4];\n\nint solve(pii kitchen, pii master) {\n  queue<P> Q;\n  pii hoge = iki[kitchen.first][kitchen.second][dd[0]];\n  REP(i, 4)\n    Q.push(P(hoge.first, hoge.second, dd[0], kitchen.first, kitchen.second, i));\n  memset(visited2,0,sizeof(visited));\n  bool f = 0;\n  while(!Q.empty()) {\n    P p = Q.front(); Q.pop();\n    if (visited2[p.sy][p.sx][p.d1][p.ty][p.tx][p.d2]) continue;\n    visited2[p.sy][p.sx][p.d1][p.ty][p.tx][p.d2] = 1;\n    \n    if (pii(p.sy, p.sx) == master && pii(p.ty, p.tx) == iki[master.first][master.second][dd[1]] && p.d2 == dd[1]) {\n      return 2;\n    }\n    if (pii(p.sy, p.sx) == master) f = 1;\n\n    //printf(\"(%d,%d)%d, (%d,%d)%d\\n\", p.sx,p.sy,p.d1,p.tx,p.ty,p.d2);\n    \n    REP(i, 2) {\n      pii pp = iki[p.sy][p.sx][(p.d1+i*2+1)%4];\n      int ii = (p.d2+i*2+1)%4;\n      \n      FOR(it, kaeri[p.ty][p.tx][p.d2]) {\n//cout << it->second << \",\" << it->first << endl;\n        Q.push(P(pp.first, pp.second, (p.d1+i*2+1)%4, it->first, it->second, ii));\n      }\n    }\n  }\n  return f;\n}\n\nint main() {\n  while(cin>>w>>h,w||h) {\n    pii p[2];\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ba[i][j];\n        if (ba[i][j] == 'K') p[0] = pii(i,j);\n        else if (ba[i][j] == 'M') p[1] = pii(i,j);\n      }\n    }\n    memset(visited,0,sizeof(visited));\n    REP(i, h) REP(j,w) REP(k,4) kaeri[i][j][k].clear();\n    // REP(i,h) {\n    //   REP(j,w) {\n    //     if (ba[i][j] == '#') continue;\n    //     int cnt = 1;\n    //     // REP(d,4) {\n    //     //   int yy = i+dy[d];\n    //     //   int xx = j+dx[d];\n    //     //   if (ba[yy][xx] != '#') cnt++;\n    //     // }\n    //     if (cnt == 1) {\n    //       //cout << j << \",\" << i << \" \";\n    //       REP(d, 4) {\n    //         make_graph(pii(i,j), d, 0);\n    //       }\n    //     }\n    //   }\n    // }\n    bool f = 0;\n    REP(i,2) {\n      REP(d,4) {\n        int yy=p[i].first+dy[d];\n        int xx=p[i].second+dx[d];\n        if (ba[yy][xx] == '.') dd[i] = d;\n        make_graph(p[i], d, 0);\n        if (i == 0) {\n          REP(j,4) {\n            if (visited[p[1].first][p[1].second][j]) f = 1;\n          }\n        }\n      }\n    }\n    if (!f) {\n      cout << \"He cannot bring tea to his master.\" << endl;\n    } else {\n      memset(visited2,0,sizeof(visited2));\n      int res = solve(p[0], p[1]);\n      if (res == 2) {\n        cout << \"He can accomplish his mission.\" << endl;\n      } else {\n        cout << \"He cannot return to the kitchen.\" << endl;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint toidx(int a, int b, int n)\n{\n\treturn a * n + b;\n}\n\nint check(int w,int kitchen, int start, int master, int revstart, vector<pair<int, int> > &g, vector<vector<pair<int, bool> > > &rg)\n{\n\tconst int n = g.size();\n\tvector<bool> visited(n * n, false);\n\n\tqueue<pair<int, int> > q;\n\n\tfor(int i = 0; i < 4; ++i)\n\t\tq.push(make_pair(start, kitchen + i));\n\n\twhile(!q.empty()) {\n\n\t\tconst int a = q.front().first;\n\t\tconst int b = q.front().second;\n\t\tq.pop();\n\t\tconst int idx = toidx(a, b, n);\n\n\t\tif(visited[idx])\n\t\t\tcontinue;\n\t\tint ax = (a / 4) / w, ay = (a / 4) % w;\n\t\tint bx = (b / 4) / w, by = (b / 4) % w;\n\t\t//printf(\"(%d %d %d), (%d %d)\\n\", ax, ay, bx, by);\n\t\tvisited[idx] = true;\n\n\t\tfor(int i = 0; i < rg[b].size(); ++i) {\n\t\t\tint nb = rg[b][i].first;\n\t\t\tbool right = rg[b][i].second;\n\t\t\tint na = right ? g[a].first : g[a].second;\n\t\t\tq.push(make_pair(na, nb));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tif(visited[toidx(master + i, revstart, n)])\n\t\t\treturn 2;\n\t}\n\n\tvector<int> visited2(n);\n\tqueue<int> q2;\n\n\tq2.push(start);\n\n\twhile(!q2.empty()) {\n\n\t\tint v = q2.front();\n\t\tq2.pop();\n\n\t\tif(visited2[v])\n\t\t\tcontinue;\n\t\tvisited2[v] = true;\n\n\t\tq2.push(g[v].first);\n\t\tq2.push(g[v].second);\n\t}\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tif(visited2[master + i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid make_graphs(vector<string> &f, int &kitchen, int &start, int &master, int &revstart, vector<pair<int, int> > &g, vector<vector<pair<int, bool> > > &rg)\n{\n\tconst int h = f.size(), w = f[0].size();\n\tconst int n = h * w * 4;\n\n\tg.resize(n);\n\trg.resize(n);\n\n\t// up: 0, right: 1, down: 2, left: 3\n\tconst int dx[] = {-1, 0, 1, 0};\n\tconst int dy[] = {0, 1, 0, -1};\n\n\tfor(int x = 0; x < h; ++x) {\n\t\tfor(int y = 0; y < w; ++y) {\n\n\t\t\tif(f[x][y] == '#')\n\t\t\t\tcontinue;\n\t\t\tif(f[x][y] == 'K') {\n\t\t\t\tkitchen = 4 * (x * w + y);\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\tif(f[x+dx[i]][y+dy[i]] != '#')\n\t\t\t\t\t\tstart = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f[x][y] == 'M') {\n\t\t\t\tmaster = 4 * (x * w + y);\n\t\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\t\tif(f[x+dx[i]][y+dy[i]] != '#')\n\t\t\t\t\t\trevstart = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int node = 0; node < 4; ++node) {\n\n\t\t\t\tint ldir = (node + 3) % 4, rdir = (node + 1) % 4;\n\t\t\t\tint lx = x, ly = y, rx = x, ry = y;\n\t\t\t\tint gidx = 4 * (x * w + y) + node;\n\n\t\t\t\twhile(f[lx+dx[ldir]][ly+dy[ldir]] != '#')\n\t\t\t\t\tlx += dx[ldir], ly += dy[ldir];\n\t\t\t\twhile(f[rx+dx[rdir]][ry+dy[rdir]] != '#')\n\t\t\t\t\trx += dx[rdir], ry += dy[rdir];\n\n\t\t\t\tint lidx = 4 * (lx * w + ly) + ldir;\n\t\t\t\tint ridx = 4 * (rx * w + ry) + rdir;\n\n\t\t\t\tg[gidx] = make_pair(lidx, ridx);\n\t\t\t\trg[lidx].push_back(make_pair(gidx, false));\n\t\t\t\trg[ridx].push_back(make_pair(gidx, true));\n\t\t\t}\n\t\t}\n\t}\n\n\trevstart = g[master + (revstart + 1) % 4].first;\n\tstart = g[kitchen + (start + 1) % 4].first;\n}\n\nint main()\n{\n\tstring ansstr[3];\n\n\tansstr[0] = \"He cannot bring tea to his master.\";\n\tansstr[1] = \"He cannot return to the kitchen.\";\n\tansstr[2] = \"He can accomplish his mission.\";\n\n\twhile(true) {\n\n\t\tint w, h;\n\t\tvector<string> f;\n\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif(w == 0)\n\t\t\tbreak;\n\t\tf.resize(h);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tchar buf[128];\n\t\t\tscanf(\"%s\", buf);\n\t\t\tf[i] = buf;\n\t\t}\n\n\t\tvector<pair<int, int> > g;\n\t\tvector<vector<pair<int, bool> > > rg;\n\t\tint kitchen, start, master, revstart;\n\n\t\tmake_graphs(f, kitchen, start, master, revstart, g, rg);\n\t\tint ans = check(w,kitchen, start, master, revstart, g, rg);\n\n\t\tprintf(\"%s\\n\", ansstr[ans].c_str());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nstruct node{\n    int y1,x1,y2,x2,dir1,dir2;\n\tnode(int y1,int x1,int dir1,int y2,int x2,int dir2):y1(y1),x1(x1),dir1(dir1),y2(y2),x2(x2),dir2(dir2){}\n};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\ntypedef vector<vvvvi> vvvvvi;\ntypedef vector<vvvvvi> vvvvvvi;\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int h,w;\n    while(cin>>w>>h,w|h){\n        vs f(h);\n        pii kichen,master;\n        int k_dir,m_dir;\n        REP(i,h){\n            cin>>f[i];\n\t\t}\n        REP(i,h){\n            REP(j,w){\n                if(f[i][j]=='K'){\n                    kichen=make_pair(i,j);\n                    REP(d,4){\n                        int yy=i+dy[d];\n                        int xx=j+dx[d];\n                        if(f[yy][xx]=='.'){\n                            k_dir=d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                if(f[i][j]=='M'){\n                    master=make_pair(i,j);\n                    REP(d,4){\n                        int yy=i+dy[d];\n                        int xx=j+dx[d];\n                        if(f[yy][xx]=='.'){\n                            m_dir=d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<node> q;\n        vvvvvvi visited(h,vvvvvi(w,vvvvi(4,vvvi(h,vvi(w,vi(5))))));\n\t\tint sy,sx;\n        for(int i=1;;i++){\n\t\t\tint cy=kichen.first+dy[k_dir]*(i-1);\n\t\t\tint cx=kichen.second+dx[k_dir]*(i-1);\n\t\t\tint ny=kichen.first+dy[k_dir]*i;\n\t\t\tint nx=kichen.second+dx[k_dir]*i;\n            if(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n                sy=cy;\n                sx=cx;\n                break;\n\t\t\t}\n\t\t}\n\t\tFOR(i,1,3+1){\n\t\t\tq.push(node(sy,sx,k_dir,kichen.first,kichen.second,(k_dir+i)%4));\n\t\t\tvisited[sy][sx][k_dir][kichen.first][kichen.second][(k_dir+i)%4]=1;\n\t\t}\n        while(!q.empty()){\n            node cnode=q.front();q.pop();\n\t\t\tfor (int d = 1; d <= 3; d+=2)\n\t\t\t{\n\t\t\t\tvector<pii> points;\n\t\t\t\tint dir1=(cnode.dir1+d)%4;\n\t\t\t\tint sy1,sx1;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint cy=cnode.y1+dy[dir1]*(i-1);\n\t\t\t\t\tint cx=cnode.x1+dx[dir1]*(i-1);\n\t\t\t\t\tint ny=cnode.y1+dy[dir1]*i;\n\t\t\t\t\tint nx=cnode.x1+dx[dir1]*i;\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n\t\t\t\t\t\tsy1=cy;\n\t\t\t\t\t\tsx1=cx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnode.dir2!=4){\n\t\t\t\t\tint dir2=(cnode.dir2+d)%4;\n\t\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\t\tint cy=cnode.y2+dy[(cnode.dir2+2)%4]*(i-1);\n\t\t\t\t\t\tint cx=cnode.x2+dx[(cnode.dir2+2)%4]*(i-1);\n\t\t\t\t\t\tint ny=cnode.y2+dy[(cnode.dir2+2)%4]*i;\n\t\t\t\t\t\tint nx=cnode.x2+dx[(cnode.dir2+2)%4]*i;\n\t\t\t\t\t\tint sidey=cy+dy[dir2%4];\n\t\t\t\t\t\tint sidex=cx+dx[dir2%4];\n\t\t\t\t\t\tif(sidey>=0&&sidex>=0&&sidey<h&&sidex<w&&f[sidey][sidex]=='#'){\n\t\t\t\t\t\t\tpoints.push_back(make_pair(cy,cx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tREP(j,points.size()){\n\t\t\t\t\t\tif(!visited[sy1][sx1][dir1][points[j].first][points[j].second][dir2]){\n\t\t\t\t\t\t\tvisited[sy1][sx1][dir1][points[j].first][points[j].second][dir2]=1;\n\t\t\t\t\t\t\tq.push(node(sy1,sx1,dir1,points[j].first,points[j].second,dir2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!visited[sy1][sx1][dir1][0][0][4]){\n\t\t\t\t\tvisited[sy1][sx1][dir1][0][0][4]=1;\n\t\t\t\t\tq.push(node(sy1,sx1,dir1,0,0,4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ac=false;\n        for(int i=1;;i++){\n\t\t\tint cy=master.first+dy[m_dir]*(i-1);\n\t\t\tint cx=master.second+dx[m_dir]*(i-1);\n\t\t\tint ny=master.first+dy[m_dir]*i;\n\t\t\tint nx=master.second+dx[m_dir]*i;\n            if(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n                sy=cy;\n                sx=cx;\n                break;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++)\n\t\t{\n\t\t\tif(visited[master.first][master.second][(m_dir+i)%4][sy][sx][m_dir]){\n\t\t\t\tac=true;\n\t\t\t}\n\t\t}\n\t\tif(ac){\n            cout<<\"He can accomplish his mission.\"<<endl;\n            goto end;\n\t\t}else{\n            bool flag=false;\n            REP(i,h)REP(j,w)REP(d,5)FOR(d1,1,4){\n\t\t\t\tif(visited[master.first][master.second][(m_dir+d1)%4][i][j][d]){\n                    flag=true;\n                    break;\n\t\t\t\t}\n\t\t\t}\n            if(flag){\n                cout<<\"He cannot return to the kitchen.\"<<endl;\n\t\t\t}else{\n                cout<<\"He cannot bring tea to his master.\"<<endl;\n\t\t\t}\n\t\t}\nend:\n        ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nchar grid[16][64];\nbool used[16][64][4][16][64][4];\nvector<string> output{\n    \"He can accomplish his mission.\",\n    \"He cannot return to the kitchen.\",\n    \"He cannot bring tea to his master.\",\n};\n\nvoid dfs(int fy, int fx, int fd, int ry, int rx, int rd){\n    if(used[fy][fx][fd][ry][rx][rd]) return;\n    used[fy][fx][fd][ry][rx][rd] = true;\n    for(int diff=1; diff<=3; diff+=2){\n        int nfy = fy;\n        int nfx = fx;\n        int nfd = (fd +diff) %4;\n        while(grid[nfy+dy[nfd]][nfx+dx[nfd]] != '#'){\n            nfy += dy[nfd];\n            nfx += dx[nfd];\n        }\n        if(ry == 0){\n            dfs(nfy, nfx, nfd, 0, 0, 0);\n            continue;\n        }\n        int nry = ry;\n        int nrx = rx;\n        int nrd = (rd +diff) %4;\n        while(grid[nry][nrx] != '#'){\n            if(grid[nry+dy[nrd]][nrx+dx[nrd]] == '#'){\n                dfs(nfy, nfx, nfd, nry, nrx, nrd);\n            }\n            nry -= dy[rd];\n            nrx -= dx[rd];\n        }\n    }\n}\n\nint main(){\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(w == 0) break;\n\n        memset(used, 0, sizeof(used));\n        int sy,sx,gy,gx;\n        sy = sx = gy = gx = -1;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin >> grid[i][j];\n                if(grid[i][j] == 'K'){\n                    sy = i;\n                    sx = j;\n                }\n                if(grid[i][j] == 'M'){\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n\n        int dir_go=-1, dir_ret=-1;\n        for(int d=0; d<4; d++){\n            if(grid[sy+dy[d]][sx+dx[d]] != '#'){\n                dir_go = d;\n            }\n            if(grid[gy+dy[d]][gx+dx[d]] != '#'){\n                dir_ret = d;\n            }\n        }\n        int fsy = sy;\n        int fsx = sx;\n        while(grid[fsy+dy[dir_go]][fsx+dx[dir_go]] != '#'){\n            fsy += dy[dir_go];\n            fsx += dx[dir_go];\n        }\n        int fgy = gy;\n        int fgx = gx;\n        while(grid[fgy+dy[dir_ret]][fgx+dx[dir_ret]] != '#'){\n            fgy += dy[dir_ret];\n            fgx += dx[dir_ret];\n        }\n        \n        dfs(fsy, fsx, dir_go, sy, sx, (dir_go+1)%4);\n        dfs(fsy, fsx, dir_go, sy, sx, (dir_go+2)%4);\n        dfs(fsy, fsx, dir_go, sy, sx, (dir_go+3)%4);\n        dfs(fsy, fsx, dir_go, 0, 0, 0);\n        bool ok = false;\n        for(int i=0; i<4; i++){\n            if(used[gy][gx][i][fgy][fgx][dir_ret]){\n                ok = true;\n            }\n        }\n        if(ok){\n            cout << output[0] << endl;\n            continue;\n        }\n        if(used[gy][gx][(dir_ret+2)%4][0][0][0]){\n            cout << output[1] << endl;\n        }else{\n            cout << output[2] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    int x, y, d;\n    S() {}\n    S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { if (!vis.count(s)) vis.insert(s), q.push(s); }\nbool reach(const S& s, const S& t) {\n    set<S> vis;\n    queue<S> q;\n    const S st = forward(s.x, s.y, s.d);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == t.x && cur.y == t.y) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, set<pair<S, S> >& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish(const S& s, const S& t) {\n    set<pair<S, S> > vis;\n    queue<pair<S, S> > q;\n    const S st = forward(s.x, s.y, s.d);\n    rep (d, 4) push(q, vis, st, s.x, s.y, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == t.x && cur.y == t.y\n                && rev.x == t.x && rev.y == t.y && rev.d == t.d) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    S s(-1, -1, -1), t(-1, -1, -1);\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        s.x = i, s.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') s.d = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        t.x = i, t.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') t.d = d;\n    }\n    if (!reach(s, t)) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish(s, t)) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int w,int gy,int gx ) {\n\tstatic bool v[16][64][4];\n\tmemset(v, 0, sizeof(v));\n\tint sd = 0;\n\tqueue<pi> q;\n\tmp.first = sy * w + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / w, x = q.front().first%w;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') y += dy[dir], x + dx[dir];\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = 1;\n\t\t\t\tmp.first = y*w + x;\n\t\t\t\tmp.second = dir;\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint h, w,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h&&w) {\n\t\trep(i, h) getline(cin, in[i]);\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tiki = solve(sy, sx, w, gy, gx);\n\t\tkaeri = solve(gy, gx, w, sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <unordered_set>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n#define F(x, y, d) while (f[x+dx[d]][y+dy[d]] != '#') x+=dx[d], y+=dy[d]\ninline int h(int x, int y, int d) { return (x<<8) | (y<<2) | d; }\ninline int h(int x1, int y1, int d1, int x2, int y2, int d2) {\n    return (h(x1, y1, d1) << 16) | h(x2, y2, d2);\n}\n\nint H, W;\nchar f[16][64], h1[16][64][4];\nint sx, sy, sd, tx, ty, td;\nstd::unordered_set<int> h2;\n\nbool reach(int x, int y, int d) {\n    F(x, y, d);\n    if (x == tx && y == ty) return true;\n    if (h1[x][y][d]) return false;\n    h1[x][y][d] = 1;\n    if (reach(x, y, (d+1)%4)) return true;\n    if (reach(x, y, (d+3)%4)) return true;\n    return false;\n}\n\nbool acc(int cx, int cy, int cd, int x, int y, int d) {\n    if (f[x+dx[d]][y+dy[d]] != '#') return false;\n    F(cx, cy, cd);\n    const bool p = cx == tx && cy == ty && d == td;\n    while (f[x][y] != '#') {\n        if (!h2.insert(h(cx, cy, cd, x, y, d)).second) break;\n        if (p && x == tx && y == ty) return true;\n        if (acc(cx, cy, (cd+1)%4, x, y, (d+1)%4)) return true;\n        if (acc(cx, cy, (cd+3)%4, x, y, (d+3)%4)) return true;\n        x -= dx[d], y -= dy[d];\n    }\n    return false;\n}\n\nvoid solve() {\n    memset(h1, 0, sizeof(h1));\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') sx = i, sy = j, sd = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') tx = i, ty = j, td = d;\n    }\n    if (!reach(sx, sy, sd)) puts(\"He cannot bring tea to his master.\");\n    else {\n        h2.clear();\n        rep (d, 4) if (acc(sx, sy, sd, sx, sy, d)) {\n            puts(\"He can accomplish his mission.\");\n            return ;\n        }\n        puts(\"He cannot return to the kitchen.\");\n    }\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, -1, 0, 1 };\n\nstruct pos{\n\tint x1;\n\tint y1;\n\tint d1;\n\tint x2;\n\tint y2;\n\tint d2;\n};\n\nstruct pos2{\n\tint x1;\n\tint y1;\n\tint d1;\n};\n\nbool operator <(const pos left, const pos right){\n\treturn left.x1 == right.x1 ? left.y1 == right.y1 ? left.d1 == right.d1 ? left.x2 == right.x2 ? left.y2 == right.y2 ? left.d2 < right.d2 : left.y2 < right.y2 : left.x2 < right.x2 : left.d1 < right.d1 : left.y1 < right.y1 : left.x1 < right.x1;\n}\nbool operator <(const pos2 left, const pos2 right){\n\treturn left.x1 == right.x1 ? left.y1 == right.y1 ? left.d1 < right.d1 : left.y1 < right.y1 : left.x1 < right.x1;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w){\n\t\tint sx, sy, gx, gy;\n\t\tvvb wall(h, vb(w, false));\n\t\tREP(i, h){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tREP(j, w){\n\t\t\t\tif (s[j] == '#')\n\t\t\t\t\twall[i][j] = true;\n\t\t\t\tif (s[j] == 'K'){\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t\tif (s[j] == 'M'){\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint dirs, dirg;\n\t\tset<pos2> G2;\n\t\tqueue<pos2> Q2;\n\t\tint ans = 0;\n\t\tREP(i, 4){\n\t\t\tif (wall[sy + dy[i]][sx + dx[i]] == false)\n\t\t\t\tdirs = i;\n\t\t\tif (wall[gy + dy[i]][gx + dx[i]] == false)\n\t\t\t\tdirg = i;\n\t\t}\n\t\tREP(i, 4){\n\t\t\tG2.insert({ sx, sy, dirs });\n\t\t\tQ2.push({ sx, sy, dirs });\n\t\t}\n\n\t\twhile (!Q2.empty()){\n\t\t\tpos2 p = Q2.front(); Q2.pop();\n\t\t\tif (p.x1 == gx&&p.y1 == gy){\n\t\t\t\tans = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (wall[p.y1 + dy[p.d1]][p.x1 + dx[p.d1]] != true){\n\t\t\t\tp.x1 += dx[p.d1];\n\t\t\t\tp.y1 += dy[p.d1];\n\t\t\t}\n\n\t\t\tif (G2.find({ p.x1, p.y1, (p.d1 + 1) % 4}) == G2.end()){\n\t\t\t\tG2.insert({ p.x1, p.y1, (p.d1 + 1) % 4});\n\t\t\t\tQ2.push({ p.x1, p.y1, (p.d1 + 1) % 4});\n\t\t\t}\n\t\t\tif (G2.find({ p.x1, p.y1, (p.d1 + 3) % 4}) == G2.end()){\n\t\t\t\tG2.insert({ p.x1, p.y1, (p.d1 + 3) % 4});\n\t\t\t\tQ2.push({ p.x1, p.y1, (p.d1 + 3) % 4});\n\t\t\t}\n\t\t}\n\n\t\tset<pos> G;\n\t\tqueue<pos> Q;\n\n\t\tREP(i, 4){\n\t\t\tG.insert({ sx, sy, dirs, sx, sy, i });\n\t\t\tQ.push({ sx, sy, dirs, sx, sy, i });\n\t\t}\n\n\n\t\twhile (!Q.empty()){\n\t\t\tpos p = Q.front(); Q.pop();\n\n\t\t\twhile (wall[p.y1 + dy[p.d1]][p.x1 + dx[p.d1]] != true){\n\t\t\t\tp.x1 += dx[p.d1];\n\t\t\t\tp.y1 += dy[p.d1];\n\t\t\t}\n\n\t\t\twhile (true) {\n\n\n\t\t\t\tif (wall[p.y2 + dy[(p.d2 + 1) % 4]][p.x2 + dx[(p.d2 + 1) % 4]]){\n\t\t\t\t\tif (G.find({ p.x1, p.y1, (p.d1 + 1) % 4, p.x2, p.y2, (p.d2 + 1) % 4 }) == G.end()){\n\t\t\t\t\t\tG.insert({ p.x1, p.y1, (p.d1 + 1) % 4, p.x2, p.y2, (p.d2 + 1) % 4 });\n\t\t\t\t\t\tQ.push({ p.x1, p.y1, (p.d1 + 1) % 4, p.x2, p.y2, (p.d2 + 1) % 4 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (wall[p.y2 + dy[(p.d2 + 3) % 4]][p.x2 + dx[(p.d2 + 3) % 4]]){\n\t\t\t\t\tif (G.find({ p.x1, p.y1, (p.d1 + 3) % 4, p.x2, p.y2, (p.d2 + 3) % 4 }) == G.end()){\n\t\t\t\t\t\tG.insert({ p.x1, p.y1, (p.d1 + 3) % 4, p.x2, p.y2, (p.d2 + 3) % 4 });\n\t\t\t\t\t\tQ.push({ p.x1, p.y1, (p.d1 + 3) % 4, p.x2, p.y2, (p.d2 + 3) % 4 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!wall[p.y2 + dy[(p.d2 + 2) % 4]][p.x2 + dx[(p.d2 + 2) % 4]]){\n\t\t\t\t\tp.x2 += dx[(p.d2 + 2) % 4];\n\t\t\t\t\tp.y2 += dy[(p.d2 + 2) % 4];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (p.x1 == gx&&p.y1 == gy&&p.x2 == gx&&p.y2 == gy&&p.d2 == dirg){\n\t\t\t\tans = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ans == 2)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ans == 0)\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\tif (ans == 1)\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\t\tif (ans == 2)\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nchar str[20][70];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nbool bfs[16][64][16][64][4][4];\nint to[16][64][4];\nstruct wolf{\n\tint r1,r2,c1,c2;\n\tint d,s;\n\twolf(int a,int b,int c,int D,int e,int f){\n\t\tr1=a;c1=b;r2=c;c2=D;d=e;s=f;\n\t}\n\twolf(){}\n};\nint v[16][64][4];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&b,&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\t\tint sr,sc;\n\t\tint gr,gc;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tif(str[i][j]=='K'){sr=i;sc=j;}\n\t\t\tif(str[i][j]=='M'){gr=i;gc=j;}\n\t\t}\n\t\tqueue<wolf>Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++)\n\t\t\t\tfor(int m=0;m<4;m++)for(int n=0;n<4;n++)\n\t\t\t\t\tbfs[i][j][k][l][m][n]=0;\n\t\tint sd;\n\t\tfor(int i=0;i<4;i++)\n\t\t\tif(str[sr+dx[i]][sc+dy[i]]=='.'){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t//\tif(str[sr+dx[j]][sc+dy[j]]=='.')continue;\n\t\t\t\t\tbfs[sr][sc][sr][sc][i][j]=1;\n\t\t\t\t\tQ.push(wolf(sr,sc,sr,sc,i,j));\n\t\t\t\t}\n\t\t\t\tsd=i;\n\t\t\t}\n\t\tbool A=false;\n\t\twhile(Q.size()){\n\t\t\twolf at=Q.front();\n\t\t\tQ.pop();\n\t\t\tint tr=at.r1;\n\t\t\tint tc=at.c1;\n\t//\tprintf(\"%d %d %d %d %d %d\\n\",at.r1,at.c1,at.r2,at.c2,at.d,at.s);\n\t\t\twhile(str[tr+dx[at.d]][tc+dy[at.d]]!='#'){\n\t\t\t\ttr+=dx[at.d];\n\t\t\t\ttc+=dy[at.d];\n\t\t\t}\n\t//\t\tif(at.d%2==0)tr=to[tr][tc][at.d];\n\t\t//\telse tc=to[tr][tc][at.d];\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(i%2==0)continue;\n\t\t\t\tint nr=at.r2;\n\t\t\t\tint nc=at.c2;\n\t\t\t\twhile(1){\n\t\t\t\t\tif(str[nr][nc]=='#'){\n\t\t\t\t\t\tnr+=dx[at.s];\n\t\t\t\t\t\tnc+=dy[at.s];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[nr+dx[(i+at.s)%4]][nc+dy[(i+at.s)%4]]=='#'&&!bfs[tr][tc][nr][nc][(at.d+i)%4][(at.s+i)%4]){\n\t\t\t\t\t\tbfs[tr][tc][nr][nc][(at.d+i)%4][(at.s+i)%4]=1;\n\t\t\t\t\t\tQ.push(wolf(tr,tc,nr,nc,(at.d+i)%4,(at.s+i)%4));\n\t\t\t\t\t}\n\t\t\t\t\tnr-=dx[at.s];\n\t\t\t\t\tnc-=dy[at.s];\n\t\t\t\t}\n\t\t\t\tif(tr==gr&&tc==gc&&nr==gr&&nc==gc&&str[gr+dx[at.s]][gc+dy[at.s]]!='#')A=true;\n\t\t\t}\t\n\t\t}\n\t\tif(A){printf(\"He can accomplish his mission.\\n\");continue;}\n\t\tbool B=false;\n\t\tqueue<pair< pair<int,int> ,int> > Q2;\n\t\tQ2.push(make_pair(make_pair(sr,sc),sd));\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<4;k++)\n\t\t\tv[i][j][k]=0;\n\t\tv[sr][sc][sd]=1;\n\t\twhile(Q2.size()){\n\t\t\tint row=Q2.front().first.first;\n\t\t\tint col=Q2.front().first.second;\n\t\t\tint dir=Q2.front().second;\n\t\t//\tprintf(\"%d %d %d\\n\",row,col,dir);\n\t\t\tQ2.pop();\n\t\t\twhile(str[row+dx[dir]][col+dy[dir]]!='#'){\n\t\t\t\trow+=dx[dir];\n\t\t\t\tcol+=dy[dir];\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(i%2==0)continue;\n\t\t\t\tif(!v[row][col][(dir+i)%4]){\n\t\t\t\t\tv[row][col][(dir+i)%4]=1;\n\t\t\t\t\tQ2.push(make_pair(make_pair(row,col),(dir+i)%4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++)if(v[gr][gc][i])B=true;\n\t\tif(B)printf(\"He cannot return to the kitchen.\\n\");\n\t\telse printf(\"He cannot bring tea to his master.\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\n\t\t\tvisited[y][x][dir] = true;\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, mx, my;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, 0);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec(sx, sy, 0);\n\n\t\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    int x, y, d;\n    S() {}\n    S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const pair<S, S>& p) {\n    return (sig(p.first) << 16) | sig(p.second);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { \\\n    const int si = sig(s); \\\n    if (!vis.count(si)) vis.insert(si), q.push(s); \\\n}\n\nbool reach(const S& s, const S& t) {\n    set<int> vis;\n    queue<S> q;\n    const S st = forward(s.x, s.y, s.d);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == t.x && cur.y == t.y) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, set<int>& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish(const S& s, const S& t) {\n    set<int> vis;\n    queue<pair<S, S> > q;\n    const S st = forward(s.x, s.y, s.d);\n    rep (d, 4) push(q, vis, st, s.x, s.y, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == t.x && cur.y == t.y\n                && rev.x == t.x && rev.y == t.y && rev.d == t.d) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    S s(-1, -1, -1), t(-1, -1, -1);\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        s.x = i, s.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') s.d = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        t.x = i, t.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') t.d = d;\n    }\n    if (!reach(s, t)) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish(s, t)) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nbool memo[64][16][4][64][16][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint fway;\n\tint tx;\n\tint ty;\n\tint tway;\n};\nint gx, gy;\n\nvector<aa>astack;\n\nbool cangoal;\n\nint gway;\n\nbool check(int fx, int fy,int fway, int tx, int ty, int tway) {\n\n\tif (memo[fx][fy][fway][tx][ty][tway])return false;\n\tmemo[fx][fy][fway][tx][ty][tway] =true;\n\t\n\t//else{\n\n\t\tint nfy = fy + dy[fway];\n\t\tint nfx = fx + dx[fway];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (mp[nfy][nfx]) {\n\t\t\t\tnfx -= dx[fway];\n\t\t\t\tnfy -= dy[fway];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[fway];\n\t\t\tnfx = nfx + dx[fway];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (mp[nty][ntx]) {\n\t\t\t\tntx -= dx[tway];\n\t\t\t\tnty -= dy[tway];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\t\tint afway = (fway + 3) % 4;\n\t\t\t\tint atway = (tway + 3) % 4;\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\t\tint afway = (fway + 1) % 4;\n\t\t\t\tint atway = (tway + 1) % 4;\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnty = nty + dy[tway];\n\t\t\tntx = ntx + dx[tway];\n\t\t}\n\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\tint afway = (fway + 3) % 4;\n\t\t\tint atway = (tway + 3) % 4;\n\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\tcangoal = true;\n\t\t\t}\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\t\t}\n\n\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\tint atway = (tway + 1) % 4;\n\t\t\tint afway = (fway + 1) % 4;\n\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\tcangoal = true;\n\t\t\t}\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\n\t\t\t}\n\t\t}\n\n\t//}\n\treturn false;\n}\n\nbool memo2[64][16][4];\n\nbool check2(int fx, int fy, int fway) {\n\tif (memo2[fx][fy][fway])return false;\n\tmemo2[fx][fy][fway] = true;\n\n\tif (fx == gx&&fy == gy)return true;\n\tint nfy = fy + dy[fway];\n\tint nfx = fx + dx[fway];\n\twhile (1) {\n\n\t\tif (mp[nfy][nfx]) {\n\t\t\tnfy -= dy[fway];\n\t\t\tnfx -= dx[fway];\n\t\t\tbreak;\n\t\t}\n\t\tnfy = nfy + dy[fway];\n\t\tnfx = nfx + dx[fway];\n\t}\n\treturn (check2(nfx, nfy, (fway + 1) % 4) || check2(nfx, nfy, (fway + 3) % 4));\n}\n\nint main() {\n\twhile (1) {\n\t\tcangoal = false;\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemset(memo2, 0, sizeof(memo2));\n\t\tastack.clear();\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\t\tmp.resize(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tmp[i].resize(W);\n\t\t}\n\n\t\tint sx, sy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t\tif (mp[gy + dy[i]][gx + dx[i]] == 0) {\n\t\t\t\tgway = i;\n\t\t\t}\n\t\t}\n\t\tbool perf = false;\n\t\tfor (int i = 0; i < 4;++i)\n\t\t\tastack.push_back(aa{ sx,sy,sway,sx,sy,i });\n\n\t\twhile (!astack.empty()) {\n\t\t\taa atop(astack.back());\n\t\t\tastack.pop_back();\n\t\t\tif (check(atop.fx, atop.fy,atop.fway, atop.tx, atop.ty, atop.tway)) {\n\t\t\t\tperf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (perf) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (check2(sx,sy,sway)) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double EPS = 1e-12;\n\nstatic const int tx[] = {+0,+1,+0,-1};\nstatic const int ty[] = {-1,+0,+1,+0};\n\nclass State {\npublic:\n  int forward_x;\n  int forward_y;\n  int forward_dir;\n  int backward_x;\n  int backward_y;\n  int backward_dir;\n  State(int fx,int fy,int fd,int bx,int by,int bd)\n    : forward_x(fx),forward_y(fy),forward_dir(fd),\n      backward_x(bx),backward_y(by),backward_dir(bd) {}\n};\n\nbool visited[17][65][4][17][65][4];\nchar stage[17][65];\n\nbool two_doll_bfs(int sx,int sy,int sdir,int gx,int gy,int gdir){\n  queue<State> que;\n  memset(visited,false,sizeof(visited));\n\n  for(int bdir = 0; bdir < 4; bdir++){\n    visited[sy][sx][sdir][sy][sx][bdir] = true;\n    que.push(State(sx,sy,sdir,sx,sy,bdir));\n  }\n  \n  while(!que.empty()){\n    State s = que.front();\n    que.pop();\n    \n    int tmp_forward_dx = s.forward_x;\n    int tmp_forward_dy = s.forward_y;\n    while(stage[tmp_forward_dy][tmp_forward_dx] != '#'){\n      tmp_forward_dx += tx[s.forward_dir];\n      tmp_forward_dy += ty[s.forward_dir];\n    }\n    tmp_forward_dx -= tx[s.forward_dir];\n    tmp_forward_dy -= ty[s.forward_dir];\n    \n    int forward_dx = tmp_forward_dx;\n    int forward_dy = tmp_forward_dy;\n    \n    int backward_dx = s.backward_x;\n    int backward_dy = s.backward_y;\n    \n    while(stage[backward_dy][backward_dx] != '#'){\n\n      if(visited[forward_dy][forward_dx][s.forward_dir][backward_dy][backward_dx][s.backward_dir]){\n        backward_dx += tx[(s.backward_dir + 2) % 4];\n        backward_dy += ty[(s.backward_dir + 2) % 4];\n        continue;\n      }\n\n      const int lr[] = {3,1}; // {left,right}\n      for(int i = 0; i < 2; i++){\n        if(stage[ty[(s.backward_dir + lr[i]) % 4] + backward_dy][tx[(s.backward_dir + lr[i]) % 4] + backward_dx] != '#') continue;\n        visited[forward_dy][forward_dx][s.forward_dir][backward_dy][backward_dx][s.backward_dir] = true;\n        que.push(State(forward_dx,forward_dy,(s.forward_dir + lr[i]) % 4,\n                       backward_dx,backward_dy,(s.backward_dir + lr[i]) % 4));\n      }\n      backward_dx += tx[(s.backward_dir + 2) % 4];\n      backward_dy += ty[(s.backward_dir + 2) % 4];\n    }\n  }\n  \n  bool flag = false;\n  for(int i = 0; i < 4; i++){\n    if(visited[gy][gx][i][gy][gx][gdir]){\n      flag = true;\n      break;\n    }\n  }\n  \n  return flag;\n}\n\nbool one_doll_bfs(int sx,int sy,int sdir,int gx,int gy,int gdir){\n  queue<State> que;\n  memset(visited,false,sizeof(visited));\n\n  const int backward_dx = sx;\n  const int backward_dy = sy;\n  const int backward_dir = 0;\n\n  que.push(State(sx,sy,sdir,backward_dx,backward_dy,backward_dir));\n  \n  while(!que.empty()){\n    State s = que.front();\n    que.pop();\n    \n    int tmp_forward_dx = s.forward_x;\n    int tmp_forward_dy = s.forward_y;\n\n    while(stage[tmp_forward_dy][tmp_forward_dx] != '#'){\n      tmp_forward_dx += tx[s.forward_dir];\n      tmp_forward_dy += ty[s.forward_dir];\n    }\n    tmp_forward_dx -= tx[s.forward_dir];\n    tmp_forward_dy -= ty[s.forward_dir];\n    \n    int forward_dx = tmp_forward_dx;\n    int forward_dy = tmp_forward_dy;\n    \n    if(visited[forward_dy][forward_dx][s.forward_dir][backward_dy][backward_dx][backward_dir]) continue;\n    visited[forward_dy][forward_dx][s.forward_dir][backward_dy][backward_dx][backward_dir] = true;\n\n    const int lr[] = {3,1}; // {left,right}\n    for(int i = 0; i < 2; i++){\n      que.push(State(forward_dx,forward_dy,(s.forward_dir + lr[i]) % 4,\n                     backward_dx,backward_dy,backward_dir));\n    }\n  }\n  \n  bool flag = false;\n  for(int i = 0; i < 4; i++){\n    if(visited[gy][gx][i][backward_dy][backward_dx][backward_dir]){\n      flag = true;\n      break;\n    }\n  }\n  \n  return flag;\n}\n\nvoid disp(int W,int H){\n  for(int y = 0; y < H; y++){\n    for(int x = 0; x < W; x++){\n      printf(\"%c\",stage[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n\nint main(){\n  int W,H;\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W == 0 && H == 0) break;\n    // memset(stage,'\\0',sizeof(stage));\n\n    int sx,sy,sdir;\n    int gx,gy,gdir;\n\n    for(int y = 0; y < H; y++){\n      char line[128];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(stage[y][x] == 'K'){\n          sx = x;\n          sy = y;\n        }\n        if(stage[y][x] == 'M'){\n          gx = x;\n          gy = y;\n        }\n      }\n    }\n\n    for(int i = 0; i < 4; i++){\n      if(stage[sy + ty[i]][sx + tx[i]] == '.'){\n        sdir = i;\n      }\n      if(stage[gy + ty[i]][gx + tx[i]] == '.'){\n        gdir = i;\n      }\n    }\n\n    if(one_doll_bfs(sx,sy,sdir,gx,gy,gdir)){\n      if(two_doll_bfs(sx,sy,sdir,gx,gy,gdir)){\n            printf(\"He can accomplish his mission.\\n\");\n      }\n      else{\n            printf(\"He cannot return to the kitchen.\\n\");\n      }\n    }\n    else{\n      printf(\"He cannot bring tea to his master.\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int y,x,ry,rx,d,rd;\n};\n\nstruct SS{\n  int y,x,d;\n};\n\nint main(){\n  for(int W,H;cin>>W>>H,W;){\n    char g[16][64];\n    int y,x;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>g[i][j];\n\tif(g[i][j]=='K'){\n\t  y=i;\n\t  x=j;\n\t}\n      }\n    }\n    int dy[]={-1,0,1,0};\n    int dx[]={0,1,0,-1};\n    int d;\n    for(d=0;g[y+dy[d]][x+dx[d]]=='#';d++);\n    vector<S> v;\n    vector<SS> vs{{y,x,d}};\n    for(int i=0;i<4;i++){\n      v.push_back({y,x,y,x,d,i});\n    }\n    static bool p[16][64][16][64][4][4];\n    bool ps[16][64][4]={};\n    fill(p[0][0][0][0][4],p[16][0][0][0][4],false);\n    bool reach=false,ret=false;\n    while(!vs.empty()){\n      auto cs=vs.back();\n      reach|=g[cs.y][cs.x]=='M';\n      vs.pop_back();\n      if(ps[cs.y][cs.x][cs.d]++)continue;\n      int ny,nx;\n      for(ny=cs.y,nx=cs.x;g[ny+dy[cs.d]][nx+dx[cs.d]]!='#';ny+=dy[cs.d],nx+=dx[cs.d]);\n      for(int i=1;i<=3;i+=2){\n\tvs.push_back({ny,nx,(cs.d+i)%4});\n      }\n    }\n\n    while(!v.empty()){\n      S cs=v.back();\n      v.pop_back();\n      if(p[cs.y][cs.x][cs.ry][cs.rx][cs.d][cs.rd]++)continue;\n      int ny,nx;\n      for(ny=cs.y,nx=cs.x;g[ny+dy[cs.d]][nx+dx[cs.d]]!='#';ny+=dy[cs.d],nx+=dx[cs.d]);\n\n      for(int rny=cs.ry,rnx=cs.rx;g[rny][rnx]!='#';rny+=dy[cs.rd],rnx+=dx[cs.rd]){\n\tret|=g[ny][nx]=='M'&&g[rny][rnx]=='M'&&g[rny-dy[cs.rd]][rnx-dx[cs.rd]]!='#';\n\tfor(int i=1;i<=3;i+=2){\n\t  if(g[rny+dy[(cs.rd+i+2)%4]][rnx+dx[(cs.rd+i+2)%4]]=='#'){\n\t    v.push_back({ny,nx,rny,rnx,(cs.d+i)%4,(cs.rd+i)%4});\n\t  }\n  for(int W,H;cin>>W>>H,W;){\n    char g[16][64];\n    int y,x;\n    for(int i=0;i<H;\n  for(int W,H;cin>>W>>H,W;){\n    char g[16][64];\n    int y,x;\n    for(int i=0;i<H;\n  for(int W,H;cin>>W>>H,W;){\n    char g[16][64];\n    int y,x;\n    for(int i=0;i<H;\n  for(int W,H;cin>>W>>H,W;){\n    char g[16][64];\n    int y,x;\n    for(int i=0;i<H;\n\t}\n      }\n    }\n    cout<<(!reach?\"He cannot bring tea to his master.\":\n\t   !ret?\"He cannot return to the kitchen.\":\n\t   \"He can accomplish his mission.\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\t/*\n\tif (!(m[i+dy[(k+2)%4]][j+dx[(k+2)%4]] == '.'||\n\t      m[i+dy[(k+1)%4]][j+dx[(k+1)%4]] == '#'||\n\t      m[i+dy[(k+3)%4]][j+dx[(k+3)%4]] == '#')\n\t    )continue;\n\t*/\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t}\n      }\n    }\n  }\n}\n\nvoid output(int r,int c,int ry,int rx,int rd,int rl){\n  const char dd[]={'N','E','S','W'};\n  const char aho[]={'R','L'};\n  cout <<\"Outputbegin\"<<endl;\n  cout << aho[rl] << endl;\n  rep(i,r){\n    rep(j,c){\n      if (ry == i && rx == j)cout << dd[rd];\n      else cout << m[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl<<endl;\n}\n\nbool cango;\n\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gy,int gx,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  if (m[sy][sx] == 'M')cango=true;\n  \n  if (m[sy][sx] == 'M' &&\n      ry == gy && rx == gx && rd == gd)return true;\n\n  Edge cpy1,cpy2;\n\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\t/*\n\tif (m[sy][sx] == 'M' &&\n\t    cpy2.y == gy && cpy2.x == gx && cpy2.d == gd){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  output(r,c,sy,sx,sd,l);\n\t  //\t  cout << cpy1.y <<\" \" << cpy1.x << endl;\n\t  //\t  cout << \"final state \" << cpy2.y <<\" \" << cpy2.x  << \" \" << cpy2.d << endl;\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n\t*/\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  //output(r,c,sy,sx,sd,l);\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n      }\n    }\n  }\n  \n  return false;\n}\n\n\nbool vis2[R][C][DIR];\nbool solve_to_kit(int r,int c,int sy,int sx,int sd){\n  if (vis2[sy][sx][sd])return false;\n  vis2[sy][sx][sd]=true;\n  if (m[sy][sx] == 'M')return true;\n  \n  Edge cpy1;\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      if (solve_to_kit(r,c,cpy1.y,cpy1.x,cpy1.d))return true;\n     }\n  }\n  return false;\n}\n\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    rep(i,r)rep(j,c)rep(k,k)vis2[i][j][k]=false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n    /*\n    char TEST[]={'N','E','S','W'};\n    char TURN[]={'R','L'};\n    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,edge[i][j][k][l].size()){\n\t      cout <<\"pos \" <<  i<<\" \" << j <<\" dir \" << TEST[k] <<\" turn to \" <<\n\t\tTURN[l] ;\n\t      cout << \" will go \" << \n\t\tedge[i][j][k][l][m].y <<\" \" << edge[i][j][k][l][m].x <<\" dir \" \n\t\t   <<TEST[edge[i][j][k][l][m].d] << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n\n    /*    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout << i <<\" \" << j <<\" \" << TEST[k] <<\" \" \n\t\t   <<TURN[l] << endl; \n\t      output(r,c,rev[i][j][k][l][m].y,rev[i][j][k][l][m].x,\n\t\t     rev[i][j][k][l][m].d,l);\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n    if (solve_to_kit(r,c,iniy,inix,inidir))cango=true;\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  /*\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n  cout << vis[R-1][C-1][DIR-1][R-1][C-1][DIR-1] << endl;\n  */\n  \n  rep(i,R)rep(j,C)\n    rep(ii,R)rep(jj,C)\ncout << vis[i][j][0][ii][jj][0] <<\" \" << i <<\" \" << j <<\" \" << 0 <<\" \" << ii<<\" \" << jj <<\" \" << 0 << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, mx, my;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, 0);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec(mx, my, 0);\n\n\t\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[sy][sx][dir];\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0;i<(int)n;i++)\n#define REPS(i, n) for(int i=1;i<=(int)n;i++)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint d[10] = {0, -1, 0, 1, 0, -1, 0, 1, 0, -1};\nint w, h, s1, s2, t1, t2;\n\nchar ss[100][100];\nint encode(int x, int y, int d){\n\treturn x*16*4 + y*4 + d;\n}\n\nunsigned char dp[64*16*4][64*16*4];\nunsigned char dp2[64*16*4];\nint main(){\n\twhile(cin >> w >> h, w){\n\t\tREP(i, h) cin >> ss[i];\n\t\tvector<vi> g(64*16*4, vi(2, -1));\n\t\tvector<vector<vi>> invg(64*16*4, vector<vi>(2));\n\t\tREP(i, h)REP(j, w)if(ss[i][j] != '#'){\n\t\t\tREP(k, 4)if(ss[i+d[k]][j+d[k+1]] == '.'){\n\t\t\t\tint dx=j, dy=i;\n\t\t\t\twhile(ss[dy+d[k]][dx+d[k+1]] != '#'){\n\t\t\t\t\tdy+=d[k]; dx+=d[k+1];\n\t\t\t\t}\n\t\t\t\tif(ss[i][j] == 'K'){\n\t\t\t\t\ts1 = encode(dx, dy, k);\n\t\t\t\t\ts2 = encode(j, i, k);\n\t\t\t\t}\n\t\t\t\tif(ss[i][j] == 'M'){\n\t\t\t\t\tt1 = encode(j, i, k^2);\n\t\t\t\t\tt2 = encode(dx, dy, k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(k, 4)REP(l, 2){\n\t\t\t\tint dx=j, dy=i;\n\t\t\t\tint dir = (k+1+l*2)%4;\n\t\t\t\twhile(ss[dy+d[dir]][dx+d[dir+1]] != '#'){\n\t\t\t\t\tdy+=d[dir]; dx+=d[dir+1];\n\t\t\t\t}\n\t\t\t\tint u = encode(j, i, k);\n\t\t\t\tint v = encode(dx, dy, dir);\n\t\t\t\tinvg[v][!l].push_back(u);\n\t\t\t\tg[u][l] = v;\n\t\t\t}\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tqueue<pii> q;\n\t\tREPS(i, 3) q.emplace(s1, s2^i);\n\t\tint ans = 0;\n\t\twhile(!q.empty()){\n\t\t\tint u1, u2; tie(u1, u2) = q.front(); q.pop();\n\t\t\tif((u1|3) == (t1|3)) ans = 1;\n\t\t\tif((u1|3)== (t1|3) && u2 == t2){\n\t\t\t\tans = 2; break;\n\t\t\t}\n\t\t\tREP(l, 2){\n\t\t\t\tint v1 = g[u1][l];\n\t\t\t\tif(u2 == -1 || invg[u2][l].empty()){\n\t\t\t\t\tif(!dp2[v1]){\n\t\t\t\t\t\tdp2[v1] = 1;\n\t\t\t\t\t\tq.emplace(v1, -1);\n\t\t\t\t\t}\n\t\t\t\t}else for(int v2 : invg[u2][l]){\n\t\t\t\t\tif(!dp[v1][v2]){\n\t\t\t\t\t\tdp[v1][v2] = 1;\n\t\t\t\t\t\tq.emplace(v1, v2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 0) puts(\"He cannot bring tea to his master.\");\n\t\tif(ans == 1) puts(\"He cannot return to the kitchen.\");\n\t\tif(ans == 2) puts(\"He can accomplish his mission.\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <unordered_set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    unsigned x, y, d;\n    S() {}\n    S(unsigned x, unsigned y, unsigned d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const pair<S, S>& p) {\n    return (sig(p.first) << 16) | sig(p.second);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { \\\n    const int si = sig(s); \\\n    if (!vis.count(si)) vis.insert(si), q.push(s); \\\n}\n\nbool reach(const S& s, const S& t) {\n    unordered_set<int> vis;\n    queue<S> q;\n    const S st = forward(s.x, s.y, s.d);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == t.x && cur.y == t.y) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, unordered_set<int>& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish(const S& s, const S& t) {\n    unordered_set<int> vis;\n    queue<pair<S, S> > q;\n    const S st = forward(s.x, s.y, s.d);\n    rep (d, 4) push(q, vis, st, s.x, s.y, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == t.x && cur.y == t.y\n                && rev.x == t.x && rev.y == t.y && rev.d == t.d) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    S s(-1, -1, -1), t(-1, -1, -1);\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        s.x = i, s.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') s.d = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        t.x = i, t.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') t.d = d;\n    }\n    if (!reach(s, t)) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish(s, t)) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <unordered_set>\nusing namespace std;\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\ntypedef long long ll;\n#define EXIST(a, b) ((a).find(b)!=(a).end())\n\nint dy[4]={1, 0, -1, 0};\nint dx[4]={0, 1, 0, -1};\n// char c[70][20];\nchar c[20][70];\nunordered_set<int> s;\nint ky, kx, kd, my, mx, md, ny, nx, nd;\nbool cango, canback;\n\nvoid dp(int ay, int ax, int ad, int by, int bx, int bd){\n\tint cod=(ad<<10|ay<<6|ax)<<12|(bd<<10|by<<6|bx);\n\tif(EXIST(s, cod)) return;\n\ts.insert(cod);\n\t// printf(\"(%d, %d)-%d (%d, %d)-%d\\n\", ay, ax, ad, by, bx, bd);\n\tif(ay==my && ax==mx){\n\t\t// cango=true;\n\t\tif(by==ny && bx==nx && bd==nd){\n\t\t\tcanback=true;\n\t\t}\n\t}\n\tREP(di, 2){\n\t\tint cy=ay, cx=ax, cd=(ad+di*2-1+4)%4;\n\t\twhile(c[cy+dy[cd]][cx+dx[cd]]=='.') cy+=dy[cd], cx+=dx[cd];\n\t\tint ey=by, ex=bx, \n\t\t\t\t// ed=(bd-di*2+1+4)%4, \n\t\t\t\ted=(bd+di*2-1+4)%4, \n\t\t\t\tee=(bd+2)%4;\n\t\tdo{\n\t\t\t// printf(\"at (%d, %d)-%d %c: [%d, %d]=%c\\n\", ay, ax, ad, di?'L':'R', ey+dy[ed], ex+dx[ed], c[ey+dy[ed]][ex+dx[ed]]);\n\t\t\tif(c[ey+dy[ed]][ex+dx[ed]]=='#'){\n\t\t\t\t// printf(\"(%d, %d)-%d (%d, %d)-%d --%c--> (%d, %d)-%d (%d, %d)-%d\\n\", \n\t\t\t\t// \t\tay, ax, ad, by, bx, bd, di?'L':'R', cy, cx, cd, ey, ex, ed);\n\t\t\t\tdp(cy, cx, cd, ey, ex, ed);\n\t\t\t}\n\t\t\tey+=dy[ee], ex+=dx[ee];\n\t\t}while(c[ey][ex]=='.');\n\t\t// printf(\"END LOOP\\n\");\n\t}\n}\n\nvoid dp2(int ay, int ax, int ad){\n\tint cod=(ad<<10|ay<<6|ax);\n\tif(EXIST(s, cod)) return;\n\ts.insert(cod);\n\tif(ay==my && ax==mx){\n\t\tcango=true;\n\t}\n\tREP(di, 2){\n\t\tint cy=ay, cx=ax, cd=(ad+di*2-1+4)%4;\n\t\twhile(c[cy+dy[cd]][cx+dx[cd]]=='.') cy+=dy[cd], cx+=dx[cd];\n\t\tdp2(cy, cx, cd);\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tcango=canback=false;\n\t\tREP(i, h) scanf(\"%s\", c[i]);\n\n\t\tREP(i, h) REP(j, w) if(c[i][j]=='K') ky=i, kx=j;\n\t\tREP(i, 4) if(c[ky+dy[i]][kx+dx[i]]=='.') kd=i;\n\t\tc[ky][kx]='.';\n\n\t\tREP(i, h) REP(j, w) if(c[i][j]=='M') my=i, mx=j;\n\t\tREP(i, 4) if(c[my+dy[i]][mx+dx[i]]=='.') md=i;\n\t\tc[my][mx]='.';\n\n\t\tint ay=ky, ax=kx, ad=kd;//, by=my, bx=mx, bd=md;\n\t\tny=my, nx=mx, nd=md;\n\t\twhile(c[ay+dy[ad]][ax+dx[ad]]=='.') ay+=dy[ad], ax+=dx[ad];\n\t\twhile(c[ny+dy[nd]][nx+dx[nd]]=='.') ny+=dy[nd], nx+=dx[nd];\n\t\tREP(i, 4){\n\t\t\tif(i!=kd){\n\t\t\t\ts.clear();\n\t\t\t\tdp2(ay, ax, ad);\n\t\t\t\ts.clear();\n\t\t\t\tdp(ay, ax, ad, ky, kx, i);\n\t\t\t}\n\t\t}\n\n\t\tif(!cango) printf(\"He cannot bring tea to his master.\\n\");\n\t\telse if(!canback) printf(\"He cannot return to the kitchen.\\n\");\n\t\telse printf(\"He can accomplish his mission.\\n\");\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 2000500;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nint w, h;\nchar mp[16][64];\nbool exi[16][64][4][16][64][4];\n\nbool canr[16][64][4];\nstruct status {\n\tint x1, y1, d1, x2, y2, d2;\n};\nvoid solve() {\n\trep(i, h)rep(j, w) {\n\t\tcin >> mp[i][j];\n\t}\n\trep(i, h)rep(j, w)rep(k, 4)rep(x, h)rep(y, w)rep(l, 4) {\n\t\texi[i][j][k][x][y][l] = false;\n\t}\n\tqueue<status> q;\n\trep(i, h)rep(j, w)if (mp[i][j] == 'K') {\n\t\tint d = 0;\n\t\trep(k, 4) {\n\t\t\tint nx = i + dx[k];\n\t\t\tint ny = j + dy[k];\n\t\t\tif (mp[nx][ny] != '#') {\n\t\t\t\td = k;\n\t\t\t}\n\t\t}\n\t\trep(k, 4) {\n\t\t\tif (k == (2^d))continue;\n\t\t\texi[i][j][d][i][j][k] = true;\n\t\t\tq.push({ i,j,d,i,j,k });\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tstatus s = q.front(); q.pop();\n\t\tint x1 = s.x1;\n\t\tint y1 = s.y1;\n\t\tint d1 = s.d1;\n\t\t/*if (s.x1 == 6 && s.y1 == 10) {\n\t\t\tcout << s.d1 << endl;\n\t\t}*/\n\t\t/*if (s.x2 == 4 && s.y2 == 5 && s.d2 == 3) {\n\t\t\tcout << s.x1 << \" \" << s.y1 << \" \" << s.d1 << endl;\n\t\t}*/\n\t\t//cout << s.x1 << \" \" << s.y1 << \" \" << s.d1 << endl;\n\t\t//cout << s.x1 << \" \" << s.y1 << \" \" << s.d1 << \" \" << s.x2 << \" \" << s.y2 << \" \" << s.d2 << endl;\n\t\twhile (mp[x1 + dx[d1]][y1 + dy[d1]] != '#') {\n\t\t\tx1 += dx[d1]; y1 += dy[d1];\n\t\t}\n\t\tint x2 = s.x2;\n\t\tint y2 = s.y2;\n\t\tint d2 = s.d2;\n\t\t//assert(mp[x1][y1] != '#');\n\t\t//assert(mp[x2][y2] != '#');\n\t\twhile (mp[x2][y2] != '#') {\n\t\t\t//turn right\n\t\t\tint dd1 = (d1 + 1) % 4;\n\t\t\tint dd2 = (d2 + 1) % 4;\n\t\t\tif (mp[x2 + dx[dd2 ^ 2]][y2 + dy[dd2 ^ 2]] == '#') {\n\t\t\t\tif (!exi[x1][y1][dd1][x2][y2][dd2]) {\n\t\t\t\t\texi[x1][y1][dd1][x2][y2][dd2] = true;\n\t\t\t\t\tq.push({ x1,y1,dd1,x2,y2,dd2 });\n\t\t\t\t}\n\t\t\t}\n\t\t\t//turn left\n\t\t\tdd1 = (d1 + 3) % 4;\n\t\t\tdd2 = (d2 + 3) % 4;\n\t\t\tif (mp[x2 + dx[dd2 ^ 2]][y2 + dy[dd2 ^ 2]] == '#') {\n\t\t\t\tif (!exi[x1][y1][dd1][x2][y2][dd2]) {\n\t\t\t\t\texi[x1][y1][dd1][x2][y2][dd2] = true;\n\t\t\t\t\tq.push({ x1,y1,dd1,x2,y2,dd2 });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx2 += dx[d2];\n\t\t\ty2 += dy[d2];\n\t\t}\n\t}\n\tint gx, gy;\n\tint gd = 0;\n\trep(i, h)rep(j, w) {\n\t\tif (mp[i][j] == 'M') {\n\t\t\tgx = i, gy = j;\n\t\t\trep(k, 4) {\n\t\t\t\tif (mp[i + dx[k]][j + dy[k]] != '#') {\n\t\t\t\t\tgd = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<status> vf,vs;\n\trep(k, 4) {\n\t\tint cx = gx, cy = gy;\n\t\twhile (mp[cx][cy] != '#') {\n\t\t\tvf.push_back({ cx,cy,k ^ 2,0,0,0 });\n\t\t\t/*if (k == gd) {\n\t\t\t\tvs.push_back({ 0,0,0,cx,cy , k ^ 2 });\n\t\t\t}*/\n\n\t\t\tcx += dx[k];\n\t\t\tcy += dy[k];\n\t\t}\n\t\tcx -= dx[k]; cy -= dy[k];\n\t\tif (k == gd) {\n\t\t\tvs.push_back({ 0,0,0,cx,cy,k ^ 2 });\n\t\t}\n\t}\n\tfor (status s2 : vs) {\n\t\t//cout << s2.x2 << \" \" << s2.y2 << \" \" << s2.d2 << endl;\n\t}\n\tfor (status s1 : vf)for (status s2 : vs) {\n\t\tif (exi[s1.x1][s1.y1][s1.d1][s2.x2][s2.y2][s2.d2]) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\trep(i, h)rep(j, w)rep(k, 4) {\n\t\tcanr[i][j][k] = false;\n\t}\n\trep(i, h)rep(j, w){\n\t\tif (mp[i][j] == 'K') {\n\t\t\tint d = 0;\n\t\t\trep(k, 4) {\n\t\t\t\tint nx = i + dx[k];\n\t\t\t\tint ny = j + dy[k];\n\t\t\t\tif (mp[nx][ny] != '#')d = k;\n\t\t\t}\n\t\t\tcanr[i][j][d] = true;\n\t\t\tq.push({ i,j,d });\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tstatus s = q.front(); q.pop();\n\t\tint x = s.x1;\n\t\tint y = s.y1;\n\t\tint d = s.d1;\n\t\twhile (mp[x + dx[d]][y + dy[d]] != '#') {\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t}\n\t\tint dd = (d + 1) % 4;\n\t\tif (!canr[x][y][dd]) {\n\t\t\tcanr[x][y][dd] = true;\n\t\t\tq.push({ x,y,dd });\n\t\t}\n\t\tdd = (d + 3) % 4;\n\t\tif (!canr[x][y][dd]) {\n\t\t\tcanr[x][y][dd] = true;\n\t\t\tq.push({ x,y,dd });\n\t\t}\n\t}\n\tif (canr[gx][gy][gd ^ 1] || canr[gx][gy][gd ^ 3]) {\n\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\t\treturn;\n\t}\n\tcout << \"He cannot bring tea to his master.\" << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f(); //init();\n\t//int t; cin >> t; rep(i, t)solve();\n\twhile(cin>>w>>h,w)solve();\n\t//solve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n  cout << vis[R-1][C-1][DIR-1][R-1][C-1][DIR-1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint W, H;\nbool wall[16][64];\nP to[16][64][4];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nint rot[2] = {-1, 1};\n\nbool reached[16][64][16][64][4][4];\n\nstruct Node {\n\tint x1, y1, x2, y2, d1, d2;\n};\nstruct SingleNode {\n\tint x, y, d;\n};\n\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nint main() {\n\twhile ( cin >> W >> H, W || H ) {\n\t\tfill(wall[0], wall[16], false);\n\t\tint sx, sy, gx, gy;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tswitch (str[x]) {\n\t\t\t\t\tcase '.': break;\n\t\t\t\t\tcase '#': wall[y][x] = true; break;\n\t\t\t\t\tcase 'K': sx = x, sy = y; break;\n\t\t\t\t\tcase 'M': gx = x, gy = y; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int t = 0; t < W+H; ++t) {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\t\tint nx = x + dx[d];\n\t\t\t\t\t\t\tint ny = y + dy[d];\n\t\t\t\t\t\t\tif ( inRange(nx, ny) && !wall[ny][nx] ) {\n\t\t\t\t\t\t\t\tto[y][x][d] = P(nx, ny);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tto[y][x][d] = P(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tP np = to[y][x][d];\n\t\t\t\t\t\t\tint nx = np.first, ny = np.second;\n\t\t\t\t\t\t\tto[y][x][d] = to[ny][nx][d];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill(&reached[0][0][0][0][0][0], &reached[0][0][0][0][0][0] + 16*64*16*64*4*4, false);\n\n\t\tSingleNode G[16][64][4][2];\n\t\tvector<SingleNode> rG[16][64][4][2];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\tfor (int dd = 0; dd < 2; ++dd) {\n\t\t\t\t\t\tint xx = x+dx[d], yy = y+dy[d];\n\t\t\t\t\t\tif ( wall[y][x] || (inRange(xx, yy) && !wall[yy][xx]) ) {\n\t\t\t\t\t\t\tG[y][x][d][dd] = (SingleNode){-1, -1, -1};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint nd = (d + rot[dd] + 4) % 4;\n\t\t\t\t\t\t\tP np = to[y][x][nd];\n\t\t\t\t\t\t\tG[y][x][d][dd] = (SingleNode){np.first, np.second, nd};\n\t\t\t\t\t\t\trG[np.second][np.first][nd][dd].push_back( (SingleNode){x, y, d} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<Node> Q;\n\t\tint sx2, sy2, gx2, gy2, sd;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint x = gx + dx[i];\n\t\t\tint y = gy + dy[i];\n\t\t\tif ( inRange(x, y) && !wall[y][x] ) {\n\t\t\t\tP p = to[gy][gx][i];\n\t\t\t\tgx2 = p.first;\n\t\t\t\tgy2 = p.second;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint x = sx + dx[i];\n\t\t\tint y = sy + dy[i];\n\t\t\tif ( inRange(x, y) && !wall[y][x] ) {\n\t\t\t\tP p = to[sy][sx][i];\n\t\t\t\tsx2 = p.first;\n\t\t\t\tsy2 = p.second;\n\t\t\t\tsd = i;\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n//\t\t\t\t\tcout << sx2 << \" \" << sy2 << \" \" << sx << \" \" << sy << endl;\n\t\t\t\t\treached[sy2][sx2][sy][sx][i][j] = true;\n\t\t\t\t\tQ.push( (Node){sx2, sy2, sx, sy, i, j} );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n/*\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tint snx = sx + dx[i];\n\t\t\t\tint sny = sy + dy[i];\n\t\t\t\tint gnx = gx + dx[i];\n\t\t\t\tint gny = gy + dy[i];\n\t\t\t\tif ( inRange(snx, sny) && !wall[sny][snx] && (!inRange(gnx, gny) || wall[gny][gnx]) ) {\n\t\t\t\t\treached[sy][sx][sy][sx][i][j] = true;\n\t\t\t\t\tQ.push( (Node){sx, sy, sx, sy, i, j} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n*/\n\t\tint ans = 0;\n/*\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcout << (wall[y][x] ? \"#\" : \".\");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.front(); Q.pop();\n\t\t\tint x1 = node.x1;\n\t\t\tint y1 = node.y1;\n\t\t\tint x2 = node.x2;\n\t\t\tint y2 = node.y2;\n\t\t\tint d1 = node.d1;\n\t\t\tint d2 = node.d2;\n\t\t\tif (x1 == gx && y1 == gy) {\n\t\t\t\tif (x2 == gx2 && y2 == gy2) {\n\t\t\t\t\tans = max(ans, 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = max(ans, 1);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << d1 << \" \" << d2 << endl;\n\t\t\tfor (int dd = 0; dd < 2; ++dd) {\n\t\t\t\tSingleNode& next1 = G[y1][x1][d1][dd];\n//\t\t\t\tcout << y2 << \" \" << x2 << \" \" << d2 << \" \" << dd << endl;\n\t\t\t\tassert( !wall[y1][x1] );\n\t\t\t\tassert( !wall[y2][x2] );\n//\t\t\t\tassert( rG[y2][x2][d2][!dd].size() > 0 );\n\t\t\t\tfor (int i = 0; i < rG[y2][x2][d2][!dd].size(); ++i) {\n\t\t\t\t\tSingleNode& next2 = rG[y2][x2][d2][!dd][i];\n\t\t\t\t\tif ( !reached[next1.y][next1.x][next2.y][next2.x][next1.d][next2.d] ) {\n\t\t\t\t\t\treached[next1.y][next1.x][next2.y][next2.x][next1.d][next2.d] = true;\n\t\t\t\t\t\tQ.push( (Node){next1.x, next1.y, next2.x, next2.y, next1.d, next2.d} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 0) {\n\t\t\tbool used[16][64][4] = {0};\n\t\t\tqueue<SingleNode> Q2; Q2.push({sx2, sy2, sd}); used[sy2][sx2][sd] = true;\n\t\t\twhile ( !Q2.empty() ) {\n\t\t\t\tSingleNode node = Q2.front(); Q2.pop();\n\t\t\t\tint x = node.x, y = node.y, d = node.d;\n\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\tans = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int dd = 0; dd < 2; ++dd) {\n\t\t\t\t\tSingleNode& next = G[y][x][d][dd];\n\t\t\t\t\tif ( !used[next.y][next.x][next.d] ) {\n\t\t\t\t\t\tused[next.y][next.x][next.d] = true;\n\t\t\t\t\t\tQ2.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans == 0) {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t\telse if (ans == 1) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unordered_set>\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\n#define F(x, y, d) while (f[x+dx[d]][y+dy[d]] != '#') x+=dx[d], y+=dy[d]\ninline int h(int x, int y, int d) { return (x<<8) | (y<<2) | d; }\ninline int h(int x1, int y1, int d1, int x2, int y2, int d2) {\n    return (h(x1, y1, d1) << 16) | h(x2, y2, d2);\n}\n\nint H, W;\nchar f[16][64], h1[16][64][4];\nint sx, sy, sd, tx, ty, td;\nstd::unordered_set<int> h2;\n\nbool reach(int x, int y, int d) {\n    F(x, y, d);\n    if (x == tx && y == ty) return true;\n    if (h1[x][y][d]) return false;\n    h1[x][y][d] = 1;\n    if (reach(x, y, (d+1)%4)) return true;\n    if (reach(x, y, (d+3)%4)) return true;\n    return false;\n}\n\nbool acc(int cx, int cy, int cd, int x, int y, int d) {\n    if (f[x+dx[d]][y+dy[d]] != '#') return false;\n    F(cx, cy, cd);\n    const bool p = cx == tx && cy == ty && d == td;\n    while (f[x][y] != '#') {\n        if (!h2.insert(h(cx, cy, cd, x, y, d)).second) break;\n        if (p && x == tx && y == ty) return true;\n        if (acc(cx, cy, (cd+1)%4, x, y, (d+1)%4)) return true;\n        if (acc(cx, cy, (cd+3)%4, x, y, (d+3)%4)) return true;\n        x -= dx[d], y -= dy[d];\n    }\n    return false;\n}\n\nvoid solve() {\n    memset(h1, 0, sizeof(h1));\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') sx = i, sy = j, sd = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') tx = i, ty = j, td = d;\n    }\n    if (!reach(sx, sy, sd)) puts(\"He cannot bring tea to his master.\");\n    else {\n        h2.clear();\n        rep (d, 4) if (acc(sx, sy, sd, sx, sy, d)) {\n            puts(\"He can accomplish his mission.\");\n            return ;\n        }\n        puts(\"He cannot return to the kitchen.\");\n    }\n}\n\nint main() {\n    char buf[80];\n    for (;;) {\n        fgets(buf, 80, stdin);\n        sscanf(buf, \"%d%d\", &W, &H);\n        if (W == 0) return 0;\n        rep (i, H) {\n            fgets(buf, 80, stdin);\n            memcpy(f[i], buf, W);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct state{\n\tint i,j,k; // 行きの y 座標, x 座標, 向き\n};\n\nstruct state2{\n\tint i,j,k,y,x,d; // 行きの y 座標, x 座標, 向き, 帰りの y 座標, x 座標, 向き\n};\n\nint h,w;\nchar B[16][65];\n\nvoid go_straight(int i,int j,int k,int &i2,int &j2){\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j;\n}\n\nvoid turn_left(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+1)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nvoid turn_right(int i,int j,int k,int &i2,int &j2,int &k2){\n\tk=(k+3)%4;\n\twhile(B[i+dy[k]][j+dx[k]]=='.') i+=dy[k], j+=dx[k];\n\ti2=i, j2=j, k2=k;\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w){\n\t\trep(i,h) scanf(\"%s\",B[i]);\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h) rep(j,w) {\n\t\t\tif(B[i][j]=='K') sx=j, sy=i, B[i][j]='.';\n\t\t\tif(B[i][j]=='M') gx=j, gy=i, B[i][j]='.';\n\t\t}\n\t\tint gk;\n\t\trep(k,4) if(B[gy+dy[k]][gx+dx[k]]=='.') gk=k;\n\n\t\tbool ok=false;\n\t\t{\n\t\t\tstatic bool vis[16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) vis[i][j][k]=false;\n\n\t\t\tqueue<state> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\tvis[yy][xx][k]=true;\n\t\t\t\t\tQ.push((state){yy,xx,k});\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k;\n\n\t\t\t\tif(i==gy && j==gx){ ok=true; break; }\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\tif(!vis[i2][j2][k2]){\n\t\t\t\t\tvis[i2][j2][k2]=true;\n\t\t\t\t\tQ.push((state){i2,j2,k2});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!ok) puts(\"He cannot bring tea to his master.\");\n\n\t\tok=false;\n\t\t{\n\t\t\tvector<state> from_L[16][64][4],from_R[16][64][4];\n\t\t\trep(i,h) rep(j,w) if(B[i][j]=='.') rep(k,4) {\n\t\t\t\tint y,x,d;\n\t\t\t\tturn_left (i,j,k,y,x,d); from_L[y][x][d].push_back((state){i,j,k});\n\t\t\t\tturn_right(i,j,k,y,x,d); from_R[y][x][d].push_back((state){i,j,k});\n\t\t\t}\n\n\t\t\tstatic bool vis[16][64][4][16][64][4];\n\t\t\trep(i,h) rep(j,w) rep(k,4) rep(y,h) rep(x,w) rep(d,4) vis[i][j][k][y][x][d]=false;\n\n\t\t\tqueue<state2> Q;\n\t\t\trep(k,4){\n\t\t\t\tint yy=sy+dy[k],xx=sx+dx[k];\n\t\t\t\tif(B[yy][xx]=='.'){\n\t\t\t\t\tgo_straight(yy,xx,k,yy,xx);\n\t\t\t\t\trep(kk,4) if(kk!=k) {\n\t\t\t\t\t\tvis[yy][xx][k][sy][sx][kk]=true;\n\t\t\t\t\t\tQ.push((state2){yy,xx,k,sy,sx,kk});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate2 S=Q.front(); Q.pop();\n\t\t\t\tint i=S.i,j=S.j,k=S.k,y=S.y,x=S.x,d=S.d;\n\n\t\t\t\tif(i==gy && j==gx){\n\t\t\t\t\tint yy,xx;\n\t\t\t\t\tgo_straight(gy,gx,gk,yy,xx);\n\t\t\t\t\tif(y==yy && x==xx && d==gk){ ok=true; break; }\n\t\t\t\t}\n\n\t\t\t\tint i2,j2,k2;\n\t\t\t\tturn_left(i,j,k,i2,j2,k2);\n\t\t\t\trep(t,from_R[y][x][d].size()){\n\t\t\t\t\tint y2=from_R[y][x][d][t].i;\n\t\t\t\t\tint x2=from_R[y][x][d][t].j;\n\t\t\t\t\tint d2=from_R[y][x][d][t].k;\n\t\t\t\t\tif(!vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tturn_right(i,j,k,i2,j2,k2);\n\t\t\t\trep(t,from_L[y][x][d].size()){\n\t\t\t\t\tint y2=from_L[y][x][d][t].i;\n\t\t\t\t\tint x2=from_L[y][x][d][t].j;\n\t\t\t\t\tint d2=from_L[y][x][d][t].k;\n\t\t\t\t\tif(!vis[i2][j2][k2][y2][x2][d2]){\n\t\t\t\t\t\tvis[i2][j2][k2][y2][x2][d2]=true;\n\t\t\t\t\t\tQ.push((state2){i2,j2,k2,y2,x2,d2});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(ok) puts(\"He can accomplish his mission.\");\n\t\telse   puts(\"He cannot return to the kitchen.\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nusing P = pair<int, int>;\nusing PP = pair<P, int>;\nint W, H;\nint sy, sx, sd;\nint gy, gx, gd;\nbool field[16][64];\nbool used[16][64][4][16][64][4];\nbool used2[16][64][4];\nconstexpr int dx[] = {0, 1, 0, -1};\nconstexpr int dy[] = {-1, 0, 1, 0};\n\nvoid init()\n{\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 64; j++) {\n            for (int k = 0; k < 4; k++) {\n                for (int l = 0; l < 16; l++) {\n                    for (int m = 0; m < 64; m++) {\n                        for (int n = 0; n < 4; n++) {\n                            used[i][j][k][l][m][n] = false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nP front(const int y, const int x, const int d)\n{\n    if (d == 0) {\n        int Y = y;\n        for (; field[Y - 1][x]; Y--) {\n        }\n        return {Y, x};\n    } else if (d == 1) {\n        int X = x;\n        for (; field[y][X + 1]; X++) {\n        }\n        return {y, X};\n    } else if (d == 2) {\n        int Y = y;\n        for (; field[Y + 1][x]; Y++) {\n        }\n        return {Y, x};\n    } else {\n        int X = x;\n        for (; field[y][X - 1]; X--) {\n        }\n        return {y, X};\n    }\n}\n\nvector<PP> back(const int y, const int x, const int d)\n{\n    vector<PP> ans;\n    constexpr int R = 1;\n    constexpr int L = 3;\n    if (d == 0) {\n        int Y = y;\n        for (; field[Y][x]; Y--) {\n            if (not field[Y][x + 1]) {\n                ans.push_back({{Y, x}, L});\n            }\n            if (not field[Y][x - 1]) {\n                ans.push_back({{Y, x}, R});\n            }\n        }\n    } else if (d == 1) {\n        int X = x;\n        for (; field[y][X]; X++) {\n            if (not field[y + 1][X]) {\n                ans.push_back({{y, X}, L});\n            }\n            if (not field[y - 1][X]) {\n                ans.push_back({{y, X}, R});\n            }\n        }\n    } else if (d == 2) {\n        int Y = y;\n        for (; field[Y][x]; Y++) {\n            if (not field[Y][x + 1]) {\n                ans.push_back({{Y, x}, R});\n            }\n            if (not field[Y][x - 1]) {\n                ans.push_back({{Y, x}, L});\n            }\n        }\n    } else {\n        int X = x;\n        for (; field[y][X]; X--) {\n            if (not field[y + 1][X]) {\n                ans.push_back({{y, X}, R});\n            }\n            if (not field[y - 1][X]) {\n                ans.push_back({{y, X}, L});\n            }\n        }\n    }\n    return ans;\n}\n\nbool dfs(int fy, int fx, int fd, int by, int bx, int bd)\n{\n    tie(fy, fx) = front(fy, fx, fd);\n    vector<PP> cand = back(by, bx, bd);\n    for (const auto& next : cand) {\n        const int div = next.second;\n        by = next.first.first;\n        bx = next.first.second;\n        const int newfd = (fd + div) % 4;\n        const int newbd = (bd + div) % 4;\n        if (fy == gy and fx == gx and by == gy and bx == gx and bd == gd) {\n            return true;\n        }\n        if (not used[fy][fx][newfd][by][bx][newbd]) {\n            used[fy][fx][newfd][by][bx][newbd] = true;\n            const bool sub = dfs(fy, fx, newfd, by, bx, newbd);\n            if (sub) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool dfs(int fy, int fx, int fd)\n{\n    if (fy == gy and fx == gx) {\n        return true;\n    }\n    tie(fy, fx) = front(fy, fx, fd);\n    for (int i = -1; i <= 1; i += 2) {\n        const int nd = (fd + i + 4) % 4;\n        if (not used2[fy][fx][nd]) {\n            used2[fy][fx][nd] = true;\n            if (dfs(fy, fx, nd)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    int cnt = 0;\n    while (true) {\n        cnt++;\n        cin >> W >> H;\n        if (W == 0 and H == 0) {\n            break;\n        }\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c;\n                cin >> c;\n                field[i][j] = c != '#';\n                if (c == 'K') {\n                    sy = i;\n                    sx = j;\n                } else if (c == 'M') {\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            if (field[sy + dy[i]][sx + dx[i]]) {\n                sd = i;\n                break;\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            if (field[gy + dy[i]][gx + dx[i]]) {\n                gd = i;\n                break;\n            }\n        }\n        gd = (gd + 2) % 4;\n        bool ans = false;\n        for (int d = 0; d < 4; d++) {\n            if (d > 0) {\n                init();\n            }\n            used[sy][sx][sd][sy][sx][d] = true;\n            if (dfs(sy, sx, sd, sy, sx, d)) {\n                ans = true;\n                break;\n            }\n        }\n        if (ans) {\n            cout << \"He can accomplish his mission.\" << endl;\n        } else {\n            for (int i = 0; i < 16; i++) {\n                for (int j = 0; j < 64; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        used2[i][j][k] = false;\n                    }\n                }\n            }\n            used2[sy][sx][sd] = true;\n            if (dfs(sy, sx, sd)) {\n                cout << \"He cannot return to the kitchen.\" << endl;\n            } else {\n                cout << \"He cannot bring tea to his master.\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\t/*\n\tif (!(m[i+dy[(k+2)%4]][j+dx[(k+2)%4]] == '.'||\n\t      m[i+dy[(k+1)%4]][j+dx[(k+1)%4]] == '#'||\n\t      m[i+dy[(k+3)%4]][j+dx[(k+3)%4]] == '#')\n\t    )continue;\n\t*/\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t  /*\n\t  rep(ll,2){\n\t    int nndir = (ndir+d[ll])%4;\n\t    if (m[ney+dy[nndir]][nex+dx[nndir]] == '#')\n\t      rev[ney][nex][nndir][ll].pb((Edge){i  ,  j,(ndir+2)%4});\n\t  }\n\t  */\n\n\t}\n      }\n    }\n  }\n}\n\nvoid output(int r,int c,int ry,int rx,int rd,int rl){\n  const char dd[]={'N','E','S','W'};\n  const char aho[]={'R','L'};\n  cout <<\"Outputbegin\"<<endl;\n  cout << aho[rl] << endl;\n  rep(i,r){\n    rep(j,c){\n      if (ry == i && rx == j)cout << dd[rd];\n      else cout << m[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl<<endl;\n}\n\nbool cango;\n\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gx,int gy,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  \n  if (m[sy][sx] == 'M')cango=true;\n  Edge cpy1,cpy2;\n\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      // cout << ry <<\" \" << rx <<\" \" << rd <<\" \" << rl <<\" \" <<\n      //rev[ry][rx][rd][rl].size() <<endl;\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\tif (m[sy][sx] == 'M' &&\n\t    cpy2.y == gy && cpy2.x == gx && cpy2.d == gd){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  //\t  output(r,c,sy,sx,sd,l);\n\t  //\t  cout << cpy1.y <<\" \" << cpy1.x << endl;\n\t  //\t  cout << \"final state \" << cpy2.y <<\" \" << cpy2.x  << \" \" << cpy2.d << endl;\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  //cout << \"output normal\"<<endl;\n\t  //output(r,c,sy,sx,sd,l);\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n      }\n    }\n  }\n  \n  return false;\n}\n\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n\n    char TEST[]={'N','E','S','W'};\n    char TURN[]={'R','L'};\n    /*\n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout <<\"pos \" <<  i<<\" \" << j <<\" dir \" << TEST[k] <<\" turn to \" <<\n\t\tTURN[l] ;\n\t      cout << \" will go \" << \n\t\trev[i][j][k][l][m].y <<\" \" << rev[i][j][k][l][m].x <<\" dir \" \n\t\t   <<TEST[rev[i][j][k][l][m].d] << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n    */\n\n\n    /*    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout << i <<\" \" << j <<\" \" << TEST[k] <<\" \" \n\t\t   <<TURN[l] << endl; \n\t      output(r,c,rev[i][j][k][l][m].y,rev[i][j][k][l][m].x,\n\t\t     rev[i][j][k][l][m].d,l);\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing vi=vector<bool>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vvvvvi=vector<vvvvi>;\nusing vvvvvvi=vector<vvvvvi>;\n\nstruct State{\n    int hk,wk;\n    int hm,wm;\n    int dirk,dirm;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nint w,h;\nint solve();\nint main(){\n    while(cin>>w>>h,w){\n        solve();\n    }\n}\nint solve(){\n\n    vector<string> f(h);\n    for(int i=0;i<h;i++){\n        cin>>f[i];\n    }        \n    \n    int ini_hk=-1,ini_wk=-1,ini_dirk=-1;\n    int ini_hm=-1,ini_wm=-1,ini_dirm=1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='K'){\n                ini_hk=i;\n                ini_wk=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirk=k;\n                    }\n                }\n            }\n            if(f[i][j]=='M'){\n                ini_hm=i;\n                ini_wm=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirm=k;\n                    }\n                }\n            }\n        }\n    }\n    /*\n    cout<<ini_hk<<\" \"<<ini_wk<<\" \"<<ini_dirk<<endl;\n    cout<<ini_hm<<\" \"<<ini_wm<<\" \"<<ini_dirm<<endl;\n    */\n    vvvvvvi dp(h,vvvvvi(w,vvvvi(h,vvvi(w,vvi(4,(vi(4,false)))))));\n    dp[ini_hk][ini_wk][ini_hm][ini_wm][ini_dirk][ini_dirm]=true;\n    queue<State> que;\n    que.push(State{ini_hk,ini_wk,ini_hm,ini_wm,ini_dirk,ini_dirm});\n    \n    while(!que.empty()){\n        auto st=que.front();\n        que.pop();\n        int hk=st.hk,wk=st.wk,dk=st.dirk;\n        int hm=st.hm,wm=st.wm,dm=st.dirm;\n        /*\n        cout<<hk<<\" \"<<wk<<\" \"<<dk<<endl;\n        cout<<hm<<\" \"<<wm<<\" \"<<dm<<endl;\n        */\n        int tohk=hk+dh[dk],towk=wk+dw[dk];\n        //cout<<tohk<<\" \"<<towk<<endl;\n        int tohm=hm+dh[dm],towm=wm+dw[dm];\n        //cout<<tohm<<\" \"<<towm<<endl;\n        char tokf=f[tohk][towk];\n        char tomf=f[tohm][towm];\n        if(tokf=='#' && tomf=='#'){\n            int todk=(dk+1)%4;\n            int todm=(dm+3)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n            todk=(dk+3)%4;\n            todm=(dm+1)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n        }\n        else if(tokf=='#'){\n            if(!dp[hk][wk][tohm][towm][dk][dm]){\n                dp[hk][wk][tohm][towm][dk][dm]=true;\n                que.push(State{hk,wk,tohm,towm,dk,dm});\n            }\n        }\n        else if(tomf=='#'){\n            if(!dp[tohk][towk][hm][wm][dk][dm]){\n                dp[tohk][towk][hm][wm][dk][dm]=true;\n                que.push(State{tohk,towk,hm,wm,dk,dm});\n            }\n        }\n        else{\n            \n            if(!dp[tohk][towk][tohm][towm][dk][dm]){\n                dp[tohk][towk][tohm][towm][dk][dm]=true;\n                que.push(State{tohk,towk,tohm,towm,dk,dm});\n            }\n        }\n        \n    }\n    bool two_way=false;\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(i!=ini_dirk && j!=ini_dirm){\n                two_way|=dp[ini_hm][ini_wm][ini_hk][ini_wk][i][j];\n            }\n        }\n    }\n\n    bool one_way=false;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int ki=0;ki<4;ki++){\n                for(int kj=0;kj<4;kj++){\n                    if(ki!=ini_dirk && kj!=ini_dirm){\n                        one_way|=dp[ini_hm][ini_wm][i][j][ki][kj];\n                    }\n                }\n            }\n        }\n    }\n    if(two_way){\n        cout<<\"He can accomplish his mission.\"<<endl;\n    }\n    else if(one_way){   \n        cout<<\"He cannot return to the kitchen.\"<<endl;\n    }\n    else{        \n        cout<<\"He cannot bring tea to his master.\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H;\nstring home_map[16];\n\npii nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pii(cx, cy);\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_M, wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k].clear();\n\twall_dir_at_M.clear();\n\twall_dir_at_K.clear();\n\t\n\tmap< pii, int > pos_id;\n\tint id = 1;\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[pii(x, y)] = 0;\n\t\tif (home_map[y][x] == 'M') pos_id[pii(x, y)] = 1023;\n\t\tif (home_map[y][x] == '.') pos_id[pii(x, y)] = id++;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\tfor_(d,0,4) {\n\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\tif (home_map[y][x] == 'M') wall_dir_at_M.push_back(d);\n\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\tgoal_id = pos_id[nextPos(nx, ny, d)];\n\t\t\t\t\tgoal_dir = d;\n\t\t\t\t} else {\n\t\t\t\t\tstart_id = pos_id[nextPos(nx, ny, d)];\n\t\t\t\t\tstart_dir = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[pii(x, y)];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = pos_id[nextPos(x, y, nxt_dir)];\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nstruct State {\n\tint id, dir;\n\tint rev_id, rev_dir;\n};\n\nbool vis[1024][4][1024][4];\n\nbool canReachMaster() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tque.push(State{start_id, start_dir});\n\tvis[start_id][start_dir][0][0] = true;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c);\n\t\t\tif (!vis[nxt_id][nxt_dir][0][0]) {\n\t\t\t\tvis[nxt_id][nxt_dir][0][0] = true;\n\t\t\t\tque.push(State{nxt_id, nxt_dir});\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = false;\n\tfor (int f : wall_dir_at_M) flag |= vis[1023][f][0][0];\n\treturn flag;\n}\n\nvoid bfs() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(State{start_id, start_dir, 0, d});\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c), nxt_rev_dir = changeDirection(s.rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[s.rev_id][s.rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(State{nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tconstructTransition();\n\tcanReachMaster();\n\tbfs();\n\t\n\tbool ans = false;\n\tfor (int f : wall_dir_at_M) ans |= vis[1023][f][goal_id][goal_dir];\n\t\n\tif (ans) {\n\t\tputs(\"He can accomplish his mission.\");\n\t} else {\n\t\tif (canReachMaster()) puts(\"He cannot return to the kitchen.\");\n\t\telse puts(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_M, wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_M = wall_dir_at_K = vector< int >();\n\t\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\tif (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\tif (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\tfor_(d,0,4) {\n\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\tif (home_map[y][x] == 'M') wall_dir_at_M.push_back(d);\n\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\tgoal_dir = d;\n\t\t\t\t} else {\n\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\tstart_dir = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nstruct State {\n\tint id, dir;\n\tint rev_id, rev_dir;\n};\n\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< pii > que;\n\tque.push(pii(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tif (p.first == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[p.first][p.second][c], nxt_dir = changeDirection(p.second, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(pii(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< State > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(State{start_id, start_dir, 0, d});\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.front(); que.pop();\n\t\tif (s.id == 1023 && s.rev_id == goal_id && s.rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[s.id][s.dir][c], nxt_dir = changeDirection(s.dir, c), nxt_rev_dir = changeDirection(s.rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[s.rev_id][s.rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(State{nxt_id, nxt_dir, nxt_rev_id, nxt_rev_dir});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pag;\ntypedef pair<pag,pag> sit;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n// »ÝÌÊu©çßéÆ«ÉAæè¤éOÌêðñ\nvector<pag> backTable[2][4][16][64];\n// »ÝÌÊu©çiÞÆ«ÉAæè¤éÌê\npag goTable[2][4][16][64];\n// ·ÅÉÊßµ½ê\nbool vis[4][16][64][4][16][64];\n// ¡ÌóÔ©çS[Ößêé©\nbool isGoal[4][16][64];\n\nint H,W;\nchar field[101][101];\nint sx,sy;\nint sag;\nint gx,gy;\nint gag;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nvoid calcGoAndBackTable(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<4;k++){\n                // ¶©EÉûü]·µÄAOiµ½ ÆÌêðßé\n                // ¶\n                {\n                    int nag=(k-1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[0][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // E\n                {\n                    int nag=(k+1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[1][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // »ÝÌü«Ì½ÎÖßÁ½ãûü]··é\n                int backAg=(k+2)%4;\n                int ny=i;\n                int nx=j;\n                while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                    // ±±Å¶ÉûüðÏ¦éêÆEÉûüðÏ¦éêÅêí¯\n                    // ¶\n                    {\n                        int nag=(k-1+4)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[0][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    // E\n                    {\n                        int nag=(k+1)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[1][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    ny+=dy[backAg];\n                    nx+=dx[backAg];\n                }\n            }\n        }\n    }\n}\n// X^[gn_©çÔÉvZµÄ¢­\nint bfs(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return 2;\n    for(int cnt=0;cnt<4;cnt++){\n    memset(vis,0,sizeof(vis));\n    priority_queue<sit> pq;\n    // X^[gn_ðpush\n    pq.push(sit(pag(pii(psy,psx),pang),pag(pii(sy,sx),(cnt))));\n    vis[pang][psy][psx][sag][sy][sx]=true;\n    while(pq.size()){\n        sit cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.first.second;\n        int gpy=cur.first.first.first;\n        int gang=cur.first.second;\n        int bpx=cur.second.first.second;\n        int bpy=cur.second.first.first;\n        int bang=cur.second.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            res=max(res,1);\n            if(isGoal[bang][bpy][bpx]){\n                res=max(res,2);\n            }\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            // ßéÓ¾¯vZ\n            for(int j=0;j<backTable[i][bang][bpy][bpx].size();j++){\n                pag nbpag=backTable[i][bang][bpy][bpx][j];\n                // ngpagÆnbpagÌîñ©çÉ¢¯éê\n                if(vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second])\n                    continue;\n                vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second]=true;\n                pq.push(sit(ngpag,nbpag));\n            }\n        }\n    }\n    }\n    // 3ÂÌÇÌóÔÉÈé©`FbN\n    return res;\n}\n\nbool used[4][101][101];\nbool bfs2(int psy,int psx,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return true;\n    memset(used,0,sizeof(used));\n    priority_queue<pag> pq;\n    // X^[gn_ðpush\n    pq.push(pag(pii(psy,psx),pang));\n    used[pang][psy][psx]=true;\n    while(pq.size()){\n        pag cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.second;\n        int gpy=cur.first.first;\n        int gang=cur.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            return true;\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            if(used[ngpag.second][ngpag.first.first][ngpag.first.second])\n                continue;\n            used[ngpag.second][ngpag.first.first][ngpag.first.second]=true;\n            pq.push(ngpag);\n        }\n    }\n    return false;\n}\n\nvoid input(){\n    // startÆgoalÌÊuðè\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>field[i][j];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='K'){\n                field[i][j]='.';\n                sy=i;sx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')sag=k;\n                }\n            }\n            else if(field[i][j]=='M'){\n                field[i][j]='.';\n                gy=i;gx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')gag=k;\n                }\n            }\n        }\n    }\n}\nvoid init(){\n    memset(isGoal,0,sizeof(isGoal));\n    for(int i=0;i<2;i++)for(int j=0;j<4;j++)\n        for(int k=0;k<16;k++)for(int l=0;l<64;l++)\n            backTable[i][j][k][l].clear();\n}\nint main(){\n    while(cin>>W>>H&&(W|H)){\n        // ú»\n        init();\n        input();\n        calcGoAndBackTable();\n        // S[ÖßêéêðvZ\n        {\n            int cy=gy;\n            int cx=gx;\n            int cag=gag;\n            while(field[cy][cx]!='#'){\n                isGoal[cag][cy][cx]=true;\n                cy+=dy[gag];\n                cx+=dx[gag];\n            }\n        }\n        // startn_©ç··ßÄ¨­\n        int psy=sy;\n        int psx=sx;\n        int pang=sag;\n        while(psy>=0&&psx>=0&&psy<H&&psx<W&&field[psy][psx]!='#'){\n            psy+=dy[sag];\n            psx+=dx[sag];\n        }\n        // ß·\n        psy-=dy[sag];\n        psx-=dx[sag];\n        int res=bfs(psx,psy,pang);\n        res=max(res,(int)bfs2(psx,psy,pang));\n        if(res==0)\n            cout<<\"He cannot bring tea to his master.\"<<endl;\n        else if(res==1)\n            cout<<\"He cannot return to the kitchen.\"<<endl;\n        else if(res==2)\n            cout<<\"He can accomplish his mission.\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\tcout << x << \" \" << y << endl;\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tcout << \"i:\" << i << endl;\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf_s(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tcout << sy << \" \" << sx << endl;\n\t\tcout << gy << \" \" << gx << endl;\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include<deque>\n#include<climits>\n#include<cassert>\n#define F first\n#define S second\n#define T 0\n#define R 1\n#define B 2\n#define L 3\n#define all(n) n.begin(),n.end()\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef deque<int> DI;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<VVB> VVVB;\nP K,M;\nint W,H;\nint dx[] = {0,1,0,-1};//T R B L\nint dy[] = {-1,0,1,0};\nint add[] = {1,3};\nbool M_ok,K_ok;\nmap<VI,bool> Mcheki;\n\nvoid Input(VVC& G,VVVB& mincost)\n{\n  G.resize(H);\n  mincost.resize(4);\n  rep(i,4)\n    mincost[i].resize(H);\n  for(int i=0;i<H;i++)\n    {\n      G[i].resize(W);\n      rep(j,4)\n\tmincost[j][i].resize(W);\n      string line;\n      cin >> line;\n      for(int j=0;j<W;j++)\n\t{\n\t  rep(k,4)\n\t    mincost[k][i][j] = false;\n\t  G[i][j] = line[j];\n\t  if(line[j] == 'K')\n\t    K = P(j,i);\n\t  else if(line[j] == 'M')\n\t    M = P(j,i);\n\t}\n    }\n}\n\nbool check(VVC& G,DI info,int x,int y)\n{\n  int dir = -1;\n  rep(i,4)\n    {\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(G[ny][nx] == '.')\n\t{\n\t  dir = i;\n\t  break;\n\t}\n    }\n\n  for(int i = info.size()-1;i>=0;i--)\n    {\n      while(G[y+dy[dir]][x+dx[dir]] != '#')\n\t{\n\t  x += dx[dir];\n\t  y += dy[dir];\n\t}\n\n      dir = (info[i]==L?(dir+1)%4:(dir+3)%4);\n       \n    }\n\n  while(G[y+dy[dir]][x+dx[dir]] != '#')\n    {\n      x += dx[dir];\n      y += dy[dir];\n    }\n  \n  return G[y][x] == 'K';\n\n}\n\n\nvoid dfs(VVC& G,VVVB mincost,DI info,int x,int y,int dir)\n{\n  if(K_ok)\n    return;\n  if(mincost[dir][y][x])\n    return;\n\n  mincost[dir][y][x] = true;  \n \n  while(G[y+dy[dir]][x+dx[dir]] != '#')\n    {\n      x += dx[dir];\n      y += dy[dir];\n    }\n\n   \n  if(G[y][x] == 'M')\n    { \n      \n      M_ok = true;\n      if(check(G,info,x,y))\n\t{\t  \n\t  K_ok = true;\t\n\t  return;\n\t}\n    }\n\n  \n  rep(i,2)\n    {\n      if(i == 0)\n\tinfo.push_back(R);\n      else if(i == 1)\n\tinfo.push_back(L);\n      dfs(G,mincost,info,x,y,(dir+add[i])%4);\n      info.pop_back();\n    }\n\n}\n\nint main()\n{\n \n  while(cin >> W >> H,W|H)\n    {\n      VVC G;\n      VVVB mincost;\n      Input(G,mincost);\n      M_ok = K_ok = false;\n      Mcheki.clear();\n      DI info;\n      int dir = -1;\n      rep(i,4)\n\t{\n\t  if(G[K.S+dy[i]][K.F+dx[i]] == '.')\n\t    dir = i;\n\t\n\t} \n    \n      dfs(G,mincost,info,K.F,K.S,dir);\n\n      if(!M_ok)\n\tcout << \"He cannot bring tea to his master.\" << endl;\n      else if(K_ok)\n\tcout << \"He can accomplish his mission.\" << endl;\n      else \n\tcout << \"He cannot return to the kitchen.\" << endl;\n\n      if(K_ok && !M_ok)\n\tassert(false);    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef vector<int> pos;\ntypedef pair<int,int> P;\n\nint w,h;\nstring g[16];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nbool vis[16][64][4][16][64][4];\n\nint main(){\n  int cnt=0;\n  while(cin >> w >> h,w){\n    cnt++;\n    rep(i,h)cin >> g[i];\n    //if(cnt!=11)continue;\n    memset(vis,0,sizeof(vis));\n\n    int sy,sx,sd, gy,gx,gd;\n    rep(i,h){\n      rep(j,w){\n\tif(g[i][j] == 'K'){\n\t  rep(k,4){\n\t    int ny = i+dy[k], nx = j+dx[k];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(g[ny][nx] == '.'){\n\t      sy = i; sx = j; sd = k;\n\t    }\n\t  }\n\t}\n\tif(g[i][j] == 'M'){\n\t  rep(k,4){\n\t    int ny = i+dy[k], nx = j+dx[k];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(g[ny][nx] == '.'){\n\t      gy = i; gx = j; gd = k;\n\t    }\n\t  }\n\t}\n      }\n    }\n    set<P> check;\n\n    stack<pos> s;\n    pos p(6);\n    p[0] = sy; p[1] = sx; p[2] = sd;\n    p[3] = sy; p[4] = sx;\n\n    rep(i,4){\n      vis[sy][sx][sd][sy][sx][i] = true;\n      p[5] = i;\n      s.push(p);\n    }\n\n    while(s.size()){\n      p = s.top(); s.pop();\n      \n      check.insert(make_pair(p[0],p[1]));\n      //rep(i,6)cout << p[i] << \" \";cout << endl;\n\n      int d1 = p[2], y1 = p[0]+dy[d1], x1 = p[1]+dx[d1];\n      while(g[y1][x1]!='#'){\n\ty1+=dy[d1]; x1+=dx[d1];\n      }\n      y1-=dy[d1]; x1-=dx[d1];\n\n      int d2 = p[5], y2 = p[3], x2 = p[4];\n      while(g[y2][x2]!='#'){\n\tint rd = (p[5]+1)%4, ry = y2+dy[rd], rx = x2+dx[rd];\n\tint ld = (p[5]+3)%4, ly = y2+dy[ld], lx = x2+dx[ld];\n\n\tif(g[ry][rx]=='#' || g[ly][lx]=='#'){\n\t  if(!vis[y1][x1][d1][y2][x2][d2]){\n\t    vis[y1][x1][d1][y2][x2][d2] = true;\n\t    if(g[ry][rx]=='#'){\n\t      pos tmp(6);\n\t      tmp[0] = y1; tmp[1] = x1; tmp[2] = (d1+1)%4;\n\t      tmp[3] = y2; tmp[4] = x2; tmp[5] = rd;\n\t      s.push(tmp);\n\t    }\n\n\t    if(g[ly][lx]=='#'){\n\t      pos tmp(6);\n\t      tmp[0] = y1; tmp[1] = x1; tmp[2] = (d1+3)%4;\n\t      tmp[3] = y2; tmp[4] = x2; tmp[5] = ld;\n\t      s.push(tmp);\n\t    }\n\t  }\n\t}\n\ty2-=dy[d2]; x2-=dx[d2];\n      }\n    }\n    bool f1=false;\n    rep(i,4){\n      if(vis[gy][gx][i][gy][gx][gd])f1 = true;\n    }\n\n    if(f1)cout << \"He can accomplish his mission.\" << endl;\n    else{\n      memset(vis,0,sizeof(vis));\n      p.resize(3);\n      p[0] = sy; p[1] = sx; p[2] = sd;\n      s.push(p);\n\n      while(s.size()){\n\tp = s.top(); s.pop();\n\t\n\tint ny = p[0]+dy[p[2]], nx = p[1]+dx[p[2]];\n\twhile(g[ny][nx]!='#'){\n\t  ny += dy[p[2]]; nx += dx[p[2]];\n\t}\n\tny -= dy[p[2]]; nx -= dx[p[2]];\n\t\n\tif(vis[ny][nx][p[2]][0][0][0])continue;\n\tvis[ny][nx][p[2]][0][0][0] = true;\n\trep(d,2){\n\t  int nd = (p[2] + 2*d+1)%4;\n\t  pos tmp(3);\n\t  tmp[0] = ny; tmp[1] = nx; tmp[2] = nd;\n\t  s.push(tmp);\n\t}\n      }\t  \n      \n      bool f2=false;\n      rep(i,4){\n\tif(vis[gy][gx][i][0][0][0])f2 = true;\n      }\n      if(f2)cout << \"He cannot return to the kitchen.\" << endl;\n      else cout << \"He cannot bring tea to his master.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int H = 17;\nconst int W = 65;\n\nint h,w;\nvector<string> mp;\n\nint used[W][H][4][W][H][4];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar getChar(int x,int y,int dir){return mp[y + dy[dir]][x + dx[dir]];}\nvoid getNx(int &x,int &y,int dir){while(getChar(x, y, dir) != '#') x += dx[dir],y += dy[dir];}\nint getDir(int x,int y){for(int i=0;i<4;i++) if(getChar(x, y, i) != '#') return i;}\n\nint bfs(int sx,int sy,int gx,int gy,int flag = 0){\n  memset(used,0,sizeof(used));\n  int sdir = getDir(sx, sy);\n  int gdir = getDir(gx, gy);\n  \n  struct dat{\n    int x, y, dir1, a, b, dir2;\n    dat();\n    dat(int x,int y,int dir1,int a,int b,int dir2):\n      x(x), y(y), dir1(dir1), a(a), b(b), dir2(dir2){}\n  };\n  \n  queue<dat> Q;\n  \n  auto Push=[&](int nx,int ny,int ndir1,int a,int b,int ndir2){\n    \n    if(flag) {\n      if(used[nx][ny][ndir1][0][0][0]++ == 0) Q.push(dat(nx,ny,ndir1, 0,0,0));\n      return;\n    }\n\n    if(getChar(a, b, ndir2) != '#') return;\n    int na = a, nb = b;\n    while(mp[nb][na] != '#'){\n      int flag = getChar(na,nb,(ndir2+1)%4) == '#' || getChar(na, nb, (ndir2+3)%4) == '#';\n      if(flag && used[nx][ny][ndir1][na][nb][ndir2]++ == 0) Q.push(dat(nx,ny,ndir1, na,nb,ndir2));\n      na += dx[(ndir2+2)%4];\n      nb += dy[(ndir2+2)%4];\n    }\n  };\n  \n  for(int i=0;i<4;i++){\n    int nx = sx, ny = sy; getNx(nx, ny, sdir);\n    if(getChar(sx, sy, i) == '#') Push(nx,ny,sdir,sx,sy,i);\n  }\n\n  int res = 0;\n  while(!Q.empty()){\n    auto t = Q.front(); Q.pop();\n    int x = t.x, y = t.y, dir1 = t.dir1;\n    int a = t.a, b = t.b, dir2 = t.dir2;\n    if(x == gx && y == gy) res = 1;\n    if(x == gx && y == gy && a == gx && b == gy && dir2 == gdir) return 2;\n    \n    \n    {//右に曲がる\n      int nx = x, ny = y, ndir1 = (dir1 + 1) % 4; getNx(nx, ny, ndir1);\n      int ndir2 = (dir2 + 1) % 4;\n      Push(nx, ny, ndir1, a, b, ndir2);\n    }\n\n    {//左に曲がる。\n      int nx = x, ny = y, ndir1 = (dir1 + 3) % 4; getNx(nx, ny, ndir1);\n      int ndir2 = (dir2 + 3) % 4;\n      Push(nx, ny, ndir1, a, b, ndir2);\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>w>>h;\n    if(h == 0 && w == 0) return 0;\n    \n    mp.clear();\n    mp.resize(h);\n    cin>>mp;\n  \n    int sx,sy,gx,gy;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n        if(mp[i][j] == 'K') sx = j, sy = i;\n        if(mp[i][j] == 'M') gx = j, gy = i;\n      }\n\n    int ans = bfs(gx, gy, sx, sy);\n    if(ans != 2) ans = bfs(sx, sy, gx, gy, 1);\n    if(ans == 0) cout<<\"He cannot bring tea to his master.\"<<endl;\n    else if(ans == 1) cout<<\"He cannot return to the kitchen.\"<<endl;\n    else cout<<\"He can accomplish his mission.\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <unordered_set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    int x, y, d;\n    S() {}\n    S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const pair<S, S>& p) {\n    return (sig(p.first) << 16) | sig(p.second);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\nint sx, sy, sd, tx, ty, td;\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { \\\n    const int si = sig(s); \\\n    if (!vis.count(si)) vis.insert(si), q.push(s); \\\n}\n\nbool reach() {\n    unordered_set<int> vis;\n    queue<S> q;\n    const S st = forward(sx, sy, sd);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == tx && cur.y == ty) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, unordered_set<int>& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish() {\n    unordered_set<int> vis;\n    queue<pair<S, S> > q;\n    const S st = forward(sx, sy, sd);\n    rep (d, 4) push(q, vis, st, sx, sy, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == tx && cur.y == ty\n                && rev.x == tx && rev.y == ty && rev.d == td) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        sx = i, sy = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') sd = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        tx = i, ty = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') td = d;\n    }\n    if (!reach()) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish()) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n//\n//\n//int move(string st, int& now, int way) {\n//\tif (now!=st.size()&&mp[st[now]] == way) {\n//\t\tnow++;\n//\t\treturn now;\n//\t}\n//\telse if (now != 0&& mp[st[now-1]] == (way + 2) % 4) {\n//\t\tnow--;\n//\t\treturn now;\n//\t}\n//\treturn now;\n//}\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nlong long int hash_[1000011], pmo_[1000011];\nlong long int hash2_[1000011], pmo2_[1000011];\n\nlong long int rhash_[1000011], rpmo_[1000011];\nlong long int rhash2_[1000011], rpmo2_[1000011];\n\nstruct RollingHash {\n\tstatic const long long int mul0 = 10009, mul1 = 10007;\n\tstatic const long long int add0 = 1000010007, add1 = 1003333331;\n\tstring s; int l;\n\tvoid init(string s) {\n\t\tthis->s = s; l = s.size();\n\t\thash_[0] = 0; pmo_[0] = 1;\n\t\thash2_[0] = 0; pmo2_[0] = 1;\n\t\tfor (int i = 0; i < l; ++i) {\n\t\t\tpmo_[i + 1] = pmo_[i] * mul0;\n\t\t\tpmo2_[i + 1] = pmo2_[i] * mul1;\n\t\t}\n\t\tfor (int i = 0; i < l; ++i) {\n\t\t\thash_[i + 1] = (hash_[i] * mul0 + s[i]);\n\t\t\thash2_[i + 1] = (hash2_[i] * mul1 + s[i]);\n\t\t}\n\t}\n\tpair<long long int, long long int >  hash(int l, int r) { // s[l..r]\n\t\treturn make_pair(hash_[r + 1] - hash_[l] * pmo_[r + 1 - l],\n\t\t\thash2_[r + 1] - hash2_[l] * pmo2_[r + 1 - l]);\n\n\t}\n};\nstruct RollingHash2 {\n\tstatic const long long int mul0 = 10009, mul1 = 10007;\n\tstatic const long long int add0 = 1000010007, add1 = 1003333331;\n\tstring s; int l;\n\tvoid init(string s) {\n\t\tthis->s = s; l = s.size();\n\t\trhash_[0] = 0; rpmo_[0] = 1;\n\t\trhash2_[0] = 0; rpmo2_[0] = 1;\n\t\tfor (int i = 0; i < l; ++i) {\n\t\t\trpmo_[i + 1] = rpmo_[i] * mul0;\n\t\t\trpmo2_[i + 1] = rpmo2_[i] * mul1;\n\t\t}\n\t\tfor (int i = 0; i < l; ++i) {\n\t\t\trhash_[i + 1] = (rhash_[i] * mul0 + s[i]);\n\t\t\trhash2_[i + 1] = (rhash2_[i] * mul1 + s[i]);\n\t\t}\n\t}\n\tpair<long long int, long long int >  hash(int l, int r) { // s[l..r]\n\t\treturn make_pair(rhash_[r + 1] - rhash_[l] * rpmo_[r + 1 - l],\n\t\t\trhash2_[r + 1] - rhash2_[l] * rpmo2_[r + 1 - l]);\n\n\t}\n};\n\nvector<pair<int, int>> ps;\nvoid wr(int a, int b) {\n\t//cout << a+1 << \" \" << b+1 << endl;\n\tps.push_back({ a + 1,b + 1 });\n}\n//5 15~\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nint memo[16][64][16][64][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint tx;\n\tint ty;\n\tint way;\n};\n\nvector<aa>stack;\n\nbool cangogoal;\n\nbool check(int fx, int fy, int tx, int ty, int way) {\n\tmemo[fx][fy][tx][ty][way]=1;\n\tif (tx == gx&&ty == gy) {\n\t\tcangogoal = true;\n\t}else if (fx == gx&&fy == gy&&tx == gx&&ty == gy) {\n\t\treturn true;\n\t}\n\telse{\n\n\t\tint nfy = fy + dy[way];\n\t\tint nfx = fx + dx[way];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (dp[nfy][nfx]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[way];\n\t\t\tnfx = nfx + dx[way];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (dp[nty + dy[tw + 1]][ntx + dx[tw + 1]]) {\n\t\t\t\tint away = (tw + 3) % 4;\n\t\t\t\tstack.push_back(aa{ nfx,nfy,ntx,nty,away });\n\t\t\t}\n\n\t\t\tif (dp[nty + dy[tw + 3]][ntx + dx[tw + 3]]) {\n\t\t\t\tint away = (tw + 1) % 4;\n\t\t\t\tstack.push_back(aa{ nfx,nfy,ntx,nty,away });\n\t\t\t}\n\n\t\t\tif (dp[nty][ntx]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnty = nty + dy[way];\n\t\t\tntx = ntx + dx[way];\n\t\t}\n\t\tif (dp[nty + dy[tw + 1]][ntx + dx[tw + 1]]) {\n\t\t\tint away = (tw + 3) % 4;\n\t\t\tif (!memo[nfx][nfy][ntx][nty][away])\n\t\t\t\tstack.push_back(aa{ nfx,nfy,ntx,nty,away });\n\t\t}\n\n\t\tif (dp[nty + dy[tw + 3]][ntx + dx[tw + 3]]) {\n\t\t\tint away = (tw + 1) % 4;\n\n\t\t\tif (!memo[nfx][nfy][ntx][nty][away])\n\t\t\t\tstack.push_back(aa{ nfx,nfy,ntx,nty,away });\n\t\t}\n\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (1) {\n\t\tcangogoal = false;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tint W, H; cin >> W >> H;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\n\t\tmp.resize(H,vector<bool>(false));\n\n\t\tint sx, sy, gx, gy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstack.push_back(aa{ sx,sy,sway,sx,sy,sway });\n\t\tbool isok = false;\n\t\twhile (!stack.empty()) {\n\t\t\taa atop(stack.back());\n\t\t\tstack.pop_back();\n\t\t\tif (check(atop)) {\n\t\t\t\tisok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isok) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (cangogoal) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\ninline int changeDirection(int& f, int& c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_K;\n\nvoid constructTransition() {\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_K = vector< int >();\n\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\telse if (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\telse if (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tint cnt = 0;\n\tfor_(y,0,H) {\n\t\tfor_(x,0,W) {\n\t\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\t\tfor_(d,0,4) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tgoal_dir = d;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tstart_dir = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt == 2) break;\n\t\t}\n\t\tif (cnt == 2) break;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nconst int SHIFT = 16;\nconst int MASK = (1 << 16) - 1;\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\ninline int makeState(int& id, int& dir) { return (id | (dir << SHIFT)); }\ninline int getID(int& state) { return (state & MASK); }\ninline int getDIR(int& state) { return (state >> SHIFT); }\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< int > que;\n\tque.push(makeState(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tint s = que.front(); que.pop();\n\t\tint id = getID(s), dir = getDIR(s);\n\t\tif (id == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(makeState(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< pii > que; int zero = 0;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(pii(makeState(start_id, start_dir), makeState(zero, d)));\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint id = getID(p.first), dir = getDIR(p.first);\n\t\tint rev_id = getID(p.second), rev_dir = getDIR(p.second);\n\t\tif (id == 1023 && rev_id == goal_id && rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c), nxt_rev_dir = changeDirection(rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[rev_id][rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(pii(makeState(nxt_id, nxt_dir), makeState(nxt_rev_id, nxt_rev_dir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nstruct node{\n    int y1,x1,y2,x2,dir1,dir2;\n\tnode(int y1,int x1,int dir1,int y2,int x2,int dir2):y1(y1),x1(x1),dir1(dir1),y2(y2),x2(x2),dir2(dir2){}\n};\n\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\ntypedef vector<vvvvi> vvvvvi;\ntypedef vector<vvvvvi> vvvvvvi;\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n    int h,w;\n    while(cin>>w>>h,w|h){\n        vs f(h);\n        pii kichen,master;\n        int k_dir,m_dir;\n        REP(i,h){\n            cin>>f[i];\n\t\t}\n        REP(i,h){\n            REP(j,w){\n                if(f[i][j]=='K'){\n                    kichen=make_pair(i,j);\n                    REP(d,4){\n                        int yy=i+dy[d];\n                        int xx=j+dx[d];\n                        if(f[yy][xx]=='.'){\n                            k_dir=d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n                if(f[i][j]=='M'){\n                    master=make_pair(i,j);\n                    REP(d,4){\n                        int yy=i+dy[d];\n                        int xx=j+dx[d];\n                        if(f[yy][xx]=='.'){\n                            m_dir=d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<node> q;\n        vvvvvvi visited(h,vvvvvi(w,vvvvi(4,vvvi(h,vvi(w,vi(5))))));\n\t\tint sy,sx;\n        for(int i=1;;i++){\n\t\t\tint cy=kichen.first+dy[k_dir]*(i-1);\n\t\t\tint cx=kichen.second+dx[k_dir]*(i-1);\n\t\t\tint ny=kichen.first+dy[k_dir]*i;\n\t\t\tint nx=kichen.second+dx[k_dir]*i;\n            if(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n                sy=cy;\n                sx=cx;\n                break;\n\t\t\t}\n\t\t}\n\t\tFOR(i,1,3+1){\n\t\t\tq.push(node(sy,sx,k_dir,kichen.first,kichen.second,(k_dir+i)%4));\n\t\t\tvisited[sy][sx][k_dir][kichen.first][kichen.second][(k_dir+i)%4]=1;\n\t\t}\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n\t\t\tfor (int d = 1; d <= 3; d+=2)\n\t\t\t{\n\t\t\t\tvector<pii> points;\n\t\t\t\tint dir1=(cnode.dir1+d)%4;\n\t\t\t\tint sy1,sx1;\n\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\tint cy=cnode.y1+dy[dir1]*(i-1);\n\t\t\t\t\tint cx=cnode.x1+dx[dir1]*(i-1);\n\t\t\t\t\tint ny=cnode.y1+dy[dir1]*i;\n\t\t\t\t\tint nx=cnode.x1+dx[dir1]*i;\n\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n\t\t\t\t\t\tsy1=cy;\n\t\t\t\t\t\tsx1=cx;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cnode.dir2!=4){\n\t\t\t\t\tint dir2=(cnode.dir2+d)%4;\n\t\t\t\t\tfor(int i=1;;i++){\n\t\t\t\t\t\tint cy=cnode.y2+dy[(cnode.dir2+2)%4]*(i-1);\n\t\t\t\t\t\tint cx=cnode.x2+dx[(cnode.dir2+2)%4]*(i-1);\n\t\t\t\t\t\tint ny=cnode.y2+dy[(cnode.dir2+2)%4]*i;\n\t\t\t\t\t\tint nx=cnode.x2+dx[(cnode.dir2+2)%4]*i;\n\t\t\t\t\t\tint sidey=cy+dy[dir2%4];\n\t\t\t\t\t\tint sidex=cx+dx[dir2%4];\n\t\t\t\t\t\tif(sidey>=0&&sidex>=0&&sidey<h&&sidex<w&&f[sidey][sidex]=='#'){\n\t\t\t\t\t\t\tpoints.push_back(make_pair(cy,cx));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tREP(j,points.size()){\n\t\t\t\t\t\tif(!visited[sy1][sx1][dir1][points[j].first][points[j].second][dir2]){\n\t\t\t\t\t\t\tvisited[sy1][sx1][dir1][points[j].first][points[j].second][dir2]=1;\n\t\t\t\t\t\t\tq.push(node(sy1,sx1,dir1,points[j].first,points[j].second,dir2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!visited[sy1][sx1][dir1][0][0][4]){\n\t\t\t\t\tvisited[sy1][sx1][dir1][0][0][4]=1;\n\t\t\t\t\tq.push(node(sy1,sx1,dir1,0,0,4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ac=false;\n        for(int i=1;;i++){\n\t\t\tint cy=master.first+dy[m_dir]*(i-1);\n\t\t\tint cx=master.second+dx[m_dir]*(i-1);\n\t\t\tint ny=master.first+dy[m_dir]*i;\n\t\t\tint nx=master.second+dx[m_dir]*i;\n            if(ny>=0&&nx>=0&&ny<h&&nx<w&&f[ny][nx]=='#'){\n                sy=cy;\n                sx=cx;\n                break;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 3; i++)\n\t\t{\n\t\t\tif(visited[master.first][master.second][(m_dir+i)%4][sy][sx][m_dir]){\n\t\t\t\tac=true;\n\t\t\t}\n\t\t}\n\t\tif(ac){\n            cout<<\"He can accomplish his mission.\"<<endl;\n            goto end;\n\t\t}else{\n            bool flag=false;\n            REP(i,h)REP(j,w)REP(d,5)FOR(d1,1,4){\n\t\t\t\tif(visited[master.first][master.second][(m_dir+d1)%4][i][j][d]){\n                    flag=true;\n                    break;\n\t\t\t\t}\n\t\t\t}\n            if(flag){\n                cout<<\"He cannot return to the kitchen.\"<<endl;\n\t\t\t}else{\n                cout<<\"He cannot bring tea to his master.\"<<endl;\n\t\t\t}\n\t\t}\nend:\n        ;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\nchar m[R][C];\n\nclass Edge{\npublic:\n  int y,x,d;\n};\n\n#define RIGHT 0\n#define LEFT 1\n//N E S W\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\nint d[] ={1,3};\n\n\nvector<Edge> edge[R][C][DIR][2];//0 right 1 left\nvector<Edge>  rev[R][C][DIR][2];\n\nvoid make_edge(int r,int c){\n  REP(i,1,r-1){\n    REP(j,1,c-1){\n      if (m[i][j] == '#')continue;\n      rep(k,4){\n\tif (m[i+dy[k]][j+dx[k]] != '#')continue;//no wall\t\n\t/*\n\tif (!(m[i+dy[(k+2)%4]][j+dx[(k+2)%4]] == '.'||\n\t      m[i+dy[(k+1)%4]][j+dx[(k+1)%4]] == '#'||\n\t      m[i+dy[(k+3)%4]][j+dx[(k+3)%4]] == '#')\n\t    )continue;\n\t*/\t\t\n\trep(l,2){\n\t  int nex=j,ney=i;\n\t  int ndir=(k+d[l])%4;\n\t  while(true){\n\t    if (m[ney+dy[ndir]][nex+dx[ndir]] == '#')break;\n\t    ney+=dy[ndir];\n\t    nex+=dx[ndir];\n\t  }\n\t  edge[i][j][k][l].pb(      (Edge){ney,nex,ndir});\n\t  rev[ney][nex][ndir][l].pb((Edge){i  ,  j,   k});\n\t}\n      }\n    }\n  }\n}\n\nvoid output(int r,int c,int ry,int rx,int rd,int rl){\n  const char dd[]={'N','E','S','W'};\n  const char aho[]={'R','L'};\n  cout <<\"Outputbegin\"<<endl;\n  cout << aho[rl] << endl;\n  rep(i,r){\n    rep(j,c){\n      if (ry == i && rx == j)cout << dd[rd];\n      else cout << m[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl<<endl;\n}\n\nbool cango;\n\nbool solve(int r,int c,int sy,int sx,int sd,\n\t   int ry,int rx,int rd,\n\t   int gy,int gx,int gd){\n\n  if (vis[sy][sx][sd][ry][rx][rd])return false;\n  vis[sy][sx][sd][ry][rx][rd]=true;\n  \n  if (m[sy][sx] == 'M' &&\n      ry == gy && rx == gx && rd == gd)return true;\n\n  Edge cpy1,cpy2;\n\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      int rl=1-l;\n      cpy1=edge[sy][sx][sd][l][i];\n      rep(j,rev[ry][rx][rd][rl].size()){\n\tcpy2=rev[ry][rx][rd][rl][j];\n\tif (solve(r,c,cpy1.y,cpy1.x,cpy1.d,\n\t\t  cpy2.y,cpy2.x,cpy2.d,gy,gx,gd)){\n\t  //\t  cout << \"output normal\"<<endl;\n\t  //output(r,c,sy,sx,sd,l);\n\t  //\t  cout << \"output rev\"<<endl;\n\t  //\t  output(r,c,ry,rx,rd,rl);\n\t  return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\n\nbool vis2[R][C][DIR];\nbool solve_to_kit(int r,int c,int sy,int sx,int sd){\n  if (vis2[sy][sx][sd])return false;\n\n  vis2[sy][sx][sd]=true;\n  if (m[sy][sx] == 'M')return true;\n  \n  Edge cpy1;\n  rep(l,2){\n     rep(i,edge[sy][sx][sd][l].size()){\n      cpy1=edge[sy][sx][sd][l][i];\n      if (solve_to_kit(r,c,cpy1.y,cpy1.x,cpy1.d))return true;\n     }\n  }\n  return false;\n}\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && r){\n    rep(i,r)rep(j,c)rep(k,4)rep(l,2)\n      edge[i][j][k][l].clear(),rev[i][j][k][l].clear();\n    rep(i,r)rep(j,c)rep(k,DIR)rep(ii,r)rep(jj,c)rep(kk,DIR)\n      vis[i][j][k][ii][jj][kk] = false;\n    rep(i,r)rep(j,c)rep(k,DIR)vis2[i][j][k]=false;\n    cango=false;\n    \n    int inix,iniy,inidir,orix,oriy,goalx,goaly,goaldir;\n    rep(i,r){\n      rep(j,c){\n\tcin>>m[i][j];\n\tif (m[i][j] == 'K')inix =j,iniy =i;\n\tif (m[i][j] == 'M')goalx=j,goaly=i;\n      }\n    }\n\n    orix=inix;\n    oriy=iniy;\n    rep(i,4){\n      int nex=inix+dx[i],ney=iniy+dy[i];\n      if(m[ney][nex] != '#'){\n\tinidir = i;\n\tbreak;\n      }\n    }\n    \n    while(m[iniy+dy[inidir]][inix+dx[inidir]] != '#'){\n      inix+=dx[inidir];\n      iniy+=dy[inidir];\n    }\n\n    rep(i,4){\n      int nex = goalx+dx[i],ney=goaly+dy[i];\n      if (m[ney][nex] != '#'){\n\tgoaldir = i;\n\tbreak;\n      }\n    }\n\n    while(m[goaly+dy[goaldir]][goalx+dx[goaldir]] != '#'){\n      goalx+=dx[goaldir];\n      goaly+=dy[goaldir];\n    }\n\n    make_edge(r,c);\n\n\n    /*\n    char TEST[]={'N','E','S','W'};\n    char TURN[]={'R','L'};\n    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,edge[i][j][k][l].size()){\n\t      cout <<\"pos \" <<  i<<\" \" << j <<\" dir \" << TEST[k] <<\" turn to \" <<\n\t\tTURN[l] ;\n\t      cout << \" will go \" << \n\t\tedge[i][j][k][l][m].y <<\" \" << edge[i][j][k][l][m].x <<\" dir \" \n\t\t   <<TEST[edge[i][j][k][l][m].d] << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n\n    /*    \n    rep(i,r){\n      rep(j,c){\n\trep(k,DIR){\n\t  rep(l,2){\n\t    rep(m,rev[i][j][k][l].size()){\n\t      cout << i <<\" \" << j <<\" \" << TEST[k] <<\" \" \n\t\t   <<TURN[l] << endl; \n\t      output(r,c,rev[i][j][k][l][m].y,rev[i][j][k][l][m].x,\n\t\t     rev[i][j][k][l][m].d,l);\n\t    }\n\t  }\n\t}\n      }\n    }\n    */    \n\n    if (solve_to_kit(r,c,iniy,inix,inidir))cango=true;\n    \n    bool isok=false;\n    rep(i,4){\n      int checkx=orix+dx[i],checky=oriy+dy[i];\n      if (m[checky][checkx] != '#')continue;\n      if (solve(r,c,iniy,inix,inidir,oriy,orix,i,\n\t\tgoaly,goalx,goaldir)){\n\tisok=true;\n\tbreak;\n      }\n    }\n\n\n    if (isok)cout <<\"He can accomplish his mission.\"<<endl;\n    else if(cango)cout <<\"He cannot return to the kitchen.\"<<endl;\n    else cout << \"He cannot bring tea to his master.\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pag;\ntypedef pair<pag,pag> sit;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n// »ÝÌÊu©çßéÆ«ÉAæè¤éOÌêðñ\nvector<pag> backTable[2][4][16][64];\n// »ÝÌÊu©çiÞÆ«ÉAæè¤éÌê\npag goTable[2][4][16][64];\n// ·ÅÉÊßµ½ê\nbool vis[4][16][64][4][16][64];\n// ¡ÌóÔ©çS[Ößêé©\nbool isGoal[4][16][64];\n\nint H,W;\nchar field[101][101];\nint sx,sy;\nint sag;\nint gx,gy;\nint gag;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nvoid calcGoAndBackTable(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<4;k++){\n                // ¶©EÉûü]·µÄAOiµ½ ÆÌêðßé\n                // ¶\n                {\n                    int nag=(k-1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[0][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // E\n                {\n                    int nag=(k+1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[1][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // »ÝÌü«Ì½ÎÖßÁ½ãûü]··é\n                int backAg=(k+2)%4;\n                int ny=i;\n                int nx=j;\n                while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                    // ±±Å¶ÉûüðÏ¦éêÆEÉûüðÏ¦éêÅêí¯\n                    // ¶\n                    {\n                        int nag=(k-1+4)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[0][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    // E\n                    {\n                        int nag=(k+1)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[1][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    ny+=dy[backAg];\n                    nx+=dx[backAg];\n                }\n            }\n        }\n    }\n}\n// X^[gn_©çÔÉvZµÄ¢­\nint bfs(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return 2;\n    for(int cnt=0;cnt<4;cnt++){\n    memset(vis,0,sizeof(vis));\n    priority_queue<sit> pq;\n    // X^[gn_ðpush\n    pq.push(sit(pag(pii(psy,psx),pang),pag(pii(sy,sx),(cnt))));\n    vis[pang][psy][psx][sag][sy][sx]=true;\n    while(pq.size()){\n        sit cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.first.second;\n        int gpy=cur.first.first.first;\n        int gang=cur.first.second;\n        int bpx=cur.second.first.second;\n        int bpy=cur.second.first.first;\n        int bang=cur.second.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            res=max(res,1);\n            if(isGoal[bang][bpy][bpx]){\n                res=max(res,2);\n            }\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            // ßéÓ¾¯vZ\n            for(int j=0;j<backTable[i][bang][bpy][bpx].size();j++){\n                pag nbpag=backTable[i][bang][bpy][bpx][j];\n                // ngpagÆnbpagÌîñ©çÉ¢¯éê\n                if(vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second])\n                    continue;\n                vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second]=true;\n                pq.push(sit(ngpag,nbpag));\n            }\n        }\n    }\n    }\n    // 3ÂÌÇÌóÔÉÈé©`FbN\n    return res;\n}\n\nbool used[4][101][101];\nbool bfs2(int psy,int psx,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==sy&&gx==sx)return true;\n    memset(vis,0,sizeof(vis));\n    priority_queue<pag> pq;\n    // X^[gn_ðpush\n    pq.push(pag(pii(psy,psx),pang));\n    used[pang][psy][psx]=true;\n    while(pq.size()){\n        pag cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.second;\n        int gpy=cur.first.first;\n        int gang=cur.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            return true;\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            if(used[ngpag.second][ngpag.first.first][ngpag.first.second])\n                continue;\n            used[ngpag.second][ngpag.first.first][ngpag.first.second]=true;\n            pq.push(ngpag);\n        }\n    }\n    return false;\n}\n\nvoid input(){\n    // startÆgoalÌÊuðè\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>field[i][j];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='K'){\n                field[i][j]='.';\n                sy=i;sx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')sag=k;\n                }\n            }\n            else if(field[i][j]=='M'){\n                field[i][j]='.';\n                gy=i;gx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')gag=k;\n                }\n            }\n        }\n    }\n}\nvoid init(){\n    memset(isGoal,0,sizeof(isGoal));\n    for(int i=0;i<2;i++)for(int j=0;j<4;j++)\n        for(int k=0;k<16;k++)for(int l=0;l<64;l++)\n            backTable[i][j][k][l].clear();\n}\nint main(){\n    while(cin>>W>>H&&(W|H)){\n        // ú»\n        init();\n        input();\n        calcGoAndBackTable();\n        // S[ÖßêéêðvZ\n        {\n            int cy=gy;\n            int cx=gx;\n            int cag=gag;\n            while(field[cy][cx]!='#'){\n                isGoal[cag][cy][cx]=true;\n                cy+=dy[gag];\n                cx+=dx[gag];\n            }\n            //// S[n_ÅÍSûüÅS[Â\\\n            //for(int i=0;i<4;i++)if(i!=(gag+2)%4)isGoal[i][gy][gx]=true;\n        }\n        // startn_©ç··ßÄ¨­\n        int psy=sy;\n        int psx=sx;\n        int pang=sag;\n        while(psy>=0&&psx>=0&&psy<H&&psx<W&&field[psy][psx]!='#'){\n            psy+=dy[sag];\n            psx+=dx[sag];\n        }\n        // ß·\n        psy-=dy[sag];\n        psx-=dx[sag];\n        int res=bfs(psx,psy,pang);\n        res=max(res,(int)bfs2(psx,psy,pang));\n        if(res==0)\n            cout<<\"He cannot bring tea to his master.\"<<endl;\n        else if(res==1)\n            cout<<\"He cannot return to the kitchen.\"<<endl;\n        else if(res==2)\n            cout<<\"He can accomplish his mission.\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ai=array<bool,4>;\nusing aai=array<ai,4>;\nusing aaai=array<aai,64>;\nusing aaaai=array<aaai,16>;\nusing aaaaai=array<aaaai,64>;\nusing aaaaaai=array<aaaaai,16>;\naaaaaai dp;\nstruct State{\n    int hk,wk;\n    int hm,wm;\n    int dirk,dirm;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nint w,h;\nint solve();\nint main(){\n    while(cin>>w>>h,w){\n        solve();\n    }\n}\nint solve(){\n\n    vector<string> f(h);\n    for(int i=0;i<h;i++){\n        cin>>f[i];\n    }        \n    \n    int ini_hk=-1,ini_wk=-1,ini_dirk=-1;\n    int ini_hm=-1,ini_wm=-1,ini_dirm=1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='K'){\n                ini_hk=i;\n                ini_wk=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirk=k;\n                    }\n                }\n            }\n            if(f[i][j]=='M'){\n                ini_hm=i;\n                ini_wm=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirm=k;\n                    }\n                }\n            }\n        }\n    }\n    /*\n    cout<<ini_hk<<\" \"<<ini_wk<<\" \"<<ini_dirk<<endl;\n    cout<<ini_hm<<\" \"<<ini_wm<<\" \"<<ini_dirm<<endl;\n    */\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int k=0;k<h;k++){\n                for(int l=0;l<w;l++){\n                    for(int ii=0;ii<4;ii++){\n                        for(int jj=0;jj<4;jj++){\n                            dp[i][j][k][l][ii][jj]=false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    dp[ini_hk][ini_wk][ini_hm][ini_wm][ini_dirk][ini_dirm]=true;\n    queue<State> que;\n    que.push(State{ini_hk,ini_wk,ini_hm,ini_wm,ini_dirk,ini_dirm});\n    \n    while(!que.empty()){\n        auto st=que.front();\n        que.pop();\n        \n        int hk=st.hk,wk=st.wk,dk=st.dirk;\n        int hm=st.hm,wm=st.wm,dm=st.dirm;\n        power_play:\n        /*\n        cout<<hk<<\" \"<<wk<<\" \"<<dk<<endl;\n        cout<<hm<<\" \"<<wm<<\" \"<<dm<<endl;\n        */\n        int tohk=hk+dh[dk],towk=wk+dw[dk];\n        //cout<<tohk<<\" \"<<towk<<endl;\n        int tohm=hm+dh[dm],towm=wm+dw[dm];\n        //cout<<tohm<<\" \"<<towm<<endl;\n        char tokf=f[tohk][towk];\n        char tomf=f[tohm][towm];\n        if(tokf=='#' && tomf=='#'){\n            int todk=(dk+1)%4;\n            int todm=(dm+3)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n            todk=(dk+3)%4;\n            todm=(dm+1)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n        }\n        else if(tokf=='#'){\n            hm=tohm;\n            wm=towm;\n            goto power_play;\n        }\n        else if(tomf=='#'){\n            hk=tohk;\n            wk=towk;\n            goto power_play;\n        }\n        else{\n            \n            if(!dp[tohk][towk][tohm][towm][dk][dm]){\n                dp[tohk][towk][tohm][towm][dk][dm]=true;\n                que.push(State{tohk,towk,tohm,towm,dk,dm});\n            }\n        }\n        \n    }\n    bool two_way=false;\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(i!=ini_dirk && j!=ini_dirm){\n                two_way|=dp[ini_hm][ini_wm][ini_hk][ini_wk][i][j];\n            }\n        }\n    }\n\n    bool one_way=false;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int ki=0;ki<4;ki++){\n                for(int kj=0;kj<4;kj++){\n                    if(ki!=ini_dirk && kj!=ini_dirm){\n                        one_way|=dp[ini_hm][ini_wm][i][j][ki][kj];\n                    }\n                }\n            }\n        }\n    }\n    if(two_way){\n        cout<<\"He can accomplish his mission.\"<<endl;\n    }\n    else if(one_way){   \n        cout<<\"He cannot return to the kitchen.\"<<endl;\n    }\n    else{        \n        cout<<\"He cannot bring tea to his master.\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst int D = 4,H = 16, W = 64;\nbool dp[D][H][W][D][H][W];\nchar st[H][W];\n\nbool rc[D][H][W];\n\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nP mv[D][H][W];\n\nstruct ST{\n  int k1,y1,x1,k2,y2,x2;\n  ST(){}\n  ST(int k1,int y1,int x1,int k2,int y2,int x2):\n    k1(k1),y1(y1),x1(x1),k2(k2),y2(y2),x2(x2){}\n};\n\nsigned main(){\n  int w,h;\n  while(cin>>w>>h,w){\n    vector<string> tt(h);\n    for(int i=0;i<h;i++) cin>>tt[i];\n    memset(st,'#',sizeof(st));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        st[i][j]=tt[i][j];\n    h=H;w=W;\n\n    int sy=-1,sx=-1,gy=-1,gx=-1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(st[i][j]=='K') sy=i,sx=j;\n        if(st[i][j]=='M') gy=i,gx=j;\n      }\n    }\n\n    int dy[]={0,1,0,-1};\n    int dx[]={1,0,-1,0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(st[i][j]=='#') continue;\n        for(int k=0;k<4;k++){\n          int y=i,x=j;\n          while(st[y+dy[k]][x+dx[k]]!='#'){\n            y+=dy[k];\n            x+=dx[k];\n          }\n          mv[k][i][j]=P(y,x);\n        }\n      }\n    }\n\n    {\n      memset(rc,0,sizeof(rc));\n      queue<T> que;\n      for(int k=0;k<4;k++){\n        if(st[sy+dy[k]][sx+dx[k]]=='.'){\n          int y,x;\n          tie(y,x)=mv[k][sy][sx];\n          rc[k][y][x]=1;\n          que.emplace(k,y,x);\n        }\n      }\n\n      while(!que.empty()){\n        int k,y,x;\n        tie(k,y,x)=que.front();que.pop();\n        assert(st[y+dy[k]][x+dx[k]]=='#');\n        for(int dk=1;dk<4;dk+=2){\n          int nk=(k+dk)%4;\n          int ny,nx;\n          tie(ny,nx)=mv[nk][y][x];\n          if(rc[nk][ny][nx]) continue;\n          rc[nk][ny][nx]=1;\n          que.emplace(nk,ny,nx);\n        }\n      }\n\n      int flg=0;\n      for(int k=0;k<4;k++)\n        flg|=rc[k][gy][gx];\n      if(!flg){\n        cout<<\"He cannot bring tea to his master.\"<<endl;\n        continue;\n      }\n    }\n\n    int tap=0,uku=0;\n    for(int k=0;k<4;k++){\n      if(st[sy+dy[k]][sx+dx[k]]=='.')\n        tap=k;\n      if(st[gy+dy[k]][gx+dx[k]]=='.')\n        uku=k;\n    }\n    memset(dp,0,sizeof(dp));\n    queue<ST> que;\n    auto push=\n      [&](int k1,int y1,int x1,int k2,int y2,int x2){\n        if(dp[k1][y1][x1][k2][y2][x2]) return;\n        dp[k1][y1][x1][k2][y2][x2]=1;\n        que.emplace(k1,y1,x1,k2,y2,x2);\n      };\n\n    for(int k=0;k<4;k++){\n      if(st[sy+dy[k]][sx+dx[k]]!='#') continue;\n      push(tap,mv[tap][sy][sx].first,mv[tap][sy][sx].second,k,sy,sx);\n    }\n\n    while(!que.empty()){\n      ST s=que.front();que.pop();\n      assert(st[s.y1][s.x1]!='#');\n      assert(st[s.y2][s.x2]!='#');\n      assert(st[s.y1+dy[s.k1]][s.x1+dx[s.k1]]=='#');\n      assert(st[s.y2+dy[s.k2]][s.x2+dx[s.k2]]=='#');\n\n      for(int dk=1;dk<4;dk+=2){\n        int nk1=(s.k1+dk)%4;\n        int ny1,nx1;\n        tie(ny1,nx1)=mv[nk1][s.y1][s.x1];\n\n        int nk2=(s.k2+dk)%4;\n        int ny2=s.y2,nx2=s.x2;\n        while(st[ny2][nx2]!='#'){\n          if(st[ny2+dy[nk2]][nx2+dx[nk2]]=='#')\n            push(nk1,ny1,nx1,nk2,ny2,nx2);\n          ny2-=dy[s.k2];\n          nx2-=dx[s.k2];\n        }\n      }\n    }\n\n    int flg=0;\n    for(int k=0;k<4;k++)\n      flg|=dp[k][gy][gx][uku][mv[uku][gy][gx].first][mv[uku][gy][gx].second];\n    if(flg) cout<<\"He can accomplish his mission.\"<<endl;\n    else cout<<\"He cannot return to the kitchen.\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint W, H;\nint Ky, Kx, My, Mx;\nchar mas[16][64];\nbool used[4][16][64][4][16][64];\n\nconst int dy[] = {-1, 0, 1, 0};\nconst int dx[] = {0, -1, 0, 1};\n\nbool in(int i, int j) {\n  return 0<=i&&i<H&&0<=j&&j<W;\n}\nbool wall(int y, int x) {\n  return in(y, x) && mas[y][x] == '#';\n}\nbool nowall(int y, int x) {\n  return in(y, x) && mas[y][x] != '#';\n}\n\nbool master, kitchen;\nvoid dfs(int Fd, int Fy, int Fx, int Bd, int By, int Bx, bool isone) {\n  if(kitchen) return;\n  if(isone && master) return;\n  if(used[Fd][Fy][Fx][Bd][By][Bx]) return;\n  used[Fd][Fy][Fx][Bd][By][Bx] = true;\n\n  int nFy = Fy+dy[Fd], nFx = Fx+dx[Fd];\n  while(nowall(nFy, nFx)) {\n    nFy += dy[Fd], nFx += dx[Fd];\n  }\n  nFy -= dy[Fd], nFx -= dx[Fd];\n  if(isone) {\n    if(nFy == My && nFx == Mx) {\n      master = true;\n      return;\n    }\n    dfs((Fd+1)%4, nFy, nFx, 0, 0, 0, true);\n    dfs((Fd+3)%4, nFy, nFx, 0, 0, 0, true);\n    return;\n  }\n\n  if(!wall(By+dy[(Bd+2)%4], Bx+dx[(Bd+2)%4])) return;\n  int nBy = By, nBx = Bx;\n  while(nowall(nBy, nBx)) {\n    rep(i, 2) {\n      dfs((Fd+2*i+1)%4, nFy, nFx, (Bd+2*i+1)%4, nBy, nBx, false);\n      if(kitchen) return;\n    }\n    nBy += dy[Bd], nBx += dx[Bd];\n  }\n  nBy -= dy[Bd], nBx -= dx[Bd];\n  if(nFy == My && nFx == Mx && nBy == My && nBx == Mx &&\n     nowall(nBy+dy[(Bd+2)%4], nBx+dx[(Bd+2)%4])) {\n    kitchen = true;\n    return;\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> W >> H, W || H) {\n    rep(i, H) rep(j, W) {\n      cin >> mas[i][j];\n      if(mas[i][j] == 'K') Ky = i, Kx = j;\n      else if(mas[i][j] == 'M') My = i, Mx = j;\n    }\n    kitchen = master = false;\n    rep(i, 4) {\n      int y = Ky+dy[i], x = Kx+dx[i];\n      if(nowall(y, x)) {\n\tmemset(used, false, sizeof(used));\n\trep(j, 4) dfs(i, Ky, Kx, j, Ky, Kx, false);\n\tmemset(used, false, sizeof(used));\n\tdfs(i, Ky, Kx, 0, 0, 0, true);\n\tbreak;\n      }\n    }\n    if(kitchen) cout << \"He can accomplish his mission.\" << endl;\n    else if(master) cout << \"He cannot return to the kitchen.\" << endl;\n    else cout << \"He cannot bring tea to his master.\" << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<deque>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<sstream>\n#include<bitset>\n#include<cstring>\n#include<climits>\n#include<cassert>\n#define F first\n#define S second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define T 0\n#define R 1\n#define B 2\n#define L 3\n#define PesIns(a,b,c,d) Pes(PP(P(a.x,a.y),P(b.x,b.y)),P(c,d))\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<VVB> VVVB;\ntypedef vector<VC> VVC;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<PP,P> Pes;\n\n\nstruct Point\n{\n  int x,y;\n  Point(int x = -1,int y = -1):x(x),y(y){}\n  bool operator == (const Point& p)const\n  {\n    return (x == p.x && y == p.y);\n  }\n  friend ostream& operator << (ostream& os,const Point& p);\n};\n\nostream& operator << (ostream& os,const Point& p)\n{\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\n\n\nint H,W;\nchar G[17][65];\nPoint K,M;\nVVVB visited;\nmap<Pes,bool> exist;\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\nint add[] = {1,3};\nbool M_ok,K_ok;\nint est;\n\nstring debug(int d)\n{\n  if(d == 0)\n    return \"T\";\n\n  if(d == 1)\n    return \"R\";\n\n  if(d == 2)\n    return \"B\";\n\n  if(d == 3)\n    return \"L\";\n\n  return \"X\";\n}\n\nvoid dfs(Point p1,Point p2,int dir1,int dir2,bool f)\n{\n  \n  if(K_ok)\n    return;\n\n  if(!f && M_ok)\n    return;\n\n  Pes pes = PesIns(p1,p2,dir1,dir2);\n  if(exist[pes])\n  return;\n  exist[pes] = true;\n\n  if(f && G[p2.y+dy[dir2]][p2.x+dx[dir2]] != '#')//ループ内ではなくここでカットする\n      return;\n\n  //cout << \"----\" << endl;\n  //cout << p1 << \" \" << p2 << \" \" << debug(dir1) << \" \" << debug(dir2)  << \" M = \" << M<< endl; \n\n  while(G[p1.y+dy[dir1]][p1.x+dx[dir1]] != '#')\n    p1.x += dx[dir1],p1.y += dy[dir1];\n\n\n  if(f && p1 == M && p1 == p2 && G[M.y+dy[dir2]][M.x+dx[dir2]] == '.')\n    {\n      K_ok = true;\n      return;\n    }  \n  else if(!f && p1 == M)\n    {\n      M_ok = true;\n      return;\n    }\n\n  \n  if(f)\n    {\n      while(G[p2.y][p2.x] != '#')//一つ一つ戻りながら全探索\n\t{    \n\t  rep(i,2)\n\t    {\n\t      dfs(p1,p2,(dir1+add[i])%4,(dir2+add[i])%4,f);\t\n\t      \n\t      if(K_ok)\n\t\treturn;\n\t    }\n\t  \n\t  p2.x += dx[(dir2+2)%4],p2.y += dy[(dir2+2)%4]; //ここでやらないと最初の状態がとばされる         \n\t}\n      p2.x += dx[dir2],p2.y += dy[dir2];\n    }\n  else \n    {\n      rep(i,2)\n\t{\n\t  dfs(p1,p2,(dir1+add[i])%4,dir2,f);\n\t  if(M_ok)\n\t    return;\n\t}\n    }\n  if(p1 == M && p1 == p2 && G[M.y+dy[dir2]][M.x+dx[dir2]] == '.')\n    {\n    \n      K_ok = true;\n      return;\n    }\n  else if(!f && p1 == M)\n    {\n      M_ok = true;\n      return;\n    }\n \n}\n\n\n\nint main()\n{\n\n  while(cin >> W >> H,H|W)\n    {\n  \n      M_ok = K_ok = false;\n      exist.clear();\n      visited.clear();\n      visited.resize(4);\n      rep(i,4)\n\tvisited[i].resize(H);\n\n  \n      rep(i,H)\n\t{\n\t  rep(j,4)\n\t    visited[j][i].resize(W);\n\t  string line;\n\t  cin >> line;\n\t  rep(j,W)\n\t    {\n\t      rep(k,4)\n\t\tvisited[k][i][j] = false;\n\t      G[i][j] = line[j];\n\t\n\t      if(G[i][j] == 'K')\n\t\tK = Point(j,i);\n\t      else if(G[i][j] == 'M')\n\t\tM = Point(j,i);\n\t    }\n\t}\n\n  \n     \n\n      int inidir = -1;\n      rep(i,4)\n\tif(G[K.y+dy[i]][K.x+dx[i]] == '.')\n\t  inidir = i;\n      dfs(K,Point(-1,-1),inidir,-1,false);\t \n      rep(i,4)\n\t{\n\t  dfs(K,K,inidir,i,true);\n\t  \n\t  if(K_ok)\n\t    break;\n\t}\n\tif(K_ok)\n\tcout << \"He can accomplish his mission.\" << endl;\n\telse if(M_ok)\n\t  cout << \"He cannot return to the kitchen.\" << endl;\n\telse\n\t  cout << \"He cannot bring tea to his master.\" << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint H, W;\n\nstring M[16];\n\nbool visited[16][64][4];\n\nbool visit2[16][64][4][16][64][4];\n\nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n\nvoid rec(int x, int y, int dir)\n{\n\tif (!visited[y][x][dir])\n\t{\n\t\tvisited[y][x][dir] = true;\n\n\t\twhile (M[y + dy[dir]][x + dx[dir]] != '#')\n\t\t{\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\t\t}\n\n\t\trec(x, y, (dir + 3) % 4);\n\t\trec(x, y, (dir + 1) % 4);\n\t}\n}\n\nvoid rec2(int x1, int y1, int dir1, int x2, int y2, int dir2)\n{\n\tif (!visit2[y1][x1][dir1][y2][x2][dir2])\n\t{\n\t\tvisit2[y1][x1][dir1][y2][x2][dir2] = true;\n\n\t\twhile (M[y1 + dy[dir1]][x1 + dx[dir1]] != '#')\n\t\t{\n\t\t\tx1 += dx[dir1];\n\t\t\ty1 += dy[dir1];\n\t\t}\n\n\t\twhile (M[y2 + dy[dir2]][x2 + dx[dir2]] != '#')\n\t\t{\n\t\t\tx2 += dx[dir2];\n\t\t\ty2 += dy[dir2];\n\t\t}\n\n\t\trec2(x1, y1, (dir1 + 3) % 4, x2, y2, (dir2 + 1) % 4);\n\t\trec2(x1, y1, (dir1 + 1) % 4, x2, y2, (dir2 + 3) % 4);\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\t\t\n\t\tif (H == 0 && W == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> M[i];\n\n\t\tint sx, sy, sd, mx, my, md;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == 'K')\n\t\t\t\t{\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\n\t\t\t\t\tfor (int d = 0; d < 4; d++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (M[i + dy[d]][j + dx[d]] != '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsd = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (M[i][j] == 'M')\n\t\t\t\t{\n\t\t\t\t\tmx = j;\n\t\t\t\t\tmy = i;\n\n\t\t\t\t\tfor (int d = 0; d < 4; d++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (M[i + dy[d]][j + dx[d]] != '#')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmd = d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok;\n\n\t\t// 1st.\n\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\trec(sx, sy, sd);\n\n\t\tok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n\n\t\tif (!ok)\n\t\t{\n\t\t\tprintf(\"He cannot bring tea to his master.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// 2nd.\n\n\t\t\tmemset(visited, false, sizeof(visited)); rec2(sx, sy, sd, mx, my, md);\n\n\t\t\tok = false;\n\t\t\t\n\t\t\tfor (int dir1 = 0; dir1 < 4; dir1++)\n\t\t\t{\n\t\t\t\tfor (int dir2 = 0; dir2 < 4; dir2++)\n\t\t\t\t{\n\t\t\t\t\tok = ok || visit2[my][mx][dir1][sy][sx][dir2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tprintf(\"He cannot return to the kitchen.\\n\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"He can accomplish his mission.\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> pag;\ntypedef pair<pag,pag> sit;\n\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\n\n// »ÝÌÊu©çßéÆ«ÉAæè¤éOÌêðñ\nvector<pag> backTable[2][4][16][64];\n// »ÝÌÊu©çiÞÆ«ÉAæè¤éÌê\npag goTable[2][4][16][64];\n// ·ÅÉÊßµ½ê\nbool vis[4][16][64][4][16][64];\n// ¡ÌóÔ©çS[Ößêé©\nbool isGoal[4][16][64];\nbool used[4][101][101];\n\nint H,W;\nchar field[101][101];\nint sx,sy;\nint sag;\nint gx,gy;\nint gag;\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,1,0,-1};\n\nvoid calcGoAndBackTable(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int k=0;k<4;k++){\n                // ¶©EÉûü]·µÄAOiµ½ ÆÌêðßé\n                // ¶\n                {\n                    int nag=(k-1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[0][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // E\n                {\n                    int nag=(k+1+4)%4;\n                    int ny=i;\n                    int nx=j;\n                    while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                        ny+=dy[nag];\n                        nx+=dx[nag];\n                    }\n                    ny-=dy[nag];\n                    nx-=dx[nag];\n                    goTable[1][k][i][j]=pag(pii(ny,nx),nag);\n                }\n                // »ÝÌü«Ì½ÎÖßÁ½ãûü]··é\n                int backAg=(k+2)%4;\n                int ny=i;\n                int nx=j;\n                while(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n                    // ±±Å¶ÉûüðÏ¦éêÆEÉûüðÏ¦éêÅêí¯\n                    // ¶\n                    {\n                        int nag=(k-1+4)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[0][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    // E\n                    {\n                        int nag=(k+1)%4;\n                        // ¡ü¢Ä¢éûüÉÇª êÎAXgÉÇÁ\n                        if(field[ny+dy[nag]][nx+dx[nag]]=='#')backTable[1][k][i][j].push_back(pag(pii(ny,nx),nag));\n                    }\n                    ny+=dy[backAg];\n                    nx+=dx[backAg];\n                }\n            }\n        }\n    }\n}\n// X^[gn_©çÔÉvZµÄ¢­\nint bfs(int psx,int psy,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return 2;\n    for(int cnt=0;cnt<4;cnt++){\n        memset(vis,0,sizeof(vis));\n        priority_queue<sit> pq;\n        // X^[gn_ðpush\n        pq.push(sit(pag(pii(psy,psx),pang),pag(pii(sy,sx),(cnt))));\n        vis[pang][psy][psx][sag][sy][sx]=true;\n        while(pq.size()){\n            sit cur=pq.top();pq.pop();\n            // »ÝÌóÔðæ¾\n            int gpx=cur.first.first.second;\n            int gpy=cur.first.first.first;\n            int gang=cur.first.second;\n            int bpx=cur.second.first.second;\n            int bpy=cur.second.first.first;\n            int bang=cur.second.second;\n            // S[»è\n            if(gpy==gy&&gpx==gx){\n                res=max(res,1);\n                if(isGoal[bang][bpy][bpx]){\n                    res=max(res,2);\n                }\n            }\n            // Ì½ßðÇ¤·é©\n            for(int i=0;i<2;i++){\n                // Ìs«æ\n                pag ngpag=goTable[i][gang][gpy][gpx];\n                // ßéÓ¾¯vZ\n                for(int j=0;j<backTable[i][bang][bpy][bpx].size();j++){\n                    pag nbpag=backTable[i][bang][bpy][bpx][j];\n                    // ngpagÆnbpagÌîñ©çÉ¢¯éê\n                    if(vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second])\n                        continue;\n                    vis[ngpag.second][ngpag.first.first][ngpag.first.second][nbpag.second][nbpag.first.first][nbpag.first.second]=true;\n                    pq.push(sit(ngpag,nbpag));\n                }\n            }\n        }\n    }\n    // 3ÂÌÇÌóÔÉÈé©`FbN\n    return res;\n}\n\nbool bfs2(int psy,int psx,int pang){\n    int res=0;\n    // ·ÅÉS[Â\\\n    if(gy==psy&&gx==psx)return true;\n    memset(used,0,sizeof(used));\n    priority_queue<pag> pq;\n    // X^[gn_ðpush\n    pq.push(pag(pii(psy,psx),pang));\n    used[pang][psy][psx]=true;\n    while(pq.size()){\n        pag cur=pq.top();pq.pop();\n        // »ÝÌóÔðæ¾\n        int gpx=cur.first.second;\n        int gpy=cur.first.first;\n        int gang=cur.second;\n        // S[»è\n        if(gpy==gy&&gpx==gx){\n            return true;\n        }\n        // Ì½ßðÇ¤·é©\n        for(int i=0;i<2;i++){\n            // Ìs«æ\n            pag ngpag=goTable[i][gang][gpy][gpx];\n            if(used[ngpag.second][ngpag.first.first][ngpag.first.second])\n                continue;\n            used[ngpag.second][ngpag.first.first][ngpag.first.second]=true;\n            pq.push(ngpag);\n        }\n    }\n    return false;\n}\n\nvoid input(){\n    // startÆgoalÌÊuðè\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>field[i][j];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j]=='K'){\n                field[i][j]='.';\n                sy=i;sx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')sag=k;\n                }\n            }\n            else if(field[i][j]=='M'){\n                field[i][j]='.';\n                gy=i;gx=j;\n                for(int k=0;k<4;k++){\n                    int ny=i+dy[k];\n                    int nx=j+dx[k];\n                    if(field[ny][nx]=='.')gag=k;\n                }\n            }\n        }\n    }\n}\nvoid init(){\n    memset(isGoal,0,sizeof(isGoal));\n    for(int i=0;i<2;i++)for(int j=0;j<4;j++)\n        for(int k=0;k<16;k++)for(int l=0;l<64;l++)\n            backTable[i][j][k][l].clear();\n}\nint main(){\n    while(cin>>W>>H&&(W|H)){\n        // ú»\n        init();\n        input();\n        calcGoAndBackTable();\n        // S[ÖßêéêðvZ\n        {\n            int cy=gy;\n            int cx=gx;\n            int cag=gag;\n            isGoal[cag][cy][cx]=true;\n            while(field[cy][cx]!='#'){\n                //isGoal[cag][cy][cx]=true;\n                cy+=dy[gag];\n                cx+=dx[gag];\n            }\n            cy-=dy[gag];\n            cx-=dx[gag];\n            isGoal[cag][cy][cx]=true;\n        }\n        // startn_©ç··ßÄ¨­\n        int psy=sy;\n        int psx=sx;\n        int pang=sag;\n        while(psy>=0&&psx>=0&&psy<H&&psx<W&&field[psy][psx]!='#'){\n            psy+=dy[sag];\n            psx+=dx[sag];\n        }\n        // ß·\n        psy-=dy[sag];\n        psx-=dx[sag];\n        int res=bfs(psx,psy,pang);\n        res=max(res,(int)bfs2(psx,psy,pang));\n        if(res==0)\n            cout<<\"He cannot bring tea to his master\"<<endl;\n        else if(res==1)\n            cout<<\"He cannot return to the kitchen\"<<endl;\n        else if(res==2)\n            cout<<\"He can accomplish his mission\"<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nbool memo[64][16][4][64][16][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint fway;\n\tint tx;\n\tint ty;\n\tint tway;\n};\nint gx, gy;\n\nvector<aa>astack;\n\nbool cangoal;\n\nint gway;\n\nbool check(int fx, int fy,int fway, int tx, int ty, int tway) {\n\n\tif (memo[fx][fy][fway][tx][ty][tway])return false;\n\tmemo[fx][fy][fway][tx][ty][tway] =true;\n\t\n\t//else{\n\n\t\tint nfy = fy + dy[fway];\n\t\tint nfx = fx + dx[fway];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (mp[nfy][nfx]) {\n\t\t\t\tnfx -= dx[fway];\n\t\t\t\tnfy -= dy[fway];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[fway];\n\t\t\tnfx = nfx + dx[fway];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (mp[nty][ntx]) {\n\t\t\t\tntx -= dx[tway];\n\t\t\t\tnty -= dy[tway];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\t\tint afway = (fway + 3) % 4;\n\t\t\t\tint atway = (tway + 3) % 4;\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\t\tcangoal = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\t\tint afway = (fway + 1) % 4;\n\t\t\t\tint atway = (tway + 1) % 4;\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\t\tcangoal = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnty = nty + dy[tway];\n\t\t\tntx = ntx + dx[tway];\n\t\t}\n\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\tint afway = (fway + 3) % 4;\n\t\t\tint atway = (tway + 3) % 4;\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\t\t}\n\n\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\tint atway = (tway + 1) % 4;\n\t\t\tint afway = (fway + 1) % 4;\n\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\t\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\n\t\t\t}\n\t\t}\n\n\t//}\n\treturn false;\n}\n\nbool memo2[64][16][4];\n\nbool check2(int fx, int fy, int fway) {\n\tif (memo2[fx][fy][fway])return false;\n\tmemo2[fx][fy][fway] = true;\n\n\tif (fx == gx&&fy == gy)return true;\n\tint nfy = fy + dy[fway];\n\tint nfx = fx + dx[fway];\n\twhile (1) {\n\n\t\tif (mp[nfy][nfx]) {\n\t\t\tnfx -= dx[fway];\n\t\t\tnfy -= dy[fway];\n\t\t\tbreak;\n\t\t}\n\t\tnfy = nfy + dy[fway];\n\t\tnfx = nfx + dx[fway];\n\n\t}\n\treturn (check2(nfx, nfy, (fway + 1) % 4) || check2(nfx, nfy, (fway + 3) % 4));\n}\n\nint main() {\n\twhile (1) {\n\t\tcangoal = false;\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemset(memo2, 0, sizeof(memo2));\n\t\tastack.clear();\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\t\tmp.resize(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tmp[i].resize(W);\n\t\t}\n\n\t\tint sx, sy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t\tif (mp[gy + dy[i]][gx + dx[i]] == 0) {\n\t\t\t\tgway = i;\n\t\t\t}\n\t\t}\n\t\tbool perf = false;\n\t\tfor (int i = 0; i < 4;++i)\n\t\t\tastack.push_back(aa{ sx,sy,sway,sx,sy,i });\n\n\t\twhile (!astack.empty()) {\n\t\t\taa atop(astack.back());\n\t\t\tastack.pop_back();\n\t\t\tif (check(atop.fx, atop.fy,atop.fway, atop.tx, atop.ty, atop.tway)) {\n\t\t\t\tperf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (perf) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (check2(sx,sy,sway)) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<cstdio>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\t\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\tcout << x << \" \" << y << endl;\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') { y += dy[dir]; x += dx[dir];\n\t\t}\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int y, int x) {\n\trep(i, 4) {\n\t\tcout << \"i:\" << i << endl;\n\t\tif (in[y + dy[i]][x + dx[i]] != '#')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (1) {\n\t\tscanf(\"%d %d\", &w, &h);\n\t\tif (w == 0 && h == 0)break;\n\t\trep(i, h) cin >> in[i];\n\t\t\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tcout << sy << \" \" << sx << endl;\n\t\tcout << gy << \" \" << gx << endl;\n\t\tbool iki, kaeri;\n\t\tdir(gy, gx);\n\t\t\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  /*\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef pair<int, int> pi;\npi mp;\nstring in[16];\nconst int W = 100;\nconst int dy[] = { -1,0,1,0 }, dx[] = { 0,-1,0,1 };\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nbool solve(int sy,int sx,int sd,int gy,int gx ) {\n\tstatic bool v[16][64][4];\n\tmemset(v, 0, sizeof(v));\n\tqueue<pi> q;\n\tmp.first = sy * W + sx; mp.second = sd;\n\tq.push(mp);\n\tv[sy][sx][sd] = 1;\n\twhile (!q.empty()) {\n\t\tint y = q.front().first / W, x = q.front().first%W;\n\t\tint dir = q.front().second; q.pop();\n\t\twhile (in[y + dy[dir]][x + dx[dir]] != '#') y += dy[dir], x += dx[dir];\n\t\tif (y == gy&& x == gx)return 1;\n\t\tdir = (dir + 1) % 4 ;\n\t\trep(d, 2) {\n\t\t\tif ((!v[y][x][dir])) {\n\t\t\t\tv[y][x][dir] = true;\n\t\t\t\tmp.first = y*W + x;\n\t\t\t\tmp.second = dir;\n\t\t\t\tq.push(mp);\n\t\t\t}\n\t\t\tdir = (dir + 2) % 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dir(int x, int y) {\n\trep(i, 4) {\n\t\tif (in[y + dy[i]][x + dx[i]] == ',')return i;\n\t}\n}\n\nint main() {\n\tint w,h,sx,sy,gx,gy;\n\twhile (cin >> w >> h, h!=0&&w!=0) {\n\t\trep(i, h) cin >> in[i];\n\t\trep(j, w)rep(i, h) {\n\t\t\tif (in[i][j] == 'K')sy = i, sx = j;\n\t\t\tif (in[i][j] == 'M')gy = i, gx = j;\n\t\t}\n\t\tbool iki, kaeri;\n\t\tiki = solve(sy, sx,dir(sy,sx),  gy, gx);\n\t\tkaeri = solve(gy, gx,dir(gy,gx), sy, sx);\n\t\tif (iki&&kaeri)cout << \"He can accomplish his mission.\" << endl;\n\t\telse if (iki)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse if (!iki)cout << \"He cannot bring tea to his master.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\n// L,U,R,D --- right:+1, left:-1\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,1,0,-1};\nconst int dc[2] = {-1,1};\n\nint changeDirection(int f, int c) { return (f + dc[c] + 4) % 4; }\n\nint W, H, pos_id[16][64];\nstring home_map[16];\n\nint nextPos(int cx, int cy, int d) {\n\twhile (home_map[cy + dy[d]][cx + dx[d]] != '#') {\n\t\tcx += dx[d];\n\t\tcy += dy[d];\n\t}\n\treturn pos_id[cy][cx];\n}\n\n/***************** solver ********************/\n\nint trans[1024][4][2];\nvector< int > trans_rev[1024][4][2];\nint start_id, start_dir, goal_id, goal_dir;\nvector< int > wall_dir_at_K;\n\nvoid constructTransition() {\n\tmemset(trans, -1, sizeof(trans));\n\tfor_(i,0,1024) for_(j,0,4) for_(k,0,2) trans_rev[i][j][k] = vector< int >();\n\twall_dir_at_K = vector< int >();\n\t\n\tint id = 1;\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == 'K') pos_id[y][x] = 0;\n\t\telse if (home_map[y][x] == 'M') pos_id[y][x] = 1023;\n\t\telse if (home_map[y][x] == '.') pos_id[y][x] = id++;\n\t}\n\t\n\tint cnt = 0;\n\tfor_(y,0,H) {\n\t\tfor_(x,0,W) {\n\t\t\tif (home_map[y][x] == 'M' || home_map[y][x] == 'K') {\n\t\t\t\tfor_(d,0,4) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\t\t\t\tif (home_map[ny][nx] == '#') {\n\t\t\t\t\t\tif (home_map[y][x] == 'K') wall_dir_at_K.push_back(d);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tif (home_map[y][x] == 'M') {\n\t\t\t\t\t\tgoal_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tgoal_dir = d;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstart_id = nextPos(nx, ny, d);\n\t\t\t\t\t\tstart_dir = d;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t\tif (cnt == 2) break;\n\t\t}\n\t\tif (cnt == 2) break;\n\t}\n\t\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (home_map[y][x] == '#') continue;\n\t\tid = pos_id[y][x];\n\t\tfor_(f,0,4) for_(c,0,2) {\n\t\t\tint nxt_dir = changeDirection(f, c);\n\t\t\tint nxt_id = nextPos(x, y, nxt_dir);\n\t\t\ttrans[id][f][c] = nxt_id;\n\t\t\ttrans_rev[nxt_id][nxt_dir][c].push_back(id);\n\t\t}\n\t}\n}\n\nint SHIFT = 16, MASK = (1 << 16) - 1;\nbool visM[1024][4];\nbool vis[1024][4][1024][4];\n\ninline int makeState(int id, int dir) { return (id | (dir << SHIFT)); }\ninline int getID(int state) { return (state & MASK); }\ninline int getDIR(int state) { return (state >> SHIFT); }\n\nbool canReachMaster() {\n\tmemset(visM, 0, sizeof(visM));\n\t\n\tqueue< int > que;\n\tque.push(makeState(start_id, start_dir));\n\tvisM[start_id][start_dir] = true;\n\t\n\twhile (!que.empty()) {\n\t\tint s = que.front(); que.pop();\n\t\tint id = getID(s), dir = getDIR(s);\n\t\tif (id == 1023) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c);\n\t\t\tif (!visM[nxt_id][nxt_dir]) {\n\t\t\t\tvisM[nxt_id][nxt_dir] = true;\n\t\t\t\tque.push(makeState(nxt_id, nxt_dir));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nbool canDo() {\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tqueue< pii > que;\n\tfor (int d : wall_dir_at_K) {\n\t\tque.push(pii(makeState(start_id, start_dir), makeState(0, d)));\n\t\tvis[start_id][start_dir][0][d] = true;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tpii p = que.front(); que.pop();\n\t\tint id = getID(p.first), dir = getDIR(p.first);\n\t\tint rev_id = getID(p.second), rev_dir = getDIR(p.second);\n\t\tif (id == 1023 && rev_id == goal_id && rev_dir == goal_dir) return true;\n\t\tfor_(c,0,2) {\n\t\t\tint nxt_id = trans[id][dir][c], nxt_dir = changeDirection(dir, c), nxt_rev_dir = changeDirection(rev_dir, c);\n\t\t\tfor (int nxt_rev_id : trans_rev[rev_id][rev_dir][1 - c]) {\n\t\t\t\tif (!vis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir]) {\n\t\t\t\t\tvis[nxt_id][nxt_dir][nxt_rev_id][nxt_rev_dir] = true;\n\t\t\t\t\tque.push(pii(makeState(nxt_id, nxt_dir), makeState(nxt_rev_id, nxt_rev_dir)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tconstructTransition();\t\n\tif (canReachMaster()) {\n\t\tif (canDo()) puts(\"He can accomplish his mission.\");\n\t\telse puts(\"He cannot return to the kitchen.\");\n\t} else {\n\t\tputs(\"He cannot bring tea to his master.\");\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (H == 0) break;\n\t\tfor_(y,0,H) cin >> home_map[y];\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint change(int kx, int ky, int kv, int mx, int my, int mv){\n\tint ans = 0;\n\tans += kx;\n\tans <<= 4;\n\tans += ky;\n\tans <<= 2;\n\tans += kv;\n\tans <<= 6;\n\tans += mx;\n\tans <<= 4;\n\tans += my;\n\tans <<= 2;\n\tans += mv;\n\treturn ans;\n}\nint getkx(int n){\n\treturn (n >> 18) & (63);\n}\nint getky(int n){\n\treturn (n >> 14)&(15);\n}\nint getkv(int n){\n\treturn (n >> 12)&(3);\n}\nint getmx(int n){\n\treturn (n >> 6)&(63);\n}\nint getmy(int n){\n\treturn (n >> 2)&(15);\n}\nint getmv(int n){\n\treturn n & 3;\n}\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vs;\n\t\tint kx, ky;\n\t\tint mx, my;\n\t\tREP(i, H){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tint k = s.find(\"K\");\n\t\t\tint m = s.find(\"M\");\n\t\t\tif (k != string::npos){\n\t\t\t\tkx = k;\n\t\t\t\tky = i;\n\t\t\t}\n\t\t\tif (m != string::npos){\n\t\t\t\tmx = m;\n\t\t\t\tmy = i;\n\t\t\t}\n\t\t}\n\t\tvector<int> vsh;\n\t\tREP(i, 4){\n\t\t\tif (vs[ky + dy[i]][kx + dx[i]] == '.'){\n\t\t\t\tREP(j, 4){\n\t\t\t\t\tif (vs[my + dy[j]][mx + dx[j]] == '.'){\n\t\t\t\t\t\tvsh.push_back(change(kx, ky, i, mx, my, j));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tbool clear = false;\n\t\tbool ktom = false;\n\t\twhile (1){\n\t\t\tint kx2 = getkx(vsh[count]);\n\t\t\tint ky2 = getky(vsh[count]);\n\t\t\tint kv2 = getkv(vsh[count]);\n\t\t\tint mx2 = getmx(vsh[count]);\n\t\t\tint my2 = getmy(vsh[count]);\n\t\t\tint mv2 = getmv(vsh[count]);\n\t\t\tif (kx2 == mx&&ky2 == my){\n\t\t\t\tktom = true;\n\t\t\t}\n\t\t\tif (kx2 == mx&&ky2 == my&&mx2 == kx&&my2 == ky){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (dx[kv2] != 0 && vs[ky2 + dy[kv2]][kx2 + dx[kv2]] != '#')kx2 += dx[kv2];\n\t\t\twhile (dy[kv2] != 0 && vs[ky2 + dy[kv2]][kx2 + dx[kv2]] != '#')ky2 += dy[kv2];\n\t\t\twhile (dx[mv2] != 0 && vs[my2 + dy[mv2]][mx2 + dx[mv2]] != '#')mx2 += dx[mv2];\n\t\t\twhile (dy[mv2] != 0 && vs[my2 + dy[mv2]][mx2 + dx[mv2]] != '#')my2 += dy[mv2];\n\t\t\t//if (ky2 + dy[kv2] >= 0 && ky2 + dy[kv2]<W&&mx2 + dx[mv2]>=0 && mx2 + dx[mv2]<=)\n\t\t\tREP(i, 2){\n\t\t\t\tint i2=-1;\n\t\t\t\tif (i == 1)i2 = 1;\n\t\t\t\tif (find(vsh.begin(), vsh.end(), change(kx2, ky2, (kv2 + i2 + 4) % 4, mx2, my2, (mv2 - i2 + 4) % 4)) == vsh.end())\n\t\t\t\t\tvsh.push_back(change(kx2, ky2, (kv2 + i2 + 4) % 4, mx2, my2, (mv2 - i2 + 4) % 4));\n\t\t\t}\n\t\t\tif (count + 1 == vsh.size())break;\n\t\t\t\tcount++;\n\t\t}\n\t\tif (!ktom&&!clear)cout <<\"He cannot bring tea to his master.\" << endl;\n\t\telse if (!clear)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse cout << \"He can accomplish his mission.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl\n#define double long double\nusing namespace std;\nconst int INF = 1e9;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nconst int H = 17;\nconst int W = 65;\n\nint h,w;\nvector<string> mp;\n\nint used[W][H][4][W][H][4];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nchar getChar(int x,int y,int dir){return mp[y + dy[dir]][x + dx[dir]];}\nvoid getNx(int &x,int &y,int dir){while(getChar(x, y, dir) != '#') x += dx[dir],y += dy[dir];}\nint getDir(int x,int y){for(int i=0;i<4;i++) if(getChar(x, y, i) != '#') return i;}\n\nint bfs(int sx,int sy,int gx,int gy,int flag = 0){\n  memset(used,0,sizeof(used));\n  int sdir = getDir(sx, sy);\n  int gdir = getDir(gx, gy);\n  \n  struct dat{\n    int x, y, dir1, a, b, dir2;\n    dat();\n    dat(int x,int y,int dir1,int a,int b,int dir2):\n      x(x), y(y), dir1(dir1), a(a), b(b), dir2(dir2){}\n  };\n  \n  queue<dat> Q;\n  \n  auto Push=[&](int nx,int ny,int ndir1,int a,int b,int ndir2){\n    \n    if(flag) {\n      if(used[nx][ny][ndir1][0][0][0]++ == 0) Q.push(dat(nx,ny,ndir1, 0,0,0));\n      return;\n    }\n\n    if(getChar(a, b, ndir2) != '#') return;\n    int na = a, nb = b;\n    while(mp[nb][na] != '#'){\n      int flag = getChar(na,nb,(ndir2+1)%4) == '#' || getChar(na, nb, (ndir2+3)%4) == '#';\n      if(flag && used[nx][ny][ndir1][na][nb][ndir2]++ == 0) Q.push(dat(nx,ny,ndir1, na,nb,ndir2));\n      na += dx[(ndir2+2)%4];\n      nb += dy[(ndir2+2)%4];\n    }\n  };\n  \n  for(int i=0;i<4;i++){\n    int nx = sx, ny = sy; getNx(nx, ny, sdir);\n    if(getChar(sx, sy, i) == '#') Push(nx,ny,sdir,sx,sy,i);\n  }\n\n  int res = 0;\n  while(!Q.empty()){\n    auto t = Q.front(); Q.pop();\n    int x = t.x, y = t.y, dir1 = t.dir1;\n    int a = t.a, b = t.b, dir2 = t.dir2;\n    if(x == gx && y == gy) res = 1;\n    if(x == gx && y == gy && a == gx && b == gy && dir2 == gdir) return 2;\n    \n    \n    {//右に曲がる\n      int nx = x, ny = y, ndir1 = (dir1 + 1) % 4; getNx(nx, ny, ndir1);\n      int ndir2 = (dir2 + 1) % 4;\n      Push(nx, ny, ndir1, a, b, ndir2);\n    }\n\n    {//左に曲がる。\n      int nx = x, ny = y, ndir1 = (dir1 + 3) % 4; getNx(nx, ny, ndir1);\n      int ndir2 = (dir2 + 3) % 4;\n      Push(nx, ny, ndir1, a, b, ndir2);\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    cin>>w>>h;\n    if(h == 0 && w == 0) return 0;\n    \n    mp.clear();\n    mp.resize(h);\n    cin>>mp;\n  \n    int sx,sy,gx,gy;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n        if(mp[i][j] == 'K') sx = j, sy = i;\n        if(mp[i][j] == 'M') gx = j, gy = i;\n      }\n\n    int ans = bfs(gx, gy, sx, sy);\n    if(ans != 2) ans = bfs(sx, sy, gx, gy, 1);\n    if(ans == 0) cout<<\"He cannot bring tea to his master.\"<<endl;\n    else if(ans == 1) cout<<\"He cannot return to the kitchen.\"<<endl;\n    else cout<<\"He can accomplish his mission.\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint change(int kx, int ky, int kv, int mx, int my, int mv){\n\tint ans = 0;\n\tans += kx;\n\tans <<= 4;\n\tans += ky;\n\tans <<= 2;\n\tans += kv;\n\tans <<= 6;\n\tans += mx;\n\tans <<= 4;\n\tans += my;\n\tans <<= 2;\n\tans += mv;\n\treturn ans;\n}\nint getkx(int n){\n\treturn (n >> 18) & (63);\n}\nint getky(int n){\n\treturn (n >> 14)&(15);\n}\nint getkv(int n){\n\treturn (n >> 12)&(3);\n}\nint getmx(int n){\n\treturn (n >> 6)&(63);\n}\nint getmy(int n){\n\treturn (n >> 2)&(15);\n}\nint getmv(int n){\n\treturn n & 3;\n}\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vs;\n\t\tint kx, ky;\n\t\tint mx, my;\n\t\tREP(i, H){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tvs.push_back(s);\n\t\t\tint k = s.find(\"K\");\n\t\t\tint m = s.find(\"M\");\n\t\t\tif (k != string::npos){\n\t\t\t\tkx = k;\n\t\t\t\tky = i;\n\t\t\t}\n\t\t\tif (m != string::npos){\n\t\t\t\tmx = m;\n\t\t\t\tmy = i;\n\t\t\t}\n\t\t}\n\t\tvector<int> vsh;\n\t\tREP(i, 4){\n\t\t\tif (vs[ky + dy[i]][kx + dx[i]] == '.'){\n\t\t\t\tREP(j, 4){\n\t\t\t\t\tif (vs[my + dy[j]][mx + dx[j]] == '.'){\n\t\t\t\t\t\tvsh.push_back(change(kx, ky, i, mx, my, j));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tbool clear = false;\n\t\tbool ktom = false;\n\t\twhile (1){\n\t\t\tint kx2 = getkx(vsh[count]);\n\t\t\tint ky2 = getky(vsh[count]);\n\t\t\tint kv2 = getkv(vsh[count]);\n\t\t\tint mx2 = getmx(vsh[count]);\n\t\t\tint my2 = getmy(vsh[count]);\n\t\t\tint mv2 = getmv(vsh[count]);\n\t\t\tif (kx2 == mx&&ky2 == my){\n\t\t\t\tktom = true;\n\t\t\t}\n\t\t\tif (kx2 == mx&&ky2 == my&&mx2 == kx&&my2 == ky){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (dx[kv2] != 0 && vs[ky2 + dy[kv2]][kx2 + dx[kv2]] != '#')kx2 += dx[kv2];\n\t\t\twhile (dy[kv2] != 0 && vs[ky2 + dy[kv2]][kx2 + dx[kv2]] != '#')ky2 += dy[kv2];\n\t\t\twhile (dx[mv2] != 0 && vs[my2 + dy[mv2]][mx2 + dx[mv2]] != '#')mx2 += dx[mv2];\n\t\t\twhile (dy[mv2] != 0 && vs[my2 + dy[mv2]][mx2 + dx[mv2]] != '#')my2 += dy[mv2];\n\t\t\t//if (ky2 + dy[kv2] >= 0 && ky2 + dy[kv2]<W&&mx2 + dx[mv2]>=0 && mx2 + dx[mv2]<=)\n\t\t\tREP(i, 2){\n\t\t\t\tint i2=-1;\n\t\t\t\tif (i == 1)i2 = 1;\n\t\t\t\tif (find(vsh.begin(), vsh.end(), change(kx2, ky2, (kv2 + i2 + 4) % 4, mx2, my2, (mv2 - i2 + 4) % 4)) == vsh.end())\n\t\t\t\t\tvsh.push_back(change(kx2, ky2, (kv2 + i2 + 4) % 4, mx2, my2, (mv2 - i2 + 4) % 4));\n\t\t\t}\n\t\t\tif (count + 1 == vsh.size())break;\n\t\t\t\tcount++;\n\t\t}\n\t\tif (!ktom&&!clear)cout <<\"He cannot bring tea to his master.\" << endl;\n\t\telse if (!ktom)cout << \"He cannot return to the kitchen.\" << endl;\n\t\telse cout << \"He can accomplish his mission.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int R   = 16;\nconst int C   = 64;\nconst int DIR = 4;\nbool vis[R][C][DIR][R][C][DIR]={false};\n\n\nmain(){\n  /*\n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\n    vis[i][j][k][ii][jj][kk]=false;\n  cout << vis[R-1][C-1][DIR-1][R-1][C-1][DIR-1] << endl;\n  */\n  \n  rep(i,R)rep(j,C)rep(k,DIR)\n    rep(ii,R)rep(jj,C)rep(kk,DIR)\ncout << vis[i][j][k][ii][jj][kk] <<\" \" << i <<\" \" << j <<\" \" << k <<\" \" << ii<<\" \" << jj <<\" \" << kk << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <string>\n#include <iostream>\n#include <cstdio>\n#include <stack>\nusing namespace std;\n\nint gen;\nint vis[1 << 24];\nint dpt[1<<24];\nchar ch[1<<24];\nqueue<int> q;\ninline void addq(int d2, int d1, int y2, int x2, int y1, int x1){\n\tint st = (d2 & 3) << 22 | (d1 & 3) << 20 | y2 << 16 | x2 << 10 |\n\t         y1 << 6 | x1;\n\tif(vis[st] != gen){\n\t\tvis[st] = gen;\n\t\tq.push(st);\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tint dy[] = {-1, 0, 1, 0};\n\tint dx[] = {0, -1, 0, 1};\n\tint h, w;\n\twhile(cin >> w >> h, h){\n\t\t++gen;\n\t\tvector<string> v(h);\n\t\tint kd = -1, ky = -1, kx = -1, md = -1, my = -1, mx = -1;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tif(v[i][j] == 'K'){\n\t\t\t\t\tfor(kd = 0; v[i + dy[kd]][j + dx[kd]] == '#'; ++kd);\n\t\t\t\t\tky = i;\n\t\t\t\t\tkx = j;\n\t\t\t\t}\n\t\t\t\telse if(v[i][j] == 'M'){\n\t\t\t\t\tfor(md = 0; v[i + dy[md]][j + dx[md]] == '#'; ++md);\n\t\t\t\t\tmy = i;\n\t\t\t\t\tmx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint d2 = kd, d1 = kd, y2 = ky, x2 = kx, y1 = ky, x1 = kx;\n\t\taddq(d2 + 1, d1, y2, x2, y1, x1);\n\t\taddq(d2 + 3, d1, y2, x2, y1, x1);\n\t\twhile(v[y2][x2] != '#'){\n\t\t\taddq(d2, d1, y2, x2, y1, x1);\n\t\t\ty2 += dy[d2];\n\t\t\tx2 += dx[d2];\n\t\t}\n\t\taddq(0, d1, 0, 0, y1, x1);\n\t\tint ans = 0;\n\t\twhile(!q.empty()){\n\t\t\tint st = q.front();\n\t\t\tq.pop();\n\n\t\t\td2 = st >> 22 & 3;\n\t\t\td1 = st >> 20 & 3;\n\t\t\ty2 = st >> 16 & 15;\n\t\t\tx2 = st >> 10 & 63;\n\t\t\ty1 = st >> 6 & 15;\n\t\t\tx1 = st & 63;\n\n\t\t\twhile(v[y1 + dy[d1]][x1 + dx[d1]] != '#'){\n\t\t\t\ty1 += dy[d1];\n\t\t\t\tx1 += dx[d1];\n\t\t\t}\n\n\t\t\tif(y1 == my && x1 == mx){\n\t\t\t\tans |= 1;\n\t\t\t\tif(y2 == my && x2 == mx && (d2 + 2 & 3) == md){\n\t\t\t\t\tans = 3;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(y2){\n\t\t\t\tif(v[y2 + dy[d2 + 1 & 3]][x2 + dx[d2 + 1 & 3]] == '#'){\n\t\t\t\t\tint ny2 = y2, nx2 = x2;\n\t\t\t\t\twhile(v[ny2][nx2] != '#'){\n\t\t\t\t\t\taddq(d2 + 3, d1 + 3, ny2, nx2, y1, x1);\n\t\t\t\t\t\tny2 += dy[d2 + 3 & 3];\n\t\t\t\t\t\tnx2 += dx[d2 + 3 & 3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(v[y2 + dy[d2 + 3 & 3]][x2 + dx[d2 + 3 & 3]] == '#'){\n\t\t\t\t\tint ny2 = y2, nx2 = x2;\n\t\t\t\t\twhile(v[ny2][nx2] != '#'){\n\t\t\t\t\t\taddq(d2 + 1, d1 + 1, ny2, nx2, y1, x1);\n\t\t\t\t\t\tny2 += dy[d2 + 1 & 3];\n\t\t\t\t\t\tnx2 += dx[d2 + 1 & 3];\n\t\t\t\t\t\tif(y1 == my && x1 == mx && ny2 == my && nx2 == mx && (d2 + 3 & 3) == md){\n\t\t\t\t\t\t\tans = 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\taddq(0, d1 + 1, 0, 0, y1, x1);\n\t\t\t\taddq(0, d1 + 3, 0, 0, y1, x1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ans == 3){\n\t\t\tputs(\"He can accomplish his mission.\");\n\t\t}\n\t\telse if(ans == 1){\n\t\t\tputs(\"He cannot return to the kitchen.\");\n\t\t}\n\t\telse{\n\t\t\tputs(\"He cannot bring tea to his master.\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n \n#pragma warning(disable : 4996)\n \nusing namespace std;\n \nint H, W;\n \nstring M[16];\n \nbool visited[16][64][4];\n \nbool visit2[16][64][4][16][64][4];\n \nconst int dx[4] = { 0, 1, 0, -1 };\nconst int dy[4] = { -1, 0, 1, 0 };\n \nvoid rec(int x, int y, int dir)\n{\n    if (!visited[y][x][dir])\n    {\n        visited[y][x][dir] = true;\n \n        while (M[y + dy[dir]][x + dx[dir]] != '#')\n        {\n            x += dx[dir];\n            y += dy[dir];\n        }\n \n        rec(x, y, (dir + 3) % 4);\n        rec(x, y, (dir + 1) % 4);\n    }\n}\n \nvoid rec2(int x1, int y1, int dir1, int x2, int y2, int dir2)\n{\n    if (!visit2[y1][x1][dir1][y2][x2][dir2])\n    {\n        visit2[y1][x1][dir1][y2][x2][dir2] = true;\n \n        while (M[y1 + dy[dir1]][x1 + dx[dir1]] != '#')\n        {\n            x1 += dx[dir1];\n            y1 += dy[dir1];\n        }\n \n        while (M[y2 + dy[dir2]][x2 + dx[dir2]] != '#')\n        {\n            x2 += dx[dir2];\n            y2 += dy[dir2];\n        }\n \n        rec2(x1, y1, (dir1 + 3) % 4, x2, y2, (dir2 + 1) % 4);\n        rec2(x1, y1, (dir1 + 1) % 4, x2, y2, (dir2 + 3) % 4);\n    }\n}\n \nint main()\n{\n    while (true)\n    {\n        scanf(\"%d\", &W);\n        scanf(\"%d\", &H);\n         \n        if (H == 0 && W == 0) break;\n \n        for (int i = 0; i < H; i++) cin >> M[i];\n \n        int sx, sy, sd, mx, my, md;\n \n        for (int i = 0; i < H; i++)\n        {\n            for (int j = 0; j < W; j++)\n            {\n                if (M[i][j] == 'K')\n                {\n                    sx = j;\n                    sy = i;\n \n                    for (int d = 0; d < 4; d++)\n                    {\n                        if (M[i + dy[d]][j + dx[d]] != '#')\n                        {\n                            sd = d;\n                        }\n                    }\n                }\n \n                if (M[i][j] == 'M')\n                {\n                    mx = j;\n                    my = i;\n \n                    for (int d = 0; d < 4; d++)\n                    {\n                        if (M[i + dy[d]][j + dx[d]] != '#')\n                        {\n                            md = d;\n                        }\n                    }\n                }\n            }\n        }\n \n        bool ok;\n \n        // 1st.\n \n        memset(visited, false, sizeof(visited));\n \n        rec(sx, sy, sd);\n \n        ok = false; for (int dir = 0; dir < 4; dir++) ok = ok || visited[my][mx][dir];\n \n        if (!ok)\n        {\n            printf(\"He cannot bring tea to his master.\\n\");\n        }\n        else\n        {\n            // 2nd.\n \n            memset(visit2, false, sizeof(visit2)); rec2(sx, sy, sd, mx, my, md);\n \n            ok = false;\n             \n            for (int dir1 = 0; dir1 < 4; dir1++)\n            {\n                for (int dir2 = 0; dir2 < 4; dir2++)\n                {\n                    ok = ok || visit2[my][mx][dir1][sy][sx][dir2];\n                }\n            }\n \n            if (!ok)\n            {\n                printf(\"He cannot return to the kitchen.\\n\");\n            }\n            else\n            {\n                printf(\"He can accomplish his mission.\\n\");\n            }\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint W, H;\nbool wall[16][64];\nP to[16][64][4];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\nint rot[2] = {-1, 1};\n\nbool reached[16][64][16][64][4][4];\n\nstruct Node {\n\tint x1, y1, x2, y2, d1, d2;\n};\nstruct SingleNode {\n\tint x, y, d;\n};\n\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nint main() {\n\twhile ( cin >> W >> H, W || H ) {\n\t\tfill(wall[0], wall[16], false);\n\t\tint sx, sy, gx, gy;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tswitch (str[x]) {\n\t\t\t\t\tcase '.': break;\n\t\t\t\t\tcase '#': wall[y][x] = true; break;\n\t\t\t\t\tcase 'K': sx = x, sy = y; break;\n\t\t\t\t\tcase 'M': gx = x, gy = y; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int t = 0; t < W+H; ++t) {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\t\tif (t == 0) {\n\t\t\t\t\t\t\tint nx = x + dx[d];\n\t\t\t\t\t\t\tint ny = y + dy[d];\n\t\t\t\t\t\t\tif ( inRange(nx, ny) && !wall[ny][nx] ) {\n\t\t\t\t\t\t\t\tto[y][x][d] = P(nx, ny);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tto[y][x][d] = P(x, y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tP np = to[y][x][d];\n\t\t\t\t\t\t\tint nx = np.first, ny = np.second;\n\t\t\t\t\t\t\tto[y][x][d] = to[ny][nx][d];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill(&reached[0][0][0][0][0][0], &reached[0][0][0][0][0][0] + 16*64*16*64*4*4, false);\n\n\t\tSingleNode G[16][64][4][2];\n\t\tvector<SingleNode> rG[16][64][4][2];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\tfor (int dd = 0; dd < 2; ++dd) {\n\t\t\t\t\t\tint xx = x+dx[d], yy = y+dy[d];\n\t\t\t\t\t\tif ( wall[y][x] || (inRange(xx, yy) && !wall[yy][xx]) ) {\n\t\t\t\t\t\t\tG[y][x][d][dd] = (SingleNode){-1, -1, -1};\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint nd = (d + rot[dd] + 4) % 4;\n\t\t\t\t\t\t\tP np = to[y][x][nd];\n\t\t\t\t\t\t\tG[y][x][d][dd] = (SingleNode){np.first, np.second, nd};\n\t\t\t\t\t\t\trG[np.second][np.first][nd][dd].push_back( (SingleNode){x, y, d} );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<Node> Q;\n\t\tint sx2, sy2, gx2, gy2, sd;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint x = gx + dx[i];\n\t\t\tint y = gy + dy[i];\n\t\t\tif ( inRange(x, y) && !wall[y][x] ) {\n\t\t\t\tP p = to[gy][gx][i];\n\t\t\t\tgx2 = p.first;\n\t\t\t\tgy2 = p.second;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint x = sx + dx[i];\n\t\t\tint y = sy + dy[i];\n\t\t\tif ( inRange(x, y) && !wall[y][x] ) {\n\t\t\t\tP p = to[sy][sx][i];\n\t\t\t\tsx2 = p.first;\n\t\t\t\tsy2 = p.second;\n\t\t\t\tsd = i;\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n//\t\t\t\t\tcout << sx2 << \" \" << sy2 << \" \" << sx << \" \" << sy << endl;\n\t\t\t\t\treached[sy2][sx2][sy][sx][i][j] = true;\n\t\t\t\t\tQ.push( (Node){sx2, sy2, sx, sy, i, j} );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n/*\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tint snx = sx + dx[i];\n\t\t\t\tint sny = sy + dy[i];\n\t\t\t\tint gnx = gx + dx[i];\n\t\t\t\tint gny = gy + dy[i];\n\t\t\t\tif ( inRange(snx, sny) && !wall[sny][snx] && (!inRange(gnx, gny) || wall[gny][gnx]) ) {\n\t\t\t\t\treached[sy][sx][sy][sx][i][j] = true;\n\t\t\t\t\tQ.push( (Node){sx, sy, sx, sy, i, j} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n*/\n\t\tint ans = 0;\n/*\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tcout << (wall[y][x] ? \"#\" : \".\");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.front(); Q.pop();\n\t\t\tint x1 = node.x1;\n\t\t\tint y1 = node.y1;\n\t\t\tint x2 = node.x2;\n\t\t\tint y2 = node.y2;\n\t\t\tint d1 = node.d1;\n\t\t\tint d2 = node.d2;\n\t\t\tif (x1 == gx && y1 == gy) {\n\t\t\t\tif (x2 == gx2 && y2 == gy2) {\n\t\t\t\t\tans = max(ans, 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans = max(ans, 1);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << d1 << \" \" << d2 << endl;\n\t\t\tfor (int dd = 0; dd < 2; ++dd) {\n\t\t\t\tSingleNode& next1 = G[y1][x1][d1][dd];\n//\t\t\t\tcout << y2 << \" \" << x2 << \" \" << d2 << \" \" << dd << endl;\n\t\t\t\tassert( !wall[y1][x1] );\n\t\t\t\tassert( !wall[y2][x2] );\n//\t\t\t\tassert( rG[y2][x2][d2][!dd].size() > 0 );\n\t\t\t\tfor (int i = 0; i < rG[y2][x2][d2][!dd].size(); ++i) {\n\t\t\t\t\tSingleNode& next2 = rG[y2][x2][d2][!dd][i];\n\t\t\t\t\tif ( !reached[next1.y][next1.x][next2.y][next2.x][next1.d][next2.d] ) {\n\t\t\t\t\t\treached[next1.y][next1.x][next2.y][next2.x][next1.d][next2.d] = true;\n\t\t\t\t\t\tQ.push( (Node){next1.x, next1.y, next2.x, next2.y, next1.d, next2.d} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == 0) {\n\t\t\tbool used[16][64][4] = {0};\n\t\t\tqueue<SingleNode> Q2; Q2.push({sx2, sy2, sd}); used[sy2][sx2][sd] = true;\n\t\t\twhile ( !Q2.empty() ) {\n\t\t\t\tSingleNode node = Q2.front(); Q2.pop();\n\t\t\t\tint x = node.x, y = node.y, d = node.d;\n\t\t\t\tif (x == gx && y == gy) {\n\t\t\t\t\tans = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int dd = 0; dd < 2; ++dd) {\n\t\t\t\t\tSingleNode& next = G[y][x][d][dd];\n\t\t\t\t\tif ( !used[next.y][next.x][next.d] ) {\n\t\t\t\t\t\tused[next.y][next.x][next.d] = true;\n\t\t\t\t\t\tQ2.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ans == 0) {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t\telse if (ans == 1) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\nusing namespace std;\n\nint dx[7] = { -1,0,1,0,-1,0,1 };\nint dy[7] = { 0,1,0,-1,0,1,0 };\n\nbool memo[64][16][4][64][16][4];\n\n\nvector <vector<bool>>mp;\n\nstruct aa {\n\tint fx;\n\tint fy;\n\tint fway;\n\tint tx;\n\tint ty;\n\tint tway;\n};\nint gx, gy;\n\nvector<aa>astack;\n\nbool cangoal;\n\nint gway;\n\nbool check(int fx, int fy,int fway, int tx, int ty, int tway) {\n\n\tif (memo[fx][fy][fway][tx][ty][tway])return false;\n\tmemo[fx][fy][fway][tx][ty][tway] =true;\n\t\n\t//else{\n\n\t\tint nfy = fy + dy[fway];\n\t\tint nfx = fx + dx[fway];\n\t\twhile (1) {\n\t\t\t\n\t\t\tif (mp[nfy][nfx]) {\n\t\t\t\tnfx -= dx[fway];\n\t\t\t\tnfy -= dy[fway];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnfy = nfy + dy[fway];\n\t\t\tnfx = nfx + dx[fway];\n\n\t\t}\n\n\t\tint nty = ty;\n\t\tint ntx = tx;\n\t\twhile (1) {\n\n\t\t\tif (mp[nty][ntx]) {\n\t\t\t\tntx -= dx[tway];\n\t\t\t\tnty -= dy[tway];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\t\tint afway = (fway + 3) % 4;\n\t\t\t\tint atway = (tway + 3) % 4;\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\t\tcangoal = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\t\tint afway = (fway + 1) % 4;\n\t\t\t\tint atway = (tway + 1) % 4;\n\t\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\t\tcangoal = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnty = nty + dy[tway];\n\t\t\tntx = ntx + dx[tway];\n\t\t}\n\t\tif (mp[nty + dy[tway + 1]][ntx + dx[tway + 1]]) {\n\t\t\tint afway = (fway + 3) % 4;\n\t\t\tint atway = (tway + 3) % 4;\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\n\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\t\t\t}\n\t\t}\n\n\t\tif (mp[nty + dy[tway + 3]][ntx + dx[tway + 3]]) {\n\t\t\tint atway = (tway + 1) % 4;\n\t\t\tint afway = (fway + 1) % 4;\n\n\t\t\tif (!memo[nfx][nfy][afway][ntx][nty][atway]) {\n\t\t\t\tif (nfx == gx&&nfy == gy&&ntx == gx&&nty == gy) {\n\t\t\t\t\tif (tway == (gway + 2) % 4)\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse if (fx == gx&&fy == gy) {\n\t\t\t\t\tcangoal = true;\n\t\t\t\t}\t\t\n\t\t\t\tastack.push_back(aa{ nfx,nfy,afway,ntx,nty,atway });\n\n\t\t\t}\n\t\t}\n\n\t//}\n\treturn false;\n}\n\nint main() {\n\twhile (1) {\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tastack.clear();\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<string>stmp;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tstmp.push_back(st);\n\t\t}\n\t\tmp.resize(H);\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tmp[i].resize(W);\n\t\t}\n\n\t\tint sx, sy;\n\n\t\tfor (int i = 0; i < W; ++i) {\n\t\t\tfor (int j = 0; j < H; ++j) {\n\t\t\t\tif (stmp[j][i] == '.') {\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == '#') {\n\t\t\t\t\tmp[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (stmp[j][i] == 'K') {\n\t\t\t\t\tsx = i; sy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgx = i; gy = j;\n\t\t\t\t\tmp[j][i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sway;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (mp[sy + dy[i]][sx + dx[i]] == 0) {\n\t\t\t\tsway = i;\n\t\t\t}\n\t\t\tif (mp[gy + dy[i]][gx + dx[i]] == 0) {\n\t\t\t\tgway = i;\n\t\t\t}\n\t\t}\n\t\tbool perf = false;\n\t\tfor (int i = 0; i < 4;++i)\n\t\t\tastack.push_back(aa{ sx,sy,sway,sx,sy,i });\n\n\t\twhile (!astack.empty()) {\n\t\t\taa atop(astack.back());\n\t\t\tastack.pop_back();\n\t\t\tif (check(atop.fx, atop.fy,atop.fway, atop.tx, atop.ty, atop.tway)) {\n\t\t\t\tperf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (perf) {\n\t\t\tcout << \"He can accomplish his mission.\" << endl;\n\t\t}\n\t\telse if (cangoal) {\n\t\t\tcout << \"He cannot return to the kitchen.\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"He cannot bring tea to his master.\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing vi=vector<bool>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vvvvvi=vector<vvvvi>;\nusing vvvvvvi=vector<vvvvvi>;\n\nstruct State{\n    int hk,wk;\n    int hm,wm;\n    int dirk,dirm;\n};\n\nint dh[]={-1,0,1,0};\nint dw[]={0,1,0,-1};\nint w,h;\nint solve();\nint main(){\n    while(cin>>w>>h,w){\n        solve();\n    }\n}\nint solve(){\n\n    vector<string> f(h);\n    for(int i=0;i<h;i++){\n        cin>>f[i];\n    }        \n    \n    int ini_hk=-1,ini_wk=-1,ini_dirk=-1;\n    int ini_hm=-1,ini_wm=-1,ini_dirm=1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='K'){\n                ini_hk=i;\n                ini_wk=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirk=k;\n                    }\n                }\n            }\n            if(f[i][j]=='M'){\n                ini_hm=i;\n                ini_wm=j;\n                for(int k=0;k<4;k++){\n                    if(f[i+dh[k]][j+dw[k]]!='#'){\n                        ini_dirm=k;\n                    }\n                }\n            }\n        }\n    }\n    /*\n    cout<<ini_hk<<\" \"<<ini_wk<<\" \"<<ini_dirk<<endl;\n    cout<<ini_hm<<\" \"<<ini_wm<<\" \"<<ini_dirm<<endl;\n    */\n    vvvvvvi dp(h,vvvvvi(w,vvvvi(h,vvvi(w,vvi(4,(vi(4,false)))))));\n    dp[ini_hk][ini_wk][ini_hm][ini_wm][ini_dirk][ini_dirm]=true;\n    queue<State> que;\n    que.push(State{ini_hk,ini_wk,ini_hm,ini_wm,ini_dirk,ini_dirm});\n    \n    while(!que.empty()){\n        auto st=que.front();\n        que.pop();\n        \n        int hk=st.hk,wk=st.wk,dk=st.dirk;\n        int hm=st.hm,wm=st.wm,dm=st.dirm;\n        power_play:\n        /*\n        cout<<hk<<\" \"<<wk<<\" \"<<dk<<endl;\n        cout<<hm<<\" \"<<wm<<\" \"<<dm<<endl;\n        */\n        int tohk=hk+dh[dk],towk=wk+dw[dk];\n        //cout<<tohk<<\" \"<<towk<<endl;\n        int tohm=hm+dh[dm],towm=wm+dw[dm];\n        //cout<<tohm<<\" \"<<towm<<endl;\n        char tokf=f[tohk][towk];\n        char tomf=f[tohm][towm];\n        if(tokf=='#' && tomf=='#'){\n            int todk=(dk+1)%4;\n            int todm=(dm+3)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n            todk=(dk+3)%4;\n            todm=(dm+1)%4;\n            if(!dp[hk][wk][hm][wm][todk][todm]){\n                dp[hk][wk][hm][wm][todk][todm]=true;\n                que.push(State{hk,wk,hm,wm,todk,todm});\n            }\n        }\n        else if(tokf=='#'){\n            hm=tohm;\n            wm=towm;\n            goto power_play;\n        }\n        else if(tomf=='#'){\n            hk=tohk;\n            wk=towk;\n            goto power_play;\n        }\n        else{\n            \n            if(!dp[tohk][towk][tohm][towm][dk][dm]){\n                dp[tohk][towk][tohm][towm][dk][dm]=true;\n                que.push(State{tohk,towk,tohm,towm,dk,dm});\n            }\n        }\n        \n    }\n    bool two_way=false;\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(i!=ini_dirk && j!=ini_dirm){\n                two_way|=dp[ini_hm][ini_wm][ini_hk][ini_wk][i][j];\n            }\n        }\n    }\n\n    bool one_way=false;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            for(int ki=0;ki<4;ki++){\n                for(int kj=0;kj<4;kj++){\n                    if(ki!=ini_dirk && kj!=ini_dirm){\n                        one_way|=dp[ini_hm][ini_wm][i][j][ki][kj];\n                    }\n                }\n            }\n        }\n    }\n    if(two_way){\n        cout<<\"He can accomplish his mission.\"<<endl;\n    }\n    else if(one_way){   \n        cout<<\"He cannot return to the kitchen.\"<<endl;\n    }\n    else{        \n        cout<<\"He cannot bring tea to his master.\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\nusing namespace std;\nusing P = pair<int, int>;\nusing PP = pair<P, int>;\nint W, H;\nint sy, sx, sd;\nint gy, gx, gd;\nbool field[16][64];\nbool used[16][64][4][16][64][4];\nbool used2[16][64][4];\n\nvoid init()\n{\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 64; j++) {\n            for (int k = 0; k < 4; k++) {\n                for (int l = 0; l < 16; l++) {\n                    for (int m = 0; m < 64; m++) {\n                        for (int n = 0; n < 4; n++) {\n                            used[i][j][k][l][m][n] = false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nP front(const int y, const int x, const int d)\n{\n    if (d == 0) {\n        int Y = y;\n        for (; field[Y - 1][x]; Y--) {\n        }\n        return {Y, x};\n    } else if (d == 1) {\n        int X = x;\n        for (; field[y][X + 1]; X++) {\n        }\n        return {y, X};\n    } else if (d == 2) {\n        int Y = y;\n        for (; field[Y + 1][x]; Y++) {\n        }\n        return {Y, x};\n    } else {\n        int X = x;\n        for (; field[y][X - 1]; X--) {\n        }\n        return {y, X};\n    }\n}\n\nvector<PP> back(const int y, const int x, const int d)\n{\n    vector<PP> ans;\n    constexpr int R = 1;\n    constexpr int L = 3;\n    if (d == 0) {\n        int Y = y;\n        for (; field[Y][x]; Y--) {\n            if (not field[Y][x + 1]) {\n                ans.push_back({{Y, x}, L});\n            } else if (not field[Y][x - 1]) {\n                ans.push_back({{Y, x}, R});\n            }\n        }\n    } else if (d == 1) {\n        int X = x;\n        for (; field[y][X]; X++) {\n            if (not field[y + 1][X]) {\n                ans.push_back({{y, X}, L});\n            } else if (not field[y - 1][X]) {\n                ans.push_back({{y, X}, R});\n            }\n        }\n    } else if (d == 2) {\n        int Y = y;\n        for (; field[Y][x]; Y++) {\n            if (not field[Y][x + 1]) {\n                ans.push_back({{Y, x}, R});\n            } else if (not field[Y][x - 1]) {\n                ans.push_back({{Y, x}, L});\n            }\n        }\n    } else {\n        int X = x;\n        for (; field[y][X]; X--) {\n            if (not field[y + 1][X]) {\n                ans.push_back({{y, X}, R});\n            } else if (not field[y - 1][X]) {\n                ans.push_back({{y, X}, L});\n            }\n        }\n    }\n    return ans;\n}\n\nbool dfs(int fy, int fx, int fd, int by, int bx, int bd)\n{\n    if (fy == gy and fx == gx and by == gy and bx == gx) {\n        return true;\n    } else if (by == gy and bx == gx and bd == gd) {\n        return false;\n    }\n\n    tie(fy, fx) = front(fy, fx, fd);\n    vector<PP> cand = back(by, bx, bd);\n    for (const auto& next : cand) {\n        const int div = next.second;\n        by = next.first.first;\n        bx = next.first.second;\n        const int newfd = (fd + div) % 4;\n        const int newbd = (bd + div) % 4;\n        if (not used[fy][fx][newfd][by][bx][newbd]) {\n            used[fy][fx][newfd][by][bx][newbd] = true;\n            const bool sub = dfs(fy, fx, newfd, by, bx, newbd);\n            if (sub) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool dfs(int fy, int fx, int fd)\n{\n    if (fy == gy and fx == gx) {\n        return true;\n    }\n    tie(fy, fx) = front(fy, fx, fd);\n    for (int i = -1; i <= 1; i += 2) {\n        const int nd = (fd + i + 4) % 4;\n        if (not used2[fy][fx][nd]) {\n            used2[fy][fx][nd] = true;\n            if (dfs(fy, fx, nd)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while (true) {\n        cin >> W >> H;\n        if (W == 0 and H == 0) {\n            break;\n        }\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c;\n                cin >> c;\n                field[i][j] = c != '#';\n                if (c == 'K') {\n                    sy = i;\n                    sx = j;\n                } else if (c == 'M') {\n                    gy = i;\n                    gx = j;\n                }\n            }\n        }\n        constexpr int dx[] = {0, 1, 0, -1};\n        constexpr int dy[] = {-1, 0, 1, 0};\n        for (int i = 0; i < 4; i++) {\n            if (field[sy + dy[i]][sx + dx[i]]) {\n                sd = i;\n                break;\n            }\n        }\n        for (int i = 0; i < 4; i++) {\n            if (field[gy + dy[i]][gx + dx[i]]) {\n                gd = i;\n                break;\n            }\n        }\n        gd = (gd + 2) % 4;\n        bool ans = false;\n        for (int d = 0; d < 4; d++) {\n            if (d > 0) {\n                init();\n            }\n            used[sy][sx][sd][sy][sx][d] = true;\n            if (dfs(sy, sx, sd, sy, sx, d)) {\n                ans = true;\n                break;\n            }\n        }\n        if (ans) {\n            cout << \"He can accomplish his mission.\" << endl;\n        } else {\n            for (int i = 0; i < 16; i++) {\n                for (int j = 0; j < 64; j++) {\n                    for (int k = 0; k < 4; k++) {\n                        used2[i][j][k] = false;\n                    }\n                }\n            }\n            used2[sy][sx][sd] = true;\n            if (dfs(sy, sx, sd)) {\n                cout << \"He cannot return to the kitchen.\" << endl;\n            } else {\n                cout << \"He cannot bring tea to his master.\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <queue>\n#include <set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    int x, y, d;\n    S() {}\n    S(int x, int y, int d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const pair<S, S>& p) {\n    return (sig(p.first) << 16) | sig(p.second);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { \\\n    const int si = sig(s); \\\n    if (!vis.count(si)) vis.insert(si), q.push(s); \\\n}\n\nbool reach(const S& s, const S& t) {\n    set<int> vis;\n    queue<S> q;\n    const S st = forward(s.x, s.y, s.d);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == t.x && cur.y == t.y) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, set<int>& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish(const S& s, const S& t) {\n    set<int> vis;\n    queue<pair<S, S> > q;\n    const S st = forward(s.x, s.y, s.d);\n    rep (d, 4) push(q, vis, st, s.x, s.y, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == t.x && cur.y == t.y\n                && rev.x == t.x && rev.y == t.y && rev.d == t.d) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    S s(-1, -1, -1), t(-1, -1, -1);\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        s.x = i, s.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') s.d = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        t.x = i, t.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') t.d = d;\n    }\n    if (!reach(s, t)) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish(s, t)) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2017 Karakuri Doll\n// 2018.3.16 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 300000\ntypedef struct { char r1, c1, d1, r2, c2, d2; } Q;\nQ q[QMAX + 5]; int top, end;\nint H, W, SR, SC, SD, GR, GC, GD;     // (r,c) dir\nchar map[16][66];\nchar visited[17][65][5][17][65][5];   // r1,c1,d1 r2,c2,d2\nint mv[4][2] = { {-1,0},{0,1},{1,0},{0,-1} };\n#define L(d) ((d+3)%4)\n#define R(d) ((d+1)%4)\nint ans;\n\nvoid enq(int r1, int c1, int d1, int r2, int c2, int d2, int _d2)\n{\n\tif (r1 == GR && c1 == GC) {\n\t\tans = 1;\n\t\tif (r2 == GR && c2 == GC && _d2 == GD) { ans = 2; return; }\n\t}\n\tif (visited[r1][c1][d1][r2][c2][d2]) return;\n\tvisited[r1][c1][d1][r2][c2][d2] = 1;\n\n\tq[end].r1 = r1, q[end].c1 = c1, q[end].d1 = d1;\n\tq[end].r2 = r2, q[end].c2 = c2, q[end].d2 = d2;\n\t++end;\n}\n\nint bfs()\n{\n\tint r1, c1, d1, r2, c2, d2;\n\n\tmemset(visited, 0, sizeof(visited));\n\tans = 0, top = end = 0;\n\tfor (d2 = 0; d2 < 4; d2++) enq(SR, SC, SD, SR, SC, d2, 4);\n\n\twhile (top != end && ans != 2) {\n\t\tr1 = q[top].r1, c1 = q[top].c1, d1 = q[top].d1;\n\t\tr2 = q[top].r2, c2 = q[top].c2, d2 = q[top].d2;\n\t\t++top;\n\n\t\twhile (map[r1 + mv[d1][0]][c1 + mv[d1][1]] != '#')\n\t\t\tr1 += mv[d1][0], c1 += mv[d1][1];\n\t\tenq(r1, c1, L(d1), H, W, 4, 4);\n\t\tenq(r1, c1, R(d1), H, W, 4, 4);\n\n\t\tif (d2 < 4) while (map[r2][c2] != '#') {\n\t\t\tif (map[r2 + mv[L(d2)][0]][c2 + mv[L(d2)][1]] == '#')\n\t\t\t\tenq(r1, c1, L(d1), r2, c2, L(d2), d2);\n\t\t\tif (map[r2 + mv[R(d2)][0]][c2 + mv[R(d2)][1]] == '#')\n\t\t\t\tenq(r1, c1, R(d1), r2, c2, R(d2), d2);\n\t\t\tr2 -= mv[d2][0], c2 -= mv[d2][1];\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint r, c;\n\tstatic char *msg[3] = { \"He cannot bring tea to his master.\",\n\t\t\t\t\t\t\t\"He cannot return to the kitchen.\",\n\t\t\t\t\t\t\t\"He can accomplish his mission.\" };\n\n\twhile (scanf(\"%d%d\", &W, &H) && (W | H)) {\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < W; c++) {\n\t\t\t\tif (map[r][c] == 'K') SR = r, SC = c;\n\t\t\t\telse if (map[r][c] == 'M') GR = r, GC = c;\n\t\t\t}\n\t\t}\n\t\tfor (SD = 0; ; SD++) {\n\t\t\tr = SR + mv[SD][0], c = SC + mv[SD][1];\n\t\t\tif (map[r][c] != '#') break;\n\t\t}\n\t\tfor (GD = 0; ; GD++) {\n\t\t\tr = GR + mv[GD][0], c = GC + mv[GD][1];\n\t\t\tif (map[r][c] != '#') break;\n\t\t}\n\t\tprintf(\"%s\\n\", msg[bfs()]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <queue>\n#include <unordered_set>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nstruct S {\n    unsigned x, y, d;\n    S() {}\n    S(unsigned x, unsigned y, unsigned d) : x(x), y(y), d(d) {}\n};\n\ninline int sig(const S& s) {\n    return (s.x<<8) | (s.y<<2) | s.d;\n}\n\ninline int sig(const pair<S, S>& p) {\n    return (sig(p.first) << 16) | sig(p.second);\n}\n\nbool operator<(const S& l, const S& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.d < r.d;\n}\n\nint H, W;\nchar f[16][64];\n\nS forward(int x, int y, int d) {\n    for (;;) {\n        const int nx = x + dx[d], ny = y + dy[d];\n        if (f[nx][ny] == '#') return S(x, y, d);\n        x = nx, y = ny;\n    }\n}\n\n#define PUSH(q, vis, s) { \\\n    const int si = sig(s); \\\n    if (!vis.count(si)) vis.insert(si), q.push(s); \\\n}\n\nbool reach(const S& s, const S& t) {\n    unordered_set<int> vis;\n    queue<S> q;\n    const S st = forward(s.x, s.y, s.d);\n    PUSH(q, vis, st);\n    while (!q.empty()) {\n        const S cur = q.front();\n        q.pop();\n        if (cur.x == t.x && cur.y == t.y) return true;\n        int dd = 1;\n        rep (_, 2) {\n            const S p = forward(cur.x, cur.y, (cur.d+dd)%4);\n            PUSH(q, vis, p);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid push(queue<pair<S, S> >& q, unordered_set<int>& vis, const S& l, int x, int y, int d) {\n    const int rd = (d+2) % 4;\n    if (f[x+dx[d]][y+dy[d]] != '#') return ;\n    for (;;) {\n        const pair<S, S> ss(l, S(x, y, d));\n        PUSH(q, vis, ss);\n        const int nx = x + dx[rd], ny = y + dy[rd];\n        if (f[nx][ny] == '#') break;\n        x = nx, y = ny;\n    }\n}\n\nbool accomplish(const S& s, const S& t) {\n    unordered_set<int> vis;\n    queue<pair<S, S> > q;\n    const S st = forward(s.x, s.y, s.d);\n    rep (d, 4) push(q, vis, st, s.x, s.y, d);\n    while (!q.empty()) {\n        const pair<S, S> vv = q.front();\n        q.pop();\n        const S cur = vv.first, rev = vv.second;\n        if (cur.x == t.x && cur.y == t.y\n                && rev.x == t.x && rev.y == t.y && rev.d == t.d) {\n            return true;\n        }\n        int dd = 1;\n        rep (_, 2) {\n            push(q, vis, forward(cur.x, cur.y, (cur.d+dd)%4),\n                    rev.x, rev.y, (rev.d+dd)%4);\n            dd += 2;\n        }\n    }\n    return false;\n}\n\nvoid solve() {\n    S s(-1, -1, -1), t(-1, -1, -1);\n    rep (i, H) rep (j, W) if (f[i][j] == 'K') {\n        f[i][j] = '.';\n        s.x = i, s.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') s.d = d;\n    }\n    rep (i, H) rep (j, W) if (f[i][j] == 'M') {\n        f[i][j] = '.';\n        t.x = i, t.y = j;\n        rep (d, 4) if (f[i+dx[d]][j+dy[d]] != '#') t.d = d;\n    }\n    if (!reach(s, t)) puts(\"He cannot bring tea to his master.\");\n    else if (!accomplish(s, t)) puts(\"He cannot return to the kitchen.\");\n    else puts(\"He can accomplish his mission.\");\n}\n\nint main() {\n    for (;;) {\n        scanf(\"%d%d\", &W, &H);\n        if (H == 0) return 0;\n        rep (i, H) rep (j, W) scanf(\" %c\", f[i]+j);\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tboolean[][][][][][] vis = new boolean[H][W][4][H][W][4];\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tvis[gh][gw][i][gh][gw][j] = true;\n\t\t\t\t\t\t\tvis[p1.h][p1.w][i][p2.h][p2.w][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (vis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tvis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2] = true;\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n\n\tint w, h; //yoko tate\n\tString[] board;\n\n\tint kx,ky;\n\tint mx,my;\n\n\tvoid solve(){\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true)\n\t\t{\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w==0 && h==0) return;\n\t\t\tboard = new String[h];\n\t\t\tfor(int i=0;i<h;i++) board[i] = cin.next();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(board[i].charAt(j)=='K'){\n\t\t\t\t\t\tky = i;\n\t\t\t\t\t\tkx = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if(board[i].charAt(j)=='M'){\n\t\t\t\t\t\tmy = i;\n\t\t\t\t\t\tmx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = bfs(ky,kx,my,mx);\n\t\t\tif(ret == 0){\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t\telse if(ret == 1){\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean[][][][][][] dp;\n\tint[] vy = new int[]{1,0,-1,0};\n\tint[] vx = new int[]{0,1,0,-1};\n\n\tint[] next = new int[]{1,3}; //1(left) and -1(right)\n\n\tint bfs(int sy, int sx, int gy, int gx){\n\t\tdp = new boolean[h][w][h][w][4][4];\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tint sk = 0;\n\t\tint gk = 0;\n\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(board[sy+vy[k]].charAt(sx+vx[k])!='#') sk = k;\n\t\t\tif(board[gy+vy[k]].charAt(gx+vx[k])!='#') gk = k;\n\t\t}\n\t\tfor(int k2=0;k2<4;k2++){\n\t\t\tq.add(encode(sy,sx,sy,sx,sk,k2));\n\t\t\tdp[sy][sx][sy][sx][sk][k2] = true;\n\t\t}\n\n\t\tint ret = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] now = decode(q.poll());\n\t\t\tint y1 = now[0];\n\t\t\tint x1 = now[1];\n\t\t\tint y2 = now[2];\n\t\t\tint x2 = now[3];\n\t\t\tint k = now[4];\n\t\t\tint k2 = now[5];\n\t\t\t//if(x1!=5 && x2!=5 && x2!=0) System.out.println(y1 + \" \" + x1 + \" \" + y2 + \" \" + x2 + \" \" + k);\n\t\t\twhile(board[y1 + vy[k]].charAt(x1 + vx[k]) != '#'){\n\t\t\t\ty1 += vy[k];\n\t\t\t\tx1 += vx[k];\n\t\t\t}\n\t\t\tif(true){\n\t\t\t\tif(y1==gy && x1 == gx){\n\t\t\t\t\tret = 1;\n\t\t\t\t}\n\t\t\t\tfor(int vk : next){\n\t\t\t\t\tint nk = (k + vk) % 4;\n\t\t\t\t\tint nk2 = (k2+vk)%4;\n\t\t\t\t\tif(!dp[y1][x1][0][0][nk][nk2]){\n\t\t\t\t\t\tq.add(encode(y1,x1,0,0,nk,nk2));\n\t\t\t\t\t\tdp[y1][x1][0][0][nk][nk2] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y2!=0){\n\t\t\t\tdo{\n\t\t\t\t\tfor(int vk : next){\n\t\t\t\t\t\tint nk = (k + vk) % 4;\n\t\t\t\t\t\tint nk2 = (k2 + vk)%4;\n\t\t\t\t\t\tif(board[y2+vy[(nk2+2)%4]].charAt(x2+vx[(nk2+2)%4])!='#') continue;\n\n\t\t\t\t\t\tif(y1==gy && x1==gx){\n\t\t\t\t\t\t\tif(y2==gy && x2==gx){\n\t\t\t\t\t\t\t\tif(k2==(gk+2)%4)return 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!dp[y1][x1][y2][x2][nk][nk2]){\n\t\t\t\t\t\t\tq.add(encode(y1,x1,y2,x2,nk,nk2));\n\t\t\t\t\t\t\tdp[y1][x1][y2][x2][nk][nk2] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty2 += vy[k2];\n\t\t\t\t\tx2 += vx[k2];\n\t\t\t\t}while(board[y2].charAt(x2) != '#');\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint encode(int y1, int x1, int y2, int x2, int k, int k2){\n\t\tint ret = 0;\n\t\tret += y1;\n\t\tret *= w;\n\t\tret += x1;\n\t\tret *= h;\n\t\tret += y2;\n\t\tret *= w;\n\t\tret += x2;\n\t\tret *= 4;\n\t\tret += k;\n\t\tret *= 4;\n\t\tret += k2;\n\t\treturn ret;\n\t}\n\n\tint[] decode(int hash){\n\t\tint[] ret = new int[6];\n\t\tret[5] = hash % 4;\n\t\thash /= 4;\n\t\tret[4] = hash % 4;\n\t\thash /= 4;\n\t\tret[3] = hash % w;\n\t\thash /= w;\n\t\tret[2] = hash % h;\n\t\thash /= h;\n\t\tret[1] = hash % w;\n\t\thash /= w;\n\t\tret[0] = hash;\n\t\treturn ret;\n\t}\n\n\n\n\tpublic static void main(String[] args){\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tSystem.gc();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tSystem.gc();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tSystem.gc();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tboolean[][][][][][] vis = new boolean[H][W][4][H][W][4];\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tvis[gh][gw][i][gh][gw][j] = true;\n\t\t\t\t\t\t\tvis[p1.h][p1.w][i][p2.h][p2.w][j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (vis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2])\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tvis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2] = true;\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\t// boolean[][][][][][] vis = new boolean[H][W][4][H][W][4];\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\t// vis[gh][gw][i][gh][gw][j] = true;\n\t\t\t\t\t\t\t// vis[p1.h][p1.w][i][p2.h][p2.w][j] = true;\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\t// if (vis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2])\n\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\t// vis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2] = true;\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tSystem.gc();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n\n\tint w, h; //yoko tate\n\tString[] board;\n\n\tint kx,ky;\n\tint mx,my;\n\n\tvoid solve(){\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true)\n\t\t{\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w==0 && h==0) return;\n\t\t\tboard = new String[h];\n\t\t\tfor(int i=0;i<h;i++) board[i] = cin.next();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(board[i].charAt(j)=='K'){\n\t\t\t\t\t\tky = i;\n\t\t\t\t\t\tkx = j;\n\t\t\t\t\t}\n\t\t\t\t\telse if(board[i].charAt(j)=='M'){\n\t\t\t\t\t\tmy = i;\n\t\t\t\t\t\tmx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = bfs(ky,kx,my,mx);\n\t\t\tif(ret == 0){\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t\telse if(ret == 1){\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tHashSet<Integer> hs;\n\tint[] vy = new int[]{1,0,-1,0};\n\tint[] vx = new int[]{0,1,0,-1};\n\n\tint[] next = new int[]{1,3}; //1(left) and -1(right)\n\n\tint bfs(int sy, int sx, int gy, int gx){\n\t\ths = new HashSet<Integer>();\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tint sk = 0;\n\t\tint gk = 0;\n\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(board[sy+vy[k]].charAt(sx+vx[k])!='#') sk = k;\n\t\t\tif(board[gy+vy[k]].charAt(gx+vx[k])!='#') gk = k;\n\t\t}\n\t\tfor(int k2=0;k2<4;k2++){\n\t\t\tint hash = encode(sy,sx,sy,sx,sk,k2);\n\t\t\tq.add(hash);\n\t\t\ths.add(hash);\n\t\t}\n\n\t\tint ret = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint[] now = decode(q.poll());\n\t\t\tint y1 = now[0];\n\t\t\tint x1 = now[1];\n\t\t\tint y2 = now[2];\n\t\t\tint x2 = now[3];\n\t\t\tint k = now[4];\n\t\t\tint k2 = now[5];\n\t\t\t//if(x1!=5 && x2!=5 && x2!=0) System.out.println(y1 + \" \" + x1 + \" \" + y2 + \" \" + x2 + \" \" + k);\n\t\t\twhile(board[y1 + vy[k]].charAt(x1 + vx[k]) != '#'){\n\t\t\t\ty1 += vy[k];\n\t\t\t\tx1 += vx[k];\n\t\t\t}\n\t\t\tif(true){\n\t\t\t\tif(y1==gy && x1 == gx){\n\t\t\t\t\tret = 1;\n\t\t\t\t}\n\t\t\t\tfor(int vk : next){\n\t\t\t\t\tint nk = (k + vk) % 4;\n\t\t\t\t\tint nk2 = (k2+vk)%4;\n\t\t\t\t\tint hash = encode(y1,x1,0,0,nk,nk2);\n\t\t\t\t\tif(!hs.contains(hash)){\n\t\t\t\t\t\tq.add(hash);\n\t\t\t\t\t\ths.add(hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y2!=0){\n\t\t\t\tdo{\n\t\t\t\t\tfor(int vk : next){\n\t\t\t\t\t\tint nk = (k + vk) % 4;\n\t\t\t\t\t\tint nk2 = (k2 + vk)%4;\n\t\t\t\t\t\tif(board[y2+vy[(nk2+2)%4]].charAt(x2+vx[(nk2+2)%4])!='#') continue;\n\n\t\t\t\t\t\tif(y1==gy && x1==gx){\n\t\t\t\t\t\t\tif(y2==gy && x2==gx){\n\t\t\t\t\t\t\t\tif(k2==(gk+2)%4)return 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tret = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint hash = encode(y1,x1,y2,x2,nk,nk2);\n\t\t\t\t\t\tif(!hs.contains(hash)){\n\t\t\t\t\t\t\tq.add(hash);\n\t\t\t\t\t\t\ths.add(hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ty2 += vy[k2];\n\t\t\t\t\tx2 += vx[k2];\n\t\t\t\t}while(board[y2].charAt(x2) != '#');\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint encode(int y1, int x1, int y2, int x2, int k, int k2){\n\t\tint ret = 0;\n\t\tret += y1;\n\t\tret *= w;\n\t\tret += x1;\n\t\tret *= h;\n\t\tret += y2;\n\t\tret *= w;\n\t\tret += x2;\n\t\tret *= 4;\n\t\tret += k;\n\t\tret *= 4;\n\t\tret += k2;\n\t\treturn ret;\n\t}\n\n\tint[] decode(int hash){\n\t\tint[] ret = new int[6];\n\t\tret[5] = hash % 4;\n\t\thash /= 4;\n\t\tret[4] = hash % 4;\n\t\thash /= 4;\n\t\tret[3] = hash % w;\n\t\thash /= w;\n\t\tret[2] = hash % h;\n\t\thash /= h;\n\t\tret[1] = hash % w;\n\t\thash /= w;\n\t\tret[0] = hash;\n\t\treturn ret;\n\t}\n\n\n\n\tpublic static void main(String[] args){\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\t// boolean[][][][][][] vis = new boolean[H][W][4][H][W][4];\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\t// vis[gh][gw][i][gh][gw][j] = true;\n\t\t\t\t\t\t\t// vis[p1.h][p1.w][i][p2.h][p2.w][j] = true;\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\t// if (vis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2])\n\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\t// vis[p1.h][p1.w][ndir1][p2.h][p2.w][ndir2] = true;\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[] dx = new int[] { 1, 0, -1, 0 };\n\tstatic int[] dy = new int[] { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint TESTCASE = 0;\n\t\touter: while (++TESTCASE > 0) {\n\t\t\tSystem.gc();\n\t\t\tint W = sc.nextInt();\n\t\t\tint H = sc.nextInt();\n\t\t\tif (W == 0 && H == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[H][W];\n\t\t\tint sh = -1, sw = -1, gh = -1, gw = -1;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (map[i][j] == 'K') {\n\t\t\t\t\t\tsh = i;\n\t\t\t\t\t\tsw = j;\n\t\t\t\t\t} else if (map[i][j] == 'M') {\n\t\t\t\t\t\tgh = i;\n\t\t\t\t\t\tgw = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] forward = new ArrayList[H][W][4];\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Pos>[][][] backward = new ArrayList[H][W][4];\n\t\t\tfor (int i = 0; i < forward.length; ++i) {\n\t\t\t\tfor (int j = 0; j < forward[i].length; ++j) {\n\t\t\t\t\tfor (int k = 0; k < forward[i][j].length; ++k) {\n\t\t\t\t\t\tforward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t\tbackward[i][j][k] = new ArrayList<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int h = 1; h < H - 1; ++h) {\n\t\t\t\tfor (int w = 1; w < W - 1; ++w) {\n\t\t\t\t\tfor (int dir = 0; dir < 4; ++dir) {\n\t\t\t\t\t\tint nh = h;\n\t\t\t\t\t\tint nw = w;\n\t\t\t\t\t\twhile (map[nh + dy[dir]][nw + dx[dir]] != '#') {\n\t\t\t\t\t\t\tnh += dy[dir];\n\t\t\t\t\t\t\tnw += dx[dir];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforward[h][w][dir].add(new Pos(nh, nw));\n\t\t\t\t\t\tbackward[nh][nw][dir].add(new Pos(h, w));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tHashSet<List> set = new HashSet<>();\n\t\t\tArrayDeque<P> que = new ArrayDeque<>();\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\t\tfor (Pos p1 : forward[gh][gw][i]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[gh][gw][j]) {\n\t\t\t\t\t\t\tif (map[gh + dy[i]][gw + dx[i]] == '#')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(gh, gw, i, gh, gw, j));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, i, p2.h, p2.w, j));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean f = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tP p = que.poll();\n\t\t\t\tfor (int rot = -1; rot <= 1; rot += 2) {\n\t\t\t\t\tint ndir1 = (p.dir1 + rot + 4) % 4;\n\t\t\t\t\tint ndir2 = (p.dir2 + rot + 4) % 4;\n\t\t\t\t\tfor (Pos p1 : forward[p.h1][p.w1][ndir1]) {\n\t\t\t\t\t\tfor (Pos p2 : backward[p.h2][p.w2][ndir2]) {\n\t\t\t\t\t\t\tif (set.contains(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2))) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tque.add(new P(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tset.add(Arrays.asList(p1.h, p1.w, ndir1, p2.h, p2.w, ndir2));\n\t\t\t\t\t\t\tif (p2.h == sh && p2.w == sw && map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#')\n\t\t\t\t\t\t\t\tf = true;\n\t\t\t\t\t\t\tif (p1.h == sh && p1.w == sw && p2.h == sh && p2.w == sw\n\t\t\t\t\t\t\t\t\t&& map[p2.h + dy[ndir2]][p2.w + dx[ndir2]] != '#') {\n\t\t\t\t\t\t\t\tSystem.out.println(\"He can accomplish his mission.\");\n\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t\tSystem.out.println(\"He cannot return to the kitchen.\");\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"He cannot bring tea to his master.\");\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class P {\n\t\tint h1;\n\t\tint w1;\n\t\tint h2;\n\t\tint w2;\n\t\tint dir1;\n\t\tint dir2;\n\n\t\tpublic P(int h1, int w1, int dir1, int h2, int w2, int dir2) {\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t\tthis.dir1 = dir1;\n\t\t\tthis.dir2 = dir2;\n\t\t}\n\t}\n\n\tstatic class Pos {\n\t\tint h;\n\t\tint w;\n\n\t\tpublic Pos(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = uint;\nPoint makePoint(uint y, uint x, uint dir) {\n    return (y << 10) + (x << 2) + dir;\n}\nuint y(Point p) { return p >> 10; }\nuint x(Point p) { return (p << 22) >> 22 >> 2; }\nuint dir(Point p) { return (p << 30) >> 30; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = makePoint(100, 100, 7);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        assert(0 <= p.dir && p.dir < 4);\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        struct State {\n            Point forward, back;\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(makePoint(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = ushort;\nPoint makePoint(uint y, uint x, uint dir) {\n    return cast(Point)((y << 10) + (x << 2) + dir);\n}\nint y(Point p) { return p >> 10; }\nint x(Point p) { return (p & ((-1) << 2) & ((1 << 10) - 1)) >> 2; }\nint dir(Point p) { return p & 3; }\nstruct State { Point forward, back; }\nint hash(Point a, Point b) { return (a << 16) | b; }\nint hash(State s) { return hash(s.forward, s.back); }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = cast(Point)(-1);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        bool[int] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[hash(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (hash(nstate) in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[hash(nforward, nback)] = true;\n                }\n            }\n        }\n\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (hash(State(makePoint(M.y, M.x, fdir), m)) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nimport core.stdc.string;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = ushort;\nPoint makePoint(uint y, uint x, uint dir) {\n    return cast(Point)((y << 8) + (x << 2) + dir);\n}\nint y(Point p) { return p >> 8; }\nint x(Point p) { return (p & ((-1) << 2) & ((1 << 8) - 1)) >> 2; }\nint dir(Point p) { return p & 3; }\nstruct State { Point forward, back; }\nint hash(Point a, Point b) { return (a << 12) | b; }\nint hash(State s) { return hash(s.forward, s.back); }\n\nvoid main() {\n    int W, H;\n    string[] F;\n    auto checked = new bool[1<<24];\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = cast(Point)(-1);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        memset(checked.ptr, false, bool.sizeof * (1<<24));\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[hash(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (checked[ hash(nstate) ]) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[hash(nforward, nback)] = true;\n                }\n            }\n        }\n\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (checked[ hash(makePoint(M.y, M.x, fdir), m) ]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n\n    struct Point { int y, x, dir; }\n    Point K, M;\n    void find_KandM() {\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    K.x = x;\n                    K.y = y;\n                }\n                if (F[y][x] == 'M') {\n                    M.x = x;\n                    M.y = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        K.dir = find_empty_dir(K.y, K.x);\n        M.dir = find_empty_dir(M.y, M.x);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return Point(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return Point(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = Point(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                            reachable_to[tuple(src, dir_char)] ~= Point(-1, -1, -1);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(Point(-1, -1, -1), 'L')] = [Point(-1, -1, -1)];\n            reachable_to[tuple(Point(-1, -1, -1), 'R')] = [Point(-1, -1, -1)];\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = Point(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to[tuple(s.back, opposite(dir_char))];\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(Point(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = ushort;\nPoint makePoint(uint y, uint x, uint dir) {\n    return cast(Point)((y << 10) + (x << 2) + dir);\n}\nint y(Point p) { return p >> 10; }\nint x(Point p) { return (p & ((-1) << 2) & ((1 << 10) - 1)) >> 2; }\nint dir(Point p) { return p & 3; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = makePoint(100, 100, 7);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        struct State {\n            Point forward, back;\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(makePoint(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n\n    struct Point { int y, x, dir; }\n    Point K, M;\n    void find_KandM() {\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    K.x = x;\n                    K.y = y;\n                }\n                if (F[y][x] == 'M') {\n                    M.x = x;\n                    M.y = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        K.dir = find_empty_dir(K.y, K.x);\n        M.dir = find_empty_dir(M.y, M.x);\n    }\n\n    Point forward(in Point p) { // (p.y, p.x)?????????p.dir???????????£?????¶??´?¨?????????±????????¨?????? ????????????????????§?????¶????????????????????£????????§?????°??????????¶?????????        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return Point(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return Point(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[] find_reachable_to(in Point dst, char dir_char) {\n            Point[] ret;\n            ret ~= Point(-1, -1, -1); // dummy\n            foreach (int y; 0 .. H) {\n                foreach (int x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (int dir; 0 .. 4) {\n                        auto cand = Point(y, x, dir);\n                        auto cand_dst = forward(turn(cand, opposite(dir_char)));\n                        if (cand_dst == dst) {\n                            ret ~= cand;\n                        }\n                    }\n                }\n            }\n            return ret;\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = Point(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = find_reachable_to(s.back, dir_char);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(Point(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = long;\nPoint makePoint(long y, long x, long dir) {\n    return (y << 20L) + (x << 4L) + (dir % 4);\n}\nint y(Point p) { return cast(int)(p >> 20L); }\nint x(Point p) { return cast(int)((p << 44L) >> 44L >> 4L); }\nint dir(Point p) { return cast(int)(p % 4); }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = makePoint(100, 100, 7);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(makePoint(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = int;\nPoint makePoint(int y, int x, int dir) {\n    return (y << 16) + (x << 4) + dir;\n}\nint y(Point p) { return cast(int)(p >> 16); }\nint x(Point p) { return cast(int)((p << 16) >> 16 >> 4L); }\nint dir(Point p) { return cast(int)(p % 4); }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = makePoint(100, 100, 7);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(makePoint(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n\n    struct Point { int y, x, dir; }\n    Point K, M;\n    void find_KandM() {\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    K.x = x;\n                    K.y = y;\n                }\n                if (F[y][x] == 'M') {\n                    M.x = x;\n                    M.y = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        K.dir = find_empty_dir(K.y, K.x);\n        M.dir = find_empty_dir(M.y, M.x);\n    }\n\n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return Point(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return Point(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[] find_reachable_to(in Point dst, char dir_char) {\n            Point[] ret;\n            ret ~= Point(-1, -1, -1); // dummy\n            foreach (int y; 0 .. H) {\n                foreach (int x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (int dir; 0 .. 4) {\n                        auto cand = Point(y, x, dir);\n                        auto cand_dst = forward(turn(cand, opposite(dir_char)));\n                        if (cand_dst == dst) {\n                            ret ~= cand;\n                        }\n                    }\n                }\n            }\n            return ret;\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = Point(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = find_reachable_to(s.back, dir_char);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(Point(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n\n    struct Point { int y, x, dir; }\n    Point K, M;\n    void find_KandM() {\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    K.x = x;\n                    K.y = y;\n                }\n                if (F[y][x] == 'M') {\n                    M.x = x;\n                    M.y = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        K.dir = find_empty_dir(K.y, K.x);\n        M.dir = find_empty_dir(M.y, M.x);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return Point(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return Point(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            Point[] find_reachable_to(in Point dst, char dir_char) {\n                Point[] ret;\n                ret ~= Point(-1, -1, -1); // dummy\n                foreach (int y; 0 .. H) {\n                    foreach (int x; 0 .. W) {\n                        if (F[y][x] == '#') continue;\n                        foreach (int dir; 0 .. 4) {\n                            auto cand = Point(y, x, dir);\n                            auto cand_dst = forward(turn(cand, opposite(dir_char)));\n                            if (cand_dst == dst) {\n                                ret ~= cand;\n                            }\n                        }\n                    }\n                }\n                return ret;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto dst = Point(y, x, dir);\n                            reachable_to[tuple(dst, dir_char)] = find_reachable_to(dst, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(Point(-1, -1, -1), 'L')] = [Point(-1, -1, -1)];\n            reachable_to[tuple(Point(-1, -1, -1), 'R')] = [Point(-1, -1, -1)];\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = Point(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to[tuple(s.back, dir_char)];\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(Point(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n\n    struct Point { int y, x, dir; }\n    Point K, M;\n    void find_KandM() {\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    K.x = x;\n                    K.y = y;\n                }\n                if (F[y][x] == 'M') {\n                    M.x = x;\n                    M.y = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        K.dir = find_empty_dir(K.y, K.x);\n        M.dir = find_empty_dir(M.y, M.x);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return Point(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return Point(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = Point(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(Point(-1, -1, -1), 'L')] = [Point(-1, -1, -1)];\n            reachable_to[tuple(Point(-1, -1, -1), 'R')] = [Point(-1, -1, -1)];\n        }\n\n        struct State {\n            Point forward;\n            Point back;\n        }\n        auto init = forward(K);\n        DList!State Q;\n        bool[State] checked;\n        foreach (last_dir; 0 .. 4) {\n            auto last = Point(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[State(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            auto s = Q.front; Q.removeFront;\n            assert(s in checked);\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), []);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (nstate in checked) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[nstate] = true;\n                }\n            }\n        }\n\n        //log(checked);\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (State(Point(M.y, M.x, fdir), m) in checked) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nimport core.stdc.string;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = ushort;\nPoint makePoint(uint y, uint x, uint dir) {\n    return cast(Point)((y << 8) + (x << 2) + dir);\n}\nint y(Point p) { return p >> 8; }\nint x(Point p) { return (p & ((-1) << 2) & ((1 << 8) - 1)) >> 2; }\nint dir(Point p) { return p & 3; }\nstruct State { Point forward, back; }\nint hash(Point a, Point b) { return (a << 12) | b; }\nint hash(State s) { return hash(s.forward, s.back); }\n\nconst bufsize = 1<<24;\n\nvoid main() {\n    int W, H;\n    string[] F;\n    auto checked = new bool[bufsize];\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        find_KandM();\n\n        {\n            memset(checked.ptr, false, bool.sizeof * bufsize);\n            DList!Point Q;\n            Q.insert(K);\n            while (! Q.empty) {\n                auto c = Q.front; Q.removeFront;\n                foreach (char dir_char; \"LR\") {\n                    auto next = forward(turn(c, dir_char));\n                    if (checked[next]) continue;\n                    Q.insert(next);\n                    checked[next] = true;\n                    if (next.y == M.y && next.x == M.x) {\n                        goto NEXT;\n                    }\n                }\n            }\n            writeln(\"He cannot bring tea to his master.\");\n            return;\nNEXT:;\n        }\n\n        memset(checked.ptr, false, bool.sizeof * bufsize);\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[hash(init, last)] = true;\n        }\n\n        auto m = forward(M);\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), []);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (checked[ hash(nstate) ]) continue;\n                    Q.insert(nstate);\n                    checked[hash(nforward, nback)] = true;\n                    if (nforward.y == M.y && nforward.x == M.x && nback == m) {\n                        writeln(\"He can accomplish his mission.\");\n                        return;\n                    }\n                }\n            }\n        }\n\n        writeln(\"He cannot return to the kitchen.\");\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nimport core.stdc.string;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = ushort;\nPoint makePoint(uint y, uint x, uint dir) {\n    return cast(Point)((y << 8) + (x << 2) + dir);\n}\nint y(Point p) { return p >> 8; }\nint x(Point p) { return (p & ((-1) << 2) & ((1 << 8) - 1)) >> 2; }\nint dir(Point p) { return p & 3; }\nstruct State { Point forward, back; }\nint hash(Point a, Point b) { return (a << 13) | b; }\nint hash(State s) { return hash(s.forward, s.back); }\nbool[1<<26] checked;\n\nvoid main() {\n    int W, H;\n    string[] F;\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = cast(Point)(-1);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        memset(checked.ptr, false, checked.sizeof);\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[hash(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (checked[ hash(nstate) ]) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[hash(nforward, nback)] = true;\n                }\n            }\n        }\n\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (checked[ hash(makePoint(M.y, M.x, fdir), m) ]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nimport core.stdc.string;\nvoid log(A...)(A arg) { stderr.writeln(arg); }\nint size(T)(in T s) { return cast(int)s.length; }\n\nalias Point = ushort;\nPoint makePoint(uint y, uint x, uint dir) {\n    return cast(Point)((y << 8) + (x << 2) + dir);\n}\nint y(Point p) { return p >> 8; }\nint x(Point p) { return (p & ((-1) << 2) & ((1 << 8) - 1)) >> 2; }\nint dir(Point p) { return p & 3; }\nstruct State { Point forward, back; }\nint hash(Point a, Point b) { return (a << 13) | b; }\nint hash(State s) { return hash(s.forward, s.back); }\n\nvoid main() {\n    int W, H;\n    string[] F;\n    auto checked = new bool[1<<26];\n\n    bool input() {\n        readf(\"%d %d\\n\", &W, &H);\n        if (W == 0 && H == 0) return false;\n        F = new string[H];\n        foreach (ref L; F) {\n            L = readln.chomp;\n        }\n        return true;\n    }\n\n    const int[] dy = [-1, 0, 1, 0];\n    const int[] dx = [0, 1, 0, -1];\n\n    char opposite(char dir_char) {\n        return dir_char == 'R' ? 'L' : 'R';\n    }\n    Point dummy = cast(Point)(-1);\n\n    Point K, M;\n    void find_KandM() {\n        int ky, kx, kdir;\n        int my, mx, mdir;\n        foreach (int y; 0 .. H) {\n            foreach (int x; 0 .. W) {\n                if (F[y][x] == 'K') {\n                    kx = x;\n                    ky = y;\n                }\n                if (F[y][x] == 'M') {\n                    mx = x;\n                    my = y;\n                }\n            }\n        }\n        int find_empty_dir(int sy, int sx) {\n            int sd = -1;\n            foreach (int j; 0 .. 4) {\n                int ny = sy + dy[j];\n                int nx = sx + dx[j];\n                if (F[ny][nx] == '.') {\n                    sd = j;\n                }\n            }\n            return sd;\n        }\n        kdir = find_empty_dir(ky, kx);\n        mdir = find_empty_dir(my, mx);\n        K = makePoint(ky, kx, kdir);\n        M = makePoint(my, mx, mdir);\n    }\n    \n    Point forward(in Point p) {\n        int k = p.dir;\n        int cy = p.y;\n        int cx = p.x;\n        while (true) {\n            int ny = cy + dy[k];\n            int nx = cx + dx[k];\n            if (F[ny][nx] == '#') break;\n            cy = ny;\n            cx = nx;\n        }\n        return makePoint(cy, cx, k);\n    }\n    \n    Point turn(in Point p, char dir_char) {\n        int dir;\n        if (dir_char == 'R') {\n            dir = +1;\n        } else if (dir_char == 'L') {\n            dir = -1;\n        } else {\n            assert(false);\n        }\n        int k = (p.dir + dir + 4) % 4;\n        return makePoint(p.y, p.x, k);\n    }\n\n    void solve() {\n        memset(checked.ptr, false, bool.sizeof * (1<<26));\n        find_KandM();\n\n        Point[][Tuple!(Point, char)] reachable_to;\n        {\n            void find_reachable_from(in Point src, char dir_char) {\n                reachable_to[tuple(forward(turn(src, dir_char)), dir_char)] ~= src;\n            }\n            foreach (y; 0 .. H) {\n                foreach (x; 0 .. W) {\n                    if (F[y][x] == '#') continue;\n                    foreach (dir; 0 .. 4) {\n                        foreach (char dir_char; \"LR\") {\n                            auto src = makePoint(y, x, dir);\n                            find_reachable_from(src, dir_char);\n                        }\n                    }\n                }\n            }\n            reachable_to[tuple(dummy, 'L')] = [dummy];\n            reachable_to[tuple(dummy, 'R')] = [dummy];\n        }\n\n        auto init = forward(K);\n        DList!State Q;\n        foreach (last_dir; 0 .. 4) {\n            auto last = makePoint(K.y, K.x, last_dir);\n            Q.insert(State(init, last));\n            checked[hash(init, last)] = true;\n        }\n\n        bool can_reach_to_M = false;\n        while (! Q.empty) {\n            State s = Q.front; Q.removeFront;\n            foreach (char dir_char; \"LR\") {\n                auto turned = turn(s.forward, dir_char);\n                //log(\"forward: \", s.forward, \" -> \", forward(turned));\n                auto nforward = forward(turned);\n                //log(\"back: \", s.back, \" <- \", find_reachable_to(s.back))\n                auto backs = reachable_to.get(tuple(s.back, opposite(dir_char)), [dummy]);\n                foreach (nback; backs) {\n                    auto nstate = State(nforward, nback);\n                    if (checked[ hash(nstate) ]) continue;\n                    if (nforward.y == M.y && nforward.x == M.x) { can_reach_to_M = true; }\n                    Q.insert(nstate);\n                    checked[hash(nforward, nback)] = true;\n                }\n            }\n        }\n\n        auto m = forward(M);\n        bool can_back_to_K() {\n            foreach (fdir; 0 .. 4) {\n                if (checked[ hash(makePoint(M.y, M.x, fdir), m) ]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        writeln( can_reach_to_M ? \n                    can_back_to_K() ? \"He can accomplish his mission.\" : \"He cannot return to the kitchen.\"\n                  : \"He cannot bring tea to his master.\" );\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    W, H = map(int, readline().split())\n    if W == H == 0:\n        return False\n    S = [readline().strip() for i in range(H)]\n\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        Si = S[i]\n        for j in range(W):\n            if Si[j] == \"K\":\n                sy = i; sx = j\n            elif Si[j] == \"M\":\n                gy = i; gx = j\n    ks = kg = 0\n    for k in range(4):\n        dx, dy = dd[k]\n        if S[sy+dy][sx+dx] != \"#\":\n            ks = k\n        if S[gy+dy][gx+dx] != \"#\":\n            kg = k\n\n    dx, dy = dd[ks]\n    sx1 = sx; sy1 = sy\n    while S[sy1+dy][sx1+dx] != \"#\":\n        sx1 += dx; sy1 += dy\n    dx, dy = dd[kg]\n    gx1 = gx; gy1 = gy\n    while S[gy1+dy][gx1+dx] != \"#\":\n        gx1 += dx; gy1 += dy\n\n    N = W*H*4\n    G0 = [[[] for i in range(2)] for j in range(N)]\n    G1 = [[[] for i in range(2)] for j in range(N)]\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == \"#\":\n                continue\n            for k in range(4):\n                dx, dy = dd[k]\n                x = j; y = i\n                while S[y+dy][x+dx] != \"#\":\n                    x += dx; y += dy\n                dx1, dy1 = dd[k-1]\n                if S[i+dy1][j+dx1] == \"#\":\n                    p0 = (i*W + j)*4 + (k-1)%4\n                    p1 = (y*W + x)*4 + k\n                    G0[p0][1].append(p1)\n                    G1[p1][1].append(p0)\n                dx2, dy2 = dd[k-3]\n                if S[i+dy2][j+dx2] == \"#\":\n                    p0 = (i*W + j)*4 + (k+1)%4\n                    p1 = (y*W + x)*4 + k\n                    G0[p0][0].append(p1)\n                    G1[p1][0].append(p0)\n    used = set()\n    que = deque()\n    for k in range(4):\n        if k != ks:\n            s = ((sy1*W + sx1)*4 + ks, (sy*W + sx)*4 + k)\n            que.append(s)\n            used.add(s)\n    while que:\n        v1, v2 = que.popleft()\n        for k in range(2):\n            for w1 in G0[v1][k]:\n                for w2 in G1[v2][k^1]:\n                    s = (w1, w2)\n                    if s in used:\n                        continue\n                    que.append(s)\n                    used.add(s)\n    ok = 0\n    for k in range(4):\n        if k != kg:\n            s = ((gy*W + gx)*4 + k, (gy1*W + gx1)*4 + kg)\n            if s in used:\n                ok = 1\n    if ok:\n        write(\"He can accomplish his mission.\\n\")\n        return True\n\n    que = deque([(sy1*W + sx1)*4 + ks])\n    used = [0]*N\n    used[(sy1*W + sx1)*4 + ks] = 1\n    while que:\n        v = que.popleft()\n        for w in G0[v][0]:\n            if used[w]:\n                continue\n            used[w] = 1\n            que.append(w)\n        for w in G0[v][1]:\n            if used[w]:\n                continue\n            used[w] = 1\n            que.append(w)\n    for k in range(4):\n        if used[(gy*W + gx)*4 + k]:\n            ok = 1\n    if ok:\n        write(\"He cannot return to the kitchen.\\n\")\n    else:\n        write(\"He cannot bring tea to his master.\\n\")\n    return True\nwhile solve():\n    ...\n"
  }
]