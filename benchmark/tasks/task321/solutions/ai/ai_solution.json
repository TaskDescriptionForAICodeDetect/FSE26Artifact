[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\nbool canMeasure(int amount, int* weights, int weightsSize, int index, int sum) {\n    if (sum == amount) {\n        return true;\n    }\n    if (index >= weightsSize) {\n        return false;\n    }\n    return canMeasure(amount, weights, weightsSize, index + 1, sum + weights[index]) ||\n           canMeasure(amount, weights, weightsSize, index + 1, sum - weights[index]) ||\n           canMeasure(amount, weights, weightsSize, index + 1, sum);\n}\n\nbool canMeasureAll(int* amounts, int amountsSize, int* weights, int weightsSize) {\n    for (int i = 0; i < amountsSize; i++) {\n        if (!canMeasure(amounts[i], weights, weightsSize, 0, 0)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint findMinAdditionalWeight(int* amounts, int amountsSize, int* weights, int weightsSize) {\n    if (canMeasureAll(amounts, amountsSize, weights, weightsSize)) {\n        return 0;\n    }\n\n    int minWeight = INT_MAX;\n    for (int w = 1; w <= 1000; w++) {\n        int newWeightsSize = weightsSize + 1;\n        int* newWeights = (int*)malloc(newWeightsSize * sizeof(int));\n        for (int i = 0; i < weightsSize; i++) {\n            newWeights[i] = weights[i];\n        }\n        newWeights[weightsSize] = w;\n\n        if (canMeasureAll(amounts, amountsSize, newWeights, newWeightsSize)) {\n            if (w < minWeight) {\n                minWeight = w;\n            }\n        }\n        free(newWeights);\n    }\n\n    return (minWeight != INT_MAX) ? minWeight : -1;\n}\n\nint main() {\n    int amountsSize, weightsSize;\n    scanf(\"%d\", &amountsSize);\n    int* amounts = (int*)malloc(amountsSize * sizeof(int));\n    for (int i = 0; i < amountsSize; i++) {\n        scanf(\"%d\", &amounts[i]);\n    }\n    scanf(\"%d\", &weightsSize);\n    int* weights = (int*)malloc(weightsSize * sizeof(int));\n    for (int i = 0; i < weightsSize; i++) {\n        scanf(\"%d\", &weights[i]);\n    }\n\n    int result = findMinAdditionalWeight(amounts, amountsSize, weights, weightsSize);\n    if (result == 0) {\n        printf(\"All measurements can be done with the current weights.\\n\");\n    } else if (result > 0) {\n        printf(\"The lightest additional weight needed is %d.\\n\", result);\n    } else {\n        printf(\"Adding any single weight is insufficient.\\n\");\n    }\n\n    free(amounts);\n    free(weights);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nbool canMeasure(int amount, const unordered_set<int>& possible) {\n    return possible.find(amount) != possible.end();\n}\n\nunordered_set<int> generatePossible(const vector<int>& weights) {\n    unordered_set<int> possible;\n    possible.insert(0);\n    for (int w : weights) {\n        unordered_set<int> temp;\n        for (int p : possible) {\n            temp.insert(p + w);\n            temp.insert(abs(p - w));\n        }\n        for (int t : temp) {\n            possible.insert(t);\n        }\n    }\n    return possible;\n}\n\nint findMinAdditionalWeight(const vector<int>& amounts, const vector<int>& weights) {\n    unordered_set<int> possible = generatePossible(weights);\n    unordered_set<int> missing;\n    for (int amount : amounts) {\n        if (!canMeasure(amount, possible)) {\n            missing.insert(amount);\n        }\n    }\n    if (missing.empty()) {\n        return 0;\n    }\n    int minWeight = INT_MAX;\n    unordered_set<int> newWeights;\n    for (int w : possible) {\n        for (int m : missing) {\n            int diff = abs(m - w);\n            if (diff != 0) {\n                newWeights.insert(diff);\n            }\n        }\n    }\n    for (int newW : newWeights) {\n        vector<int> newWeightList = weights;\n        newWeightList.push_back(newW);\n        unordered_set<int> newPossible = generatePossible(newWeightList);\n        bool allMeasurable = true;\n        for (int amount : amounts) {\n            if (!canMeasure(amount, newPossible)) {\n                allMeasurable = false;\n                break;\n            }\n        }\n        if (allMeasurable) {\n            minWeight = min(minWeight, newW);\n        }\n    }\n    return minWeight == INT_MAX ? -1 : minWeight;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> amounts(N);\n    vector<int> weights(M);\n    for (int i = 0; i < N; ++i) {\n        cin >> amounts[i];\n    }\n    for (int i = 0; i < M; ++i) {\n        cin >> weights[i];\n    }\n    int result = findMinAdditionalWeight(amounts, weights);\n    if (result == 0) {\n        cout << \"All measurements can be done with the current weights.\" << endl;\n    } else if (result == -1) {\n        cout << \"Adding any single weight is insufficient.\" << endl;\n    } else {\n        cout << \"The lightest additional weight needed is \" << result << \".\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:04:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ChemicalWeights {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] chemicals = new int[n];\n        int[] weights = new int[m];\n        \n        for (int i = 0; i < n; i++) {\n            chemicals[i] = scanner.nextInt();\n        }\n        for (int i = 0; i < m; i++) {\n            weights[i] = scanner.nextInt();\n        }\n        \n        Set<Integer> possible = new HashSet<>();\n        possible.add(0);\n        \n        for (int w : weights) {\n            Set<Integer> temp = new HashSet<>();\n            for (int p : possible) {\n                temp.add(p + w);\n                temp.add(Math.abs(p - w));\n            }\n            possible.addAll(temp);\n        }\n        \n        boolean allPossible = true;\n        for (int chem : chemicals) {\n            if (!possible.contains(chem)) {\n                allPossible = false;\n                break;\n            }\n        }\n        \n        if (allPossible) {\n            System.out.println(0);\n            return;\n        }\n        \n        Set<Integer> missing = new HashSet<>();\n        for (int chem : chemicals) {\n            if (!possible.contains(chem)) {\n                missing.add(chem);\n            }\n        }\n        \n        Set<Integer> candidates = new HashSet<>();\n        for (int chem : missing) {\n            for (int p : possible) {\n                candidates.add(Math.abs(chem - p));\n                candidates.add(chem + p);\n            }\n        }\n        \n        int minAdditional = Integer.MAX_VALUE;\n        for (int candidate : candidates) {\n            if (candidate == 0) continue;\n            Set<Integer> newPossible = new HashSet<>(possible);\n            Set<Integer> temp = new HashSet<>();\n            for (int p : newPossible) {\n                temp.add(p + candidate);\n                temp.add(Math.abs(p - candidate));\n            }\n            newPossible.addAll(temp);\n            \n            boolean valid = true;\n            for (int chem : chemicals) {\n                if (!newPossible.contains(chem)) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid && candidate < minAdditional) {\n                minAdditional = candidate;\n            }\n        }\n        \n        if (minAdditional != Integer.MAX_VALUE) {\n            System.out.println(minAdditional);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:05:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass ChemicalWeightMeasurement {\n    public static int findMinAdditionalWeight(int[] weights, int[] amounts) {\n        Set<Integer> possibleMeasurements = new HashSet<>();\n        possibleMeasurements.add(0);\n\n        for (int weight : weights) {\n            Set<Integer> newMeasurements = new HashSet<>(possibleMeasurements);\n            for (int measurement : possibleMeasurements) {\n                newMeasurements.add(measurement + weight);\n                newMeasurements.add(Math.abs(measurement - weight));\n            }\n            possibleMeasurements = newMeasurements;\n        }\n\n        for (int amount : amounts) {\n            if (!canMeasure(possibleMeasurements, amount)) {\n                for (int potentialWeight = 1; ; potentialWeight++) {\n                    Set<Integer> extendedMeasurements = new HashSet<>(possibleMeasurements);\n                    for (int measurement : possibleMeasurements) {\n                        extendedMeasurements.add(measurement + potentialWeight);\n                        extendedMeasurements.add(Math.abs(measurement - potentialWeight));\n                    }\n\n                    boolean allMeasurable = true;\n                    for (int amount : amounts) {\n                        if (!canMeasure(extendedMeasurements, amount)) {\n                            allMeasurable = false;\n                            break;\n                        }\n                    }\n\n                    if (allMeasurable) {\n                        return potentialWeight;\n                    }\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    private static boolean canMeasure(Set<Integer> measurements, int target) {\n        return measurements.contains(target);\n    }\n\n    public static void main(String[] args) {\n        int[] weights = {1, 3, 9};\n        int[] amounts = {5, 7, 13};\n        System.out.println(findMinAdditionalWeight(weights, amounts));\n    }\n}",
    "timestamp": "2025-08-05 21:05:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_WEIGHTS 20\n#define MAX_AMOUNTS 100\n\nbool can_measure(int* weights, int weight_count, int amount) {\n    bool dp[MAX_AMOUNTS * 2 + 1] = {false};\n    dp[MAX_AMOUNTS] = true;\n\n    for (int i = 0; i < weight_count; i++) {\n        bool new_dp[MAX_AMOUNTS * 2 + 1] = {false};\n        for (int j = 0; j < MAX_AMOUNTS * 2 + 1; j++) {\n            if (dp[j]) {\n                if (j + weights[i] < MAX_AMOUNTS * 2 + 1)\n                    new_dp[j + weights[i]] = true;\n                if (j - weights[i] >= 0)\n                    new_dp[j - weights[i]] = true;\n            }\n        }\n        for (int j = 0; j < MAX_AMOUNTS * 2 + 1; j++)\n            dp[j] |= new_dp[j];\n    }\n\n    return dp[MAX_AMOUNTS + amount];\n}\n\nint find_lightest_weight(int* weights, int weight_count, int* amounts, int amount_count) {\n    int max_amount = 0;\n    for (int i = 0; i < amount_count; i++)\n        max_amount = (amounts[i] > max_amount) ? amounts[i] : max_amount;\n\n    for (int additional_weight = 1; additional_weight <= max_amount; additional_weight++) {\n        bool all_measurable = true;\n        weights[weight_count] = additional_weight;\n\n        for (int i = 0; i < amount_count; i++) {\n            if (!can_measure(weights, weight_count + 1, amounts[i])) {\n                all_measurable = false;\n                break;\n            }\n        }\n\n        if (all_measurable)\n            return additional_weight;\n    }\n\n    return -1;\n}\n\nint main() {\n    int weights[MAX_WEIGHTS];\n    int amounts[MAX_AMOUNTS];\n    int weight_count, amount_count;\n\n    scanf(\"%d\", &weight_count);\n    for (int i = 0; i < weight_count; i++)\n        scanf(\"%d\", &weights[i]);\n\n    scanf(\"%d\", &amount_count);\n    for (int i = 0; i < amount_count; i++)\n        scanf(\"%d\", &amounts[i]);\n\n    int result = find_lightest_weight(weights, weight_count, amounts, amount_count);\n\n    if (result == -1)\n        printf(\"Cannot measure all amounts\\n\");\n    else\n        printf(\"Lightest additional weight: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_set>\n#include <climits>\n\nusing namespace std;\n\nclass ChemicalWeightMeasurement {\npublic:\n    int findLightestAdditionalWeight(vector<int>& weights, vector<int>& amounts) {\n        int maxAmount = *max_element(amounts.begin(), amounts.end());\n        unordered_set<int> possibleWeights;\n        possibleWeights.insert(0);\n\n        for (int weight : weights) {\n            unordered_set<int> newPossibleWeights = possibleWeights;\n            for (int possibleWeight : possibleWeights) {\n                newPossibleWeights.insert(possibleWeight + weight);\n                newPossibleWeights.insert(abs(possibleWeight - weight));\n            }\n            possibleWeights = newPossibleWeights;\n        }\n\n        for (int amount : amounts) {\n            if (possibleWeights.find(amount) == possibleWeights.end()) {\n                int lightestWeight = findLightestAdditionalWeightForAmount(weights, amount, maxAmount);\n                return lightestWeight;\n            }\n        }\n\n        return -1;\n    }\n\nprivate:\n    int findLightestAdditionalWeightForAmount(vector<int>& weights, int targetAmount, int maxAmount) {\n        for (int candidate = 1; candidate <= maxAmount; candidate++) {\n            unordered_set<int> possibleWeights;\n            possibleWeights.insert(0);\n            vector<int> extendedWeights = weights;\n            extendedWeights.push_back(candidate);\n\n            for (int weight : extendedWeights) {\n                unordered_set<int> newPossibleWeights = possibleWeights;\n                for (int possibleWeight : possibleWeights) {\n                    newPossibleWeights.insert(possibleWeight + weight);\n                    newPossibleWeights.insert(abs(possibleWeight - weight));\n                }\n                possibleWeights = newPossibleWeights;\n            }\n\n            if (possibleWeights.find(targetAmount) != possibleWeights.end()) {\n                return candidate;\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    ChemicalWeightMeasurement solution;\n    vector<int> weights = {1, 3, 9};\n    vector<int> amounts = {5, 7, 11};\n    int result = solution.findLightestAdditionalWeight(weights, amounts);\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef can_measure_with_weights(weights, amounts):\n    def can_measure(amount, weights):\n        total_weights = weights + [-w for w in weights]\n        for r in range(len(total_weights) + 1):\n            for combo in combinations(total_weights, r):\n                if sum(combo) == amount:\n                    return True\n        return False\n    \n    for amount in amounts:\n        if not can_measure(amount, weights):\n            return False\n    return True\n\ndef find_lightest_additional_weight(weights, amounts):\n    max_amount = max(amounts)\n    for additional_weight in range(1, max_amount + 1):\n        new_weights = weights + [additional_weight]\n        if can_measure_with_weights(new_weights, amounts):\n            return additional_weight\n    return None\n\ndef measure_or_find_weight(weights, amounts):\n    if can_measure_with_weights(weights, amounts):\n        return \"All measurements can be done with current weights.\"\n    \n    additional_weight = find_lightest_additional_weight(weights, amounts)\n    if additional_weight is not None:\n        return f\"Lightest additional weight: {additional_weight}\"\n    else:\n        return \"Adding any single weight is insufficient.\"\n\n# Example usage:\nweights = [2, 3, 5]\namounts = [1, 4, 7]\nprint(measure_or_find_weight(weights, amounts))",
    "timestamp": "2025-08-13 04:48:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ChemistScale {\n\n    public static void main(String[] args) {\n        int[] weights = {1, 3, 9}; // example weights\n        int[] amounts = {2, 5, 7}; // example amounts\n        System.out.println(findLightestAdditionalWeight(weights, amounts));\n    }\n\n    public static int findLightestAdditionalWeight(int[] weights, int[] amounts) {\n        Set<Integer> measurable = new HashSet<>();\n        generateWeightCombinations(weights, 0, 0, measurable);\n\n        int maxAmount = Arrays.stream(amounts).max().orElse(0);        \n        boolean allMeasurable = true;\n        for (int amount : amounts) {\n            if (!measurable.contains(amount)) {\n                allMeasurable = false;\n                break;\n            }\n        }\n\n        if (allMeasurable) {\n            return 0;  // All amounts are measurable\n        }\n\n        for (int w = 1; w <= maxAmount; w++) {\n            Set<Integer> tempMeasurable = new HashSet<>(measurable);\n            generateWeightCombinationsWithExtraWeight(weights, w, 0, 0, tempMeasurable);\n\n            boolean allMeasurableWithExtra = true;\n            for (int amount : amounts) {\n                if (!tempMeasurable.contains(amount)) {\n                    allMeasurableWithExtra = false;\n                    break;\n                }\n            }\n\n            if (allMeasurableWithExtra) {\n                return w;  // Return the lightest additional weight needed\n            }\n        }\n\n        return -1;  // Cannot make all measurements with any single additional weight\n    }\n\n    private static void generateWeightCombinations(int[] weights, int idx, int currentWeight, Set<Integer> measurable) {\n        if (idx == weights.length) {\n            measurable.add(Math.abs(currentWeight));\n            return;\n        }\n        generateWeightCombinations(weights, idx + 1, currentWeight + weights[idx], measurable);\n        generateWeightCombinations(weights, idx + 1, currentWeight - weights[idx], measurable);\n        generateWeightCombinations(weights, idx + 1, currentWeight, measurable);\n    }\n\n    private static void generateWeightCombinationsWithExtraWeight(int[] weights, int extra, int idx, int currentWeight, Set<Integer> measurable) {\n        if (idx == weights.length) {\n            measurable.add(Math.abs(currentWeight));\n            measurable.add(Math.abs(currentWeight + extra));\n            measurable.add(Math.abs(currentWeight - extra));\n            return;\n        }\n        generateWeightCombinationsWithExtraWeight(weights, extra, idx + 1, currentWeight + weights[idx], measurable);\n        generateWeightCombinationsWithExtraWeight(weights, extra, idx + 1, currentWeight - weights[idx], measurable);\n        generateWeightCombinationsWithExtraWeight(weights, extra, idx + 1, currentWeight, measurable);\n    }\n}",
    "timestamp": "2025-08-13 04:48:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_WEIGHTS 100\n#define MAX_CHEMICALS 100\n\nint weights[MAX_WEIGHTS];\nint chemicals[MAX_CHEMICALS];\nbool possible[MAX_WEIGHTS * MAX_CHEMICALS + 1];\nint n, m, maxChemical;\n\n// Utility function for checking possibilities\nvoid markPossibilities(int weight) {\n    bool current[MAX_WEIGHTS * MAX_CHEMICALS + 1];\n    for (int i = 0; i <= maxChemical; i++) {\n        current[i] = possible[i];\n    }\n    for (int i = 0; i <= maxChemical; i++) {\n        if (current[i]) {\n            if (i + weight <= maxChemical)\n                possible[i + weight] = true;\n            if (i - weight > 0)\n                possible[i - weight] = true;\n            if (weight - i >= 0)\n                possible[weight - i] = true;\n        }\n    }\n}\n\nbool canMeasureAll() {\n    for (int i = 0; i < m; i++) {\n        if (!possible[chemicals[i]])\n            return false;\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d\", &n); // number of available weights\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &weights[i]);\n    }\n    scanf(\"%d\", &m); // number of chemicals\n    maxChemical = 0;\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &chemicals[i]);\n        if (chemicals[i] > maxChemical)\n            maxChemical = chemicals[i];\n    }\n\n    possible[0] = true;\n    for (int i = 0; i < n; i++) {\n        markPossibilities(weights[i]);\n    }\n\n    if (canMeasureAll()) {\n        printf(\"All measurements can be done with existing weights.\\n\");\n        return 0;\n    }\n\n    int minAdditionalWeight = -1;\n    for (int i = 1; i <= maxChemical; i++) {\n        if (!possible[i]) {\n            markPossibilities(i);\n            if (canMeasureAll()) {\n                minAdditionalWeight = i;\n                break;\n            }\n        }\n    }\n\n    if (minAdditionalWeight != -1) {\n        printf(\"Lightest additional weight needed: %d\\n\", minAdditionalWeight);\n    } else {\n        printf(\"Even with one additional weight, it's not possible.\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:48:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_measure_amounts(weights, amounts):\n    def can_measure_recursive(weights, target, index):\n        if target == 0:\n            return True\n        if index < 0 or target < 0:\n            return False\n        \n        # Try not using current weight\n        if can_measure_recursive(weights, target, index - 1):\n            return True\n        \n        # Try adding current weight to one side\n        if can_measure_recursive(weights, target - weights[index], index - 1):\n            return True\n        \n        # Try subtracting current weight from one side\n        if can_measure_recursive(weights, target + weights[index], index - 1):\n            return True\n        \n        return False\n\n    def find_minimum_additional_weight(weights, amounts):\n        max_amount = max(amounts)\n        current_max_measurable = 0\n        \n        for amount in amounts:\n            found_measurement = False\n            for sign in [1, -1]:\n                if can_measure_recursive(weights, sign * amount, len(weights) - 1):\n                    found_measurement = True\n                    current_max_measurable = max(current_max_measurable, abs(amount))\n                    break\n            \n            if not found_measurement:\n                # Find smallest weight that allows measurement\n                for w in range(1, max_amount + 1):\n                    new_weights = weights + [w]\n                    if can_measure_recursive(new_weights, amount, len(new_weights) - 1):\n                        return w\n                return None\n        \n        return None\n\n    # Check if all amounts can be measured\n    for amount in amounts:\n        found_measurement = False\n        for sign in [1, -1]:\n            if can_measure_recursive(weights, sign * amount, len(weights) - 1):\n                found_measurement = True\n                break\n        \n        if not found_measurement:\n            # Try to find minimum additional weight\n            additional_weight = find_minimum_additional_weight(weights, amounts)\n            return additional_weight if additional_weight is not None else -1\n    \n    return 0",
    "timestamp": "2025-08-13 04:48:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_measure(amount, weights):\n    possible = {0}\n    for w in weights:\n        temp = set()\n        for p in possible:\n            temp.add(p + w)\n            temp.add(abs(p - w))\n        possible.update(temp)\n    return amount in possible\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    T = int(input[idx])\n    idx += 1\n    for _ in range(T):\n        N, M = map(int, input[idx:idx+2])\n        idx +=2\n        amounts = list(map(int, input[idx:idx+N]))\n        idx +=N\n        weights = list(map(int, input[idx:idx+M]))\n        idx +=M\n        \n        all_measurable = True\n        for amount in amounts:\n            if not can_measure(amount, weights):\n                all_measurable = False\n                break\n        \n        if all_measurable:\n            print(0)\n            continue\n        \n        min_additional = float('inf')\n        for amount in amounts:\n            if not can_measure(amount, weights):\n                possible_new = set()\n                current_possible = {0}\n                for w in weights:\n                    temp = set()\n                    for p in current_possible:\n                        temp.add(p + w)\n                        temp.add(abs(p - w))\n                    current_possible.update(temp)\n                \n                for p in current_possible:\n                    new_weight = abs(amount - p)\n                    if new_weight == 0:\n                        continue\n                    new_weights = weights + [new_weight]\n                    all_new_measurable = True\n                    for a in amounts:\n                        if not can_measure(a, new_weights):\n                            all_new_measurable = False\n                            break\n                    if all_new_measurable and new_weight < min_additional:\n                        min_additional = new_weight\n        \n        if min_additional != float('inf'):\n            print(min_additional)\n        else:\n            print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 04:53:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconst int MAX_SUM = 1000000;\n\nbool canMeasure(std::vector<int>& weights, std::vector<int>& chemicals) {\n    int n = weights.size();\n    std::vector<bool> possible(2 * MAX_SUM + 1, false);\n    possible[MAX_SUM] = true; // zero difference possible\n\n    for (int weight : weights) {\n        std::vector<bool> nextPossible = possible;\n        for (int diff = 0; diff <= 2 * MAX_SUM; ++diff) {\n            if (possible[diff]) {\n                if (diff + weight <= 2 * MAX_SUM) nextPossible[diff + weight] = true;\n                if (diff - weight >= 0) nextPossible[diff - weight] = true;\n            }\n        }\n        possible = nextPossible;\n    }\n\n    for (int chemical : chemicals) {\n        if (!possible[chemical + MAX_SUM]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint findMinimumAdditionalWeight(std::vector<int>& weights, std::vector<int>& chemicals) {\n    if (canMeasure(weights, chemicals)) {\n        return 0; // No additional weight needed\n    }\n\n    for (int addWeight = 1; addWeight <= MAX_SUM; ++addWeight) {\n        weights.push_back(addWeight);\n        if (canMeasure(weights, chemicals)) {\n            return addWeight; // Found the minimum additional weight possible to measure all\n        }\n        weights.pop_back();\n    }\n\n    return -1; // Even with an additional weight it is not possible\n}\n\nint main() {\n    std::vector<int> weights = {1, 3, 9};\n    std::vector<int> chemicals = {2, 4, 10};\n\n    int result = findMinimumAdditionalWeight(weights, chemicals);\n    if (result == 0) {\n        std::cout << \"All weights can be measured with the current weights.\" << std::endl;\n    } else if (result == -1) {\n        std::cout << \"It is impossible to measure all weights even with one additional weight.\" << std::endl;\n    } else {\n        std::cout << \"The minimum additional weight needed is: \" << result << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:21:53"
  }
]