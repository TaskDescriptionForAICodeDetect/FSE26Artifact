[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\n\nint main(){\n    int n,m;\n    while(cin >> n >> m,n){\n        vector<int> a(n),w(m);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i]; \n        }\n        for (int i = 0; i < m; i++) {\n            cin >> w[i];\n        }\n        vector<int> sum(1<<m,0);\n        for (int i = 0; i < 1<<m; i++) {\n            for (int j = 0; j < m; j++) {\n                if(i&(1<<j)) sum[i]+=w[j];\n            }\n        }\n        vector<vector<int>> dp(n);\n        for (int mask = 0; mask < 1<<m; mask++) {\n            int tmask=((1<<m)-1)^mask;\n            for(int i=tmask;;i=(i-1)&tmask) {\n                for (int j = 0; j < n; j++) {\n                    dp[j].push_back(abs(sum[mask]+a[j]-sum[i]));\n                }\n                if(i==0) break;\n            }\n        }\n        vector<bool> s(n);\n        int cnt=0;\n        for (int i = 0; i < n; i++) {\n            sort(ALL(dp[i]));\n            if(dp[i][0]==0){\n                cnt++;\n                s[i]=true;\n                continue;\n            }\n            dp[i].erase(unique(ALL(dp[i])),dp[i].end());\n        }\n        if(cnt==n){\n            cout << 0 << endl;\n            continue;\n        }\n        bool f=false;\n        for (int i = 0; i < n; i++) {\n            if(s[i]) continue;\n            for (int j = 0; j < dp[i].size(); j++) {\n                bool ff=false;\n                for (int k = i+1; k < n; k++) {\n                    if(s[k]) continue;\n                    auto p = lower_bound(ALL(dp[k]),dp[i][j]);\n                    if(*p!=dp[i][j]){\n                        ff=true;\n                        break;\n                    }\n                }\n                if(!ff){\n                    cout << dp[i][j] << endl;\n                    f=true;\n                    break;\n                }\n            }\n            break;\n        }\n        if(!f) cout << -1 << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n\t//1\n\tint N,M;\n\tcin>>N>>M;\n\tif(N==0)exit(0);\n\tint A[100],W[10]={0,0,0,0,0,0,0,0,0,0};\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>A[i];\n\t}\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tcin>>W[i];\n\t}\n\n\tvector<int>diffs;\n\tfor(int i0=0;i0<3;i0++)\n\t\tfor(int i1=0;i1<3;i1++)\n\t\t\tfor(int i2=0;i2<3;i2++)\n\t\t\t\tfor(int i3=0;i3<3;i3++)\n\t\t\t\t\tfor(int i4=0;i4<3;i4++)\n\t\t\t\t\t\tfor(int i5=0;i5<3;i5++)\n\t\t\t\t\t\t\tfor(int i6=0;i6<3;i6++)\n\t\t\t\t\t\t\t\tfor(int i7=0;i7<3;i7++)\n\t\t\t\t\t\t\t\t\tfor(int i8=0;i8<3;i8++)\n\t\t\t\t\t\t\t\t\t\tfor(int i9=0;i9<3;i9++)\n\t{\n\t\tint W_L=0,W_R=0;\n\t\tif(i0==1)W_L=W_L+W[0];\n\t\telse if(i0==2)W_R=W_R+W[0];\n\t\tif(i1==1)W_L=W_L+W[1];\n\t\telse if(i1==2)W_R=W_R+W[1];\n\t\tif(i2==1)W_L=W_L+W[2];\n\t\telse if(i2==2)W_R=W_R+W[2];\n\t\tif(i3==1)W_L=W_L+W[3];\n\t\telse if(i3==2)W_R=W_R+W[3];\n\t\tif(i4==1)W_L=W_L+W[4];\n\t\telse if(i4==2)W_R=W_R+W[4];\n\t\tif(i5==1)W_L=W_L+W[5];\n\t\telse if(i5==2)W_R=W_R+W[5];\n\t\tif(i6==1)W_L=W_L+W[6];\n\t\telse if(i6==2)W_R=W_R+W[6];\n\t\tif(i7==1)W_L=W_L+W[7];\n\t\telse if(i7==2)W_R=W_R+W[7];\n\t\tif(i8==1)W_L=W_L+W[8];\n\t\telse if(i8==2)W_R=W_R+W[8];\n\t\tif(i9==1)W_L=W_L+W[9];\n\t\telse if(i9==2)W_R=W_R+W[9];\n\n\t\tint diff=abs(W_L-W_R);\n\t\tdiffs.push_back(diff);\n\t}\n\tsort(diffs.begin(),diffs.end());\n\tdiffs.erase(unique(diffs.begin(),diffs.end()),diffs.end());\n\n\t//2,3\n\tvector<int>Y;\n\tbool first=true;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tvector<int>X;\n\t\tbool flag=false;\n\t\tfor(int j=0;j<diffs.size();j++)\n\t\t{\n\t\t\tint diff=diffs.at(j);\n\t\t\tX.push_back(diff+A[i]);\n\t\t\tif(diff>=A[i])\n\t\t\t{\n\t\t\t\tX.push_back(diff-A[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tX.push_back(A[i]-diff);\n\t\t\t}\n\t\t\tif(diff==A[i])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(flag==false)\n\t\t{\n\t\t\tsort(X.begin(),X.end());\n\t\t\tX.erase(unique(X.begin(),X.end()),X.end());\n\n\t\t\tif(first==true)\n\t\t\t{\n\t\t\t\tfirst=false;\n\t\t\t\tY=X;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector<int>result;\n\t\t\t\tset_intersection(Y.begin(),Y.end(),\n\t\t\t\t\t\t\t\tX.begin(),X.end(),\n\t\t\t\t\t\t\t\tinserter(result,result.end()));\n\t\t\t\tY=result;\n\t\t\t}\n\t\t}\n\t}\n\tif(first==true)\n\t{\n\t\tcout<<0<<endl;\n\t}\n\telse\n\t{\n\t\tif(Y.size()==0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<Y[0]<<endl;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(true)\n\t{\n\t\tsolve();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \n#define M_PI       3.14159265358979323846\n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <ll> par; \n    vector <ll> siz; \n    \n    vector <ll> maxv;\n    UnionFind(ll sz_): par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    ll root(ll x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(ll x, ll y) { \n        return root(x) == root(y);\n    }\n \n    ll size(ll x) { \n        return siz[root(x)];\n    }\n};\n \n \nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid make_sieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n \n \n \nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\n \npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n \n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n \n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] += lazy[k];\n            if(r - l > 1) {\n                lazy[2*k+1] += lazy[k] / 2;\n                lazy[2*k+2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\n \n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = node[2*k+1] + node[2*k+2];\n        }\n    }\n \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n};\n\nint const INF = INT_MAX;\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<int> node;\n\npublic:\n    SegmentTree(vector<int> v) {\n        int sz = v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, INF);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n\n    void update(int x, int val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n\n    int getmin(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node[k];\n\n        int vl = getmin(a, b, 2*k+1, l, (l+r)/2);\n        int vr = getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Flow cap;\n    Edge() : src(0), dst(0), weight(0) {}\n    Edge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n \nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n    g[a].emplace_back(a, b, w);\n    g[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n// template<typename T> class basic_stopwatch: T {\n//     typedef typename T BaseTimer;\n\n// public:\n//     explicit basic_stopwatch(bool start);\n//     explicit basic_stopwatch(char const* activity = \"Stopwatch\", bool start = true);\n//     basic_stopwatch(std::ostream& log, char const* activity = \"Stopwatch\", bool start = true);\n//     basic_stopwatch();\n//     unsigned LapGet() const;\n//     bool IsStarted() const;\n//     unsigned Show(char const* event = \"show\");\n//     unsigned Start(char const* event_name = \"start\");\n//     unsigned Stop(char const* event_name = \"stop\");\n// private:\n//     char const*     m_activity;\n//     unsigned        m_lap;\n//     std::ostream&   m_log;\n// };\n\n// #include <chrono>\n// using namespace std::chrono;\n// class TimerBase {\n// public: \n\n//     // タイマをクリアする\n//     TimerBase(): m_start(system_clock::time_point::min()) {}\n\n//     void Clear(){\n//         m_start = system_clock::time_point::min();\n//     }\n\n//     bool IsStarted() const {\n//         return (m_start.time_since_epoch() != system_clock::duration(0));\n//     }\n\n//     void Start() {\n//         m_start = system_clock::now();\n//     }\n\n//     unsigned long GetMs(){\n//         if(IsStarted()) {\n//             system_clock::duration diff;\n//             diff = system_clock::now() - m_start;\n//             return (unsigned)(duration_cast<milliseconds>(diff).const();\n//         }\n//         return 0;\n//     }\n// private:\n//     system_clock::time_point m_start;\n// };\nbool ok[110];\n\nset<ll> makeable;\n\nvoid dfs(ll idx, ll left, ll right, vector<ll>&a, vector<ll>&w){\n\n    if(idx == w.size()){\n        makeable.insert(left-right);\n        for(int i=0; i<a.size(); i++){\n            if(left+a[i] == right || left == right+a[i]){\n                ok[i] = true;\n            }\n        }\n        return;\n    }\n\n    dfs(idx+1, left+w[idx], right,a,w);\n    dfs(idx+1, left, right + w[idx],a,w);\n    dfs(idx+1, left, right,a,w);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    \n    int n, m;\n    while(cin >> n >> m, n&&m){\n        makeable.clear();\n        vector<ll> a(n); REP(i,n) cin >> a[i];\n        vector<ll> w(m); REP(i,m) cin >> w[i];\n        for(int i=0; i<n; i++)ok[i] = false;\n\n        dfs(0, 0, 0, a, w);\n\n        bool check = true;\n        \n        vector<ll> need;\n        for(int i=0; i<n; i++){\n            if(!ok[i]){\n                need.push_back(i);\n                check = false;\n            }else{\n                \n            }\n        }\n        if(check){\n            cout << 0 << endl;\n        }else{\n            \n            set<ll> cand;\n            \n            /* とりあえず候補を列挙する */\n            for(auto e: makeable){\n                cand.insert(abs(e+a[need[0]]));\n            }\n            \n            for(int i=1; i<need.size(); i++){\n                int idx = need[i];\n                set<ll> nxt;\n                for(auto e: makeable){\n                    if(cand.find(abs(e+a[idx])) != cand.end()){\n                        nxt.insert(abs(e+a[idx]));\n                    }\n                }\n                cand = nxt;\n            }\n            \n            ll mi = (1LL<<60);\n            for(auto e: cand){\n                mi = min(mi, e);\n                break;\n            }\n            \n            \n            if(cand.size() == 0){\n                cout << -1 << endl;\n            }\n            else{\n                cout << mi << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint pow3(int j){\n  return (j==0)?(1):(3*pow3(j-1));\n}\nint q=1;\nint main(void){\n  for(;;){\n    int n,m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ return 0; }\n    int a[n];\n    for(int i=0;i<n;i++){\n      cin >> a[i];\n    }\n    int w[m];\n    for(int i=0;i<m;i++){\n      cin >> w[i];\n    }\n    \n    int measurable[pow3(m)];\n    for(int i=0;i<pow3(m);i++){ measurable[i]=0; }    \n    for(int i=0;i<pow3(m);i++){\n      for(int j=0;j<m;j++){\n\tif((i/pow3(j))%3==1){ measurable[i]+=w[j]; }\n\tif((i/pow3(j))%3==2){ measurable[i]-=w[j]; }\n      }\n    }\n\n    int candidate[pow3(m)];\n    int intersection[pow3(m)];\n    bool buyweight=false;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<pow3(m);j++){\n\tcandidate[j] = abs(measurable[j] - a[i]);\n      }\n      sort(candidate,candidate+pow3(m));\n\n      if(candidate[0]==0){\n      }else{\n\tif(buyweight==false){\n\t  for(int j=0;j<pow3(m);j++){\n\t    intersection[j] = candidate[j];\n\t  }\n\t  buyweight=true;\n\t}else{\n\t  int j=0; int k=0;\n\t  while(j<pow3(m) && k<pow3(m)){\n\t    if(intersection[k] == -1){\n\t      k++;\n\t    }else if(candidate[j] == intersection[k]){\n\t      j++; k++;\n\t    }else if(candidate[j] < intersection[k]){\n\t      j++;\n\t    }else{\n\t      intersection[k]=-1; k++;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    if(buyweight==false){\n      cout << 0 << endl;\n    }else{\n      int ans=-1;\n      for(int j=0;j<pow3(m);j++){\n\tif(intersection[j]>=0){ ans=intersection[j]; break; }\n      }\n      cout << ans << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\nint N,M;\nll a[105],weight[15];\nmap<ll,bool> MAP,PRE,CURRENT;\nvector<ll> V,CAN_NOT;\n\nvoid recursive(int index,ll add_sum){\n\n\tif(index == M){\n\n\t\tMAP[add_sum] = true;\n\t\tV.push_back(add_sum);\n\n\t\treturn;\n\t}\n\n\t//足さない\n\trecursive(index+1,add_sum);\n\n\t//+(-weight[index])\n\trecursive(index+1,add_sum-weight[index]);\n\n\t//+weight[index]\n\trecursive(index+1,add_sum+weight[index]);\n}\n\nvoid func(){\n\n\tMAP.clear();\n\tV.clear();\n\tCAN_NOT.clear();\n\tPRE.clear();\n\tCURRENT.clear();\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%lld\",&weight[i]);\n\t}\n\n\trecursive(0,0);\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\tbool FLG = true;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tauto at = MAP.find(a[i]);\n\n\t\tif(at == MAP.end()){\n\t\t\tFLG = false;\n\t\t\tCAN_NOT.push_back(a[i]);\n\t\t}\n\t}\n\n\tif(FLG){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tll ans = HUGE_NUM;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tPRE[abs(CAN_NOT[0]-V[i])] = true;\n\t\tif(CAN_NOT.size() == 1){ //コーナーケース\n\n\t\t\tans = min(ans,abs(CAN_NOT[0]-V[i]));\n\t\t}\n\t}\n\n\tfor(int i = 1; i < CAN_NOT.size(); i++){\n\n\t\tfor(int k = 0; k < V.size(); k++){\n\n\t\t\tauto at = PRE.find(abs(CAN_NOT[i]-V[k]));\n\n\t\t\tif(at != PRE.end()){\n\n\t\t\t\tCURRENT[abs(CAN_NOT[i]-V[k])] = true;\n\n\t\t\t\tif(i == CAN_NOT.size()-1){\n\n\t\t\t\t\tans = min(ans,abs(CAN_NOT[i]-V[k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPRE.clear();\n\t\tPRE = CURRENT;\n\t\tCURRENT.clear();\n\t}\n\n\tif(ans == HUGE_NUM){\n\n\t\tprintf(\"-1\\n\");\n\t}else{\n\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\ntypedef long long int ll;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\n    // clang-format on\n\n#include <functional>\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    while (cin >> n >> m, n + m) {\n        vector<ll> a(n);\n        REP(i, 0, n) {\n            cin >> a[i];\n        }\n        vector<ll> w(m);\n        REP(i, 0, m) {\n            cin >> w[i];\n        }\n        vector<vector<ll>> v(n);\n        function<void(ll, int, int)> rec = [&](ll sum, int pos, int t) {\n            if (pos == m) {\n                v[t].push_back(abs(sum));\n                return;\n            }\n            REP(i, -1, 2) {\n                rec(sum + i * w[pos], pos + 1, t);\n            }\n        };\n        REP(i, 0, n) {\n            rec(a[i], 0, i);\n        }\n\n        int cnt = 0;\n        vector<ll> ans;\n        bool ft = true;\n\n        REP(t, 0, n) {\n            sort(v[t].begin(), v[t].end());\n            v[t].erase(unique(v[t].begin(), v[t].end()), v[t].end());\n            if (v[t][0] == 0) {\n                cnt++;\n                continue;\n            }\n            if (ft) {\n                ft = false;\n                ans = v[t];\n            } else {\n                vector<ll> tmp;\n                set_intersection(ans.begin(), ans.end(), v[t].begin(), v[t].end(), inserter(tmp, tmp.end()));\n                ans = tmp;\n            }\n        }\n\n        if (cnt == n) {\n            cout << 0 << endl;\n        } else if (ans.size() == 0) {\n            cout << -1 << endl;\n        } else {\n            cout << ans[0] << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define rrep(ri,n) for(int ri = (int)(n-1); ri >= 0; ri--)\n#define rep2(i,x,n) for(int i = (int)(x); i < (int)(n); i++)\n#define repit(itr,x) for(auto itr = x.begin(); itr != x.end(); itr++)\n#define rrepit(ritr,x) for(auto ritr = x.rbegin(); ritr != x.rend(); ritr++)\n#define ALL(n) begin(n), end(n)\nusing ll = long long;\nusing namespace std;\n\nint main(){\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\tvector<ll> a(n);\n\t\trep(snip_i, n) cin >> a.at(snip_i);\n\t\tvector<ll> w(m);\n\t\trep(snip_i, m) cin >> w.at(snip_i);\n\t\tsort(w.begin(), w.end());\n\t\tmap<ll, int> mp;\n\t\tmp.clear();\n\t\trep(i, pow(3, m)){\n\t\t\tll sum = 0;\n\t\t\tint ii = i;\n\t\t\trep(j, m){\n\t\t\t\tif(ii % 3 == 0) sum += w.at(j);\n\t\t\t\tif(ii % 3 == 1) sum -= w.at(j);\n\t\t\t\tii /= 3;\n\t\t\t}\n\t\t\tmp[sum] = i;\n\t\t}\n\t\tvector<ll> nf;\n\t\trep(i, n){\n\t\t\tll now = a.at(i);\n\t\t\tif(mp.count(now) == 0){\n\t\t\t\tnf.push_back(now);\n\t\t\t}\n\t\t}\n\t\tif(nf.size() == 0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tll fst = nf.at(0);\n\t\tll ans = 1e18;\n\t\tfor(auto p : mp){\n\t\t\tll add =fabs(fst - p.first);\n\t\t\tbool flag = true;\n\t\t\trep2(j, 1, nf.size()){\n\t\t\t\tll now = nf.at(j);\n\t\t\t\tif(mp.count(now-add) == 0 && mp.count(now+add) == 0){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == true){\n\t\t\t\tans = min(ans, add);\n\t\t\t}\n\t\t}\n\t\tif(ans == 1e18) ans = -1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 110;\nint n, m;\nvector<int> all_m;\nvoid dfs(int d, int s, vector<int> w)\n{\n\tif(d >= m)\n\t{\n\t\tall_m.push_back(s);\n\t\treturn ;\n\t}\n\tdfs(d + 1, s, w);\n\tdfs(d + 1, s + w[d] ,w);\n\tdfs(d + 1, abs(s - w[d]), w);\n}\nint main() \n{\n\twhile(scanf(\"%d%d\", &n, &m))\n\t{\n\t\tif(!n && !m) break;\n\t\tall_m.clear();\n\t\tvector<int> a(n), w(m);\n\t\tfor(int i = 0; i < n; i++) cin >> a[i];\n\t\tfor(int i = 0; i < m; i++) cin >> w[i];\n\t\tsort(a.begin(), a.end());\n\t\ta.erase(unique(a.begin(), a.end()), a.end());\n\t\tdfs(0, 0, w);\n\t\tsort(all_m.begin(), all_m.end());\n\t\tall_m.erase(unique(all_m.begin(), all_m.end()), all_m.end());\n\t\tfor(int i = 0; i < all_m.size(); i++)\n\t\t{\n\t\t\tfor(int j = 0; j < a.size(); j++)\n\t\t\t{\n\t\t\t\tif(all_m[i] == a[j])\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t}\n\t\t}\n\t\tif(a.empty())\n\t\t{\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tvector<vector<int> >  mul(a.size() + 1);\n\t\tfor(int i = 0; i < a.size(); i ++)\n\t\t{\n\t\t\tfor(int j = 0; j < all_m.size(); j++)\n\t\t\t{\n\t\t\t\tmul[i].push_back(a[i] + all_m[j]);\n\t\t\t\tmul[i].push_back(abs(a[i] - all_m[j]));\n\t\t\t}\n\t\t\tsort(mul[i].begin(), mul[i].end());\n\t\t\tmul[i].erase(unique(mul[i].begin(), mul[i].end()), mul[i].end());\n\t\t}\n\t\t\n\t\tvector<int> res = mul[0];\n\t\t\n\t\tfor(int k = 1; k < a.size(); k++)\n\t\t{\n\t\t\tvector<int> l1 = res;\n\t\t\tvector<int> l2 = mul[k]; \n\t\t\tint i = 0, j = 0;\n\t\t\tres.clear();\n\t\t\twhile(i < l1.size() && j < l2.size())\n\t\t\t{\n\t\t\t\tif(l1[i] < l2[j])\n\t\t\t\t\t++i;\n\t\t\t\telse if(l1[i] > l2[j])\n\t\t\t\t\t++j;\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tif(res.empty() || res[res.size() - 1] != l1[i]) res.push_back(l1[i]);\n\t\t\t\t\t++i, ++j;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\t\n\t\tif(res.empty()) printf(\"-1\\n\");\n\t\telse \n\t\t\tprintf(\"%d\\n\", res[0]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\nint n,m,a[100],b[10],ok;\nint main(void){\n    while(1){\n    cin>>n>>m;\n    //cout<<n<<\" \"<<m<<endl;\n    if(n==0&&m==0)return 0;\n    for(int i=0;i<n;i++)cin>>a[i];\n    for(int i=0;i<m;i++)cin>>b[i];\n    map<int,int> mp;\n    set<int> se;\n    vector<int> v,u;\n    mp[0]=1;\n    ok=0;\n    for(int i=0;i<m;i++){\n        v={};\n        for(auto x:mp)v.push_back(x.F);\n        for(auto x:v){\n            if(x-b[i]>0)mp[x-b[i]]=1;\n            if(b[i]-x>0)mp[b[i]-x]=1;\n            if(b[i]+x)mp[b[i]+x]=1;\n        }\n    }\n    for(auto x:mp)u.push_back(x.F);\n    for(int i=0;i<n;i++){\n        if(mp[a[i]]==1)continue;\n        //for(auto x:u)cout<<x;\n        //cout<<endl;\n        if(se.empty()&&ok==0){\n            ok=1;\n            for(auto x:u){\n                if(x-a[i]>0)se.insert(x-a[i]);\n                if(a[i]-x>0)se.insert(a[i]-x);\n                if(a[i]+x)se.insert(a[i]+x);\n            }\n        }\n        else{\n            set<int> se1;\n            for(auto x:u){\n                if(x-a[i]>0&&se.count(x-a[i])){se1.insert(x-a[i]);}\n                if(a[i]-x>0&&se.count(a[i]-x)){se1.insert(a[i]-x);}\n                if(a[i]+x&&se.count(a[i]+x)){se1.insert(a[i]+x);}\n            }\n            //cout<<endl;\n            se.clear();\n            se=se1;\n        }\n    }\n    if(ok==0){cout<<0<<endl;}\n    else if(se.empty()){cout<<-1<<endl;}\n    else{\n        auto itr=se.begin();\n    //itr--;\n    cout<<*itr<<endl;}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Int = long long;\nusing ll = long long;\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  Int n,m;\n  while(cin>>n>>m,n||m){\n    vector<Int> as(n),ws(m);\n    for(Int i=0;i<n;i++) cin>>as[i];\n    for(Int i=0;i<m;i++) cin>>ws[i];\n\n    Int s=1<<m;\n    vector<Int> sm(s,0);\n    for(Int b=0;b<s;b++)\n      for(Int i=0;i<m;i++)\n        if((b>>i)&1) sm[b]+=ws[i];\n\n    vector<Int> ts;\n    ts.emplace_back(0);\n    for(Int b=0;b<s;b++){\n      for(Int c=0;c<s;c++){\n        if(b&c) continue;\n        ts.emplace_back(abs(sm[b]-sm[c]));\n      }\n    }\n    sort(ts.begin(),ts.end());\n    ts.erase(unique(ts.begin(),ts.end()),ts.end());\n\n    vector<Int> bs;\n    for(Int a:as)\n      if(!binary_search(ts.begin(),ts.end(),a)) bs.emplace_back(a);\n\n    vector<Int> cand(bs);\n    for(Int a:bs){\n      for(Int x:ts){\n        cand.emplace_back(abs(a-x));\n        cand.emplace_back(abs(a+x));\n      }\n      break;\n    }\n\n    cand.emplace_back(0);\n    sort(cand.begin(),cand.end());\n    cand.erase(unique(cand.begin(),cand.end()),cand.end());\n\n    Int ng=1;\n    for(Int x:cand){\n      Int ok=1;\n\n      for(Int a:bs)\n        ok&=\n          binary_search(ts.begin(),ts.end(),abs(a-x))||\n          binary_search(ts.begin(),ts.end(),abs(a+x));\n\n      if(ok){\n        cout<<x<<endl;\n        ng=0;\n        break;\n      }\n    }\n\n    if(ng) cout<<-1<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//ICPC C\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nconst ll mod=1e9+7;\n\nint main(){\n    vector<int> answers;\n    while(1){\n        int n,m;\n        cin>>n>>m;\n        if(n==0&&m==0) break;\n        vector<ll> a(n);\n        vector<ll> w(m);\n        for(int i=0;i<n;i++){\n            cin>>a[i];\n        }\n        for(int i=0;i<m;i++){\n            cin>>w[i];\n        }\n\n        //既存の分銅で量れる質量\n        vector<ll> p;\n        for(int i=0;i<pow(3,m);i++){\n            ll tmp=i;\n            ll val=0LL;\n            for(int j=0;j<m;j++){\n                int amari=tmp%3;\n                if(amari==1){\n                    val+=w[j];\n                }else if(amari==2){\n                    val-=w[j];\n                }\n                tmp/=3;\n            }\n            if(val>=0) p.push_back(val);\n        }\n        sort(p.begin(),p.end());\n\n        //既存の分銅では作れない量のリストを作成\n        vector<ll> targets;\n        for(auto aim:a){\n            if(!binary_search(p.begin(),p.end(),aim)) targets.push_back(aim);\n        }\n        if(targets.empty()){\n            answers.push_back(0);\n            continue;\n        }\n\n        //各作れない量と量れる量の差の絶対値\n        vector<vector<ll>> diff(targets.size(),vector<ll>(p.size()*2));\n        for(int i=0;i<targets.size();i++){\n            for(int j=0;j<p.size();j++){\n                diff[i][j]=abs(targets[i]-p[j]);\n                diff[i][p.size()+j]=targets[i]+p[j];\n            }\n            sort(diff[i].begin(),diff[i].end());\n        }\n\n        //targets[0]を作るための追加分銅候補で他のも作れるかを判定\n        bool find=false;\n        for(int i=0;i<diff[0].size();i++){\n            bool flag=true;\n            for(int j=1;j<targets.size();j++){\n                if(!binary_search(diff[j].begin(),diff[j].end(),diff[0][i])){\n                    flag=false;\n                    continue;\n                }\n            }\n            if(flag){\n                answers.push_back(diff[0][i]);\n                find=true; break;\n            }\n        }\n\n        if(!find) answers.push_back(-1);\n      \n    }\n    for(auto ans:answers){\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\n\nvector<int> a,w;\nset<int> can;\nvoid dfs(int idx,int left_w,int right_w){\n    if(idx==w.size()){\n        can.insert(abs(left_w-right_w));\n        return;\n    }\n    dfs(idx+1,left_w+w[idx],right_w); // 右に乗せる\n    dfs(idx+1,left_w,right_w+w[idx]); // 左に乗せる\n    dfs(idx+1,left_w,right_w); // 使わない\n    return;\n}\n\nsigned main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n+m==0)break;\n        a.resize(n);\n        w.resize(m);\n        for(int i=0;i<n;i++)cin>>a[i];\n        for(int i=0;i<m;i++)cin>>w[i];\n        can.clear();\n        dfs(0,0,0);\n        \n        for(int i=0;i<a.size();i++){\n            if(can.find(a[i])!=can.end()){\n                a.erase(a.begin()+i);\n                i--;\n            }\n        }\n\n        if(a.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        vector<set<int>> v(a.size());\n        for(int i=0;i<a.size();i++){\n            for(auto s:can){\n                v[i].insert(abs(a[i]-s));\n                v[i].insert(abs(a[i]+s));\n            }\n        }\n\n        auto intersection=[&](set<int>& A, set<int>& B){\n            set<int> ret;\n            for(auto a:A){\n                if(B.find(a)!=B.end()){\n                    ret.insert(a);\n                }\n            }\n            return ret;\n        };\n        set<int> res=v[0];\n        for(int i=1;i<v.size();i++){\n            res=intersection(res,v[i]);\n        }\n        if(res.size()==0)cout<<-1<<endl;\n        else cout<<*(res.begin())<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid solve()\n{\n\t//1\n\tint N,M;\n\tcin>>N>>M;\n\tif(N==0)exit(0);\n\tint A[100],W[10]={0,0,0,0,0,0,0,0,0,0};\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>A[i];\n\t}\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tcin>>W[i];\n\t}\n\n\tvector<int>diffs;\n\tfor(int i0=0;i0<3;i0++)\n\t\tfor(int i1=0;i1<3;i1++)\n\t\t\tfor(int i2=0;i2<3;i2++)\n\t\t\t\tfor(int i3=0;i3<3;i3++)\n\t\t\t\t\tfor(int i4=0;i4<3;i4++)\n\t\t\t\t\t\tfor(int i5=0;i5<3;i5++)\n\t\t\t\t\t\t\tfor(int i6=0;i6<3;i6++)\n\t\t\t\t\t\t\t\tfor(int i7=0;i7<3;i7++)\n\t\t\t\t\t\t\t\t\tfor(int i8=0;i8<3;i8++)\n\t\t\t\t\t\t\t\t\t\tfor(int i9=0;i9<3;i9++)\n\t{\n\t\tint W_L=0,W_R=0;\n\t\tif(i0==1)W_L=W_L+W[0];\n\t\telse if(i0==2)W_R=W_R+W[0];\n\t\tif(i1==1)W_L=W_L+W[1];\n\t\telse if(i1==2)W_R=W_R+W[1];\n\t\tif(i2==1)W_L=W_L+W[2];\n\t\telse if(i2==2)W_R=W_R+W[2];\n\t\tif(i3==1)W_L=W_L+W[3];\n\t\telse if(i3==2)W_R=W_R+W[3];\n\t\tif(i4==1)W_L=W_L+W[4];\n\t\telse if(i4==2)W_R=W_R+W[4];\n\t\tif(i5==1)W_L=W_L+W[5];\n\t\telse if(i5==2)W_R=W_R+W[5];\n\t\tif(i6==1)W_L=W_L+W[6];\n\t\telse if(i6==2)W_R=W_R+W[6];\n\t\tif(i7==1)W_L=W_L+W[7];\n\t\telse if(i7==2)W_R=W_R+W[7];\n\t\tif(i8==1)W_L=W_L+W[8];\n\t\telse if(i8==2)W_R=W_R+W[8];\n\t\tif(i9==1)W_L=W_L+W[9];\n\t\telse if(i9==2)W_R=W_R+W[9];\n\n\t\tint diff=abs(W_L-W_R);\n\t\tdiffs.push_back(diff);\n\t}\n\tsort(diffs.begin(),diffs.end());\n\tdiffs.erase(unique(diffs.begin(),diffs.end()),diffs.end());\n\n\t//2,3\n\tvector<int>Y;\n\tbool first=true;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tvector<int>X;\n\t\tbool flag=false;\n\t\tfor(int j=0;j<diffs.size();j++)\n\t\t{\n\t\t\tint diff=diffs.at(j);\n\t\t\tX.push_back(diff+A[i]);\n\t\t\tif(diff>=A[i])\n\t\t\t{\n\t\t\t\tX.push_back(diff-A[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tX.push_back(A[i]-diff);\n\t\t\t}\n\t\t\tif(diff==A[i])\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\tif(flag==false)\n\t\t{\n\t\t\tsort(X.begin(),X.end());\n\t\t\tX.erase(unique(X.begin(),X.end()),X.end());\n\n\t\t\tif(first==true)\n\t\t\t{\n\t\t\t\tfirst=false;\n\t\t\t\tY=X;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvector<int>result;\n\t\t\t\tset_intersection(Y.begin(),Y.end(),\n\t\t\t\t\t\t\t\tX.begin(),X.end(),\n\t\t\t\t\t\t\t\tinserter(result,result.end()));\n\t\t\t\tY=result;\n\t\t\t}\n\t\t}\n\t}\n\tif(first==true)\n\t{\n\t\tcout<<0<<endl;\n\t}\n\telse\n\t{\n\t\tif(Y.size()==0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout<<Y[0]<<endl;\n\t\t}\n\t}\n}\nint main()\n{\n\twhile(true)\n\t{\n\t\tsolve();\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    int N,M;\n    while(cin >> N >> M && N){\n        vector<int> A(N),W(M);\n        for(int i=0;i<N;i++) cin >> A[i];\n        for(int i=0;i<M;i++) cin >> W[i];\n        set<int> s;\n        for(int S=0;S<(1<<M);S++){\n            for(int T=S;T>=0;T=(T-1)&S){\n                int x = 0,y = 0;\n                for(int i=0;i<M;i++){\n                    if((S&(1<<i)) && (T&(1<<i))) x += W[i];\n                    else if((S&(1<<i)) && !(T&(1<<i))) y += W[i];\n                }\n                s.insert(x-y);\n                if(T==0) break;\n            }\n        }\n        vector<int> unable;\n        for(int i=0;i<N;i++){\n            if(s.count(A[i])==0 && s.count(-A[i])==0) unable.push_back(A[i]);\n        }\n        if(unable.empty()){\n            cout << 0 << endl;\n            continue;\n        }\n        set<int> kouho;\n        for(auto a:s){\n            kouho.insert(abs(a-unable[0]));\n            kouho.insert(abs(a+unable[0]));\n        }\n        for(auto u:unable){//O(N)\n            if(kouho.empty()) break;\n            set<int> nkouho;\n            for(auto k:kouho){//O(3^M)\n                if(s.count(u-k)!=0 || s.count(u+k)!=0 || s.count(-u-k)!=0 || s.count(-u+k)!=0) nkouho.insert(k);\n            }\n            kouho = nkouho;\n        }\n        cout << (!kouho.empty()? *kouho.begin():-1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n, m, a[123], w[12];\nint main()\n{\n\twhile(cin >> n >> m && m && n)\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor(int i = 0; i < m; i++)\n\t\t\tcin >> w[i];\n\t\tunordered_set<long long>st;\n\t\tst.insert(0);\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tunordered_set<long long>st1;\n\t\t\tfor(auto r : st)\n\t\t\t{\n\t\t\t\tst1.insert(r+w[i]);\n\t\t\t\tst1.insert(abs(r-w[i]));\n\t\t\t}\n\t\t\tfor(auto r : st1)\n\t\t\t\tst.insert(r); \n\t\t}\n\t\tint cnt = 0;\n\t\tlong long ans = -1;\n\t\tvector<long long>newa;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(st.find(a[i]) == st.end())\n\t\t\t\tnewa.push_back(a[i]);\n\t\tcnt = newa.size();\n\t\t\n\t\tif(!cnt)\n\t\t\tans = 0;\n\t\telse if(cnt <= 2*st.size())\n\t\t{\n\t\t\tset<long long>neww;\n\t\t\tfor(auto r : st)\n\t\t\t{\n\t\t\t\tneww.insert(r+newa[0]);\n\t\t\t\tneww.insert(abs(r-newa[0]));\n\t\t\t}\n\t\t\tfor(auto r : neww)\n\t\t\t{\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tfor(auto rr : newa)\n\t\t\t\t\tif(st.find(rr+r) != st.end() || st.find(abs(rr-r)) != st.end())\n\t\t\t\t\t\tcnt1++;\n//\t\t\t\t\telse\n//\t\t\t\t\t\tbreak;\n\t\t\t\tif(cnt1 == cnt)\n\t\t\t\t{\n\t\t\t\t\tans = r;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <math.h>\nusing namespace std;\ntypedef long long int ll;\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,m;\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tvector<int> a(n),w(m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor(int j=0;j<m;j++){\n\t\t\tcin >> w[j];\n\t\t}\n\t\tset<int> s;\n\t\tfor(int i=0;i<pow(3,m);i++){\n\t\t\tint x=0,y=0;\n\t\t\tint cp=i;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(cp%3==0){\n\t\t\t\t\tx+=w[j];\n\t\t\t\t}\n\t\t\t\telse if(cp%3==1){\n\t\t\t\t\ty+=w[j];\n\t\t\t\t}\n\t\t\t\tcp/=3;\n\t\t\t}\n\t\t\ts.insert(x-y);\n\t\t}\n\t\tvector<int> v;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(s.find(a[i])==s.end())v.push_back(a[i]);\n\t\t}\n\t\tif(v.size()==0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tset<int> st;\n\t\tfor(auto p:s){\n\t\t\tst.insert(abs(p-v[0]));\n\t\t\tst.insert(abs(p+v[0]));\n\t\t}\n\t\tfor(auto q:v){\n\t\t\tif(st.empty())break;\n\t\t\tset<int> st2;\n\t\t\tfor(auto p:st){\n\t\t\t\tif(s.count(q+p)!=0||s.count(-q+p)!=0||s.count(-q-p)!=0||s.count(q-p)!=0){\n\t\t\t\t\tst2.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tst=st2;\n\t\t}\n\t\tcout << (st.empty()?-1:*st.begin()) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nint main() {\n    for (;;) {\n        int N, M; cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        vector<int> A(N), W(M);\n        for (auto &a : A) cin >> a;\n        for (auto &w : W) cin >> w;\n        set<Int> S;\n        for (int i = 0, ma = pow(3, M); i < ma; i++) {\n            int t = i;\n            Int val = 0;\n            for (int j = 0; j < M; j++) {\n                val += (t % 3 == 0 ? 0 : t % 3 == 1 ? W[j] : -W[j]);\n                t /= 3;\n            }\n            if (val >= 0) S.insert(val);\n        }\n        vector<int> rest;\n        for (auto a : A) if (!S.count(a)) rest.push_back(a);\n        if (rest.empty()) {\n            cout << 0 << '\\n';\n        } else {\n            Int ans = 1e18;\n            auto f = [&](int x) {\n                if (x <= 0 || x >= ans) return;\n                bool ok = true;\n                for (auto r : rest) {\n                    if (!S.count(r - x) && !S.count(r + x) && !S.count(x - r)) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) ans = x;\n            };\n            for (auto a : S) {\n                for (auto r : rest) {\n                    f(r - a); // a + x == r\n                    f(a - r); // a - x == r\n                    f(r + a); // x - a == r\n                }\n            }\n            if (ans == 1e18) ans = -1;\n            cout << ans << '\\n';\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5;\nint n, m;\nint bs3[15];\nll a[105], w[15];\nll lfw[maxn], rtw[maxn];\nvector<ll> v[105], tmp;\nll solve()\n{\n    for(int i = 0; i < n; ++i)\n        v[i].clear();\n    int mx = bs3[m];\n    for(int i = 1; i < mx; ++i){//遍历 3的m次方种组合方式{\n        lfw[i] = rtw[i] = 0;\n        int ii = i;\n        for(int j = 0; j < m; ++j){\n            /*  相当于按位枚举 如13 就相当于 111 14相当于211\n                                  28  相当于 100 30      010\n            */\n            int rm = ii%3;\n            if(rm == 0) { }//不添加\n            else if(rm == 1)//左天平\n                lfw[i] += w[j];\n            else            //右天平\n                rtw[i] += w[j];\n            ii /= 3;//下一个砝码 所处于的状态\n        }\n    }\n    int tot = 0;\n    // printf(\"mask: %lld\\n\", mask);\n    for(int i = 0; i < n; ++i)//枚举药品\n    {\n        bool ok = false;\n        for(int j = 0; j < mx; ++j)//枚举所有组合\n        {\n            ll lf = lfw[j], rt = rtw[j];\n            ll nd = abs(lf - rt - a[i]);\n            //cout << lf << rt << endl;\n            if(nd == 0)//天平平衡\n            {\n                ok = true;\n                break;\n            }\n        }\n        if(ok)\n            continue;\n        for(int j = 0; j < mx; ++j)//不平衡 则把所有情况所需砝码（即可满足解）储存\n        {\n            ll lf = lfw[j], rt = rtw[j];\n            ll nd = abs(lf - rt - a[i]);\n            v[tot].push_back(nd);\n        }\n        //vecotr去重 先排序 然后用unique (本质是将无重复序列放在前端覆盖重复序列 即大小并未改变)\n        // 并返回无重复序列的终端\n        sort(v[tot].begin(), v[tot].end());\n        v[tot].erase(unique(v[tot].begin(), v[tot].end()), v[tot].end());\n        ++tot;\n    }\n    if(tot == 0)//初始时即平衡\n        return 0;\n    for(int i = 1; i < tot; ++i)\n    {\n        // printf(\"%d: \", i);\n        // for(auto x:v[¨]) {\n        // printf(\" %lld\", x);\n        // } // puts(\"\");\n        tmp.clear();\n        //set_intersection 并不是只适用于set 而是适用于有set性质的函数 即排序无重复的\n        //并且只是复制给另一个容器 所以通过back_inserter实现插入操作\n        set_intersection(v[0].begin(), v[0].end(), v[i].begin(), v[i].end(), back_inserter(tmp));\n        v[0].assign(tmp.begin(), tmp.end());//assign 将元素复制到该容器中 并删除原容器中的元素\n        if(v[0].empty())//无交集 即与题意不符\n            break;\n    }\n    if(v[0].empty())\n        return -1;\n    return v[0][0];//输出交集中第一个元素 就是最小的可满足解\n}\nint main()\n{\n    bs3[0] = 1;\n    for(int i = 1; i <= 12; ++i)\n    {\n        bs3[i] = bs3[i - 1]*3;\n    }\n    while(scanf(\"%d%d\", &n, &m) != EOF)\n    {\n        if(n == 0 || m == 0)\n            break;\n        for(int i = 0; i < n; ++i)\n        {\n            scanf(\"%lld\", &a[i]);\n        }\n        for(int i = 0; i < m; ++i)\n        {\n            scanf(\"%lld\", &w[i]);\n        }\n        ll ans = solve();\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e16\nusing namespace std;\n\nlong long n, m, threepow;\nvector<long long> a, w, b;\nset<long long> st;\n\nint solve();\n\nint main() {\n  while(1) {\n    cin >> n >> m;\n    if(n + m == 0) break;\n    a.resize(n);\n    w.resize(m);\n    for(int i = 0; i < n; ++i) cin >> a[i];\n    for(int i = 0; i < m; ++i) cin >> w[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  st.clear();\n  b.erase(b.begin(), b.end());\n  threepow = 1;\n  for(int i = 0; i < m; ++i) threepow *= 3;\n  for(long long i = 0; i < threepow; ++i) {\n    long long x = i, sum = 0;\n    for(int j = 0; j < m; ++j) {\n      if(x % 3 == 1)\n        sum += w[j];\n      else if(x % 3 == 2)\n        sum -= w[j];\n      x /= 3;\n    }\n    st.insert(sum);\n  }\n  for(int i = 0; i < n; ++i)\n    if(st.find(a[i]) == st.end()) b.push_back(a[i]);\n  if(b.size() == 0) return 0;\n  long long ans = inf, neww;\n  for(auto now : st) {\n    neww = abs(now - b[0]);\n    bool ch = 1;\n    for(int i = 0; i < b.size(); ++i) {\n      if(st.find(b[i] + neww) != st.end()) continue;\n      if(st.find(abs(b[i] - neww)) != st.end()) continue;\n      ch = 0;\n    }\n    if(ch) ans = min(ans, neww);\n  }\n  if(ans == inf) return -1;\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nvector <int> can;//今ある分銅で測れる重さ\n\n//今ある分銅で測れる重さを、総当たりで求める再帰関数。\nvoid make_can(int depth, int sum, vector<int> w){\n\tif(depth >= m){\n\t\tcan.push_back(sum);\n\t\treturn;\n\t}\n\tmake_can(depth+1, sum, w);//置かない\n\tmake_can(depth+1, sum+w[depth], w);//薬品じゃない方に置く(足す)\n\tmake_can(depth+1, abs(sum-w[depth]), w); //薬品の方に置く(引く)\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\n\t\tvector <int> a(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector <int> w(m);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> w[i];\n\t\t}\n\n\t\t//前半(今ある分銅で、全ての薬品を測れるか)\n\t\tcan.clear();\n\t\tmake_can(0, 0, w); \n\t\tsort(can.begin(), can.end());\n\t\tfor(int i=0; i<can.size(); i++){\n\t\t\tfor(int j=0; j<a.size(); j++){\n\t\t\t\tif(can[i] == a[j]) a.erase(a.begin()+j); //今ある分銅で測れる薬品を消す\n\t\t\t}\n\t\t}\n\n\t\tif(a.size() == 0){\n\t\t\tcout << 0 << endl; //全ての薬品は今ある分銅で測れる\n\t\t\tcontinue;\n\t\t}\n\n\t\t//後半(どの重さの分銅を追加すればいいか)\n\t\tvector <vector<int> > cand(n); //各薬品に対して追加が必要な分銅の候補\n\t\tfor(int i=0; i<a.size(); i++){\n\t\t\tfor(int j=0; j<can.size(); j++){\n\t\t\t\tcand[i].push_back(can[j]+a[i]);\n\t\t\t\tcand[i].push_back((abs(can[j]-a[i])));\n\t\t\t}\n\t\t\tsort(cand[i].begin(), cand[i].end());\n\t\t}\n\n\t\tvector <int> need = cand[0]; //v1とv2の積集合。答えの候補。\n\t\tfor(int s=1; s<a.size(); s++){\n\t\t\tvector <int> v1 = need;\n\t\t\tvector <int> v2 = cand[s];\n\t\t\tneed.clear();\n\t\t\tint i=0, j=0; // iはv1に jはv2に対応。v1[i], v2[j]\n\t\t\twhile(i<v1.size() && j<v2.size()){\n\t\t\t\tif(v1[i] < v2[j]) i++;\n\t\t\t\telse if(v1[i] > v2[j]) j++;\n\t\t\t\telse{\n\t\t\t\t\t//重複を省くための条件式\n\t\t\t\t\tif(need.size() == 0) need.push_back(v1[i]);\n\t\t\t\t\telse if(need[need.size()-1] != v1[i]){\n\t\t\t\t\t\tneed.push_back(v1[i]);\n\t\t\t\t\t}\n\t\t\t\t\ti++; j++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(need.empty()) cout << -1 << endl; //候補が残っていない -> 1つ追加しても無理\n\t\telse cout << need[0] << endl; //候補の中で一番軽いやつが答え\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os, const map<T,U>& mp){ os << \"{\"; for(auto& p : mp){ os << p << \",\"; } os << \"}\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = std::pair<int,int>;\nusing vi = std::vector<int>;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nvoid solve(int n,int m){\n    vector<ll> a(n);\n    vector<ll> w(m);\n    rep(i,n) cin >> a[i];\n    rep(i,m) cin >> w[i];\n    sort(all(a));\n\n    unordered_set<ll> val; // 3 ^ 10 =  6 * 10 ^ 4\n    for(int mask1=0;mask1<(1<<m);mask1++){\n        for(int mask2=0;mask2<(1<<m);mask2++){\n            if(mask1 & mask2) continue;\n            ll sum = 0;\n            for(int i=0;i<m;i++){\n                int m1 = (mask1 & (1<<i));\n                int m2 = (mask2 & (1<<i));\n                if(m1 and !m2){\n                    sum += w[i];\n                }else if(!m1 and m2){\n                    sum -= w[i];\n                }\n            }\n\n            val.insert(sum);\n        }\n    }\n\n    bool ok = true;\n    for(int i=0;i<n;i++){\n        if(!val.count(a[i])){\n            ok = false;\n            break;\n        }\n    }\n    if(ok){\n        cout << 0 << endl;\n        return;\n    }\n\n    set<ll> cand;\n    for(int i=0;i<n;i++){\n        if(val.count(a[i])) continue;\n\n        for(auto v : val){\n            if(v!=a[i]) cand.insert(abs(v-a[i]));\n        }\n\n        break;\n    }\n\n    for(auto c : cand){\n        bool ok = true;\n        for(int i=0;i<n;i++){\n            if(!(val.count(a[i]) || val.count(a[i]-c) || val.count(a[i]+c))){\n                ok = false;\n                break;\n            }\n        }\n        if(ok){\n            cout << c << endl;\n            return;\n        }\n    }\n    cout << -1 << endl;\n}\n\nint main(){\n    while(1){\n        int n,m; cin >> n >> m;\n        if(n == 0 and m == 0) break;\n        solve(n,m);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint n,m;\nint a[100];\nint w[10];\nset<int> all_poss;\n\nvoid init(){\n    for(int i=0;i<n;i++)\n        scanf(\"%d\",a+i);\n\n    for(int j=0;j<m;j++)\n        scanf(\"%d\",w+j);\n}\n\nvoid calc(int c,int init){\n    if (c>=m)\n        return;\n\n    int plus=init+w[c];\n    int minus=abs(init-w[c]);\n\n    all_poss.insert(plus);\n    all_poss.insert(minus);\n\n    calc(c+1,init);\n    calc(c+1,plus);\n    calc(c+1,minus);\n}\n\nvoid filter(){\n    int i=0;\n    for(int j=0;j<n;j++){\n        if (all_poss.count(a[j])==0){\n            // printf(\"%d\\n\",a[j]);\n            swap(a[i++],a[j]);\n        }\n    }\n    n=i;\n}\n\nvoid makeup(){\n    set<int> candidate;\n    for (auto i:all_poss){\n        candidate.insert(i+a[0]);\n        candidate.insert(abs(i-a[0]));\n    }\n\n    for (int i=1;i<n;i++){\n        for (auto j:candidate){\n            if (all_poss.count(a[i]+j)==0&&all_poss.count(abs(j-a[i]))==0)\n                candidate.erase(j);\n        }\n    }\n\n    if (candidate.empty())\n        puts(\"-1\");\n    else \n        printf(\"%d\\n\",*candidate.begin());\n}\n\nint main(){\n\n    while(scanf(\"%d%d\",&n,&m)&&(n!=0||m!=0)){\n        all_poss=set<int>({0});\n        init();\n        calc(0,0);\n        // for(auto i:all_poss)\n        //     printf(\"%d \",i);\n        // putchar('\\n');\n        filter();\n        if (n==0){\n            puts(\"0\");\n            continue;\n        }\n        makeup();\n        // printf(\"%d\\n\",n);\n    }   \n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n){\n        int a[n], w[m];\n        for(int i = 0; i < n; i++)  cin >> a[i];\n        for(int i = 0; i < m; i++)  cin >> w[i];\n        set<int> s;\n        for(int i = 0; i < pow(3,m); i++){\n            int x = 0, cp = i;\n            for(int j = 0; j < m; j++)  x += (cp%3-1)*w[j], cp /= 3;\n            s.insert(x);\n        }\n        vector<int> ng;\n        for(int i = 0; i < n; i++)  if(s.count(a[i]) == 0)  ng.push_back(a[i]);\n        if(ng.size() == 0){\n            cout << 0 << endl;\n            continue;\n        }\n        set<int> ok;\n        for(int i : s){\n            ok.insert(abs(i-ng[0]));\n        }\n        for(int i = 1; i < ng.size(); i++){\n            set<int> nok;\n            for(int x : ok) if(s.count(x+ng[i]) || s.count(abs(x-ng[i])))   nok.insert(x);\n            ok = nok;\n        }\n        cout << (ok.empty() ? -1 : *ok.begin()) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define chmax(a, b) a = (a >= b ? a : b)\n#define chmin(a, b) a = (a <= b ? a : b)\n#define sz(v) (int)v.size()\n#define inf (int)(1e9+7)\n#define ceil(a, b) a / b + !!(a % b)\nll pow(ll a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\n\n\n\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    \n    \n    \n    int n, m;\n    while (cin >> n && n) {\n        cin >> m;\n        \n        vector<int> a(n);\n        rep(i, n) cin >> a[i];\n        vector<int> w(2 * m);\n        rep(i, m) cin >> w[i];\n        rep3(i, m, 2 * m) w[i] = -w[i - m];\n        \n        set<int> s;\n        rep(i, (1 << (2 * m))) {\n            int sum = 0;\n            int flg = 0;\n            rep(j, 2 * m) {\n                if (i & (1 << j)) {\n                    if (j >= m && i & (1 << (j - m))) {\n                        flg = 1;\n                        break;\n                    }\n                    sum += w[j];\n                }\n            }\n            if (flg) continue;\n            // if (sum > 0) s.insert(sum);\n            sum = abs(sum); s.insert(sum);\n        }\n        \n        // for (auto e : s) cout << e << \" \"; cout << endl << endl;\n        \n        set<int> s2;\n        int flg = 0;\n        \n        rep(i, n) {\n            if (s.find(a[i]) != s.end()) continue;\n            flg++;\n            \n            if (flg == 1) {\n                for (auto e : s) {\n                    s2.insert(e + a[i]);\n                    s2.insert(abs(e - a[i]));\n                }\n            } else {\n                set<int> s3;\n                for (auto e : s) {\n                    if (s2.find(e + a[i]) != s2.end()) {\n                        s3.insert(e + a[i]);\n                    }\n                    \n                    if (s2.find(abs(e - a[i])) != s2.end()) {\n                        s3.insert(abs(e - a[i]));\n                    }\n                    \n                }\n                s2 = s3;\n            }\n            \n            // cout << flg << \"    \"; for (auto e : s2) cout << e << \" \"; cout << endl;\n        }\n        \n        if (flg == 0) cout << 0 << '\\n';\n        else if (sz(s2) == 0) {\n            cout << -1 << '\\n';\n        } else {\n            int ans = inf;\n            for (auto e : s2) chmin(ans, abs(e));\n            cout << ans << '\\n';\n        }\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <climits>\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <tuple>\n#include <iostream>\n#include <deque>\n#include <array>\n#include <set>\n#include <functional>\n#include <memory>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nvoid make_set(const std::vector<long long int>& weights, const int current_pos, const long long int current, std::vector<long long int> &result) {\n\tif (current_pos == weights.size()) {\n\t\tresult.push_back(current);\n\t}\n\telse {\n\t\tmake_set(weights, current_pos + 1, current - weights[current_pos], result);\n\t\tmake_set(weights, current_pos + 1, current + weights[current_pos], result);\n\t\tmake_set(weights, current_pos + 1, current, result);\n\t}\n}\nint main() {\n\twhile (true) {\n\t\tint n, m; std::cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tstd::vector<int>targets(n); for (auto& t : targets) std::cin >> t;\n\t\tstd::vector<long long int> weights(m); for (auto& w : weights) std::cin >> w;\n\t\tstd::vector<long long int> can_make; make_set(weights, 0, 0, can_make);\n\t\tstd::sort(can_make.begin(), can_make.end());\n\t\tstd::set<long long int> suspect; \n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tif (!std::binary_search(can_make.begin(), can_make.end(), targets[i])) {\n\t\t\t\tfor (const auto c : can_make) {\n\t\t\t\t\tsuspect.insert(std::abs(c + targets[i]));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tauto make_count = 0;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tstd::set<long long int> s;\n\t\t\tif (std::binary_search(can_make.begin(), can_make.end(), targets[i])) {\n\t\t\t\tmake_count++;\n\t\t\t}else{\n\t\t\t\tfor (const auto c : can_make) {\n\t\t\t\t\tif (suspect.find(std::abs(c + targets[i])) != suspect.end()) {\n\t\t\t\t\t\ts.insert(std::abs(c + targets[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuspect = std::move(s);\n\t\t\t}\n\t\t}\n\t\tif (make_count == n) {\n\t\t\tstd::cout << 0 << std::endl;\n\t\t}else if (suspect.empty()) {\n\t\t\tstd::cout << -1 << std::endl;\n\t\t}\n\t\telse  {\n\t\t\tstd::cout << *suspect.begin() << std::endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n\nusing namespace std;\n\nbool solve() {\n  // Inputs.\n  int n, m;\n  cin >> n >> m;\n  if (n == 0 && m == 0) {\n    return false;\n  }\n  vector<int64_t> a(n), w(m);\n  for (auto &i : a) {\n    cin >> i;\n  }\n  for (auto &i : w) {\n    cin >> i;\n  }\n\n  // List measurable weights.\n  set<int64_t> s{0};\n  for (auto &i : w) {\n    set<int64_t> t;\n    for (auto &j : s) {\n      t.emplace(j + i);\n      t.emplace(j);\n      t.emplace(j - i);\n    }\n    s = move(t);\n  }\n\n  // List unmeasurable chemicals.\n  vector<int> b;\n  for (auto &i : a) {\n    if (s.find(i) == s.end()) {\n      b.emplace_back(i);\n    }\n  }\n\n  // All chemicals are measurable.\n  if (b.empty()) {\n    cout << 0 << endl;\n    return true;\n  }\n\n  // List feasible weights for each unmeasurable chemical.\n  vector<set<int64_t>> r(b.size());\n  for (int i = 0; i < int(b.size()); ++i) {\n    for (auto &j : s) {\n      r[i].emplace(abs(b[i] - j));\n    }\n  }\n\n  // Intersection of feasible weights.\n  set<int64_t> p(r[0]);\n  for (auto &i : r) {\n    set<int64_t> q;\n    for (auto &j : i) {\n      if (p.find(j) != p.end()) {\n        q.emplace(j);\n      }\n    }\n    p = move(q);\n  }\n\n  // Output the minimum feasible weight.\n  if (!p.empty()) {\n    cout << *(p.begin()) << endl;\n  } else {\n    cout << -1 << endl;\n  }\n\n  return true;\n}\n\nint main() {\n  while (solve()) {\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\nusing namespace std;\nconst int inf = 2e9;\n\nint ipow(int a, int p){\n    int res = 1;\n    for(int i=0; i<p; i++){\n        res *= a;\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0) break;\n\n        vector<int> a(n),w(m);\n        for(int i=0; i<n; i++){\n            cin >> a[i];\n        }\n        for(int i=0; i<m; i++){\n            cin >> w[i];\n        }\n        set<int> diff;\n        for(int i=0; i<ipow(3, m); i++){\n            int tmp = i;\n            int b[3] = {};\n            for(int j=0; j<m; j++){\n                b[tmp%3] += w[j];\n                tmp /= 3;\n            }\n            diff.insert(abs(b[1]-b[0]));\n        }\n\n        vector<int> b;\n        for(int i: a){\n            if(diff.find(i) == diff.end()){\n                b.push_back(i);\n            }\n        }\n        if(b.empty()){\n            cout << 0 << endl;\n            continue;\n        }\n        int ans = inf;\n        for(int e: diff){\n            for(int s=-1; s<2; s+=2){\n                int d = abs(b[0]+s*e);\n                bool ok = true;\n                for(int i: b){\n                    if(diff.find(abs(i-d)) == diff.end() and diff.find(i+d) == diff.end()){\n                        ok = false;\n                        break;\n                    }\n                }\n                if(ok){\n                    ans = min(ans, d);\n                }\n            }\n        }\n        if(ans == inf){\n            cout << -1 << endl;\n        }else{\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1634 Balance Scale\n// bal4u 2019.8.12\n\n#include <stdio.h>\n#include <string.h>\n\n//// 入出力関係\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\n\nint in() {   // 非負整数の入力\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf); while ((c = gc()) >= '0');\n\treturn n;\n}\n\nvoid out(int n) { // 整数の表示（出力）\n\tint i;\n\tchar b[20];\n\n\tif (!n) pc('0');\n\telse {\n\t\tif (n < 0) pc('-'), n = -n;\n\t\ti = 0; while (n) b[i++] = n % 10 + '0', n /= 10;\n\t\twhile (i--) pc(b[i]);\n\t\t\n\t}\n\tpc('\\n');\n}\n\n//// ハッシュ関数\n#define HASHSIZ 1000003\ntypedef struct { int n, b; } HA;\nint ha1[HASHSIZ+5], *hae1 = ha1 + HASHSIZ;\nHA  ha2[HASHSIZ+5], *hae2 = ha2 + HASHSIZ;\n\nint lookup1(int n) {\n\tint *p = ha1 + n % HASHSIZ;\n\twhile (*p) {\n\t\tif (*p == n) return 1;\n\t\tif (++p == hae1) p = ha1;\n\t}\n\treturn 0;\n}\n\nvoid insert1(int n) {\n\tint *p = ha1 + n % HASHSIZ;\n\twhile (*p) {\n\t\tif (*p == n) return;\n\t\tif (++p == hae1) p = ha1;\n\t}\n\t*p = n;\n}\n\nint lookup2(int n, int b) {\n\tHA *p = ha2 + n % HASHSIZ;\n\twhile (p->n) {\n\t\tif (p->n == n) {\n\t\t\tif (p->b == b-1) { p->b = b; return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\tif (++p == ha2) p = ha2;\n\t}\n\treturn 0;\n}\n\nvoid insert2(int n) {\n\tHA *p = ha2 + n % HASHSIZ;\n\twhile (p->n) {\n\t\tif (p->n == n) return;\n\t\tif (++p == ha2) p = ha2;\n\t}\n\tp->n = n, p->b = 1;\n}\n\n//// 本問題関連\n#define INF 0x7fffffff\n#define ABS(x)  ((x)>=0?(x):-(x))\nint q[60000];   // 3^10\nint a[102];\nint w[12];\n\t\t\nint main()\n{\n\tint n, m, i, j, end, x, ans;\n\t\n\twhile (n = in()) {\n\t\tm = in();\n\t\tfor (i = 0; i < n; i++) a[i] = in();\n\t\tfor (i = 0; i < m; i++) w[i] = in();\n\t\tq[0] = 0, end = 1;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tint e = end;\n\t\t\tfor (j = 0; j < e; j++) {\n\t\t\t\tq[end++] = q[j] + w[i];\n\t\t\t\tq[end++] = q[j] - w[i];\n\t\t\t}\n\t\t}\n\t\tmemset(ha1, 0, sizeof(ha1));\n\t\tfor (i = 0; i < end; i++) if (q[i] > 0) insert1(q[i]);\n\t\tx = 0, ans = 0; for (i = 0; i < n; i++) if (!lookup1(a[i])) {\n\t\t\tif (x == 0) {\n\t\t\t\tint t; ans = INF;\n\t\t\t\tmemset(ha2, 0, sizeof(ha2));\n\t\t\t\tfor (j = 0; j < end; j++) {\n\t\t\t\t\tif ((t = ABS(a[i]-q[j])) < ans) ans = t;\n\t\t\t\t\tinsert2(t);\n\t\t\t\t}\n\t\t\t\tx = 1;\n\t\t\t} else {\n\t\t\t\tint t, r = 0; x++, ans = INF;\n\t\t\t\tfor (j = 0; j < end; j++) {\n\t\t\t\t\tt = ABS(a[i]-q[j]);\n\t\t\t\t\tif (lookup2(t, x)) {\n\t\t\t\t\t\tif (t < ans) ans = t;\n\t\t\t\t\t\tr = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (r == 0) { ans = -1; break; }\n\t\t\t}\n\t\t}\n\t\tout(ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\tint n = Integer.parseInt(scan.next());\n\t\t\tint m = Integer.parseInt(scan.next());\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\tint a[] = new int[n];\n\t\t\tint w[] = new int[m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = Integer.parseInt(scan.next());\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tw[j] = Integer.parseInt(scan.next());\t\t\t\t\n\t\t\t}\n\t\t\tSortedSet<Integer> commonAdditions = null;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tSortedSet<Integer> additions = new TreeSet<Integer>();\n\t\t\t\tboolean bJust = calcNearestWeight(a[i], w, 0, 0, additions);\n\t\t\t\tif (!bJust) {\n\t\t\t\t\tif (commonAdditions == null) {\n\t\t\t\t\t\tcommonAdditions = additions;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommonAdditions.retainAll(additions);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (commonAdditions == null) {\n\t\t\t\tSystem.out.println(0);\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (commonAdditions.size() > 0) {\n\t\t\t\t\tSystem.out.println(commonAdditions.first());\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscan.close();\n\t}\n\n\tprivate static boolean calcNearestWeight(int x, int w[], int i, int sum, SortedSet<Integer> additions) {\n\t\tif (x == sum) return true;\n\t\tif (i == w.length) {\n\t\t\tadditions.add(Math.abs(x - sum));\n\t\t\treturn false;\n\t\t}\n\t\tif (calcNearestWeight(x, w, i + 1, sum, additions)) return true;\n\t\tif (calcNearestWeight(x, w, i + 1, sum + w[i], additions)) return true;\n\t\treturn calcNearestWeight(x, w, i + 1, sum - w[i], additions);\n\t}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left, bisect_right\nwhile True:\n    n, m = map(int, input().split())\n    if n == m == 0:\n        break\n    a = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n    Set = set()\n    def go(i, weight):\n        if i == m:\n            Set.add(weight)\n            return\n        go(i + 1, weight)\n        go(i + 1, weight + w[i])\n        go(i + 1, weight - w[i])\n    go(0, 0)\n    ans = False\n    for i in a:\n        if i not in Set:\n            if ans == False:\n                ans = set(abs(s - i) for s in Set)\n            else:\n                ans = set(s for s in ans if i + s in Set or i - s in Set)\n    if ans == False:\n        print(0)\n        continue\n    elif len(ans) == 0:\n        print(-1)\n        continue\n    else:\n        print(min(ans))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef solve(N, M, A, W):\n    S = set([0])\n    for w in W:\n        T = set()\n        for s in S:\n            T.add(s); T.add(s + w); T.add(s - w)\n        S = T\n    C = defaultdict(int)\n    L = None\n    for a in A:\n        if a not in S:\n            if L is None:\n                L = [abs(s - a) for s in S]\n            else:\n                L = [l for l in L if a+l in S or a-l in S]\n    if L is None:\n        print(0)\n    elif L:\n        print(min(L))\n    else:\n        print(-1)\n\nwhile 1:\n    N, M = map(int, input().split())\n    if N == 0:\n        break\n    *A, = map(int, input().split())\n    *W, = map(int, input().split())\n    solve(N, M, A, W)\n"
  },
  {
    "language": "Python",
    "code": "while True:\n\n    n, m = list(map(int, input().split()))\n\n    if n == 0 and m == 0:\n        break\n\n    medicines = set(map(int, input().split()))\n    weights = list(map(int, input().split()))\n\n    possibles = {0}\n\n    for i in weights:\n        pre = possibles.copy()\n        for j in possibles:\n            plus = i + j\n            minus = abs(i - j)\n            pre.add(plus)\n            pre.add(minus)\n        possibles = pre\n    possibles.discard(0)\n\n    medicines -= possibles\n\n    if len(medicines) == 0:\n        print(0)\n        continue\n\n    add = []\n\n    for i in medicines:\n        pre_add = {0}\n        for j in possibles:\n            plus = i + j\n            minus = abs(i - j)\n            pre_add.add(plus)\n            pre_add.add(minus)\n            pre_add.add(i)\n            pre_add.discard(0)\n        add.append(pre_add)\n\n    ans = add[0]\n\n    for i in add:\n        pre_ans = ans & i\n        ans = pre_ans\n\n    ans_list = []\n\n    for i in ans:\n        ans_list.append(i)\n\n    if len(ans_list) == 0:\n        print(-1)\n    elif len(ans_list) == 1:\n        print(ans_list[0])\n    else:\n        print(min(ans_list))\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    n,m = map(int,input().split())\n    if n*m == 0: return False\n    a = list(map(int, input().split()))\n    w = list(map(int,input().split()))\n    d = {0:1}\n    for i in w:\n        new_d = dict(d)\n        for j in d.keys():\n            new_d[j+i] = 1\n            new_d[abs(j-i)] = 1\n        new_d[i] = 1\n        d = dict(new_d)\n    nokori = []\n    for i in a:\n        if i in d.keys():\n            pass\n        else:\n            nokori += [i]\n    # print(nokori)\n    nokorimono = len(nokori)\n    if nokorimono == 0:\n        print(0)\n        return True\n    ans_d = {}\n    for i in nokori:\n        new_d = {}\n        for j in d.keys():\n            new_d[abs(i-j)] = 1\n            new_d[i+j] = 1\n        for j in new_d.keys():\n            if j in ans_d:\n                ans_d[j] = ans_d[j] + 1\n            else:\n                ans_d[j] = 1\n    ans = 10**12\n    for i in ans_d.keys():\n        if ans_d[i] == nokorimono:\n            ans = min(ans, i)\n    if ans == 10**12:\n        ans = -1\n    print(ans)\n    return True\n\nwhile main():\n    pass\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    while True:\n        N, M = read_ints()\n        if (N, M) == (0, 0):\n            break\n        A = read_ints()\n        W = read_ints()\n        print(solve(N, M, A, W))\n\n\ndef solve(N, M, A, W):\n    weights = set([])\n    for w in W:\n        wl = list(weights)\n        weights.add(w)\n        for w0 in wl:\n            if w0 + w > 0:\n                weights.add(w0 + w)\n            if w0 - w > 0:\n                weights.add(w0 - w)\n            if w - w0 > 0:\n                weights.add(w - w0)\n\n    rest = set()\n    for a in A:\n        if a not in weights:\n            rest.add(a)\n\n    if not rest:\n        return 0\n\n    rest = list(rest)\n    cands = None\n    for w in rest:\n        r = set([w])\n        for w0 in weights:\n            r.add(w0 + w)\n            if w0 - w > 0:\n                r.add(w0 - w)\n            if w - w0 > 0:\n                r.add(w - w0)\n        if cands is None:\n            cands = r\n        else:\n            cands &= r\n\n    if not cands:\n        return -1\n    return min(cands)\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  }
]