[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)b - *(int *)a);\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    int *manju = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &manju[i]);\n    }\n\n    qsort(manju, N, sizeof(int), compare);\n\n    int *box_capacity = (int *)malloc(M * sizeof(int));\n    int *box_price = (int *)malloc(M * sizeof(int));\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &box_capacity[i], &box_price[i]);\n    }\n\n    int max_profit = 0;\n    int manju_index = 0;\n\n    while (manju_index < N) {\n        int best_profit = INT_MIN;\n        int best_box = -1;\n        int best_count = 0;\n\n        for (int i = 0; i < M; i++) {\n            if (box_capacity[i] == 0) continue;\n\n            int count = 0;\n            int sum = 0;\n            for (int j = manju_index; j < N && count < box_capacity[i]; j++) {\n                sum += manju[j];\n                count++;\n            }\n\n            int profit = sum - box_price[i];\n            if (profit > best_profit) {\n                best_profit = profit;\n                best_box = i;\n                best_count = count;\n            }\n        }\n\n        if (best_profit <= 0) break;\n\n        max_profit += best_profit;\n        manju_index += best_count;\n        box_capacity[best_box] = 0;\n    }\n\n    printf(\"%d\\n\", max_profit);\n\n    free(manju);\n    free(box_capacity);\n    free(box_price);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ManjuProfitCalculator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read number of Manju varieties and box types\n        int n = scanner.nextInt(); // Manju varieties\n        int m = scanner.nextInt(); // Box types\n        \n        // Arrays to store Manju prices\n        int[] manjuPrices = new int[n];\n        for (int i = 0; i < n; i++) {\n            manjuPrices[i] = scanner.nextInt();\n        }\n        \n        // Arrays to store box capacities and prices\n        int[] boxCapacities = new int[m];\n        int[] boxPrices = new int[m];\n        for (int i = 0; i < m; i++) {\n            boxCapacities[i] = scanner.nextInt();\n            boxPrices[i] = scanner.nextInt();\n        }\n        \n        // Calculate maximum profit\n        int maxProfit = calculateMaxProfit(n, m, manjuPrices, boxCapacities, boxPrices);\n        \n        // Output the result\n        System.out.println(maxProfit);\n        \n        scanner.close();\n    }\n    \n    public static int calculateMaxProfit(int n, int m, int[] manjuPrices, \n                                          int[] boxCapacities, int[] boxPrices) {\n        // Sort Manju prices in descending order\n        Arrays.sort(manjuPrices);\n        reverse(manjuPrices);\n        \n        // Sort box types by capacity in descending order\n        Integer[] boxIndices = new Integer[m];\n        for (int i = 0; i < m; i++) {\n            boxIndices[i] = i;\n        }\n        Arrays.sort(boxIndices, (a, b) -> Integer.compare(boxCapacities[b], boxCapacities[a]));\n        \n        int totalProfit = 0;\n        int remainingManju = 0;\n        \n        // Iterate through sorted box types\n        for (int i = 0; i < m; i++) {\n            int currentBoxIndex = boxIndices[i];\n            int boxCapacity = boxCapacities[currentBoxIndex];\n            int boxPrice = boxPrices[currentBoxIndex];\n            \n            // Fill box with most expensive Manju\n            int manjuInBox = Math.min(boxCapacity, n - remainingManju);\n            int boxRevenue = 0;\n            \n            for (int j = 0; j < manjuInBox; j++) {\n                boxRevenue += manjuPrices[remainingManju + j];\n            }\n            \n            // Calculate profit for this box\n            int boxProfit = boxRevenue - boxPrice;\n            \n            // Add to total profit if positive\n            if (boxProfit > 0) {\n                totalProfit += boxProfit;\n                remainingManju += manjuInBox;\n            }\n            \n            // Stop if all Manju are packaged\n            if (remainingManju >= n) {\n                break;\n            }\n        }\n        \n        return totalProfit;\n    }\n    \n    // Helper method to reverse an array\n    private static void reverse(int[] arr) {\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            int temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:50:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> manju(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> manju[i];\n    }\n    \n    vector<pair<int, int>> boxes(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> boxes[i].first >> boxes[i].second;\n    }\n    \n    sort(manju.rbegin(), manju.rend());\n    \n    sort(boxes.begin(), boxes.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        if (a.first == b.first) {\n            return a.second > b.second;\n        }\n        return a.first < b.first;\n    });\n    \n    vector<pair<int, int>> optimized_boxes;\n    int max_price = 0;\n    for (int i = 0; i < M; ++i) {\n        if (boxes[i].second > max_price) {\n            optimized_boxes.push_back(boxes[i]);\n            max_price = boxes[i].second;\n        }\n    }\n    \n    int total_profit = 0;\n    int manju_idx = 0;\n    int box_idx = 0;\n    int box_count = optimized_boxes.size();\n    \n    while (manju_idx < N && box_idx < box_count) {\n        int capacity = optimized_boxes[box_idx].first;\n        int price = optimized_boxes[box_idx].second;\n        \n        int sum_manju = 0;\n        int end = min(manju_idx + capacity, N);\n        for (int i = manju_idx; i < end; ++i) {\n            sum_manju += manju[i];\n        }\n        \n        if (sum_manju > price) {\n            total_profit += sum_manju - price;\n            manju_idx = end;\n            box_idx++;\n        } else {\n            box_idx++;\n        }\n    }\n    \n    for (int i = manju_idx; i < N; ++i) {\n        total_profit += manju[i];\n    }\n    \n    cout << total_profit << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_VARIETIES 100\n#define MAX_BOXES 100\n\nint main() {\n    int num_varieties, num_boxes;\n    int manju_prices[MAX_VARIETIES];\n    int box_capacities[MAX_BOXES];\n    int box_prices[MAX_BOXES];\n    int max_profit = 0;\n\n    // Read number of Manju varieties and box types\n    scanf(\"%d %d\", &num_varieties, &num_boxes);\n\n    // Read Manju prices\n    for (int i = 0; i < num_varieties; i++) {\n        scanf(\"%d\", &manju_prices[i]);\n    }\n\n    // Read box capacities and prices\n    for (int j = 0; j < num_boxes; j++) {\n        scanf(\"%d %d\", &box_capacities[j], &box_prices[j]);\n    }\n\n    // Try all possible combinations of Manju sets and boxes\n    for (int subset = 1; subset < (1 << num_varieties); subset++) {\n        int total_manju = 0;\n        int total_manju_value = 0;\n        int current_profit = 0;\n\n        // Calculate total Manju in current subset\n        for (int i = 0; i < num_varieties; i++) {\n            if (subset & (1 << i)) {\n                total_manju++;\n                total_manju_value += manju_prices[i];\n            }\n        }\n\n        // Find best box for this subset\n        for (int j = 0; j < num_boxes; j++) {\n            if (box_capacities[j] >= total_manju) {\n                current_profit = total_manju_value - box_prices[j];\n                max_profit = (current_profit > max_profit) ? current_profit : max_profit;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_profit);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> manju_prices(n);\n    for (int i = 0; i < n; i++) {\n        cin >> manju_prices[i];\n    }\n\n    vector<pair<int, int>> boxes(m);\n    for (int i = 0; i < m; i++) {\n        cin >> boxes[i].first >> boxes[i].second;\n    }\n\n    int max_profit = 0;\n\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<int> selected_manju;\n        int total_manju_price = 0;\n\n        for (int j = 0; j < n; j++) {\n            if (mask & (1 << j)) {\n                selected_manju.push_back(manju_prices[j]);\n                total_manju_price += manju_prices[j];\n            }\n        }\n\n        int current_profit = total_manju_price;\n\n        for (auto& box : boxes) {\n            int box_capacity = box.first;\n            int box_price = box.second;\n\n            int total_manju_in_box = 0;\n            for (int price : selected_manju) {\n                if (total_manju_in_box + price <= box_capacity) {\n                    total_manju_in_box += price;\n                }\n            }\n\n            current_profit -= box_price;\n        }\n\n        max_profit = max(max_profit, current_profit);\n    }\n\n    cout << max_profit << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        int[] manjuPrices = new int[N];\n        for (int i = 0; i < N; i++) {\n            manjuPrices[i] = scanner.nextInt();\n        }\n        \n        int[] boxCapacities = new int[M];\n        int[] boxPrices = new int[M];\n        for (int i = 0; i < M; i++) {\n            boxCapacities[i] = scanner.nextInt();\n            boxPrices[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(manjuPrices);\n        reverseArray(manjuPrices);\n        \n        int maxProfit = 0;\n        int manjuIndex = 0;\n        \n        for (int i = 0; i < M; i++) {\n            int capacity = boxCapacities[i];\n            int price = boxPrices[i];\n            int sum = 0;\n            int count = 0;\n            \n            while (count < capacity && manjuIndex < N) {\n                sum += manjuPrices[manjuIndex];\n                manjuIndex++;\n                count++;\n            }\n            \n            if (sum > price) {\n                maxProfit += sum - price;\n            }\n        }\n        \n        System.out.println(maxProfit);\n    }\n    \n    private static void reverseArray(int[] array) {\n        int i = 0;\n        int j = array.length - 1;\n        while (i < j) {\n            int temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n            i++;\n            j--;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:51:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_profit():\n    num_manju_varieties = int(input())\n    num_box_types = int(input())\n    \n    manju_prices = list(map(int, input().split()))\n    box_info = [list(map(int, input().split())) for _ in range(num_box_types)]\n    \n    manju_prices.sort(reverse=True)\n    box_info.sort(key=lambda x: x[1]/x[0])\n    \n    max_profit = 0\n    manju_index = 0\n    for capacity, cost in box_info:\n        if manju_index >= num_manju_varieties:\n            break\n        num_manju_in_box = min(capacity, num_manju_varieties - manju_index)\n        box_profit = sum(manju_prices[manju_index:manju_index + num_manju_in_box]) - cost\n        manju_index += num_manju_in_box\n        max_profit += box_profit\n    \n    print(max_profit)\n\nmax_profit()",
    "timestamp": "2025-08-13 01:12:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class ManjuProfitCalculator {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Read number of Manju varieties and box types\n        int numberOfManjuVarieties = scanner.nextInt();\n        int numberOfBoxTypes = scanner.nextInt();\n\n        // Read prices of each Manju\n        int[] manjuPrices = new int[numberOfManjuVarieties];\n        for (int i = 0; i < numberOfManjuVarieties; i++) {\n            manjuPrices[i] = scanner.nextInt();\n        }\n\n        // Read capacities and prices of each box\n        int[] boxCapacities = new int[numberOfBoxTypes];\n        int[] boxPrices = new int[numberOfBoxTypes];\n        for (int i = 0; i < numberOfBoxTypes; i++) {\n            boxCapacities[i] = scanner.nextInt();\n            boxPrices[i] = scanner.nextInt();\n        }\n\n        // Calculate maximum profit\n        System.out.println(calcMaxProfit(manjuPrices, boxCapacities, boxPrices));\n    }\n\n    private static int calcMaxProfit(int[] manjuPrices, int[] boxCapacities, int[] boxPrices) {\n        int maxProfit = Integer.MIN_VALUE;\n\n        for (int i = 0; i < boxCapacities.length; i++) {\n            int currentCapacity = boxCapacities[i];\n            int currentBoxPrice = boxPrices[i];\n            int totalManjuPrice = 0;\n\n            // Calculate the maximum sale price for the current box type\n            for (int price : manjuPrices) {\n                totalManjuPrice += currentCapacity * price;\n            }\n\n            // Calculate profit for the current box type\n            int currentProfit = totalManjuPrice - currentBoxPrice;\n            maxProfit = Math.max(maxProfit, currentProfit);\n        }\n\n        return maxProfit;\n    }\n}",
    "timestamp": "2025-08-13 01:12:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint main() {\n    int m, b;\n    scanf(\"%d %d\", &m, &b);\n\n    int manjuPrices[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &manjuPrices[i]);\n    }\n\n    int boxCapacities[b];\n    int boxPrices[b];\n    for (int i = 0; i < b; i++) {\n        scanf(\"%d %d\", &boxCapacities[i], &boxPrices[i]);\n    }\n\n    int maxProfit = 0;\n    for (int i = 0; i < b; i++) {\n        int capacity = boxCapacities[i];\n        int boxCost = boxPrices[i];\n\n        int currentProfit = 0;\n        for (int j = 0; j < m && j < capacity; j++) {\n            currentProfit += manjuPrices[j];\n        }\n        currentProfit -= boxCost;\n\n        if (currentProfit > maxProfit) {\n            maxProfit = currentProfit;\n        }\n    }\n\n    printf(\"%d\\n\", maxProfit);\n    return 0;\n}",
    "timestamp": "2025-08-13 01:12:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_profit_manju_sets():\n    # Read number of Manju varieties and box types\n    num_manju, num_boxes = map(int, input().split())\n    \n    # Read Manju prices\n    manju_prices = list(map(int, input().split()))\n    \n    # Read box details: capacity and price\n    boxes = []\n    for _ in range(num_boxes):\n        capacity, price = map(int, input().split())\n        boxes.append((capacity, price))\n    \n    # Initialize maximum profit\n    max_profit = 0\n    \n    # Try all possible combinations of boxes\n    for box_combination in range(1, 2**num_boxes):\n        current_profit = 0\n        current_manju_count = [0] * num_manju\n        \n        # Check which boxes are selected in this combination\n        for box_idx in range(num_boxes):\n            if box_combination & (1 << box_idx):\n                box_capacity, box_price = boxes[box_idx]\n                \n                # Find max number of each Manju type for this box\n                box_manju_counts = [0] * num_manju\n                for manju_type in range(num_manju):\n                    box_manju_counts[manju_type] = min(box_capacity // (manju_type + 1), \n                                                       box_capacity - sum(box_manju_counts))\n                \n                # Update current manju count and profit\n                for manju_type in range(num_manju):\n                    current_manju_count[manju_type] += box_manju_counts[manju_type]\n                \n                current_profit -= box_price\n        \n        # Calculate profit from selling Manju sets\n        for manju_type in range(num_manju):\n            current_profit += current_manju_count[manju_type] * (manju_type + 1) * manju_prices[manju_type]\n        \n        # Update maximum profit\n        max_profit = max(max_profit, current_profit)\n    \n    return max_profit\n\n# Run the solution\nprint(max_profit_manju_sets())",
    "timestamp": "2025-08-13 01:12:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    manjus = list(map(int, data[idx:idx+N]))\n    idx += N\n    \n    boxes = []\n    for _ in range(M):\n        C = int(data[idx])\n        P = int(data[idx+1])\n        boxes.append((C, P))\n        idx += 2\n    \n    # Sort manjus in descending order to maximize profit\n    manjus.sort(reverse=True)\n    \n    # Sort boxes by ascending capacity then ascending price for efficiency\n    boxes.sort()\n    \n    max_profit = 0\n    \n    # Precompute prefix sum of manjus\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i+1] = prefix_sum[i] + manjus[i]\n    \n    # For each box, find the maximum number of manjus it can hold and calculate profit\n    for C, P in boxes:\n        if C > N:\n            current_profit = prefix_sum[N] - P\n        else:\n            current_profit = prefix_sum[C] - P\n        if current_profit > max_profit:\n            max_profit = current_profit\n    \n    print(max_profit)\n\nsolve()",
    "timestamp": "2025-08-13 01:13:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Manju {\n    int price;\n};\n\nstruct Box {\n    int capacity;\n    int price;\n};\n\nint main() {\n    int numManjuVarieties, numBoxTypes;\n    std::cin >> numManjuVarieties >> numBoxTypes;\n\n    std::vector<Manju> manjus(numManjuVarieties);\n    for (int i = 0; i < numManjuVarieties; ++i) {\n        std::cin >> manjus[i].price;\n    }\n\n    std::vector<Box> boxes(numBoxTypes);\n    for (int i = 0; i < numBoxTypes; ++i) {\n        std::cin >> boxes[i].capacity >> boxes[i].price;\n    }\n\n    int maxProfit = 0;\n    for (const auto& box : boxes) {\n        int currentProfit = 0;\n        for (const auto& manju : manjus) {\n            currentProfit += box.capacity * manju.price;\n        }\n        currentProfit -= box.price;\n        maxProfit = std::max(maxProfit, currentProfit);\n    }\n\n    std::cout << maxProfit << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:58:56"
  }
]