[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nobject Main extends App {\n  import scala.io.StdIn._\n\n\n  val Array(_w, _h, m) = readLine.trim.split(' ').map(_.toInt)\n  val _walls = Array.tabulate(m){_ ⇒\n    val Array(px, py, qx, qy) = readLine.trim.split(' ').map(_.toInt)\n    Wall(Coordinate(px, py), Coordinate(qx, qy))\n  }\n  val (h, w, walls, compressor) = compressed(_h, _w, _walls)\n  //coordinate.x < w && coordinate.y < h\n  val state = Array.tabulate(h){_ ⇒ Array.tabulate(w){_ ⇒ true}}\n  for (w ← walls) {\n    if (w.from.x == w.to.x) {\n      for (y ← math.min(w.from.y, w.to.y) to math.max(w.from.y, w.to.y)) {\n        state(y)(w.from.x) = false\n      }\n    }else {\n      for (x ← math.min(w.from.x, w.to.x) to math.max(w.from.x, w.to.x)){\n        state(w.from.y)(x) = false\n      }\n    }\n  }\n  val represent = Array.tabulate(h){y ⇒ Array.tabulate(w){x ⇒ new UnionFind(-1)}}\n\n  for (x ← 0 until w; y ← 0 until h if state(y)(x)) {\n    if (x + 1 < w && state(y)(x + 1)){\n      represent(y)(x).merge(represent(y)(x + 1))\n    }\n    if (y + 1 < h && state(y + 1)(x)){\n      represent(y)(x).merge(represent(y + 1)(x))\n    }\n  }\n  var nodeCount = 0\n  for (x ← 0 until w; y ← 0 until h if state(y)(x)){\n    if (represent(y)(x).id == -1){\n      represent(y)(x).id = nodeCount\n      nodeCount += 1\n    }\n  }\n  val hasEdge = Array.tabulate(nodeCount){ _ ⇒ Array.tabulate(nodeCount){ _ ⇒ false}}\n  for (x ← 0 until w; y ← 0 until h if !state(y)(x)) {\n    if (x + 1 < w && 0 <= w - 1 && state(y)(x + 1) && state(y)(x - 1) && !represent(y)(x + 1).isSameUnion(represent(y)(x - 1))) {\n      hasEdge(represent(y)(x + 1).id)(represent(y)(x - 1).id) = true\n      hasEdge(represent(y)(x - 1).id)(represent(y)(x + 1).id) = true\n    }\n    if (y + 1 < h && 0 <= h - 1 && state(y + 1)(x) && state(y - 1)(x) && !represent(y + 1)(x).isSameUnion(represent(y - 1)(x))) {\n      hasEdge(represent(y + 1)(x).id)(represent(y - 1)(x).id) = true\n      hasEdge(represent(y - 1)(x).id)(represent(y + 1)(x).id) = true\n    }\n  }\n  val nodes = hasEdge.map(a ⇒ a.indices.filter(a).toArray)\n  val minCost = Array.tabulate(nodeCount){_ ⇒ Int.MaxValue}\n  val queue = mutable.Queue[Int]()\n  for (_ ← 0 until readInt){\n    minCost.indices.foreach(i ⇒ minCost(i) = -1)\n    queue.clear()\n    val Array(sx, sy, gx, gy) = readLine.trim.split(' ').map(_.toInt)\n    val startNode = compressor.compress(Coordinate(sx, sy)).let(c ⇒ represent(c.y)(c.x).id)\n    val goalNode = compressor.compress(Coordinate(gx, gy)).let(c ⇒ represent(c.y)(c.x).id)\n    minCost(startNode) = 0\n    queue.enqueue(startNode)\n    while(minCost(goalNode) == -1){\n      val current = queue.dequeue()\n      for (next ← nodes(current) if minCost(next) == -1){\n        minCost(next) = minCost(current) + 1\n        queue.enqueue(next)\n      }\n    }\n    println(minCost(goalNode))\n  }\n\n\n  class UnionFind(private var mId: Int) {\n    private var mParent: UnionFind = this\n    private var size: Int = 1\n    private def parent: UnionFind = {\n      if (mParent != this){\n        mParent = mParent.parent\n      }\n      mParent\n    }\n    def isSameUnion(that: UnionFind): Boolean = {\n      parent == that.parent\n    }\n    def merge(that: UnionFind): Unit = {\n      if (!isSameUnion(that)) {\n        val thisP = parent\n        val thatP = that.parent\n        if (thisP.size > thatP.size){\n          thatP.mParent = thisP\n          thisP.size += thatP.size\n        }else {\n          thisP.mParent = thatP\n          thatP.size += thisP.size\n        }\n      }\n    }\n    def id: Int = parent.mId\n    def id_=(newValue:Int): Unit = parent.mId = newValue\n  }\n  def compressed(h: Int, w: Int, walls: Array[Wall]): (Int, Int, Array[Wall], CoordinateCompressor) = {\n    val compressor = CoordinateCompressor(Coordinate(0, 0) +: Coordinate(w, h) +: walls.flatMap(w ⇒ List(w.from, w.to)))\n    val rightBottom = compressor.compress(Coordinate(w, h))\n    (rightBottom.y + 1, rightBottom.x + 1, walls.map(w ⇒ Wall(compressor.compress(w.from), compressor.compress(w.to))), compressor)\n  }\n  case class Coordinate(x: Int, y: Int)\n  case class Wall(from: Coordinate, to: Coordinate)\n  object CoordinateCompressor {\n    def apply(coordinates: Seq[Coordinate]): CoordinateCompressor = {\n      new CoordinateCompressor(new AdaptiveCoordinateCompressor(coordinates.map(_.x)), new AdaptiveCoordinateCompressor(coordinates.map(_.y)))\n    }\n    class AdaptiveCoordinateCompressor(coordinates: Seq[Int]) {\n      private[this] val sortedCoordinates = coordinates.distinct.sorted.toArray\n      private[this] def lowerBound(target: Int): Int = {//sortedCoordinate.head <= target <= sortedCoordinate.last\n        var left = 0\n        var right = sortedCoordinates.length\n        while(left < right){\n          val mid = (left + right) / 2\n          if (sortedCoordinates(mid) < target){\n            left = mid + 1\n          }else {\n            right = mid\n          }\n        }\n        right\n      }\n      def compress(c: Int): Int = {\n        val i = lowerBound(c)\n        if (sortedCoordinates(i) == c) i * 2\n        else i * 2 - 1\n      }\n    }\n  }\n  class CoordinateCompressor private (private[this] val x: CoordinateCompressor.AdaptiveCoordinateCompressor, private[this] val y: CoordinateCompressor.AdaptiveCoordinateCompressor) {\n    def compress(coordinate: Coordinate): Coordinate = {\n      Coordinate(x.compress(coordinate.x), y.compress(coordinate.y))\n    }\n\n  }\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n       // g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      //sx++;\n      sy*=2;\n      //sy++;\n      gx*=2;\n      //gx++;\n      gy*=2;\n      //gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=lower_bound(xv.begin(),xv.end(),sx)-xv.begin();\n      syp=lower_bound(yv.begin(),yv.end(),sy)-yv.begin();\n      gxp=lower_bound(xv.begin(),xv.end(),gx)-xv.begin();\n      gyp=lower_bound(yv.begin(),yv.end(),gy)-yv.begin();\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<50000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[1001][1001]={0};\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  vector<long long> node[1005];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[1005];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      s=masu[syp][sxp];\n      g=masu[gyp][gxp];\n      for(int j=1;j<=now;j++){\n\tmincost[j]=(1LL<<60);\n      }\n      priority_queue<P,vector<P>,greater<P> >que;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tlong long nowc=que.top().first;\n\tlong long nowp=que.top().second;\n\tque.pop();\n\tif(nowp==g){\n\t  cout<<nowc<<endl;\n\t  break;\n\t}\n\tfor(int j=0;j<node[nowp].size();j++){\n\t  long long nextp=node[nowp][j];\n\t  if(mincost[nextp]>nowc+1){\n\t    mincost[nextp]=nowc+1;\n\t    que.push(P(nowc+1,nextp));\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\t//sort(g[i].begin(),g[i].end());\n       // g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[801][801];\nint used[801][801];\n\nint dp[801][801];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]*=2;\n\t\tsy[i]*=2;\n\t\tgx[i]*=2;\n\t\tgy[i]*=2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]),\n\t  g[a[ry][rx]].push_back(a[y][x]);\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<map>\n#include<algorithm>\n\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = false, WALL = true};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nint Dijkstra(const vector<vector<bool>>& field, int sx, int sy, int gx, int gy) {\n  const int h = field.size();\n  const int w = field.front().size();\n\n  typedef tuple<int, int, int> Node;\n\n  vector<vector<bool>> visited(h, vector<bool>(w, false));\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, sy, sx);\n  while(!q.empty()) {\n    int cost, y, x;\n    tie(cost, y, x) = q.top();\n    q.pop();\n    if(y == gy && x == gx) return cost;\n    if(visited[y][x]) continue;\n    visited[y][x] = true;\n//     cout << cost << \", \" << y << \", \" << x << endl;\n    for(const auto& d: NEXT) {\n      int ncost = cost;\n      int ny = y + d[Y];\n      int nx = x + d[X];\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(field[ny][nx] == WALL) {\n        ny += d[Y];\n        nx += d[X];\n        ++ncost;\n      }\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(!visited[ny][nx]) q.emplace(ncost, ny, nx);\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n  vector<vector<bool>> field(y.size(), vector<bool>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n//   for(auto i: field) {\n//     for(auto j: i)cout<<\" \"<<j;\n//     cout<<endl;\n//   }\n\n  for(const auto& q: query) {\n    cout << Dijkstra(field, x.index(q.sx), y.index(q.sy), x.index(q.gx), y.index(q.gy)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nint px[114];ll py[114];ll qx[114];ll qy[114];\nvector<int> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nbool f[401][401];\nint sx1,sy1,gx1,gy1;\nint WW,HH;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%d%d%d\",&W,&H,&M);W*=2;H*=2;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;py[i]*=2;qx[i]*=2;qy[i]*=2;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\tf[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tint sx,sy,gx,gy;\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\tsx*=2;sy*=2;gx*=2;gy*=2;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\ts[sx1][sy1]=0;f[sx1][sy1]=true;\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\t\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair<int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<ds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\tds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[701][701];\nint s[500001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[500001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[2000][2000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n\n    printf(\"%d\\n\",dist[t]);\n}\n\nint main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nqueue<P> que;\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tif(y<500&&x<500&&y>=0&&x>=0){\n\t  masu[y][x]=-1;\n\t}\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < xs.size() - 1 && y < ys.size() - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * ys.size() + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(xs.size() * ys.size());\n\tgraph = vector<vector<int> >(xs.size() * ys.size(), vector<int>());\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[701][701];\nint s[500001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[500001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx;xidx<maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny;yidx<maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n      \n      if(cost[y][x]&&cost[ny][nx]) continue;\n      \n      if(ny==0||nx==0||ny>=rY[h]||nx>=rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\t\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n  \n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1 << 28)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct State {\n\tint x, y, cnt;\n\tState (int x, int y, int cnt) : x(x), y(y), cnt(cnt){}\n\tbool operator < (const State &t) const {\n\t\treturn cnt > t.cnt;\n\t}\n};\n\nint w, h, m, q;\nvector<int> ZX, ZY;\nint PX[200], PY[200], QX[200], QY[200];\nint SX[100], SY[100], GX[100], GY[100];\nbool grid[2048][2048];\nint d[2048][2048];\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < ZX.size() && y < ZY.size();\n}\n\nvoid solve(int sx, int sy, int gx, int gy)\n{\n\tfill((int*)d, (int*)d + 1024 * 1024, INF);\n\tpriority_queue<State> pq;\n\tfor (pq.push(State(sx, sy, 0)); pq.size(); ){\n\t\tState st = pq.top(); pq.pop();\n\t\tif (d[st.x][st.y] < st.cnt) continue;\n\t\tif (st.x == gx && st.y == gy){\n\t\t\tprintf(\"%d\\n\", st.cnt);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//printf(\"%d %d %d\\n\", st.x, st.y, st.cnt);\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = st.x + dx[dir];\n\t\t\tint ny = st.y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[st.x][st.y] && grid[nx][ny]) continue;\n\t\t\tint nc = st.cnt + grid[nx][ny];\n\t\t\tif (d[nx][ny] > nc){\n\t\t\t\tpq.push(State(nx, ny, nc));\n\t\t\t\td[nx][ny] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &m);\n\tZX.push_back(0);\n\tZY.push_back(0);\n\tZX.push_back(w * 2);\n\tZY.push_back(h * 2);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tPX[i] *= 2;\n\t\tPY[i] *= 2;\n\t\tQX[i] *= 2;\n\t\tQY[i] *= 2;\n\t\tZX.push_back(PX[i]);\n\t\tZY.push_back(PY[i]);\n\t\tZX.push_back(QX[i]);\n\t\tZY.push_back(QY[i]);\n\t\tZX.push_back(PX[i] + 1);\n\t\tZY.push_back(PY[i] + 1);\n\t\tZX.push_back(QX[i] + 1);\n\t\tZY.push_back(QY[i] + 1);\n\t}\n\tPX[m] = 0; PY[m] = 0;\n\tQX[m] = w * 2; QY[m] = 0;\n\tPX[m + 1] = 0; PY[m + 1] = 0;\n\tQX[m + 1] = 0; QY[m + 1] = h * 2;\n\tPX[m + 2] = w * 2; PY[m + 2] = 0;\n\tQX[m + 2] = w * 2; QY[m + 2] = h * 2;\n\tPX[m + 3] = 0; PY[m + 3] = h * 2;\n\tQX[m + 3] = w * 2; QY[m + 3] = h * 2;\n\tm += 4;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tSX[i] *= 2;\n\t\tSY[i] *= 2;\n\t\tGX[i] *= 2;\n\t\tGY[i] *= 2;\n\t\tZX.push_back(SX[i]);\n\t\tZY.push_back(SY[i]);\n\t\tZX.push_back(GX[i]);\n\t\tZY.push_back(GY[i]);\n\t\tZX.push_back(SX[i] + 1);\n\t\tZY.push_back(SY[i] + 1);\n\t\tZX.push_back(GX[i] + 1);\n\t\tZY.push_back(GY[i] + 1);\n\t}\n\tsort(ZX.begin(), ZX.end());\n\tZX.erase(lower_bound(ZX.begin(), ZX.end(), w * 2 + 1), upper_bound(ZX.begin(), ZX.end(), w * 2 + 1));\n\tZX.erase(unique(ZX.begin(), ZX.end()), ZX.end());\n\tsort(ZY.begin(), ZY.end());\n\tZY.erase(lower_bound(ZY.begin(), ZY.end(), h * 2 + 1), upper_bound(ZY.begin(), ZY.end(), h * 2 + 1));\n\tZY.erase(unique(ZY.begin(), ZY.end()), ZY.end());\n\tfor (int i = 0; i < m; i++){\n\t\tPX[i] = lower_bound(ZX.begin(), ZX.end(), PX[i]) - ZX.begin();\n\t\tPY[i] = lower_bound(ZY.begin(), ZY.end(), PY[i]) - ZY.begin();\n\t\tQX[i] = lower_bound(ZX.begin(), ZX.end(), QX[i]) - ZX.begin();\n\t\tQY[i] = lower_bound(ZY.begin(), ZY.end(), QY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tSX[i] = lower_bound(ZX.begin(), ZX.end(), SX[i]) - ZX.begin();\n\t\tSY[i] = lower_bound(ZY.begin(), ZY.end(), SY[i]) - ZY.begin();\n\t\tGX[i] = lower_bound(ZX.begin(), ZX.end(), GX[i]) - ZX.begin();\n\t\tGY[i] = lower_bound(ZY.begin(), ZY.end(), GY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int x = PX[i]; x <= QX[i]; x++){\n\t\t\tfor (int y = PY[i]; y <= QY[i]; y++){\n\t\t\t\tgrid[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < ZY.size(); i++){\n\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\tprintf(\"%c\", grid[j][i] ? '+' : ' ');\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < q; i++){\n\t\t//printf(\"%d:\\n\", i);\n\t\tsolve(SX[i], SY[i], GX[i], GY[i]);\n\t\t/*for (int i = 0; i < ZY.size(); i++){\n\t\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\t\tprintf(\"%d\", d[j][i] - INF ? d[i][j] : 9);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 210\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      if( dx != 0 && dy != 0 ) continue;\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\ninline bool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid[0].size() - 1) return false;\n\treturn true;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * grid[0].size() + y;\n}\n\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t/*\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}*/\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define mp make_pair\n#define int long long\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> POS;\ntypedef pair<int,POS> P;\nint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\nsigned main(){\n\tint w,h,m,q,px[100],py[100],qx[100],qy[100];\n\tbool ng[200][200][4] = {};\n\tvector<int> xs,ys;\n\tcin >> w >> h >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> px[i] >> py[i] >> qx[i] >> qy[i];\n\t\tif(px[i] > qx[i]) swap(px[i],qx[i]);\n\t\tif(py[i] > qy[i]) swap(py[i],qy[i]);\n\t\txs.push_back(px[i]);\n\t\tys.push_back(py[i]);\n\t\txs.push_back(qx[i]);\n\t\tys.push_back(qy[i]);\n\t}\n\txs.push_back(0);\n\txs.push_back(w);\n\tys.push_back(0);\n\tys.push_back(h);\n\tsort(xs.begin(),xs.end());\n\tsort(ys.begin(),ys.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tys.erase(unique(ys.begin(),ys.end()),ys.end());\n\tfor(int i = 0;i < xs.size() - 1;i++){\n\t\tfor(int j = 0;j < ys.size() - 1;j++){\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tif(px[k] <= xs[i] && xs[i + 1] <= qx[k]){\n\t\t\t\t\tif(ys[j] == py[k]) ng[i][j][0] = true;\n\t\t\t\t\telse if(ys[j + 1] == py[k]) ng[i][j][2] = true;\n\t\t\t\t}else if(py[k] <= ys[j] && ys[j + 1] <= qy[k]){\n\t\t\t\t\tif(xs[i] == px[k]) ng[i][j][3] = true;\n\t\t\t\t\telse if(xs[i + 1] == px[k]) ng[i][j][1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tint sx,sy,gx,gy,x1,y1,x2,y2,d[110][110];\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tfor(int j = 0;j < xs.size();j++){\n\t\t\tfor(int k = 0;k < ys.size();k++) d[j][k] = INF;\n\t\t}\n\t\tfor(int j = 0;j < xs.size() - 1;j++){\n\t\t\tif(xs[j] <= sx && sx <= xs[j + 1]) x1 = j;\n\t\t\tif(xs[j] <= gx && gx <= xs[j + 1]) x2 = j;\n\t\t}\n\t\tfor(int j = 0;j < ys.size() - 1;j++){\n\t\t\tif(ys[j] <= sy && sy <= ys[j + 1]) y1 = j;\n\t\t\tif(ys[j] <= gy && gy <= ys[j + 1]) y2 = j;\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0,mp(x1,y1)));\n\t\td[x1][y1] = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint x = p.second.first,y = p.second.second;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tint nx = x + dx[j],ny = y + dy[j];\n\t\t\t\tif(nx >= 0 && nx < xs.size() - 1 && ny >= 0 && ny < ys.size() - 1 && d[nx][ny] > d[x][y] + ng[x][y][j]){\n\t\t\t\t\td[nx][ny] = d[x][y] + ng[x][y][j];\n\t\t\t\t\tque.push(mp(d[nx][ny],mp(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << d[x2][y2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>H||nx<0||nx>W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    W*=2;H*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;ys.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[1001][1001]={0};\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  \n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  \n  vector<long long> node[1005];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[1005];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      s=masu[syp][sxp];\n      g=masu[gyp][gxp];\n      for(int j=1;j<=now;j++){\n\tmincost[j]=(1LL<<60);\n      }\n      priority_queue<P,vector<P>,greater<P> >que;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tlong long nowc=que.top().first;\n\tlong long nowp=que.top().second;\n\tque.pop();\n\tif(nowp==g){\n\t  cout<<nowc<<endl;\n\t  break;\n\t}\n\tfor(int j=0;j<node[nowp].size();j++){\n\t  long long nextp=node[nowp][j];\n\t  if(mincost[nextp]>nowc+1){\n\t    mincost[nextp]=nowc+1;\n\t    que.push(P(nowc+1,nextp));\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    cout<<dist[t]<<endl;\n}\n\nint main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        if(x1[i]>x2[i])swap(x1[i],x2[i]);\n        if(y1[i]>y2[i])swap(y1[i],y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    W*=2;H*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;ys.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[2000][2000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%lld%lld%lld%lld\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%lld%lld%lld%lld\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 座標圧縮 + ダイクストラ\n\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\n\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::unordered_map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = false, WALL = true};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nint Dijkstra(const vector<vector<bool>>& field, int sx, int sy, int gx, int gy) {\n  const int H = field.size();\n  const int W = field.front().size();\n\n  typedef tuple<int, int, int> Node;\n\n  vector<vector<bool>> visited(H, vector<bool>(W, false));\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, sy, sx);\n  while(!q.empty()) {\n    int cost, y, x;\n    tie(cost, y, x) = q.top();\n    q.pop();\n    if(y == gy && x == gx) return cost;\n    if(visited[y][x]) continue;\n    visited[y][x] = true;\n//     cout << cost << \", \" << y << \", \" << x << endl;\n    for(int dy: {-1, 0, 1}) for(int dx: {-1, 0, 1}) {\n      int ncost = cost;\n      int ny = y + dy;\n      int nx = x + dx;\n      if(ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n      if(field[ny][nx] == WALL) {\n        ny += dy;\n        nx += dx;\n        ++ncost;\n      }\n      if(ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n      if(!visited[ny][nx]) q.emplace(ncost, ny, nx);\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(q.sx + d, 0, W), range(q.gx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(q.sy + d, 0, H), range(q.gy + d, 0, H)});\n    }\n  }\n\n  Compression x(raw_x), y(raw_y);\n  vector<vector<bool>> field(y.size(), vector<bool>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n//   for(auto i: field) {\n//     for(auto j: i)cout<<\" \"<<j;\n//     cout<<endl;\n//   }\n\n  for(const auto& q: query) {\n    cout << Dijkstra(field, x.index(q.sx), y.index(q.sy), x.index(q.gx), y.index(q.gy)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx;xidx<=maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny;yidx<=maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n\n      if(ny==0||nx==0||ny==rY[h]||nx==rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n  \n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx+1;xidx<=maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny+1;yidx<=maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n\n      if(ny==0||nx==0||ny>=rY[h]||nx>=rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n  \n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[701][701];\nint s[500001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[500001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\t//if(ax>=bx)swap(ax,bx);\n\t\t//if(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<H){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[801][801];\nint used[801][801];\n\nint dp[801][801];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]*=2;\n\t\tsy[i]*=2;\n\t\tgx[i]*=2;\n\t\tgy[i]*=2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define mp make_pair\n#define int long long\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> POS;\ntypedef pair<int,POS> P;\nint dx[] = {0,1,0,-1},dy[] = {-1,0,1,0};\n\nsigned main(){\n\tint w,h,m,q,px[100],py[100],qx[100],qy[100];\n\tbool ng[210][210][4] = {};\n\tvector<int> xs,ys;\n\tcin >> w >> h >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> px[i] >> py[i] >> qx[i] >> qy[i];\n\t\tif(px[i] > qx[i]) swap(px[i],qx[i]);\n\t\tif(py[i] > qy[i]) swap(py[i],qy[i]);\n\t\txs.push_back(px[i]);\n\t\tys.push_back(py[i]);\n\t\txs.push_back(qx[i]);\n\t\tys.push_back(qy[i]);\n\t}\n\txs.push_back(0);\n\txs.push_back(w);\n\tys.push_back(0);\n\tys.push_back(h);\n\tsort(xs.begin(),xs.end());\n\tsort(ys.begin(),ys.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tys.erase(unique(ys.begin(),ys.end()),ys.end());\n\tfor(int i = 0;i < xs.size() - 1;i++){\n\t\tfor(int j = 0;j < ys.size() - 1;j++){\n\t\t\tfor(int k = 0;k < m;k++){\n\t\t\t\tif(px[k] <= xs[i] && xs[i + 1] <= qx[k]){\n\t\t\t\t\tif(ys[j] == py[k]) ng[i][j][0] = true;\n\t\t\t\t\telse if(ys[j + 1] == py[k]) ng[i][j][2] = true;\n\t\t\t\t}else if(py[k] <= ys[j] && ys[j + 1] <= qy[k]){\n\t\t\t\t\tif(xs[i] == px[k]) ng[i][j][3] = true;\n\t\t\t\t\telse if(xs[i + 1] == px[k]) ng[i][j][1] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcin >> q;\n\tfor(int i = 0;i < q;i++){\n\t\tint sx,sy,gx,gy,x1,y1,x2,y2,d[210][210];\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tfor(int j = 0;j <= 200;j++){\n\t\t\tfor(int k = 0;k <= 200;k++) d[j][k] = INF;\n\t\t}\n\t\tfor(int j = 0;j < xs.size() - 1;j++){\n\t\t\tif(xs[j] <= sx && sx <= xs[j + 1]) x1 = j;\n\t\t\tif(xs[j] <= gx && gx <= xs[j + 1]) x2 = j;\n\t\t}\n\t\tfor(int j = 0;j < ys.size() - 1;j++){\n\t\t\tif(ys[j] <= sy && sy <= ys[j + 1]) y1 = j;\n\t\t\tif(ys[j] <= gy && gy <= ys[j + 1]) y2 = j;\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(mp(0,mp(x1,y1)));\n\t\td[x1][y1] = 0;\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint x = p.second.first,y = p.second.second;\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tint nx = x + dx[j],ny = y + dy[j];\n\t\t\t\tif(nx >= 0 && nx < xs.size() - 1 && ny >= 0 && ny < ys.size() - 1 && d[nx][ny] > d[x][y] + ng[x][y][j]){\n\t\t\t\t\td[nx][ny] = d[x][y] + ng[x][y][j];\n\t\t\t\t\tque.push(mp(d[nx][ny],mp(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << d[x2][y2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x < 0 || y < 0 || x >= grid.size() || y >= grid.size()) return false;\n\tif (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t//if (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (ns) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid.size() - 1) return false;\n\t/*if (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;*/\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[5001][5001]={0};\nvector<long long> node[105005];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i]&&y<h;y++){\n      for(long long x=X1[i];x<=X2[i]&&x<w;x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[105005];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[605]605];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=100101001;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nvector<int> edge[10001];\nint fie[1001][1001];\nint dp[10001];\nint cnt;\n\nint sx[101],sy[101],gx[101],gy[101];\n\n\nint bfs(int x,int y){\n\tqueue <P> que;\n\tque.push(P(x,y));\n\tfie[x][y]=cnt;\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tint xx=p.first,yy=p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tfie[nx][ny]=cnt;\n\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<int> que;\n\tdp[f]=0;\n\tque.push(f);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tif(v==t)return dp[t];\n\t\tfor(int i=0;i<edge[v].size();i++){\n\t\t\tint next=edge[v][i];\n\t\t\tif(dp[next]==-1){\n\t\t\t\tdp[next]=dp[v]+1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\tif(px[i]>0)xid.push_back(px[i]-1);\n\t\tif(qx[i]>0)xid.push_back(qx[i]-1);\n\t\tif(py[i]>0)yid.push_back(py[i]-1);\n\t\tif(qy[i]>0)yid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\tif(px[i]+1<w*2)xid.push_back(px[i]+1);\n\t\tif(qx[i]+1<w*2)xid.push_back(qx[i]+1);\n\t\tif(py[i]+1<h*2)yid.push_back(py[i]+1);\n\t\tif(qy[i]+1<h*2)yid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=-1;\n\t\t\tfie[j][qy[i]]=-1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=-1;\n\t\t\tfie[qx[i]][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tif(fie[j][i]==0){\n\t\t\t\tcnt++;\n\t\t\t\tbfs(j,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tif(fie[j][i]>=1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k]*2,ny=i+dy[k]*2;\n\t\t\t\t\tif(nx>=0 && nx<xid.size() && ny>=0 && ny<yid.size()){\n\t\t\t\t\t\tif(fie[nx][ny]>=0 && fie[nx][ny]!=fie[j][i]){\n\t\t\t\t\t\t\tint l;\n\t\t\t\t\t\t\tfor(l=0;l<edge[fie[j][i]].size();l++){\n\t\t\t\t\t\t\t\tif(edge[fie[j][i]][l]==fie[nx][ny])break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l==edge[fie[j][i]].size()){\n\t\t\t\t\t\t\t\tedge[fie[j][i]].push_back(fie[nx][ny]);\n\t\t\t\t\t\t\t\tedge[fie[nx][ny]].push_back(fie[j][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs2(fie[sx[i]][sy[i]],fie[gx[i]][gy[i]]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n  \nint cnt;\nint edge[1000][1000];\n  \nbool mas[1000][1000];\nint number[1000][1000];\nbool used[1000][1000];\n  \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint H, W;\n  \nvoid dfs2(int y, int x){\n  if(used[y][x]++) return;\n     \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    int sanoy = y - dy[i], sanox = x - dx[i];\n  \n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(sanoy > H || sanoy < 0 || sanox > W || sanox < 0) continue;\n    if(mas[ny][nx] || mas[sanoy][sanox]) continue;\n  \n    edge[number[ny][nx]][number[sanoy][sanox]] = 1;\n    edge[number[sanoy][sanox]][number[ny][nx]] = 1;\n  }\n  \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(!mas[ny][nx]) continue;\n    dfs2( ny, nx);\n  }\n  \n  return;\n}\nvoid dfs(int y, int x, const int num){\n  if(number[y][x] != -1) return;\n  number[y][x] = num;\n  \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(mas[ny][nx]) continue;\n    if(number[ny][nx] == -1) dfs( ny, nx, num);\n  }\n  return;\n}\n  \npair< int, vector< int > > compress( vector< int >& x,const int w){\n  vector< int > xs;\n  for(int i = 0; i < x.size() ; i++ ){\n    for(int d = -1; d <= 1 ; d++ ){\n      int nx = x[i] + d;\n      if(0 <= nx && nx < w) xs.push_back(nx);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i = 0 ; i < x.size() ; i++ ){\n    x[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n  }\n  return make_pair( xs.size(), xs);\n}\n  \nint main(){\n  int M;\n  \n  cin >> W >> H >> M;\n  \n  M += 4;\n  vector< int > x(2 * M), y(2 * M);\n  \n  for(int i = 0; i < M - 4; i++){\n    cin >> x[i] >> y[i] >> x[i + M] >> y[i + M];\n  \n    x[i] *= 2, y[i] *= 2, x[i + M] *= 2, y[i + M] *= 2;\n    if(x[i] > x[i + M]) swap(x[i], x[i + M]);\n    if(y[i] > y[i + M]) swap(y[i], y[i + M]);\n  }\n \n  x[M - 4] = W * 2, x[2 * M - 4] = W * 2;\n  y[M - 4] = 0, y[2 * M - 4] = H * 2;\n \n  x[M - 3] = 0, x[2 * M - 3] = W * 2;\n  y[M - 3] = H * 2, y[2 * M - 3] = H * 2;\n \n  x[M - 2] = 0, x[2 * M - 2] = 0;\n  y[M - 2] = 0, y[2 * M - 2] = H * 2;\n \n  x[M - 1] = 0, x[2 * M - 1] = W * 2;\n  y[M - 1] = 0, y[2 * M - 1] = 0;\n  \n  pair< int , vector< int > > hoge = compress( x, 2 * W);\n  pair< int , vector< int > > hoge2 = compress( y, 2 * H);\n  W = hoge.first;\n  H = hoge2.first;\n  \n  for(int i = 0; i < M; i++){\n    if(y[i] == y[i + M]){\n      for(int j = x[i]; j < x[i + M]; j++){\n        mas[y[i]][j] = true;\n      }\n    } else {\n      for(int j = y[i]; j < y[i + M]; j++){\n        mas[j][x[i]] = true;\n      }\n    }\n  }\n \n  memset( number, -1, sizeof(number));\n  cnt = 0;\n  for(int i = 0; i <= H; i++){\n    for(int j = 0; j <= W; j++){\n      if(!mas[i][j] && number[i][j] == -1) dfs( i, j, cnt++);\n    }\n  }\n  \n  memset( used, false, sizeof(used));\n  fill_n( *edge, 1000 * 1000, INF);\n  \n  for(int i = 0; i < M; i++){\n    if(!used[y[i]][x[i]]) dfs2( y[i], x[i]);\n  }\n  \n  for(int i = 0; i < cnt; i++){\n    edge[i][i] = 0;\n  }\n  \n  for(int k = 0; k < cnt; k++){\n    for(int i = 0; i < cnt; i++){\n      if(edge[i][k] == INF) continue;\n      for(int j = 0; j < cnt; j++){\n        if(edge[k][j] == INF) continue;\n        edge[i][j] = min( edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n  \n  int q;\n  cin >> q;\n  \n  sort( x.begin(), x.end());\n  sort( y.begin(), y.end());\n  \n  while(q--){\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n  \n    a *= 2, b *= 2, c *= 2, d *= 2;\n \n    //????????£??¨??§????????¨??????\n    int sx = upper_bound( hoge.second.begin(), hoge.second.end(), a) - hoge.second.begin();\n    int sy = upper_bound( hoge2.second.begin(), hoge2.second.end(), b) - hoge2.second.begin();\n    int gx = upper_bound( hoge.second.begin(), hoge.second.end(), c) - hoge.second.begin();\n    int gy = upper_bound( hoge2.second.begin(), hoge2.second.end(), d) - hoge2.second.begin();\n    cout << edge[number[sy][sx]][number[gy][gx]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t\tif(W>=1000000000&&i==0)return 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx;xidx<maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny;yidx<maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n\n      if(ny==0||nx==0||ny>=rY[h]||nx>=rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n  \n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint H, W, N, Q, px[109], py[109], qx[109], qy[109], sx[109], sy[109], gx[109], gy[109], dist[10009];\nvector<int>X, Y; bool wall[1009][1009]; int col[1009][1009], cntw; vector<int>G[10009]; map<pair<int, int>, int>M;\n\nvoid dfs(int cx, int cy) {\n\tcol[cx][cy] = cntw;\n\tint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\n\tfor (int i = 0; i < 4; i++) {\n\t\tint fx = cx + dx[i], fy = cy + dy[i];\n\t\tif (fx < 0 || fy < 0 || fx >= X.size() || fy >= Y.size() || wall[fx][fy] == true || col[fx][fy] >= 1) continue;\n\t\tdfs(fx, fy);\n\t}\n}\nint solve(int cx, int cy) {\n\tfor (int i = 0; i < 10009; i++)dist[i] = 9999999;\n\tqueue<int>q; q.push(cx); dist[cx] = 0;\n\twhile (!q.empty()) {\n\t\tint to1 = q.front(); q.pop();\n\t\tfor (int i : G[to1]) {\n\t\t\tif (dist[i] > dist[to1] + 1) {\n\t\t\t\tdist[i] = dist[to1] + 1; q.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[cy];\n}\n\nint main() {\n\tcin >> H >> W >> N;\n\tfor (int i = 1; i <= N; i++) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n\tcin >> Q;\n\tfor (int i = 1; i <= Q; i++) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n\tfor (int i = 1; i <= N; i++) {\n\t\tpx[i] *= 2; py[i] *= 2; qx[i] *= 2; qy[i] *= 2;\n\t\tif (px[i] >= 1) X.push_back(px[i] - 1); X.push_back(px[i]); if (px[i] < H * 2) X.push_back(px[i] + 1);\n\t\tif (qx[i] >= 1) X.push_back(qx[i] - 1); X.push_back(qx[i]); if (qx[i] < H * 2) X.push_back(qx[i] + 1);\n\t\tif (py[i] >= 1) Y.push_back(py[i] - 1); Y.push_back(py[i]); if (py[i] < W * 2) Y.push_back(py[i] + 1);\n\t\tif (py[i] >= 1) Y.push_back(qy[i] - 1); Y.push_back(qy[i]); if (qy[i] < W * 2) Y.push_back(qy[i] + 1);\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tsx[i] *= 2; sy[i] *= 2; gx[i] *= 2; gy[i] *= 2;\n\t\tX.push_back(sx[i]); Y.push_back(sy[i]);\n\t\tX.push_back(gx[i]); Y.push_back(gy[i]);\n\t}\n\tX.push_back(0); Y.push_back(0); X.push_back(H * 2); Y.push_back(W * 2);\n\tsort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n\tsort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\tfor (int i = 1; i <= N; i++) {\n\t\tpx[i] = lower_bound(X.begin(), X.end(), px[i]) - X.begin();\n\t\tqx[i] = lower_bound(X.begin(), X.end(), qx[i]) - X.begin();\n\t\tpy[i] = lower_bound(Y.begin(), Y.end(), py[i]) - Y.begin();\n\t\tqy[i] = lower_bound(Y.begin(), Y.end(), qy[i]) - Y.begin();\n\t\tif (px[i] == qx[i]) {\n\t\t\tfor (int j = py[i]; j <= qy[i]; j++) wall[px[i]][j] = true;\n\t\t}\n\t\tif (py[i] == qy[i]) {\n\t\t\tfor (int j = px[i]; j <= qx[i]; j++) wall[j][py[i]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < Y.size(); i++) wall[0][i] = true;\n\tfor (int i = 0; i < Y.size(); i++) wall[X.size() - 1][i] = true;\n\tfor (int i = 0; i < X.size(); i++) wall[i][0] = true;\n\tfor (int i = 0; i < X.size(); i++) wall[i][Y.size() - 1] = true;\n\tfor (int i = 1; i <= Q; i++) {\n\t\tsx[i] = lower_bound(X.begin(), X.end(), sx[i]) - X.begin();\n\t\tgx[i] = lower_bound(X.begin(), X.end(), gx[i]) - X.begin();\n\t\tsy[i] = lower_bound(Y.begin(), Y.end(), sy[i]) - Y.begin();\n\t\tgy[i] = lower_bound(Y.begin(), Y.end(), gy[i]) - Y.begin();\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tif (wall[i][j] == true || col[i][j] >= 1) continue;\n\t\t\tcntw++; dfs(i, j);\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)X.size(); i++) {\n\t\tfor (int j = 0; j < (int)Y.size() - 2; j++) {\n\t\t\tif (wall[i][j] == false && wall[i][j + 1] == true && wall[i][j + 2] == false && col[i][j] != col[i][j + 2]) {\n\t\t\t\tint d1 = col[i][j], d2 = col[i][j + 2];\n\t\t\t\tif (M[make_pair(d1, d2)] == 1) continue;\n\t\t\t\tM[make_pair(d1, d2)] = 1; G[d1].push_back(d2);\n\t\t\t\tM[make_pair(d2, d1)] = 1; G[d2].push_back(d1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)Y.size(); i++) {\n\t\tfor (int j = 0; j < (int)X.size() - 2; j++) {\n\t\t\tif (wall[j][i] == false && wall[j + 1][i] == true && wall[j + 2][i] == false && col[j][i] != col[j + 2][i]) {\n\t\t\t\tint d1 = col[j][i], d2 = col[j + 2][i];\n\t\t\t\tif (M[make_pair(d1, d2)] == 1) continue;\n\t\t\t\tM[make_pair(d1, d2)] = 1; G[d1].push_back(d2);\n\t\t\t\tM[make_pair(d2, d1)] = 1; G[d2].push_back(d1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tcout << solve(col[sx[i]][sy[i]], col[gx[i]][gy[i]]) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[200]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n\t  while(!q.empty())q.pop();\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[505][505];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nint ccccc, ddddd;\nvoid DFS(int XS, int YS){\n\tpriority_queue <pair<int, pair<int, int> > ,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> >  > >que;\n\tque.push(make_pair(0, make_pair(XS, YS)));\n\tint ma = 0;\n\twhile (!que.empty()){\n\t\tpair<int, pair<int, int> >P = que.top(); que.pop();\n\t\tif (P.first > MAP[P.second.first][P.second.second])continue;\n\t\tMAP[P.second.first][P.second.second] = P.first;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (P.second.first + DX[i] >= 0 && P.second.first + DX[i] <= 2 * (ccccc - 1) && P.second.second + DY[i] >= 0 && P.second.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\tif (MAP[P.second.first + DX[i]][P.second.second + DY[i]] == -1){\n\t\t\t\t\tif (MAP[P.second.first + 2 * DX[i]][P.second.second + 2 * DY[i]] > P.first + 1){\n\t\t\t\t\t\tMAP[P.second.first + 2 * DX[i]][P.second.second + 2 * DY[i]] = P.first + 1;\n\t\t\t\t\t\tque.push(make_pair(P.first + 1, make_pair(P.second.first + 2 * DX[i], P.second.second + 2 * DY[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (MAP[P.second.first + DX[i]][P.second.second + DY[i]] > P.first){\n\t\t\t\t\t\tMAP[P.second.first][P.second.second] = P.first;\n\t\t\t\t\t\tque.push(make_pair(P.first, make_pair(P.second.first + DX[i], P.second.second + DY[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid.size() - 1) return false;\n\t/*if (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;*/\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t//if (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (ns) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <tuple>\n#include <cstring>\n\nusing namespace std;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++) \n#define sz(c) ((int)c.size())\n\ntypedef pair<int, int> Pii;\n\nvoid compress(vector<int>& v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint w, h;\ntypedef pair<Pii, int> P;\nvector<P> e[350][350];\nint cost[350][350];\n\nint solve(Pii s, Pii g) {\n\tmemset(cost, 0x1f, sizeof(cost));\n\tdeque<Pii> deq;\n\tdeq.push_back(s);\n\tcost[s.first][s.second] = 0;\n\n\twhile (!deq.empty()) {\n\t\tPii cur = deq.front(); deq.pop_front();\n\t\tif (cur == g) \n            return cost[g.first][g.second];\n\t\tfor (auto to : e[cur.first][cur.second]) {\n\t\t\tint nf, ns;\n\t\t\ttie(nf, ns) = to.first;\n\t\t\tint ncost = cost[cur.first][cur.second] + to.second;\n\t\t\tif (ncost < cost[nf][ns]) {\n\t\t\t\tcost[nf][ns] = ncost;\n\t\t\t\tif (to.second == 0) {\n\t\t\t\t\tdeq.push_front(Pii(nf, ns));\n\t\t\t\t} else {\n\t\t\t\t\tdeq.push_back(Pii(nf, ns));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint m; cin >> w >> h >> m;\n\tvector<int> cx, cy;\n\tcx.push_back(0);\n\tcx.push_back(1);\n\tcx.push_back(w - 1);\n\tcx.push_back(w);\n\tcy.push_back(0);\n\tcy.push_back(1);\n\tcy.push_back(h - 1);\n\tcy.push_back(h);\n\tvector < pair<Pii, Pii>> seg;\n\n\tFOR(i, m) {\n\t\tint pa, pb, qa, qb;\n\t\tcin >> pa >> pb >> qa >> qb;\n\t\tseg.emplace_back(Pii(pa, pb), Pii(qa, qb));\n\t\tif (pa > qa || pb > qb) swap(seg.back().first, seg.back().second);\n\t\tif(pa - 1 >= 0) cx.push_back(pa - 1);\n\t\tcx.push_back(pa);\n\t\tif (pa + 1 <= w) cx.push_back(pa + 1);\n\t\tif (qa - 1 >= 0) cx.push_back(qa - 1);\n\t\tcx.push_back(qa);\n\t\tif (qa + 1 <= w) cx.push_back(qa + 1);\n\n\t\tif (pb - 1 >= 0) cy.push_back(pb - 1);\n\t\tcy.push_back(pb);\n\t\tif (pb + 1 <= h) cy.push_back(pb + 1);\n\t\tif (qb - 1 >= 0) cy.push_back(qb - 1);\n\t\tcy.push_back(qb);\n\t\tif (qb + 1 <= h) cy.push_back(qb + 1);\n\t}\n\tcompress(cx); compress(cy);\n\tauto co = [&cx, &cy](Pii xy) {\n\t\tint a = lower_bound(cx.begin(), cx.end(), xy.first) - cx.begin();\n\t\tint b = lower_bound(cy.begin(), cy.end(), xy.second) - cy.begin();\n\t\treturn Pii(a, b);\n\t};\n\ttie(w, h) = co(Pii(w, h));\n\n\tFOR(i, m) {\n\t\tseg[i].first = co(seg[i].first);\n\t\tseg[i].second = co(seg[i].second);\n\t}\n\n\tFOR(x, sz(cx) - 2) FOR(y, sz(cy) - 1) {\n\t\tint nx = x + 1, ny = y;\n\t\tint c = 0;\n\t\tfor (auto& s : seg) {\n\t\t\tif (s.first.first != nx) continue;\n\t\t\tif (s.second.first != nx) continue;\n\t\t\tif (s.first.second <= y && y < s.second.second) c = 1;\n\t\t}\n\t\te[x][y].push_back(P(Pii(nx, ny), c));\n\t\te[nx][ny].push_back(P(Pii(x, y), c));\n\t}\n\tFOR(x, sz(cx) - 1) FOR(y, sz(cy) - 2) {\n\t\tint nx = x , ny = y + 1;\n\t\tint c = 0;\n\t\tfor (auto& s : seg) {\n\t\t\tif (s.first.second != ny) continue;\n\t\t\tif (s.second.second != ny) continue;\n\t\t\tif (s.first.first <= x && x < s.second.first) c = 1;\n\t\t}\n\t\te[x][y].push_back(P(Pii(nx, ny), c));\n\t\te[nx][ny].push_back(P(Pii(x, y), c));\n\t}\n\n\tint q; cin >> q;\n\tFOR(i, q) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tPii s(a, b), g(c, d);\n\t\ts = co(s); s.first--; s.second--;\n\t\tg = co(g); g.first--; g.second--;\n\n\t\tint ans = solve(s, g);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[1001][1001]={0};\nvector<long long> node[105005];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i]&&y<h;y++){\n      for(long long x=X1[i];x<=X2[i]&&x<w;x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[105005];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<long long,long long>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[501][501],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[505];\nbool used[505][505];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(500,500,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=sx&&(*it).f.s>sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=gx&&(*it).f.s>gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=sy&&(*it).f.s>sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=gy&&(*it).f.s>gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[200]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n\t  while(!q.empty())q.pop();\n          break;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }//L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n \nint cnt;\nint edge[1000][1000];\n \nbool mas[1000][1000];\nint number[1000][1000];\nbool used[1000][1000];\n \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint H, W;\n \nvoid dfs2(int y, int x){\n  if(used[y][x]++) return;\n    \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    int sanoy = y - dy[i], sanox = x - dx[i];\n \n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(sanoy > H || sanoy < 0 || sanox > W || sanox < 0) continue;\n    if(mas[ny][nx] || mas[sanoy][sanox]) continue;\n \n    edge[number[ny][nx]][number[sanoy][sanox]] = 1;\n    edge[number[sanoy][sanox]][number[ny][nx]] = 1;\n  }\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(!mas[ny][nx]) continue;\n    dfs2( ny, nx);\n  }\n \n  return;\n}\nvoid dfs(int y, int x, const int num){\n  if(number[y][x] != -1) return;\n  number[y][x] = num;\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(mas[ny][nx]) continue;\n    if(number[ny][nx] == -1) dfs( ny, nx, num);\n  }\n  return;\n}\n \npair< int, vector< int > > compress( vector< int >& x,const int w){\n  vector< int > xs;\n  for(int i = 0; i < x.size() ; i++ ){\n    for(int d = -1; d <= 1 ; d++ ){\n      int nx = x[i] + d;\n      if(0 <= nx && nx < w) xs.push_back(nx);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i = 0 ; i < x.size() ; i++ ){\n    x[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n  }\n  return make_pair( xs.size(), xs);\n}\n \nint main(){\n  int M;\n \n  cin >> W >> H >> M;\n \n  M += 4;\n  vector< int > x(2 * M), y(2 * M);\n \n  for(int i = 0; i < M - 4; i++){\n    cin >> x[i] >> y[i] >> x[i + M] >> y[i + M];\n \n    x[i] *= 2, y[i] *= 2, x[i + M] *= 2, y[i + M] *= 2;\n  }\n\n  x[M - 4] = W * 2, x[2 * M - 4] = W * 2;\n  y[M - 4] = 0, y[2 * M - 4] = H * 2;\n\n  x[M - 3] = 0, x[2 * M - 3] = W * 2;\n  y[M - 3] = H * 2, y[2 * M - 3] = H * 2;\n\n  x[M - 2] = 0, x[2 * M - 2] = 0;\n  y[M - 2] = 0, y[2 * M - 2] = H * 2;\n\n  x[M - 1] = 0, x[2 * M - 1] = W * 2;\n  y[M - 1] = 0, y[2 * M - 1] = 0;\n \n  pair< int , vector< int > > hoge = compress( x, 2 * W);\n  pair< int , vector< int > > hoge2 = compress( y, 2 * H);\n  W = hoge.first;\n  H = hoge2.first;\n \n  for(int i = 0; i < M; i++){\n    if(y[i] == y[i + M]){\n      for(int j = x[i]; j < x[i + M]; j++){\n        mas[y[i]][j] = true;\n      }\n    } else {\n      for(int j = y[i]; j < y[i + M]; j++){\n        mas[j][x[i]] = true;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i < 15; i++){\n    for(int j = 0; j < 15; j++){\n      cout << mas[i][j];\n    }\n    cout << endl;\n  }\n  */\n\n  memset( number, -1, sizeof(number));\n  cnt = 0;\n  for(int i = 0; i <= H; i++){\n    for(int j = 0; j <= W; j++){\n      if(!mas[i][j] && number[i][j] == -1) dfs( i, j, cnt++);\n    }\n  }\n \n  memset( used, false, sizeof(used));\n  fill_n( *edge, 1000 * 1000, INF);\n \n  for(int i = 0; i < M; i++){\n    if(!used[y[i]][x[i]]) dfs2( y[i], x[i]);\n  }\n \n  for(int i = 0; i < cnt; i++){\n    edge[i][i] = 0;\n  }\n \n  for(int k = 0; k < cnt; k++){\n    for(int i = 0; i < cnt; i++){\n      if(edge[i][k] == INF) continue;\n      for(int j = 0; j < cnt; j++){\n        if(edge[k][j] == INF) continue;\n        edge[i][j] = min( edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n \n  int q;\n  cin >> q;\n \n  sort( x.begin(), x.end());\n  sort( y.begin(), y.end());\n \n  while(q--){\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n \n    a *= 2, b *= 2, c *= 2, d *= 2;\n\n    //ちょっと大きいところ\n    int sx = upper_bound( hoge.second.begin(), hoge.second.end(), a) - hoge.second.begin();\n    int sy = upper_bound( hoge2.second.begin(), hoge2.second.end(), b) - hoge2.second.begin();\n    int gx = upper_bound( hoge.second.begin(), hoge.second.end(), c) - hoge.second.begin();\n    int gy = upper_bound( hoge2.second.begin(), hoge2.second.end(), d) - hoge2.second.begin();\n    cout << edge[number[sy][sx]][number[gy][gx]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 3100\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int index,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\n\nint indexMap[MAX][MAX];\nint V;\n\nvector<int> G[MAX];\n\nvoid makeVVV(int nW,int nH) {\n  memset(indexMap,-1,sizeof indexMap);\n  rep(i,nH) rep(j,nW) if( !bmap[i][j] && indexMap[i][j] == -1 ) {\n    indexMap[i][j] = V;\n    deque<int> deq;\n    deq.push_back(j+i*nW);\n    while( !deq.empty() ) {\n      int tmp = deq.front(); deq.pop_front();\n      int x = tmp % nW, y = tmp / nW;\n      rep(i,4) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n        if( bmap[ny][nx] ) continue;\n        if( indexMap[ny][nx] != -1 ) continue;\n        indexMap[ny][nx] = V;\n        deq.push_back(nx+ny*nW);\n      }\n    }\n    ++V;    \n  }\n\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << indexMap[i][j] << \" \";\n    }\n    puts(\"\");\n  } puts(\"\");\n  */\n  \n  rep(i,nH) rep(j,nW) if( indexMap[i][j] != -1 ) {\n    set<int> used;\n    rep(k,4) {\n      int nx = j + dx[k] * 2, ny = i + dy[k] * 2;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      if( indexMap[ny][nx] == -1 || indexMap[ny][nx] == indexMap[i][j] ) continue;\n      if( used.count(indexMap[ny][nx]) ) continue;\n      used.insert(indexMap[ny][nx]);\n      G[indexMap[i][j]].push_back(indexMap[ny][nx]);\n    }\n  }\n\n  /*\n  rep(i,V) \n    {\n      cout << i << \"-th\" << endl;\n      rep(j,(int)G[i].size()) cout << G[i][j] << \" \"; puts(\"\");\n    }\n*/\n  \n}\n\n\nint mini[MAX][MAX];\n\nvoid dijkstra(int s) {\n  mini[s][s] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){s,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    rep(i,(int)G[data.index].size()) {\n      int next = G[data.index][i];\n      if( mini[s][next] > data.w + 1 ) {\n        mini[s][next] = data.w + 1;\n        Q.push((Data){next,data.w+1});\n      }\n    }\n  }\n}\n\nvoid calc() {\n  rep(i,V) rep(j,V) mini[i][j] = INT_MAX;\n  rep(i,V) dijkstra(i);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n\n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  \n  makeVVV(nW,nH);\n  //cout << \"V = \" << V << endl;\n  calc();\n  \n/*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n*/\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    int s1 = indexMap[y1][x1];\n    int s2 = indexMap[y2][x2];\n    assert( s1 != -1 );\n    assert( s2 != -1 );\n    cout << mini[s1][s2] << endl;\n  }\n  \n}\n\nint main() {\n  /*\n  cout << 1000000000 << \" \" << 1000000000 << \" \" << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+3 << \" 999999999 \" << i*3+3 << endl;\n  }\n  cout << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+4 << \" 999999999 \" << i*3+4 << endl;\n  }\n  return 0;\n  */\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nvector<int>G[160001];\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;py[i]*=2;qx[i]*=2;qy[i]*=2;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\tds[j][k]=2*(WW+HH)+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=2;sy*=2;gx*=2;gy*=2;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair<int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\tds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx;xidx<=maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny;yidx<=maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n\n      if(ny==0||nx==0||ny>=rY[h]||nx>=rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n  \n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[5001][5001]={0};\nvector<long long> node[105005];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i]&&y<h;y++){\n      for(long long x=X1[i];x<=X2[i]&&x<w;x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      masu[ny][nx]=now;\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  if(now>5000) return 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[105005];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n \nint cnt;\nint edge[1000][1000];\n \nbool mas[1000][1000];\nint number[1000][1000];\nbool used[1000][1000];\n \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint H, W;\n \nvoid dfs2(int y, int x){\n  if(used[y][x]++) return;\n    \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    int sanoy = y - dy[i], sanox = x - dx[i];\n \n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(sanoy >= H || sanoy < 0 || sanox >= W || sanox < 0) continue;\n    if(mas[ny][nx] || mas[sanoy][sanox]) continue;\n \n    edge[number[ny][nx]][number[sanoy][sanox]] = 1;\n    edge[number[sanoy][sanox]][number[ny][nx]] = 1;\n  }\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(!mas[ny][nx]) continue;\n    dfs2( ny, nx);\n  }\n \n  return;\n}\nvoid dfs(int y, int x, const int num){\n  if(number[y][x] != -1) return;\n  number[y][x] = num;\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(mas[ny][nx]) continue;\n    if(number[ny][nx] == -1) dfs( ny, nx, num);\n  }\n  return;\n}\n \npair< int, vector< int > > compress( vector< int >& x,const int w){\n  vector< int > xs;\n  for(int i = 0; i < x.size() ; i++ ){\n    for(int d = -1; d <= 1 ; d++ ){\n      int nx = x[i] + d;\n      if(0 <= nx && nx < w) xs.push_back(nx);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i = 0 ; i < x.size() ; i++ ){\n    x[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n  }\n  return make_pair( xs.size(), xs);\n}\n \nint main(){\n  int M;\n \n  cin >> W >> H >> M;\n \n  M += 4;\n  vector< int > x(2 * M), y(2 * M);\n \n  for(int i = 0; i < M - 4; i++){\n    cin >> x[i] >> y[i] >> x[i + M] >> y[i + M];\n \n    x[i] *= 2, y[i] *= 2, x[i + M] *= 2, y[i + M] *= 2;\n  }\n\n  x[M - 4] = W * 2, x[2 * M - 4] = W * 2;\n  y[M - 4] = 0, y[2 * M - 4] = H * 2;\n\n  x[M - 3] = 0, x[2 * M - 3] = W * 2;\n  y[M - 3] = H * 2, y[2 * M - 3] = H * 2;\n\n  x[M - 2] = 0, x[2 * M - 2] = 0;\n  y[M - 2] = 0, y[2 * M - 2] = H * 2;\n\n  x[M - 1] = 0, x[2 * M - 1] = W * 2;\n  y[M - 1] = 0, y[2 * M - 1] = 0;\n \n  pair< int , vector< int > > hoge = compress( x, 2 * W);\n  pair< int , vector< int > > hoge2 = compress( y, 2 * H);\n  W = hoge.first;\n  H = hoge2.first;\n \n  for(int i = 0; i < M; i++){\n    if(y[i] == y[i + M]){\n      for(int j = x[i]; j < x[i + M]; j++){\n        mas[y[i]][j] = true;\n      }\n    } else {\n      for(int j = y[i]; j < y[i + M]; j++){\n        mas[j][x[i]] = true;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i < 15; i++){\n    for(int j = 0; j < 15; j++){\n      cout << mas[i][j];\n    }\n    cout << endl;\n  }\n  */\n\n  memset( number, -1, sizeof(number));\n  cnt = 0;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      if(!mas[i][j] && number[i][j] == -1) dfs( i, j, cnt++);\n    }\n  }\n \n  memset( used, false, sizeof(used));\n  fill_n( *edge, 300 * 300, INF);\n \n  for(int i = 0; i < M; i++){\n    if(!used[y[i]][x[i]]) dfs2( y[i], x[i]);\n  }\n \n  for(int i = 0; i < cnt; i++){\n    edge[i][i] = 0;\n  }\n \n  for(int k = 0; k < cnt; k++){\n    for(int i = 0; i < cnt; i++){\n      if(edge[i][k] == INF) continue;\n      for(int j = 0; j < cnt; j++){\n        if(edge[k][j] == INF) continue;\n        edge[i][j] = min( edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n \n  int q;\n  cin >> q;\n \n  sort( x.begin(), x.end());\n  sort( y.begin(), y.end());\n \n  while(q--){\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n \n    a *= 2, b *= 2, c *= 2, d *= 2;\n\n    //ちょっと大きいところ\n    int sx = upper_bound( hoge.second.begin(), hoge.second.end(), a) - hoge.second.begin();\n    int sy = upper_bound( hoge2.second.begin(), hoge2.second.end(), b) - hoge2.second.begin();\n    int gx = upper_bound( hoge.second.begin(), hoge.second.end(), c) - hoge.second.begin();\n    int gy = upper_bound( hoge2.second.begin(), hoge2.second.end(), d) - hoge2.second.begin();\n    cout << edge[number[sy][sx]][number[gy][gx]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 座標圧縮ライブラリ\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\npublic:\n  Compression(const std::vector<int>& list) : value_(list) {\n    std::sort(begin(value_), end(value_));\n    value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n    for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n  }\n  int size() const {return value_.size();}\n  int index(const int v) const {return index_.at(v);}\n  int operator[](const int i) const {return value_.at(i);}\nprivate:\n  std::unordered_map<int, int> index_;\n  std::vector<int> value_;\n};\n\n////////////////////////////////////////\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = -2, WALL};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint round(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nvoid flood_fill(vector<vector<int>>& field, int y, int x, int color) {\n  const int h = field.size();\n  const int w = field.front().size();\n  field[y][x] = color;\n  for(const auto& d: NEXT) {\n    int ny = y + d[Y];\n    int nx = x + d[X];\n    if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n    if(field[ny][nx] == BLANK) flood_fill(field, ny, nx, color);\n  }\n}\n\n////////////////////////////////////////\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {round(w.px + d, 0, W), round(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {round(w.py + d, 0, H), round(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n\n  // 俯瞰図\n  vector<vector<int>> field(y.size(), vector<int>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n  // 塗り分け\n  int color = 0;\n  for(int i = 0; i < y.size(); ++i) for(int j = 0; j < x.size(); ++j) {\n    if(field[i][j] == BLANK) flood_fill(field, i, j, color++);\n  }\n\n  // ワーシャルフロイド\n  const int INF = 1000000000;\n  const int NEXTNEXT[4][2] = {{-2, 0}, {2, 0}, {0, -2}, {0, 2}};\n  vector<vector<int>> cost(color, vector<int>(color, INF));\n  for(int v = 0; v < color; ++v) cost[v][v] = 0;\n  for(int i = 0; i < y.size(); ++i) for(int j = 0; j < x.size(); ++j) {\n    if(field[i][j] == WALL) continue;\n    for(const auto& d: NEXTNEXT) {\n      int ny = i + d[Y];\n      int nx = j + d[X];\n      if(ny < 0 || y.size() <= ny || nx < 0 || x.size() <= nx) continue;\n      int u = field[i][j];\n      int v = field[ny][nx];\n      if(v == WALL) continue;\n      if(u == v) continue;\n      cost[u][v] = cost[v][u] = 1;\n    }\n  }\n  for(int k = 0; k < color; ++k) for(int u = 0; u < color; ++u) for(int v = 0; v < color; ++v) {\n    cost[u][v] = min(cost[u][v], cost[u][k] + cost[k][v]);\n  }\n\n  for(const auto& q: query) {\n    cout << cost[field[y.index(q.sy)][x.index(q.sx)]][field[y.index(q.gy)][x.index(q.gx)]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint ddy[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n    //if(ax[i]-ax[i-1]>2){\n      ax[i]=ax[i-1]+2;\n    //}\n    qx[mk(ay[i-1],pp)]=ax[i]-1;\n    mx[pp]=ax[i];//cout<<ax.size()<<endl;\n  }\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n    //if(ay[i]-ay[i-1]>2){\n      ay[i]=ay[i-1]+2;\n    //}\n    qy[mk(ay[i-1],pp)]=ay[i]-1;\n    my[pp]=ay[i];\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){//cout<<x<<endl;\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<16;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    /*for(int ii=0;ii<=h;ii++){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%2d\",a[ii][jj]);cout<<endl;\n    }\n    for(int ii=h;ii>=0;ii--){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%2d\",a[ii][jj]);cout<<endl;\n    }*/\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    /*for(int ii=h;ii>=0;ii--){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%3d\",a[ii][jj]);cout<<endl;\n    }*/\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      //sx*=2;sy*=2;gx*=2;gy*=2;\n      int so=a[sy][sx],go=a[gy][gx];//cout<<so<<go<<endl;\n      int use[100]={};\n      use[so]=1;\n      //if(so==go)cout<<1111<<endl;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          //cout<<u.s+1<<endl;\n          if(m==2)cout<<3<<endl;\n          else cout<<1<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[4000][4000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    if(dist[t]==INF)for(;;);\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%lld%lld%lld%lld\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%lld%lld%lld%lld\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\n\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::unordered_map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = false, WALL = true};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nint Dijkstra(const vector<vector<bool>>& field, int sx, int sy, int gx, int gy) {\n  const int h = field.size();\n  const int w = field.front().size();\n\n  typedef tuple<int, int, int> Node;\n\n  vector<vector<bool>> visited(h, vector<bool>(w, false));\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, sy, sx);\n  while(!q.empty()) {\n    int cost, y, x;\n    tie(cost, y, x) = q.top();\n    q.pop();\n    if(y == gy && x == gx) return cost;\n    if(visited[y][x]) continue;\n    visited[y][x] = true;\n//     cout << cost << \", \" << y << \", \" << x << endl;\n    for(int dy: {-1, 0, 1}) for(int dx: {-1, 0, 1}) {\n      if(abs(dx) + abs(dy) != 1) continue;\n      int ncost = cost;\n      int ny = y + dy;\n      int nx = x + dx;\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(field[ny][nx] == WALL) {\n        ny += dy;\n        nx += dx;\n        ++ncost;\n      }\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(!visited[ny][nx]) q.emplace(ncost, ny, nx);\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n  vector<vector<bool>> field(y.size(), vector<bool>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n//   for(auto i: field) {\n//     for(auto j: i)cout<<\" \"<<j;\n//     cout<<endl;\n//   }\n\n  for(const auto& q: query) {\n    cout << Dijkstra(field, x.index(q.sx), y.index(q.sy), x.index(q.gx), y.index(q.gy)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\tif(W>=1000000000)continue;\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[1001][1001],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx]&&used[ry][rx]==0)graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    if(dist[t]==INF)for(;;);\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%lld%lld%lld%lld\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%lld%lld%lld%lld\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid[0].size() - 1) return false;\n\treturn true;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * grid[0].size() + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(grid.size() * grid[0].size());\n\tgraph = vector<vector<int> >(grid.size() * grid[0].size(), vector<int>());\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 710\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    rep(i,4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n\n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  /*\n  cout << 1000000000 << \" \" << 1000000000 << \" \" << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+3 << \" 999999999 \" << i*3+3 << endl;\n  }\n  cout << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+4 << \" 999999999 \" << i*3+4 << endl;\n  }\n  return 0;\n  */\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::unordered_map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = -2, WALL};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nvoid flood_fill(vector<vector<int>>& field, int y, int x, int color) {\n  const int h = field.size();\n  const int w = field.front().size();\n  field[y][x] = color;\n  for(const auto& d: NEXT) {\n    int ny = y + d[Y];\n    int nx = x + d[X];\n    if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n    if(field[ny][nx] == BLANK) flood_fill(field, ny, nx, color);\n  }\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n\n  vector<vector<int>> field(y.size(), vector<int>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n  // 塗りつぶし\n  int color = 0;\n  for(int i = 0; i < y.size(); ++i) for(int j = 0; j < x.size(); ++j) {\n    if(field[i][j] == BLANK) flood_fill(field, i, j, color++);\n  }\n\n  // ワーシャルフロイド\n  const int INF = 1000000000;\n  const int NEXTNEXT[4][2] = {{-2, 0}, {2, 0}, {0, -2}, {0, 2}};\n  vector<vector<int>> cost(color, vector<int>(color, INF));\n  for(int i = 0; i < y.size(); ++i) for(int j = 0; j < x.size(); ++j) {\n    if(field[i][j] == WALL) continue;\n    for(const auto& d: NEXTNEXT) {\n      int ny = i + d[Y];\n      int nx = j + d[X];\n      if(ny < 0 || y.size() <= ny || nx < 0 || x.size() <= nx) continue;\n      int u = field[i][j];\n      int v = field[ny][nx];\n      if(v == WALL) continue;\n      if(u == v) continue;\n      cost[u][v] = cost[v][u] = 1;\n    }\n  }\n  for(int k = 0; k < color; ++k) for(int u = 0; u < color; ++u) for(int v = 0; v < color; ++v)\n    cost[u][v] = min(cost[u][v], cost[u][k] + cost[k][v]);\n\n  for(const auto& q: query) {\n    cout << cost[field[y.index(q.sy)][x.index(q.sx)]][field[y.index(q.gy)][x.index(q.gx)]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tassert(W * H > 0);\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1 << 28)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct State {\n\tint x, y, cnt;\n\tState (int x, int y, int cnt) : x(x), y(y), cnt(cnt){}\n\tbool operator < (const State &t) const {\n\t\treturn cnt < t.cnt;\n\t}\n};\n\nint w, h, m, q;\nvector<int> ZX, ZY;\nint PX[200], PY[200], QX[200], QY[200];\nint SX[100], SY[100], GX[100], GY[100];\nbool grid[2048][2048];\nint d[2048][2048];\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < ZX.size() && y < ZY.size();\n}\n\nvoid solve(int sx, int sy, int gx, int gy)\n{\n\tfill((int*)d, (int*)d + 1024 * 1024, INF);\n\tdeque<State> dq;\n\tfor (dq.push_front(State(sx, sy, 0)); dq.size(); ){\n\t\tState st = dq.front(); dq.pop_front();\n\t\tif (d[st.x][st.y] < st.cnt) continue;\n\t\tif (st.x == gx && st.y == gy){\n\t\t\tprintf(\"%d\\n\", st.cnt);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t/*\n\t\tfor (auto &t : dq) printf(\"%d \", t.cnt);\n\t\tputs(\"\");\n\t\t*/\n\t\t\n\t\t//printf(\"%d %d %d\\n\", st.x, st.y, st.cnt);\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = st.x + dx[dir];\n\t\t\tint ny = st.y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[st.x][st.y] && grid[nx][ny]) continue;\n\t\t\tint nc = st.cnt + grid[nx][ny];\n\t\t\tif (d[nx][ny] > nc){\n\t\t\t\tdq.insert(lower_bound(dq.begin(), dq.end(), State(nx, ny, nc)), State(nx, ny, nc));\n\t\t\t\td[nx][ny] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &m);\n\tZX.push_back(0);\n\tZY.push_back(0);\n\tZX.push_back(w * 2);\n\tZY.push_back(h * 2);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tPX[i] *= 2;\n\t\tPY[i] *= 2;\n\t\tQX[i] *= 2;\n\t\tQY[i] *= 2;\n\t\tZX.push_back(PX[i]);\n\t\tZY.push_back(PY[i]);\n\t\tZX.push_back(QX[i]);\n\t\tZY.push_back(QY[i]);\n\t\tZX.push_back(PX[i] + 1);\n\t\tZY.push_back(PY[i] + 1);\n\t\tZX.push_back(QX[i] + 1);\n\t\tZY.push_back(QY[i] + 1);\n\t}\n\tPX[m] = 0; PY[m] = 0;\n\tQX[m] = w * 2; QY[m] = 0;\n\tPX[m + 1] = 0; PY[m + 1] = 0;\n\tQX[m + 1] = 0; QY[m + 1] = h * 2;\n\tPX[m + 2] = w * 2; PY[m + 2] = 0;\n\tQX[m + 2] = w * 2; QY[m + 2] = h * 2;\n\tPX[m + 3] = 0; PY[m + 3] = h * 2;\n\tQX[m + 3] = w * 2; QY[m + 3] = h * 2;\n\tm += 4;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tSX[i] *= 2;\n\t\tSY[i] *= 2;\n\t\tGX[i] *= 2;\n\t\tGY[i] *= 2;\n\t\tZX.push_back(SX[i]);\n\t\tZY.push_back(SY[i]);\n\t\tZX.push_back(GX[i]);\n\t\tZY.push_back(GY[i]);\n\t\tZX.push_back(SX[i] + 1);\n\t\tZY.push_back(SY[i] + 1);\n\t\tZX.push_back(GX[i] + 1);\n\t\tZY.push_back(GY[i] + 1);\n\t}\n\tsort(ZX.begin(), ZX.end());\n\tZX.erase(lower_bound(ZX.begin(), ZX.end(), w * 2 + 1), upper_bound(ZX.begin(), ZX.end(), w * 2 + 1));\n\tZX.erase(unique(ZX.begin(), ZX.end()), ZX.end());\n\tsort(ZY.begin(), ZY.end());\n\tZY.erase(lower_bound(ZY.begin(), ZY.end(), h * 2 + 1), upper_bound(ZY.begin(), ZY.end(), h * 2 + 1));\n\tZY.erase(unique(ZY.begin(), ZY.end()), ZY.end());\n\tfor (int i = 0; i < m; i++){\n\t\tPX[i] = lower_bound(ZX.begin(), ZX.end(), PX[i]) - ZX.begin();\n\t\tPY[i] = lower_bound(ZY.begin(), ZY.end(), PY[i]) - ZY.begin();\n\t\tQX[i] = lower_bound(ZX.begin(), ZX.end(), QX[i]) - ZX.begin();\n\t\tQY[i] = lower_bound(ZY.begin(), ZY.end(), QY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tSX[i] = lower_bound(ZX.begin(), ZX.end(), SX[i]) - ZX.begin();\n\t\tSY[i] = lower_bound(ZY.begin(), ZY.end(), SY[i]) - ZY.begin();\n\t\tGX[i] = lower_bound(ZX.begin(), ZX.end(), GX[i]) - ZX.begin();\n\t\tGY[i] = lower_bound(ZY.begin(), ZY.end(), GY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int x = PX[i]; x <= QX[i]; x++){\n\t\t\tfor (int y = PY[i]; y <= QY[i]; y++){\n\t\t\t\tgrid[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\tfor (int i = 0; i < ZY.size(); i++){\n\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\tprintf(\"%c\", grid[j][i] ? '+' : ' ');\n\t\t}\n\t\tputs(\"\");\n\t}\n\t*/\n\t\n\tfor (int i = 0; i < q; i++){\n\t\t//printf(\"%d:\\n\", i);\n\t\tsolve(SX[i], SY[i], GX[i], GY[i]);\n\t\t/*for (int i = 0; i < ZY.size(); i++){\n\t\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\t\tprintf(\"%d\", d[j][i] - INF ? d[i][j] : 9);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid[0].size() - 1) return false;\n\t/*if (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;*/\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nqueue<P> que;\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tif(y<500&&x<500&&y>=0&&x>=0){\n\t  masu[y][x]=-1;\n\t}\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      //sx++;\n      sy*=2;\n      //sy++;\n      gx*=2;\n      //gx++;\n      gy*=2;\n      //gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    if(dist[t]==INF)for(;;);\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n    if(W>3000||H>3000)for(;;);\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\tif(W>=1000000000&&i==0)return 0;\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 405\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx;xidx<maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny;yidx<maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n\n      if(ny==0||nx==0||ny>=rY[h]||nx>=rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n  \n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nqueue<P> que;\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tif(y<500&&x<500&&y>=0&&x>=0){\n\t  masu[y][x]=-1;\n\t}\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<=200000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nint px[114];ll py[114];ll qx[114];ll qy[114];\nvector<int> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nbool f[401][401];\nint sx1,sy1,gx1,gy1;\nint WW,HH;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%d%d%d\",&W,&H,&M);W*=2;H*=2;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;py[i]*=2;qx[i]*=2;qy[i]*=2;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\tds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tint sx,sy,gx,gy;\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\tsx*=2;sy*=2;gx*=2;gy*=2;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\t\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair<int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<ds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\tds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[501][501],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[505];\nbool used[505][505];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(500,500,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[200]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n\t  while(!q.empty())q.pop();\n          break;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }//L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 1010\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    rep(i,4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n\n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  /*\n  cout << 1000000000 << \" \" << 1000000000 << \" \" << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+3 << \" 999999999 \" << i*3+3 << endl;\n  }\n  cout << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+4 << \" 999999999 \" << i*3+4 << endl;\n  }\n  return 0;\n  */\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=1001001001;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1 << 28)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct State {\n\tint x, y, cnt;\n\tState (int x, int y, int cnt) : x(x), y(y), cnt(cnt){}\n\tbool operator < (const State &t) const {\n\t\treturn cnt > t.cnt;\n\t}\n};\n\nint w, h, m, q;\nvector<int> ZX, ZY;\nint PX[100], PY[100], QX[100], QY[100];\nint SX[100], SY[100], GX[100], GY[100];\nbool grid[2048][2048];\nint d[2048][2048];\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < ZX.size() && y < ZY.size();\n}\n\nvoid solve(int sx, int sy, int gx, int gy)\n{\n\tfill((int*)d, (int*)d + 1024 * 1024, INF);\n\tpriority_queue<State> pq;\n\tfor (pq.push(State(sx, sy, 0)); pq.size(); ){\n\t\tState st = pq.top(); pq.pop();\n\t\tif (d[st.x][st.y] < st.cnt) continue;\n\t\tif (st.x == gx && st.y == gy){\n\t\t\tprintf(\"%d\\n\", st.cnt);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//printf(\"%d %d %d\\n\", st.x, st.y, st.cnt);\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = st.x + dx[dir];\n\t\t\tint ny = st.y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[st.x][st.y] && grid[nx][ny]) continue;\n\t\t\tint nc = st.cnt + grid[nx][ny];\n\t\t\tif (d[nx][ny] > nc){\n\t\t\t\tpq.push(State(nx, ny, nc));\n\t\t\t\td[nx][ny] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &m);\n\tZX.push_back(0);\n\tZY.push_back(0);\n\tZX.push_back(w * 2);\n\tZY.push_back(h * 2);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tPX[i] *= 2;\n\t\tPY[i] *= 2;\n\t\tQX[i] *= 2;\n\t\tQY[i] *= 2;\n\t\tZX.push_back(PX[i]);\n\t\tZY.push_back(PY[i]);\n\t\tZX.push_back(QX[i]);\n\t\tZY.push_back(QY[i]);\n\t\tZX.push_back(PX[i] + 1);\n\t\tZY.push_back(PY[i] + 1);\n\t\tZX.push_back(QX[i] + 1);\n\t\tZY.push_back(QY[i] + 1);\n\t}\n\tPX[m] = 0; PY[m] = 0;\n\tQX[m] = w * 2; QY[m] = 0;\n\tPX[m + 1] = 0; PY[m + 1] = 0;\n\tQX[m + 1] = 0; QY[m + 1] = h * 2;\n\tPX[m + 2] = w * 2; PY[m + 2] = 0;\n\tQX[m + 2] = w * 2; QY[m + 2] = h * 2;\n\tPX[m + 3] = 0; PY[m + 3] = h * 2;\n\tQX[m + 3] = w * 2; QY[m + 3] = h * 2;\n\tm += 4;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tSX[i] *= 2;\n\t\tSY[i] *= 2;\n\t\tGX[i] *= 2;\n\t\tGY[i] *= 2;\n\t\tZX.push_back(SX[i]);\n\t\tZY.push_back(SY[i]);\n\t\tZX.push_back(GX[i]);\n\t\tZY.push_back(GY[i]);\n\t}\n\tsort(ZX.begin(), ZX.end());\n\tZX.erase(lower_bound(ZX.begin(), ZX.end(), w * 2 + 1), upper_bound(ZX.begin(), ZX.end(), w * 2 + 1));\n\tZX.erase(unique(ZX.begin(), ZX.end()), ZX.end());\n\tsort(ZY.begin(), ZY.end());\n\tZY.erase(lower_bound(ZY.begin(), ZY.end(), h * 2 + 1), upper_bound(ZY.begin(), ZY.end(), h * 2 + 1));\n\tZY.erase(unique(ZY.begin(), ZY.end()), ZY.end());\n\tfor (int i = 0; i < m; i++){\n\t\tPX[i] = lower_bound(ZX.begin(), ZX.end(), PX[i]) - ZX.begin();\n\t\tPY[i] = lower_bound(ZY.begin(), ZY.end(), PY[i]) - ZY.begin();\n\t\tQX[i] = lower_bound(ZX.begin(), ZX.end(), QX[i]) - ZX.begin();\n\t\tQY[i] = lower_bound(ZY.begin(), ZY.end(), QY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tSX[i] = lower_bound(ZX.begin(), ZX.end(), SX[i]) - ZX.begin();\n\t\tSY[i] = lower_bound(ZY.begin(), ZY.end(), SY[i]) - ZY.begin();\n\t\tGX[i] = lower_bound(ZX.begin(), ZX.end(), GX[i]) - ZX.begin();\n\t\tGY[i] = lower_bound(ZY.begin(), ZY.end(), GY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int x = PX[i]; x <= QX[i]; x++){\n\t\t\tfor (int y = PY[i]; y <= QY[i]; y++){\n\t\t\t\tgrid[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < ZY.size(); i++){\n\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\tprintf(\"%c\", grid[j][i] ? '+' : ' ');\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < q; i++){\n\t\t//printf(\"%d:\\n\", i);\n\t\tsolve(SX[i], SY[i], GX[i], GY[i]);\n\t\t/*for (int i = 0; i < ZY.size(); i++){\n\t\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\t\tprintf(\"%d\", d[j][i] - INF ? d[i][j] : 9);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n \nint cnt;\nint edge[1000][1000];\n \nbool mas[1000][1000];\nint number[1000][1000];\nbool used[1000][1000];\n \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint H, W;\n \nvoid dfs2(int y, int x){\n  if(used[y][x]++) return;\n    \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    int sanoy = y - dy[i], sanox = x - dx[i];\n \n    if(ny >= H || ny < 0 || nx > W || nx < 0) continue;\n    if(sanoy > H || sanoy < 0 || sanox > W || sanox < 0) continue;\n    if(mas[ny][nx] || mas[sanoy][sanox]) continue;\n \n    edge[number[ny][nx]][number[sanoy][sanox]] = 1;\n    edge[number[sanoy][sanox]][number[ny][nx]] = 1;\n  }\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(!mas[ny][nx]) continue;\n    dfs2( ny, nx);\n  }\n \n  return;\n}\nvoid dfs(int y, int x, const int num){\n  if(number[y][x] != -1) return;\n  number[y][x] = num;\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny > H || ny < 0 || nx > W || nx < 0) continue;\n    if(mas[ny][nx]) continue;\n    if(number[ny][nx] == -1) dfs( ny, nx, num);\n  }\n  return;\n}\n \npair< int, vector< int > > compress( vector< int >& x,const int w){\n  vector< int > xs;\n  for(int i = 0; i < x.size() ; i++ ){\n    for(int d = -1; d <= 1 ; d++ ){\n      int nx = x[i] + d;\n      if(0 <= nx && nx < w) xs.push_back(nx);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i = 0 ; i < x.size() ; i++ ){\n    x[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n  }\n  return make_pair( xs.size(), xs);\n}\n \nint main(){\n  int M;\n \n  cin >> W >> H >> M;\n \n  M += 4;\n  vector< int > x(2 * M), y(2 * M);\n \n  for(int i = 0; i < M - 4; i++){\n    cin >> x[i] >> y[i] >> x[i + M] >> y[i + M];\n \n    x[i] *= 2, y[i] *= 2, x[i + M] *= 2, y[i + M] *= 2;\n  }\n\n  x[M - 4] = W * 2, x[2 * M - 4] = W * 2;\n  y[M - 4] = 0, y[2 * M - 4] = H * 2;\n\n  x[M - 3] = 0, x[2 * M - 3] = W * 2;\n  y[M - 3] = H * 2, y[2 * M - 3] = H * 2;\n\n  x[M - 2] = 0, x[2 * M - 2] = 0;\n  y[M - 2] = 0, y[2 * M - 2] = H * 2;\n\n  x[M - 1] = 0, x[2 * M - 1] = W * 2;\n  y[M - 1] = 0, y[2 * M - 1] = 0;\n \n  pair< int , vector< int > > hoge = compress( x, 2 * W);\n  pair< int , vector< int > > hoge2 = compress( y, 2 * H);\n  W = hoge.first;\n  H = hoge2.first;\n \n  for(int i = 0; i < M; i++){\n    if(y[i] == y[i + M]){\n      for(int j = x[i]; j < x[i + M]; j++){\n        mas[y[i]][j] = true;\n      }\n    } else {\n      for(int j = y[i]; j < y[i + M]; j++){\n        mas[j][x[i]] = true;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i < 15; i++){\n    for(int j = 0; j < 15; j++){\n      cout << mas[i][j];\n    }\n    cout << endl;\n  }\n  */\n\n  memset( number, -1, sizeof(number));\n  cnt = 0;\n  for(int i = 0; i <= H; i++){\n    for(int j = 0; j <= W; j++){\n      if(!mas[i][j] && number[i][j] == -1) dfs( i, j, cnt++);\n    }\n  }\n \n  memset( used, false, sizeof(used));\n  fill_n( *edge, 1000 * 1000, INF);\n \n  for(int i = 0; i < M; i++){\n    if(!used[y[i]][x[i]]) dfs2( y[i], x[i]);\n  }\n \n  for(int i = 0; i < cnt; i++){\n    edge[i][i] = 0;\n  }\n \n  for(int k = 0; k < cnt; k++){\n    for(int i = 0; i < cnt; i++){\n      if(edge[i][k] == INF) continue;\n      for(int j = 0; j < cnt; j++){\n        if(edge[k][j] == INF) continue;\n        edge[i][j] = min( edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n \n  int q;\n  cin >> q;\n \n  sort( x.begin(), x.end());\n  sort( y.begin(), y.end());\n \n  while(q--){\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n \n    a *= 2, b *= 2, c *= 2, d *= 2;\n\n    //ちょっと大きいところ\n    int sx = upper_bound( hoge.second.begin(), hoge.second.end(), a) - hoge.second.begin();\n    int sy = upper_bound( hoge2.second.begin(), hoge2.second.end(), b) - hoge2.second.begin();\n    int gx = upper_bound( hoge.second.begin(), hoge.second.end(), c) - hoge.second.begin();\n    int gy = upper_bound( hoge2.second.begin(), hoge2.second.end(), d) - hoge2.second.begin();\n    cout << edge[number[sy][sx]][number[gy][gx]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i]&&y<h;y++){\n      for(long long x=X1[i];x<=X2[i]&&x<w;x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<50000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\ntypedef vector<int> vec;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nconst int MAX_M=100,MAX_Q=100,MAX_V=MAX_M*6;\nint W,H,M,Q;\nint px[MAX_M],py[MAX_M],qx[MAX_M],qy[MAX_M];\nint sx[MAX_Q],sy[MAX_Q],gx[MAX_Q],gy[MAX_Q];\n\nbool grid[(MAX_M+MAX_Q)*6][(MAX_M+MAX_Q)*6];\nint grid2[(MAX_M+MAX_Q)*6][(MAX_M+MAX_Q)*6];\n\nint V;\nint G[MAX_V][MAX_V];\nint dist[MAX_V];\n\nvoid compress(int *x1,int *x2,int *x3,int *x4,int &w){\n    vec v;\n    REP(i,M){\n        REP(j,3){\n            int x=*(x1+i)+j-1;\n            if (x>=0 && x<=w){\n                v.push_back(x);\n            }\n            x=*(x2+i)+j-1;\n            if (x>=0 && x<=w){\n                v.push_back(x);\n            }\n        }\n    }\n    REP(i,Q){\n        v.push_back(*(x3+i));\n        v.push_back(*(x4+i));\n    }\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n    REP(i,M){\n        *(x1+i)=find(v.begin(),v.end(),*(x1+i))-v.begin();\n        *(x2+i)=find(v.begin(),v.end(),*(x2+i))-v.begin();\n    }\n    REP(i,Q){\n        *(x3+i)=find(v.begin(),v.end(),*(x3+i))-v.begin();\n        *(x4+i)=find(v.begin(),v.end(),*(x4+i))-v.begin();\n    }\n    w=v.size();\n}\n\nvoid bfs(int s){\n    queue<int> q;\n    memset(dist,-1,sizeof(dist));\n    dist[s]=0;\n    q.push(s);\n    while(!q.empty()){\n        int v=q.front();\n        q.pop();\n        REP(i,V){\n            if (G[v][i] && dist[i]==-1){\n                dist[i]=dist[v]+1;\n                q.push(i);\n            }\n        }\n    }\n}\n\nvoid bfs2(int x,int y){\n    queue<P> q;\n    q.push(P(x,y));\n    grid2[x][y]=V;\n    while(!q.empty()){\n        P p=q.front();\n        q.pop();\n        REP(i,4){\n            int x2=p.first+dx[i],y2=p.second+dy[i];\n            if (x2<0 || x2>=W || y2<0 || y2>=H) continue;\n            if (!grid[x2][y2] && grid2[x2][y2]==-1){\n                grid2[x2][y2]=V;\n                q.push(P(x2,y2));\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d %d %d\",&W,&H,&M);\n    W*=2;\n    H*=2;\n    REP(i,M){\n        scanf(\"%d %d %d %d\",&px[i],&py[i],&qx[i],&qy[i]);\n        if (px[i]>qx[i]){\n            swap(px[i],qx[i]);\n        }\n        if (py[i]>qy[i]){\n            swap(py[i],qy[i]);\n        }\n        px[i]*=2;\n        py[i]*=2;\n        qx[i]*=2;\n        qy[i]*=2;\n    }\n    scanf(\"%d\",&Q);\n    REP(i,Q){\n        scanf(\"%d %d %d %d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n        sx[i]*=2;\n        sy[i]*=2;\n        gx[i]*=2;\n        gy[i]*=2;\n    }\n    compress(px,qx,sx,gx,W);\n    compress(py,qy,sy,gy,H);\n    REP(i,M){\n        FOR(j,px[i],qx[i]+1){\n            FOR(k,py[i],qy[i]+1){\n                grid[j][k]=true;\n            }\n        }\n    }\n    memset(grid2,-1,sizeof(grid2));\n    REP(x,W){\n        REP(y,H){\n            if (!grid[x][y] && grid2[x][y]==-1){\n                bfs2(x,y);\n                V++;\n            }\n        }\n    }\n    REP(x,W){\n        REP(y,H){\n            if (grid[x][y]){\n                int x2,y2,x3,y3;\n                int v,u;\n                x2=x-1;\n                x3=x+1;\n                if (x2>=0 && x3<W && !grid[x2][y] && !grid[x3][y]){\n                    v=grid2[x2][y];\n                    u=grid2[x3][y];\n                    G[v][u]=G[u][v]=1;\n                }\n                y2=y-1;\n                y3=y+1;\n                if (y2>=0 && y3<H && !grid[x][y2] && !grid[x][y3]){\n                    v=grid2[x][y2];\n                    u=grid2[x][y3];\n                    G[v][u]=G[u][v]=1;\n                }\n            }\n        }\n    }\n    REP(i,Q){\n        bfs(grid2[sx[i]][sy[i]]);\n        printf(\"%d\\n\",dist[grid2[gx[i]][gy[i]]]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]<X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]<Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      //sx++;\n      sy*=2;\n      //sy++;\n      gx*=2;\n      //gx++;\n      gy*=2;\n      //gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=lower_bound(xv.begin(),xv.end(),sx)-xv.begin();\n      syp=lower_bound(yv.begin(),yv.end(),sy)-yv.begin();\n      gxp=lower_bound(xv.begin(),xv.end(),gx)-xv.begin();\n      gyp=lower_bound(yv.begin(),yv.end(),gy)-yv.begin();\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<50000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1 << 28)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct State {\n\tint x, y, cnt;\n\tState (int x, int y, int cnt) : x(x), y(y), cnt(cnt){}\n\tbool operator < (const State &t) const {\n\t\treturn cnt < t.cnt;\n\t}\n};\n\nint w, h, m, q;\nvector<int> ZX, ZY;\nint PX[200], PY[200], QX[200], QY[200];\nint SX[100], SY[100], GX[100], GY[100];\nbool grid[2048][2048];\nint d[2048][2048];\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < ZX.size() && y < ZY.size();\n}\n\nvoid solve(int sx, int sy, int gx, int gy)\n{\n\tfill((int*)d, (int*)d + 1024 * 1024, INF);\n\tlist<State> li;\n\tfor (li.push_front(State(sx, sy, 0)); li.size(); ){\n\t\tState st = li.front(); li.pop_front();\n\t\tif (d[st.x][st.y] < st.cnt) continue;\n\t\tif (st.x == gx && st.y == gy){\n\t\t\tprintf(\"%d\\n\", st.cnt);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\t//for (auto &t : li) printf(\"%d \", t.cnt);\n\t\t//puts(\"\");\n\t\t\n\t\t\n\t\t//printf(\"%d %d %d\\n\", st.x, st.y, st.cnt);\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = st.x + dx[dir];\n\t\t\tint ny = st.y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[st.x][st.y] && grid[nx][ny]) continue;\n\t\t\tint nc = st.cnt + grid[nx][ny];\n\t\t\tif (d[nx][ny] > nc){\n\t\t\t\tli.insert(lower_bound(li.begin(), li.end(), State(nx, ny, nc)), State(nx, ny, nc));\n\t\t\t\td[nx][ny] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &m);\n\tZX.push_back(0);\n\tZY.push_back(0);\n\tZX.push_back(w * 2);\n\tZY.push_back(h * 2);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tPX[i] *= 2;\n\t\tPY[i] *= 2;\n\t\tQX[i] *= 2;\n\t\tQY[i] *= 2;\n\t\tZX.push_back(PX[i]);\n\t\tZY.push_back(PY[i]);\n\t\tZX.push_back(QX[i]);\n\t\tZY.push_back(QY[i]);\n\t\tZX.push_back(PX[i] + 1);\n\t\tZY.push_back(PY[i] + 1);\n\t\tZX.push_back(QX[i] + 1);\n\t\tZY.push_back(QY[i] + 1);\n\t}\n\tPX[m] = 0; PY[m] = 0;\n\tQX[m] = w * 2; QY[m] = 0;\n\tPX[m + 1] = 0; PY[m + 1] = 0;\n\tQX[m + 1] = 0; QY[m + 1] = h * 2;\n\tPX[m + 2] = w * 2; PY[m + 2] = 0;\n\tQX[m + 2] = w * 2; QY[m + 2] = h * 2;\n\tPX[m + 3] = 0; PY[m + 3] = h * 2;\n\tQX[m + 3] = w * 2; QY[m + 3] = h * 2;\n\tm += 4;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tSX[i] *= 2;\n\t\tSY[i] *= 2;\n\t\tGX[i] *= 2;\n\t\tGY[i] *= 2;\n\t\tZX.push_back(SX[i]);\n\t\tZY.push_back(SY[i]);\n\t\tZX.push_back(GX[i]);\n\t\tZY.push_back(GY[i]);\n\t\tZX.push_back(SX[i] + 1);\n\t\tZY.push_back(SY[i] + 1);\n\t\tZX.push_back(GX[i] + 1);\n\t\tZY.push_back(GY[i] + 1);\n\t}\n\tsort(ZX.begin(), ZX.end());\n\tZX.erase(lower_bound(ZX.begin(), ZX.end(), w * 2 + 1), upper_bound(ZX.begin(), ZX.end(), w * 2 + 1));\n\tZX.erase(unique(ZX.begin(), ZX.end()), ZX.end());\n\tsort(ZY.begin(), ZY.end());\n\tZY.erase(lower_bound(ZY.begin(), ZY.end(), h * 2 + 1), upper_bound(ZY.begin(), ZY.end(), h * 2 + 1));\n\tZY.erase(unique(ZY.begin(), ZY.end()), ZY.end());\n\tfor (int i = 0; i < m; i++){\n\t\tPX[i] = lower_bound(ZX.begin(), ZX.end(), PX[i]) - ZX.begin();\n\t\tPY[i] = lower_bound(ZY.begin(), ZY.end(), PY[i]) - ZY.begin();\n\t\tQX[i] = lower_bound(ZX.begin(), ZX.end(), QX[i]) - ZX.begin();\n\t\tQY[i] = lower_bound(ZY.begin(), ZY.end(), QY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tSX[i] = lower_bound(ZX.begin(), ZX.end(), SX[i]) - ZX.begin();\n\t\tSY[i] = lower_bound(ZY.begin(), ZY.end(), SY[i]) - ZY.begin();\n\t\tGX[i] = lower_bound(ZX.begin(), ZX.end(), GX[i]) - ZX.begin();\n\t\tGY[i] = lower_bound(ZY.begin(), ZY.end(), GY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int x = PX[i]; x <= QX[i]; x++){\n\t\t\tfor (int y = PY[i]; y <= QY[i]; y++){\n\t\t\t\tgrid[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*\n\tfor (int i = 0; i < ZY.size(); i++){\n\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\tprintf(\"%c\", grid[j][i] ? '+' : ' ');\n\t\t}\n\t\tputs(\"\");\n\t}\n\t*/\n\t\n\tfor (int i = 0; i < q; i++){\n\t\t//printf(\"%d:\\n\", i);\n\t\tsolve(SX[i], SY[i], GX[i], GY[i]);\n\t\t/*for (int i = 0; i < ZY.size(); i++){\n\t\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\t\tprintf(\"%d\", d[j][i] - INF ? d[i][j] : 9);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint H, W, N, Q, px[109], py[109], qx[109], qy[109], sx[109], sy[109], gx[109], gy[109], dist[10009];\nvector<int>X, Y; bool wall[1009][1009]; int col[1009][1009], cntw; vector<int>G[10009]; map<pair<int, int>, int>M;\n\nvoid dfs(int cx, int cy) {\n\tcol[cx][cy] = cntw;\n\tint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\n\tfor (int i = 0; i < 4; i++) {\n\t\tint fx = cx + dx[i], fy = cy + dy[i];\n\t\tif (fx < 0 || fy < 0 || fx >= X.size() || fy >= Y.size() || wall[fx][fy] == true || col[fx][fy] >= 1) continue;\n\t\tdfs(fx, fy);\n\t}\n}\nint solve(int cx, int cy) {\n\tfor (int i = 0; i < 10009; i++)dist[i] = 9999999;\n\tqueue<int>q; q.push(cx); dist[cx] = 0;\n\twhile (!q.empty()) {\n\t\tint to1 = q.front(); q.pop();\n\t\tfor (int i : G[to1]) {\n\t\t\tif (dist[i] > dist[to1] + 1) {\n\t\t\t\tdist[i] = dist[to1] + 1; q.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[cy];\n}\n\nint main() {\n\tcin >> H >> W >> N;\n\tfor (int i = 1; i <= N; i++) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n\tcin >> Q;\n\tfor (int i = 1; i <= Q; i++) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n\tfor (int i = 1; i <= N; i++) {\n\t\tpx[i] *= 2; py[i] *= 2; qx[i] *= 2; qy[i] *= 2;\n\t\tif (px[i] > qx[i]) swap(px[i], qx[i]); if (py[i] > qy[i]) swap(py[i], qy[i]);\n\t\tif (px[i] >= 1) X.push_back(px[i] - 1); X.push_back(px[i]); if (px[i] < H * 2) X.push_back(px[i] + 1);\n\t\tif (qx[i] >= 1) X.push_back(qx[i] - 1); X.push_back(qx[i]); if (qx[i] < H * 2) X.push_back(qx[i] + 1);\n\t\tif (py[i] >= 1) Y.push_back(py[i] - 1); Y.push_back(py[i]); if (py[i] < W * 2) Y.push_back(py[i] + 1);\n\t\tif (py[i] >= 1) Y.push_back(qy[i] - 1); Y.push_back(qy[i]); if (qy[i] < W * 2) Y.push_back(qy[i] + 1);\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tsx[i] *= 2; sy[i] *= 2; gx[i] *= 2; gy[i] *= 2;\n\t\tX.push_back(sx[i]); Y.push_back(sy[i]);\n\t\tX.push_back(gx[i]); Y.push_back(gy[i]);\n\t}\n\tX.push_back(0); Y.push_back(0); X.push_back(H * 2); Y.push_back(W * 2);\n\tsort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n\tsort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\tfor (int i = 1; i <= N; i++) {\n\t\tpx[i] = lower_bound(X.begin(), X.end(), px[i]) - X.begin();\n\t\tqx[i] = lower_bound(X.begin(), X.end(), qx[i]) - X.begin();\n\t\tpy[i] = lower_bound(Y.begin(), Y.end(), py[i]) - Y.begin();\n\t\tqy[i] = lower_bound(Y.begin(), Y.end(), qy[i]) - Y.begin();\n\t\tif (px[i] == qx[i]) {\n\t\t\tfor (int j = py[i]; j <= qy[i]; j++) wall[px[i]][j] = true;\n\t\t}\n\t\tif (py[i] == qy[i]) {\n\t\t\tfor (int j = px[i]; j <= qx[i]; j++) wall[j][py[i]] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < Y.size(); i++) wall[0][i] = true;\n\tfor (int i = 0; i < Y.size(); i++) wall[X.size() - 1][i] = true;\n\tfor (int i = 0; i < X.size(); i++) wall[i][0] = true;\n\tfor (int i = 0; i < X.size(); i++) wall[i][Y.size() - 1] = true;\n\tfor (int i = 1; i <= Q; i++) {\n\t\tsx[i] = lower_bound(X.begin(), X.end(), sx[i]) - X.begin();\n\t\tgx[i] = lower_bound(X.begin(), X.end(), gx[i]) - X.begin();\n\t\tsy[i] = lower_bound(Y.begin(), Y.end(), sy[i]) - Y.begin();\n\t\tgy[i] = lower_bound(Y.begin(), Y.end(), gy[i]) - Y.begin();\n\t}\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) {\n\t\t\tif (wall[i][j] == true || col[i][j] >= 1) continue;\n\t\t\tcntw++; dfs(i, j);\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)X.size(); i++) {\n\t\tfor (int j = 0; j < (int)Y.size() - 2; j++) {\n\t\t\tif (wall[i][j] == false && wall[i][j + 1] == true && wall[i][j + 2] == false && col[i][j] != col[i][j + 2]) {\n\t\t\t\tint d1 = col[i][j], d2 = col[i][j + 2];\n\t\t\t\tif (M[make_pair(d1, d2)] == 1) continue;\n\t\t\t\tM[make_pair(d1, d2)] = 1; G[d1].push_back(d2);\n\t\t\t\tM[make_pair(d2, d1)] = 1; G[d2].push_back(d1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)Y.size(); i++) {\n\t\tfor (int j = 0; j < (int)X.size() - 2; j++) {\n\t\t\tif (wall[j][i] == false && wall[j + 1][i] == true && wall[j + 2][i] == false && col[j][i] != col[j + 2][i]) {\n\t\t\t\tint d1 = col[j][i], d2 = col[j + 2][i];\n\t\t\t\tif (M[make_pair(d1, d2)] == 1) continue;\n\t\t\t\tM[make_pair(d1, d2)] = 1; G[d1].push_back(d2);\n\t\t\t\tM[make_pair(d2, d1)] = 1; G[d2].push_back(d1);\n\t\t\t}\n\t\t}\n\t}\n\t/*for (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) cout << (int)wall[i][j] << \" \"; cout << endl;\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < X.size(); i++) {\n\t\tfor (int j = 0; j < Y.size(); j++) cout << col[i][j] << \" \"; cout << endl;\n\t}*/\n\tfor (int i = 1; i <= Q; i++) {\n\t\tcout << solve(col[sx[i]][sy[i]], col[gx[i]][gy[i]]) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\t//if (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] < INF) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x < 0 || y < 0 || x >= grid.size() || y >= grid.size()) return false;\n\tif (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\t//if (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (ns) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define MAX 111\n\nint W, H, M, Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nvector<int> X, Y;\n\nbool hori[MAX*4][MAX*4];\nbool vert[MAX*4][MAX*4];\nbool used[MAX*4][MAX*4];\nint color[MAX*4][MAX*4];\n\nmap<int, int> mpX, mpY;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvector< set<int> > graph;\n\nsigned main(){\n  cin >> W >> H >> M;\n  X.push_back(0);\n  X.push_back(W);\n  Y.push_back(0);\n  Y.push_back(H);  \n  for(int i = 0; i < M; i++) {\n    cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n    X.push_back(px[i]);\n    X.push_back(qx[i]);\n    Y.push_back(py[i]);\n    Y.push_back(qy[i]);        \n  }\n  sort(X.begin(), X.end());\n  X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end());\n  Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  /*\n  for(int i = 0; i < X.size(); i++)cout<<X[i]<<\" \";\n  cout<<endl;\n  for(int i = 0; i < Y.size(); i++)cout<<Y[i]<<\" \";\n  cout<<endl;  \n  */\n  for(int i = 0; i < X.size(); i++) mpX[X[i]] = i;\n  for(int i = 0; i < Y.size(); i++) mpY[Y[i]] = i;\n  cin >> Q;\n  for(int i = 0; i < Q; i++) {\n    cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  }\n  memset(hori, false, sizeof(hori));\n  memset(vert, false, sizeof(vert));\n  memset(used, false, sizeof(used));\n  memset(color, -1, sizeof(color));\n  for(int i = 0; i < M; i++) {\n    if(px[i] == qx[i]) {\n      if(py[i] > qy[i]) swap(py[i], qy[i]);\n      for(int j = mpY[py[i]]; j < mpY[qy[i]]; j++) {\n\tvert[j][mpX[px[i]]] = true;\n      }\n    } else {\n      if(px[i] > qx[i]) swap(px[i], qx[i]);\n      for(int j = mpX[px[i]]; j < mpX[qx[i]]; j++) {\n\thori[mpY[py[i]]][j] = true;\n      }\n    }\n  }\n  //cout<<\"piyo\"<<endl;\n  typedef pair<int, int> P;\n  int cnt = 0;\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) {\n      if(used[i][j]) continue;\n      queue<P> que;\n      que.emplace(i, j);\n      used[i][j] = true;      \n      color[i][j] = cnt;\n      while(que.size()) {\n\tP p = que.front(); que.pop();\n\tint y = p.first, x = p.second;\n\tfor(int k = 0; k < 4; k++) {\n\t  int ny = y + dy[k], nx = x + dx[k];\n\t  if(0 <= ny && ny < Y.size()-1 && 0 <= nx && nx < X.size()-1) {\n\t    if(!used[ny][nx]) {\n\t      if((k & 1) && !hori[ny][nx]) {\n\t\tque.emplace(ny, nx);\n\t\tused[ny][nx] = true;\n\t\tcolor[ny][nx] = cnt;\n\t      }\n\t      if(!(k & 1) && !vert[ny][nx]) {\n\t\tque.emplace(ny, nx);\n\t\tused[ny][nx] = true;\n\t\tcolor[ny][nx] = cnt;\n\t      }\t      \n\t    }\n\t  }\n\t}\n      }\n      cnt++;\n    }\n  }\n  graph.clear();\n  graph.resize(cnt);\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) {\n      //if(used[i][j]) continue;      \n      for(int k = 0; k < 4; k++) {\n\tint ny = i + dy[k], nx = j + dx[k];\n\tif(0 <= ny && ny < Y.size()-1 && 0 <= nx && nx < X.size()-1) {\n\t  if(color[i][j] != color[ny][nx]) {\n\t    graph[color[i][j]].insert(color[ny][nx]);\n\t    graph[color[ny][nx]].insert(color[i][j]);\n\t    //cout<<color[i][j]<<\" \"<<color[ny][nx]<<endl;\n\t  }\n\t}\n      }      \n    }\n  }\n  /*\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) cout << color[i][j];\n    cout<<endl;\n  }\n  cout << endl;\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) cout << hori[i][j];\n    cout<<endl;\n  }\n  cout<<endl;\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) cout << vert[i][j];\n    cout<<endl;\n  } \n  */ \n  //exit(0);\n  for(int q = 0; q < Q; q++) {\n    int ty = -1, tx = -1, hy = -1, hx = -1;\n    for(int i = 0; i < Y.size()-1; i++) {\n      if(Y[i] <= sy[q] && sy[q] < Y[i+1]) ty = i;\n      if(Y[i] <= gy[q] && gy[q] < Y[i+1]) hy = i;\n    }\n    for(int i = 0; i < X.size()-1; i++) {\n      if(X[i] <= sx[q] && sx[q] < X[i+1]) tx = i;\n      if(X[i] <= gx[q] && gx[q] < X[i+1]) hx = i;\n    }\n    queue<int> que;\n    que.push(color[ty][tx]);\n    vector<int> dist(cnt, -1);\n    dist[color[ty][tx]] = 0;\n    while(!que.empty()) {\n      int now = que.front(); que.pop();\n      //cout << now << endl;\n      if(now == color[hy][hx]) {\n\tcout << dist[now] << endl;\n\tbreak;\n      }\n      for(int to : graph[now]) {\n\tif(~dist[to]) continue;\n\tdist[to] = dist[now] + 1;\n\tque.push(to);\n      }\n    }\n    //cout << \"hoge\"<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[801][801];\nint used[801][801];\n\nint dp[801][801];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque2.push(P(x,y));\n\t\tused[x][y]=1;\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && used[nx][ny]==0){\n\t\t\t\t\tused[nx][ny]=1;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tdp[nx][ny]=c+1;\n\t\t\t\t\t\tque.push(data(nx,ny,c+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]*=2;\n\t\tsy[i]*=2;\n\t\tgx[i]*=2;\n\t\tgy[i]*=2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[501][501];\nint s[250001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[250001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=100101001;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid[0].size() - 1) return false;\n\treturn true;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * grid[0].size() + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(grid.size() * grid[0].size());\n\tgraph = vector<vector<int> >(grid.size() * grid[0].size(), vector<int>());\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 3010\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    rep(i,4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n\n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  /*\n  cout << 1000000000 << \" \" << 1000000000 << \" \" << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+3 << \" 999999999 \" << i*3+3 << endl;\n  }\n  cout << 100 << endl;\n  rep(i,100) {\n    cout << \"1 \" << i*3+4 << \" 999999999 \" << i*3+4 << endl;\n  }\n  return 0;\n  */\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tint W, H, N, Q;\n\tcin >> W >> H >> N;\n\tvector<int> cx = { 0, W }, cy = { 0, H };\n\tvector<int> ax(N), ay(N), bx(N), by(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> ax[i] >> ay[i] >> bx[i] >> by[i];\n\t\tcx.push_back(ax[i]);\n\t\tcy.push_back(ay[i]);\n\t\tcx.push_back(bx[i]);\n\t\tcy.push_back(by[i]);\n\t}\n\tsort(cx.begin(), cx.end());\n\tcx.erase(unique(cx.begin(), cx.end()), cx.end());\n\tsort(cy.begin(), cy.end());\n\tcy.erase(unique(cy.begin(), cy.end()), cy.end());\n\tW = cx.size() - 1;\n\tH = cy.size() - 1;\n\tvector<vector<bool> > vertline(W + 1, vector<bool>(H)), horzline(W, vector<bool>(W + 1));\n\tfor (int i = 0; i < N; ++i) {\n\t\tax[i] = lower_bound(cx.begin(), cx.end(), ax[i]) - cx.begin();\n\t\tay[i] = lower_bound(cy.begin(), cy.end(), ay[i]) - cy.begin();\n\t\tbx[i] = lower_bound(cx.begin(), cx.end(), bx[i]) - cx.begin();\n\t\tby[i] = lower_bound(cy.begin(), cy.end(), by[i]) - cy.begin();\n\t\tif (ax[i] > bx[i]) swap(ax[i], bx[i]);\n\t\tif (ay[i] > by[i]) swap(ay[i], by[i]);\n\t\tif (ax[i] == bx[i]) {\n\t\t\tfor (int j = ay[i]; j < by[i]; ++j) {\n\t\t\t\thorzline[ax[i]][j] = true;\n\t\t\t}\n\t\t}\n\t\tif (ay[i] == by[i]) {\n\t\t\tfor (int j = ax[i]; j < bx[i]; ++j) {\n\t\t\t\tvertline[j][ay[i]] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint sx, sy, gx, gy;\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tsx = lower_bound(cx.begin(), cx.end(), sx) - cx.begin() - 1;\n\t\tsy = lower_bound(cy.begin(), cy.end(), sy) - cy.begin() - 1;\n\t\tgx = lower_bound(cx.begin(), cx.end(), gx) - cx.begin() - 1;\n\t\tgy = lower_bound(cy.begin(), cy.end(), gy) - cy.begin() - 1;\n\t\tvector<vector<int> > d(W, vector<int>(H, -1));\n\t\td[sx][sy] = 0;\n\t\tdeque<pair<int, int> > que;\n\t\tque.push_back(make_pair(sx, sy));\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> u = que.front(); que.pop_front();\n\t\t\tint cur = d[u.first][u.second];\n\t\t\tif (u.first >= 1 && (d[u.first - 1][u.second] == -1 || d[u.first - 1][u.second] == cur + 1)) {\n\t\t\t\tif (horzline[u.first][u.second] && d[u.first - 1][u.second] == -1) {\n\t\t\t\t\td[u.first - 1][u.second] = cur + 1;\n\t\t\t\t\tque.push_back(make_pair(u.first - 1, u.second));\n\t\t\t\t}\n\t\t\t\tif (!horzline[u.first][u.second]) {\n\t\t\t\t\td[u.first - 1][u.second] = cur;\n\t\t\t\t\tque.push_front(make_pair(u.first - 1, u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u.first < W - 1 && (d[u.first + 1][u.second] == -1 || d[u.first + 1][u.second] == cur + 1)) {\n\t\t\t\tif (horzline[u.first + 1][u.second] && d[u.first + 1][u.second] == -1) {\n\t\t\t\t\td[u.first + 1][u.second] = cur + 1;\n\t\t\t\t\tque.push_back(make_pair(u.first + 1, u.second));\n\t\t\t\t}\n\t\t\t\tif (!horzline[u.first + 1][u.second]) {\n\t\t\t\t\td[u.first + 1][u.second] = cur;\n\t\t\t\t\tque.push_front(make_pair(u.first + 1, u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u.second >= 1 && (d[u.first][u.second - 1] == -1 || d[u.first][u.second - 1] == cur + 1)) {\n\t\t\t\tif (vertline[u.first][u.second] && d[u.first][u.second - 1] == -1) {\n\t\t\t\t\td[u.first][u.second - 1] = cur + 1;\n\t\t\t\t\tque.push_back(make_pair(u.first, u.second - 1));\n\t\t\t\t}\n\t\t\t\tif (!vertline[u.first][u.second]) {\n\t\t\t\t\td[u.first][u.second - 1] = cur;\n\t\t\t\t\tque.push_front(make_pair(u.first, u.second - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u.second < H - 1 && (d[u.first][u.second + 1] == -1 || d[u.first][u.second + 1] == cur + 1)) {\n\t\t\t\tif (vertline[u.first][u.second + 1] && d[u.first][u.second + 1] == -1) {\n\t\t\t\t\td[u.first][u.second + 1] = cur + 1;\n\t\t\t\t\tque.push_back(make_pair(u.first, u.second + 1));\n\t\t\t\t}\n\t\t\t\tif (!vertline[u.first][u.second + 1]) {\n\t\t\t\t\td[u.first][u.second + 1] = cur;\n\t\t\t\t\tque.push_front(make_pair(u.first, u.second + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << d[gx][gy] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[1001][1001],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[1001][1001],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[I]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[I]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx]&&used[ry][rx]==0)graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\nif(a[sy][sx]<0){\nif(a[sy+1][sx]>0)sy++;\nelse if(a[sy][sx+1]>0)sx++;\nelse sy++,sx++;\n}\nif(a[gy][gx]<0){\nif(a[gy+1][gx]>0)gy++;\nelse if(a[gy][gx+1]<0)gxx++;\nelse gy++,gx++;\n}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1 << 28)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct State {\n\tint x, y, cnt;\n\tState (int x, int y, int cnt) : x(x), y(y), cnt(cnt){}\n\tbool operator < (const State &t) const {\n\t\treturn cnt > t.cnt;\n\t}\n};\n\nint w, h, m, q;\nvector<int> ZX, ZY;\nint PX[100], PY[100], QX[100], QY[100];\nint SX[100], SY[100], GX[100], GY[100];\nbool grid[2048][2048];\nint d[2048][2048];\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < ZX.size() && y < ZY.size();\n}\n\nvoid solve(int sx, int sy, int gx, int gy)\n{\n\tfill((int*)d, (int*)d + 1024 * 1024, INF);\n\tpriority_queue<State> pq;\n\tfor (pq.push(State(sx, sy, 0)); pq.size(); ){\n\t\tState st = pq.top(); pq.pop();\n\t\tif (d[st.x][st.y] < st.cnt) continue;\n\t\tif (st.x == gx && st.y == gy){\n\t\t\tprintf(\"%d\\n\", st.cnt);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//printf(\"%d %d %d\\n\", st.x, st.y, st.cnt);\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = st.x + dx[dir];\n\t\t\tint ny = st.y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[st.x][st.y] && grid[nx][ny]) continue;\n\t\t\tint nc = st.cnt + grid[nx][ny];\n\t\t\tif (d[nx][ny] > nc){\n\t\t\t\tpq.push(State(nx, ny, nc));\n\t\t\t\td[nx][ny] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &m);\n\tZX.push_back(0);\n\tZY.push_back(0);\n\tZX.push_back(w * 2);\n\tZY.push_back(h * 2);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tPX[i] *= 2;\n\t\tPY[i] *= 2;\n\t\tQX[i] *= 2;\n\t\tQY[i] *= 2;\n\t\tZX.push_back(PX[i]);\n\t\tZY.push_back(PY[i]);\n\t\tZX.push_back(QX[i]);\n\t\tZY.push_back(QY[i]);\n/*\t\tZX.push_back(PX[i] - 1);\n\t\tZY.push_back(PY[i] - 1);\n\t\tZX.push_back(QX[i] - 1);\n\t\tZY.push_back(QY[i] - 1);\n*/\t\tZX.push_back(PX[i] + 1);\n\t\tZY.push_back(PY[i] + 1);\n\t\tZX.push_back(QX[i] + 1);\n\t\tZY.push_back(QY[i] + 1);\n\t}\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tSX[i] *= 2;\n\t\tSY[i] *= 2;\n\t\tGX[i] *= 2;\n\t\tGY[i] *= 2;\n\t\tZX.push_back(SX[i]);\n\t\tZY.push_back(SY[i]);\n\t\tZX.push_back(GX[i]);\n\t\tZY.push_back(GY[i]);\n\t}\n\tsort(ZX.begin(), ZX.end());\n\tZX.erase(lower_bound(ZX.begin(), ZX.end(), w * 2 + 1), upper_bound(ZX.begin(), ZX.end(), w * 2 + 1));\n\tZX.erase(unique(ZX.begin(), ZX.end()), ZX.end());\n\tsort(ZY.begin(), ZY.end());\n\tZY.erase(lower_bound(ZY.begin(), ZY.end(), h * 2 + 1), upper_bound(ZY.begin(), ZY.end(), h * 2 + 1));\n\tZY.erase(unique(ZY.begin(), ZY.end()), ZY.end());\n\tfor (int i = 0; i < m; i++){\n\t\tPX[i] = lower_bound(ZX.begin(), ZX.end(), PX[i]) - ZX.begin();\n\t\tPY[i] = lower_bound(ZY.begin(), ZY.end(), PY[i]) - ZY.begin();\n\t\tQX[i] = lower_bound(ZX.begin(), ZX.end(), QX[i]) - ZX.begin();\n\t\tQY[i] = lower_bound(ZY.begin(), ZY.end(), QY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tSX[i] = lower_bound(ZX.begin(), ZX.end(), SX[i]) - ZX.begin();\n\t\tSY[i] = lower_bound(ZY.begin(), ZY.end(), SY[i]) - ZY.begin();\n\t\tGX[i] = lower_bound(ZX.begin(), ZX.end(), GX[i]) - ZX.begin();\n\t\tGY[i] = lower_bound(ZY.begin(), ZY.end(), GY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int x = PX[i]; x <= QX[i]; x++){\n\t\t\tfor (int y = PY[i]; y <= QY[i]; y++){\n\t\t\t\tgrid[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < ZY.size(); i++){\n\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\tprintf(\"%c\", grid[j][i] ? '+' : ' ');\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < q; i++){\n\t\t//printf(\"%d:\\n\", i);\n\t\tsolve(SX[i], SY[i], GX[i], GY[i]);\n\t\t/*for (int i = 0; i < ZY.size(); i++){\n\t\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\t\tprintf(\"%d\", d[j][i] - INF ? d[i][j] : 9);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 210\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  assert(false);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  rep(i,(int)X.size()) X[i] = X[i];\n  rep(i,(int)Y.size()) Y[i] = Y[i];\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[5001][5001]={0};\nvector<long long> node[105005];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i]&&y<h;y++){\n      for(long long x=X1[i];x<=X2[i]&&x<w;x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      masu[ny][nx]=now;\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[105005];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    W*=2;H*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;ys.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint ddy[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<16;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nint field[700][700][4];\n\nstruct aa {\n\tint ax;\n\tint ay;\n\tint time;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nstruct line {\n\tint px;\n\tint py;\n\tint qx;\n\tint qy;\n\tint special;\n};\nstruct Compress {\n\tmap<int, int>mp;\n\tmap<int, int>revmp;\n\n\tCompress(vector<int>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (int i = 0; i < vs.size(); ++i) {\n\t\t\tmp[vs[i]] = i+10;\n\t\t\trevmp[i + 10] = vs[i];\n\t\t}\n\t}\n\tCompress(const set<int>&vs) {\n\t\tint num = 10;\n\t\tfor (auto v : vs) {\n\t\t\tmp[v] = num;\n\t\t\trevmp[num] = v;\n\t\t\tnum+=2;\n\t\t}\n\t}\n};\nint memo[700][700];\nint main() {\n\tmemset(field, 0, sizeof(field));\n\tint W, H, M; cin >> W >> H >> M;\n\tset<int>xs, ys;\n\tvector<line>ls;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint px, py, qx, qy; cin >> px >> py >> qx >> qy;\n\t\txs.emplace(px);\n\t\tys.emplace(py);\n\t\txs.emplace(qx);\n\t\tys.emplace(qy);\n\t\tls.push_back(line{ px,py,qx,qy,1 });\n\t}\n\txs.emplace(0); xs.emplace(W);\n\tls.push_back(line{ 0,0,W,0,10000 });\n\tls.push_back(line{ 0,H,W,H,10000 });\n\n\tys.emplace(0);ys.emplace(H);\n\tls.push_back(line{ 0,0,0,H,10000 });\n\tls.push_back(line{ W,0,W,H,10000 });\n\tCompress compx(xs);\n\tCompress compy(ys);\n\tfor (auto&l : ls) {\n\t\tl.px = compx.mp[l.px];\n\t\tl.py = compy.mp[l.py];\n\t\tl.qx = compx.mp[l.qx];\n\t\tl.qy = compy.mp[l.qy];\n\t}\n\tfor (auto&l : ls) {\n\t\tif (l.px == l.qx) {\n\t\t\tint miny = min(l.py, l.qy);\n\t\t\tint maxy = max(l.py, l.qy);\n\t\t\tfor (int y = miny; y < maxy;++y) {\n\t\t\t\tfield[y][l.px - 1][2] = l.special;\n\t\t\t\tfield[y][l.px][0] = l.special;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint minx = min(l.px, l.qx);\n\t\t\tint maxx = max(l.px, l.qx);\n\t\t\tfor (int x = minx; x < maxx; ++x) {\n\t\t\t\tfield[l.qy][x][3] = l.special;\n\t\t\t\tfield[l.qy-1][x][1] = l.special;\n\t\t\t}\n\t\t}\n\t}\n\tint Q; cin >> Q;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tfor (int i = 0; i < 700; ++i) {\n\t\t\tfor (int j = 0; j < 700; ++j) {\n\t\t\t\tmemo[i][j] = 100000;\n\t\t\t}\n\t\t}\n\t\tint sx, sy, gx, gy; cin >> sx >> sy >> gx >> gy;\n\t\t{\n\t\t\tauto it=compx.mp.lower_bound(sx);\n\t\t\tsx = it->second - 1;\n\t\t}\n\t\t{\n\t\t\tauto it = compx.mp.lower_bound(gx);\n\t\t\tgx = it->second  -1;\n\t\t}\n\t\t{\n\t\t\tauto it = compy.mp.lower_bound(sy);\n\t\t\tsy = it->second - 1;\n\t\t}\n\t\t{\n\t\t\tauto it = compy.mp.lower_bound(gy);\n\t\t\tgy = it->second - 1;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tmemo[sx][sy] = 0;\n\n\t\t\n\t\tque.push(aa{ sx,sy,0 });\n\t\tint ans = 0;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tconst int nowx = atop.ax;\n\t\t\tconst int nowy = atop.ay;\n\t\t\tconst int nowtime = atop.time;\n\t\t\tif (nowx == gx&&nowy == gy) {\n\t\t\t\tans = nowtime;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\tif (field[nowy][nowx][way]!=10000) {\n\t\t\t\t\tconst int nexty = nowy + dy[way];\n\t\t\t\t\tconst int nextx = nowx + dx[way];\n\t\t\t\t\tconst int nexttime = nowtime + field[nowy][nowx][way];\n\t\t\t\t\tif (nexttime < memo[nextx][nexty]) {\n\t\t\t\t\t\tmemo[nextx][nexty] = nexttime;\n\t\t\t\t\t\tque.push(aa{ nextx,nexty,nexttime });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <tuple>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <cstdint>\n#include <cctype>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\nusing ll =  long long;\nusing Pll = pair<ll, ll>;\nusing Pii = pair<int, int>;\nusing P = pair<int, Pii>;\n\nconstexpr int INF = 1 << 30;\nconstexpr ll LINF = 1LL << 60;\nconstexpr ll MOD = 1000000007;\nconstexpr long double EPS = 1e-10;\nconstexpr int dyx[4][2] = {\n    { 0, 1}, {-1, 0}, {0,-1}, {1, 0}    // 右, 上, 左, 下\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int w, h, m;\n    cin >> w >> h >> m;\n    int px[m], py[m], qx[m], qy[m];\n    set<int> xs, ys;\n    xs.insert(0);\n    xs.insert(w);\n    ys.insert(0);\n    ys.insert(h);\n    for(int i=0;i<m;++i) {\n        cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n        xs.insert(px[i]);\n        ys.insert(py[i]);\n        xs.insert(qx[i]);\n        ys.insert(qy[i]);\n    }\n\n    int q;\n    cin >> q;\n    int sx[m], sy[m], gx[m], gy[m];\n    for(int i=0;i<q;++i) {\n        cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n        xs.insert(sx[i]);\n        ys.insert(sy[i]);\n        xs.insert(gx[i]);\n        ys.insert(gy[i]);\n    }\n\n    map<int, int> mpx, mpy;\n    {\n        int i = 0;\n        for(int x: xs) {\n            mpx[x] = i++;\n        }\n    }\n    {\n        int i = 0;\n        for(int y: ys) {\n            mpy[y] = i++;\n        }\n    }\n\n    bool a[2*ys.size()-1][2*xs.size()-1];\n    fill_n(a[0], (2*ys.size()-1) * (2*xs.size()-1), true);\n    for(int i=0;i<2*ys.size()-1;++i) {\n        a[i][0] = false;\n        a[i][2*xs.size()-2] = false;\n    }\n    for(int j=0;j<2*xs.size()-1;++j) {\n        a[0][j] = false;\n        a[2*ys.size()-2][j] = false;\n    }\n    for(int i=0;i<m;++i) {\n        for(int x=2*mpx[min(px[i], qx[i])];x<=2*mpx[max(px[i], qx[i])];++x) {\n            for(int y=2*mpy[min(py[i], qy[i])];y<=2*mpy[max(py[i], qy[i])];++y) {\n                a[y][x] = false;\n            }\n        }\n    }\n\n    int nodes[2*ys.size()-1][2*xs.size()-1];\n    fill_n(nodes[0], (2*ys.size()-1) * (2*xs.size()-1), 0);\n    int node_i = 1;\n    for(int y=1;y<2*ys.size()-2;++y) {\n        for(int x=1;x<2*xs.size()-2;++x) {\n            if(!a[y][x] || nodes[y][x]) continue;\n            nodes[y][x] = node_i;\n            queue<Pii> que;\n            que.emplace(y, x);\n            while(!que.empty()) {\n                Pii p = que.front(); que.pop();\n                for(int k=0;k<4;++k) {\n                    int yy = p.first + dyx[k][0], xx = p.second + dyx[k][1];\n                    if(!a[yy][xx] || nodes[yy][xx]) continue;\n                    que.emplace(yy, xx);\n                    nodes[yy][xx] = node_i;\n                }\n            }\n            node_i++;\n        }\n    }\n\n    set<int> graph[node_i];\n    for(int y=1;y<2*ys.size()-2;++y) {\n        for(int x=1;x<2*xs.size()-2;++x) {\n            if(nodes[y][x]) continue;\n            if(nodes[y-1][x] != 0 && nodes[y+1][x] != 0) {\n                graph[nodes[y-1][x]].insert(nodes[y+1][x]);\n                graph[nodes[y+1][x]].insert(nodes[y-1][x]);\n            }\n            if(nodes[y][x-1] != 0 && nodes[y][x+1] != 0) {\n                graph[nodes[y][x-1]].insert(nodes[y][x+1]);\n                graph[nodes[y][x+1]].insert(nodes[y][x-1]);\n            }\n        }\n    }\n\n    for(int i=0;i<q;++i) {\n        int s = nodes[2*mpy[sy[i]]][2*mpx[sx[i]]];\n        int g = nodes[2*mpy[gy[i]]][2*mpx[gx[i]]];\n        queue<int> que;\n        vector<int> dist(node_i, INF);\n        que.push(s);\n        dist[s] = 0;\n        while(!que.empty()) {\n            s = que.front(); que.pop();\n            for(int t: graph[s]) {\n                if(dist[t] > dist[s] + 1) {\n                    dist[t] = dist[s] + 1;\n                    que.push(t);\n                }\n            }\n        }\n        cout << dist[g] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nqueue<P> que;\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tif(y<500&&x<500&&y>=0&&x>=0){\n\t  masu[y][x]=-1;\n\t}\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      //sx++;\n      sy*=2;\n      //sy++;\n      gx*=2;\n      //gx++;\n      gy*=2;\n      //gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=max(0,upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1);\n      syp=max(0,upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1);\n      gxp=max(0,upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1);\n      gyp=max(0,upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define int long long\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[2000][2000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    if(dist[t]==INF)for(;;);\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%lld%lld%lld\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%lld%lld%lld%lld\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%lld%lld%lld%lld\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 210\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  assert(false);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(W), Y.push_back(H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = W, qy[M  ] = 0;\n  px[M+1] = W, py[M+1] = 0, qx[M+1] = W, qy[M+1] = H;\n  px[M+2] = W, py[M+2] = H, qx[M+2] = 0, qy[M+2] = H;\n  px[M+3] = 0, py[M+3] = H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[250001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[250001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=100101001;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<fstream>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nbool FF[1000][1000];\nint ccccc, ddddd;\nvoid DFS(int XS, int YS,int XG,int YG){\n\tpriority_queue <pair<int, int> >que;\n\tque.push(make_pair(XS, YS));\n\tint res = 0;\n\twhile (true){\n\t\tbool F = true;\n\t\tif (res == 0){\n\t\t\tMAP[XS][YS] = 0;\n\t\t\tque.push(make_pair(XS, YS));\n\t\t}\n\t\twhile (!que.empty()){\n\t\t\tpair<int, int> P = que.top(); que.pop();\n\t\t\tif (FF[P.first][P.second])continue;\n\t\t\tFF[P.first][P.second] = true;\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tif (P.first + DX[i] >= 0 && P.first + DX[i] <= 2 * (ccccc - 1) && P.second + DY[i] >= 0 && P.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\t\tif (MAP[P.first + DX[i]][P.second + DY[i]] != -1){\n\t\t\t\t\t\tif (!FF[P.first + DX[i]][P.second + DY[i]]){\n\t\t\t\t\t\t\tMAP[P.first + DX[i]][P.second + DY[i]] = res;\n\t\t\t\t\t\t\tque.push(make_pair(P.first + DX[i], P.second + DY[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 2 * (ccccc - 1); i++){\n\t\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j++){\n\t\t\t\tif (MAP[i][j] != res)continue;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tif (i + DX[k] >= 0 && i + DX[k] <= 2 * (ccccc - 1) && j + DY[k] >= 0 && j + DY[k] <= 2 * (ddddd - 1)){\n\t\t\t\t\t\tif (MAP[i + DX[k]][j + DY[k]] == -1){\n\t\t\t\t\t\t\tif (!FF[i + 2 * DX[k]][j + 2 * DY[k]] && MAP[i + 2 * DX[k]][j + 2 * DY[k]] != -1){\n\t\t\t\t\t\t\t\tque.push(make_pair(i + 2 * DX[k], j + 2 * DY[k]));\n\t\t\t\t\t\t\t\tMAP[i + 2 * DX[k]][j + 2 * DY[k]] = res + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres++;\n\t\tif (MAP[XG][YG] != 10000000){\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j++){\n\t\t\tfor (int k = 0; k <= 2 * (ddddd - 1); k++){\n\t\t\t\tFF[j][k] = false;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY,GGX,GGY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define MAX 111\n\nint W, H, M, Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nvector<int> X, Y;\n\nbool hori[MAX*4][MAX*4];\nbool vert[MAX*4][MAX*4];\nbool used[MAX*4][MAX*4];\nint color[MAX*4][MAX*4];\n\nmap<int, int> mpX, mpY;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvector< set<int> > graph;\n\nsigned main(){\n  cin >> W >> H >> M;\n  X.push_back(0);\n  X.push_back(W);\n  Y.push_back(0);\n  Y.push_back(H);  \n  for(int i = 0; i < M; i++) {\n    cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n    X.push_back(px[i]);\n    X.push_back(qx[i]);\n    Y.push_back(py[i]);\n    Y.push_back(qy[i]);        \n  }\n  sort(X.begin(), X.end());\n  X.erase(unique(X.begin(), X.end()), X.end());\n  sort(Y.begin(), Y.end());\n  Y.erase(unique(Y.begin(), Y.end()), Y.end());\n  /*\n  for(int i = 0; i < X.size(); i++)cout<<X[i]<<\" \";\n  cout<<endl;\n  for(int i = 0; i < Y.size(); i++)cout<<Y[i]<<\" \";\n  cout<<endl;  \n  */\n  for(int i = 0; i < X.size(); i++) mpX[X[i]] = i;\n  for(int i = 0; i < Y.size(); i++) mpY[Y[i]] = i;\n  cin >> Q;\n  for(int i = 0; i < Q; i++) {\n    cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  }\n  memset(hori, false, sizeof(hori));\n  memset(vert, false, sizeof(vert));\n  memset(used, false, sizeof(used));\n  memset(color, -1, sizeof(color));\n  for(int i = 0; i < M; i++) {\n    if(px[i] == qx[i]) {\n      if(py[i] > qy[i]) swap(py[i], qy[i]);\n      for(int j = mpY[py[i]]; j < mpY[qy[i]]; j++) {\n\tvert[j][mpX[px[i]]] = true;\n      }\n    } else {\n      if(px[i] > qx[i]) swap(px[i], qx[i]);\n      for(int j = mpX[px[i]]; j < mpX[qx[i]]; j++) {\n\thori[mpY[py[i]]][j] = true;\n      }\n    }\n  }\n  //cout<<\"piyo\"<<endl;\n  typedef pair<int, int> P;\n  int cnt = 0;\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) {\n      if(used[i][j]) continue;\n      queue<P> que;\n      que.emplace(i, j);\n      used[i][j] = true;      \n      color[i][j] = cnt;\n      while(que.size()) {\n\tP p = que.front(); que.pop();\n\tint y = p.first, x = p.second;\n\tfor(int k = 0; k < 4; k++) {\n\t  int zx = k == 2, zy = k == 3;\n\t  int ny = y + dy[k], nx = x + dx[k];\n\t  if(0 <= ny && ny < Y.size()-1 && 0 <= nx && nx < X.size()-1) {\n\t    if(!used[ny][nx]) {\n\t      if((k & 1) && !hori[ny+zy][nx+zx]) {\n\t\tque.emplace(ny, nx);\n\t\tused[ny][nx] = true;\n\t\tcolor[ny][nx] = cnt;\n\t      }\n\t      if(!(k & 1) && !vert[ny+zy][nx+zx]) {\n\t\tque.emplace(ny, nx);\n\t\tused[ny][nx] = true;\n\t\tcolor[ny][nx] = cnt;\n\t      }\t      \n\t    }\n\t  }\n\t}\n      }\n      cnt++;\n    }\n  }\n  graph.clear();\n  graph.resize(cnt);\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) {\n      //if(used[i][j]) continue;      \n      for(int k = 0; k < 4; k++) {\n\tint ny = i + dy[k], nx = j + dx[k];\n\tif(0 <= ny && ny < Y.size()-1 && 0 <= nx && nx < X.size()-1) {\n\t  if(color[i][j] != color[ny][nx]) {\n\t    graph[color[i][j]].insert(color[ny][nx]);\n\t    graph[color[ny][nx]].insert(color[i][j]);\n\t    //cout<<color[i][j]<<\" \"<<color[ny][nx]<<endl;\n\t  }\n\t}\n      }      \n    }\n  }\n  /*\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) cout << color[i][j];\n    cout<<endl;\n  }\n  cout << endl;\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) cout << hori[i][j];\n    cout<<endl;\n  }\n  cout<<endl;\n  for(int i = 0; i < Y.size()-1; i++) {\n    for(int j = 0; j < X.size()-1; j++) cout << vert[i][j];\n    cout<<endl;\n  } \n  */ \n  //exit(0);\n  for(int q = 0; q < Q; q++) {\n    int ty = -1, tx = -1, hy = -1, hx = -1;\n    for(int i = 0; i < Y.size()-1; i++) {\n      if(Y[i] <= sy[q] && sy[q] < Y[i+1]) ty = i;\n      if(Y[i] <= gy[q] && gy[q] < Y[i+1]) hy = i;\n    }\n    for(int i = 0; i < X.size()-1; i++) {\n      if(X[i] <= sx[q] && sx[q] < X[i+1]) tx = i;\n      if(X[i] <= gx[q] && gx[q] < X[i+1]) hx = i;\n    }\n    queue<int> que;\n    que.push(color[ty][tx]);\n    vector<int> dist(cnt, -1);\n    dist[color[ty][tx]] = 0;\n    while(!que.empty()) {\n      int now = que.front(); que.pop();\n      //cout << now << endl;\n      if(now == color[hy][hx]) {\n\tcout << dist[now] << endl;\n\tbreak;\n      }\n      for(int to : graph[now]) {\n\tif(~dist[to]) continue;\n\tdist[to] = dist[now] + 1;\n\tque.push(to);\n      }\n    }\n    //cout << \"hoge\"<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[3001][3001]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[3001][3001]={0};\nvector<long long> node[3005];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[3005];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      s=masu[syp][sxp];\n      g=masu[gyp][gxp];\n      for(int j=1;j<=now;j++){\n\tmincost[j]=(1LL<<60);\n      }\n      priority_queue<P,vector<P>,greater<P> >que;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tlong long nowc=que.top().first;\n\tlong long nowp=que.top().second;\n\tque.pop();\n\tif(nowp==g){\n\t  cout<<nowc<<endl;\n\t  break;\n\t}\n\tfor(int j=0;j<node[nowp].size();j++){\n\t  long long nextp=node[nowp][j];\n\t  if(mincost[nextp]>nowc+1){\n\t    mincost[nextp]=nowc+1;\n\t    que.push(P(nowc+1,nextp));\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::unordered_map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = -2, WALL};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nvoid flood_fill(vector<vector<int>>& field, int y, int x, int color) {\n  const int h = field.size();\n  const int w = field.front().size();\n  field[y][x] = color;\n  for(const auto& d: NEXT) {\n    int ny = y + d[Y];\n    int nx = x + d[X];\n    if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n    if(field[ny][nx] == BLANK) flood_fill(field, ny, nx, color);\n  }\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n\n  vector<vector<int>> field(y.size(), vector<int>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n  // 塗りつぶし\n  int color = 0;\n  for(int i = 0; i < y.size(); ++i) for(int j = 0; j < x.size(); ++j) {\n    if(field[i][j] == BLANK) flood_fill(field, i, j, color++);\n  }\n\n  // ワーシャルフロイド\n  const int INF = 1000000000;\n  const int NEXTNEXT[4][2] = {{-2, 0}, {2, 0}, {0, -2}, {0, 2}};\n  vector<vector<int>> cost(color, vector<int>(color, INF));\n  for(int v = 0; v < color; ++v) cost[v][v] = 0;\n  for(int i = 0; i < y.size(); ++i) for(int j = 0; j < x.size(); ++j) {\n    if(field[i][j] == WALL) continue;\n    for(const auto& d: NEXTNEXT) {\n      int ny = i + d[Y];\n      int nx = j + d[X];\n      if(ny < 0 || y.size() <= ny || nx < 0 || x.size() <= nx) continue;\n      int u = field[i][j];\n      int v = field[ny][nx];\n      if(v == WALL) continue;\n      if(u == v) continue;\n      cost[u][v] = cost[v][u] = 1;\n    }\n  }\n  for(int k = 0; k < color; ++k) for(int u = 0; u < color; ++u) for(int v = 0; v < color; ++v)\n    cost[u][v] = min(cost[u][v], cost[u][k] + cost[k][v]);\n\n  for(const auto& q: query) {\n    cout << cost[field[y.index(q.sy)][x.index(q.sx)]][field[y.index(q.gy)][x.index(q.gx)]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < W && y < H;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\t//if (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] < INF) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\txs.erase(xs.begin());\n\txs.pop_back();\n\tys.erase(ys.begin());\n\tys.pop_back();\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <tuple>\n#include <cstring>\n\nusing namespace std;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++) \n#define sz(c) ((int)c.size())\n\ntypedef pair<int, int> Pii;\n\nvoid compress(vector<int>& v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint w, h;\ntypedef pair<Pii, int> P;\nvector<P> e[650][650];\nint cost[650][650];\n\nint solve(Pii s, Pii g) {\n\tmemset(cost, 0x1f, sizeof(cost));\n\tdeque<Pii> deq;\n\tdeq.push_back(s);\n\tcost[s.first][s.second] = 0;\n\n\twhile (!deq.empty()) {\n\t\tPii cur = deq.front(); deq.pop_front();\n\t\tif (cur == g) \n            return cost[g.first][g.second];\n\t\tfor (auto to : e[cur.first][cur.second]) {\n\t\t\tint nf, ns;\n\t\t\ttie(nf, ns) = to.first;\n\t\t\tint ncost = cost[cur.first][cur.second] + to.second;\n\t\t\tif (ncost < cost[nf][ns]) {\n\t\t\t\tcost[nf][ns] = ncost;\n\t\t\t\tif (to.second == 0) {\n\t\t\t\t\tdeq.push_front(Pii(nf, ns));\n\t\t\t\t} else {\n\t\t\t\t\tdeq.push_back(Pii(nf, ns));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint m; cin >> w >> h >> m;\n\tvector<int> cx, cy;\n\tcx.push_back(0);\n\tcx.push_back(1);\n\tcx.push_back(w - 1);\n\tcx.push_back(w);\n\tcy.push_back(0);\n\tcy.push_back(1);\n\tcy.push_back(h - 1);\n\tcy.push_back(h);\n\tvector < pair<Pii, Pii>> seg;\n\n\tFOR(i, m) {\n\t\tint pa, pb, qa, qb;\n\t\tcin >> pa >> pb >> qa >> qb;\n\t\tseg.emplace_back(Pii(pa, pb), Pii(qa, qb));\n\t\tif (pa > qa || pb > qb) swap(seg.back().first, seg.back().second);\n\t\tif(pa - 1 >= 0) cx.push_back(pa - 1);\n\t\tcx.push_back(pa);\n\t\tif (pa + 1 <= w) cx.push_back(pa + 1);\n\t\tif (qa - 1 >= 0) cx.push_back(qa - 1);\n\t\tcx.push_back(qa);\n\t\tif (qa + 1 <= w) cx.push_back(qa + 1);\n\n\t\tif (pb - 1 >= 0) cy.push_back(pb - 1);\n\t\tcy.push_back(pb);\n\t\tif (pb + 1 <= h) cy.push_back(pb + 1);\n\t\tif (qb - 1 >= 0) cy.push_back(qb - 1);\n\t\tcy.push_back(qb);\n\t\tif (qb + 1 <= h) cy.push_back(qb + 1);\n\t}\n\tcompress(cx); compress(cy);\n\tauto co = [&cx, &cy](Pii xy) {\n\t\tint a = lower_bound(cx.begin(), cx.end(), xy.first) - cx.begin();\n\t\tint b = lower_bound(cy.begin(), cy.end(), xy.second) - cy.begin();\n\t\treturn Pii(a, b);\n\t};\n\ttie(w, h) = co(Pii(w, h));\n\n\tFOR(i, m) {\n\t\tseg[i].first = co(seg[i].first);\n\t\tseg[i].second = co(seg[i].second);\n\t}\n\n\tFOR(x, sz(cx) - 2) FOR(y, sz(cy) - 1) {\n\t\tint nx = x + 1, ny = y;\n\t\tint c = 0;\n\t\tfor (auto& s : seg) {\n\t\t\tif (s.first.first != nx) continue;\n\t\t\tif (s.second.first != nx) continue;\n\t\t\tif (s.first.second <= y && y < s.second.second) c = 1;\n\t\t}\n\t\te[x][y].push_back(P(Pii(nx, ny), c));\n\t\te[nx][ny].push_back(P(Pii(x, y), c));\n\t}\n\tFOR(x, sz(cx) - 1) FOR(y, sz(cy) - 2) {\n\t\tint nx = x , ny = y + 1;\n\t\tint c = 0;\n\t\tfor (auto& s : seg) {\n\t\t\tif (s.first.second != ny) continue;\n\t\t\tif (s.second.second != ny) continue;\n\t\t\tif (s.first.first <= x && x < s.second.first) c = 1;\n\t\t}\n\t\te[x][y].push_back(P(Pii(nx, ny), c));\n\t\te[nx][ny].push_back(P(Pii(x, y), c));\n\t}\n\n\tint q; cin >> q;\n\tFOR(i, q) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tPii s(a, b), g(c, d);\n\t\ts = co(s); s.first--; s.second--;\n\t\tg = co(g); g.first--; g.second--;\n\n\t\tint ans = solve(s, g);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=100101001;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool f[309][309][2];\nint d[309][309];\nint H,W,M,Q,h,w;\nint ax[100],ay[100],bx[100],by[100];\nmap<int,int> X,Y;\n\nint solve(int sx,int sy,int tx,int ty){\n  memset(d,1,sizeof(d));\n  deque<int> qx,qy;\n  qx.push_front(sx);\n  qy.push_front(sy);\n  d[sx][sy]=0;\n  while(!qx.empty()){\n    int px=qx.front();qx.pop_front();\n    int py=qy.front();qy.pop_front();\n    //cout<<px<<' '<<py<<endl;\n    if(px==tx&&py==ty)return d[px][py];\n    for(int i=0;i<4;i++){\n      int nx=px+dx[i];\n      int ny=py+dy[i];\n      if(nx<=0||ny<=0)continue;\n      if(w<=nx||h<=ny)continue;\n      int flg=0;\n      if(i<2){\n        if(f[px][py][i])flg=1;\n      }else{\n        if(f[nx][ny][i-2])flg=1;\n      }\n      if(d[px][py]+flg<d[nx][ny]){\n        d[nx][ny]=d[px][py]+flg;\n        if(flg){\n          qx.push_back(nx);\n          qy.push_back(ny);\n        }else{\n          qx.push_front(nx);\n          qy.push_front(ny);\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nvoid func(map<int,int> &X){  \n  map<int,int>::iterator it;  \n  int C=0;\n  for(it=X.begin();it!=X.end();++it)\n    X[it->first]=++C;\n}\n\nint sx[105],sy[105];\nint tx[105],ty[105];\n\nint main(){\n  scanf(\"%d %d %d\",&W,&H,&M);\n  for(int i=0;i<M;i++){\n    scanf(\"%d %d %d %d\",&ax[i],&ay[i],&bx[i],&by[i]);\n    if(ax[i]>bx[i])swap(ax[i],bx[i]);\n    if(ay[i]>by[i])swap(ay[i],by[i]);\n    X[ax[i]]=Y[ay[i]]=i;\n    X[bx[i]]=Y[by[i]]=i;\n  }\n  X[0]=Y[0]=1;\n  X[W]=Y[H]=M;\n  scanf(\"%d\",&Q);\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d %d %d\",&sx[i],&sy[i],&tx[i],&ty[i]);\n    X[sx[i]]=Y[sy[i]]=i;\n    X[tx[i]]=Y[ty[i]]=i;\n  }  \n  func(X);\n  func(Y);\n  w=X[W],h=Y[H];\n  for(int i=0;i<M;i++){\n    int AX=X[ax[i]],AY=Y[ay[i]];\n    int BX=X[bx[i]],BY=Y[by[i]];\n    if(AX==BX){\n      for(int y=AY;y<BY;y++)f[AX][y][0]=true;      \n    }else{\n      for(int x=AX;x<BX;x++)f[x][AY][1]=true;      \n    }    \n  }\n  for(int i=0;i<Q;i++){\n    sx[i]=X[sx[i]];\n    sy[i]=Y[sy[i]];\n    tx[i]=X[tx[i]];\n    ty[i]=Y[ty[i]];\n    printf(\"%d\\n\",solve(sx[i],sy[i],tx[i],ty[i]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nvector<int>G[160001];\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\tds[j][k]=2*(WW+HH)+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair< int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\twhile(!que.empty()){\n\t\t\t\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\t\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<ds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\tds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[1001][1001],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx]&&used[ry][rx]==0)graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\nif(a[sy][sx]<0){\nif(a[sy+1][sx]>0)sy++;\nelse if(a[sy][sx+1]>0)sx++;\nelse sy++,sx++;\n}\nif(a[gy][gx]<0){\nif(a[gy+1][gx]>0)gy++;\nelse if(a[gy][gx+1]<0)gx++;\nelse gy++,gx++;\n}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[505][505];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[901][901];\nint used[901][901];\n\nint dp[901][901];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",dp[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]*=2;\n\t\tsy[i]*=2;\n\t\tgx[i]*=2;\n\t\tgy[i]*=2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      //if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gyp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n\t//}\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[1001][1001];\n\nint dp[1001][1001];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",dp[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\treturn dp[gx][gy];\n}\n\nint sx[101],sy[101],gx[101],gy[101];\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\tif(px[i]>0)xid.push_back(px[i]-1);\n\t\tif(qx[i]>0)xid.push_back(qx[i]-1);\n\t\tif(py[i]>0)yid.push_back(py[i]-1);\n\t\tif(qy[i]>0)yid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\tif(px[i]+1<w*2)xid.push_back(px[i]+1);\n\t\tif(qx[i]+1<w*2)xid.push_back(qx[i]+1);\n\t\tif(py[i]+1<h*2)yid.push_back(py[i]+1);\n\t\tif(qy[i]+1<h*2)yid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tif(fie[j][py[i]]==0)fie[j][py[i]]=1;\n\t\t\tif(fie[j][qy[i]]==0)fie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tif(fie[px[i]][j]==0)fie[px[i]][j]=1;\n\t\t\tif(fie[qx[i]][j]==0)fie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid[0].size() - 1) return false;\n\treturn true;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * grid[0].size() + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(grid.size() * grid[0].size());\n\tgraph = vector<vector<int> >(grid.size() * grid[0].size(), vector<int>());\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    if(dist[t]==INF)for(;;);\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint ddy[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n    //if(ax[i]-ax[i-1]>2){\n      ax[i]=ax[i-1]+2;\n    //}\n    qx[mk(ay[i-1],pp)]=ax[i]-1;\n    mx[pp]=ax[i];//cout<<ax.size()<<endl;\n  }\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n    //if(ay[i]-ay[i-1]>2){\n      ay[i]=ay[i-1]+2;\n    //}\n    qy[mk(ay[i-1],pp)]=ay[i]-1;\n    my[pp]=ay[i];\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){//cout<<x<<endl;\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<16;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    /*for(int ii=0;ii<=h;ii++){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%2d\",a[ii][jj]);cout<<endl;\n    }\n    for(int ii=h;ii>=0;ii--){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%2d\",a[ii][jj]);cout<<endl;\n    }*/\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    /*for(int ii=h;ii>=0;ii--){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%3d\",a[ii][jj]);cout<<endl;\n    }*/\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      //sx*=2;sy*=2;gx*=2;gy*=2;\n      int so=a[sy][sx],go=a[gy][gx];//cout<<so<<go<<endl;\n      int use[100]={};\n      use[so]=1;\n      //if(so==go)cout<<1111<<endl;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s+1<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gyp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=100101001;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t\tif(W>=100000000&&i==0)return 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < W && y < H;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\t//if (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] < INF) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tif (px[i] > qx[i]) swap(px[i], qx[i]);\n\t\tif (py[i] > qy[i]) swap(py[i], qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\txs.erase(xs.begin());\n\txs.pop_back();\n\tys.erase(ys.begin());\n\tys.pop_back();\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (grid[x][y]) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n\tbool operator<(const data& d1)const{\n\t\treturn c<d1.c;\n\t}\n};\nint w,h,m;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[801][801];\n\nint q;\nint dp[801][801];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata pp=que.top();\n\t\tque.pop();\n\t\tint x=pp.x,y=pp.y,c=pp.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]>dp[x][y] || dp[nx][ny]==-1)){\n\t\t\t\tdp[nx][ny]=dp[x][y];\n\t\t\t\tque.push(data(nx,ny,c));\n\t\t\t}\n\t\t\tif(fie[nx][ny]==1){\n\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]>dp[x][y]+1 || dp[nx][ny]==-1)){\n\t\t\t\t\tdp[nx][ny]=dp[x][y]+1;\n\t\t\t\t\tque.push(data(nx,ny,c+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]*=2;\n\t\tsy[i]*=2;\n\t\tgx[i]*=2;\n\t\tgy[i]*=2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool f[405][405][2];\nint d[405][405];\nint H,W,M,Q,h,w;\nint ax[100],ay[100],bx[100],by[100];\nmap<int,int> X,Y;\n\nint solve(int sx,int sy,int tx,int ty){\n  memset(d,1,sizeof(d));\n  deque<int> qx,qy;\n  qx.push_front(sx);\n  qy.push_front(sy);\n  d[sx][sy]=0;\n  while(!qx.empty()){\n    int px=qx.front();qx.pop_front();\n    int py=qy.front();qy.pop_front();\n    //cout<<px<<' '<<py<<endl;\n    if(px==tx&&py==ty)return d[px][py];\n    for(int i=0;i<4;i++){\n      int nx=px+dx[i];\n      int ny=py+dy[i];\n      if(nx<=0||ny<=0)continue;\n      if(w<=nx||h<=ny)continue;\n      int flg=0;\n      if(i<2){\n        if(f[px][py][i])flg=1;\n      }else{\n        if(f[nx][ny][i-2])flg=1;\n      }\n      if(d[px][py]+flg<d[nx][ny]){\n        d[nx][ny]=d[px][py]+flg;\n        if(flg){\n          qx.push_back(nx);\n          qy.push_back(ny);\n        }else{\n          qx.push_front(nx);\n          qy.push_front(ny);\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nvoid func(map<int,int> &X){  \n  map<int,int>::iterator it;  \n  int C=0;\n  for(it=X.begin();it!=X.end();++it)\n    X[it->first]=++C;\n}\n\nint sx[105],sy[105];\nint tx[105],ty[105];\n\nint main(){\n  scanf(\"%d %d %d\",&W,&H,&M);\n  for(int i=0;i<M;i++){\n    scanf(\"%d %d %d %d\",&ax[i],&ay[i],&bx[i],&by[i]);\n    if(ax[i]>bx[i])swap(ax[i],bx[i]);\n    if(ay[i]>by[i])swap(ay[i],by[i]);\n    X[ax[i]]=Y[ay[i]]=i;\n    X[bx[i]]=Y[by[i]]=i;\n  }\n  X[0]=Y[0]=1;\n  X[W]=Y[H]=M;\n  scanf(\"%d\",&Q);\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d %d %d\",&sx[i],&sy[i],&tx[i],&ty[i]);\n    X[sx[i]]=Y[sy[i]]=i;\n    X[tx[i]]=Y[ty[i]]=i;\n  }  \n  func(X);\n  func(Y);\n  w=X[W],h=Y[H];\n  for(int i=0;i<M;i++){\n    int AX=X[ax[i]],AY=Y[ay[i]];\n    int BX=X[bx[i]],BY=Y[by[i]];\n    if(AX==BX){\n      for(int y=AY;y<BY;y++)f[AX][y][0]=true;      \n    }else{\n      for(int x=AX;x<BX;x++)f[x][AY][1]=true;      \n    }    \n  }\n  for(int i=0;i<Q;i++){\n    sx[i]=X[sx[i]];\n    sy[i]=Y[sy[i]];\n    tx[i]=X[tx[i]];\n    ty[i]=Y[ty[i]];\n    printf(\"%d\\n\",solve(sx[i],sy[i],tx[i],ty[i]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <map>\n#include <queue>\n#include <tuple>\n#include <deque>\n\nconstexpr size_t m1 = -1;\nconstexpr size_t di[] = {m1, 0, 1, 0};\nconstexpr size_t dj[] = {0, m1, 0, 1};\n\nvoid append(std::map<int, size_t>& m, int x) {\n  m[x-1], m[x], m[x+1];\n}\n\nint neko(std::vector<std::string> const& s,\n         size_t si, size_t sj, size_t gi, size_t gj) {\n\n  size_t h = s.size();\n  size_t w = s[0].length();\n\n  using zahyo = std::pair<size_t, size_t>;\n  int inf = 1e9;\n  std::vector<std::vector<int>> dp(h, std::vector<int>(w, inf));\n  dp[si][sj] = 0;\n  std::deque<zahyo> q;\n  q.emplace_front(si, sj);\n  while (!q.empty()) {\n    size_t i, j;\n    std::tie(i, j) = q.front();\n    q.pop_front();\n    bool breakable = (s[i][j] == '.');\n    for (int k = 0; k < 4; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      if (!(ni < h && nj < w)) continue;\n      int cost = 0;\n      if (s[ni][nj] == '#') {\n        if (!breakable) continue;\n        cost = 1;\n      }\n      if (dp[ni][nj] > dp[i][j] + cost) {\n        dp[ni][nj] = dp[i][j] + cost;\n        if (cost == 0) {\n          q.emplace_front(ni, nj);\n        } else {\n          q.emplace_back(ni, nj);\n        }\n        if (ni == gi && nj == gj) {\n          // for (size_t i = 0; i < h; ++i)\n          //   for (size_t j = 0; j < w; ++j) {\n          //     if (dp[i][j] == inf) fprintf(stderr, \"##\");\n          //     else fprintf(stderr, \"%2d\", dp[i][j]);\n          //     fprintf(stderr, \"%c\", j+1<w? ' ':'\\n');\n          //   }\n          return dp[ni][nj];\n        }\n      }\n    }\n  }\n\n  assert(false);\n  // return dp[gi][gj];\n}\n\nint main() {\n  size_t h, w, m;\n  scanf(\"%zu %zu %zu\", &w, &h, &m);\n\n  std::map<int, size_t> xs, ys;\n  std::vector<int> px(m), py(m), qx(m), qy(m);\n  xs[0], xs[2*w], ys[0], ys[2*h];\n  for (size_t i = 0; i < m; ++i) {\n    scanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n    if (px[i] > qx[i]) std::swap(px[i], qx[i]);\n    if (py[i] > qy[i]) std::swap(py[i], qy[i]);\n    px[i] *= 2;\n    py[i] *= 2;\n    qx[i] *= 2;\n    qy[i] *= 2;\n  }\n\n  size_t q;\n  scanf(\"%zu\", &q);\n  std::vector<int> sx(q), sy(q), gx(q), gy(q);\n  for (size_t i = 0; i < q; ++i) {\n    scanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n    // if (sx[i] > gx[i]) std::swap(sx[i], gx[i]);\n    // if (sy[i] > gy[i]) std::swap(sy[i], gy[i]);\n    sx[i] *= 2;\n    sy[i] *= 2;\n    gx[i] *= 2;\n    gy[i] *= 2;\n  }\n\n  for (auto const& x: px) append(xs, x);\n  for (auto const& x: qx) append(xs, x);\n  for (auto const& x: sx) append(xs, x);\n  for (auto const& x: gx) append(xs, x);\n\n  for (auto const& y: py) append(ys, y);\n  for (auto const& y: qy) append(ys, y);\n  for (auto const& y: sy) append(ys, y);\n  for (auto const& y: gy) append(ys, y);\n\n  {\n    size_t i = 0;\n    for (auto& p: xs) p.second = i++;\n    // for (auto& p: xs) {\n    //   fprintf(stderr, \"x: %d -> %zu\\n\", p.first, p.second);\n    // }\n  }\n  {\n    size_t i = 0;\n    for (auto& p: ys) p.second = i++;\n    // for (auto& p: ys) {\n    //   fprintf(stderr, \"y: %d -> %zu\\n\", p.first, p.second);\n    // }\n  }\n\n  size_t hh = ys.size();\n  size_t ww = xs.size();\n  std::vector<std::string> s(hh, std::string(ww, '.'));\n  for (size_t i = 0; i < m; ++i) {\n    size_t pi = ys.at(py[i]);\n    size_t pj = xs.at(px[i]);\n    size_t qi = ys.at(qy[i]);\n    size_t qj = xs.at(qx[i]);\n    for (size_t ii = pi; ii <= qi; ++ii)\n      for (size_t jj = pj; jj <= qj; ++jj)\n        s[ii][jj] = '#';\n  }\n\n  s[ys.at(0)] = s[ys.at(2*h)] = std::string(ww, '#');\n  s[0] = s[hh-1] = std::string(ww, '#');\n  for (size_t i = 0; i < hh; ++i) {\n    s[i][xs.at(0)] = s[i][xs.at(2*w)] = '#';\n    s[i][0] = s[i][ww-1] = '#';\n  }\n\n  // for (size_t i = 0; i < hh; ++i)\n  //   fprintf(stderr, \"%s\\n\", s[i].c_str());\n\n  for (size_t i = 0; i < q; ++i) {\n    int res = neko(s, ys.at(sy[i]), xs.at(sx[i]), ys.at(gy[i]), xs.at(gx[i]));\n    printf(\"%d\\n\", res);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<fstream>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nbool FF[1000][1000];\nint ccccc, ddddd;\nvoid DFS(int XS, int YS,int XG,int YG){\n\tpriority_queue <pair<int, int> >que;\n\tque.push(make_pair(XS, YS));\n\tint res = 0;\n\twhile (true){\n\t\tbool F = true;\n\t\tif (res == 0){\n\t\t\tMAP[XS][YS] = 0;\n\t\t\tque.push(make_pair(XS, YS));\n\t\t}\n\t\twhile (!que.empty()){\n\t\t\tpair<int, int> P = que.top(); que.pop();\n\t\t\tif (FF[P.first][P.second])continue;\n\t\t\tFF[P.first][P.second] = true;\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tif (P.first + DX[i] >= 0 && P.first + DX[i] <= 2 * (ccccc - 1) && P.second + DY[i] >= 0 && P.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\t\tif (MAP[P.first + DX[i]][P.second + DY[i]] != -1){\n\t\t\t\t\t\tif (!FF[P.first + DX[i]][P.second + DY[i]]){\n\t\t\t\t\t\t\tMAP[P.first + DX[i]][P.second + DY[i]] = res;\n\t\t\t\t\t\t\tque.push(make_pair(P.first + DX[i], P.second + DY[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 2 * (ccccc - 1); i++){\n\t\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j++){\n\t\t\t\tif (MAP[i][j] != res)continue;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tif (i + DX[k] >= 0 && i + DX[k] <= 2 * (ccccc - 1) && j + DY[k] >= 0 && j + DY[k] <= 2 * (ddddd - 1)){\n\t\t\t\t\t\tif (MAP[i + DX[k]][j + DY[k]] == -1){\n\t\t\t\t\t\t\tif (!FF[i + 2 * DX[k]][j + 2 * DY[k]] && MAP[i + 2 * DX[k]][j + 2 * DY[k]] != -1){\n\t\t\t\t\t\t\t\tque.push(make_pair(i + 2 * DX[k], j + 2 * DY[k]));\n\t\t\t\t\t\t\t\tMAP[i + 2 * DX[k]][j + 2 * DY[k]] = res + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres++;\n\t\t\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j++){\n\t\t\tfor (int k = 0; k <= 2 * (ddddd - 1); k++){\n\t\t\t\tFF[j][k] = false;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY,GGX,GGY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 510\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      if( dx != 0 && dy != 0 ) continue;\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[1001][1001];\n\nint dp[1001][1001];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",dp[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\treturn dp[gx][gy];\n}\n\nint sx[101],sy[101],gx[101],gy[101];\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\tif(px[i]>0)xid.push_back(px[i]-1);\n\t\tif(qx[i]>0)xid.push_back(qx[i]-1);\n\t\tif(py[i]>0)yid.push_back(py[i]-1);\n\t\tif(qy[i]>0)yid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\tif(px[i]+1<w*2)xid.push_back(px[i]+1);\n\t\tif(qx[i]+1<w*2)xid.push_back(qx[i]+1);\n\t\tif(py[i]+1<h*2)yid.push_back(py[i]+1);\n\t\tif(qy[i]+1<h*2)yid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tif(fie[j][py[i]]==0)fie[j][py[i]]=1;\n\t\t\tif(fie[j][qy[i]]==0)fie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tif(fie[px[i]][j]==0)fie[px[i]][j]=1;\n\t\t\tif(fie[qx[i]][j]==0)fie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nvector<int> edge[20001];\nint fie[3001][3001];\nint dp[20001];\nint cnt;\n\nint sx[101],sy[101],gx[101],gy[101];\n\n\nint bfs(int x,int y){\n\tqueue <P> que;\n\tque.push(P(x,y));\n\tfie[x][y]=cnt;\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tint xx=p.first,yy=p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tfie[nx][ny]=cnt;\n\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<int> que;\n\tdp[f]=0;\n\tque.push(f);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tif(v==t)return dp[t];\n\t\tfor(int i=0;i<edge[v].size();i++){\n\t\t\tint next=edge[v][i];\n\t\t\tif(dp[next]==-1){\n\t\t\t\tdp[next]=dp[v]+1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\tif(px[i]>0)xid.push_back(px[i]-1);\n\t\tif(qx[i]>0)xid.push_back(qx[i]-1);\n\t\tif(py[i]>0)yid.push_back(py[i]-1);\n\t\tif(qy[i]>0)yid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\tif(px[i]+1<w*2)xid.push_back(px[i]+1);\n\t\tif(qx[i]+1<w*2)xid.push_back(qx[i]+1);\n\t\tif(py[i]+1<h*2)yid.push_back(py[i]+1);\n\t\tif(qy[i]+1<h*2)yid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=-1;\n\t\t\tfie[j][qy[i]]=-1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=-1;\n\t\t\tfie[qx[i]][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tif(fie[j][i]==0){\n\t\t\t\tcnt++;\n\t\t\t\tbfs(j,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tif(fie[j][i]>=1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k]*2,ny=i+dy[k]*2;\n\t\t\t\t\tif(nx>=0 && nx<xid.size() && ny>=0 && ny<yid.size()){\n\t\t\t\t\t\tif(fie[nx][ny]>=0 && fie[nx][ny]!=fie[j][i]){\n\t\t\t\t\t\t\tint l;\n\t\t\t\t\t\t\tfor(l=0;l<edge[fie[j][i]].size();l++){\n\t\t\t\t\t\t\t\tif(edge[fie[j][i]][l]==fie[nx][ny])break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l==edge[fie[j][i]].size()){\n\t\t\t\t\t\t\t\tedge[fie[j][i]].push_back(fie[nx][ny]);\n\t\t\t\t\t\t\t\tedge[fie[nx][ny]].push_back(fie[j][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j+1==xid.size()?'\\n':' ');\t\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs2(fie[sx[i]][sy[i]],fie[gx[i]][gy[i]]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nint px[114];ll py[114];ll qx[114];ll qy[114];\nvector<int> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nvector<int>G[160001];\nint main()\n{\n\tscanf(\"%d%d%d\",&W,&H,&M);W*=2;H*=2;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;py[i]*=2;qx[i]*=2;qy[i]*=2;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\tds[j][k]=2*(WW+HH)+1;\n\t\t\t}\n\t\t}\n\t\tint sx,sy,gx,gy;\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\tsx*=2;sy*=2;gx*=2;gy*=2;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair<int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\tds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Segment {\n  int x1, y1, x2, y2;\n  Segment(int x1, int y1, int x2, int y2):x1(x1), y1(y1), x2(x2), y2(y2){};\n};\nbool mas[1000][1000], used[1000][1000];\nint number[1000][1000], edge[400][400];\nconst int INF = 1 << 28;\nstatic const int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\ninline void dfs(int x, int y, const int& num) {\n  if(number[y][x] != -1 || mas[y][x]) return;\n  number[y][x] = num;\n  for(int i = 0; i < 4; i++) dfs(x + dx[i], y + dy[i], num);\n}\n\ninline void dfs2(int x, int y, const int& W, const int& H) {\n  if(used[y][x]++) return;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    int vx = x - dx[i], vy = y - dy[i];\n    if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n    if(mas[ny][nx] && !used[nx][ny]) dfs2(nx, ny, W, H);\n    if(vx < 0 || vx > W || vy < 0 || vy > H) continue;\n    if(mas[ny][nx] || mas[vy][vx]) continue;\n    edge[number[ny][nx]][number[vy][vx]] = 1;\n  }\n}\n\n\nint main() {\n  int W, H, M, Q;\n  vector< Segment > Wall;\n\n  scanf(\"%d %d %d\", &W, &H, &M);\n  for(int i = 0; i < M; i++){ \n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    if(x1 > x2) swap(x1, x2);\n    if(y1 > y2) swap(y1, y2);\n    Wall.push_back(Segment(x1 << 1, y1 << 1, x2 << 1, y2 << 1));\n  }\n  Wall.push_back(Segment(0 << 1, 0 << 1, 0 << 1, H << 1));\n  Wall.push_back(Segment(0 << 1, 0 << 1, W << 1, 0 << 1));\n  Wall.push_back(Segment(0 << 1, H << 1, W << 1, H << 1));\n  Wall.push_back(Segment(W << 1, 0 << 1, W << 1, H << 1));\n\n  W <<= 1, H <<= 1;\n  vector< int > numX, numY;\n  for(int i = 0; i < Wall.size(); i++) {\n    for(int j = -1; j <= 1; j++) {\n      if(0 <= Wall[i].x1 + j && Wall[i].x1 + j <= W) numX.push_back(Wall[i].x1 + j);\n      if(0 <= Wall[i].x2 + j && Wall[i].x2 + j <= W) numX.push_back(Wall[i].x2 + j);\n      if(0 <= Wall[i].y1 + j && Wall[i].y1 + j <= H) numY.push_back(Wall[i].y1 + j);\n      if(0 <= Wall[i].y2 + j && Wall[i].y2 + j <= H) numY.push_back(Wall[i].y2 + j);\n    }\n  }\n  sort(numX.begin(), numX.end());\n  numX.erase(unique(numX.begin(), numX.end()), numX.end());\n  sort(numY.begin(), numY.end());\n  numY.erase(unique(numY.begin(), numY.end()), numY.end());\n\n  for(int i = 0; i < Wall.size(); i++) {\n    Segment& p = Wall[i];\n    p.x1 = lower_bound(numX.begin(), numX.end(), p.x1) - numX.begin();\n    p.x2 = lower_bound(numX.begin(), numX.end(), p.x2) - numX.begin();\n    p.y1 = lower_bound(numY.begin(), numY.end(), p.y1) - numY.begin();\n    p.y2 = lower_bound(numY.begin(), numY.end(), p.y2) - numY.begin();\n    if(p.x1 == p.x2) {\n      for(int j = p.y1; j < p.y2; j++) {\n        mas[j][p.x1] = true;\n      }\n    } else {\n      for(int j = p.x1; j < p.x2; j++) {\n        mas[p.y1][j] = true;\n      }\n    }\n  }\n\n  H = numY.size() - 1; W = numX.size() - 1;\n  int size = 0;\n  fill_n(*number, 1000 * 1000, -1);\n  for(int i = 1; i < H; i++) {\n    for(int j = 1; j < W; j++) {\n      if(!mas[i][j] && number[i][j] == -1) dfs(j, i, size++);\n    }\n  }\n  fill_n(*edge, 400 * 400, INF);\n  for(int i = 0; i < Wall.size(); i++) {\n    if(!used[Wall[i].y1][Wall[i].x1]) {\n      dfs2(Wall[i].x1, Wall[i].y1, W, H);\n    }\n  }\n\n  for(int k = 0; k < size; k++) {\n    edge[k][k] = 0;\n    for(int i = 0; i < size; i++) {\n      for(int j = 0; j < size; j++) {\n        edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n\n  scanf(\"%d\", &Q);\n  while(Q--){ \n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    int sx = upper_bound(numX.begin(), numX.end(), a << 1) - numX.begin();\n    int sy = upper_bound(numY.begin(), numY.end(), b << 1) - numY.begin();\n    int gx = upper_bound(numX.begin(), numX.end(), c << 1) - numX.begin();\n    int gy = upper_bound(numY.begin(), numY.end(), d << 1) - numY.begin();\n    printf(\"%d\\n\", edge[number[sy][sx]][number[gy][gx]]);\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 210\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    rep(i,4) {\n      int nx = x + dx[i], ny = y + dy[i];\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 3;\n\t\tpy[i] *= 3;\n\t\tqx[i] *= 3;\n\t\tqy[i] *= 3;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 3;\n\t\tpy[i] *= 3;\n\t\tqx[i] *= 3;\n\t\tqy[i] *= 3;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 3;\n\t\tsy[i] *= 3;\n\t\tgx[i] *= 3;\n\t\tgy[i] *= 3;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]),\n\t  g[a[ry][rx]].push_back(a[y][x]);\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nqueue<P> que;\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tif(y<500&&x<500&&y>=0&&x>=0){\n\t  masu[y][x]=-1;\n\t}\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "// 座標圧縮 + ダイクストラ\n\n#include<vector>\n#include<unordered_map>\n#include<algorithm>\n\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::unordered_map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = false, WALL = true};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nint Dijkstra(const vector<vector<bool>>& field, int sx, int sy, int gx, int gy) {\n  const int h = field.size();\n  const int w = field.front().size();\n\n  typedef tuple<int, int, int> Node;\n\n  vector<vector<bool>> visited(h, vector<bool>(w, false));\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, sy, sx);\n  while(!q.empty()) {\n    int cost, y, x;\n    tie(cost, y, x) = q.top();\n    q.pop();\n    if(y == gy && x == gx) return cost;\n    if(visited[y][x]) continue;\n    visited[y][x] = true;\n//     cout << cost << \", \" << y << \", \" << x << endl;\n    for(int dy: {-1, 0, 1}) for(int dx: {-1, 0, 1}) {\n      int ncost = cost;\n      int ny = y + dy;\n      int nx = x + dx;\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(field[ny][nx] == WALL) {\n        ny += dy;\n        nx += dx;\n        ++ncost;\n      }\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(!visited[ny][nx]) q.emplace(ncost, ny, nx);\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n  vector<vector<bool>> field(y.size(), vector<bool>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n//   for(auto i: field) {\n//     for(auto j: i)cout<<\" \"<<j;\n//     cout<<endl;\n//   }\n\n  for(const auto& q: query) {\n    cout << Dijkstra(field, x.index(q.sx), y.index(q.sy), x.index(q.gx), y.index(q.gy)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nvector<int>G[160001];\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair< int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\t//ds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\t//ds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\t//if(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n       // g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\t//sort(g[i].begin(),g[i].end());\n       // g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      s=masu[syp][sxp];\n      g=masu[gyp][gxp];\n      for(int j=1;j<=now;j++){\n\tmincost[j]=(1LL<<60);\n      }\n      priority_queue<P,vector<P>,greater<P> >que;\n      que.push(P(0,s));\n      while(!que.empty()){\n\tlong long nowc=que.top().first;\n\tlong long nowp=que.top().second;\n\tque.pop();\n\tif(nowp==g){\n\t  cout<<nowc<<endl;\n\t  break;\n\t}\n\tfor(int j=0;j<node[nowp].size();j++){\n\t  long long nextp=node[nowp][j];\n\t  if(mincost[nextp]>nowc+1){\n\t    mincost[nextp]=nowc+1;\n\t    que.push(P(nowc+1,nextp));\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < W - 1 && y < H - 1;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\tif (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[1001][1001];\n\nint dp[1001][1001];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",dp[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\treturn dp[gx][gy];\n}\n\nint sx[101],sy[101],gx[101],gy[101];\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<fstream>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nbool FF[1000][1000];\nint ccccc, ddddd;\nvoid DFS(int XS, int YS,int XG,int YG){\n\tpriority_queue <pair<int, int> >que;\n\tque.push(make_pair(XS, YS));\n\tint res = 0;\n\twhile (true){\n\t\tif (res == 0){\n\t\t\tMAP[XS][YS] = 0;\n\t\t\tque.push(make_pair(XS, YS));\n\t\t}\n\t\twhile (!que.empty()){\n\t\t\tpair<int, int> P = que.top(); que.pop();\n\t\t\tif (FF[P.first][P.second])continue;\n\t\t\tFF[P.first][P.second] = true;\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tif (P.first + DX[i] >= 0 && P.first + DX[i] <= 2 * (ccccc - 1) && P.second + DY[i] >= 0 && P.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\t\tif (MAP[P.first + DX[i]][P.second + DY[i]] != -1){\n\t\t\t\t\t\tif (!FF[P.first+DX[i]][P.second+DY[i]]){\n\t\t\t\t\t\t\tMAP[P.first+DX[i]][P.second+DY[i]] = res;\n\t\t\t\t\t\t\tque.push(make_pair(P.first+DX[i],P.second+DY[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (MAP[XG][YG] == res)return;\n\t\tfor (int i = 0; i <= 2 * (ccccc - 1); i++){\n\t\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j++){\n\t\t\t\tif (MAP[i][j] != res)continue;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tif (i + DX[k] >= 0 && i+ DX[k] <= 2 * (ccccc - 1) && j + DY[k] >= 0 && j + DY[k] <= 2 * (ddddd - 1)){\n\t\t\t\t\t\tif (MAP[i + DX[k]][j + DY[k]] == -1){\n\t\t\t\t\t\t\tif (!FF[i + 2 * DX[k]][j + 2 * DY[k]]){\n\t\t\t\t\t\t\t\tque.push(make_pair(i + 2 * DX[k], j + 2 * DY[k]));\n\t\t\t\t\t\t\t\tMAP[i + 2 * DX[k]][j + 2 * DY[k]] = res + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres++;\n\t\t\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j++){\n\t\t\tfor (int k = 0; k <= 2 * (ddddd - 1); k++){\n\t\t\t\tFF[j][k] = false;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY,GGX,GGY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[605][605];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[1001][1001]={0};\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int i=0;i<4;i++){\n\t    long long nx=nowx+dx[i];\n\t    long long ny=nowy+dy[i];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  vector<long long> node[1005];\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[1005];\n  cin>>e;\n  for(int i=0;i<e;i++){\n    long long s,g;\n    long long sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    sx*=2;\n    sx++;\n    sy*=2;\n    sy++;\n    gx*=2;\n    gx++;\n    gy*=2;\n    gy++;\n    long long sxp,syp,gxp,gyp;\n    sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n    syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n    gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n    gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n    s=masu[syp][sxp];\n    g=masu[gyp][gxp];\n    for(int j=1;j<=now;j++){\n      mincost[j]=(1LL<<60);\n    }\n    priority_queue<P,vector<P>,greater<P> >que;\n    que.push(P(0,s));\n    while(!que.empty()){\n      long long nowc=que.top().first;\n      long long nowp=que.top().second;\n      que.pop();\n      if(nowp==g){\n\tcout<<nowc<<endl;\n\tbreak;\n      }\n      for(int j=0;j<node[nowp].size();j++){\n\tlong long nextp=node[nowp][j];\n\tif(mincost[nextp]>nowc+1){\n\t  mincost[nextp]=nowc+1;\n\t  que.push(P(nowc+1,nextp));\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nconst int dy[] = {0, 1, -1, 0};\nconst int dx[] = {1, 0, 0, -1};\n\nint main()\n{\n    int w, h, m;\n    cin >> w >> h >> m;\n\n    vector<int> px(2*m), py(2*m);\n    map<int, int> mx = { make_pair(0, -1), make_pair(1, -1), make_pair(2*w, -1) };\n    map<int, int> my = { make_pair(0, -1), make_pair(1, -1), make_pair(2*h, -1) };\n    for(int i=0; i<2*m; ++i){\n        cin >> px[i] >> py[i];\n        for(int j=0; j<2; ++j){\n            if(px[i] * 2 + j <= 2 * w)\n                mx[px[i] * 2 + j];\n            if(py[i] * 2 + j <= 2 * h)\n                my[py[i] * 2 + j];\n        }\n    }\n\n    w = 0;\n    h = 0;\n    for(auto& p : mx){\n        p.second = w;\n        ++ w;\n    }\n    for(auto& p : my){\n        p.second = h;\n        ++ h;\n    }\n\n    vector<vector<bool> > grid(h, vector<bool>(w, false));\n    for(int y=0; y<h; ++y)\n        grid[y][0] = grid[y][w-1] = true;\n    for(int x=0; x<w; ++x)\n        grid[0][x] = grid[h-1][x] = true;\n    for(int i=0; i<m; ++i){\n        if(py[2*i] == py[2*i+1]){\n            int y  = my[py[2*i]*2];\n            int x1 = mx[px[2*i]*2];\n            int x2 = mx[px[2*i+1]*2];\n            if(x1 > x2)\n                swap(x1, x2);\n            for(int x=x1; x<=x2; ++x)\n                grid[y][x] = true;\n        }\n        else{\n            int x  = mx[px[2*i]*2];\n            int y1 = my[py[2*i]*2];\n            int y2 = my[py[2*i+1]*2];\n            if(y1 > y2)\n                swap(y1, y2);\n            for(int y=y1; y<=y2; ++y)\n                grid[y][x] = true;\n        }\n    }\n\n    int q;\n    cin >> q;\n    while(--q >= 0){\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        sx = (--mx.upper_bound(sx * 2))->second;\n        sy = (--my.upper_bound(sy * 2))->second;\n        gx = (--mx.upper_bound(gx * 2))->second;\n        gy = (--my.upper_bound(gy * 2))->second;\n\n        deque<pair<int, int> > dq;\n        vector<vector<bool> > check(h, vector<bool>(w, false));\n        dq.push_back(make_pair(sy, sx));\n        check[sy][sx] = true;\n        int n = dq.size();\n        int ret = 0;\n        for(;;){\n            int y = dq.front().first;\n            int x = dq.front().second;\n            dq.pop_front();\n            -- n;\n            if(n < 0){\n                n = dq.size();\n                ++ ret;\n            }\n            if(y == gy && x == gx){\n                cout << ret << endl;\n                break;\n            }\n\n            for(int i=0; i<4; ++i){\n                int y2 = y + dy[i];\n                int x2 = x + dx[i];\n                if(y2 == 0 || y2 == h-1 || x2 == 0 || x2 == w-1 || check[y2][x2])\n                    continue;\n\n                check[y2][x2] = true;\n                if(grid[y2][x2]){\n                    dq.push_back(make_pair(y2, x2));\n                }\n                else{\n                    dq.push_front(make_pair(y2, x2));\n                    ++ n;\n                }\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nqueue<P> que;\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      //sx++;\n      sy*=2;\n      //sy++;\n      gx*=2;\n      //gx++;\n      gy*=2;\n      //gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=lower_bound(xv.begin(),xv.end(),sx)-xv.begin();\n      syp=lower_bound(yv.begin(),yv.end(),sy)-yv.begin();\n      gxp=lower_bound(xv.begin(),xv.end(),gx)-xv.begin();\n      gyp=lower_bound(yv.begin(),yv.end(),gy)-yv.begin();\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<50000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tif(y<500&&x<500&&y>=0&&x>=0){\n\t  masu[y][x]=-1;\n\t}\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<=200000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    cout<<0<<endl;\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<=200000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nint px[114];int py[114];int qx[114];int qy[114];\nvector<int> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%d%d%d\",&W,&H,&M);W*=2;H*=2;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;py[i]*=2;qx[i]*=2;qy[i]*=2;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tint sx,sy,gx,gy;\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\tsx*=2;sy*=2;gx*=2;gy*=2;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tvoid set(int arg_row1,int arg_row2,int arg_col1,int arg_col2){\n\t\trow1 = arg_row1;\n\t\trow2 = arg_row2;\n\t\tcol1 = arg_col1;\n\t\tcol2 = arg_col2;\n\t}\n\tint row1,row2,col1,col2;\n};\n\nstruct Data{\n\tbool right_wall,under_wall;\n};\n\nstruct State{\n\tState(int arg_row,int arg_col,int arg_sum_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{ //壁を越えた回数の昇順(PQ)\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\n\tint row,col,sum_cost;\n};\n\nint comp_H,comp_W; //座標圧縮後の高さと幅\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint min_cost[500][500];\nInfo wall[100],query[100];\nData table[500][500];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 2 && row <= comp_H-2 && col >= 2 && col <= comp_W-2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint W,H,M;\n\tscanf(\"%d %d %d\",&W,&H,&M);\n\n\tvector<int> ROW,COL;\n\n\t/*★外枠に注意!!★*/\n\tROW.push_back(0);\n\tROW.push_back(H);\n\tROW.push_back(-BIG_NUM);\n\tROW.push_back(BIG_NUM);\n\n\tCOL.push_back(0);\n\tCOL.push_back(W);\n\tCOL.push_back(-BIG_NUM);\n\tCOL.push_back(BIG_NUM);\n\n\tint row1,row2,col1,col2;\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d %d %d %d\",&col1,&row1,&col2,&row2);\n\n\t\tif(row1 > row2)swap(row1,row2);\n\t\tif(col1 > col2)swap(col1,col2);\n\n\t\twall[i].set(row1,row2,col1,col2);\n\n\t\tROW.push_back(row1);\n\t\tROW.push_back(row2);\n\t\tCOL.push_back(col1);\n\t\tCOL.push_back(col2);\n\t}\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tscanf(\"%d %d %d %d\",&query[i].col1,&query[i].row1,&query[i].col2,&query[i].row2);\n\n\t\tROW.push_back(query[i].row1);\n\t\tROW.push_back(query[i].row2);\n\t\tCOL.push_back(query[i].col1);\n\t\tCOL.push_back(query[i].col2);\n\t}\n\n\tsort(ROW.begin(),ROW.end());\n\tsort(COL.begin(),COL.end());\n\n\tROW.erase(unique(ROW.begin(),ROW.end()),ROW.end());\n\tCOL.erase(unique(COL.begin(),COL.end()),COL.end());\n\n\tmap<int,int> INDEX_ROW,INDEX_COL;\n\tfor(int i = 0; i < ROW.size(); i++){\n\t\tINDEX_ROW[ROW[i]] = i;\n\t}\n\n\tfor(int i = 0; i < COL.size(); i++){\n\t\tINDEX_COL[COL[i]] = i;\n\t}\n\n\t//座標変換\n\tfor(int i = 0; i < M; i++){\n\t\twall[i].row1 = INDEX_ROW[wall[i].row1];\n\t\twall[i].row2 = INDEX_ROW[wall[i].row2];\n\t\twall[i].col1 = INDEX_COL[wall[i].col1];\n\t\twall[i].col2 = INDEX_COL[wall[i].col2];\n\t}\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tquery[i].row1 = INDEX_ROW[query[i].row1];\n\t\tquery[i].row2 = INDEX_ROW[query[i].row2];\n\t\tquery[i].col1 = INDEX_COL[query[i].col1];\n\t\tquery[i].col2 = INDEX_COL[query[i].col2];\n\t}\n\n\tcomp_H = ROW.size(),comp_W = COL.size();\n\n\tfor(int row = 0; row < comp_H;row++){\n\t\tfor(int col = 0; col < comp_W; col++){\n\t\t\ttable[row][col].right_wall = false;\n\t\t\ttable[row][col].under_wall = false;\n\t\t}\n\t}\n\n\t//外壁の情報を設定\n\n\t//上\n\tfor(int col = 0; col < comp_W; col++){\n\t\ttable[1][col].under_wall = true;\n\t}\n\n\t//左\n\tfor(int row = 0; row < comp_H; row++){\n\t\ttable[row][1].right_wall = true;\n\t}\n\n\t//下\n\tfor(int col = 0; col < comp_W; col++){\n\t\ttable[comp_H-2][col].under_wall = true;\n\t}\n\n\t//右\n\tfor(int row = 0; row < comp_H; row++){\n\t\ttable[row][comp_W-2].right_wall = true;\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(wall[i].row1 == wall[i].row2){ //横線\n\n\t\t\tfor(int col = wall[i].col1+1; col <= wall[i].col2; col++){\n\t\t\t\ttable[wall[i].row1][col].under_wall = true;\n\t\t\t}\n\t\t}else{ //縦線\n\n\t\t\tfor(int row = wall[i].row1+1; row <= wall[i].row2; row++){\n\t\t\t\ttable[row][wall[i].col1].right_wall = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<State> Q;\n\tint adj_row,adj_col,next_cost,add_cost;\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tfor(int row = 0; row < comp_H; row++){\n\t\t\tfor(int col = 0; col < comp_W; col++)min_cost[row][col] = BIG_NUM;\n\t\t}\n\n\t\twhile(!Q.empty())Q.pop();\n\n\t\tmin_cost[query[i].row1][query[i].col1] = 0;\n\t\tQ.push(State(query[i].row1,query[i].col1,0));\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().row == query[i].row2 && Q.top().col == query[i].col2){\n\t\t\t\tprintf(\"%d\\n\",Q.top().sum_cost);\n\t\t\t\tbreak;\n\t\t\t}else if(Q.top().sum_cost > min_cost[Q.top().row][Q.top().col]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tadd_cost = 0;\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0: //上\n\t\t\t\t\t\tif(table[adj_row][adj_col].under_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: //左\n\t\t\t\t\t\tif(table[adj_row][adj_col].right_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: //右\n\t\t\t\t\t\tif(table[Q.top().row][Q.top().col].right_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: //下\n\t\t\t\t\t\tif(table[Q.top().row][Q.top().col].under_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+add_cost;\n\t\t\t\t\tif(min_cost[adj_row][adj_col] > next_cost){\n\t\t\t\t\t\tmin_cost[adj_row][adj_col] = next_cost;\n\t\t\t\t\t\tQ.push(State(adj_row,adj_col,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int W, H, n;\n    cin >> W >> H >> n;\n    vector<int> zy = {0, H}, zx = {0, W};\n    vector<array<int, 3>> A, B;\n    for (int i = 0; i < n; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        zx.emplace_back(x1);\n        zx.emplace_back(x2);\n        zy.emplace_back(y1);\n        zy.emplace_back(y2);\n        if(x1 == x2){\n            B.emplace_back(array<int, 3>{x1, y1, y2});\n        }else {\n            A.emplace_back(array<int, 3>{x1, x2, y1});\n        }\n    }\n\n    sort(zy.begin(), zy.end());\n    zy.erase(unique(zy.begin(), zy.end()), zy.end());\n    sort(zx.begin(), zx.end());\n    zx.erase(unique(zx.begin(), zx.end()), zx.end());\n    auto fx = [&](int x){ return lower_bound(zx.begin(),zx.end(), x) - zx.begin(); };\n    auto fy = [&](int y){ return lower_bound(zy.begin(),zy.end(), y) - zy.begin(); };\n    int h = zy.size(), w = zx.size();\n    vector<vector<pair<int, int>>> P(h), Q(w);\n    for (int i = 0; i < A.size(); ++i) {\n        P[fy(A[i][2])].emplace_back(A[i][0], A[i][1]);\n    }\n    for (int i = 0; i < B.size(); ++i) {\n        Q[fx(B[i][0])].emplace_back(B[i][1], B[i][2]);\n    }\n    auto f = [&](int i, int j){ return i*(w-1)+j; };\n    vector<vector<pair<int, int>>> G((h-1)*(w-1));\n    vector<int> S(w+1);\n    for (int i = 1; i < h-1; ++i) {\n        fill(S.begin(),S.end(), 0);\n        for (auto &&j : P[i]) {\n            S[fx(j.first)]++;\n            S[fx(j.second+1)-1]--;\n        }\n        for (int j = 0; j < w-1; ++j) {\n            G[f(i-1, j)].emplace_back(f(i, j), S[j]);\n            G[f(i, j)].emplace_back(f(i-1, j), S[j]);\n            S[j+1] += S[j];\n        }\n    }\n    S.resize(h+1);\n    for (int i = 1; i < w-1; ++i) {\n        fill(S.begin(),S.end(), 0);\n        for (auto &&j : Q[i]) {\n            S[fy(j.first)]++;\n            S[fy(j.second+1)-1]--;\n        }\n        for (int j = 0; j < h-1; ++j) {\n            G[f(j, i-1)].emplace_back(f(j, i), S[j]);\n            G[f(j, i)].emplace_back(f(j, i-1), S[j]);\n            S[j+1] += S[j];\n        }\n    }\n    int q;\n    cin >> q;\n    for (int i = 0; i < q; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        int s = f(fy(y1+1)-1, fx(x1+1)-1), g = f(fy(y2+1)-1, fx(x2+1)-1);\n        vector<int> dist((h-1)*(w-1), INF<int>);\n        dist[s] = 0;\n        deque<int> que;\n        que.emplace_back(s);\n        while(!que.empty()){\n            int x = que.front(); que.pop_front();\n            for (auto &&j : G[x]) {\n                if(j.second == 0){\n                    if(dist[j.first] > dist[x]){\n                        dist[j.first] = dist[x];\n                        que.emplace_front(j.first);\n                    }\n                }else {\n                    if(dist[j.first] > dist[x]+1){\n                        dist[j.first] = dist[x]+1;\n                        que.emplace_back(j.first);\n                    }\n                }\n            }\n        }\n        cout << dist[g] << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<fstream>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nbool FF[1000][1000];\nint ccccc, ddddd;\nvoid DFS(int XS, int YS,int XG,int YG){\n\tpriority_queue <pair<int, int> >que;\n\tque.push(make_pair(XS, YS));\n\tint res = 0;\n\twhile (true){\n\t\tbool F = true;\n\t\tif (res == 0){\n\t\t\tMAP[XS][YS] = 0;\n\t\t\tque.push(make_pair(XS, YS));\n\t\t}\n\t\twhile (!que.empty()){\n\t\t\tF = false;\n\t\t\tpair<int, int> P = que.top(); que.pop();\n\t\t\tif (FF[P.first][P.second])continue;\n\t\t\tFF[P.first][P.second] = true;\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tif (P.first + DX[i] >= 0 && P.first + DX[i] <= 2 * (ccccc - 1) && P.second + DY[i] >= 0 && P.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\t\tif (MAP[P.first + DX[i]][P.second + DY[i]] != -1){\n\t\t\t\t\t\tif (!FF[P.first + DX[i]][P.second + DY[i]]){\n\t\t\t\t\t\t\tMAP[P.first + DX[i]][P.second + DY[i]] = res;\n\t\t\t\t\t\t\tque.push(make_pair(P.first + DX[i], P.second + DY[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 2 * (ccccc - 1); i++){\n\t\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j++){\n\t\t\t\tif (MAP[i][j] != res)continue;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tif (i + DX[k] >= 0 && i + DX[k] <= 2 * (ccccc - 1) && j + DY[k] >= 0 && j + DY[k] <= 2 * (ddddd - 1)){\n\t\t\t\t\t\tif (MAP[i + DX[k]][j + DY[k]] == -1){\n\t\t\t\t\t\t\tif (!FF[i + 2 * DX[k]][j + 2 * DY[k]]){\n\t\t\t\t\t\t\t\tque.push(make_pair(i + 2 * DX[k], j + 2 * DY[k]));\n\t\t\t\t\t\t\t\tMAP[i + 2 * DX[k]][j + 2 * DY[k]] = res + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres++;\n\t\tif (F){\n\t\t\t//printf(\"%d\\n\", res);\n\t\t\tbreak;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j++){\n\t\t\tfor (int k = 0; k <= 2 * (ddddd - 1); k++){\n\t\t\t\tFF[j][k] = false;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY,GGX,GGY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[1001][1001]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[5001][5001]={0};\nvector<long long> node[105005];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i]&&y<h;y++){\n      for(long long x=X1[i];x<=X2[i]&&x<w;x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      masu[ny][nx]=now;\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[105005];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[1001][1001],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i];\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i];\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx]&&used[ry][rx]==0)graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint ddy[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<16;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[1001][1001];\n\nint dp[1001][1001];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",dp[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\treturn dp[gx][gy];\n}\n\nint sx[101],sy[101],gx[101],gy[101];\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\tif(px[i]>0)xid.push_back(px[i]-1);\n\t\tif(qx[i]>0)xid.push_back(qx[i]-1);\n\t\tif(py[i]>0)yid.push_back(py[i]-1);\n\t\tif(qy[i]>0)yid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\tif(px[i]+1<w*2)xid.push_back(px[i]+1);\n\t\tif(qx[i]+1<w*2)xid.push_back(qx[i]+1);\n\t\tif(py[i]+1<h*2)yid.push_back(py[i]+1);\n\t\tif(qy[i]+1<h*2)yid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+3;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+3;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint ddy[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n    //if(ax[i]-ax[i-1]>2){\n      ax[i]=ax[i-1]+2;\n    //}\n    qx[mk(ay[i-1],pp)]=ax[i]-1;\n    mx[pp]=ax[i];//cout<<ax.size()<<endl;\n  }\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n    //if(ay[i]-ay[i-1]>2){\n      ay[i]=ay[i-1]+2;\n    //}\n    qy[mk(ay[i-1],pp)]=ay[i]-1;\n    my[pp]=ay[i];\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){//cout<<x<<endl;\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<16;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    /*for(int ii=0;ii<=h;ii++){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%2d\",a[ii][jj]);cout<<endl;\n    }\n    for(int ii=h;ii>=0;ii--){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%2d\",a[ii][jj]);cout<<endl;\n    }*/\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    /*for(int ii=h;ii>=0;ii--){\n      for(int jj=0;jj<=w;jj++)\n        printf(\"%3d\",a[ii][jj]);cout<<endl;\n    }*/\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      //sx*=2;sy*=2;gx*=2;gy*=2;\n      int so=a[sy][sx],go=a[gy][gx];//cout<<so<<go<<endl;\n      int use[100]={};\n      use[so]=1;\n      //if(so==go)cout<<1111<<endl;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s+1<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < W && y < H;\n}\n\nint conv(int x, int y)\n{\n\treturn x * H + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\t//if (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] < INF) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tif (px[i] > qx[i]) swap(px[i], qx[i]);\n\t\tif (py[i] > qy[i]) swap(py[i], qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\txs.erase(xs.begin());\n\txs.pop_back();\n\tys.erase(ys.begin());\n\tys.pop_back();\n\tW = xs.size();\n\tH = ys.size();\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\t\n\tgrid = vector<vector<int> >(W, vector<int>(H, 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(W * H);\n\tgraph = vector<vector<int> >(W * H, vector<int>());\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (grid[x][y]) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < W; x++){\n\t\tfor (int y = 0; y < H; y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry]\n\t\t\t){\n\t\t\t\tl = uf.find(conv(lx, ly));\n\t\t\t\tr = uf.find(conv(rx, ry));\n\t\t\t\t//if (!uf.same(l, r)){\n\t\t\t\t\tgraph[l].pb(r);\n\t\t\t\t\tgraph[r].pb(l);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < W; i++){\n\t\tfor (int j = 0; j < H; j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nvector<int> edge[15001];\nint fie[2001][2001];\nint dp[15001];\nint cnt;\n\nint sx[101],sy[101],gx[101],gy[101];\n\n\nint bfs(int x,int y){\n\tqueue <P> que;\n\tque.push(P(x,y));\n\tfie[x][y]=cnt;\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tint xx=p.first,yy=p.second;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\tif(fie[nx][ny]==0){\n\t\t\t\tfie[nx][ny]=cnt;\n\t\t\t\tque.push(P(nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint bfs2(int f,int t){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<int> que;\n\tdp[f]=0;\n\tque.push(f);\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tif(v==t)return dp[t];\n\t\tfor(int i=0;i<edge[v].size();i++){\n\t\t\tint next=edge[v][i];\n\t\t\tif(dp[next]==-1){\n\t\t\t\tdp[next]=dp[v]+1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\tif(px[i]>qx[i])swap(px[i],qx[i]);\n\t\tif(py[i]>qy[i])swap(py[i],qy[i]);\n\t\tif(px[i]>0)xid.push_back(px[i]-1);\n\t\tif(qx[i]>0)xid.push_back(qx[i]-1);\n\t\tif(py[i]>0)yid.push_back(py[i]-1);\n\t\tif(qy[i]>0)yid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\tif(px[i]+1<w*2)xid.push_back(px[i]+1);\n\t\tif(qx[i]+1<w*2)xid.push_back(qx[i]+1);\n\t\tif(py[i]+1<h*2)yid.push_back(py[i]+1);\n\t\tif(qy[i]+1<h*2)yid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2;\n\t\tsy[i]=sy[i]*2;\n\t\tgx[i]=gx[i]*2;\n\t\tgy[i]=gy[i]*2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=-1;\n\t\t\tfie[j][qy[i]]=-1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=-1;\n\t\t\tfie[qx[i]][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tif(fie[j][i]==0){\n\t\t\t\tcnt++;\n\t\t\t\tbfs(j,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tif(fie[j][i]>=1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=j+dx[k]*2,ny=i+dy[k]*2;\n\t\t\t\t\tif(nx>=0 && nx<xid.size() && ny>=0 && ny<yid.size()){\n\t\t\t\t\t\tif(fie[nx][ny]>=0 && fie[nx][ny]!=fie[j][i]){\n\t\t\t\t\t\t\tint l;\n\t\t\t\t\t\t\tfor(l=0;l<edge[fie[j][i]].size();l++){\n\t\t\t\t\t\t\t\tif(edge[fie[j][i]][l]==fie[nx][ny])break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l==edge[fie[j][i]].size()){\n\t\t\t\t\t\t\t\tedge[fie[j][i]].push_back(fie[nx][ny]);\n\t\t\t\t\t\t\t\tedge[fie[nx][ny]].push_back(fie[j][i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j+1==xid.size()?'\\n':' ');\t\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs2(fie[sx[i]][sy[i]],fie[gx[i]][gy[i]]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x <= 0 || y <= 0 || x >= grid.size() - 1 || y >= grid.size() - 1) return false;\n\t/*if (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;*/\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\n\nbool ok(int x, int y)\n{\n\tif (x < 0 || y < 0 || x >= grid.size() || y >= grid.size()) return false;\n\tif (xs[x] < 0) return false;\n\tif (ys[y] < 0) return false;\n\tif (xs[x] > 2 * W) return false;\n\tif (ys[y] > 2 * H) return false;\n\treturn true;\n}\n\nint solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (ns) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tprintf(\"%d\\n\", solve(sx[i], sy[i], gx[i], gy[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[1000][1000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n\n    printf(\"%d\\n\",dist[t]);\n}\n\nint main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;xs.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 210\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      if( dx != 0 && dy != 0 ) continue;\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  assert(false);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  rep(i,(int)X.size()) X[i] = X[i];\n  rep(i,(int)Y.size()) Y[i] = Y[i];\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<fstream>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nbool FF[1000][1000];\nint ccccc, ddddd;\nvoid DFS(int XS, int YS,int XG,int YG){\n\tpriority_queue <pair<int, int> >que;\n\tque.push(make_pair(XS, YS));\n\tint res = 0;\n\twhile (true){\n\t\tbool F = true;\n\t\tif (res == 0){\n\t\t\tMAP[XS][YS] = 0;\n\t\t\tque.push(make_pair(XS, YS));\n\t\t}\n\t\twhile (!que.empty()){\n\t\t\tF = false;\n\t\t\tpair<int, int> P = que.top(); que.pop();\n\t\t\tif (FF[P.first][P.second])continue;\n\t\t\tFF[P.first][P.second] = true;\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tif (P.first + DX[i] >= 0 && P.first + DX[i] <= 2 * (ccccc - 1) && P.second + DY[i] >= 0 && P.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\t\tif (MAP[P.first + DX[i]][P.second + DY[i]] != -1){\n\t\t\t\t\t\tif (!FF[P.first + DX[i]][P.second + DY[i]]){\n\t\t\t\t\t\t\tMAP[P.first + DX[i]][P.second + DY[i]] = res;\n\t\t\t\t\t\t\tque.push(make_pair(P.first + DX[i], P.second + DY[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= 2 * (ccccc - 1); i++){\n\t\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j++){\n\t\t\t\tif (MAP[i][j] != res)continue;\n\t\t\t\tfor (int k = 0; k < 4; k++){\n\t\t\t\t\tif (i + DX[k] >= 0 && i + DX[k] <= 2 * (ccccc - 1) && j + DY[k] >= 0 && j + DY[k] <= 2 * (ddddd - 1)){\n\t\t\t\t\t\tif (MAP[i + DX[k]][j + DY[k]] == -1){\n\t\t\t\t\t\t\tif (!FF[i + 2 * DX[k]][j + 2 * DY[k]] && MAP[i + 2 * DX[k]][j + 2 * DY[k]] != -1){\n\t\t\t\t\t\t\t\tque.push(make_pair(i + 2 * DX[k], j + 2 * DY[k]));\n\t\t\t\t\t\t\t\tMAP[i + 2 * DX[k]][j + 2 * DY[k]] = res + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres++;\n\t\tif (F){\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j++){\n\t\t\tfor (int k = 0; k <= 2 * (ddddd - 1); k++){\n\t\t\t\tFF[j][k] = false;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY,GGX,GGY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<deque>\n#include<queue>\nusing namespace std;\nint zx[210];\nint zy[210];\nint px[210];\nint py[210];\nint qx[210];\nint qy[210];\nint wall[210][210];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint bfs[210][210];\nint v[210][210];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d%d%d\",px+i,py+i,qx+i,qy+i);\n\t\tzx[i*2]=px[i];\n\t\tzx[i*2+1]=qx[i];\n\t\tzy[i*2]=py[i];\n\t\tzy[i*2+1]=qy[i];\n\t}\n\tzx[c*2]=0;\n\tzx[c*2+1]=a;\n\tzy[c*2]=0;\n\tzy[c*2+1]=b;\n\tstd::sort(zx,zx+c*2+2);\n\tstd::sort(zy,zy+c*2+2);\n\tint xs=0;\n\tint ys=0;\n\tfor(int i=0;i<c*2+2;i++){\n\t\tif(i==0||zx[i]!=zx[i-1])zx[xs++]=zx[i];\n\t\tif(i==0||zy[i]!=zy[i-1])zy[ys++]=zy[i];\n\t}\n\t\n\tfor(int i=0;i<c;i++){\n\t\tif(px[i]==qx[i]){\n\t\t\tint at=lower_bound(zx,zx+xs,px[i])-zx;\n\t\t\tint L=lower_bound(zy,zy+ys,py[i])-zy;\n\t\t\tint R=lower_bound(zy,zy+ys,qy[i])-zy;\n\t\t\tif(L>R)swap(L,R);\n\t\t\tfor(int j=L;j<R;j++){\n\t\t\t\twall[at][j]|=4;\n\t\t\t\tif(at)wall[at-1][j]|=1;\n\t\t\t}\n\t\t}else{\n\t\t\tint at=lower_bound(zy,zy+ys,py[i])-zy;\n\t\t\tint L=lower_bound(zx,zx+xs,px[i])-zx;\n\t\t\tint R=lower_bound(zx,zx+xs,qx[i])-zx;\n\t\t\tif(L>R)swap(L,R);\n\t\t\tfor(int j=L;j<R;j++){\n\t\t\t\twall[j][at]|=8;\n\t\t\t\tif(at)wall[j][at-1]|=2;\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(int i=0;i<xs;i++){\n\t\tfor(int j=0;j<ys;j++)printf(\"%d \",wall[i][j]);\n\t\tprintf(\"\\n\");\n\t}*/\n\tint d;scanf(\"%d\",&d);\n\twhile(d--){\n\t\tint p,q,r,s;\n\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tint P=lower_bound(zx,zx+xs,p)-zx-1;\n\t\tint Q=lower_bound(zy,zy+ys,q)-zy-1;\n\t\tint R=lower_bound(zx,zx+xs,r)-zx-1;\n\t\tint S=lower_bound(zy,zy+ys,s)-zy-1;\n\t\tdeque<pair<int,int> > D;\n\t\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)\n\t\t\tv[i][j]=0;\n\t\tfor(int i=0;i<210;i++)for(int j=0;j<210;j++)\n\t\t\tbfs[i][j]=999999999;\n\t\tbfs[P][Q]=0;\n\t\tD.push_back(make_pair(P,Q));\n\t\twhile(D.size()){\n\t\t\tint row=D.front().first;\n\t\t\tint col=D.front().second;\n\t\t\tD.pop_front();\n\t\t\tif(v[row][col])continue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(row+dx[i]<0||col+dy[i]<0||\n\t\t\t\t\trow+dx[i]>=xs-1||col+dy[i]>=ys-1)continue;\n\t\t\t\tif(wall[row][col]&(1<<i)){\n\t\t\t\t\tif(!v[row+dx[i]][col+dy[i]]&&bfs[row+dx[i]][col+dy[i]]>bfs[row][col]+1){\n\t\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col]+1;\n\t\t\t\t\t\tD.push_back(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(!v[row+dx[i]][col+dy[i]]&&bfs[row+dx[i]][col+dy[i]]>bfs[row][col]){\n\t\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col];\n\t\t\t\t\t\tD.push_front(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t/*\tfor(int i=0;i<xs;i++){\n\t\t\tfor(int j=0;j<ys;j++)printf(\"%d \",bfs[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t\tprintf(\"%d\\n\",bfs[R][S]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1 << 28)\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct State {\n\tint x, y, cnt;\n\tState (int x, int y, int cnt) : x(x), y(y), cnt(cnt){}\n\tbool operator < (const State &t) const {\n\t\treturn cnt > t.cnt;\n\t}\n};\n\nint w, h, m, q;\nvector<int> ZX, ZY;\nint PX[200], PY[200], QX[200], QY[200];\nint SX[100], SY[100], GX[100], GY[100];\nbool grid[2048][2048];\nint d[2048][2048];\n\nbool ok(int x, int y)\n{\n\treturn x >= 0 && y >= 0 && x < ZX.size() && y < ZY.size();\n}\n\nvoid solve(int sx, int sy, int gx, int gy)\n{\n\tfill((int*)d, (int*)d + 1024 * 1024, INF);\n\tpriority_queue<State> pq;\n\tfor (pq.push(State(sx, sy, 0)); pq.size(); ){\n\t\tState st = pq.top(); pq.pop();\n\t\tif (d[st.x][st.y] < st.cnt) continue;\n\t\tif (st.x == gx && st.y == gy){\n\t\t\tprintf(\"%d\\n\", st.cnt);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//printf(\"%d %d %d\\n\", st.x, st.y, st.cnt);\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = st.x + dx[dir];\n\t\t\tint ny = st.y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[st.x][st.y] && grid[nx][ny]) continue;\n\t\t\tint nc = st.cnt + grid[nx][ny];\n\t\t\tif (d[nx][ny] > nc){\n\t\t\t\tpq.push(State(nx, ny, nc));\n\t\t\t\td[nx][ny] = nc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &w, &h, &m);\n\tZX.push_back(0);\n\tZY.push_back(0);\n\tZX.push_back(w * 2);\n\tZY.push_back(h * 2);\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tPX[i] *= 2;\n\t\tPY[i] *= 2;\n\t\tQX[i] *= 2;\n\t\tQY[i] *= 2;\n\t\tZX.push_back(PX[i]);\n\t\tZY.push_back(PY[i]);\n\t\tZX.push_back(QX[i]);\n\t\tZY.push_back(QY[i]);\n\t\tZX.push_back(PX[i] + 1);\n\t\tZY.push_back(PY[i] + 1);\n\t\tZX.push_back(QX[i] + 1);\n\t\tZY.push_back(QY[i] + 1);\n\t}\n\tPX[m] = 0; PY[m] = 0;\n\tQX[m] = w * 2; QY[m] = 0;\n\tPX[m + 1] = 0; PY[m + 1] = 0;\n\tQX[m + 1] = 0; QY[m + 1] = h * 2;\n\tPX[m + 2] = w * 2; PY[m + 2] = 0;\n\tQX[m + 2] = w * 2; QY[m + 2] = h * 2;\n\tPX[m + 3] = 0; PY[m + 3] = h * 2;\n\tQX[m + 3] = w * 2; QY[m + 3] = h * 2;\n\tm += 4;\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++){\n\t\tscanf(\"%d %d %d %d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tSX[i] *= 2;\n\t\tSY[i] *= 2;\n\t\tGX[i] *= 2;\n\t\tGY[i] *= 2;\n\t\tZX.push_back(SX[i]);\n\t\tZY.push_back(SY[i]);\n\t\tZX.push_back(GX[i]);\n\t\tZY.push_back(GY[i]);\n\t}\n\tsort(ZX.begin(), ZX.end());\n\tZX.erase(lower_bound(ZX.begin(), ZX.end(), w * 2 + 1), upper_bound(ZX.begin(), ZX.end(), w * 2 + 1));\n\tZX.erase(unique(ZX.begin(), ZX.end()), ZX.end());\n\tsort(ZY.begin(), ZY.end());\n\tZY.erase(lower_bound(ZY.begin(), ZY.end(), h * 2 + 1), upper_bound(ZY.begin(), ZY.end(), h * 2 + 1));\n\tZY.erase(unique(ZY.begin(), ZY.end()), ZY.end());\n\tfor (int i = 0; i < m; i++){\n\t\tPX[i] = lower_bound(ZX.begin(), ZX.end(), PX[i]) - ZX.begin();\n\t\tPY[i] = lower_bound(ZY.begin(), ZY.end(), PY[i]) - ZY.begin();\n\t\tQX[i] = lower_bound(ZX.begin(), ZX.end(), QX[i]) - ZX.begin();\n\t\tQY[i] = lower_bound(ZY.begin(), ZY.end(), QY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < q; i++){\n\t\tSX[i] = lower_bound(ZX.begin(), ZX.end(), SX[i]) - ZX.begin();\n\t\tSY[i] = lower_bound(ZY.begin(), ZY.end(), SY[i]) - ZY.begin();\n\t\tGX[i] = lower_bound(ZX.begin(), ZX.end(), GX[i]) - ZX.begin();\n\t\tGY[i] = lower_bound(ZY.begin(), ZY.end(), GY[i]) - ZY.begin();\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tfor (int x = PX[i]; x <= QX[i]; x++){\n\t\t\tfor (int y = PY[i]; y <= QY[i]; y++){\n\t\t\t\tgrid[x][y] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < ZY.size(); i++){\n\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\tprintf(\"%c\", grid[j][i] ? '+' : ' ');\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < q; i++){\n\t\t//printf(\"%d:\\n\", i);\n\t\tsolve(SX[i], SY[i], GX[i], GY[i]);\n\t\t/*for (int i = 0; i < ZY.size(); i++){\n\t\t\tfor (int j = 0; j < ZX.size(); j++){\n\t\t\t\tprintf(\"%d\", d[j][i] - INF ? d[i][j] : 9);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tvoid set(int arg_row1,int arg_row2,int arg_col1,int arg_col2){\n\t\trow1 = arg_row1;\n\t\trow2 = arg_row2;\n\t\tcol1 = arg_col1;\n\t\tcol2 = arg_col2;\n\t}\n\tint row1,row2,col1,col2;\n};\n\nstruct Data{\n\tbool right_wall,under_wall;\n};\n\nstruct State{\n\tState(int arg_row,int arg_col,int arg_sum_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{ //壁を越えた回数の昇順(PQ)\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\n\tint row,col,sum_cost;\n};\n\nint comp_H,comp_W; //座標圧縮後の高さと幅\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint min_cost[500][500];\nInfo wall[100],query[100];\nData table[500][500];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 2 && row <= comp_H-2 && col >= 2 && col <= comp_W-2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint W,H,M;\n\tscanf(\"%d %d %d\",&W,&H,&M);\n\n\tvector<int> ROW,COL;\n\n\t/*★外枠に注意!!★*/\n\tROW.push_back(0);\n\tROW.push_back(H);\n\tROW.push_back(-BIG_NUM);\n\tROW.push_back(BIG_NUM);\n\n\tCOL.push_back(0);\n\tCOL.push_back(W);\n\tCOL.push_back(-BIG_NUM);\n\tCOL.push_back(BIG_NUM);\n\n\tint row1,row2,col1,col2;\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d %d %d %d\",&col1,&row1,&col2,&row2);\n\n\t\tif(row1 > row2)swap(row1,row2);\n\t\tif(col1 > col2)swap(col1,col2);\n\n\t\twall[i].set(row1,row2,col1,col2);\n\n\t\tROW.push_back(row1);\n\t\tROW.push_back(row2);\n\t\tCOL.push_back(col1);\n\t\tCOL.push_back(col2);\n\t}\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tscanf(\"%d %d %d %d\",&query[i].col1,&query[i].row1,&query[i].col2,&query[i].row2);\n\n\t\tROW.push_back(query[i].row1);\n\t\tROW.push_back(query[i].row2);\n\t\tCOL.push_back(query[i].col1);\n\t\tCOL.push_back(query[i].col2);\n\t}\n\n\tsort(ROW.begin(),ROW.end());\n\tsort(COL.begin(),COL.end());\n\n\tROW.erase(unique(ROW.begin(),ROW.end()),ROW.end());\n\tCOL.erase(unique(COL.begin(),COL.end()),COL.end());\n\n\tmap<int,int> INDEX_ROW,INDEX_COL;\n\tfor(int i = 0; i < ROW.size(); i++){\n\t\tINDEX_ROW[ROW[i]] = i;\n\t}\n\n\tfor(int i = 0; i < COL.size(); i++){\n\t\tINDEX_COL[COL[i]] = i;\n\t}\n\n\t//座標変換\n\tfor(int i = 0; i < M; i++){\n\t\twall[i].row1 = INDEX_ROW[wall[i].row1];\n\t\twall[i].row2 = INDEX_ROW[wall[i].row2];\n\t\twall[i].col1 = INDEX_COL[wall[i].col1];\n\t\twall[i].col2 = INDEX_COL[wall[i].col2];\n\t}\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tquery[i].row1 = INDEX_ROW[query[i].row1];\n\t\tquery[i].row2 = INDEX_ROW[query[i].row2];\n\t\tquery[i].col1 = INDEX_COL[query[i].col1];\n\t\tquery[i].col2 = INDEX_COL[query[i].col2];\n\t}\n\n\tcomp_H = ROW.size(),comp_W = COL.size();\n\n\tfor(int row = 0; row < comp_H;row++){\n\t\tfor(int col = 0; col < comp_W; col++){\n\t\t\ttable[row][col].right_wall = false;\n\t\t\ttable[row][col].under_wall = false;\n\t\t}\n\t}\n\n\t//外壁の情報を設定\n\n\t//上\n\tfor(int col = 0; col < comp_W; col++){\n\t\ttable[1][col].under_wall = true;\n\t}\n\n\t//左\n\tfor(int row = 0; row < comp_H; row++){\n\t\ttable[row][1].right_wall = true;\n\t}\n\n\t//下\n\tfor(int col = 0; col < comp_W; col++){\n\t\ttable[comp_H-2][col].under_wall = true;\n\t}\n\n\t//右\n\tfor(int row = 0; row < comp_H; row++){\n\t\ttable[row][comp_W-2].right_wall = true;\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(wall[i].row1 == wall[i].row2){ //横線\n\t\t\tfor(int col = wall[i].col1+1; col <= wall[i].col2; col++){\n\t\t\t\ttable[wall[i].row1][col].under_wall = true;\n\t\t\t}\n\t\t}else{ //縦線\n\t\t\tfor(int row = wall[i].row1+1; row <= wall[i].row2; row++){\n\t\t\t\ttable[row][wall[i].col1-1].right_wall = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<State> Q;\n\tint adj_row,adj_col,next_cost,add_cost;\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tfor(int row = 0; row < comp_H; row++){\n\t\t\tfor(int col = 0; col < comp_W; col++)min_cost[row][col] = BIG_NUM;\n\t\t}\n\n\t\twhile(!Q.empty())Q.pop();\n\n\t\tmin_cost[query[i].row1][query[i].col1] = 0;\n\t\tQ.push(State(query[i].row1,query[i].col1,0));\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().row == query[i].row2 && Q.top().col == query[i].col2){\n\t\t\t\tprintf(\"%d\\n\",Q.top().sum_cost);\n\t\t\t\tbreak;\n\t\t\t}else if(Q.top().sum_cost > min_cost[Q.top().row][Q.top().col]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tadd_cost = 0;\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0: //上\n\t\t\t\t\t\tif(table[adj_row][adj_col].under_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: //左\n\t\t\t\t\t\tif(table[adj_row][adj_col].right_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: //右\n\t\t\t\t\t\tif(table[Q.top().row][Q.top().col].right_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: //下\n\t\t\t\t\t\tif(table[Q.top().row][Q.top().col].under_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+add_cost;\n\t\t\t\t\tif(min_cost[adj_row][adj_col] > next_cost){\n\t\t\t\t\t\tmin_cost[adj_row][adj_col] = next_cost;\n\t\t\t\t\t\tQ.push(State(adj_row,adj_col,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[1001][1001],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx]&&used[ry][rx]==0)graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\nif(a[sy][sx]<0){\nif(a[sy+1][sx]>0)sy++;\nelse if(a[sy][sx+1]>0)sx++;\nelse sy++,sx++;\n}\nif(a[gy][gx]<0){\nif(a[gy+1][gx]>0)gy++;\nelse if(a[gy][gx+1]<0)gxx++;\nelse gy++,gx++;\n}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,0,0,-2};\nint ddy[]={0,2,-2,0};\nvector<int>g[405];\nbool used[1005][1005];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n   // fullfill(490,490,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=WW*HH+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\twhile(!que.empty()){\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<s[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t\tif(W>=1000000000&&i==10)return 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n\tbool operator<(const data& d1)const{\n\t\treturn d1.c<c;\n\t}\n};\nint w,h,m;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[801][801];\n\nint q;\nint dp[801][801];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tpriority_queue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata pp=que.top();\n\t\tque.pop();\n\t\tint x=pp.x,y=pp.y,c=pp.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]>dp[x][y] || dp[nx][ny]==-1)){\n\t\t\t\tdp[nx][ny]=dp[x][y];\n\t\t\t\tque.push(data(nx,ny,c));\n\t\t\t}\n\t\t\tif(fie[nx][ny]==1){\n\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]>dp[x][y]+1 || dp[nx][ny]==-1)){\n\t\t\t\t\tdp[nx][ny]=dp[x][y]+1;\n\t\t\t\t\tque.push(data(nx,ny,c+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]*=2;\n\t\tsy[i]*=2;\n\t\tgx[i]*=2;\n\t\tgy[i]*=2;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint cnt;\nint edge[300][300];\n\nbool mas[500][500];\nint number[500][500];\nbool used[500][500];\n\nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint H, W;\n\nvoid dfs2(int y, int x){\n  if(used[y][x]++) return;\n   \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    int sanoy = y - dy[i], sanox = x - dx[i];\n\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(sanoy >= H || sanoy < 0 || sanox >= W || sanox < 0) continue;\n    if(mas[ny][nx] || mas[sanoy][sanox]) continue;\n\n    edge[number[ny][nx]][number[sanoy][sanox]] = 1; //&#65533;&#292;&#676;&#65533;&#65533;\n    edge[number[sanoy][sanox]][number[ny][nx]] = 1;\n  }\n\n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(!mas[ny][nx]) continue;\n    dfs2( ny, nx);\n  }\n\n  return;\n}\nvoid dfs(int y, int x, const int num){\n  if(number[y][x] != -1) return;\n  number[y][x] = num;\n\n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(mas[ny][nx]) continue;\n    if(number[ny][nx] == -1) dfs( ny, nx, num);\n  }\n  return;\n}\n\npair< int, vector< int > > compress( vector< int >& x,const int w){\n  vector< int > xs;\n  for(int i = 0; i < x.size() ; i++ ){\n    for(int d = -1; d <= 1 ; d++ ){\n      int nx = x[i] + d;\n      if(0 <= nx && nx < w) xs.push_back(nx);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i = 0 ; i < x.size() ; i++ ){\n    x[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n  }\n  return make_pair( xs.size(), xs);\n}\n\nint main(){\n  int M;\n\n  cin >> W >> H >> M;\n\n  M += 2;\n  vector< int > x(2 * M), y(2 * M);\n\n  for(int i = 0; i < M - 2; i++){\n    cin >> x[i] >> y[i] >> x[i + M] >> y[i + M];\n\n    x[i] *= 2, y[i] *= 2, x[i + M] *= 2, y[i + M] *= 2;\n  }\n  x[M - 2] = 0, x[2 * M - 2] = 0;\n  y[M - 2] = 0, y[2 * M - 2] = H * 2;\n  x[M - 1] = 0, x[2 * M - 1] = W * 2;\n  y[M - 1] = 0, y[2 * M - 1] = 0;\n\n  pair< int , vector< int > > hoge = compress( x, 2 * W);\n  pair< int , vector< int > > hoge2 = compress( y, 2 * H);\n  W = hoge.first;\n  H = hoge2.first;\n\n  for(int i = 0; i < M; i++){\n    if(y[i] == y[i + M]){\n      for(int j = x[i]; j < x[i + M]; j++){\n        mas[y[i]][j] = true; \n      }\n    } else {\n      for(int j = y[i]; j < y[i + M]; j++){\n        mas[j][x[i]] = true;\n      }\n    }\n  }\n  memset( number, -1, sizeof(number));\n  cnt = 0;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      if(!mas[i][j] && number[i][j] == -1) dfs( i, j, cnt++);\n    }\n  }\n\n  memset( used, false, sizeof(used));\n  fill_n( edge[0], 300 * 300, INF);\n\n  for(int i = 0; i < M; i++){\n    if(!used[y[i]][x[i]]) dfs2( y[i], x[i]);\n  }\n\n  for(int i = 0; i < cnt; i++){\n    edge[i][i] = 0;\n  }\n\n  for(int k = 0; k < cnt; k++){\n    for(int i = 0; i < cnt; i++){\n      if(edge[i][k] == INF) continue;\n      for(int j = 0; j < cnt; j++){\n        if(edge[k][j] == INF) continue;\n        edge[i][j] = min( edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n\n  int q;\n  cin >> q;\n\n  sort( x.begin(), x.end());\n  sort( y.begin(), y.end());\n\n  while(q--){\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n\n    a *= 2, b *= 2, c *= 2, d *= 2;\n    int sx = lower_bound( hoge.second.begin(), hoge.second.end(), a) - hoge.second.begin();\n    int sy = lower_bound( hoge2.second.begin(), hoge2.second.end(), b) - hoge2.second.begin();\n    int gx = lower_bound( hoge.second.begin(), hoge.second.end(), c) - hoge.second.begin();\n    int gy = lower_bound( hoge2.second.begin(), hoge2.second.end(), d) - hoge2.second.begin();\n    cout << edge[number[sy][sx]][number[gy][gx]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint ddx[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint ddy[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<16;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<405&&ry<405)\n      if(a[ry][rx]!=a[y][x])\n        g[a[y][x]].push_back(a[ry][rx]);\n  }\n  for(int i=0;i<4;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<405&&ry<405)\n        if(!a[ry][rx])graphmaker(ry,rx);\n  }\n}\nint main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct data{\n\tint x,y,c;\n\tdata(int xx,int yy,int cc){\n\t\tx=xx;\n\t\ty=yy;\n\t\tc=cc;\n\t}\n};\nint w,h,m,q;\nint px[101],py[101],qx[101],qy[101];\nint sx[101],sy[101],gx[101],gy[101];\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvector<int> xid,yid;\nint fie[901][901];\n\nint dp[901][901];\n\nint bfs(int sx,int sy,int gx,int gy){\n\tmemset(dp,-1,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx,sy,0));\n\tdp[sx][sy]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tint x=d.x,y=d.y,c=d.c;\n\t\tif(dp[x][y]<c)continue;\n\t\tqueue<P> que2;\n\t\tqueue<P> que3;\n\t\tque2.push(P(x,y));\n\t\twhile(que2.size()){\n\t\t\tP p=que2.front();\n\t\t\tque2.pop();\n\t\t\tint xx=p.first,yy=p.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=xx+dx[i],ny=yy+dy[i];\n\t\t\t\tif(fie[nx][ny]==-1)continue;\n\t\t\t\tif(fie[nx][ny]==0 && (dp[nx][ny]==-1 || dp[nx][ny]>c)){\n\t\t\t\t\tdp[nx][ny]=c;\n\t\t\t\t\tque2.push(P(nx,ny));\n\t\t\t\t}\n\t\t\t\tif(fie[nx][ny]==1){\n\t\t\t\t\tnx+=dx[i];\n\t\t\t\t\tny+=dy[i];\n\t\t\t\t\tif(fie[nx][ny]==0 && dp[nx][ny]==-1){\n\t\t\t\t\t\tque3.push(P(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que3.size()){\n\t\t\tP p=que3.front();\n\t\t\tque3.pop();\n\t\t\tif(dp[p.first][p.second]==-1){\n\t\t\t\tdp[p.first][p.second]=c+1;\n\t\t\t\tque.push(data(p.first,p.second,c+1));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",dp[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\treturn dp[gx][gy];\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&w,&h,&m);\n\txid.push_back(0);\n\txid.push_back(w*2);\n\tyid.push_back(0);\n\tyid.push_back(h*2);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d%d\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=2;\n\t\tpy[i]*=2;\n\t\tqx[i]*=2;\n\t\tqy[i]*=2;\n\t\txid.push_back(px[i]-1);\n\t\txid.push_back(qx[i]-1);\n\t\tyid.push_back(py[i]-1);\n\t\tyid.push_back(qy[i]-1);\n\t\txid.push_back(px[i]);\n\t\txid.push_back(qx[i]);\n\t\tyid.push_back(py[i]);\n\t\tyid.push_back(qy[i]);\n\t\txid.push_back(px[i]+1);\n\t\txid.push_back(qx[i]+1);\n\t\tyid.push_back(py[i]+1);\n\t\tyid.push_back(qy[i]+1);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%d%d%d\",&sx[i],&sy[i],&gx[i],&gy[i]);\n\t\tsx[i]=sx[i]*2-1;\n\t\tsy[i]=sy[i]*2-1;\n\t\tgx[i]=gx[i]*2-1;\n\t\tgy[i]=gy[i]*2-1;\n\t\txid.push_back(sx[i]);\n\t\txid.push_back(gx[i]);\n\t\tyid.push_back(sy[i]);\n\t\tyid.push_back(gy[i]);\n\t}\n\tsort(xid.begin(),xid.end());\n\txid.erase(unique(xid.begin(),xid.end()),xid.end());\n\tsort(yid.begin(),yid.end());\n\tyid.erase(unique(yid.begin(),yid.end()),yid.end());\n\tfor(int i=0;i<m;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),px[i])-xid.begin();\n\t\tpx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),qx[i])-xid.begin();\n\t\tqx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),py[i])-yid.begin();\n\t\tpy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),qy[i])-yid.begin();\n\t\tqy[i]=num;\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint num=lower_bound(xid.begin(),xid.end(),sx[i])-xid.begin();\n\t\tsx[i]=num;\n\t\tnum=lower_bound(xid.begin(),xid.end(),gx[i])-xid.begin();\n\t\tgx[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),sy[i])-yid.begin();\n\t\tsy[i]=num;\n\t\tnum=lower_bound(yid.begin(),yid.end(),gy[i])-yid.begin();\n\t\tgy[i]=num;\n\t}\n\tmemset(fie,-1,sizeof(fie));\n\tfor(int i=1;i<xid.size()-1;i++){\n\t\tfor(int j=1;j<yid.size()-1;j++){\n\t\t\tfie[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=px[i];j<=qx[i];j++){\n\t\t\tfie[j][py[i]]=1;\n\t\t\tfie[j][qy[i]]=1;\n\t\t}\n\t\tfor(int j=py[i];j<=qy[i];j++){\n\t\t\tfie[px[i]][j]=1;\n\t\t\tfie[qx[i]][j]=1;\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<yid.size();i++){\n\t\tfor(int j=0;j<xid.size();j++){\n\t\t\tprintf(\"%2d%c\",fie[j][i],j==xid.size()-1?'\\n':' ');\n\t\t}\n\t}\n\t*/\n\tfor(int i=0;i<q;i++)printf(\"%d\\n\",bfs(sx[i],sy[i],gx[i],gy[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n       // g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\t//sort(g[i].begin(),g[i].end());\n       // g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tif(ax>=bx)swap(ax,bx);\n\t\tif(ay>=by)swap(ay,by);\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0&&g1!=g2){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<long long,long long>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[501][501],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[505];\nbool used[505][505];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<4;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(500,500,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<=gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<=gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[200]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n\t  while(!q.empty())q.pop();\n          break;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }//L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nint ccccc, ddddd;\nvoid DFS(int XS,int YS){\n\tpriority_queue<pair<int, pair<int, int> > >que;\n\tque.push(make_pair(0, make_pair(XS, YS)));\n\twhile (!que.empty()){\n\t\tpair<int, pair<int, int> >P = que.top(); que.pop();\n\t\tif (P.first > MAP[P.second.first][P.second.second])continue;\n\t\tMAP[P.second.first][P.second.second] = P.first;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (P.second.first + DX[i] >= 0 && P.second.first + DX[i] <= 2 * (ccccc - 1) && P.second.second + DY[i] >= 0 && P.second.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\tif (MAP[P.second.first + DX[i]][P.second.second + DY[i]] ==-1){\n\t\t\t\t\tif (MAP[P.second.first + 2 * DX[i]][P.second.second + 2 * DY[i]] > P.first + 1){\n\t\t\t\t\t\tMAP[P.second.first + 2 * DX[i]][P.second.second + 2 * DY[i]] = P.first + 1;\n\t\t\t\t\t\tque.push(make_pair(P.first + 1, make_pair(P.second.first + 2 * DX[i], P.second.second + 2 * DY[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (MAP[P.second.first + DX[i]][P.second.second + DY[i]] > P.first){\n\t\t\t\t\t\tMAP[P.second.first][P.second.second] = P.first;\n\t\t\t\t\t\tque.push(make_pair(P.first, make_pair(P.second.first + DX[i], P.second.second + DY[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tvoid set(int arg_row1,int arg_row2,int arg_col1,int arg_col2){\n\t\trow1 = arg_row1;\n\t\trow2 = arg_row2;\n\t\tcol1 = arg_col1;\n\t\tcol2 = arg_col2;\n\t}\n\tint row1,row2,col1,col2;\n};\n\nstruct Data{\n\tbool right_wall,under_wall;\n};\n\nstruct State{\n\tState(int arg_row,int arg_col,int arg_sum_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{ //壁を越えた回数の昇順(PQ)\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\n\tint row,col,sum_cost;\n};\n\nint comp_H,comp_W; //座標圧縮後の高さと幅\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nint min_cost[500][500];\nInfo wall[100],query[100];\nData table[500][500];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 2 && row <= comp_H-2 && col >= 2 && col <= comp_W-2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint W,H,M;\n\tscanf(\"%d %d %d\",&W,&H,&M);\n\n\tvector<int> ROW,COL;\n\n\t/*★外枠に注意!!★*/\n\tROW.push_back(0);\n\tROW.push_back(H);\n\tROW.push_back(-BIG_NUM);\n\tROW.push_back(BIG_NUM);\n\n\tCOL.push_back(0);\n\tCOL.push_back(W);\n\tCOL.push_back(-BIG_NUM);\n\tCOL.push_back(BIG_NUM);\n\n\tint row1,row2,col1,col2;\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d %d %d %d\",&col1,&row1,&col2,&row2);\n\n\t\tif(row1 > row2)swap(row1,row2);\n\t\tif(col1 > col2)swap(col1,col2);\n\n\t\twall[i].set(row1,row2,col1,col2);\n\n\t\tROW.push_back(row1);\n\t\tROW.push_back(row2);\n\t\tCOL.push_back(col1);\n\t\tCOL.push_back(col2);\n\t}\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tscanf(\"%d %d %d %d\",&query[i].col1,&query[i].row1,&query[i].col2,&query[i].row2);\n\n\t\tROW.push_back(query[i].row1);\n\t\tROW.push_back(query[i].row2);\n\t\tCOL.push_back(query[i].col1);\n\t\tCOL.push_back(query[i].col2);\n\t}\n\n\tsort(ROW.begin(),ROW.end());\n\tsort(COL.begin(),COL.end());\n\n\tROW.erase(unique(ROW.begin(),ROW.end()),ROW.end());\n\tCOL.erase(unique(COL.begin(),COL.end()),COL.end());\n\n\tmap<int,int> INDEX_ROW,INDEX_COL;\n\tfor(int i = 0; i < ROW.size(); i++){\n\t\tINDEX_ROW[ROW[i]] = i;\n\t}\n\n\tfor(int i = 0; i < COL.size(); i++){\n\t\tINDEX_COL[COL[i]] = i;\n\t}\n\n\t//座標変換\n\tfor(int i = 0; i < M; i++){\n\t\twall[i].row1 = INDEX_ROW[wall[i].row1];\n\t\twall[i].row2 = INDEX_ROW[wall[i].row2];\n\t\twall[i].col1 = INDEX_COL[wall[i].col1];\n\t\twall[i].col2 = INDEX_COL[wall[i].col2];\n\t}\n\n\tprintf(\"\\n\");\n\tfor(int i = 0; i < num_query; i++){\n\t\tquery[i].row1 = INDEX_ROW[query[i].row1];\n\t\tquery[i].row2 = INDEX_ROW[query[i].row2];\n\t\tquery[i].col1 = INDEX_COL[query[i].col1];\n\t\tquery[i].col2 = INDEX_COL[query[i].col2];\n\t}\n\n\tcomp_H = ROW.size(),comp_W = COL.size();\n\n\tfor(int row = 0; row < comp_H;row++){\n\t\tfor(int col = 0; col < comp_W; col++){\n\t\t\ttable[row][col].right_wall = false;\n\t\t\ttable[row][col].under_wall = false;\n\t\t}\n\t}\n\n\t//外壁の情報を設定\n\n\t//上\n\tfor(int col = 0; col < comp_W; col++){\n\t\ttable[1][col].under_wall = true;\n\t}\n\n\t//左\n\tfor(int row = 0; row < comp_H; row++){\n\t\ttable[row][1].right_wall = true;\n\t}\n\n\t//下\n\tfor(int col = 0; col < comp_W; col++){\n\t\ttable[comp_H-2][col].under_wall = true;\n\t}\n\n\t//右\n\tfor(int row = 0; row < comp_H; row++){\n\t\ttable[row][comp_W-2].right_wall = true;\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(wall[i].row1 == wall[i].row2){ //横線\n\n\t\t\tfor(int col = wall[i].col1+1; col <= wall[i].col2; col++){\n\t\t\t\ttable[wall[i].row1][col].under_wall = true;\n\t\t\t}\n\t\t}else{ //縦線\n\n\t\t\tfor(int row = wall[i].row1+1; row <= wall[i].row2; row++){\n\t\t\t\ttable[row][wall[i].col1].right_wall = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<State> Q;\n\tint adj_row,adj_col,next_cost,add_cost;\n\n\tfor(int i = 0; i < num_query; i++){\n\t\tfor(int row = 0; row < comp_H; row++){\n\t\t\tfor(int col = 0; col < comp_W; col++)min_cost[row][col] = BIG_NUM;\n\t\t}\n\n\t\twhile(!Q.empty())Q.pop();\n\n\t\tmin_cost[query[i].row1][query[i].col1] = 0;\n\t\tQ.push(State(query[i].row1,query[i].col1,0));\n\n\t\twhile(!Q.empty()){\n\t\t\tif(Q.top().row == query[i].row2 && Q.top().col == query[i].col2){\n\t\t\t\tprintf(\"%d\\n\",Q.top().sum_cost);\n\t\t\t\tbreak;\n\t\t\t}else if(Q.top().sum_cost > min_cost[Q.top().row][Q.top().col]){\n\t\t\t\tQ.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tadj_row = Q.top().row+diff_row[i];\n\t\t\t\t\tadj_col = Q.top().col+diff_col[i];\n\n\t\t\t\t\tif(!rangeCheck(adj_row,adj_col))continue;\n\n\t\t\t\t\tadd_cost = 0;\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0: //上\n\t\t\t\t\t\tif(table[adj_row][adj_col].under_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: //左\n\t\t\t\t\t\tif(table[adj_row][adj_col].right_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: //右\n\t\t\t\t\t\tif(table[Q.top().row][Q.top().col].right_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: //下\n\t\t\t\t\t\tif(table[Q.top().row][Q.top().col].under_wall)add_cost++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnext_cost = Q.top().sum_cost+add_cost;\n\t\t\t\t\tif(min_cost[adj_row][adj_col] > next_cost){\n\t\t\t\t\t\tmin_cost[adj_row][adj_col] = next_cost;\n\t\t\t\t\t\tQ.push(State(adj_row,adj_col,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tQ.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define lb lower_bound\n#define all(v) (v).begin(), (v).end()\n#define at(a, b) get<b>(a)\ntypedef pair<int, int> PR;\ntypedef tuple<int, int, int> TP;\nconst int INF = 1 << 28;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t}\n};\n\nint W, H, M, Q;\nvector<int> px, py, qx, qy;\nvector<int> sx, sy, gx, gy;\nvector<int> xs, ys;\nvector<vector<int> > grid;\nvector<vector<int> > graph;\n\ninline bool ok(int x, int y)\n{\n\treturn x > 0 && y > 0 && x < xs.size() - 1 && y < ys.size() - 1;\n}\n\ninline int conv(int x, int y)\n{\n\treturn x * ys.size() + y;\n}\n\nint solve(int s, int g)\n{\n\tvector<int> dist(graph.size(), INF);\n\tdist[s] = 0;\n\tqueue<PR> que;\n\tque.push(PR(s, 0));\n\twhile (que.size()){\n\t\tPR pr = que.front(); que.pop();\n\t\tint pos = pr.first;\n\t\tint sum = pr.second;\n\t\tif (dist[pos] < sum) continue;\n\t\tif (pos == g) return sum;\n\t\tfor (int i = 0; i < graph[pos].size(); i++){\n\t\t\tint to = graph[pos][i];\n\t\t\tif (dist[to] <= sum + 1) continue;\n\t\t\tdist[to] = sum + 1;\n\t\t\tque.push(PR(to, sum + 1));\n\t\t}\n\t}\n}\n\n/*int solve(int sx, int sy, int gx, int gy)\n{\n\tvector<vector<int> > dist(grid.size(), vector<int>(grid[0].size(), INF));\n\tdist[sx][sy] = 0;\n\tdeque<TP> dq;\n\tdq.pb(TP(sx, sy, 0));\n\twhile (dq.size()){\n\t\tTP t = dq.front(); dq.pop_front();\n\t\tint x = at(t, 0);\n\t\tint y = at(t, 1);\n\t\tint s = at(t, 2);\n\t\tif (dist[x][y] < s) continue;\n\t\tif (x == gx && y == gy) return s;\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint nx = x + dx[dir];\n\t\t\tint ny = y + dy[dir];\n\t\t\tif (!ok(nx, ny)) continue;\n\t\t\tif (grid[x][y] & grid[nx][ny]) continue;\n\t\t\tint ns = s + grid[nx][ny];\n\t\t\tif (dist[nx][ny] <= ns) continue;\n\t\t\tdist[nx][ny] = ns;\n\t\t\tif (grid[nx][ny]) dq.pb(TP(nx, ny, ns));\n\t\t\telse dq.push_front(TP(nx, ny, ns));\n\t\t}\n\t}\n}*/\n\n\nint main()\n{\n\tscanf(\"%d %d %d\", &W, &H, &M);\n\tpx.resize(M);\n\tpy.resize(M);\n\tqx.resize(M);\n\tqy.resize(M);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(0);\n\t\n\tpx.pb(0);\n\tpy.pb(0);\n\tqx.pb(0);\n\tqy.pb(H);\n\t\n\tpx.pb(W);\n\tpy.pb(0);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tpx.pb(0);\n\tpy.pb(H);\n\tqx.pb(W);\n\tqy.pb(H);\n\t\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\", &px[i], &py[i], &qx[i], &qy[i]);\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tfor (int i = M; i < qx.size(); i++){\n\t\tpx[i] *= 2;\n\t\tpy[i] *= 2;\n\t\tqx[i] *= 2;\n\t\tqy[i] *= 2;\n\t\txs.pb(px[i] - 1);\n\t\txs.pb(px[i]);\n\t\txs.pb(px[i] + 1);\n\t\txs.pb(qx[i] - 1);\n\t\txs.pb(qx[i]);\n\t\txs.pb(qx[i] + 1);\n\t\tys.pb(py[i] - 1);\n\t\tys.pb(py[i]);\n\t\tys.pb(py[i] + 1);\n\t\tys.pb(qy[i] - 1);\n\t\tys.pb(qy[i]);\n\t\tys.pb(qy[i] + 1);\n\t}\n\tM = qx.size();\n\tscanf(\"%d\", &Q);\n\tsx.resize(Q);\n\tsy.resize(Q);\n\tgx.resize(Q);\n\tgy.resize(Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &gx[i], &gy[i]);\n\t\tsx[i] *= 2;\n\t\tsy[i] *= 2;\n\t\tgx[i] *= 2;\n\t\tgy[i] *= 2;\n\t\txs.pb(sx[i] - 1);\n\t\txs.pb(sx[i]);\n\t\txs.pb(sx[i] + 1);\n\t\txs.pb(gx[i] - 1);\n\t\txs.pb(gx[i]);\n\t\txs.pb(gx[i] + 1);\n\t\tys.pb(sy[i] - 1);\n\t\tys.pb(sy[i]);\n\t\tys.pb(sy[i] + 1);\n\t\tys.pb(gy[i] - 1);\n\t\tys.pb(gy[i]);\n\t\tys.pb(gy[i] + 1);\n\t}\n\tsort(all(xs));\n\txs.erase(unique(all(xs)), xs.end());\n\tsort(all(ys));\n\tys.erase(unique(all(ys)), ys.end());\n\tfor (int i = 0; i < M; i++){\n\t\tpx[i] = lb(all(xs), px[i]) - xs.begin();\n\t\tpy[i] = lb(all(ys), py[i]) - ys.begin();\n\t\tqx[i] = lb(all(xs), qx[i]) - xs.begin();\n\t\tqy[i] = lb(all(ys), qy[i]) - ys.begin();\n\t}\n\tfor (int i = 0; i < Q; i++){\n\t\tsx[i] = lb(all(xs), sx[i]) - xs.begin();\n\t\tsy[i] = lb(all(ys), sy[i]) - ys.begin();\n\t\tgx[i] = lb(all(xs), gx[i]) - xs.begin();\n\t\tgy[i] = lb(all(ys), gy[i]) - ys.begin();\n\t}\n\tgrid = vector<vector<int> >(xs.size(), vector<int>(ys.size(), 0));\n\tfor (int i = 0; i < M; i++){\n\t\tfor (int x = px[i]; x <= qx[i]; x++){\n\t\t\tfor (int y = py[i]; y <= qy[i]; y++){\n\t\t\t\tgrid[x][y] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tUnionFind uf(xs.size() * ys.size());\n\tgraph = vector<vector<int> >(xs.size() * ys.size(), vector<int>());\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint nx, ny;\n\t\t\tnx = x + 1;\n\t\t\tny = y;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t\tnx = x;\n\t\t\tny = y + 1;\n\t\t\tif (ok(nx, ny) && !grid[x][y] && !grid[nx][ny]){\n\t\t\t\tuf.unite(conv(x, y), conv(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int x = 0; x < grid.size(); x++){\n\t\tfor (int y = 0; y < grid[x].size(); y++){\n\t\t\tif (!grid[x][y]) continue;\n\t\t\tif (!ok(x, y)) continue;\n\t\t\tint lx, ly, rx, ry, l, r;\n\t\t\tlx = x - 1;\n\t\t\tly = y;\n\t\t\trx = x + 1;\n\t\t\try = y;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y - 1;\n\t\t\trx = x;\n\t\t\try = y + 1;\n\t\t\tl = uf.find(conv(lx, ly));\n\t\t\tr = uf.find(conv(rx, ry));\n\t\t\tif (\n\t\t\tok(lx, ly) && \n\t\t\tok(rx, ry) && \n\t\t\t!grid[lx][ly] && \n\t\t\t!grid[rx][ry] && \n\t\t\t!uf.same(l, r)\n\t\t\t){\n\t\t\t\tgraph[l].pb(r);\n\t\t\t\tgraph[r].pb(l);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*for (int i = 0; i < graph.size(); i++){\n\t\tfor (int v : graph[i]){\n\t\t\tprintf(\"%d \", v);\n\t\t}\n\t\tif (graph[i].size()) puts(\"\");\n\t}*/\n\t\n\t/*for (int i = 0; i < grid.size(); i++){\n\t\tfor (int j = 0; j < grid[i].size(); j++){\n\t\t\tprintf(\"%d\", grid[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n\t\n\tfor (int i = 0; i < Q; i++){\n\t\tint s = uf.find(conv(sx[i], sy[i]));\n\t\tint g = uf.find(conv(gx[i], gy[i]));\n\t\tprintf(\"%d\\n\", solve(s, g));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n \nint cnt;\nint edge[300][300];\n \nbool mas[500][500];\nint number[500][500];\nbool used[500][500];\n \nconst int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\nint H, W;\n \nvoid dfs2(int y, int x){\n  if(used[y][x]++) return;\n    \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    int sanoy = y - dy[i], sanox = x - dx[i];\n \n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(sanoy >= H || sanoy < 0 || sanox >= W || sanox < 0) continue;\n    if(mas[ny][nx] || mas[sanoy][sanox]) continue;\n \n    edge[number[ny][nx]][number[sanoy][sanox]] = 1;\n    edge[number[sanoy][sanox]][number[ny][nx]] = 1;\n  }\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(!mas[ny][nx]) continue;\n    dfs2( ny, nx);\n  }\n \n  return;\n}\nvoid dfs(int y, int x, const int num){\n  if(number[y][x] != -1) return;\n  number[y][x] = num;\n \n  for(int i = 0; i < 4; i++){\n    int ny = y + dy[i], nx = x + dx[i];\n    if(ny >= H || ny < 0 || nx >= W || nx < 0) continue;\n    if(mas[ny][nx]) continue;\n    if(number[ny][nx] == -1) dfs( ny, nx, num);\n  }\n  return;\n}\n \npair< int, vector< int > > compress( vector< int >& x,const int w){\n  vector< int > xs;\n  for(int i = 0; i < x.size() ; i++ ){\n    for(int d = -1; d <= 1 ; d++ ){\n      int nx = x[i] + d;\n      if(0 <= nx && nx < w) xs.push_back(nx);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i = 0 ; i < x.size() ; i++ ){\n    x[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n  }\n  return make_pair( xs.size(), xs);\n}\n \nint main(){\n  int M;\n \n  cin >> W >> H >> M;\n \n  M += 4;\n  vector< int > x(2 * M), y(2 * M);\n \n  for(int i = 0; i < M - 4; i++){\n    cin >> x[i] >> y[i] >> x[i + M] >> y[i + M];\n \n    x[i] *= 2, y[i] *= 2, x[i + M] *= 2, y[i + M] *= 2;\n  }\n\n  x[M - 4] = W * 2, x[2 * M - 4] = W * 2;\n  y[M - 4] = 0, y[2 * M - 4] = H * 2;\n\n  x[M - 3] = 0, x[2 * M - 3] = W * 2;\n  y[M - 3] = H * 2, y[2 * M - 3] = H * 2;\n\n  x[M - 2] = 0, x[2 * M - 2] = 0;\n  y[M - 2] = 0, y[2 * M - 2] = H * 2;\n\n  x[M - 1] = 0, x[2 * M - 1] = W * 2;\n  y[M - 1] = 0, y[2 * M - 1] = 0;\n \n  pair< int , vector< int > > hoge = compress( x, 2 * W);\n  pair< int , vector< int > > hoge2 = compress( y, 2 * H);\n  W = hoge.first;\n  H = hoge2.first;\n \n  for(int i = 0; i < M; i++){\n    if(y[i] == y[i + M]){\n      for(int j = x[i]; j < x[i + M]; j++){\n        mas[y[i]][j] = true;\n      }\n    } else {\n      for(int j = y[i]; j < y[i + M]; j++){\n        mas[j][x[i]] = true;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i < 15; i++){\n    for(int j = 0; j < 15; j++){\n      cout << mas[i][j];\n    }\n    cout << endl;\n  }\n  */\n\n  memset( number, -1, sizeof(number));\n  cnt = 0;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      if(!mas[i][j] && number[i][j] == -1) dfs( i, j, cnt++);\n    }\n  }\n \n  memset( used, false, sizeof(used));\n  fill_n( edge[0], 300 * 300, INF);\n \n  for(int i = 0; i < M; i++){\n    if(!used[y[i]][x[i]]) dfs2( y[i], x[i]);\n  }\n \n  for(int i = 0; i < cnt; i++){\n    edge[i][i] = 0;\n  }\n \n  for(int k = 0; k < cnt; k++){\n    for(int i = 0; i < cnt; i++){\n      if(edge[i][k] == INF) continue;\n      for(int j = 0; j < cnt; j++){\n        if(edge[k][j] == INF) continue;\n        edge[i][j] = min( edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n \n  int q;\n  cin >> q;\n \n  sort( x.begin(), x.end());\n  sort( y.begin(), y.end());\n \n  while(q--){\n    int a, b, c, d;\n    cin >> a >> b >> c >> d;\n \n    a *= 2, b *= 2, c *= 2, d *= 2;\n\n    //ちょっと大きいところ\n    int sx = upper_bound( hoge.second.begin(), hoge.second.end(), a) - hoge.second.begin();\n    int sy = upper_bound( hoge2.second.begin(), hoge2.second.end(), b) - hoge2.second.begin();\n    int gx = upper_bound( hoge.second.begin(), hoge.second.end(), c) - hoge.second.begin();\n    int gy = upper_bound( hoge2.second.begin(), hoge2.second.end(), d) - hoge2.second.begin();\n    cout << edge[number[sy][sx]][number[gy][gx]] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\tsort(g[i].begin(),g[i].end());\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Segment {\n  int x1, y1, x2, y2;\n  Segment(int x1, int y1, int x2, int y2):x1(x1), y1(y1), x2(x2), y2(y2){};\n};\nbool mas[1000][1000], used[1000][1000];\nint number[1000][1000], edge[400][400];\nconst int INF = 1 << 28;\nstatic const int dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\ninline void dfs(int x, int y, const int& num) {\n  if(number[y][x] != -1 || mas[y][x]) return;\n  number[y][x] = num;\n  for(int i = 0; i < 4; i++) dfs(x + dx[i], y + dy[i], num);\n}\n\ninline void dfs2(int x, int y, const int& W, const int& H) {\n  if(used[y][x]++) return;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    int vx = x - dx[i], vy = y - dy[i];\n    if(nx < 0 || nx > W || ny < 0 || ny > H) continue;\n    if(mas[ny][nx]) dfs2(nx, ny, W, H);\n    if(vx < 0 || vx > W || vy < 0 || vy > H) continue;\n    if(mas[ny][nx] || mas[vy][vx]) continue;\n    edge[number[ny][nx]][number[vy][vx]] = 1;\n  }\n}\n\n\nint main() {\n  int W, H, M, Q;\n  vector< Segment > Wall;\n\n  scanf(\"%d %d %d\", &W, &H, &M);\n  for(int i = 0; i < M; i++){ \n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    Wall.push_back(Segment(x1 << 1, y1 << 1, x2 << 1, y2 << 1));\n  }\n  Wall.push_back(Segment(0 << 1, 0 << 1, 0 << 1, H << 1));\n  Wall.push_back(Segment(0 << 1, 0 << 1, W << 1, 0 << 1));\n  Wall.push_back(Segment(0 << 1, H << 1, W << 1, H << 1));\n  Wall.push_back(Segment(W << 1, 0 << 1, W << 1, H << 1));\n\n  W <<= 1, H <<= 1;\n  vector< int > numX, numY;\n  for(int i = 0; i < Wall.size(); i++) {\n    for(int j = -1; j <= 1; j++) {\n      if(0 <= Wall[i].x1 + j && Wall[i].x1 + j <= W) numX.push_back(Wall[i].x1 + j);\n      if(0 <= Wall[i].x2 + j && Wall[i].x2 + j <= W) numX.push_back(Wall[i].x2 + j);\n      if(0 <= Wall[i].y1 + j && Wall[i].y1 + j <= H) numY.push_back(Wall[i].y1 + j);\n      if(0 <= Wall[i].y2 + j && Wall[i].y2 + j <= H) numY.push_back(Wall[i].y2 + j);\n    }\n  }\n  sort(numX.begin(), numX.end());\n  numX.erase(unique(numX.begin(), numX.end()), numX.end());\n  sort(numY.begin(), numY.end());\n  numY.erase(unique(numY.begin(), numY.end()), numY.end());\n\n  for(int i = 0; i < Wall.size(); i++) {\n    Segment& p = Wall[i];\n    p.x1 = lower_bound(numX.begin(), numX.end(), p.x1) - numX.begin();\n    p.x2 = lower_bound(numX.begin(), numX.end(), p.x2) - numX.begin();\n    p.y1 = lower_bound(numY.begin(), numY.end(), p.y1) - numY.begin();\n    p.y2 = lower_bound(numY.begin(), numY.end(), p.y2) - numY.begin();\n    if(p.x1 == p.x2) {\n      for(int j = min(p.y1, p.y2); j < max(p.y1, p.y2); j++) {\n        mas[j][p.x1] = true;\n      }\n    } else {\n      for(int j = min(p.x1, p.x2); j < max(p.x1, p.x2); j++) {\n        mas[p.y1][j] = true;\n      }\n    }\n  }\n\n  H = numY.size() - 1; W = numX.size() - 1;\n  int size = 0;\n  fill_n(*number, 1000 * 1000, -1);\n  for(int i = 1; i < H; i++) {\n    for(int j = 1; j < W; j++) {\n      if(!mas[i][j] && number[i][j] == -1) dfs(j, i, size++);\n    }\n  }\n  fill_n(*edge, 400 * 400, INF);\n  for(int i = 0; i < Wall.size(); i++) {\n    if(!used[Wall[i].y1][Wall[i].x1]) {\n      dfs2(Wall[i].x1, Wall[i].y1, W, H);\n    }\n  }\n\n  for(int k = 0; k < size; k++) {\n    edge[k][k] = 0;\n    for(int i = 0; i < size; i++) {\n      for(int j = 0; j < size; j++) {\n        edge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n      }\n    }\n  }\n\n  scanf(\"%d\", &Q);\n  while(Q--){ \n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    int sx = upper_bound(numX.begin(), numX.end(), a << 1) - numX.begin();\n    int sy = upper_bound(numY.begin(), numY.end(), b << 1) - numY.begin();\n    int gx = upper_bound(numX.begin(), numX.end(), c << 1) - numX.begin();\n    int gy = upper_bound(numY.begin(), numY.end(), d << 1) - numY.begin();\n    printf(\"%d\\n\", edge[number[sy][sx]][number[gy][gx]]);\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <tuple>\n\nusing namespace std;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++) \n#define sz(c) ((int)c.size())\n\ntypedef pair<int, int> Pii;\n\nvoid compress(vector<int>& v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint w, h;\ntypedef pair<Pii, int> P;\nvector<P> e[350][350];\nint cost[350][350];\n\nint solve(Pii s, Pii g) {\n\tmemset(cost, 0x1f, sizeof(cost));\n\tdeque<Pii> deq;\n\tdeq.push_back(s);\n\tcost[s.first][s.second] = 0;\n\n\twhile (!deq.empty()) {\n\t\tPii cur = deq.front(); deq.pop_front();\n\t\tif (cur == g) \n            return cost[g.first][g.second];\n\t\tfor (auto to : e[cur.first][cur.second]) {\n\t\t\tint nf, ns;\n\t\t\ttie(nf, ns) = to.first;\n\t\t\tint ncost = cost[cur.first][cur.second] + to.second;\n\t\t\tif (ncost < cost[nf][ns]) {\n\t\t\t\tcost[nf][ns] = ncost;\n\t\t\t\tif (to.second == 0) {\n\t\t\t\t\tdeq.push_front(Pii(nf, ns));\n\t\t\t\t} else {\n\t\t\t\t\tdeq.push_back(Pii(nf, ns));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main() {\n\tint m; cin >> w >> h >> m;\n\tvector<int> cx, cy;\n\tcx.push_back(0);\n\tcx.push_back(1);\n\tcx.push_back(w - 1);\n\tcx.push_back(w);\n\tcy.push_back(0);\n\tcy.push_back(1);\n\tcy.push_back(h - 1);\n\tcy.push_back(h);\n\tvector < pair<Pii, Pii>> seg;\n\n\tFOR(i, m) {\n\t\tint pa, pb, qa, qb;\n\t\tcin >> pa >> pb >> qa >> qb;\n\t\tseg.emplace_back(Pii(pa, pb), Pii(qa, qb));\n\t\tif (pa > qa || pb > qb) swap(seg.back().first, seg.back().second);\n\t\tif(pa - 1 >= 0) cx.push_back(pa - 1);\n\t\tcx.push_back(pa);\n\t\tif (pa + 1 <= w) cx.push_back(pa + 1);\n\t\tif (qa - 1 >= 0) cx.push_back(qa - 1);\n\t\tcx.push_back(qa);\n\t\tif (qa + 1 <= w) cx.push_back(qa + 1);\n\n\t\tif (pb - 1 >= 0) cy.push_back(pb - 1);\n\t\tcy.push_back(pb);\n\t\tif (pb + 1 <= h) cy.push_back(pb + 1);\n\t\tif (qb - 1 >= 0) cy.push_back(qb - 1);\n\t\tcy.push_back(qb);\n\t\tif (qb + 1 <= h) cy.push_back(qb + 1);\n\t}\n\tcompress(cx); compress(cy);\n\tauto co = [&cx, &cy](Pii xy) {\n\t\tint a = lower_bound(cx.begin(), cx.end(), xy.first) - cx.begin();\n\t\tint b = lower_bound(cy.begin(), cy.end(), xy.second) - cy.begin();\n\t\treturn Pii(a, b);\n\t};\n\ttie(w, h) = co(Pii(w, h));\n\n\tFOR(i, m) {\n\t\tseg[i].first = co(seg[i].first);\n\t\tseg[i].second = co(seg[i].second);\n\t}\n\n\tFOR(x, sz(cx) - 2) FOR(y, sz(cy) - 1) {\n\t\tint nx = x + 1, ny = y;\n\t\tint c = 0;\n\t\tfor (auto& s : seg) {\n\t\t\tif (s.first.first != nx) continue;\n\t\t\tif (s.second.first != nx) continue;\n\t\t\tif (s.first.second <= y && y < s.second.second) c = 1;\n\t\t}\n\t\te[x][y].push_back(P(Pii(nx, ny), c));\n\t\te[nx][ny].push_back(P(Pii(x, y), c));\n\t}\n\tFOR(x, sz(cx) - 1) FOR(y, sz(cy) - 2) {\n\t\tint nx = x , ny = y + 1;\n\t\tint c = 0;\n\t\tfor (auto& s : seg) {\n\t\t\tif (s.first.second != ny) continue;\n\t\t\tif (s.second.second != ny) continue;\n\t\t\tif (s.first.first <= x && x < s.second.first) c = 1;\n\t\t}\n\t\te[x][y].push_back(P(Pii(nx, ny), c));\n\t\te[nx][ny].push_back(P(Pii(x, y), c));\n\t}\n\n\tint q; cin >> q;\n\tFOR(i, q) {\n\t\tint a, b, c, d; cin >> a >> b >> c >> d;\n\t\tPii s(a, b), g(c, d);\n\t\ts = co(s); s.first--; s.second--;\n\t\tg = co(g); g.first--; g.second--;\n\n\t\tint ans = solve(s, g);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 305\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint cost[N][N];\nint w,h,m;\nint sy[N],sx[N],gy[N],gx[N];\n\nset<int> X,Y;\nmap<int,int> rX,rY;\n\nvoid Mark(int idx){\n\n  if(sy[idx]==gy[idx]){\n\n    int yidx=rY[sy[idx]];\n\n    int minx=rX[min(sx[idx],gx[idx])];\n    int maxx=rX[max(sx[idx],gx[idx])];\n    \n    for(int xidx=minx;xidx<=maxx;xidx++) cost[yidx][xidx]=1;\n  }\n\n  if(sx[idx]==gx[idx]){\n\n    int xidx=rX[sx[idx]];\n\n    int miny=rY[min(sy[idx],gy[idx])];\n    int maxy=rY[max(sy[idx],gy[idx])];\n    \n    for(int yidx=miny;yidx<=maxy;yidx++) cost[yidx][xidx]=1;\n    \n  }\n  \n}\n\n\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\n\nint dijkstra(int Sy,int Sx,int Gy,int Gx){\n  \n  priority_queue<P1,vector<P1>,greater<P1> > Q;\n  int d[N][N];\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=(1e9);\n  \n  Q.push(P1(0,P(Sy,Sx)));\n\n  while(!Q.empty()){\n    \n    P1 t=Q.top(); Q.pop();\n\n    int Cost=t.first;\n    int y=t.second.first;\n    int x=t.second.second;\n\n    if(d[y][x]<Cost) continue;\n    if(y==Gy&&x==Gx) return Cost;\n\n    for(int i=0;i<4;i++){\n      \n      int ny=y+dy[i], nx=x+dx[i];\n\n      if(ny==0||nx==0||ny==rY[h]||nx==rX[w]) continue;\n      \n      if(cost[ny][nx]){\n\n\tif(d[ny][nx]>Cost+1){\n\t  d[ny][nx]=Cost+1;\n\t  Q.push(P1(Cost+1,P(ny,nx)));\n\t}\n\t\n      }else{\n\t\n\tif(d[ny][nx]>Cost){\n\t   d[ny][nx]=Cost;\n\t  Q.push(P1(Cost,P(ny,nx)));\n\t}\n\t\n      }\n      \n    }\n\n\n    \n  }\n}\n\nint main(){\n  \n  cin>>w>>h>>m;\n\n  X.insert(0);\n  Y.insert(0);\n  X.insert(w);\n  Y.insert(h);\n  \n  for(int i=0;i<m;i++){\n    \n    cin>>sx[i]>>sy[i]>>gx[i]>>gy[i];\n    \n    X.insert(sx[i]);\n    X.insert(gx[i]);\n    Y.insert(sy[i]);\n    Y.insert(sx[i]);\n    \n  }\n\n  set<int>::iterator ite=X.begin();\n  \n  int p=0;\n  \n  while(ite!=X.end()){\n    \n    rX[(*ite)]=p;\n    \n    p+=2;\n    \n    ite++;\n  }\n\n  ite=Y.begin();\n  p=0;\n  \n  while(ite!=Y.end()){\n\n    rY[(*ite)]=p;\n    \n    p+=2;\n\n    ite++;\n  }\n\n  for(int i=0;i<m;i++) Mark(i);\n  \n  int q;\n\n  cin>>q;\n\n  while(q--){\n    \n    int SX,SY,GX,GY;\n\n    cin>>SX>>SY>>GX>>GY;\n    \n    int cnt=0;\n\n    int stx,sty,gox,goy;\n    \n    ite=X.begin();\n    \n    while(ite!=X.end()){\n      \n      if(SX<(*ite)){\n\tstx=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=X.begin();\n    cnt=0;\n    \n    while(ite!=X.end()){\n      \n      if(GX<(*ite)){\n\tgox=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(SY<(*ite)){\n\tsty=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n\n    ite=Y.begin();\n    cnt=0;\n    \n    while(ite!=Y.end()){\n      \n      if(GY<(*ite)){\n\tgoy=cnt-1;\n\tbreak;\n      }\n      \n      cnt+=2;\n      ite++;\n    }\n    \n    cout<<dijkstra(sty,stx,goy,gox)<<endl;\n        \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 0292.cc: Wall\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 100 + 4;\nconst int MAX_N = MAX_M * 2;\n\nconst int INF = 1 << 30;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, 1, 0, -1};\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef map<int,int> mii;\ntypedef set<pii> spii;\n\nstruct Edge {\n  int x0, y0, x1, y1;\n  Edge() {}\n  Edge(int _x0, int _y0, int _x1, int _y1):\n    x0(_x0), y0(_y0), x1(_x1), y1(_y1) {}\n};\n\n/* global variables */\n\nEdge es[MAX_M];\nvi xs, ys;\nmii xmap, ymap;\nbool wls[MAX_N][MAX_N][4], used[MAX_N][MAX_N];\nint flds[MAX_N][MAX_N], dists[MAX_N];\nvi nbrs[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int w, h, m;\n  cin >> w >> h >> m;\n\n  for (int i = 0; i < m; i++)\n    cin >> es[i].x0 >> es[i].y0 >> es[i].x1 >> es[i].y1;\n  es[m]     = Edge(0, 0, w, 0);\n  es[m + 1] = Edge(0, h, w, h);\n  es[m + 2] = Edge(0, 0, 0, h);\n  es[m + 3] = Edge(w, 0, w, h);\n  m += 4;\n\n  for (int i = 0; i < m; i++) {\n    xs.push_back(es[i].x0);\n    xs.push_back(es[i].x1);\n    ys.push_back(es[i].y0);\n    ys.push_back(es[i].y1);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n  int xn = xs.size(), yn = ys.size();\n  for (int i = 0; i < xn; i++) xmap[xs[i]] = i;\n  for (int i = 0; i < yn; i++) ymap[ys[i]] = i;\n\n  int maxgx = xmap[w], maxgy = ymap[h];\n\n  //printf(\"xs:\");for(int i = 0; i < xn; i++)printf(\" %d\", xs[i]);putchar('\\n');\n  //printf(\"ys:\");for(int i = 0; i < yn; i++)printf(\" %d\", ys[i]);putchar('\\n');\n  //printf(\"maxgx=%d, maxgy=%d\\n\", maxgx, maxgy);\n  \n  for (int i = 0; i < m; i++) {\n    Edge &ei = es[i];\n    int gx0 = xmap[ei.x0], gy0 = ymap[ei.y0];\n    int gx1 = xmap[ei.x1], gy1 = ymap[ei.y1];\n\n    if (gy0 == gy1) {\n      for (int gx = gx0; gx < gx1; gx++) {\n\tif (gy0 > 0) wls[gy0 - 1][gx][1] = true;\n\tif (gy0 < maxgy) wls[gy0][gx][3] = true;\n      }\n    }\n    else {\n      for (int gy = gy0; gy < gy1; gy++) {\n\tif (gx0 > 0) wls[gy][gx0 - 1][0] = true;\n\tif (gx0 < maxgy) wls[gy][gx0][2] = true;\n      }\n    }\n  }\n\n  memset(flds, -1, sizeof(flds));\n  int gn = 0;\n\n  for (int y = 0; y < maxgy; y++)\n    for (int x = 0; x < maxgx; x++)\n      if (flds[y][x] < 0) {\n\tflds[y][x] = gn;\n\tqueue<pii> q;\n\tq.push(pii(x, y));\n\n\twhile (! q.empty()) {\n\t  pii u = q.front(); q.pop();\n\t  int &ux = u.first, &uy = u.second;\n\t  for (int di = 0; di < 4; di++)\n\t    if (! wls[uy][ux][di]) {\n\t      int vx = ux + dxs[di], vy = uy + dys[di];\n\t      if (flds[vy][vx] < 0) {\n\t\tflds[vy][vx] = gn;\n\t\tq.push(pii(vx, vy));\n\t      }\n\t    }\n\t  }\n\tgn++;\n      }\n\n  //printf(\"gn=%d\\n\", gn);\n  //for (int y = 0; y < maxgy; y++) {\n  //for (int x = 0; x < maxgx; x++) printf(\"%d\", flds[y][x]);\n  //putchar('\\n');\n  //}\n\n  spii eset;\n  \n  for (int y = 0; y < maxgy; y++)\n    for (int x = 0; x < maxgx; x++) {\n      int ug = flds[y][x];\n      for (int di = 0; di < 4; di++) {\n\tint vx = x + dxs[di], vy = y + dys[di];\n\tif (vx >= 0 && vx < maxgx && vy >= 0 && vy < maxgy) {\n\t  int vg = flds[vy][vx];\n\t  if (ug != vg && eset.find(pii(ug, vg)) == eset.end()) {\n\t    eset.insert(pii(ug, vg));\n\t    eset.insert(pii(vg, ug));\n\t    nbrs[ug].push_back(vg);\n\t    nbrs[vg].push_back(ug);\n\t  }\n\t}\n      }\n    }\n\n  int q;\n  cin >> q;\n\n  while (q--) {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n\n    int gx0 = lower_bound(xs.begin(), xs.end(), sx) - xs.begin() - 1;\n    int gy0 = lower_bound(ys.begin(), ys.end(), sy) - ys.begin() - 1;\n    int gx1 = lower_bound(xs.begin(), xs.end(), gx) - xs.begin() - 1;\n    int gy1 = lower_bound(ys.begin(), ys.end(), gy) - ys.begin() - 1;\n    //printf(\"(%d,%d)-(%d,%d)\\n\", gx0, gy0, gx1, gy1);\n    \n    int st = flds[gy0][gx0], gl = flds[gy1][gx1];\n    //printf(\"st=%d, gl=%d\\n\", st, gl);\n    \n    for (int i = 0; i < gn; i++) dists[i] = INF;\n    dists[st] = 0;\n\n    queue<int> q;\n    q.push(st);\n\n    while (! q.empty()) {\n      int u = q.front(); q.pop();\n      //printf(\"u=%d(%d)\\n\", u, dists[u]);\n      if (u == gl) break;\n\n      vi &nbru = nbrs[u];\n      int vd = dists[u] + 1;\n      for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\tint &v = *vit;\n\t//printf(\"  v=%d(%d)\\n\", v, dists[v]);\n\tif (dists[v] > vd) {\n\t  dists[v] = vd;\n\t  q.push(v);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\", dists[gl]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[401][401];\nint ds[401][401];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nvector<int>G[160001];\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tint WW=(int)x.size();int HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=1;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j][k]=2*(WW+HH)+1;\n\t\t\t\tds[j][k]=2*(WW+HH)+1;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\tint sx1,sy1,gx1,gy1;\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tpriority_queue<pair<int,P> ,vector<pair<int,P> > ,greater<pair< int,P> > > que;\n\t\tque.push(make_pair(0,P(sx1,sy1)));\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\twhile(!que.empty()){\n\t\t\t\n\t\t\tpair<int,P> p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc.fi][p.sc.sc])continue;\n\t\t\ts[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\tds[p.sc.fi][p.sc.sc]=p.fi;\n\t\t\t\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(p.sc.fi+dx[k]>=0&&p.sc.fi+dx[k]<WW&&p.sc.sc+dy[k]>=0&&p.sc.sc+dy[k]<HH){\n\t\t\t\t\tif(grid[p.sc.fi][p.sc.sc]==1&&grid[p.sc.fi+dx[k]][p.sc.sc+dy[k]]==1)continue;\n\t\t\t\t\tif(p.fi+grid[p.sc.fi][p.sc.sc]<ds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]){\n\t\t\t\t\t\t//n++;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif(n<500){\n\t\t\t\t\t\t\tprintf(\"%d %d %d\\n\",p.sc.fi+dx[k],p.sc.sc+dy[k]p.fi+grid[p.sc.fi][p.sc.sc]);\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tque.push(make_pair(p.fi+grid[p.sc.fi][p.sc.sc],P(p.sc.fi+dx[k],p.sc.sc+dy[k])));\n\t\t\t\t\t\tds[p.sc.fi+dx[k]][p.sc.sc+dy[k]]=p.fi+grid[p.sc.fi][p.sc.sc];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gx1][gy1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint H, W, M;\nint PX[100], PY[100], QX[100], QY[100];\nvector<int>X, Y;\nint XX[1000], YY[1000];\nint MAP[1000][1000];\nint Q;\nint SX[100], SY[100], GX[100], GY[100];\nint DX[4] = { -1, 0, 0, 1 };\nint DY[4] = { 0, -1, 1, 0 };\nint ccccc, ddddd;\nvoid DFS(int XS,int YS){\n\tpriority_queue<pair<int, pair<int, int> > >que;\n\tque.push(make_pair(0, make_pair(XS, YS)));\n\twhile (!que.empty()){\n\t\tpair<int, pair<int, int> >P = que.top(); que.pop();\n\t\tif (P.first > MAP[P.second.first][P.second.second])continue;\n\t\tMAP[P.second.first][P.second.second] = P.first;\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tif (P.second.first + DX[i] >= 0 && P.second.first + DX[i] <= 2 * (ccccc - 1) && P.second.second + DY[i] >= 0 && P.second.second + DY[i] <= 2 * (ddddd - 1)){\n\t\t\t\tif (MAP[P.second.first + DX[i]][P.second.second + DY[i]] ==-1){\n\t\t\t\t\tif (MAP[P.second.first + 2 * DX[i]][P.second.second + 2 * DY[i]] > P.first + 1){\n\t\t\t\t\t\tque.push(make_pair(P.first + 1, make_pair(P.second.first + 2 * DX[i], P.second.second + 2 * DY[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (MAP[P.second.first + DX[i]][P.second.second + DY[i]] > P.first){\n\t\t\t\t\t\tque.push(make_pair(P.first, make_pair(P.second.first + DX[i], P.second.second + DY[i])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\", &W, &H, &M);\n\tfor (int i = 0; i < M; i++){\n\t\tscanf(\"%d%d%d%d\", &PX[i], &PY[i], &QX[i], &QY[i]);\n\t\tX.push_back(PX[i]+1);\n\t\tX.push_back(QX[i]+1);\n\t\tY.push_back(PY[i]+1);\n\t\tY.push_back(QY[i]+1);\n\t}\n\tX.push_back(1); X.push_back(W+1); Y.push_back(1); Y.push_back(H+1);\n\tsort(X.begin(), X.end()); sort(Y.begin(), Y.end());\n\tfor (int i = 0; i < X.size();i++){\n\t\tXX[2 * ccccc] = X[i];\n\t\tccccc++;\n\t\twhile (i+1<X.size()&&X[i] == X[i + 1])i++;\n\t}\n\tfor (int i = 0; i < Y.size(); i++){\n\t\tYY[2 * ddddd] = Y[i];\n\t\tddddd++;\n\t\twhile (i + 1<Y.size() && Y[i] == Y[i + 1])i++;\n\t}\n\tfor (int i = 0; i < M; i++){\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (XX[j] == PX[i]+1)SSX = j;\n\t\t\tif (XX[j] == QX[i]+1)GGX = j;\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j+=2){\n\t\t\tif (YY[j] == PY[i]+1)SSY = j;\n\t\t\tif (YY[j] == QY[i]+1)GGY = j;\n\t\t}\n\t\tfor (int j = SSX; j <= GGX; j++){\n\t\t\tfor (int k = SSY; k <= GGY; k++){\n\t\t\t\tMAP[j][k] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tscanf(\"%d\", &Q);\n\tfor (int i = 0; i < Q; i++){\n\t\tfor (int j = 0; j <= 500; j++){\n\t\t\tfor (int k = 0; k <= 500; k++){\n\t\t\t\tif (MAP[j][k] != -1)MAP[j][k] = 10000000;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\", &SX[i], &SY[i], &GX[i], &GY[i]);\n\t\tint SSX, SSY, GGX, GGY;\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j+=2){\n\t\t\tif (SX[i]+1 <= XX[j]){\n\t\t\t\tSSX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ccccc - 1); j += 2){\n\t\t\tif (GX[i]+1 <= XX[j]){\n\t\t\t\tGGX = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (SY[i]+1 <= YY[j]){\n\t\t\t\tSSY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j <= 2 * (ddddd - 1); j += 2){\n\t\t\tif (GY[i]+1 <= YY[j]){\n\t\t\t\tGGY = j - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tMAP[SSX][SSY] = 0;\n\t\tDFS(SSX,SSY);\n\t\t\n\t\tprintf(\"%d\\n\", MAP[GGX][GGY]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[105],X2[105],Y1[105],Y2[105];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    Y1[i]*=2;\n    Y2[i]*=2;\n  }\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  if(w>500||h>500) return 0;\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tnow++;\n\tqueue<P> que;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      printf(\"%3d\",masu[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  /*\n  for(int i=1;i<=now;i++){\n    for(int j=0;j<node[i].size();j++){\n      cout<<node[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n  long long e;\n  long long mincost[505];\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      long long sx,sy,gx,gy;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sx++;\n      sy*=2;\n      sy++;\n      gx*=2;\n      gx++;\n      gy*=2;\n      gy++;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<=200000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<=W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<=W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  /*\n  for(int i=0;i<xs.size();i++){\n    cout<<xs[i]<<\" \";\n  }\n  cout<<endl;\n  */\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 210\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      if( dx != 0 && dy != 0 ) continue;\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  rep(i,(int)X.size()) X[i] = X[i];\n  rep(i,(int)Y.size()) Y[i] = Y[i];\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define fi first\n#define sc second\ntypedef long long int ll;\nll W,H;\nint M;\nll px[114];ll py[114];ll qx[114];ll qy[114];\nvector<ll> x,y;\nint Q;\nint grid[401][401];\nint s[160001];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint sx1,sy1,gx1,gy1;\nint WW,HH;\nvector<int>G[160001];\nmap<P,int> MAP;\n/*\nint dfs(int x1,int y1){\n\tf[x1][y1]=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x1+dx[k]>=0&&x1+dx[k]<WW&&y1+dy[k]>=0&&y1+dy[k]<HH){\n\t\t\tif(!f[x1+dx[k]][y1+dy[k]])s[x1+dx[k]][y1+dy[k]]=min(s[x1][y1],dfs(x1+dx[k],y1+dy[k]));\n\t\t}\n\t}\n\tif(grid[x1][y1])s[x1][y1]++;\n\tprintf(\"%d %d %d\\n\",x1,y1,s[x1][y1]);\n\treturn s[x1][y1];\n}*/\nint main()\n{\n\tscanf(\"%lld%lld%d\",&W,&H,&M);W*=10;H*=10;\n\tx.pb(0);x.pb(W);\n\ty.pb(0);y.pb(H);\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",&px[i],&py[i],&qx[i],&qy[i]);\n\t\tpx[i]*=10;py[i]*=10;qx[i]*=10;qy[i]*=10;\n\t\tif(px[i]!=0){\n\t\t\tx.pb(px[i]-1);\n\t\t}\n\t\tx.pb(px[i]);\n\t\tif(px[i]!=W){\n\t\t\tx.pb(px[i]+1);\n\t\t}\n\t\t\n\t\tif(qx[i]!=0){\n\t\t\tx.pb(qx[i]-1);\n\t\t}\n\t\tx.pb(qx[i]);\n\t\tif(qx[i]!=W){\n\t\t\tx.pb(qx[i]+1);\n\t\t}\n\t\t\n\t\tif(py[i]!=0){\n\t\t\ty.pb(py[i]-1);\n\t\t}\n\t\ty.pb(py[i]);\n\t\tif(py[i]!=H){\n\t\t\ty.pb(py[i]+1);\n\t\t}\n\t\t\n\t\tif(qy[i]!=0){\n\t\t\ty.pb(qy[i]-1);\n\t\t}\n\t\ty.pb(qy[i]);\n\t\tif(qy[i]!=H){\n\t\t\ty.pb(qy[i]+1);\n\t\t}\n\t\t\n\t}\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\n\tWW=(int)x.size();HH=(int)y.size();\n\tfor(int i=0;i<M;i++){\n\t\tint ax=lower_bound(x.begin(),x.end(),px[i])-x.begin();\n\t\tint bx=lower_bound(x.begin(),x.end(),qx[i])-x.begin();\n\t\tint ay=lower_bound(y.begin(),y.end(),py[i])-y.begin();\n\t\tint by=lower_bound(y.begin(),y.end(),qy[i])-y.begin();\n\t\tfor(int j=ax;j<=bx;j++){\n\t\t\tfor(int k=ay;k<=by;k++){\n\t\t\t\tgrid[j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tint index=1;\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==0){\n\t\t\t\tqueue<P> que;\n\t\t\t\tque.push(P(i,j));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p=que.front();que.pop();\n\t\t\t\t\tif(grid[p.fi][p.sc]==index)continue;\n\t\t\t\t\tgrid[p.fi][p.sc]=index;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tif(p.fi+dx[k]>=0&&p.fi+dx[k]<WW&&p.sc+dy[k]>=0&&p.sc+dy[k]<HH){\n\t\t\t\t\t\t\tif(grid[p.fi+dx[k]][p.sc+dy[k]]==0){\n\t\t\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<HH;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tprintf(\"%d \",grid[j][i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\t*/\n\tfor(int i=0;i<WW;i++){\n\t\tfor(int j=0;j<HH;j++){\n\t\t\tif(grid[i][j]==-1){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dx[k]>=0&&i-dx[k]>=0&&i+dx[k]<WW&&i-dx[k]<WW){\n\t\t\t\t\t\tif(j+dy[k]>=0&&j-dy[k]>=0&&j+dy[k]<HH&&j-dy[k]<HH){\n\t\t\t\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t\t\t\t\tint g1=grid[i+dx[k]][j+dy[k]];\n\t\t\t\t\t\t\tint g2=grid[i-dx[k]][j-dy[k]];\n\t\t\t\t\t\t\tif(g1!=-1&&g2!=-1&&MAP[P(g1,g2)]==0){\n\t\t\t\t\t\t\t\tG[g1-1].pb(g2-1);\n\t\t\t\t\t\t\t\tG[g2-1].pb(g1-1);\n\t\t\t\t\t\t\t\tMAP[P(g1,g2)]=1;\n\t\t\t\t\t\t\t\tMAP[P(g2,g1)]=1;\n\t\t\t\t\t\t\t\t//printf(\"%d %d\\n\",g1,g2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=0;i<Q;i++){\n\t\tfor(int j=0;j<WW;j++){\n\t\t\tfor(int k=0;k<HH;k++){\n\t\t\t\ts[j*HH+k]=2*(WW+HH)+1;\n\t\t\t\t//ds[j][k]=2*(WW+HH)+1;\n\t\t\t\t//f[j][k]=false;\n\t\t\t}\n\t\t}\n\t\tll sx,sy,gx,gy;\n\t\tscanf(\"%lld%lld%lld%lld\",&sx,&sy,&gx,&gy);\n\t\tsx*=10;sy*=10;gx*=10;gy*=10;\n\t\t\n\t\tsx1=lower_bound(x.begin(),x.end(),sx)-x.begin();\n\t\tgx1=lower_bound(x.begin(),x.end(),gx)-x.begin();\n\t\tsy1=lower_bound(y.begin(),y.end(),sy)-y.begin();\n\t\tgy1=lower_bound(y.begin(),y.end(),gy)-y.begin();\n\t\t\n\t\t//printf(\"%d:%d-%d:%d\\n\",sx1,sy1,gx1,gy1);\n\t\tint ss=grid[sx1][sy1]-1;\n\t\tint gg=grid[gx1][gy1]-1;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(make_pair(0,ss));\n\t\t//printf(\"%d %d\\n\",ss,gg);\n\t\t//printf(\"%d %d\\n\",sx1,sy1);\n\t\t//int n=0;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(p.fi>=s[p.sc])continue;\n\t\t\t//printf(\"%d %d\\n\",p.sc.fi,p.sc.sc);\n\t\t\ts[p.sc]=p.fi;\n\t\t\tfor(int j=0;j<(int)G[p.sc].size();j++){\n\t\t\t\tif(p.fi+1<s[G[p.sc][j]]){\n\t\t\t\t\tque.push(P(p.fi+1,G[p.sc][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d\\n\",n);\n\t\tprintf(\"%d\\n\",s[gg]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nbool f[305][305][2];\nint d[305][305];\nint H,W,M,Q,h,w;\nint ax[100],ay[100],bx[100],by[100];\nmap<int,int> X,Y;\n\nint solve(int sx,int sy,int tx,int ty){\n  memset(d,1,sizeof(d));\n  deque<int> qx,qy;\n  qx.push_front(sx);\n  qy.push_front(sy);\n  d[sx][sy]=0;\n  while(!qx.empty()){\n    int px=qx.front();qx.pop_front();\n    int py=qy.front();qy.pop_front();\n    //cout<<px<<' '<<py<<endl;\n    if(px==tx&&py==ty)return d[px][py];\n    for(int i=0;i<4;i++){\n      int nx=px+dx[i];\n      int ny=py+dy[i];\n      if(nx<=0||ny<=0)continue;\n      if(w<=nx||h<=ny)continue;\n      int flg=0;\n      if(i<2){\n        if(f[px][py][i])flg=1;\n      }else{\n        if(f[nx][ny][i-2])flg=1;\n      }\n      if(d[px][py]+flg<d[nx][ny]){\n        d[nx][ny]=d[px][py]+flg;\n        if(flg){\n          qx.push_back(nx);\n          qy.push_back(ny);\n        }else{\n          qx.push_front(nx);\n          qy.push_front(ny);\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nvoid func(map<int,int> &X){  \n  map<int,int>::iterator it;  \n  int C=0;\n  for(it=X.begin();it!=X.end();++it)\n    X[it->first]=++C;\n}\n\nint sx[105],sy[105];\nint tx[105],ty[105];\n\nint main(){\n  scanf(\"%d %d %d\",&W,&H,&M);\n  for(int i=0;i<M;i++){\n    scanf(\"%d %d %d %d\",&ax[i],&ay[i],&bx[i],&by[i]);\n    if(ax[i]>bx[i])swap(ax[i],bx[i]);\n    if(ay[i]>by[i])swap(ay[i],by[i]);\n    X[ax[i]]=Y[ay[i]]=i;\n    X[bx[i]]=Y[by[i]]=i;\n  }\n  X[0]=Y[0]=1;\n  X[W]=Y[H]=M;\n  scanf(\"%d\",&Q);\n  for(int i=0;i<Q;i++){\n    scanf(\"%d %d %d %d\",&sx[i],&sy[i],&tx[i],&ty[i]);\n    X[sx[i]]=Y[sy[i]]=i;\n    X[tx[i]]=Y[ty[i]]=i;\n  }  \n  func(X);\n  func(Y);\n  w=X[W],h=Y[H];\n  for(int i=0;i<M;i++){\n    int AX=X[ax[i]],AY=Y[ay[i]];\n    int BX=X[bx[i]],BY=Y[by[i]];\n    if(AX==BX){\n      for(int y=AY;y<BY;y++)f[AX][y][0]=true;      \n    }else{\n      for(int x=AX;x<BX;x++)f[x][AY][1]=true;      \n    }    \n  }\n  for(int i=0;i<Q;i++){\n    sx[i]=X[sx[i]];\n    sy[i]=Y[sy[i]];\n    tx[i]=X[tx[i]];\n    ty[i]=Y[ty[i]];\n    printf(\"%d\\n\",solve(sx[i],sy[i],tx[i],ty[i]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<unordered_map>\n#include<algorithm>\n\nclass Compression {\npublic:\n    Compression(const std::vector<int>& list) : value_(list) {\n        std::sort(begin(value_), end(value_));\n        value_.erase(std::unique(begin(value_), end(value_)), end(value_));\n        for(int i = 0; i < value_.size(); ++i) index_[value_[i]] = i;\n    }\n    int size() const {return value_.size();}\n    int index(const int v) const {return index_.at(v);}\n    int operator[](const int i) const {return value_.at(i);}\nprivate:\n    std::unordered_map<int, int> index_;\n    std::vector<int> value_;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nenum {BLANK = false, WALL = true};\nenum {Y, X};\nconst int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nstruct Wall {int px, py, qx, qy;};\nstruct Query {int sx, sy, gx, gy;};\n\nint range(int x, int lower, int upper) {return max(lower, min(upper, x));}\n\nint Dijkstra(const vector<vector<bool>>& field, int sx, int sy, int gx, int gy) {\n  const int h = field.size();\n  const int w = field.front().size();\n\n  typedef tuple<int, int, int> Node;\n\n  vector<vector<bool>> visited(h, vector<bool>(w, false));\n  priority_queue<Node, vector<Node>, greater<Node>> q;\n  q.emplace(0, sy, sx);\n  while(!q.empty()) {\n    int cost, y, x;\n    tie(cost, y, x) = q.top();\n    q.pop();\n    if(y == gy && x == gx) return cost;\n    if(visited[y][x]) continue;\n    visited[y][x] = true;\n//     cout << cost << \", \" << y << \", \" << x << endl;\n    for(const auto& d: NEXT) {\n      int ncost = cost;\n      int ny = y + d[Y];\n      int nx = x + d[X];\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(field[ny][nx] == WALL) {\n        ny += d[Y];\n        nx += d[X];\n        ++ncost;\n      }\n      if(ny < 0 || h <= ny || nx < 0 || w <= nx) continue;\n      if(!visited[ny][nx]) q.emplace(ncost, ny, nx);\n    }\n  }\n\n  return -1;\n}\n\nint main() {\n  int W, H, M;\n  cin >> W >> H >> M;\n  W *= 2; H *= 2;\n\n  vector<int> raw_x({0, W}), raw_y({0, H});\n\n  vector<Wall> wall(M);\n  for(auto& w: wall) {\n    cin >> w.px >> w.py >> w.qx >> w.qy;\n    w.px *= 2; w.py *= 2;\n    w.qx *= 2; w.qy *= 2;\n    for(int d: {-1, 0, 1}) {\n      raw_x.insert(begin(raw_x), {range(w.px + d, 0, W), range(w.qx + d, 0, W)});\n      raw_y.insert(begin(raw_y), {range(w.py + d, 0, H), range(w.qy + d, 0, H)});\n    }\n  }\n\n  int Q;\n  cin >> Q;\n  vector<Query> query(Q);\n  for(auto& q: query) {\n    cin >> q.sx >> q.sy >> q.gx >> q.gy;\n    q.sx *= 2; q.sy *= 2;\n    q.gx *= 2; q.gy *= 2;\n    raw_x.insert(begin(raw_x), {q.sx, q.gx});\n    raw_y.insert(begin(raw_y), {q.sy, q.gy});\n  }\n\n  Compression x(raw_x), y(raw_y);\n  vector<vector<bool>> field(y.size(), vector<bool>(x.size(), BLANK));\n  for(int i = 0; i < y.size(); ++i) field[i][0] = field[i][x.size() - 1] = WALL;\n  for(int j = 0; j < x.size(); ++j) field[0][j] = field[y.size() - 1][j] = WALL;\n  for(const auto& w: wall) {\n    if(w.px != w.qx) for(int j = x.index(min(w.px, w.qx)); j <= x.index(max(w.px, w.qx)); ++j) field[y.index(w.py)][j] = WALL;\n    if(w.py != w.qy) for(int i = y.index(min(w.py, w.qy)); i <= y.index(max(w.py, w.qy)); ++i) field[i][x.index(w.px)] = WALL;\n  }\n\n//   for(auto i: field) {\n//     for(auto j: i)cout<<\" \"<<j;\n//     cout<<endl;\n//   }\n\n  for(const auto& q: query) {\n    cout << Dijkstra(field, x.index(q.sx), y.index(q.sy), x.index(q.gx), y.index(q.gy)) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0)\n        g[a[y][x]].push_back(a[ry][rx]);\n    //g[a[ry][rx]].push_back(a[y][x]);\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size())\n        g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// very very te nu ki\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    while(1);\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS) while(1);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//\n\n#define MAX 510\n\nint H,W,M,Q;\nint px[MAX], py[MAX], qx[MAX], qy[MAX];\nint sx[MAX], sy[MAX], gx[MAX], gy[MAX];\n\nbool bmap[MAX][MAX];\n\nvoid veryVeryTenukiKansuu(vector<int> &X,vector<int> &Y) {\n  vector<Segment> segs;\n  rep(i,M) segs.push_back(Segment(Point(px[i],py[i]),Point(qx[i],qy[i])));\n  rep(i,M) REP(j,i+1,M) {\n    Segment &s1 = segs[i], &s2 = segs[j];\n    if( ( s1.p1.x == s1.p2.x ) && ( s2.p1.x == s2.p2.x ) ) continue;\n    if( ( s1.p1.y == s1.p2.y ) && ( s2.p1.y == s2.p2.y ) ) continue;\n    if( intersectSS(s1,s2) ) {\n      Point cp = crosspoint(s1,s2);\n      X.push_back(cp.x);\n      Y.push_back(cp.y);\n    }\n  }\n}\n\nstruct Data {\n  int x,y,w;\n  bool operator < (const Data &data) const {\n    return w > data.w;\n  }\n};\n\nint mini[MAX][MAX];\nint calc(int spx,int spy,int gpx,int gpy,int nH,int nW) {\n  rep(i,nH) rep(j,nW) mini[i][j] = INT_MAX;\n  mini[spy][spx] = 0;\n  priority_queue<Data> Q;\n  Q.push((Data){spx,spy,0});\n  while( !Q.empty() ) {\n    Data data = Q.top(); Q.pop();\n    int x = data.x, y = data.y;\n    if( x == gpx && y == gpy ) return mini[y][x];\n    REP(dx,-1,2) REP(dy,-1,2) {\n      if( dx != 0 && dy != 0 ) continue;\n      int nx = x + dx, ny = y + dy;\n      if( !( 0 <= nx && nx < nW && 0 <= ny && ny < nH ) ) continue;\n      int cost = mini[y][x] + bmap[ny][nx];\n      if( mini[ny][nx] > cost ) {\n        mini[ny][nx] = cost;\n        Q.push((Data){nx,ny,cost});\n      }\n    }\n  }\n  while(1);\n}\n\nvoid compute() {\n  vector<int> X, Y;\n  X.push_back(0), Y.push_back(0);\n  X.push_back(2*W), Y.push_back(2*H);\n  rep(i,M) {\n    X.push_back(px[i]), X.push_back(qx[i]);\n    Y.push_back(py[i]), Y.push_back(qy[i]);\n  }\n  rep(i,Q) {\n    X.push_back(sx[i]), X.push_back(gx[i]);\n    Y.push_back(sy[i]), Y.push_back(gy[i]);\n  }\n\n  veryVeryTenukiKansuu(X,Y);\n\n  {\n    vector<int> nX;\n    rep(i,(int)X.size()) {\n      nX.push_back(X[i]);\n      if( X[i]-1>=0 ) nX.push_back(X[i]-1);\n      if( X[i]+1<=2*W ) nX.push_back(X[i]+1);\n    }\n    X = nX;\n  }\n  {\n    vector<int> nY;\n    rep(i,(int)Y.size()) {\n      nY.push_back(Y[i]);\n      if( Y[i]-1>=0 ) nY.push_back(Y[i]-1);\n      if( Y[i]+1<=2*H ) nY.push_back(Y[i]+1);\n    }\n    Y = nY;\n  }\n\n  sort(X.begin(),X.end());\n  X.erase(unique(X.begin(),X.end()),X.end());\n  sort(Y.begin(),Y.end());\n  Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n  map<int,int> mpX,mpY;\n  rep(i,(int)X.size()) mpX[X[i]] = i;\n  rep(i,(int)Y.size()) mpY[Y[i]] = i;\n  \n  px[M  ] = 0, py[M  ] = 0, qx[M  ] = 2*W, qy[M  ] = 0;\n  px[M+1] = 2*W, py[M+1] = 0, qx[M+1] = 2*W, qy[M+1] = 2*H;\n  px[M+2] = 2*W, py[M+2] = 2*H, qx[M+2] = 0, qy[M+2] = 2*H;\n  px[M+3] = 0, py[M+3] = 2*H, qx[M+3] = 0, qy[M+3] = 0;\n  rep(i,M+4) {\n    int x1 = mpX[px[i]], y1 = mpY[py[i]];\n    int x2 = mpX[qx[i]], y2 = mpY[qy[i]];\n    REP(y,min(y1,y2),max(y1,y2)+1) REP(x,min(x1,x2),max(x1,x2)+1) bmap[y][x] = 1;\n  }\n\n  int nH = (int)Y.size(), nW = (int)X.size();\n  /*\n  rep(i,nH) {\n    rep(j,nW) {\n      cout << bmap[i][j];\n    } puts(\"\");\n  }\n  */\n  rep(i,Q) {\n    int x1 = mpX[sx[i]], y1 = mpY[sy[i]];\n    int x2 = mpX[gx[i]], y2 = mpY[gy[i]];\n    assert( !bmap[y1][x1] );\n    assert( !bmap[y2][x2] );\n    cout << calc(x1,y1,x2,y2,nH,nW) << endl;\n  }\n  \n}\n\nint main() {\n  cin >> W >> H >> M;\n  rep(i,M) cin >> px[i] >> py[i] >> qx[i] >> qy[i];\n  cin >> Q;\n  rep(i,Q) cin >> sx[i] >> sy[i] >> gx[i] >> gy[i];\n  rep(i,M) px[i] <<= 1, py[i] <<= 1, qx[i] <<= 1, qy[i] <<= 1;\n  rep(i,Q) sx[i] <<= 1, sy[i] <<= 1, gx[i] <<= 1, gy[i] <<= 1;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<long long,long long>P;\nlong long w,h,m;\nlong long dotti=0;\nvector<long long> xv,yv;\nint masu[501][501]={0};\nlong long X1[110],X2[110],Y1[110],Y2[110];\nlong long dx[4]={0,1,0,-1};\nlong long dy[4]={1,0,-1,0};\nlong long check[501][501]={0};\nvector<long long> node[505];\nlong long compress(long long *x1,long long *x2,long long w);\nmain(){\n  cin>>w>>h>>m;\n  w*=2;\n  h*=2;\n  for(int i=0;i<m;i++){\n    cin>>X1[i]>>Y1[i]>>X2[i]>>Y2[i];\n    X1[i]*=2;\n    X2[i]*=2;\n    if(X1[i]>X2[i]) swap(X1[i],X2[i]);\n    Y1[i]*=2;\n    Y2[i]*=2;\n    if(Y1[i]>Y2[i]) swap(Y1[i],Y2[i]);\n  }\n  X1[m]=0;X2[m]=w;Y1[m]=0;Y2[m]=0;m++;\n  X1[m]=0;X2[m]=w;Y1[m]=h;Y2[m]=h;m++;\n  X1[m]=0;X2[m]=0;Y1[m]=0;Y2[m]=h;m++;\n  X1[m]=w;X2[m]=w;Y1[m]=0;Y2[m]=h;m++;\n  w=compress(X1,X2,w);\n  dotti=1;\n  h=compress(Y1,Y2,h);\n  for(int i=0;i<m;i++){\n    for(long long y=Y1[i];y<=Y2[i];y++){\n      for(long long x=X1[i];x<=X2[i];x++){\n\tmasu[y][x]=-1;\n      }\n    }\n  }\n  long long now=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(masu[i][j]==0){\n\tqueue<P> que;\n\tnow++;\n\tque.push(P(i,j));\n\twhile(!que.empty()){\n\t  int nowy=que.front().first;\n\t  int nowx=que.front().second;\n\t  que.pop();\n\t  masu[nowy][nowx]=now;\n\t  for(int k=0;k<4;k++){\n\t    long long nx=nowx+dx[k];\n\t    long long ny=nowy+dy[k];\n\t    if(ny>=0&&ny<h&&nx>=0&&nx<w&&masu[ny][nx]==0){\n\t      que.push(P(ny,nx));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      long long me=masu[i][j];\n      for(int k=0;k<4;k++){\n\tlong long ny=i+dy[k]*2;\n\tlong long nx=j+dx[k]*2;\n\tif(ny>=0&&ny<h&&nx>=0&&nx<w){\n\t  long long to=masu[ny][nx];\n\t  if(me!=-1&&to!=-1&&me!=to&&check[me][to]==0){\n\t    node[me].push_back(to);\n\t    node[to].push_back(me);\n\t    check[me][to]=1;\n\t    check[to][me]=1;\n\t  }\n\t}\n      }\n    }\n  }\n  long long e;\n  long long mincost[505];\n  long long sx,sy,gx,gy;\n  cin>>e;\n  if(m==0){\n    for(int i=0;i<e;i++){\n      cin>>sx>>sy>>gx>>gy;\n      cout<<0<<endl;\n    }\n  }\n  else{\n    for(int i=0;i<e;i++){\n      long long s,g;\n      cin>>sx>>sy>>gx>>gy;\n      sx*=2;\n      sy*=2;\n      gx*=2;\n      gy*=2;\n      long long sxp,syp,gxp,gyp;\n      sxp=upper_bound(xv.begin(),xv.end(),sx)-xv.begin()-1;\n      syp=upper_bound(yv.begin(),yv.end(),sy)-yv.begin()-1;\n      gxp=upper_bound(xv.begin(),xv.end(),gx)-xv.begin()-1;\n      gyp=upper_bound(yv.begin(),yv.end(),gy)-yv.begin()-1;\n      sxp=max(sxp,0LL);\n      syp=max(syp,0LL);\n      gxp=max(gxp,0LL);\n      gyp=max(gyp,0LL);\n      if(sxp>=0&&syp>=0&&gxp>=0&&gyp>=0&&sxp<w&&gxp<w&&syp<h&&gyp<h){\n\ts=masu[syp][sxp];\n\tg=masu[gyp][gxp];\n\tif(s==-1||g==-1) break;\n\tfor(int j=1;j<=now;j++){\n\t  mincost[j]=(1LL<<60);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(P(0,s));\n\twhile(!que.empty()&&que.size()<50000){\n\t  long long nowc=que.top().first;\n\t  long long nowp=que.top().second;\n\t  que.pop();\n\t  if(nowp==g){\n\t    cout<<nowc<<endl;\n\t    break;\n\t  }\n\t  for(int j=0;j<node[nowp].size();j++){\n\t    long long nextp=node[nowp][j];\n\t    if(mincost[nextp]>nowc+1){\n\t      mincost[nextp]=nowc+1;\n\t      que.push(P(nowc+1,nextp));\n\t    }\n\t  }\n\t}\n      }\n      else{\n\tcout<<sxp<<\" \"<<syp<<\" \"<<gxp<<\" \"<<gyp<<endl;\n      }\n    }\n  }\n}\nlong long compress(long long *x1,long long *x2,long long W){\n  vector<long long> xs;\n  for(int i=0;i<m;i++){\n    for(long long d=-1;d<=1;d++){\n      long long tx1=x1[i]+d,tx2=x2[i]+d;\n      if(0<=tx1&&tx1<W) xs.push_back(tx1);\n      if(0<=tx2&&tx2<W) xs.push_back(tx2);\n    }\n  }\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  for(int i=0;i<m;i++){\n    x1[i]=find(xs.begin(),xs.end(),x1[i])-xs.begin();\n    x2[i]=find(xs.begin(),xs.end(),x2[i])-xs.begin();\n  }\n  if(dotti==0) xv=xs;\n  else yv=xs;\n  return xs.size();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mk make_pair\n#define int long long\n#define P pair<int,int>\nusing namespace std;\nint w,h,m,sx,sy,gx,gy;\nvector<pair<P,P> >v;\nvector<int>ax,ay;\nmap<int,int>mx,my;\nmap<P,int>qx,qy;\nint a[401][401],ppp;\nint dx[]={0,0,1,-1,1,1,-1,-1};\nint dy[]={1,-1,0,0,1,-1,1,-1};\nint ddx[]={2,0,0,-2,2,2,1,1,-1,-1,-2,-2};\nint ddy[]={0,2,-2,0,1,-1,2,-2,2,-2,1,-2};\nvector<int>g[405];\nbool used[405][405];\nvoid Grip(){\n  mx[0]=0;my[0]=0;\n  int pre=0;\n  for(int i=1;i<ax.size();i++){\n    int pp=ax[i];\n      ax[i]=ax[i-1]+2;\n    qx[mk(pre,pp)]=ax[i]-1;\n    mx[pp]=ax[i];\n    pre=pp;\n  }\n  pre=0;\n  for(int i=1;i<ay.size();i++){\n    int pp=ay[i];\n      ay[i]=ay[i-1]+2;\n    qy[mk(pre,pp)]=ay[i]-1;\n    my[pp]=ay[i];\n    pre=pp;\n  }\n  h=ay[ay.size()-1];\n  w=ax[ax.size()-1];\n}\nvoid mapmaker(){\n  for(int i=0;i<v.size();i++){\n    int sx=mx[v[i].f.f],sy=my[v[i].f.s];\n    int gx=mx[v[i].s.f],gy=my[v[i].s.s];\n    for(int j=sx;j<=gx;j++)\n      for(int k=sy;k<=gy;k++)\n        a[k][j]=-1;\n  }\n  for(int i=0;i<=w;i++)a[h][i]=a[0][i]=-1;\n  for(int i=0;i<=h;i++)a[i][0]=a[i][w]=-1;\n}\nvoid fullfill(int y,int x,int d){\n  a[y][x]=d;\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(!a[ry][rx])fullfill(ry,rx,d);\n  }\n}\nvoid graphmaker(int y,int x){\n  used[y][x]=1;\n  for(int i=0;i<12;i++){\n    int rx=x+ddx[i],ry=y+ddy[i];\n    if(rx>=0&&ry>=0&&rx<=w&&ry<=h)\n      if(a[ry][rx]!=a[y][x]&&a[ry][rx]>0){\n        g[a[y][x]].push_back(a[ry][rx]);\n        g[a[ry][rx]].push_back(a[y][x]);\n      }\n  }\n  for(int i=0;i<8;i++){\n    int rx=x+dx[i],ry=y+dy[i];\n      if(rx>=0&&ry>=0&&rx<=h&&ry<=w)\n        if(!used[ry][rx]&&a[ry][rx]>0)graphmaker(ry,rx);\n  }\n}\n main(){\n  cin>>w>>h>>m;\n    memset(a,0,sizeof(a));\n    ax.clear();ay.clear();v.clear();\n    mx.clear();my.clear();\n    qx.clear();qy.clear();\n    ax.push_back(w*2);ax.push_back(0);\n    ay.push_back(h*2);ay.push_back(0);\n    for(int i=0;i<405;i++)g[i].clear();\n    for(int i=0;i<m;i++){\n      cin>>sx>>sy>>gx>>gy;\n      v.push_back(mk(mk(sx*2,sy*2),mk(gx*2,gy*2)));\n      ax.push_back(sx*2);ax.push_back(gx*2);\n      ay.push_back(sy*2);ay.push_back(gy*2);\n    }\n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    Grip();\n    mapmaker();\n    fullfill(400,400,-1);\n    int cc=1;\n    for(int i=0;i<=h;i++)\n      for(int j=0;j<=w;j++){\n        if(!a[i][j])fullfill(i,j,cc++);\n      }\n    memset(used,0,sizeof(used));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        if(0<a[i][j]&&!used[i][j])\n          graphmaker(i,j);\n    for(int i=0;i<405;i++)\n      if(g[i].size()){\n\t//sort(g[i].begin(),g[i].end());\n       // g[i].erase(unique(g[i].begin(),g[i].end()),g[i].end());\n      }\n    cin>>m;\n    while(m--){\n      cin>>sx>>sy>>gx>>gy;sx*=2;sy*=2;gx*=2;gy*=2;\n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<sx&&(*it).f.s>=sx){sx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qx.begin();it!=qx.end();it++)\n        if((*it).f.f<gx&&(*it).f.s>=gx){gx=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<sy&&(*it).f.s>=sy){sy=(*it).s;break;}\n      \n      for(map<P,int>::iterator it=qy.begin();it!=qy.end();it++)\n        if((*it).f.f<gy&&(*it).f.s>=gy){gy=(*it).s;break;}\n      \n      int so=a[sy][sx],go=a[gy][gx];\n      int use[100]={};\n      use[so]=1;\n      queue<pair<int,int> >q;\n      q.push(mk(so,0));\n      while(!q.empty()){\n        P u=q.front();q.pop();\n        if(u.f==go){\n          cout<<u.s<<endl;\n          goto L;\n        }\n        for(int i=0;i<g[u.f].size();i++)\n          if(!use[g[u.f][i]]){\n            use[g[u.f][i]]=1;\n            q.push(mk(g[u.f][i],u.s+1));\n          }\n      }L:;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\nconst int INF=1001001001;\nint W,H,M,Q;\nvector<int>xs,ys;\nint x1[110],y1[110],x2[110],y2[110];\nint qx1[100],qy1[100],qx2[100],qy2[100];\nint fld[3000][3000];\nvector<vector<int> >G;\nint D;\nvoid compress(vector<int>&vec,int Sz){\n    vector<int>latte;\n    for(int i=0;i<vec.size();i++){\n        for(int d=-1;d<=1;d++){\n            int v=vec[i]+d;\n            if(v<0||v>Sz)continue;\n            latte.push_back(v);\n        }\n    }\n    sort(latte.begin(),latte.end());\n    latte.erase(unique(latte.begin(),latte.end()),latte.end());\n    vec=latte;\n}\n\nvoid paint(int y,int x,int c){\n    fld[y][x]=c;\n    for(int i=0;i<4;i++){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]!=0)continue;\n        paint(ny,nx,c);\n    }\n}\n\nvoid dijkstra(int s,int t){\n    vector<int>dist(D,INF);\n    dist[s]=0;\n    queue<int>que;\n    que.push(s);\n\n    while(que.size()){\n        int p=que.front();que.pop();\n        for(int i=0;i<G[p].size();i++){\n            int to=G[p][i];\n            if(dist[to]<=dist[p]+1)continue;\n            dist[to]=dist[p]+1;\n            que.push(to);\n        }\n\n    }\n    cout<<dist[t]<<endl;\n}\n\nsigned main(){\n    scanf(\"%d%d%d\",&W,&H,&M);\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d%d\",&x1[i],&y1[i],&x2[i],&y2[i]);\n        x1[i]*=2;x2[i]*=2;y1[i]*=2;y2[i]*=2;\n    }\n    H*=2;W*=2;\n    x1[M]=0;x2[M]=W;y1[M]=0;y2[M]=0;M++;\n    x1[M]=0;x2[M]=W;y1[M]=H;y2[M]=H;M++;\n    x1[M]=0;x2[M]=0;y1[M]=0;y2[M]=H;M++;\n    x1[M]=W;x2[M]=W;y1[M]=0;y2[M]=H;M++;\n\n    for(int i=0;i<M;i++){\n        xs.push_back(x1[i]);\n        xs.push_back(x2[i]);\n        ys.push_back(y1[i]);\n        ys.push_back(y2[i]);\n    }\n\n    scanf(\"%d\",&Q);\n    for(int i=0;i<Q;i++){\n        scanf(\"%d%d%d%d\",&qx1[i],&qy1[i],&qx2[i],&qy2[i]);\n        qx1[i]*=2;xs.push_back(qx1[i]);\n        qx2[i]*=2;xs.push_back(qx2[i]);\n        qy1[i]*=2;ys.push_back(qy1[i]);\n        qy2[i]*=2;ys.push_back(qy2[i]);\n    }\n\n    compress(xs,W);\n    compress(ys,H);\n\n    for(int i=0;i<M;i++){\n        x1[i]=lower_bound(xs.begin(),xs.end(),x1[i])-xs.begin();\n        x2[i]=lower_bound(xs.begin(),xs.end(),x2[i])-xs.begin();\n        y1[i]=lower_bound(ys.begin(),ys.end(),y1[i])-ys.begin();\n        y2[i]=lower_bound(ys.begin(),ys.end(),y2[i])-ys.begin();\n    }\n    for(int i=0;i<Q;i++){\n        qx1[i]=lower_bound(xs.begin(),xs.end(),qx1[i])-xs.begin();\n        qx2[i]=lower_bound(xs.begin(),xs.end(),qx2[i])-xs.begin();\n        qy1[i]=lower_bound(ys.begin(),ys.end(),qy1[i])-ys.begin();\n        qy2[i]=lower_bound(ys.begin(),ys.end(),qy2[i])-ys.begin();\n    }\n\n    W=xs.size();H=ys.size();\n    memset(fld,0,sizeof(fld));\n    for(int i=0;i<M;i++)\n        for(int y=y1[i];y<=y2[i];y++)\n            for(int x=x1[i];x<=x2[i];x++)\n                fld[y][x]=-1;\n\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]==0)paint(i,j,++D);\n\n\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            if(fld[i][j]!=-1)fld[i][j]--;\n\n\n    G.resize(D);\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            for(int d=0;d<2;d++){\n                int ny1=i+dy[d],ny2=i+dy[d+2];\n                int nx1=j+dx[d],nx2=j+dx[d+2];\n                if(ny1<0||ny1>=H||nx1<0||nx1>=W)continue;\n                if(ny2<0||ny2>=H||nx2<0||nx2>=W)continue;\n                if(fld[ny1][nx1]!=-1&&fld[ny2][nx2]!=-1&&fld[ny1][nx1]!=fld[ny2][nx2]){\n                    int c1=fld[ny1][nx1];\n                    int c2=fld[ny2][nx2];\n                    G[c1].push_back(c2);\n                    G[c2].push_back(c1);\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<D;i++){\n        sort(G[i].begin(),G[i].end());\n        G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n    }\n\n    for(int i=0;i<Q;i++){\n        int c1=fld[qy1[i]][qx1[i]];\n        int c2=fld[qy2[i]][qx2[i]];\n        dijkstra(c1,c2);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0292: Wall\n// 2017.12.28 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 160010\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 550000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;  if (qsize > 500000) while (1);\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define U 1\n#define D 2\n#define L 4\n#define R 8\n\ntypedef struct { int px, py, qx, qy; } T;\nT t[102];\nint x[404], xs;\nint y[404], ys;\nchar map[404][404];\nint rel[404][404];\t\t\t// (r,c) <--> p[x]\nint tbl[MAX][501]; int len[MAX];\nint mv[4][3] = {{-1,0,D},{0,1,R},{1,0,U},{0,-1,L}};\nchar used[MAX];\nchar buf[50], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nvoid pushback(int a, int b)\n{\n\tint i;\n\tfor (i = 0; i < len[a]; i++) {\n\t\tif (tbl[a][i] == b) return;\n\t}\n\ttbl[a][i] = b; len[a]++;\n\tif (len[a] >= 500) while (1){}\n}\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, d, e;\n\n\tmemset(used, 0, sizeof(used));\n\td = 0, qsize = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+1);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint w, h, m, q, i, r, c, r2, c2, a, b;\n\tint px, py, qx, qy;\n\n\tfgets(bp=buf, 30, stdin);\n\tw = in(), h = in(), m = in();\n\tx[0] = y[0] = 0, xs = ys = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tt[i].px = x[xs++] = in(), t[i].py = y[ys++] = in();\n\t\tt[i].qx = x[xs++] = in(), t[i].qy = y[ys++] = in();\n\t}\n\tx[xs++] = w, y[ys++] = h;\n\n\tqsort(x, xs, sizeof(int), cmp); xs = uniq(x, xs);\n\tqsort(y, ys, sizeof(int), cmp); ys = uniq(y, ys);\n\n\tw = bsch(x, w, xs);\n\th = bsch(y, h, ys);\n\tfor (i = 0; i < m; i++) {\n\t\tpx = bsch(x, t[i].px, xs);\n\t\tpy = bsch(y, t[i].py, ys);\n\t\tqx = bsch(x, t[i].qx, xs);\n\t\tqy = bsch(y, t[i].qy, ys);\n\t\tif (px == qx) {\n\t\t\tif (py > qy) r = py, py = qy, qy = r;\n\t\t\tfor (r = py; r < qy; r++) {\n\t\t\t\tif (px >= 1) map[r][px-1] |= R;\n\t\t\t\t             map[r][px  ] |= L;\n\t\t\t}\n\t\t} else {\n\t\t\tif (px > qx) c = px, px = qx, qx = c;\n\t\t\tfor (c = px; c < qx; c++) {\n\t\t\t\tif (py >= 1) map[py-1][c] |= U;\n\t\t\t\t             map[py  ][c] |= D;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tp[i] = i, rel[r][c] = i++;\n\t}\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && !(map[r][c] & mv[i][2])) {\n\t\t\t\tunion_set(rel[r][c], rel[r2][c2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\ta = rel[r][c] = find_set(rel[r][c]);\n\t\tif (r+1 < h) {\n\t\t\tb = rel[r+1][c] = find_set(rel[r+1][c]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t\tif (c+1 < w) {\n\t\t\tb = rel[r][c+1] = find_set(rel[r][c+1]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t}\n\t\n\tfgets(bp=buf, 10, stdin), q = in();\n\twhile (q--) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tpx = bsch(x, in(), xs), py = bsch(y, in(), ys);\n\t\ta = rel[py][px];\n\t\tqx = bsch(x, in(), xs), qy = bsch(y, in(), ys);\n\t\tb = rel[qy][qx];\n\t\tprintf(\"%d\\n\", dijkstra(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0292: Wall\n// 2017.12.28 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 160010\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 150000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define U 1\n#define D 2\n#define L 4\n#define R 8\n\ntypedef struct { int px, py, qx, qy; } T;\nT t[102];\nint x[404], xs;\nint y[404], ys;\nchar map[404][404];\nint rel[404][404];\t\t\t// (r,c) <--> p[x]\nchar tbl[MAX][24]; char len[MAX];\nint mv[4][3] = {{-1,0,D},{0,1,R},{1,0,U},{0,-1,L}};\nchar used[MAX];\nchar buf[50], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nvoid pushback(int a, int b)\n{\n\tint i;\n\tfor (i = 0; i < len[a]; i++) {\n\t\tif (tbl[a][i] == b) return;\n\t}\n\ttbl[a][i] = b; len[a]++;\n}\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, d, e;\n\n\tmemset(used, 0, sizeof(used));\n\td = 0, qsize = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+1);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint w, h, m, q, i, r, c, r2, c2, a, b;\n\tint px, py, qx, qy;\n\n\tfgets(bp=buf, 30, stdin);\n\tw = in(), h = in(), m = in();\n\tx[0] = y[0] = 0, xs = ys = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tt[i].px = x[xs++] = in(), t[i].py = y[ys++] = in();\n\t\tt[i].qx = x[xs++] = in(), t[i].qy = y[ys++] = in();\n\t}\n\tx[xs++] = w, y[ys++] = h;\n\n\tqsort(x, xs, sizeof(int), cmp); xs = uniq(x, xs);\n\tqsort(y, ys, sizeof(int), cmp); ys = uniq(y, ys);\n\n\tw = bsch(x, w, xs);\n\th = bsch(y, h, ys);\n\tfor (i = 0; i < m; i++) {\n\t\tpx = bsch(x, t[i].px, xs);\n\t\tpy = bsch(y, t[i].py, ys);\n\t\tqx = bsch(x, t[i].qx, xs);\n\t\tqy = bsch(y, t[i].qy, ys);\n\t\tif (px == qx) {\n\t\t\tif (py > qy) r = py, py = qy, qy = r;\n\t\t\tfor (r = py; r < qy; r++) {\n\t\t\t\tif (px >= 1) map[r][px-1] |= R;\n\t\t\t\t             map[r][px  ] |= L;\n\t\t\t}\n\t\t} else {\n\t\t\tif (px > qx) c = px, px = qx, qx = c;\n\t\t\tfor (c = px; c < qx; c++) {\n\t\t\t\tif (py >= 1) map[py-1][c] |= U;\n\t\t\t\t             map[py  ][c] |= D;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tp[i] = i, rel[r][c] = i++;\n\t}\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && !(map[r][c] & mv[i][2])) {\n\t\t\t\tunion_set(rel[r][c], rel[r2][c2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\ta = rel[r][c] = find_set(rel[r][c]);\n\t\tif (r+1 < h) {\n\t\t\tb = rel[r+1][c] = find_set(rel[r+1][c]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t\tif (c+1 < w) {\n\t\t\tb = rel[r][c+1] = find_set(rel[r][c+1]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t}\n\t\n\tfgets(bp=buf, 10, stdin), q = in();\n\twhile (q--) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tpx = bsch(x, in(), xs), py = bsch(y, in(), ys);\n\t\ta = rel[py][px];\n\t\tqx = bsch(x, in(), xs), qy = bsch(y, in(), ys);\n\t\tb = rel[qy][qx];\n\t\tprintf(\"%d\\n\", dijkstra(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0292: Wall\n// 2017.12.28 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 160010\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 160000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define U 1\n#define D 2\n#define L 4\n#define R 8\n\ntypedef struct { int px, py, qx, qy; } T;\nT t[102];\nint x[404], xs;\nint y[404], ys;\nchar map[404][404];\nint rel[404][404];\t\t\t// (r,c) <--> p[x]\nint tbl[MAX][501]; int len[MAX];\nint mv[4][3] = {{-1,0,D},{0,1,R},{1,0,U},{0,-1,L}};\nchar used[MAX];\nchar buf[50], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nvoid pushback(int a, int b)\n{\n\tint i;\n\tfor (i = 0; i < len[a]; i++) {\n\t\tif (tbl[a][i] == b) return;\n\t}\n\ttbl[a][i] = b; len[a]++;\n}\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, d, e;\n\n\tmemset(used, 0, sizeof(used));\n\td = 0, qsize = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+1);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint w, h, m, q, i, r, c, r2, c2, a, b;\n\tint px, py, qx, qy;\n\n\tfgets(bp=buf, 30, stdin);\n\tw = in(), h = in(), m = in();\n\tx[0] = y[0] = 0, xs = ys = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tt[i].px = x[xs++] = in(), t[i].py = y[ys++] = in();\n\t\tt[i].qx = x[xs++] = in(), t[i].qy = y[ys++] = in();\n\t}\n\tx[xs++] = w, y[ys++] = h;\n\n\tqsort(x, xs, sizeof(int), cmp); xs = uniq(x, xs);\n\tqsort(y, ys, sizeof(int), cmp); ys = uniq(y, ys);\n\n\tw = bsch(x, w, xs);\n\th = bsch(y, h, ys);\n\tfor (i = 0; i < m; i++) {\n\t\tpx = bsch(x, t[i].px, xs);\n\t\tpy = bsch(y, t[i].py, ys);\n\t\tqx = bsch(x, t[i].qx, xs);\n\t\tqy = bsch(y, t[i].qy, ys);\n\t\tif (px == qx) {\n\t\t\tif (py > qy) r = py, py = qy, qy = r;\n\t\t\tfor (r = py; r < qy; r++) {\n\t\t\t\tif (px >= 1) map[r][px-1] |= R;\n\t\t\t\t             map[r][px  ] |= L;\n\t\t\t}\n\t\t} else {\n\t\t\tif (px > qx) c = px, px = qx, qx = c;\n\t\t\tfor (c = px; c < qx; c++) {\n\t\t\t\tif (py >= 1) map[py-1][c] |= U;\n\t\t\t\t             map[py  ][c] |= D;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tp[i] = i, rel[r][c] = i++;\n\t}\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && !(map[r][c] & mv[i][2])) {\n\t\t\t\tunion_set(rel[r][c], rel[r2][c2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\ta = rel[r][c] = find_set(rel[r][c]);\n\t\tif (r+1 < h) {\n\t\t\tb = rel[r+1][c] = find_set(rel[r+1][c]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t\tif (c+1 < w) {\n\t\t\tb = rel[r][c+1] = find_set(rel[r][c+1]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t}\n\t\n\tfgets(bp=buf, 10, stdin), q = in();\n\twhile (q--) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tpx = bsch(x, in(), xs), py = bsch(y, in(), ys);\n\t\ta = rel[py][px];\n\t\tqx = bsch(x, in(), xs), qy = bsch(y, in(), ys);\n\t\tb = rel[qy][qx];\n\t\tprintf(\"%d\\n\", dijkstra(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0292: Wall\n// 2017.12.28 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 160010\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 250000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;  if (qsize > 200000) while (1);\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define U 1\n#define D 2\n#define L 4\n#define R 8\n\ntypedef struct { int px, py, qx, qy; } T;\nT t[102];\nint x[404], xs;\nint y[404], ys;\nchar map[404][404];\nint rel[404][404];\t\t\t// (r,c) <--> p[x]\nchar tbl[MAX][402]; char len[MAX];\nint mv[4][3] = {{-1,0,D},{0,1,R},{1,0,U},{0,-1,L}};\nchar used[MAX];\nchar buf[50], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nvoid pushback(int a, int b)\n{\n\tint i;\n\tfor (i = 0; i < len[a]; i++) {\n\t\tif (tbl[a][i] == b) return;\n\t}\n\ttbl[a][i] = b; len[a]++;\n\tif (len[a] >= 100) while (1){}\n}\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, d, e;\n\n\tmemset(used, 0, sizeof(used));\n\td = 0, qsize = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+1);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint w, h, m, q, i, r, c, r2, c2, a, b;\n\tint px, py, qx, qy;\n\n\tfgets(bp=buf, 30, stdin);\n\tw = in(), h = in(), m = in();\n\tx[0] = y[0] = 0, xs = ys = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tt[i].px = x[xs++] = in(), t[i].py = y[ys++] = in();\n\t\tt[i].qx = x[xs++] = in(), t[i].qy = y[ys++] = in();\n\t}\n\tx[xs++] = w, y[ys++] = h;\n\n\tqsort(x, xs, sizeof(int), cmp); xs = uniq(x, xs);\n\tqsort(y, ys, sizeof(int), cmp); ys = uniq(y, ys);\n\n\tw = bsch(x, w, xs);\n\th = bsch(y, h, ys);\n\tfor (i = 0; i < m; i++) {\n\t\tpx = bsch(x, t[i].px, xs);\n\t\tpy = bsch(y, t[i].py, ys);\n\t\tqx = bsch(x, t[i].qx, xs);\n\t\tqy = bsch(y, t[i].qy, ys);\n\t\tif (px == qx) {\n\t\t\tif (py > qy) r = py, py = qy, qy = r;\n\t\t\tfor (r = py; r < qy; r++) {\n\t\t\t\tif (px >= 1) map[r][px-1] |= R;\n\t\t\t\t             map[r][px  ] |= L;\n\t\t\t}\n\t\t} else {\n\t\t\tif (px > qx) c = px, px = qx, qx = c;\n\t\t\tfor (c = px; c < qx; c++) {\n\t\t\t\tif (py >= 1) map[py-1][c] |= U;\n\t\t\t\t             map[py  ][c] |= D;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tp[i] = i, rel[r][c] = i++;\n\t}\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && !(map[r][c] & mv[i][2])) {\n\t\t\t\tunion_set(rel[r][c], rel[r2][c2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\ta = rel[r][c] = find_set(rel[r][c]);\n\t\tif (r+1 < h) {\n\t\t\tb = rel[r+1][c] = find_set(rel[r+1][c]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t\tif (c+1 < w) {\n\t\t\tb = rel[r][c+1] = find_set(rel[r][c+1]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t}\n\t\n\tfgets(bp=buf, 10, stdin), q = in();\n\twhile (q--) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tpx = bsch(x, in(), xs), py = bsch(y, in(), ys);\n\t\ta = rel[py][px];\n\t\tqx = bsch(x, in(), xs), qy = bsch(y, in(), ys);\n\t\tb = rel[qy][qx];\n\t\tprintf(\"%d\\n\", dijkstra(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0292: Wall\n// 2017.12.28 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 160010\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 150000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n//\treturn 1;\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define U 1\n#define D 2\n#define L 4\n#define R 8\n\ntypedef struct { int px, py, qx, qy; } T;\nT t[102];\nint x[404], xs;\nint y[404], ys;\nchar map[404][404];\nint rel[404][404];\t\t\t// (r,c) <--> p[x]\nchar tbl[MAX][24]; char len[MAX];\nint mv[4][3] = {{-1,0,D},{0,1,R},{1,0,U},{0,-1,L}};\nchar used[MAX];\nchar buf[50], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nvoid pushback(int a, int b)\n{\n\tint i;\n\tfor (i = 0; i < len[a]; i++) {\n\t\tif (tbl[a][i] == b) return;\n\t}\n\ttbl[a][i] = b; len[a]++;\n}\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, d, e;\n\n\tmemset(used, 0, sizeof(used));\n\td = 0, qsize = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+1);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint w, h, m, q, i, r, c, r2, c2, a, b;\n\tint px, py, qx, qy;\n\n\tfgets(bp=buf, 30, stdin);\n\tw = in(), h = in(), m = in();\n\tx[0] = y[0] = 0, xs = ys = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tt[i].px = x[xs++] = in(), t[i].py = y[ys++] = in();\n\t\tt[i].qx = x[xs++] = in(), t[i].qy = y[ys++] = in();\n\t}\n\tx[xs++] = w, y[ys++] = h;\n\n\tqsort(x, xs, sizeof(int), cmp); xs = uniq(x, xs);\n\tqsort(y, ys, sizeof(int), cmp); ys = uniq(y, ys);\n\n\tw = bsch(x, w, xs);\n\th = bsch(y, h, ys);\n\tfor (i = 0; i < m; i++) {\n\t\tpx = bsch(x, t[i].px, xs);\n\t\tpy = bsch(y, t[i].py, ys);\n\t\tqx = bsch(x, t[i].qx, xs);\n\t\tqy = bsch(y, t[i].qy, ys);\n\t\tif (px == qx) {\n\t\t\tif (py > qy) r = py, py = qy, qy = r;\n\t\t\tfor (r = py; r < qy; r++) {\n\t\t\t\tif (px >= 1) map[r][px-1] |= R;\n\t\t\t\t             map[r][px  ] |= L;\n\t\t\t}\n\t\t} else {\n\t\t\tif (px > qx) c = px, px = qx, qx = c;\n\t\t\tfor (c = px; c < qx; c++) {\n\t\t\t\tif (py >= 1) map[py-1][c] |= U;\n\t\t\t\t             map[py  ][c] |= D;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tp[i] = i, rel[r][c] = i++;\n\t}\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && !(map[r][c] & mv[i][2])) {\n\t\t\t\tunion_set(rel[r][c], rel[r2][c2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\ta = rel[r][c] = find_set(rel[r][c]);\n\t\tif (r+1 < h) {\n\t\t\tb = rel[r+1][c] = find_set(rel[r+1][c]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t\tif (c+1 < w) {\n\t\t\tb = rel[r][c+1] = find_set(rel[r][c+1]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t}\n\t\n\tfgets(bp=buf, 10, stdin), q = in();\n\twhile (q--) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tpx = bsch(x, in(), xs), py = bsch(y, in(), ys);\n\t\ta = rel[py][px];\n\t\tqx = bsch(x, in(), xs), qy = bsch(y, in(), ys);\n\t\tb = rel[qy][qx];\n\t\tprintf(\"%d\\n\", dijkstra(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0292: Wall\n// 2017.12.28 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 160010\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\n#define QMAX 250000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;  if (qsize > 200000) while (1);\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define U 1\n#define D 2\n#define L 4\n#define R 8\n\ntypedef struct { int px, py, qx, qy; } T;\nT t[102];\nint x[404], xs;\nint y[404], ys;\nchar map[404][404];\nint rel[404][404];\t\t\t// (r,c) <--> p[x]\nchar tbl[MAX][102]; char len[MAX];\nint mv[4][3] = {{-1,0,D},{0,1,R},{1,0,U},{0,-1,L}};\nchar used[MAX];\nchar buf[50], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bsch(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nvoid pushback(int a, int b)\n{\n\tint i;\n\tfor (i = 0; i < len[a]; i++) {\n\t\tif (tbl[a][i] == b) return;\n\t}\n\ttbl[a][i] = b; len[a]++;\n\tif (len[a] >= 100) while (1){}\n}\n\nint dijkstra(int start, int goal)\n{\n\tint i, s, d, e;\n\n\tmemset(used, 0, sizeof(used));\n\td = 0, qsize = 0;\n\tenq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (s == goal) break;\n\t\tif (used[s]) continue;\n\t\tused[s] = 1;\n\t\tfor (i = 0; i < len[s]; i++) {\n\t\t\te = tbl[s][i];\n\t\t\tif (used[e]) continue;\n\t\t\tenq(e, d+1);\n\t\t}\n\t}\n\treturn d;\n}\n\nint main()\n{\n\tint w, h, m, q, i, r, c, r2, c2, a, b;\n\tint px, py, qx, qy;\n\n\tfgets(bp=buf, 30, stdin);\n\tw = in(), h = in(), m = in();\n\tx[0] = y[0] = 0, xs = ys = 1;\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tt[i].px = x[xs++] = in(), t[i].py = y[ys++] = in();\n\t\tt[i].qx = x[xs++] = in(), t[i].qy = y[ys++] = in();\n\t}\n\tx[xs++] = w, y[ys++] = h;\n\n\tqsort(x, xs, sizeof(int), cmp); xs = uniq(x, xs);\n\tqsort(y, ys, sizeof(int), cmp); ys = uniq(y, ys);\n\n\tw = bsch(x, w, xs);\n\th = bsch(y, h, ys);\n\tfor (i = 0; i < m; i++) {\n\t\tpx = bsch(x, t[i].px, xs);\n\t\tpy = bsch(y, t[i].py, ys);\n\t\tqx = bsch(x, t[i].qx, xs);\n\t\tqy = bsch(y, t[i].qy, ys);\n\t\tif (px == qx) {\n\t\t\tif (py > qy) r = py, py = qy, qy = r;\n\t\t\tfor (r = py; r < qy; r++) {\n\t\t\t\tif (px >= 1) map[r][px-1] |= R;\n\t\t\t\t             map[r][px  ] |= L;\n\t\t\t}\n\t\t} else {\n\t\t\tif (px > qx) c = px, px = qx, qx = c;\n\t\t\tfor (c = px; c < qx; c++) {\n\t\t\t\tif (py >= 1) map[py-1][c] |= U;\n\t\t\t\t             map[py  ][c] |= D;\n\t\t\t}\n\t\t}\n\t}\n\n\ti = 0;\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tp[i] = i, rel[r][c] = i++;\n\t}\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\tif (r2 >= 0 && r2 < h && c2 >= 0 && c2 < w && !(map[r][c] & mv[i][2])) {\n\t\t\t\tunion_set(rel[r][c], rel[r2][c2]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\ta = rel[r][c] = find_set(rel[r][c]);\n\t\tif (r+1 < h) {\n\t\t\tb = rel[r+1][c] = find_set(rel[r+1][c]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t\tif (c+1 < w) {\n\t\t\tb = rel[r][c+1] = find_set(rel[r][c+1]);\n\t\t\tif (a != b) pushback(a, b), pushback(b, a);\n\t\t}\n\t}\n\t\n\tfgets(bp=buf, 10, stdin), q = in();\n\twhile (q--) {\n\t\tfgets(bp=buf, 50, stdin);\n\t\tpx = bsch(x, in(), xs), py = bsch(y, in(), ys);\n\t\ta = rel[py][px];\n\t\tqx = bsch(x, in(), xs), qy = bsch(y, in(), ys);\n\t\tb = rel[qy][qx];\n\t\tprintf(\"%d\\n\", dijkstra(a, b));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\nfrom bisect import bisect\nW, H, M = map(int, input().split())\nL = [list(map(int, input().split())) for i in range(M)]\n\nXS = set([0, W])\nYS = set([0, H])\n\nfor px, py, qx, qy in L:\n    XS.add(px); XS.add(qx)\n    YS.add(py); YS.add(qy)\n\nX0 = sorted(XS)\nY0 = sorted(YS)\n\ndef convert(X0):\n    mp = {}\n    prv = -1\n    cur = 0\n    for x in X0:\n        mp[x] = cur\n        cur += 2\n        prv = x\n    cur -= 1\n    return mp, cur\n\nXM, X = convert(X0)\nYM, Y = convert(Y0)\n\nC = [[0]*X for i in range(Y)]\nD = [[-1]*X for i in range(Y)]\nfor i in range(Y):\n    C[i][0] = C[i][X-1] = 1\nfor i in range(X):\n    C[0][i] = C[Y-1][i] = 1\nfor px, py, qx, qy in L:\n    if px == qx:\n        if not py < qy:\n            py, qy = qy, py\n        x0 = XM[px]\n        y0 = YM[py]; y1 = YM[qy]\n        for i in range(y0, y1+1):\n            C[i][x0] = 1\n    else:\n        if not px < qx:\n            px, qx = qx, px\n        x0 = XM[px]; x1 = XM[qx]\n        y0 = YM[py]\n        for i in range(x0, x1+1):\n            C[y0][i] = 1\n\ndd = ((-1, 0), (0, -1), (1, 0), (0, 1))\nque = deque()\ncur = 0\nfor i in range(Y):\n    for j in range(X):\n        if C[i][j] or D[i][j] != -1:\n            continue\n        D[i][j] = cur\n        que.append((j, i))\n        while que:\n            x, y = que.popleft()\n            for dx, dy in dd:\n                nx = x + dx; ny = y + dy\n                if C[ny][nx] or D[ny][nx] != -1:\n                    continue\n                D[ny][nx] = cur\n                que.append((nx, ny))\n        cur += 1\n\nN = cur\nINF = 10**9\nG = [[] for i in range(N)]\nfor i in range(1, Y-1):\n    for j in range(1, X-1):\n        a = D[i-1][j]; b = D[i+1][j]\n        if a != -1 != b != a:\n            G[a].append(b)\n            G[b].append(a)\n        a = D[i][j-1]; b = D[i][j+1]\n        if a != -1 != b != a:\n            G[a].append(b)\n            G[b].append(a)\n\nQ = int(input())\nfor i in range(Q):\n    sx, sy, gx, gy = map(int, input().split())\n    x0 = (bisect(X0, sx)-1)*2+1; y0 = (bisect(Y0, sy-1)-1)*2+1\n    x1 = (bisect(X0, gx)-1)*2+1; y1 = (bisect(Y0, gy)-1)*2+1\n    assert D[y0][x0] != -1 and D[y1][x1] != -1\n    s = D[y0][x0]; t = D[y1][x1]\n    que = deque([s])\n    U = [-1]*N\n    U[s] = 0\n    while que:\n        v = que.popleft()\n        d = U[v]\n        for w in G[v]:\n            if U[w] != -1:\n                continue\n            U[w] = d+1\n            que.append(w)\n    print(U[t])\n\n"
  }
]