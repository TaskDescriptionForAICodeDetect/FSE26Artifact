[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Wall;\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint W, H, N;\nWall walls[1000];\nPoint start, end;\n\nint ccw(int x1, int y1, int x2, int y2, int x3, int y3) {\n    int val = (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : -1;\n}\n\nint intersect(Wall w, Point a, Point b) {\n    int ccw1 = ccw(w.x1, w.y1, w.x2, w.y2, a.x, a.y);\n    int ccw2 = ccw(w.x1, w.y1, w.x2, w.y2, b.x, b.y);\n    int ccw3 = ccw(a.x, a.y, b.x, b.y, w.x1, w.y1);\n    int ccw4 = ccw(a.x, a.y, b.x, b.y, w.x2, w.y2);\n    \n    if (ccw1 == 0 || ccw2 == 0 || ccw3 == 0 || ccw4 == 0) {\n        return 0;\n    }\n    \n    return (ccw1 != ccw2) && (ccw3 != ccw4);\n}\n\nint minWalls() {\n    int min = INT_MAX;\n    int *visited = (int *)calloc(N, sizeof(int));\n    \n    Point queue[100000];\n    int front = 0, rear = 0;\n    int wallsCrossed[100000];\n    \n    queue[rear] = start;\n    wallsCrossed[rear] = 0;\n    rear++;\n    \n    while (front < rear) {\n        Point current = queue[front];\n        int currentWalls = wallsCrossed[front];\n        front++;\n        \n        if (current.x == end.x && current.y == end.y) {\n            if (currentWalls < min) {\n                min = currentWalls;\n            }\n            continue;\n        }\n        \n        for (int i = 0; i < N; i++) {\n            if (visited[i]) continue;\n            \n            Point next;\n            if (walls[i].x1 == walls[i].x2) {\n                next.x = walls[i].x1;\n                next.y = (walls[i].y1 + walls[i].y2) / 2;\n            } else {\n                next.x = (walls[i].x1 + walls[i].x2) / 2;\n                next.y = walls[i].y1;\n            }\n            \n            int crosses = 0;\n            for (int j = 0; j < N; j++) {\n                if (j == i) continue;\n                if (intersect(walls[j], current, next)) {\n                    crosses++;\n                }\n            }\n            \n            if (crosses == 0) {\n                visited[i] = 1;\n                queue[rear] = next;\n                wallsCrossed[rear] = currentWalls + 1;\n                rear++;\n            }\n        }\n    }\n    \n    free(visited);\n    return (min == INT_MAX) ? -1 : min;\n}\n\nint main() {\n    scanf(\"%d %d\", &W, &H);\n    scanf(\"%d %d\", &start.x, &start.y);\n    scanf(\"%d %d\", &end.x, &end.y);\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d\", &walls[i].x1, &walls[i].y1, &walls[i].x2, &walls[i].y2);\n    }\n    \n    int result = minWalls();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:42:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class WallCrossing {\n    static int W, H, N;\n    static List<Wall> horizontalWalls = new ArrayList<>();\n    static List<Wall> verticalWalls = new ArrayList<>();\n\n    static class Wall {\n        int start, end, pos;\n        boolean isHorizontal;\n\n        Wall(int start, int end, int pos, boolean isHorizontal) {\n            this.start = start;\n            this.end = end;\n            this.pos = pos;\n            this.isHorizontal = isHorizontal;\n        }\n    }\n\n    static class State {\n        int x, y, crosses;\n\n        State(int x, int y, int crosses) {\n            this.x = x;\n            this.y = y;\n            this.crosses = crosses;\n        }\n    }\n\n    public static int minimumWallCrossings(int startX, int startY, int endX, int endY) {\n        boolean[][] visited = new boolean[W + 1][H + 1];\n        Queue<State> queue = new LinkedList<>();\n        queue.offer(new State(startX, startY, 0));\n        visited[startX][startY] = true;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.x == endX && current.y == endY) {\n                return current.crosses;\n            }\n\n            int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n            for (int[] dir : directions) {\n                int newX = current.x + dir[0];\n                int newY = current.y + dir[1];\n\n                if (newX < 0 || newX > W || newY < 0 || newY > H || visited[newX][newY]) {\n                    continue;\n                }\n\n                int wallCrosses = calculateWallCrosses(current.x, current.y, newX, newY);\n                if (wallCrosses != -1) {\n                    queue.offer(new State(newX, newY, current.crosses + wallCrosses));\n                    visited[newX][newY] = true;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    static int calculateWallCrosses(int x1, int y1, int x2, int y2) {\n        int crosses = 0;\n\n        for (Wall wall : horizontalWalls) {\n            if ((x1 < wall.pos && x2 > wall.pos) || (x1 > wall.pos && x2 < wall.pos)) {\n                if ((y1 <= wall.start && y2 >= wall.end) || (y1 >= wall.end && y2 <= wall.start)) {\n                    crosses++;\n                }\n            }\n        }\n\n        for (Wall wall : verticalWalls) {\n            if ((y1 < wall.pos && y2 > wall.pos) || (y1 > wall.pos && y2 < wall.pos)) {\n                if ((x1 <= wall.start && x2 >= wall.end) || (x1 >= wall.end && x2 <= wall.start)) {\n                    crosses++;\n                }\n            }\n        }\n\n        return crosses > 0 ? crosses : -1;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        W = 10; H = 10; N = 3;\n        horizontalWalls.add(new Wall(2, 7, 3, true));\n        verticalWalls.add(new Wall(3, 8, 5, false));\n        horizontalWalls.add(new Wall(6, 9, 7, true));\n\n        int result = minimumWallCrossings(1, 1, 9, 9);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 18:42:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\nstruct Wall {\n    Point p1, p2;\n    Wall(int x1, int y1, int x2, int y2) : p1(x1, y1), p2(x2, y2) {}\n};\n\nvector<Wall> walls;\nvector<int> x_coords, y_coords;\nint W, H, N;\n\nint compress_coord(vector<int>& coords, int val) {\n    return lower_bound(coords.begin(), coords.end(), val) - coords.begin();\n}\n\nvoid add_coord(int x, int y) {\n    x_coords.push_back(x);\n    y_coords.push_back(y);\n}\n\nvoid preprocess() {\n    sort(x_coords.begin(), x_coords.end());\n    sort(y_coords.begin(), y_coords.end());\n    x_coords.erase(unique(x_coords.begin(), x_coords.end()), x_coords.end());\n    y_coords.erase(unique(y_coords.begin(), y_coords.end()), y_coords.end());\n}\n\nbool is_on_wall(int x, int y) {\n    for (const Wall& wall : walls) {\n        if (wall.p1.x == wall.p2.x && x == wall.p1.x && ((wall.p1.y <= y && y <= wall.p2.y) || (wall.p2.y <= y && y <= wall.p1.y))) {\n            return true;\n        }\n        if (wall.p1.y == wall.p2.y && y == wall.p1.y && ((wall.p1.x <= x && x <= wall.p2.x) || (wall.p2.x <= x && x <= wall.p1.x))) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool is_intersection(int x, int y) {\n    int count = 0;\n    for (const Wall& wall : walls) {\n        if ((wall.p1.x == x && wall.p1.y == y) || (wall.p2.x == x && wall.p2.y == y)) {\n            count++;\n        }\n    }\n    return count >= 2;\n}\n\nint main() {\n    cin >> W >> H >> N;\n    Point start, end;\n    cin >> start.x >> start.y >> end.x >> end.y;\n    add_coord(start.x, start.y);\n    add_coord(end.x, end.y);\n\n    for (int i = 0; i < N; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        walls.emplace_back(x1, y1, x2, y2);\n        add_coord(x1, y1);\n        add_coord(x2, y2);\n    }\n\n    preprocess();\n\n    int gridW = x_coords.size() * 2 + 2;\n    int gridH = y_coords.size() * 2 + 2;\n    vector<vector<int>> dist(gridW, vector<int>(gridH, INT_MAX));\n    vector<vector<bool>> is_wall(gridW, vector<bool>(gridH, false));\n\n    for (int i = 0; i < gridW; ++i) {\n        for (int j = 0; j < gridH; ++j) {\n            int x = (i % 2 == 0) ? x_coords[i / 2] : (x_coords[i / 2] + x_coords[i / 2 + 1]) / 2;\n            int y = (j % 2 == 0) ? y_coords[j / 2] : (y_coords[j / 2] + y_coords[j / 2 + 1]) / 2;\n            if (x < 0 || x > W || y < 0 || y > H || is_on_wall(x, y) || is_intersection(x, y)) {\n                is_wall[i][j] = true;\n            }\n        }\n    }\n\n    int sx = compress_coord(x_coords, start.x) * 2;\n    int sy = compress_coord(y_coords, start.y) * 2;\n    int ex = compress_coord(x_coords, end.x) * 2;\n    int ey = compress_coord(y_coords, end.y) * 2;\n\n    dist[sx][sy] = 0;\n    queue<Point> q;\n    q.push(Point(sx, sy));\n\n    int dx[] = {1, -1, 0, 0};\n    int dy[] = {0, 0, 1, -1};\n\n    while (!q.empty()) {\n        Point p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            if (nx < 0 || nx >= gridW || ny < 0 || ny >= gridH || is_wall[nx][ny]) {\n                continue;\n            }\n            int wall_cross = 0;\n            if (i < 2) {\n                int x1 = min(p.x, nx);\n                int x2 = max(p.x, nx);\n                for (const Wall& wall : walls) {\n                    if (wall.p1.y == wall.p2.y) {\n                        int wy = compress_coord(y_coords, wall.p1.y) * 2;\n                        if (wy == p.y && ((wall.p1.x <= x_coords[p.x/2] && x_coords[p.x/2] <= wall.p2.x) || (wall.p2.x <= x_coords[p.x/2] && x_coords[p.x/2] <= wall.p1.x))) {\n                            wall_cross++;\n                        }\n                    }\n                }\n            } else {\n                int y1 = min(p.y, ny);\n                int y2 = max(p.y, ny);\n                for (const Wall& wall : walls) {\n                    if (wall.p1.x == wall.p2.x) {\n                        int wx = compress_coord(x_coords, wall.p1.x) * 2;\n                        if (wx == p.x && ((wall.p1.y <= y_coords[p.y/2] && y_coords[p.y/2] <= wall.p2.y) || (wall.p2.y <= y_coords[p.y/2] && y_coords[p.y/2] <= wall.p1.y))) {\n                            wall_cross++;\n                        }\n                    }\n                }\n            }\n            if (dist[nx][ny] > dist[p.x][p.y] + wall_cross) {\n                dist[nx][ny] = dist[p.x][p.y] + wall_cross;\n                q.push(Point(nx, ny));\n            }\n        }\n    }\n\n    cout << dist[ex][ey] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_W 100\n#define MAX_H 100\n#define MAX_WALLS 50\n\ntypedef struct {\n    int x1, y1, x2, y2;\n    int is_horizontal;\n} Wall;\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int walls_crossed;\n} QueueItem;\n\nint W, H, N;\nWall walls[MAX_WALLS];\nint visited[MAX_W][MAX_H];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint is_valid_point(int x, int y) {\n    return x >= 0 && x < W && y >= 0 && y < H;\n}\n\nint wall_intersect(int x, int y, int nx, int ny) {\n    for (int i = 0; i < N; i++) {\n        Wall w = walls[i];\n        if (w.is_horizontal) {\n            if (w.y1 == y && ((x < w.x1 && nx >= w.x1) || (x > w.x1 && nx <= w.x1)))\n                return 1;\n            if (w.y1 == ny && ((x < w.x1 && nx >= w.x1) || (x > w.x1 && nx <= w.x1)))\n                return 1;\n        } else {\n            if (w.x1 == x && ((y < w.y1 && ny >= w.y1) || (y > w.y1 && ny <= w.y1)))\n                return 1;\n            if (w.x1 == nx && ((y < w.y1 && ny >= w.y1) || (y > w.y1 && ny <= w.y1)))\n                return 1;\n        }\n    }\n    return 0;\n}\n\nint bfs(Point start, Point end) {\n    memset(visited, 0, sizeof(visited));\n    \n    QueueItem queue[MAX_W * MAX_H];\n    int front = 0, rear = 0;\n    \n    queue[rear].pos = start;\n    queue[rear].walls_crossed = 0;\n    visited[start.x][start.y] = 1;\n    rear++;\n    \n    while (front < rear) {\n        QueueItem current = queue[front++];\n        \n        if (current.pos.x == end.x && current.pos.y == end.y)\n            return current.walls_crossed;\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = current.pos.x + dx[i];\n            int ny = current.pos.y + dy[i];\n            \n            if (!is_valid_point(nx, ny) || visited[nx][ny])\n                continue;\n            \n            int walls_crossed = current.walls_crossed;\n            if (wall_intersect(current.pos.x, current.pos.y, nx, ny))\n                walls_crossed++;\n            \n            queue[rear].pos.x = nx;\n            queue[rear].pos.y = ny;\n            queue[rear].walls_crossed = walls_crossed;\n            visited[nx][ny] = 1;\n            rear++;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &W, &H, &N);\n    \n    for (int i = 0; i < N; i++) {\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        \n        walls[i].x1 = x1;\n        walls[i].y1 = y1;\n        walls[i].x2 = x2;\n        walls[i].y2 = y2;\n        walls[i].is_horizontal = (y1 == y2);\n    }\n    \n    Point start, end;\n    scanf(\"%d %d %d %d\", &start.x, &start.y, &end.x, &end.y);\n    \n    int result = bfs(start, end);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    int walls_crossed;\n};\n\nint bfs(int W, int H, vector<pair<int, int>>& horizontal_walls, vector<pair<int, int>>& vertical_walls, int sx, int sy, int ex, int ey) {\n    vector<vector<bool>> visited(W + 1, vector<bool>(H + 1, false));\n    queue<Point> q;\n    q.push({sx, sy, 0});\n    visited[sx][sy] = true;\n\n    int dx[] = {1, -1, 0, 0};\n    int dy[] = {0, 0, 1, -1};\n\n    while (!q.empty()) {\n        Point curr = q.front();\n        q.pop();\n\n        if (curr.x == ex && curr.y == ey) return curr.walls_crossed;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = curr.x + dx[i];\n            int ny = curr.y + dy[i];\n\n            if (nx < 0 || nx > W || ny < 0 || ny > H || visited[nx][ny]) continue;\n\n            int walls_crossed = curr.walls_crossed;\n            bool can_move = true;\n\n            // Check horizontal wall crossing\n            for (auto& wall : horizontal_walls) {\n                if ((curr.y == wall.first && min(curr.x, nx) < wall.second && max(curr.x, nx) > wall.second) ||\n                    (curr.y == wall.first && curr.x == wall.second && ny == wall.first + 1) ||\n                    (curr.y == wall.first && curr.x == wall.second && ny == wall.first - 1)) {\n                    walls_crossed++;\n                }\n            }\n\n            // Check vertical wall crossing\n            for (auto& wall : vertical_walls) {\n                if ((curr.x == wall.first && min(curr.y, ny) < wall.second && max(curr.y, ny) > wall.second) ||\n                    (curr.x == wall.first && curr.y == wall.second && nx == wall.first + 1) ||\n                    (curr.x == wall.first && curr.y == wall.second && nx == wall.first - 1)) {\n                    walls_crossed++;\n                }\n            }\n\n            q.push({nx, ny, walls_crossed});\n            visited[nx][ny] = true;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int W, H, N, M;\n    cin >> W >> H >> N >> M;\n\n    vector<pair<int, int>> horizontal_walls(N);\n    vector<pair<int, int>> vertical_walls(M);\n\n    for (int i = 0; i < N; i++) {\n        cin >> horizontal_walls[i].first >> horizontal_walls[i].second;\n    }\n\n    for (int i = 0; i < M; i++) {\n        cin >> vertical_walls[i].first >> vertical_walls[i].second;\n    }\n\n    int sx, sy, ex, ey;\n    cin >> sx >> sy >> ex >> ey;\n\n    int result = bfs(W, H, horizontal_walls, vertical_walls, sx, sy, ex, ey);\n    cout << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nclass Wall {\n    int x1, y1, x2, y2;\n    Wall(int x1, int y1, int x2, int y2) {\n        this.x1 = Math.min(x1, x2);\n        this.y1 = Math.min(y1, y2);\n        this.x2 = Math.max(x1, x2);\n        this.y2 = Math.max(y1, y2);\n    }\n}\n\npublic class Main {\n    static int W, H, N;\n    static Point start, end;\n    static List<Wall> walls = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        W = sc.nextInt();\n        H = sc.nextInt();\n        N = sc.nextInt();\n        start = new Point(sc.nextInt(), sc.nextInt());\n        end = new Point(sc.nextInt(), sc.nextInt());\n\n        for (int i = 0; i < N; i++) {\n            int x1 = sc.nextInt();\n            int y1 = sc.nextInt();\n            int x2 = sc.nextInt();\n            int y2 = sc.nextInt();\n            walls.add(new Wall(x1, y1, x2, y2));\n        }\n\n        System.out.println(bfs());\n    }\n\n    static int bfs() {\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        Map<String, Integer> visited = new HashMap<>();\n        pq.offer(new int[]{start.x, start.y, 0});\n        visited.put(start.x + \",\" + start.y, 0);\n\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int x = curr[0], y = curr[1], cost = curr[2];\n            if (x == end.x && y == end.y) {\n                return cost;\n            }\n\n            for (int[] dir : dirs) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (nx < 0 || nx > W || ny < 0 || ny > H) continue;\n                if (onWallOrBoundary(nx, ny)) continue;\n\n                int newCost = cost;\n                if (crossWall(x, y, nx, ny)) {\n                    newCost++;\n                }\n\n                String key = nx + \",\" + ny;\n                if (!visited.containsKey(key) || visited.get(key) > newCost) {\n                    visited.put(key, newCost);\n                    pq.offer(new int[]{nx, ny, newCost});\n                }\n            }\n        }\n        return -1;\n    }\n\n    static boolean onWallOrBoundary(int x, int y) {\n        if (x == 0 || x == W || y == 0 || y == H) return true;\n        for (Wall wall : walls) {\n            if (wall.x1 == wall.x2) {\n                if (x == wall.x1 && y >= wall.y1 && y <= wall.y2) return true;\n            } else {\n                if (y == wall.y1 && x >= wall.x1 && x <= wall.x2) return true;\n            }\n        }\n        return false;\n    }\n\n    static boolean crossWall(int x1, int y1, int x2, int y2) {\n        int minX = Math.min(x1, x2);\n        int maxX = Math.max(x1, x2);\n        int minY = Math.min(y1, y2);\n        int maxY = Math.max(y1, y2);\n\n        for (Wall wall : walls) {\n            if (wall.x1 == wall.x2) {\n                if (wall.x1 > minX && wall.x1 < maxX && y1 >= wall.y1 && y1 <= wall.y2) {\n                    return true;\n                }\n            } else {\n                if (wall.y1 > minY && wall.y1 < maxY && x1 >= wall.x1 && x1 <= wall.x2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 18:46:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef minimum_walls_to_cross(W, H, start, end, walls):\n    # We'll use a form of BFS with positions as nodes and transitions between them as edges\n    def is_legal_move(x, y):\n        # Check if position is within bounds and not on a wall\n        if not (0 < x < W and 0 < y < H):  # Check boundaries\n            return False\n        for (wx1, wy1, wx2, wy2) in walls:\n            if wx1 == wx2 and wx1 == x:  # Vertical wall\n                if min(wy1, wy2) <= y <= max(wy1, wy2):\n                    return False\n            elif wy1 == wy2 and wy1 == y:  # Horizontal wall\n                if min(wx1, wx2) <= x <= max(wx1, wx2):\n                    return False\n        return True\n\n    # Function to find neighbours accounting for walls\n    def get_neighbours(x, y):\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if is_legal_move(nx, ny):\n                yield nx, ny\n\n    # BFS implementation\n    def bfs(start, end):\n        queue = deque([(start[0], start[1], 0)])  # (x, y, crossed_walls_count)\n        visited = set()\n        visited.add((start[0], start[1]))\n        \n        while queue:\n            x, y, walls_crossed = queue.popleft()\n            if (x, y) == (end[0], end[1]):\n                return walls_crossed\n            \n            for nx, ny in get_neighbours(x, y):\n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    # Check if we cross a wall\n                    additional_walls_crossed = 0\n                    for (wx1, wy1, wx2, wy2) in walls:\n                        if wx1 == wx2: # Vertical wall\n                            if min(y, ny) <= max(wy1, wy2) and max(y, ny) >= min(wy1, wy2) and min(x, nx) < wx1 < max(x, nx):\n                                additional_walls_crossed = 1\n                        elif wy1 == wy2: # Horizontal wall\n                            if min(x, nx) <= max(wx1, wx2) and max(x, nx) >= min(wx1, wx2) and min(y, ny) < wy1 < max(y, ny):\n                                additional_walls_crossed = 1\n                    queue.append((nx, ny, walls_crossed + additional_walls_crossed))\n        return -1\n\n    return bfs(start, end)\n\n# Example usage:\nW, H = 10, 10\nstart = (1, 1)\nend = (8, 8)\nwalls = [(2, 0, 2, 5), (3, 5, 10, 5), (5, 0, 5, 10)]\nprint(minimum_walls_to_cross(W, H, start, end, walls))",
    "timestamp": "2025-08-13 00:34:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WallCrossing {\n\n    static class Point {\n        int x, y, crossedWalls;\n\n        Point(int x, int y, int crossedWalls) {\n            this.x = x;\n            this.y = y;\n            this.crossedWalls = crossedWalls;\n        }\n    }\n\n    public static void main(String[] args) {\n        int W = 10;  // Activity area width\n        int H = 10;  // Activity area height\n\n        List<int[]> walls = Arrays.asList(\n            new int[]{2, 2, 8, 2}, // x1, y1, x2, y2 format\n            new int[]{2, 2, 2, 8},\n            new int[]{8, 2, 8, 8},\n            new int[]{2, 8, 8, 8}\n        );\n\n        Point start = new Point(3, 3, 0);\n        Point end = new Point(7, 7, 0);\n\n        System.out.println(minWallsToCross(W, H, walls, start, end));\n    }\n\n    static int minWallsToCross(int W, int H, List<int[]> walls, Point start, Point end) {\n        int[][] grid = new int[W + 1][H + 1];\n        for (int[] wall : walls) {\n            if (wall[0] == wall[2]) {\n                for (int i = Math.min(wall[1], wall[3]); i <= Math.max(wall[1], wall[3]); i++) {\n                    grid[wall[0]][i] = -1; // Mark vertical wall\n                }\n            } else {\n                for (int i = Math.min(wall[0], wall[2]); i <= Math.max(wall[0], wall[2]); i++) {\n                    grid[i][wall[1]] = -1; // Mark horizontal wall\n                }\n            }\n        }\n\n        int[] dx = {0, 0, 1, -1};\n        int[] dy = {1, -1, 0, 0};\n\n        Queue<Point> queue = new LinkedList<>();\n        queue.add(start);\n        boolean[][] visited = new boolean[W + 1][H + 1];\n        visited[start.x][start.y] = true;\n\n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n\n            if (current.x == end.x && current.y == end.y) {\n                return current.crossedWalls;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int nx = current.x + dx[d];\n                int ny = current.y + dy[d];\n\n                if (nx >= 0 && nx <= W && ny >= 0 && ny <= H && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n\n                    if (grid[nx][ny] == -1) {\n                        queue.add(new Point(nx, ny, current.crossedWalls + 1));\n                    } else {\n                        queue.add(new Point(nx, ny, current.crossedWalls));\n                    }\n                }\n            }\n        }\n\n        return -1; // If the end point is unreachable\n    }\n}",
    "timestamp": "2025-08-13 00:34:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Wall;\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point *points;\n    int size;\n    int capacity;\n} PointList;\n\ntypedef struct {\n    Point point;\n    int cost;\n} Node;\n\ntypedef struct {\n    Node *nodes;\n    int size;\n    int capacity;\n} PriorityQueue;\n\nvoid addPoint(PointList *list, int x, int y) {\n    if (list->size >= list->capacity) {\n        list->capacity *= 2;\n        list->points = realloc(list->points, list->capacity * sizeof(Point));\n    }\n    list->points[list->size++] = (Point){ x, y };\n}\n\nbool isOnWall(Point p, Wall wall) {\n    if (wall.x1 == wall.x2) {\n        return p.x == wall.x1 && wall.y1 <= p.y && p.y <= wall.y2;\n    } else {\n        return p.y == wall.y1 && wall.x1 <= p.x && p.x <= wall.x2;\n    }\n}\n\nbool canMove(Point current, Point next, Wall *walls, int numWalls) {\n    for (int i = 0; i < numWalls; i++) {\n        if (isOnWall(next, walls[i])) return false;\n    }\n    return true;\n}\n\nint crossCount(Point current, Point next, Wall *walls, int numWalls) {\n    int count = 0;\n    for (int i = 0; i < numWalls; i++) {\n        if ((isOnWall(current, walls[i]) && !isOnWall(next, walls[i])) ||\n            (!isOnWall(current, walls[i]) && isOnWall(next, walls[i]))) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid addNode(PriorityQueue *pq, Point point, int cost) {\n    if (pq->size >= pq->capacity) {\n        pq->capacity *= 2;\n        pq->nodes = realloc(pq->nodes, pq->capacity * sizeof(Node));\n    }\n    pq->nodes[pq->size++] = (Node){ point, cost };\n}\n\nvoid popNode(PriorityQueue *pq, Node *node) {\n    int minCostIndex = 0;\n    for (int i = 1; i < pq->size; i++) {\n        if (pq->nodes[i].cost < pq->nodes[minCostIndex].cost) {\n            minCostIndex = i;\n        }\n    }\n    *node = pq->nodes[minCostIndex];\n    pq->nodes[minCostIndex] = pq->nodes[--pq->size];\n}\n\nbool isValid(Point p, int width, int height, Wall *walls, int numWalls) {\n    if (p.x <= 0 || p.x >= width || p.y <= 0 || p.y >= height) return false;\n    for (int i = 0; i < numWalls; i++) {\n        if (isOnWall(p, walls[i])) return false;\n    }\n    return true;\n}\n\nint calculateMinCross(Point start, Point end, int width, int height, Wall *walls, int numWalls) {\n    PriorityQueue queue = { malloc(10 * sizeof(Node)), 0, 10 };\n    addNode(&queue, start, 0);\n\n    while (queue.size > 0) {\n        Node current;\n        popNode(&queue, &current);\n        if (current.point.x == end.x && current.point.y == end.y) {\n            free(queue.nodes);\n            return current.cost;\n        }\n\n        PointList neighbors = { malloc(4 * sizeof(Point)), 0, 4 };\n        int directions[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        for (int i = 0; i < 4; i++) {\n            Point next = { current.point.x + directions[i][0], current.point.y + directions[i][1] };\n            if (isValid(next, width, height, walls, numWalls)) {\n                addPoint(&neighbors, next.x, next.y);\n            }\n        }\n\n        for (int i = 0; i < neighbors.size; i++) {\n            Point next = neighbors.points[i];\n            if (canMove(current.point, next, walls, numWalls)) {\n                int cost = current.cost + crossCount(current.point, next, walls, numWalls);\n                addNode(&queue, next, cost);\n            }\n        }\n\n        free(neighbors.points);\n    }\n\n    free(queue.nodes);\n    return -1;\n}\n\nint main() {\n    int W, H, n;\n    scanf(\"%d %d %d\", &W, &H, &n);\n\n    Wall walls[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &walls[i].x1, &walls[i].y1, &walls[i].x2, &walls[i].y2);\n    }\n\n    Point start, end;\n    scanf(\"%d %d %d %d\", &start.x, &start.y, &end.x, &end.y);\n\n    int result = calculateMinCross(start, end, W, H, walls, n);\n    printf(\"Minimum walls crossed: %d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 00:34:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve(W, H, walls, start, end):\n    # Convert walls to sets for efficient lookup\n    x_walls = set()\n    y_walls = set()\n    for wall in walls:\n        if wall[0] == wall[2]:  # vertical wall\n            y_walls.add((wall[0], min(wall[1], wall[3]), max(wall[1], wall[3])))\n        else:  # horizontal wall\n            x_walls.add((wall[1], min(wall[0], wall[2]), max(wall[0], wall[2])))\n\n    def is_blocked(x1, y1, x2, y2):\n        # Check if path between two points is blocked\n        if x1 == x2:  # vertical path\n            for y_wall in y_walls:\n                if y_wall[0] == x1 and min(y1, y2) < y_wall[2] and max(y1, y2) > y_wall[1]:\n                    return True\n        else:  # horizontal path\n            for x_wall in x_walls:\n                if x_wall[0] == y1 and min(x1, x2) < x_wall[2] and max(x1, x2) > x_wall[1]:\n                    return True\n        return False\n\n    # BFS to find minimum wall crossings\n    queue = deque([(start[0], start[1], 0)])\n    visited = set([(start[0], start[1])])\n\n    while queue:\n        x, y, crossings = queue.popleft()\n\n        if x == end[0] and y == end[1]:\n            return crossings\n\n        # 4 possible directions\n        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n            nx, ny = x + dx, y + dy\n\n            # Check bounds\n            if 0 <= nx <= W and 0 <= ny <= H and (nx, ny) not in visited:\n                # Check if path is blocked\n                if not is_blocked(x, y, nx, ny):\n                    queue.append((nx, ny, crossings))\n                    visited.add((nx, ny))\n                else:\n                    queue.append((nx, ny, crossings + 1))\n                    visited.add((nx, ny))\n\n    return -1  # No path found",
    "timestamp": "2025-08-13 00:34:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    W, H = map(int, input().split())\n    N = int(input())\n    walls = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            # Vertical wall\n            walls.append(('v', x1, min(y1, y2), max(y1, y2)))\n        else:\n            # Horizontal wall\n            walls.append(('h', y1, min(x1, x2), max(x1, x2)))\n    sx, sy = map(int, input().split())\n    ex, ey = map(int, input().split())\n    \n    # We'll use Dijkstra's algorithm, treating crossing walls as edges with cost 1\n    # The state is (x, y), and the priority is the number of walls crossed\n    # To avoid revisiting, we can keep track of the minimal walls crossed for each (x, y)\n    \n    # Initialize distances\n    INF = float('inf')\n    dist = {}\n    heap = []\n    heapq.heappush(heap, (0, sx, sy))\n    dist[(sx, sy)] = 0\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    while heap:\n        current_dist, x, y = heapq.heappop(heap)\n        if (x, y) == (ex, ey):\n            print(current_dist)\n            return\n        if current_dist > dist.get((x, y), INF):\n            continue\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= W and 0 <= ny <= H:\n                # Check if moving to (nx, ny) crosses any walls\n                walls_crossed = 0\n                for wall in walls:\n                    if wall[0] == 'v':\n                        # Vertical wall\n                        x_wall = wall[1]\n                        y_min = wall[2]\n                        y_max = wall[3]\n                        if min(x, nx) < x_wall < max(x, nx) and y_min < max(y, ny) and min(y, ny) < y_max:\n                            walls_crossed += 1\n                    else:\n                        # Horizontal wall\n                        y_wall = wall[1]\n                        x_min = wall[2]\n                        x_max = wall[3]\n                        if min(y, ny) < y_wall < max(y, ny) and x_min < max(x, nx) and min(x, nx) < x_max:\n                            walls_crossed += 1\n                new_dist = current_dist + walls_crossed\n                if new_dist < dist.get((nx, ny), INF):\n                    dist[(nx, ny)] = new_dist\n                    heapq.heappush(heap, (new_dist, nx, ny))\n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 00:35:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nstruct Point {\n    int x, y;\n};\n\nstruct Wall {\n    int x1, y1, x2, y2;\n};\n\nbool is_on_wall(const Point& p, const Wall& wall) {\n    if ((wall.x1 == wall.x2) && (p.x == wall.x1) && (p.y >= std::min(wall.y1, wall.y2)) && (p.y <= std::max(wall.y1, wall.y2))) {\n        return true;\n    }\n    if ((wall.y1 == wall.y2) && (p.y == wall.y1) && (p.x >= std::min(wall.x1, wall.x2)) && (p.x <= std::max(wall.x1, wall.x2))) {\n        return true;\n    }\n    return false;\n}\n\nbool crosses_wall(const Point& p1, const Point& p2, const Wall& wall) {\n    if (wall.x1 == wall.x2) { // Vertical wall\n        if ((p1.x < wall.x1 && p2.x > wall.x1) || (p1.x > wall.x1 && p2.x < wall.x1)) {\n            return (p1.y >= std::min(wall.y1, wall.y2) && p1.y <= std::max(wall.y1, wall.y2)) ||\n                   (p2.y >= std::min(wall.y1, wall.y2) && p2.y <= std::max(wall.y1, wall.y2));\n        }\n    } else { // Horizontal wall\n        if ((p1.y < wall.y1 && p2.y > wall.y1) || (p1.y > wall.y1 && p2.y < wall.y1)) {\n            return (p1.x >= std::min(wall.x1, wall.x2) && p1.x <= std::max(wall.x1, wall.x2)) ||\n                   (p2.x >= std::min(wall.x1, wall.x2) && p2.x <= std::max(wall.x1, wall.x2));\n        }\n    }\n    return false;\n}\n\nint bfs_min_crosses(const Point& start, const Point& end, const std::vector<Wall>& walls, int W, int H) {\n    std::queue<std::tuple<Point, int>> q;\n    std::set<Point> visited;\n    q.push({start, 0});\n    visited.insert(start);\n    \n    while (!q.empty()) {\n        auto [current, crosses] = q.front();\n        q.pop();\n        \n        if (current.x == end.x && current.y == end.y) {\n            return crosses;\n        }\n        \n        std::vector<Point> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        for (auto& dir : directions) {\n            Point next = {current.x + dir.x, current.y + dir.y};\n            \n            if (next.x <= 0 || next.x >= W || next.y <= 0 || next.y >= H) continue;\n            if (visited.count(next) != 0) continue;\n            \n            bool valid_move = true;\n            for (const auto& wall : walls) {\n                if (is_on_wall(next, wall) || crosses_wall(current, next, wall)) {\n                    valid_move = false;\n                    break;\n                }\n            }\n            \n            if (valid_move) {\n                visited.insert(next);\n                q.push({next, crosses});\n            } else {\n                visited.insert(next);\n                q.push({next, crosses + 1});\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    int W, H, startX, startY, endX, endY, numWalls;\n    std::cin >> W >> H >> startX >> startY >> endX >> endY >> numWalls;\n    std::vector<Wall> walls(numWalls);\n    for (int i = 0; i < numWalls; ++i) {\n        std::cin >> walls[i].x1 >> walls[i].y1 >> walls[i].x2 >> walls[i].y2;\n    }\n    \n    Point start = {startX, startY};\n    Point end = {endX, endY};\n    int result = bfs_min_crosses(start, end, walls, W, H);\n    std::cout << result << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:54:56"
  }
]