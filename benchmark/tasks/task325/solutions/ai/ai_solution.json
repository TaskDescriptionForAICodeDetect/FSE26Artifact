[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Line;\n\nint main() {\n    int A_x, A_y, B_x, B_y;\n    scanf(\"%d %d %d %d\", &A_x, &A_y, &B_x, &B_y);\n\n    int N;\n    scanf(\"%d\", &N);\n\n    Line *lines = malloc(N * sizeof(Line));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d %d\", &lines[i].x1, &lines[i].y1, &lines[i].x2, &lines[i].y2);\n    }\n\n    int count = 0;\n    for (int i = 0; i < N; i++) {\n        int x1 = lines[i].x1, y1 = lines[i].y1;\n        int x2 = lines[i].x2, y2 = lines[i].y2;\n\n        int ccw1 = (B_x - A_x) * (y1 - A_y) - (B_y - A_y) * (x1 - A_x);\n        int ccw2 = (B_x - A_x) * (y2 - A_y) - (B_y - A_y) * (x2 - A_x);\n        int ccw3 = (x2 - x1) * (A_y - y1) - (y2 - y1) * (A_x - x1);\n        int ccw4 = (x2 - x1) * (B_y - y1) - (y2 - y1) * (B_x - x1);\n\n        if ((ccw1 * ccw2 < 0) && (ccw3 * ccw4 < 0)) {\n            count++;\n        }\n    }\n\n    printf(\"%d\\n\", (count / 2) + 1);\n\n    free(lines);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\nstruct Segment {\n    Point p1, p2;\n};\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y))\n        return true;\n    return false;\n}\n\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nbool doIntersect(Segment s1, Segment s2) {\n    Point p1 = s1.p1, q1 = s1.p2;\n    Point p2 = s2.p1, q2 = s2.p2;\n\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Segment> existing(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> existing[i].p1.x >> existing[i].p1.y >> existing[i].p2.x >> existing[i].p2.y;\n    }\n\n    Point A, B;\n    cin >> A.x >> A.y >> B.x >> B.y;\n    Segment newRoute = {A, B};\n\n    set<Point> intersections;\n    for (const auto& seg : existing) {\n        if (doIntersect(newRoute, seg)) {\n            int x1 = seg.p1.x, y1 = seg.p1.y;\n            int x2 = seg.p2.x, y2 = seg.p2.y;\n            int x3 = A.x, y3 = A.y;\n            int x4 = B.x, y4 = B.y;\n\n            int den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n            if (den == 0) continue;\n\n            double t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / (double)den;\n            double u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / (double)den;\n\n            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n                int x = x1 + t * (x2 - x1);\n                int y = y1 + t * (y2 - y1);\n                intersections.insert({x, y});\n            }\n        }\n    }\n\n    cout << intersections.size() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:05:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RailwayEntrances {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Line {\n        Point a, b;\n        Line(Point a, Point b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<Line> existingLines = new ArrayList<>();\n        List<Line> newLines = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            existingLines.add(new Line(new Point(x1, y1), new Point(x2, y2)));\n        }\n\n        for (int i = 0; i < M; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int x2 = scanner.nextInt();\n            int y2 = scanner.nextInt();\n            newLines.add(new Line(new Point(x1, y1), new Point(x2, y2)));\n        }\n\n        int result = 1;\n        for (Line newLine : newLines) {\n            for (Line existingLine : existingLines) {\n                if (doIntersect(newLine.a, newLine.b, existingLine.a, existingLine.b)) {\n                    result++;\n                    break;\n                }\n            }\n        }\n        System.out.println(result);\n    }\n\n    static boolean onSegment(Point p, Point q, Point r) {\n        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&\n               q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n    }\n\n    static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0;\n        return (val > 0) ? 1 : 2;\n    }\n\n    static boolean doIntersect(Point p1, Point q1, Point p2, Point q2) {\n        int o1 = orientation(p1, q1, p2);\n        int o2 = orientation(p1, q1, q2);\n        int o3 = orientation(p2, q2, p1);\n        int o4 = orientation(p2, q2, q1);\n\n        if (o1 != o2 && o3 != o4) return true;\n\n        if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n        if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n        if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n        if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 21:06:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RailwayRouting {\n    static class Line {\n        int x1, y1, x2, y2;\n        public Line(int x1, int y1, int x2, int y2) {\n            this.x1 = Math.min(x1, x2);\n            this.y1 = Math.min(y1, y2);\n            this.x2 = Math.max(x1, x2);\n            this.y2 = Math.max(y1, y2);\n        }\n    }\n\n    public static int minimumEntrances(int startX, int startY, int endX, int endY, List<Line> existingLines) {\n        int entrances = 0;\n        \n        for (Line line : existingLines) {\n            if (lineIntersect(startX, startY, endX, endY, line.x1, line.y1, line.x2, line.y2)) {\n                entrances++;\n            }\n        }\n        \n        return entrances;\n    }\n\n    private static boolean lineIntersect(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {\n        int o1 = orientation(x1, y1, x2, y2, x3, y3);\n        int o2 = orientation(x1, y1, x2, y2, x4, y4);\n        int o3 = orientation(x3, y3, x4, y4, x1, y1);\n        int o4 = orientation(x3, y3, x4, y4, x2, y2);\n\n        if (o1 != o2 && o3 != o4) return true;\n        \n        if (o1 == 0 && onSegment(x1, y1, x3, y3, x2, y2)) return true;\n        if (o2 == 0 && onSegment(x1, y1, x4, y4, x2, y2)) return true;\n        if (o3 == 0 && onSegment(x3, y3, x1, y1, x4, y4)) return true;\n        if (o4 == 0 && onSegment(x3, y3, x2, y2, x4, y4)) return true;\n\n        return false;\n    }\n\n    private static int orientation(int x1, int y1, int x2, int y2, int x3, int y3) {\n        int val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2);\n        if (val == 0) return 0;\n        return val > 0 ? 1 : 2;\n    }\n\n    private static boolean onSegment(int x1, int y1, int x2, int y2, int x3, int y3) {\n        return x2 <= Math.max(x1, x3) && x2 >= Math.min(x1, x3) &&\n               y2 <= Math.max(y1, y3) && y2 >= Math.min(y1, y3);\n    }\n\n    public static void main(String[] args) {\n        List<Line> existingLines = new ArrayList<>();\n        existingLines.add(new Line(1, 1, 5, 5));\n        existingLines.add(new Line(3, 2, 7, 6));\n\n        int result = minimumEntrances(0, 0, 8, 8, existingLines);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:06:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_LINES 1000\n#define MAX_POINTS 10000\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point start, end;\n    bool is_elevated;\n} RailLine;\n\nint compare_points(const void* a, const void* b) {\n    Point* p1 = (Point*)a;\n    Point* p2 = (Point*)b;\n    return p1->x - p2->x;\n}\n\nbool lines_intersect(RailLine* line1, RailLine* line2) {\n    int x1 = line1->start.x, y1 = line1->start.y;\n    int x2 = line1->end.x, y2 = line1->end.y;\n    int x3 = line2->start.x, y3 = line2->start.y;\n    int x4 = line2->end.x, y4 = line2->end.y;\n\n    int denom = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));\n    if (denom == 0) return false;\n\n    double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n    double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\n\n    return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);\n}\n\nint calculate_entrances(RailLine* new_route, RailLine* existing_lines, int num_lines) {\n    int entrances = 0;\n    Point intersections[MAX_POINTS];\n    int num_intersections = 0;\n\n    for (int i = 0; i < num_lines; i++) {\n        if (lines_intersect(new_route, &existing_lines[i])) {\n            Point intersection;\n            // Calculate actual intersection point calculation would go here\n            intersections[num_intersections++] = intersection;\n        }\n    }\n\n    qsort(intersections, num_intersections, sizeof(Point), compare_points);\n\n    for (int i = 1; i < num_intersections; i++) {\n        if (intersections[i].x != intersections[i-1].x) {\n            entrances++;\n        }\n    }\n\n    return entrances + 1;\n}\n\nint main() {\n    int num_lines;\n    RailLine new_route, existing_lines[MAX_LINES];\n\n    // Input new route coordinates\n    scanf(\"%d %d %d %d\", &new_route.start.x, &new_route.start.y, \n                         &new_route.end.x, &new_route.end.y);\n\n    // Input number of existing lines\n    scanf(\"%d\", &num_lines);\n\n    // Input existing lines\n    for (int i = 0; i < num_lines; i++) {\n        scanf(\"%d %d %d %d %d\", &existing_lines[i].start.x, &existing_lines[i].start.y,\n                                &existing_lines[i].end.x, &existing_lines[i].end.y,\n                                &existing_lines[i].is_elevated);\n    }\n\n    int min_entrances = calculate_entrances(&new_route, existing_lines, num_lines);\n    printf(\"%d\\n\", min_entrances);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\nstruct Line {\n    int x1, y1, x2, y2;\n};\n\nint minimumEntrances(int A_x, int A_y, int B_x, int B_y, vector<Line>& existingLines) {\n    set<pair<int, int>> intersectionPoints;\n    \n    for (auto& line : existingLines) {\n        // Check line intersection\n        if ((line.x1 <= A_x && A_x <= line.x2 || line.x2 <= A_x && A_x <= line.x1) &&\n            (line.y1 <= A_y && A_y <= line.y2 || line.y2 <= A_y && A_y <= line.y1)) {\n            intersectionPoints.insert({line.x1, line.y1});\n            intersectionPoints.insert({line.x2, line.y2});\n        }\n    }\n    \n    return intersectionPoints.size();\n}\n\nint main() {\n    int A_x, A_y, B_x, B_y;\n    int n;\n    \n    cin >> A_x >> A_y >> B_x >> B_y;\n    cin >> n;\n    \n    vector<Line> existingLines(n);\n    \n    for (int i = 0; i < n; i++) {\n        cin >> existingLines[i].x1 >> existingLines[i].y1 \n            >> existingLines[i].x2 >> existingLines[i].y2;\n    }\n    \n    int result = minimumEntrances(A_x, A_y, B_x, B_y, existingLines);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_entrances(route_start, route_end, existing_lines):\n    def intersect(line1, line2):\n        # Simple intersection check for 2D lines\n        (x1, y1), (x2, y2) = line1\n        (x3, y3), (x4, y4) = line2\n\n        # Calculate determinants\n        det_line1 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        det_line1 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        \n        if det_line1 == 0:\n            return False\n        \n        t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / det_line1\n        u = ((x1 - x3) * (y1 - y2) - (y1 - y3) * (x1 - x2)) / det_line1\n\n        return 0 <= t <= 1 and 0 <= u <= 1\n    \n    route_line = (route_start, route_end)\n    intersections = 0\n\n    for line in existing_lines:\n        if intersect(route_line, line):\n            intersections += 1\n\n    return intersections + 1\n\n# Example usage:\nroute_start = (0, 0)\nroute_end = (10, 10)\nexisting_lines = [((5, 0), (5, 10)), ((0, 5), (10, 5))]\n\nprint(min_entrances(route_start, route_end, existing_lines))",
    "timestamp": "2025-08-13 04:56:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RailwayRoute {\n    static class Line {\n        int x1, y1, x2, y2;\n        \n        Line(int x1, int y1, int x2, int y2) {\n            this.x1 = x1;\n            this.y1 = y1;\n            this.x2 = x2;\n            this.y2 = y2;\n        }\n        \n        boolean intersects(Line other) {\n            int o1 = orientation(x1, y1, x2, y2, other.x1, other.y1);\n            int o2 = orientation(x1, y1, x2, y2, other.x2, other.y2);\n            int o3 = orientation(other.x1, other.y1, other.x2, other.y2, x1, y1);\n            int o4 = orientation(other.x1, other.y1, other.x2, other.y2, x2, y2);\n\n            if (o1 != o2 && o3 != o4) {\n                return true;\n            }\n\n            return (o1 == 0 && onSegment(x1, y1, other.x1, other.y1, x2, y2)) ||\n                   (o2 == 0 && onSegment(x1, y1, other.x2, other.y2, x2, y2)) ||\n                   (o3 == 0 && onSegment(other.x1, other.y1, x1, y1, other.x2, other.y2)) ||\n                   (o4 == 0 && onSegment(other.x1, other.y1, x2, y2, other.x2, other.y2));\n        }\n        \n        private int orientation(int x1, int y1, int x2, int y2, int x3, int y3) {\n            int val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2);\n            if (val == 0) return 0;  // collinear\n            return (val > 0) ? 1 : 2;  // clockwise or counterclockwise\n        }\n\n        private boolean onSegment(int x1, int y1, int x2, int y2, int x3, int y3) {\n            return x2 <= Math.max(x1, x3) && x2 >= Math.min(x1, x3) && y2 <= Math.max(y1, y3) && y2 >= Math.min(y1, y3);\n        }\n    }\n    \n    public static int minEntrances(int ax, int ay, int bx, int by, List<Line> existingLines) {\n        Line newRoute = new Line(ax, ay, bx, by);\n        int count = 0;\n        \n        for (Line line : existingLines) {\n            if (newRoute.intersects(line)) {\n                count++;\n            }\n        }\n        \n        return count + 1; // including entrance at starting block\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<Line> existingLines = Arrays.asList(\n            new Line(1, 1, 4, 4),\n            new Line(2, 3, 5, 3),\n            new Line(3, 2, 3, 6)\n        );\n        System.out.println(minEntrances(0, 0, 6, 6, existingLines));  // Output needed depends on given data\n    }\n}",
    "timestamp": "2025-08-13 04:56:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Line;\n\n// Function to check if two lines intersect\nint lines_intersect(Line new_route, Line existing_line) {\n    int orientation1 = (existing_line.x1 - new_route.x1) * (new_route.y2 - new_route.y1) - \n                       (existing_line.y1 - new_route.y1) * (new_route.x2 - new_route.x1);\n    int orientation2 = (existing_line.x2 - new_route.x1) * (new_route.y2 - new_route.y1) - \n                       (existing_line.y2 - new_route.y1) * (new_route.x2 - new_route.x1);\n    int orientation3 = (new_route.x1 - existing_line.x1) * (existing_line.y2 - existing_line.y1) - \n                       (new_route.y1 - existing_line.y1) * (existing_line.x2 - existing_line.x1);\n    int orientation4 = (new_route.x2 - existing_line.x1) * (existing_line.y2 - existing_line.y1) - \n                       (new_route.y2 - existing_line.y1) * (existing_line.x2 - existing_line.x1);\n\n    return (orientation1 * orientation2 < 0) && (orientation3 * orientation4 < 0);\n}\n\n// Function to determine minimum number of entrances needed\nint min_entrances(Line new_route, Line *existing_lines, int num_lines) {\n    int entrances_needed = 0;\n    for (int i = 0; i < num_lines; i++) {\n        if (lines_intersect(new_route, existing_lines[i])) {\n            entrances_needed++;\n        }\n    }\n    return entrances_needed;\n}\n\nint main() {\n    Line new_route = {0, 0, 10, 10}; // Example coordinates for the new route\n    Line existing_lines[] = {\n        {1, 1, 9, 9},\n        {2, 2, 8, 8},\n        {3, 3, 7, 7}\n    }; // Example existing lines\n    int num_lines = sizeof(existing_lines) / sizeof(existing_lines[0]);\n    \n    int result = min_entrances(new_route, existing_lines, num_lines);\n    printf(\"Minimum number of entrances needed: %d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:56:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_entrances(block_a, block_b, existing_lines):\n    def line_intersect(line1, line2):\n        x1, y1 = line1[0]\n        x2, y2 = line1[1]\n        x3, y3 = line2[0]\n        x4, y4 = line2[1]\n        \n        def ccw(a, b, c):\n            return (c[1]-a[1]) * (b[0]-a[0]) > (b[1]-a[1]) * (c[0]-a[0])\n        \n        return ccw(a, c, d) != ccw(b, c, d) and ccw(a, b, c) != ccw(a, b, d)\n    \n    def find_intersections(new_route):\n        intersections = 0\n        for line in existing_lines:\n            if line_intersect(new_route, line):\n                intersections += 1\n        return intersections\n    \n    # Define the new route\n    new_route = [block_a, block_b]\n    \n    # Count minimum entrances needed\n    return find_intersections(new_route)",
    "timestamp": "2025-08-13 04:56:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    A = tuple(map(int, input[ptr:ptr+2]))\n    ptr += 2\n    B = tuple(map(int, input[ptr:ptr+2]))\n    ptr += 2\n    \n    lines = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input[ptr:ptr+4])\n        ptr += 4\n        lines.append((x1, y1, x2, y2))\n    \n    # Check if A and B are the same point\n    if A == B:\n        print(0)\n        return\n    \n    # The problem reduces to counting the number of times the new line AB intersects existing lines\n    # Each intersection requires an entrance/exit\n    \n    def ccw(a, b, c):\n        # Cross product to determine the orientation of (a, b, c)\n        val = (b[0] - a[0])*(c[1] - a[1]) - (b[1] - a[1])*(c[0] - a[0])\n        if val == 0:\n            return 0  # colinear\n        return 1 if val > 0 else 2  # counter-clockwise or clockwise\n    \n    def intersect(a1, a2, b1, b2):\n        # Check if segment a1a2 intersects with segment b1b2\n        o1 = ccw(a1, a2, b1)\n        o2 = ccw(a1, a2, b2)\n        o3 = ccw(b1, b2, a1)\n        o4 = ccw(b1, b2, a2)\n        \n        if o1 != o2 and o3 != o4:\n            return True\n        \n        # Check for colinear cases\n        if o1 == 0 and on_segment(a1, b1, a2):\n            return True\n        if o2 == 0 and on_segment(a1, b2, a2):\n            return True\n        if o3 == 0 and on_segment(b1, a1, b2):\n            return True\n        if o4 == 0 and on_segment(b1, a2, b2):\n            return True\n        return False\n    \n    def on_segment(a, b, c):\n        # Check if point b lies on segment ac\n        if min(a[0], c[0]) <= b[0] <= max(a[0], c[0]) and min(a[1], c[1]) <= b[1] <= max(a[1], c[1]):\n            return True\n        return False\n    \n    count = 0\n    for line in lines:\n        x1, y1, x2, y2 = line\n        seg_start = (x1, y1)\n        seg_end = (x2, y2)\n        if intersect(A, B, seg_start, seg_end):\n            count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 04:57:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Line {\n    int x1, y1, x2, y2;\n};\n\nint minEntrances(int ax, int ay, int bx, int by, const std::vector<Line>& existingLines) {\n    int minX = std::min(ax, bx);\n    int maxX = std::max(ax, bx);\n    int minY = std::min(ay, by);\n    int maxY = std::max(ay, by);\n\n    std::vector<int> xPoints = {ax, bx};\n    std::vector<int> yPoints = {ay, by};\n\n    for (const auto& line : existingLines) {\n        if ((line.x1 >= minX && line.x1 <= maxX) || (line.x2 >= minX && line.x2 <= maxX)) {\n            if ((line.y1 >= minY && line.y1 <= maxY) || (line.y2 >= minY && line.y2 <= maxY)) {\n                xPoints.push_back(line.x1);\n                xPoints.push_back(line.x2);\n                yPoints.push_back(line.y1);\n                yPoints.push_back(line.y2);\n            }\n        }\n    }\n\n    std::sort(xPoints.begin(), xPoints.end());\n    std::sort(yPoints.begin(), yPoints.end());\n\n    xPoints.erase(std::unique(xPoints.begin(), xPoints.end()), xPoints.end());\n    yPoints.erase(std::unique(yPoints.begin(), yPoints.end()), yPoints.end());\n\n    return (xPoints.size() + yPoints.size()) - 2;\n}\n\nint main() {\n    int ax, ay, bx, by, n;\n    std::cin >> ax >> ay >> bx >> by >> n;\n\n    std::vector<Line> existingLines(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> existingLines[i].x1 >> existingLines[i].y1 >> existingLines[i].x2 >> existingLines[i].y2;\n    }\n\n    std::cout << minEntrances(ax, ay, bx, by, existingLines) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:17"
  }
]