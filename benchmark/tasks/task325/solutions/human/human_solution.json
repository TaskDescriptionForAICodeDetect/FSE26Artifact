[
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  def main(args: Array[String]) {\n    val sc = new java.util.Scanner(System.in)\n    val T = sc.nextInt()\n    for (i <- 1 to T) {\n      var xa, ya, xb, yb = sc.nextInt()\n      xb -= xa\n      yb -= ya\n      val theta = atan2(yb, xb)\n      val n = sc.nextInt()\n      val xlist = (\n        for {\n          j <- 1 to n\n          xs_ = sc.nextInt(); ys_ = sc.nextInt();\n          xt_ = sc.nextInt(); yt_ = sc.nextInt();\n          o = sc.nextInt(); l = sc.nextInt();\n          (xs, ys) = rot(xs_ - xa, ys_ - ya, -theta)\n          (xt, yt) = rot(xt_ - xa, yt_ - ya, -theta)\n          if ys*yt < 0\n        } yield ((xs*yt-xt*ys)/(yt-ys), o, l)\n      ).toList.sortWith(_._1 < _._1).filter(_._1 > 0).filter(_._1 < pow(xb*xb+yb*yb,0.5))\n\n      println(min(count(0, xlist), count(1, xlist)))\n    }\n  }\n  def rot(x: Double, y: Double, theta: Double) = {\n    val c = cos(theta)\n    val s = sin(theta)\n    (c*x - s*y, s*x + c*y)\n  }\n  def count(l_ : Int, xlist: List[(Double, Int, Int)]): Int = {\n    if (xlist.size == 0) {\n      0\n    } else {\n      val (x, o, l) = xlist.head;\n      if((l == l_ && o == 1) || (l != l_ && o == 0)) {\n        1 + count(if(l_ == 1) 0 else 1, xlist.tail)\n      } else {\n        count(l_ , xlist.tail)\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //  << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  int cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  return (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g);\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS 1e-10\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n/* àÏ */\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n/* OÏ */\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\n/* _Æûü©ç */\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n/* 2_©ç */\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\n/* 2ÂÌ¼üÌð_ */\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n/* _Æ¼üÌ£ */\ndouble dist(const Line &l, const P &p){\n  return std::abs(outp(l.d, p-l.p) / abs(l.d));\n}\n\nint main(){\n  int d; cin>>d;\n  while(d --> 0){\n    P a, b; cin>>a.real()>>a.imag()>>b.real()>>b.imag();\n    Line l1 = LinePos(a,b);\n    int n; cin>>n;\n    vector<pair<double,int> > cp; //cross point\n    REP(i,n){\n      P c,d; int o; int l;\n      cin>>c.real()>>c.imag()>>d.real()>>d.imag()>>o>>l;\n      Line l2 = LinePos(c,d);\n      if(abs((l1.d / l2.d).imag()) < EPS) continue;\n      P p = crossPoint(l1,l2);\n      double dist = ((p-a)/(b-a)).real();\n      if(dist < 0.0 || dist > 1.0) continue;\n      cp.push_back(mp(dist,(o^l)));\n    }\n    int ans = 0;\n    if(cp.size() > 1){\n      sort(cp.begin(), cp.end());\n      for(int i=1; i<cp.size(); i++){\n        int f1 = cp[i].s;\n        int f2 = cp[i-1].s;\n        if(f1 != f2) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\ntypedef long long ll;\n\n\n\nstruct Point{double x,y,mine,high;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nbool Intersection(Point p1,Point p2,Point p3,Point p4,Point *res){\n    double d = (p2.x - p1.x)*(p4.y - p3.y) - (p2.y - p1.y)*(p4.x - p3.x);\n    if (d == 0) return false;\n    double u = ((p3.x - p1.x)*(p4.y - p3.y) - (p3.y - p1.y)*(p4.x - p3.x))/d;\n    double v = ((p3.x - p1.x)*(p2.y - p1.y) - (p3.y - p1.y)*(p2.x - p1.x))/d;\n    if (u < 0.0 || u > 1.0)return false;\n    if (v < 0.0 || v > 1.0)return false;\n    res->x = p1.x + u * (p2.x - p1.x);\n    res->y = p1.y + u * (p2.y - p1.y);\n    res->high = (p3.mine == p3.high);\n    return true;\n}\n\nint main(void){\n    int N,xa,ya,xb,yb,n,xs,ys,xt,yt,o,l;\n    cin>>N;\n    while(N--){\n        vector<Point> cross;\n        cin>>xa>>ya>>xb>>yb>>n;\n        Point a = {xa,ya,true,true};\n        Point b = {xb,yb,true,true};\n        rep(i,n){\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            Point s = {xs,ys,o,l};\n            Point t = {xt,yt,o,l};\n            Point res;\n            if(Intersection(a,b,s,t,&res)){\n                cross.push_back(res);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nP A, B;\nint N;\nP S[100], T[100];\nint O[100], L[100];\n\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\nbool is_crossing(P a1, P a2, P b1, P b2)\n{\n\tbool l = cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n\tbool r = cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n\treturn l && r;\n}\n\nP intersection_is(P a1, P a2, P b1, P b2)\n{\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\nint solve()\n{\n\tvector<pair<double, int> > vp;\n\n\trep(i, 0, N) if (is_crossing(A, B, S[i], T[i]))\n\t{\n\t\tP c = intersection_is(A, B, S[i], T[i]);\n\n\t\tdouble d = abs(c - A);\n\n\t\tint place;\n\n\t\tif (O[i] == 1)\n\t\t\tplace = L[i];\n\t\telse\n\t\t\tplace = 1 - L[i];\n\n\t\tvp.push_back(make_pair(d, place));\n\t}\n\n\tsort(vp.begin(), vp.end());\n\n\tint ans = 0;\n\trep(i, 1, vp.size())\n\t{\n\t\tif (abs(vp[i].first - vp[i - 1].first) < EPS) continue;\n\t\tif (vp[i].second != vp[i - 1].second) ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(i, 0, dn)\n\t{\n\t\tdouble x, y;\n\n\t\tcin >> x >> y; A = P(x, y);\n\t\tcin >> x >> y; B = P(x, y);\n\t\tcin >> N;\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tcin >> x >> y; S[j] = P(x, y);\n\t\t\tcin >> x >> y; T[j] = P(x, y);\n\t\t\tcin >> O[j] >> L[j];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, double xo, double yo, double dx, double dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tdouble dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tif (r == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a) * b);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > EPS) return +1;\n\tif(cross(b, c) < EPS) return -1;\n\tif(dot(b, c) < 0) return  +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) *\n\t\tccw(s.first, s.second, t.second) <= 0 &&\n\t\tccw(t.first, t.second, s.first) * \n\t\tccw(t.first, t.second, s.second) <= 0;\n}\n\nxy_t crosspoint(const line &l1, const line &l2){\n\tdouble a = cross(l1.second - l1.first, l2.second - l2.first);\n\tdouble b = cross(l1.second - l1.first, l1.second - l2.first);\n\treturn l2.first + b / a * (l2.second - l2.first);\n}\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint n;\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tline l1(xy_t(xa, ya), xy_t(xb, yb));\n\t\tcin >> n;\n\t\tvector<dat> vd;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble xs, ys, xt, yt;\n\t\t\tint o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tline l2(xy_t(xs, ys), xy_t(xt, yt));\n\t\t\tif(intersectSS(l1, l2)){\n\t\t\t\tvd.push_back(dat(crosspoint(l1, l2), l ^ o));\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\t\tint res = 0;\n\t//\tcout << vd[0].first << endl;\n\t\tfor(int i = 0; i < (int)vd.size() - 1; i++){\n\t\t\tif(vd[i].second != vd[i+1].second) res++;\n\t//\t\tcout << vd[i+1].first << endl;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n    double x, y;\n    int id;\n    point () {}\n    point(double a, double b): x(a), y(b), id(-1) {}\n    point(double a, double b, int c): x(a), y(b), id(c) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.y;\n    }\n\n    bool operator > (const point& o) const {\n        return x == o.x ? y > o.y : x > o.y;\n    }\n};\n\ndouble put (point p, point l1, point l2) {\n    double a = l1.y - l2.y, b = l2.x - l1.x, c = l1.x*l2.y - l2.x*l1.y;\n    return a * p.x + b * p.y + c;\n}\n\npoint intersect(point k1, point k2, point l1, point l2) {\n    double ret_x = (k1.x + k2.x) / 2, ret_y = (k1.y + k2.y) / 2;\n    double sig = put(k1, l1, l2) > 0 ? 1 : -1;\n    for (int j = 0; j < 200; ++j) {\n        double val = put(point(ret_x, ret_y), l1, l2);\n        if (abs(val - sig)  < EPS) {\n            return point(ret_x, ret_y);\n        } else if (val * sig > 0) {\n            ret_x = (ret_x + k2.x) / 2;\n            ret_y = (ret_y + k2.y) / 2;\n        } else {\n            ret_x = (ret_x + k1.x) / 2;\n            ret_y = (ret_y + k1.y) / 2;\n        }\n    }\n    return point(ret_x, ret_y);\n}\n\nbool cross(point k1, point k2, point l1, point l2) {\n    bool b1 = put(k1, l1, l2) * put(k2, l1, l2) < 0;\n    bool b2 = put(l1, k1, k2) * put(l2, k1, k2) < 0;\n    return b1 && b2;\n}\n\nint xa, ya, xb, yb, N;\npoint s[100], t[100];\nint o[100], l[100];\n\nint solve() {\n    point start(xa, ya), goal(xb, yb);\n   vector<point> itss;\n    for (int j = 0; j < N; ++j) {\n        if (cross(start, goal, s[j], t[j])) {\n            point it = intersect(start, goal, s[j], t[j]);\n            it.id = j;\n            itss.push_back(it);\n        }\n    }\n    sort(begin(itss), end(itss));\n    if (start > goal) reverse(begin(itss), end(itss));\n\n    int ret = 0, height = -1;\n    for (const point& it: itss) {\n        int id = it.id;\n        int expected = o[id] == 1 ? l[id] : 1-l[id];\n        if (height == -1) {\n            height = expected;\n        } else if (height != expected) {\n            ++ret;\n            height = expected;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            cin >> s[j].x >> s[j].y >> t[j].x >> t[j].y >> o[j] >> l[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-10\n\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble dist2(P& a, P& b)\n{\n\treturn (a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag());\n}\n\nclass XP\n{\npublic:\n\tint cg;\n\tdouble dist;\n\tXP(int cg, double dist)\n\t:cg(cg),dist(dist)\n\t{}\n\t\n\tbool operator<(const XP& a) const\n\t{\n\t\treturn dist<a.dist;\n\t}\n};\n\nint main()\n{\n\tint N,M;\n\tscanf(\"%d\", &N);\n\twhile(N--)\n\t{\n\t\tint xa,ya,xb,yb;\n\t\tscanf(\"%d%d%d%d\", &xa,&ya,&xb,&yb);\n\t\tL line=L(P(xa,ya),P(xb,yb));\n\t\t\n\t\tscanf(\"%d\", &M);\n\t\tvector<XP> xp;\n\t\twhile(M--)\n\t\t{\n\t\t\tint xs,ys,xt,yt,o,l;\n\t\t\tscanf(\"%d%d%d%d%d%d\",&xs,&ys,&xt,&yt,&o,&l);\n\t\t\tL road=L(P(xs,ys),P(xt,yt));\n\t\t\t\n\t\t\tif(intersectSS(line, road))\n\t\t\t{\n\t\t\t\tint cg=(o==l?1:0);\n\t\t\t\tP p=crosspoint(line, road);\n\t\t\t\txp.push_back(XP(cg, dist2(line[0], p)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tsort(xp.begin(), xp.end());\n\t\tint ps=xp[0].cg;\n\t\tfor(int i=1; i<xp.size(); i++)\n\t\t{\n\t\t\tif(xp[i].cg!=ps)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tps=xp[i].cg;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define EPS 1e-10\n#define maxn 105\nusing namespace std;\ntypedef long long ll;\nstruct Point{\n\tdouble x,y;\n\tPoint(double x = 0.0,double y = 0.0): x(x),y(y) {}\n\tPoint operator + (Point p){\n\t\treturn Point(x + p.x,y + p.y);\n\t}\n\tPoint operator - (Point p){\n\t\treturn Point(x - p.x,y - p.y);\n\t}\n\tPoint operator * (double lambda){\n\t\treturn Point(x * lambda,y * lambda);\n\t}\n\tPoint operator / (double lambda){\n\t\treturn Point(x / lambda,y / lambda);\n\t}\n\tPoint operator - (){\n\t\treturn Point(-x,-y);\n\t}\n\tdouble norm(){\n\t\treturn x * x + y * y;\n\t}\n\tdouble abs_(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator == (const Point &p)const\n\t{\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n\tbool operator < (const Point &p)const\n\t{\n\t\tif(abs(x - p.x) < EPS) return y < p.y;\n\t\telse return x < p.x;\n\t}\n};\ntypedef Point Vector;\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(Point p1 = Point(),Point p2 = Point()): p1(p1),p2(p2) {}\n};\ntypedef Segment Line;\nstruct Circle{\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(),double r = 0.0): c(c),r(r) {}\n};\ntypedef vector<Point> Polygon;\ndouble dot(Vector a,Vector b){ return a.x * b.x + a.y * b.y; }\ndouble det(Vector a,Vector b){ return a.x * b.y - a.y * b.x; }\nVector rot(Vector a,double theta){//rotate.\n\tdouble x1 = cos(theta) * a.x - sin(theta) * a.y;\n\tdouble y1 = sin(theta) * a.x + cos(theta) * a.y;\n\treturn Point(x1,y1);\n}\nstruct Crossing{\n\tdouble r;\n\tint up;\n\tCrossing(double r = 0.0,int up = 0): r(r),up(up) {}\n\tbool operator < (const Crossing &b)const\n\t{\n\t\treturn r < b.r;\n\t}\n};\nvector <Crossing> lis;\nint ccw(Point p,Segment l){\n\tif(det(l.p2 - l.p1,p - l.p1) > EPS) return 1;\n\tif(det(l.p2 - l.p1,p - l.p1) < -EPS) return -1;\n\tif(dot(l.p2 - l.p1,p - l.p1) < -EPS) return 2;\n\tif((l.p2 - l.p1).norm() < (p - l.p1).norm()) return -2;\n\treturn 0;\n}\nbool cross(Segment s1,Segment s2){\n\treturn ccw(s1.p1,s2) * ccw(s1.p2,s2) <= 0 && ccw(s2.p1,s1) * ccw(s2.p2,s1) <= 0;\n}\ndouble crossPoint(Segment a,Segment b){\n\treturn det(b.p2 - b.p1,a.p1 - b.p1) / det(a.p2 - a.p1,b.p2 - b.p1);\n}\nint T,n;\nSegment nl,s;\nint o,l;\nint main(){\n\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tlis.clear();\n\t\tscanf(\"%lf%lf%lf%lf\",&nl.p1.x,&nl.p1.y,&nl.p2.x,&nl.p2.y);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lf%lf%lf%lf\",&s.p1.x,&s.p1.y,&s.p2.x,&s.p2.y);\n\t\t\tscanf(\"%d%d\",&o,&l);\n\t\t\tl ^= o ^ 1;\n\t\t\tif(cross(s,nl)){\n\t\t\t\tlis.push_back(Crossing(crossPoint(nl,s),l));\n\t\t\t}\n\t\t}\n\t\tsort(lis.begin(),lis.end());\n\t\tint ans = 0;\n\t\tfor(int i=1;i<(int)lis.size();i++){\n\t\t\tans += (lis[i].up ^ lis[i - 1].up);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-13)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> Pair;\n\nint u, n;\ndouble xa, ya, xb, yb;\ndouble x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\n// 内積 (dot product) : a⋅b = |a||b|cosθ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積 (cross product) : a×b = |a||b|sinθ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\ndouble norm(Point p){\n\treturn sqrt(p.real() * p.real() + p.imag() * p.imag());\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nstruct Line : public vector<Point> {\n  Line(const Point &a, const Point &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPoint intersection_ls(Point a1, Point a2, Point b1, Point b2) {\n\tPoint b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tif(d1<EPS && d2<EPS) return b1;\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2 - a1) * t;\n}\n\ntypedef pair<double,bool> PD;\nint N;\nPoint pa,pb;\n\n\nint main(){\n\tcin >> N;\n\tint cnt = 0;\n\twhile(N--){\n\t\tcnt++;\n\t\tint xa,ya,xb,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tpa = Point(xa,ya);\n\t\tpb = Point(xb,yb);\n\t\tvector<PD> vp;\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tint xa,ya,xb,yb;\n\t\t\tbool o,l;\n\t\t\tcin >> xa >> ya >> xb >> yb >> o >> l;\n\t\t\t// if(cnt==451){\n\t\t\t// \tcout << xa <<\" \"<< ya << \" \" << xb << \" \" << yb << \" \" << o << \" \" << l << endl;\n\t\t\t// }\n\t\t\tPoint qa = Point(xa,ya);\n\t\t\tPoint qb = Point(xb,yb);\n\t\t\tif(o)l = !l;\n\t\t\tif(intersectSS(Line(pa,pb),Line(qa,qb))){\n\t\t\t\tPoint c = intersection_ls(pa,pb,qa,qb);\n\t\t\t\tvp.push_back(PD(c.real(),l));\n\t\t\t}\n\t\t}\n\t\tif(vp.size() == 0){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(ALL(vp));\n\t\tint ans = 0;\n\t\t// if(cnt<10){\n\t\t\t// rep(i,vp.size()){\n\t\t\t// \tcout << vp[i].first << \" \" << vp[i].second << endl;\n\t\t\t// }\n\t\t// }\n\t\trep(i,vp.size()-1){\n\t\t\tif(vp[i].second != vp[i+1].second)ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\nint main() \n{ \n    int q;\n    cin >> q;\n    while(q--){\n        Segment AB;\n        cin >> AB.p1.x >> AB.p1.y >> AB.p2.x >> AB.p2.y;\n\n        int n; cin >> n;\n        vector<int> o(n), l(n);\n\n        vector<pair<Point, int>> cp;\n        for(int i=0; i<n; i++){\n            Segment s;\n          cin >> s.p1.x >> s.p1.y >> s.p2.x >> s.p2.y;\n            cin >> o[i] >> l[i];\n\n            if(intersectSS(AB, s)){\n                auto p = getCrossPointSS(AB, s);\n                cp.push_back(make_pair(p, i));\n            }\n        }\n\n        sort(cp.begin(), cp.end());\n\n        vector<vector<int>> dp((int)cp.size()+1, vector<int>(2, 20000));\n\n        // 0を高架, 1を地下とする\n        dp[0][0] = dp[0][1] = 0;\n\n        for(int i=0; i<cp.size(); i++){\n            int idx = cp[i].second;\n            if(o[idx] == 1){\n              //所有している\n              if(l[idx] == 0){\n                //高架を走っているとき\n                dp[i+1][0] = min({dp[i+1][0], dp[i][0], dp[i][1] + 1});\n              }else{\n                dp[i+1][1] = min({dp[i+1][1], dp[i][0]+1, dp[i][1]});\n              }\n            }else{\n              if(l[idx] == 0){\n                dp[i+1][1] = min({dp[i+1][1], dp[i][1], dp[i][0] + 1});\n              }else{\n                dp[i+1][0] = min({dp[i+1][0], dp[i][1]+1, dp[i][0]});\n              }\n            }\n        }\n        cout << min(dp[cp.size()][0], dp[cp.size()][1]) << endl;\n    }\n    return 0; \n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 1000\nusing namespace std;\n\n// library --- start\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// library --- end\n\nstruct Pox\n{\n  Segment s;\n  double dist;\n  bool o,l;\n  Pox(Segment s=Segment(),double dist=inf,bool o=false,bool l=false):s(s),dist(dist),o(o),l(l){}\n\n  bool operator < (const Pox& a)const{ return dist < a.dist; }\n\n};\n\nPoint a,b;\nint n;\nSegment seg[MAX];\nPox     pox[MAX];\n\nint compute(bool state)\n{\n  int cnt = 0;\n  rep(i,n)//0\n    {\n      if(pox[i].dist == inf)break;\n      if(pox[i].o)\n\t{//it's me\n\t  if(pox[i].l != state)\n\t    {\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n      else\n\t{//mario\n\t  if(pox[i].l == state)\n\t    {\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n    }\n  return cnt;\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> a.x >> a.y >> b.x >> b.y;\n\t  cin >> n;\n\t  rep(i,n)\n\t    {\n\t      cin >> seg[i].p1.x >> seg[i].p1.y >> seg[i].p2.x >> seg[i].p2.y >> pox[i].o >> pox[i].l;\n\t      pox[i].s = seg[i];\n\t      Point p = (intersectSS(Segment(a,b),seg[i])?crosspoint(Segment(a,b),seg[i]):Point(inf,inf));\n\t      pox[i].dist = (intersectSS(Segment(a,b),seg[i])?sqrt(norm(a-p)):inf);\n\t    }\t  \n\t  sort(pox,pox+n); \n\n\t  cout << min(compute(false),compute(true)) << endl;\n\t}\n    }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing namespace std;\ntypedef long double ld;\nconst ld EPS = 10e-9;\n\nstruct point {\n\n\tld x, y;\n\tld d;\n\tint id;\n\n\tbool operator<(const point& rhs) const {\n\t\treturn (d + EPS < rhs.d);\n\t}\n\n\n};\nstruct line {\n\tpoint s, t;\n\tint o, l;\n};\n\nint solve();\nld dist(point a, point b) {\n\tld x, y;\n\tx = a.x - b.x;\n\ty = a.y - b.y;\n\treturn x*x + y*y;\n}\npoint getIntersection( const line l[2] ) {\n\n\tpoint ret;\n\tret.d = -1.0f;\n\tld a[2], b[2], c[2], det, M[2], m[2];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\ta[i] = -(l[i].s.y - l[i].t.y);\n\t\tb[i] = l[i].s.x - l[i].t.x;\n\t\tc[i] = l[i].s.x*l[i].t.y - l[i].s.y*l[i].t.x;\n\t}\n\n\tdet = a[0] * b[1] - a[1] * b[0];\n\n\t// two lines are parallel\n\tif (abs(det) < EPS){ return ret; }\n\n\tret.x = b[1] * c[0] - b[0] * c[1];\n\tret.y = -a[1] * c[0] + a[0] * c[1];\n\tret.x /= det; ret.y /= det;\n\n\tm[0] = max(min(l[0].s.x, l[0].t.x), min(l[1].s.x, l[1].t.x));\n\tM[0] = min(max(l[0].s.x, l[0].t.x), max(l[1].s.x, l[1].t.x));\n\n\tm[1] = max(min(l[0].s.y, l[0].t.y), min(l[1].s.y, l[1].t.y));\n\tM[1] = min(max(l[0].s.y, l[0].t.y), max(l[1].s.y, l[1].t.y));\n\n\tif (m[0] <= ret.x && ret.x <= M[0]\n\t\t&& m[1] <= ret.y && ret.y <= M[1]) {\n\t\tret.d = dist(l[0].s, ret);\n\t}\n\n\treturn ret;\n\n}\nint isUnderground(const int o, const int l) {\n\tif (o) { return l; }\n\telse { return 1 - l; }\n}\n\n\nint main(void) {\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tsolve();\n\n\treturn 0;\n\n}\n\nint solve() {\n\n\tint n, flg, ans = 0;\n\tline l;\n\tvector<line> v;\n\tvector<point> ps;\n\n\t//input\n\tcin >> l.s.x >> l.s.y >> l.t.x >> l.t.y;\n\n\tcin >> n;\n\tv.resize(n);\n\t\n\tfor (int i = 0; i < n; i++) {\n\n\t\tcin >> v[i].s.x >> v[i].s.y >> v[i].t.x >> v[i].t.y >> v[i].o >> v[i].l;\n\t\t\n\t}\n\t\n\t//get intersection points\n\tfor (int i = 0; i < n; i++) {\n\t\tline m[] = { l, v[i] };\n\t\tpoint p = getIntersection(m);\n\t\tif ( p.d > EPS ) {\n\t\t\tp.id = i;\n\t\t\tps.push_back(p);\n\t\t}\n\t}\n\n\t//sort intersection points\n\tsort(ps.begin(), ps.end());\n\n\tif (ps.size() > 0) {\n\n\t\tint index = ps[0].id;\n\t\tflg = isUnderground(v[index].o, v[index].l);\n\n\t\tfor (int i = 1; i < ps.size(); i++) {\n\t\t\tint nind = ps[i].id;\n\t\t\tint nflg = isUnderground(v[nind].o, v[nind].l);\n\t\t\tif (flg!=nflg){ ans++; }\n\t\t\tflg = nflg;\n\t\t}\n\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,m,n) for(int i=(m);i<(n);i++)\n#define ALL(x) x.begin(),x.end()\nusing namespace std;\n\nconst double EPS = 1e-9;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator<(const point &a, const point &b) {\n\t\treturn real(a) != real(b) ? real(a)<real(b) : imag(a)<imag(b);\n\t}\n}\nstruct Line :public vector<point> {\n\tLine(const point &a, const point &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ndouble cross(const point &a, const point &b) {\n\treturn real(a)*imag(b) - imag(a)*real(b);\n}\ndouble dot(const point &a, const point &b) {\n\treturn real(a)*real(b) + imag(a)*imag(b);\n}\nint ccw(point a, point b, point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c)>EPS)return +1;\n\tif (cross(b, c)<-EPS)return -1;\n\tif (dot(b, c)<-EPS) return +2;\n\tif (norm(b)<norm(c))return -2;\n\treturn 0;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\npoint crosspoint(const Line &l, const Line &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A)<EPS&&abs(B)<EPS)return m[0];\n\tif (abs(A)<EPS)assert(false);\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble xa, ya, xb, yb;\nvoid solve() {\n\tcin >> xa >> ya >> xb >> yb;\n\tint N; cin >> N;\n\tpoint A(xa, ya), B(xb, yb);\n\tvector<Line>segments;\n\tvector<int>positions;\n\t//cout<<A<<\" \"<<B<<endl;\n\tREP(i, N) {\n\t\tdouble x1, y1, x2, y2;\n\t\tint o, l;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcin >> o >> l;\n\t\tint pos;\n\t\tpoint ps(x1, y1), pt(x2, y2);\n\t\tif (o == 1)pos = l;\n\t\telse pos = (l + 1) % 2;\n\t\tsegments.push_back(Line(ps, pt));\n\t\tpositions.push_back(pos);\n\t}\n\tvector<pair<point, int>>v;\n\tLine a_b(A, B);\n\tint idx=0;\n\tREP(i, N) {\n\t\tif (intersectSS(a_b, segments[i])) {\n\t\t\tpoint cross_p = crosspoint(a_b, segments[i]);\n\t\t\tv.push_back({ cross_p,positions[i] });\n\t\t}\n\t}\n\tsort(ALL(v));\n\tint M = v.size();\n\t//cerr<<\"number of crosspoints:\"<<M<<endl;\n\tint ans = 0;\n\t// REP(i,M){\n\t// \tcerr<<v[i].first<<\" \"<<v[i].second<<endl;\n\t// }\n\tFOR(i, 1, M) {\n\t\tif (v[i].second != v[i - 1].second)ans++;\n\t}\n\tcout << ans << endl;\n}\nsigned main() {\n\tint q; cin >> q;\n\n\twhile (q--)solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define mp       make_pair\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a), pb(b); }\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)  return CCW;\n\tif(rotdir<-EPS) return CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool intersect(const Segment &s,const Segment &t,Point &p){\n\tif(max(real(s[0]),real(s[1]))<min(real(t[0]),real(t[1]))-EPS\n\t|| max(real(t[0]),real(t[1]))<min(real(s[0]),real(s[1]))-EPS\n\t|| max(imag(s[0]),imag(s[1]))<min(imag(t[0]),imag(t[1]))-EPS\n\t|| max(imag(t[0]),imag(t[1]))<min(imag(s[0]),imag(s[1]))-EPS) return false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\tcalc_abc(s,a1,b1,c1);\n\t\tcalc_abc(t,a2,b2,c2);\n\t\tdouble det=a1*b2-a2*b1;\n\t\tif(abs(det)<EPS){ // s is parallel to t\n\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\trep(i,3){\n\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\tp=q[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint n;\nPoint A,B;\nSegment AB,S[100];\nbool own[100],loc[100];\n\nint solve(){\n\tvector< pair<double,int> > pts;\n\trep(i,n){\n\t\tPoint Q;\n\t\tif(intersect(AB,S[i],Q)) pts.pb(mp(abs(A-Q),i));\n\t}\n\tif(pts.size()==0) return 0;\n\n\tsort(pts.begin(),pts.end());\n\n\tint cnt=0,id=pts[0].second;\n\tbool now=(own[id]?loc[id]:!loc[id]);\n\tfor(int i=1;i<pts.size();i++){\n\t\tid=pts[i].second;\n\t\tif(own[id]){\n\t\t\tif(now!=loc[id]){ cnt++; now=!now; }\n\t\t}\n\t\telse{\n\t\t\tif(now==loc[id]){ cnt++; now=!now; }\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint T;\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint xa,ya,xb,yb; scanf(\"%d%d%d%d%d\",&xa,&ya,&xb,&yb,&n);\n\t\tA=Point(xa,ya);\n\t\tB=Point(xb,yb);\n\t\tAB=Segment(A,B);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,o,l; scanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&o,&l);\n\t\t\tS[i]=Segment(Point(x1,y1),Point(x2,y2));\n\t\t\town[i]=o;\n\t\t\tloc[i]=l;\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nP A, B;\nint N;\nP S[100], T[100];\nint O[100], L[100];\n\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\nbool is_crossing(P a1, P a2, P b1, P b2)\n{\n\tbool l = cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n\tbool r = cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n\treturn l && r;\n}\n\nP intersection_is(P a1, P a2, P b1, P b2)\n{\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\nint solve()\n{\n\tvector<pair<double, int> > vp;\n\n\trep(i, 0, N) if (is_crossing(A, B, S[i], T[i]))\n\t{\n\t\tP c = intersection_is(A, B, S[i], T[i]);\n\n\t\tdouble d = abs(c - A);\n\n\t\tint place;\n\n\t\tif (O[i] == 1)\n\t\t\tplace = L[i];\n\t\telse\n\t\t\tplace = 1 - L[i];\n\n\t\tvp.push_back(make_pair(d, place));\n\t}\n\n\tsort(vp.begin(), vp.end());\n\n\tint ans = 0;\n\trep(i, 1, vp.size())\n\t{\n\t\tif (vp[i].second != vp[i - 1].second) ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(i, 0, dn)\n\t{\n\t\tdouble x, y;\n\n\t\tcin >> x >> y; A = P(x, y);\n\t\tcin >> x >> y; B = P(x, y);\n\t\tcin >> N;\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tcin >> x >> y; S[j] = P(x, y);\n\t\t\tcin >> x >> y; T[j] = P(x, y);\n\t\t\tcin >> O[j] >> L[j];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\ntypedef complex<double> point;\n\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\nnamespace std{\n    bool operator < (const point &lhs,const point &rhs){\n        if(real(lhs) == real(rhs)){\n            return imag(lhs) < imag(rhs);\n        }else{\n            return real(lhs) < real(rhs);\n        }\n    }\n}\nconst double EPS = 1e-9;\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(point a,point b){\n    return real(conj(a)*b);\n}\n\n// 外積 (cross product) : |a×b| = |a||b|sinΘ\ndouble cross(point a,point b){\n    return imag(conj(a)*b);\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点(lb)とする線分の交差判定\nbool is_intersected_linesegment(point a1,point a2,point b1,point b2){\n    if(max(a1.real(),a2.real()) + EPS < min(b1.real(),b2.real())) return false;\n    if(max(b1.real(),b2.real()) + EPS < min(a1.real(),a2.real())) return false;\n    if(max(a1.imag(),a2.imag()) + EPS < min(b1.imag(),b2.imag())) return false;\n    if(max(b1.imag(),b2.imag()) + EPS < min(a1.imag(),a2.imag())) return false;\n    return (cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < EPS) and\n           (cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < EPS);\n\n}\n\n// a1,a2を端点とする線分(la)とb1,b2を端点とする線分(lb)の交点計算\npoint intersection_point_linesegment(point a1,point a2,point b1,point b2) {\n    if(a1 == b1 or a1 == b2) return a1;\n    if(a2 == b1 or a2 == b2) return a2;\n    point b = b2-b1;\n    double d1 = abs(cross(b, a1-b1));\n    double d2 = abs(cross(b, a2-b1));\n    double t = d1 / (d1 + d2);\n    return a1 + (a2-a1) * t;\n}\nstruct CrossPoint{\n    point p;\n    char is_under;\n    CrossPoint(point _p,char _is_under) :\n        p(_p),is_under(_is_under) {}\n};\n\nint solve(const point& s,const point& t,const vector<vector<point>>& lines,\n          const vector<char>& under){\n\n    int ret = 1000000000;\n    vector<CrossPoint> cross_point;\n\n    for(size_t i=0;i<lines.size();i++){\n        point a = lines[i][0];\n        point b = lines[i][1];\n        if(is_intersected_linesegment(s,t,a,b)){\n            point p = intersection_point_linesegment(s,t,a,b);\n\n            cross_point.push_back(CrossPoint(p,under[i]));\n        }\n    }\n\n    sort(all(cross_point),[s](const CrossPoint& lhs,const CrossPoint& rhs){\n                                   return abs(lhs.p-s) < abs(rhs.p-s);\n                             });\n\n    for(char istate=0;istate<2;istate++){\n        int cnt = 0;\n        char state = istate;\n        for(size_t i=0;i<cross_point.size();i++){\n            char u = cross_point[i].is_under;\n\n            if(u != state){\n                state = 1 - state;\n                cnt++;\n            }\n        }\n        ret = min(ret,cnt);\n    }\n    return ret;\n}\n\nint main(){\n    int test_case;\n    cin >> test_case;\n    for(int test=0;test<test_case;test++){\n        int xa,ya,xb,yb;\n        int n;\n        cin >> xa >> ya >> xb >> yb;\n        cin >> n;\n\n        point a(xa,ya),b(xb,yb);\n\n        vector<vector<point>> lines(n);\n        vector<char> underground(n);\n\n        for(int i=0;i<n;i++){\n            int xs,ys,xt,yt,o,l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            if(o == 0) l = 1 - l;\n            // must cross.\n            underground[i]= l;\n            lines[i].push_back(point(xs,ys));\n            lines[i].push_back(point(xt,yt));\n        }\n        cout << solve(a,b,lines,underground) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<EPS\n\ntypedef pair<double, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      double d1 = (ya-yb)/(xa-xb);\n      double d2 = (y1-y2)/(x1-x2);\n      if(EQ(xa,xb)){\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\tassert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS ){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(nx, (o==l)));\n      }\n    }\n\n    sort(all(points), sorter);\n\n    rep(i,points.size()) cout<<points[i].second<<\",\";\n    cout<<endl;\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\nusing namespace std;\n\nstruct st_data{\n\tdouble jp;\n\tint l;\n};\n\nint size;\nst_data *data;\ndouble xa,ya,xb,yb;\ndouble xs,ys,xt,yt;\nint o,l;\ndouble a,b,c;//ax+by+c=0\nint n;\n\nint jpn;\n\n//len=|ax+by+c|/sqrt(a^2+b^2)\n//point=(x,y)-(ax+by+c)/(a^2+b^2) (a,b)\n//joint=(x0,y0)+((x1,y1)-(x0,y0))*len0/(len0+len1)\nvoid set();\ndouble lpp(double,double);\ndouble len(double,double);\ndouble lenn(double,double);\ndouble lenp(double,double);\nvoid point(double*,double*,double,double);\nvoid joint(double*,double*,double,double,double,double,double,double);\nvoid sort();\nvoid swap(st_data*,st_data*);\n\nint main(){\n\tcin>>size;\n\tdouble len0,len1;\n\tint i;\n\tdouble x,y;\n\tdouble eps=1.0e-9;\n\tfor(int roop=0;roop<size;roop++){//dataset-roop\n\t\tcin>>xa>>ya>>xb>>yb;\n\t\tcout<<\"@\"<<xa<<\"@\"<<ya<<\"@\"<<xb<<\"@\"<<yb<<endl;\n\t\tset();\n\t\tcin>>n;\n\t\tdata=new st_data[n];\n\t\tjpn=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>xs>>ys>>xt>>yt>>o>>l;\n\t\t\tlen0=len(xs,ys);\n\t\t\tlen1=len(xt,yt);\n\t\t\tif(len0*len1>0){\n\t\t\t\tcout<<\" continue\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen0=fabs(len0);\n\t\t\tlen1=fabs(len1);\n\t\t\tpoint(&xs,&ys,xs,ys);\n\t\t\tpoint(&xt,&yt,xt,yt);\n\t\t\tjoint(&x,&y,xs,ys,len0,xt,yt,len1);\n\t\t\tcout<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\tdouble px0,py0,px1,py1;\n\t\t\tif(xa>xb){\n\t\t\t\tpx0=xb;\n\t\t\t\tpx1=xa;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpx0=xa;\n\t\t\t\tpx1=xb;\n\t\t\t}\n\t\t\tif(ya>yb){\n\t\t\t\tpy0=yb;\n\t\t\t\tpy1=ya;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpy0=ya;\n\t\t\t\tpy1=yb;\n\t\t\t}\n\t\t\tif(((px0-x)<=eps && (x-px1)<=eps) && ((py0-y)<=eps && (y-py1)<=eps)){\n\t\t\t\tif(o==l) data[jpn].l=1;\n\t\t\t\telse data[jpn].l=0;\n\t\t\t\tdata[jpn++].jp=lpp(x,y);\n\t\t\t}\n\t\t}\n\t\tsort();\n\t\tint p=data[0].l;\n\t\tint q=0;\n\t\tcout<<\" \"<<data[0].jp<<\",\"<<data[0].l<<endl;\n\t\tfor(i=1;i<jpn;i++){\n\t\t\tcout<<\" \"<<data[i].jp<<\",\"<<data[i].l<<endl;\n\t\t\tif(p!=data[i].l){\n\t\t\t\tp=data[i].l;\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t\tcout<<q<<endl;\n\t}\n\treturn 0;\n}\n\nvoid set(){\n\ta=yb-ya;\n\tb=xa-xb;\n\tc=xb*ya-xa*yb;\n}\n\ndouble lpp(double x,double y){\n\treturn sqrt((x-xa)*(x-xa)+(y-ya)*(y-ya));\n}\n\ndouble len(double x,double y){\n\t//len=|ax+by+c|/sqrt(a^2+b^2)\n\treturn ((double)(a*x+b*y+c));\n}\n\ndouble lenn(double x,double y){\n\t//len=|ax+by+c|/sqrt(a^2+b^2)\n\treturn ((double)(a*x+b*y+c)/sqrt(a*a+b*b));\n}\n\ndouble lenp(double x,double y){\n\treturn ((double)(a*x+b*y+c)/(a*a+b*b));\n}\n\nvoid point(double *x,double *y,double x0,double y0){\n\t//point=(x,y)-(ax+by+c)/(a^2+b^2) (a,b)\n\tdouble l=lenp(x0,y0);\n\t*x=x0-l*a;\n\t*y=y0-l*b;\n\treturn;\n}\n\nvoid joint(double *x,double *y,double x0,double y0,double l0,double x1,double y1,double l1){\n\t//joint=(x0,y0)+((x1,y1)-(x0,y0))*len0/(len0+len1)\n\t*x=x0+(x1-x0)*l0/(l0+l1);\n\t*y=y0+(y1-y0)*l0/(l0+l1);\n\treturn;\n}\n\nvoid sort(){\n\tfor(int i=0;i<jpn-1;i++){\n\t\tfor(int j=0;j<jpn-i-1;j++){\n\t\t\tif(data[j].jp>data[j+1].jp){\n\t\t\t\tst_data buf=data[j];\n\t\t\t\tdata[j]=data[j+1];\n\t\t\t\tdata[j+1]=buf;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid swap(st_data *d0,st_data *d1){\n\tst_data *buf;\n\tbuf->jp=d1->jp;\n\tbuf->l=d1->l;\n\td1->jp=d0->jp;\n\td1->l=d0->l;\n\td0->jp=buf->jp;\n\td0->l=buf->l;\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\ntypedef complex<double> P;\n\nstruct Pid {\n    P p;\n    int id;\n\n    Pid() {}\n    Pid(P a, int b): p(a), id(b) {}\n\n    bool operator < (const Pid& o) const {\n        return real(p) == real(o.p) ? imag(p) < imag(o.p) : real(p) < real(o.p);\n    }\n};\n\ndouble cross(const P a, const P b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\ndouble dot(const P a, const P b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\nbool has_intersection(const P k1, const P k2, const P l1, const P l2) {\n    return cross(l1-k1, k2-k1) * cross(l2-k1, k2-k1) < 0 &&\n        cross(k1-l1, l2-l1) * cross(k2-l1, l2-l1) < 0;\n}\n\nP intersect(const P k1, const P k2, const P l1, const P l2) {\n    assert(has_intersection(k1, k2, l1, l2));\n    //  { ((l2-l1) . (k1-l1)) / abs(l2-l1)^2 } * (l2-l1) + l1\n    double c1 = abs(cross(k2-k1, l1-k1)), c2 = abs(cross(k2-k1, l2-k1));\n    return l1 + c1 / (c1 + c2) * (l2-l1);\n}\n\nint xa, ya, xb, yb, N;\nP s[100], t[100];\nint o[100], l[100];\n\nint solve() {\n    P a(xa, ya), b(xb, yb);\n\n    vector<Pid> its;\n    for (int j = 0; j < N; ++j) if (has_intersection(a, b, s[j], t[j])) {\n        its.emplace_back(intersect(a, b, s[j], t[j]), j);\n    }\n\n    sort(begin(its), end(its));\n\n    int ans = 0;\n    for (int j = 0; j < (int)its.size() - 1; ++j) {\n        int v = o[its[j].id] == 1 ? l[its[j].id] : 1 - l[its[j].id];\n        int w = o[its[j+1].id] == 1 ? l[its[j+1].id] : 1 - l[its[j+1].id];\n        if (v != w) {\n            ++ ans;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            int sx, sy, tx, ty;\n            cin >> sx >> sy >> tx >> ty >> o[j] >> l[j];\n            s[j] = P(sx, sy); t[j] = P(tx, ty);\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e10\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b){\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b){\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n  L(const P &a, const P &b){\n    pb(a); pb(b);\n  }\n};\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return +-2;\n  return 0;\n  \n}\n\nbool intersectSS(const L &s, const L &t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspointLL(const L &l, const L &m){\n  double A = cross(l[1] -l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0];\n  if(abs(A) < EPS) return P(INF,INF);\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int z;\n  cin >> z;\n  while(z--){\n    P a, b;\n    cin >> a.real() >> a.imag() >> b.real() >> b.imag();\n    L ab(a,b);\n    int n;\n    cin >> n;\n    vector<pair<double,int> > cr;\n    while(n--){\n      P s, t;\n      int o, l;\n      cin >> s.real() >> s.imag() >> t.real() >> t.imag();\n      cin >> o >> l;\n      L st(s,t);\n      if(intersectSS(ab,st)){\n\tP p = crosspointLL(ab,st);\n\tdouble d = sqrt((a.real()-p.real())*(a.real()-p.real()) + (a.imag()-p.imag())*(a.imag()-p.imag()));\n\tif(!o) l = (l)? 0: 1;\n\tcr.pb(mp(d,l));\n      }\n    }\n    if(cr.size()>0){\n      sort(all(cr));\n      int l = cr[0].second;\n      int ans = 0;\n      repi(i,1,cr.size()){\n\tif(l != cr[i].second){\n\t  ans++;\n\t  l = cr[i].second;\n\t}\n      }\n      cout << ans << endl;\n    }else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\ntypedef vector<P> G;\nG readG(int n){\n  double x,y;\n  G g;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n  }\n  return g;\n}\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\n// a < b : -1, a > b : 1, a == b : 0\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\nP crosspointSS(L &l1,L &l2) {\n  double d1 = abs(cross(l2.v, l1[0] - l2[0])); // l1.a - l2.b???\n  double d2 = abs(cross(l2.v, l1[1] - l2[0]));\n  double t = d1 / (d1 + d2);\n  return l1[0] + t * l1.v;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m,x,y,x2,y2;\n  cin >> n;\n  int o,h;\n  rep(i,n){\n    cin >> x >> y >> x2 >> y2;\n    P a(x,y),b(x2,y2);\n    L l(a,b);\n    if(b < a) l = L(b,a);\n    cin >> m;\n    vector<pair<P,pair<int,int>>> ab;//a[i](crosspoint,h)\n    rep(j,m){\n      cin >> x >> y >> x2 >> y2;\n      P a(x,y),b(x2,y2);\n      L t(a,b);\n      if(b < a) t = L(b,a);\n      cin >> o >> h;\n      if(intersectSS(l,t)){\n        P p = crosspointSS(l,t);\n        ab.push_back(mp(p,mp(o,h)));\n      }\n    }\n    sort(all(ab));\n    int cnt = 0;\n    if(ab.size()){\n      int s = 0;\n      if(ab[0].se.se){\n        s = ab[0].se.fi;\n      }\n      else{\n        s = !ab[0].se.fi;\n      }\n      REP(u,1,ab.size()){\n        o = ab[u].se.fi,h = ab[u].se.se;\n        if(o && s != h){\n          ++cnt;\n          s = h;\n        }\n        else if(!o && s == h){\n          ++cnt;\n          s = !h;\n        }\n      }\n    }\n    cout << cnt << endl;\n    // ???????????¨??´?????¨????????¨????????????????????????\n    // ???????§??????¨????????¨?????????????????¢???????°??????????????????????????????°????????¶?????????????????????????????????????????????\n    // ????????????????????????????????¨??¶?????????????????????h = !h???ans++\n    // ??????????????¨??¶???????????????\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i=0; i < (n); i++)\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n\n\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  return a1 + d1/d2 * (a2-a1);\n}\n\nint main() {\n\t\n\tint N;\n\tcin >> N;\n\tdouble xa, ya, xb, yb, xs, ys, xt, yt;\n\tint n, l, o;\n\trep(n2, N) {\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tcin >> n;\n\t\tvector<pair<double, int>> closspoint;\n\t\tP newLines = P(xa, ya);\n\t\tP newLinet = P(xb, yb);\n\t\tint cnt = 0;\n\t\trep(i, n) {\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tif(o) l = 1 - l;\n\t\t\tif(isecSS(newLines, newLinet, P(xs, ys), P(xt, yt))) {\n\t\t\t\tP cp = crosspointLL(newLines, newLinet, P(xs, ys), P(xt, yt));\n\t\t\t\tD d = abs(cp - newLines);\n\t\t\t\tclosspoint.push_back(make_pair(d, l));\n\t\t\t}\n\t\t}\n\t\tsort(closspoint.begin(), closspoint.end());\n\t\tfor(int i = 1; i < closspoint.size(); i++) {\n\t\t\tif (closspoint[i].second != closspoint[i - 1].second) cnt++ ;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}\n\t\t\t\t\t\n\t\t\n\t\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョテ」ツ?療」ツ?ヲティツカツウテ」ツ?療ァツョツ?\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2テヲツャツ。テ・ツ?ε」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p)const{\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p)const{\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d)const{\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d)const{\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p)const{//テ・ツ??ァツゥツ?\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p)const{//テ・ツ、ツ姪ァツゥツ?\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p)const{\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//テァツキツ堙・ツ按?1-p2テ、ツクツ甘」ツ?ォテァツつケqテ」ツ?古」ツ?づ」ツつ凝」ツ?凝・ツ按、テ・ツョツ?\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//テァツ崢エテァツキツ嗔1-p2テ」ツ?ィテァツ崢エテァツキツ嘔1-q2テ」ツ?ョテ、ツコツ、テァツつケ\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//テァツキツ堙・ツ按?1-p2テ」ツ?ィテァツキツ堙・ツ按?1-q2テ」ツ?古、ツコツ、テ・ツキツョテ」ツ?凖」ツつ凝」ツ??\nbool exist_intersection(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//テ・ツケツウティツ。ツ?\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//テ・ツ篠淌ァツつケテ、ツクツュテ・ツソツε・ツ崢榲ィツサツ「\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ崢榲ィツサツ「\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//テ、ツコツ古ァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//テ・ツ??・ツ青古・ツ」ツォテ」ツ?ョテ、ツコツ、テァツつケテ」ツつ津ィツィツ暗ァツョツ?\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//テ、ツコツ、テァツつケテ」ツ?ェテ」ツ??\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ?\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//ティツァツ」テ」ツ?ェテ」ツ??\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tif(exist_intersection(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//テァツキツ堙・ツ按?ゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(exist_intersection(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\n\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ?\ndouble plain_area(vector<P> &poly){\n\tdouble s=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\ts += poly[i].det(poly[(i+1)%poly.size()]);\n\t}\n\treturn abs(s/2);\n}\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ??ゥツδィテ」ツ?ォテァツつケpテ」ツ?古」ツ?づ」ツつ凝」ツ??\nbool contains(vector<P> &poly,P p,double inf=INF){\n\tint cnt=0;\n\tP q(p.x+inf,p.y);\n\tfor(int i=0;i<poly.size();i++){\n\t\tif(exist_intersection(poly[i],poly[(i+1)%poly.size()],p,q))cnt++;\n\t}\n\treturn cnt&1;\n}\n//テァツつケpテ」ツつ津ゥツ?堙」ツつ凝・ツ??」ツ?ョテヲツ篠・テァツキツ?\npair<P,P> tangent_CP(double x,double y,double r,P p){\n\t//P q(x,y), m((x+p.x)/2,(y+p.y)/2);\n\tdouble d=sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y))/2;\n\treturn circle_intersection(x,y,r,(x+p.x)/2,(y+p.y)/2,d);\n}\n\n\nstruct CP{\n\tP p;\n\tint f;\n\tCP(P p,int f):p(p),f(f){}\n\tbool operator<(CP a)const{\n\t\tif(!a.p.equal(p))return p.x<a.p.x;\n\t\treturn p.y,a.p.y;\n\t}\n};\n\nint main(){\n\tint testcase;\n\tcin>>testcase;\n\twhile(testcase--){\n\t\tvector<CP> cp;\n\t\tP a,b;\n\t\tint n;\n\t\tcin>>a.x>>a.y>>b.x>>b.y;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tP s,t;\n\t\t\tint o,l,f;\n\t\t\tcin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n\t\t\tf=o^1^l;\n\t\t\tif(exist_intersection(a,b,s,t)){\n\t\t\t\tcp.push_back( CP(intersection(a,b,s,t),f) );\n\t\t\t}\n\t\t}\n\t\tsort(cp.begin(),cp.end());\n\t\tint f=-1,ans=0;\n\t\tfor(int i=0;i<cp.size();i++){\n\t\t\tif(f!=cp[i].f)ans++;\n\t\t\tf=cp[i].f;\n\t\t}\n\t\tcout<<ans-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <complex>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c)>0) return 1;\n\tif(cross(b, c)<0) return -1;\n\tif(dot(b, c)<0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersect(const P& a1, const P& a2, const P& b1, const P& b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\nint main()\n{\n\tint Q;\n\tscanf(\"%d\", &Q);\n\trep(q, Q) {\n\t\tint xa, ya, xb, yb;\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tP s(xa, ya), e(xb, yb);\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<pair<double, int> > v;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tscanf(\"%d%d%d%d%d%d\", &xs, &ys, &xt, &yt, &o, &l);\n\t\t\tP cs(xs, ys), ce(xt, yt);\n\t\t\tint k = (o==l) ? 1 : 0;\n\t\t\tif(intersect(s, e, cs, ce)) {\n\t\t\t\tdouble d = abs(dot(s-cs, ce-cs)/norm(ce-cs));\n\t\t\t\tv.push_back(make_pair(d, k));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint c=0;\n\t\tfor(int i=1; i<(int)v.size(); i++) {\n\t\t\tif(v[i].second!=v[i-1].second) c++;\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b-1);i>=a;i--)\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int,int>;\n\nconstexpr int INF = 1e9;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define next(P, i) P[(i + 1) % P.size()]\n#define prev(P, i) P[(i + P.size() - 1) % P.size()]\n\nstruct Point {\n    double x, y;\n    Point() : x(0.0), y(0.0) {}\n    Point(double x, double y) : x(x), y(y) {}\n\n    Point &operator+=(const Point &p) { x += p.x; y += p.y; return *this; }\n    Point &operator-=(const Point &p) { x -= p.x; y -= p.y; return *this; }\n    Point &operator*=(double a) { x *= a; y *= a; return *this; }\n    Point &operator/=(double a) { x /= a; y /= a; return *this; }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x * x + y * y; }\n};\nPoint operator+(const Point &p1, const Point &p2) { return Point(p1) += p2; }\nPoint operator-(const Point &p1, const Point &p2) { return Point(p1) -= p2; }\nPoint operator*(const Point &p1, double a) { return Point(p1) *= a; }\nPoint operator/(const Point &p1, double a) { return Point(p1) /= a; }\nbool operator==(const Point &p1, const Point &p2) { return equals(p1.x, p2.x) && equals(p1.y, p2.y); }\nbool cmpx(const Point &p1, const Point  &p2) {\n    return p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y;\n}\nbool cmpy(const Point &p1, const Point &p2) {\n    return p1.y != p2.y ? p1.y < p2.y : p1.x < p2.x;\n}\nbool operator<(const Point &p1, const Point &p2) {\n    return cmpx(p1, p2);\n}\nbool operator>(const Point &p1, const Point &p2) { return p2 < p1; }\n\nstruct Vector : public Point {\n    using Point::Point;\n    Vector() {}\n    Vector(const Point &P) { x = P.x; y = P.y; }\n    Vector rotate(double rad) { return Vector(x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)); }\n    Vector unit() { return *this / abs(); }\n};\n\nstruct Line {\n    Point p1, p2;\n    int o,l;\n    Line() {}\n    Line(Point p1, Point p2,int o,int l) : p1(p1), p2(p2),o(o),l(l) {}\n};\n\nstruct Segment : public Line {\n    using Line::Line;\n    Segment() {}\n    Segment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n    Vector vec() { return p2 - p1; }\n};\n\n\ndouble dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }\ndouble cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }\n\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2)  {\n    Vector a = p1 - p0, b = p2 - p0;\n    if (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS) return ONLINE_BACK;\n    if (a.norm() < b.norm()) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Segment a, Segment b) {\n    Point p1 = a.p1, p2 = a.p2,  p3 = b.p1, p4 = b.p2;\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <=  0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nPoint get_cross_point(Segment a, Segment b) {\n    assert(intersect(a, b));\n    Vector base = b.p2 - b.p1;\n    double area1 = abs(cross(base, a.p1 - b.p1));\n    double area2 = abs(cross(base, a.p2 - b.p1));\n    double t = area1 / (area1 + area2);\n    return a.p1 + (a.p2 - a.p1) * t;\n}\n\nvoid solve(){\n    double xa,ya,xb,yb;\n    cin>>xa>>ya>>xb>>yb;\n    Point s(xa,ya),t(xb,yb);\n    int n;cin>>n;\n    vector<double>xs(n),ys(n),xt(n),yt(n);\n    vi o(n),l(n);\n    Segment shinkan(s,t,-1,-1);\n    vector<Segment>segs;\n    rep(i,0,n){\n        cin>>xs[i]>>ys[i]>>xt[i]>>yt[i];\n        cin>>o[i]>>l[i];\n        segs.emplace_back(Point(xs[i],ys[i]),Point(xt[i],yt[i]),o[i],l[i]);\n    }\n    vector<pair<Point,int>>touch;\n    rep(i,0,n){\n        if(intersect(shinkan,segs[i])){\n            Point x=get_cross_point(shinkan,segs[i]);\n            touch.emplace_back(x,i);\n        }\n    }\n    sort(touch.begin(),touch.end());\n    auto calc=[&](int state){\n        int cnt=0;\n        rep(i,0,touch.size()){\n            Point p;\n            int idx;\n            tie(p,idx)=touch[i];\n            if(o[idx]==1){\n                cnt+=state!=l[idx];\n                state=l[idx];\n            }\n            else{\n                cnt+=state==l[idx];\n                state=not l[idx];\n            }\n        }\n        return cnt;\n    };\n    cout<<min(calc(0),calc(1))<<endl;\n\n}\n\nsigned main() {\n    int T;cin>>T;\n    while(T--){\n        solve();\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[10010];string s;ll l;double d;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tdouble nextDouble(){scanf(\"%lf\", &d);return d;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nstruct L : public vector<P>{\n\tL(const P& a, const P& b){\n\t\tclear(); pb(a); pb(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r):p(p), r(r){};\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble dist2(const P& a, const P& b){\n\tP p(a-b);\n\treturn dot(p, p);\n}\n\nbool getNext(bool a, bool b){\n\treturn a?b:!b;\n}\n\nvoid printP(const P& p){\n\tcout<<\" \"<<real(p)<<\" \"<<imag(p);\n}\n\nint main(){\n\tint N = in.nextInt();\n\twhile(N--){\n\t\tint xa = in.nextInt(), ya = in.nextInt(), xb = in.nextInt(), yb = in.nextInt();\n\t\tL l({{xa, ya}, {xb, yb}});\n\t\tint n = in.nextInt();\n\t\tvector<pii> ps;\n\t\tvector<pair<double, pair<int, int> > > ds;\n\t\trep(i, n){\n\t\t\tint xs = in.nextInt(), ys = in.nextInt(), xt = in.nextInt(), yt = in.nextInt();\n\t\t\tL t{{xs, ys}, {xt, yt}};\n\t\t\tps.pb({in.nextInt(), in.nextInt()});\n\t\t\t//printP(t[0]);\n\t\t\t//printP(t[1]);\n\t\t\t//cout<<endl;\n\t\t\tif(intersectSS(l, t))\n\t\t\t//if(ccw(l[0], crosspoint(l, t), l[1])==-2 && ccw(t[0], crosspoint(l, t), t[1]) == -2)\n\t\t\t\tds.pb({sqrt(dist2(crosspoint(l, t), l[0])), {ps.back().fi, ps.back().se}});\n\t\t\t//}\n\t\t}\n\t\t//cout<<\" \"<<ds.size()<<endl;\n\t\tsort(all(ds));\n\t\tint ans = 0;\n\t\tif(ds.size()==0){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool now = getNext(ds[0].se.fi, ds[0].se.se);\n\t\trep(i, ds.size()){\n\t\t\tif(now!=getNext(ds[i].se.fi, ds[i].se.se)){\n\t\t\t\tans++;\n\t\t\t\tnow = !now; \n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\nusing namespace std;\n\nstruct st_data{\n\tdouble jp;\n\tint l;\n};\n\nint size;\nst_data *data;\ndouble xa,ya,xb,yb;\ndouble xs,ys,xt,yt;\nint o,l;\ndouble a,b,c;//ax+by+c=0\nint n;\n\nint jpn;\n\n//len=|ax+by+c|/sqrt(a^2+b^2)\n//point=(x,y)-(ax+by+c)/(a^2+b^2) (a,b)\n//joint=(x0,y0)+((x1,y1)-(x0,y0))*len0/(len0+len1)\nvoid set();\ndouble lpp(double,double);\ndouble len(double,double);\ndouble lenn(double,double);\ndouble lenp(double,double);\nvoid point(double*,double*,double,double);\nvoid joint(double*,double*,double,double,double,double,double,double);\nvoid sort();\nvoid swap(st_data*,st_data*);\n\nint main(){\n\tcin>>size;\n\tdouble len0,len1;\n\tint i;\n\tdouble x,y;\n\tdouble eps=1.0e-9;\n\tfor(int roop=0;roop<size;roop++){//dataset-roop\n\t\tcin>>xa>>ya>>xb>>yb;\n\t\t//cout<<\"@\"<<xa<<\"@\"<<ya<<\"@\"<<xb<<\"@\"<<yb<<endl;\n\t\tset();\n\t\tcin>>n;\n\t\tdata=new st_data[n];\n\t\tjpn=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>xs>>ys>>xt>>yt>>o>>l;\n\t\t\tlen0=len(xs,ys);\n\t\t\tlen1=len(xt,yt);\n\t\t\tif(len0*len1>0){\n\t\t\t\t//cout<<\" continue\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen0=fabs(len0);\n\t\t\tlen1=fabs(len1);\n\t\t\tpoint(&xs,&ys,xs,ys);\n\t\t\tpoint(&xt,&yt,xt,yt);\n\t\t\tjoint(&x,&y,xs,ys,len0,xt,yt,len1);\n\t\t\t//cout<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\tdouble px0,py0,px1,py1;\n\t\t\tif(xa>xb){\n\t\t\t\tpx0=xb;\n\t\t\t\tpx1=xa;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpx0=xa;\n\t\t\t\tpx1=xb;\n\t\t\t}\n\t\t\tif(ya>yb){\n\t\t\t\tpy0=yb;\n\t\t\t\tpy1=ya;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpy0=ya;\n\t\t\t\tpy1=yb;\n\t\t\t}\n\t\t\tif(((px0-x)<=eps && (x-px1)<=eps) && ((py0-y)<=eps && (y-py1)<=eps)){\n\t\t\t\tif(o==l) data[jpn].l=1;\n\t\t\t\telse data[jpn].l=0;\n\t\t\t\tdata[jpn++].jp=lpp(x,y);\n\t\t\t}\n\t\t}\n\t\tsort();\n\t\tint p=data[0].l;\n\t\tint q=0;\n\t\t//cout<<\" \"<<data[0].jp<<\",\"<<data[0].l<<endl;\n\t\tfor(i=1;i<jpn;i++){\n\t\t\t//cout<<\" \"<<data[i].jp<<\",\"<<data[i].l<<endl;\n\t\t\tif(p!=data[i].l){\n\t\t\t\tp=data[i].l;\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t\tcout<<q<<endl;\n\t\tdelete []data;\n\t}\n\treturn 0;\n}\n\nvoid set(){\n\ta=yb-ya;\n\tb=xa-xb;\n\tc=xb*ya-xa*yb;\n}\n\ndouble lpp(double x,double y){\n\treturn sqrt((x-xa)*(x-xa)+(y-ya)*(y-ya));\n}\n\ndouble len(double x,double y){\n\t//len=|ax+by+c|/sqrt(a^2+b^2)\n\treturn ((double)(a*x+b*y+c));\n}\n\ndouble lenn(double x,double y){\n\t//len=|ax+by+c|/sqrt(a^2+b^2)\n\treturn ((double)(a*x+b*y+c)/sqrt(a*a+b*b));\n}\n\ndouble lenp(double x,double y){\n\treturn ((double)(a*x+b*y+c)/(a*a+b*b));\n}\n\nvoid point(double *x,double *y,double x0,double y0){\n\t//point=(x,y)-(ax+by+c)/(a^2+b^2) (a,b)\n\tdouble l=lenp(x0,y0);\n\t*x=x0-l*a;\n\t*y=y0-l*b;\n\treturn;\n}\n\nvoid joint(double *x,double *y,double x0,double y0,double l0,double x1,double y1,double l1){\n\t//joint=(x0,y0)+((x1,y1)-(x0,y0))*len0/(len0+len1)\n\t*x=x0+(x1-x0)*l0/(l0+l1);\n\t*y=y0+(y1-y0)*l0/(l0+l1);\n\treturn;\n}\n\nvoid sort(){\n\tfor(int i=0;i<jpn-1;i++){\n\t\tfor(int j=0;j<jpn-i-1;j++){\n\t\t\tif(data[j].jp>data[j+1].jp){\n\t\t\t\tst_data buf=data[j];\n\t\t\t\tdata[j]=data[j+1];\n\t\t\t\tdata[j+1]=buf;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid swap(st_data *d0,st_data *d1){\n\tst_data *buf;\n\tbuf->jp=d1->jp;\n\tbuf->l=d1->l;\n\td1->jp=d0->jp;\n\td1->l=d0->l;\n\td0->jp=buf->jp;\n\td0->l=buf->l;\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef float FP;\ntypedef complex<FP> pt;\ntypedef complex<FP> P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nbool onl(P a1,P a2,P b){\n  return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;\n}\n\nint xs[100],ys[100],xt[100],yt[100],o[100],l[100];\n\nvoid solve(){\n  int xa,ya,xb,yb;\n  cin >> xa >> ya >> xb >> yb;\n  vector<pair<FP,int> > arr;\n  int n;\n  cin >> n;\n  rep(i,n) cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n  rep(i,n){\n    P a(xs[i],ys[i]),b(xt[i],yt[i]);\n    P c(xa,ya),d(xb,yb);\n    P cr=crspt(a,b,c,d);\n    if(onl(a,b,cr) && onl(c,d,cr))\n      arr.pb(mp(abs(c-cr),o[i]^l[i]));\n  }\n  sort(ALL(arr));\n  int ans=0;\n  rep(i,SZ(arr)-1) ans += arr[i].S != arr[i+1].S;\n  cout << ans << endl;\n}\n    \n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n#define RFOR(it,c) for(__typeof((c).rbegin())it=(c).rbegin(); it!=(c).rend();++it)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n\tcopy(v.begin(), v.end(), ostream_iterator<T>(os, \" \"));\n\treturn os;\n}\n\nconst double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint():x(0), y(0) {}\n\tpoint(double x, double y):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || abs(x - p.x) < EPS && y + EPS < p.y;\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\npoint rotate90(const point& p) {\n\treturn point(-p.y, p.x);\n}\n\npoint rotate(const point& p, const double theta) {\n\tconst double s = sin(theta), c = cos(theta);\n\treturn point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\ndouble angle(const point& p) {\n\treturn atan2(p.y, p.x);\n}\n\ndouble abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ndouble cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a, point b):a(a), b(b){}\n};\n\nstruct circle {\n\tpoint c;\n\tdouble r;\n\tcircle(point c, double r):c(c), r(r){}\n};\n\ntypedef vector<point> polygon;\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tif(cross(b, c) > EPS) return 1; // ccw\n\tif(cross(b, c) < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\npoint projection(const line& l, const point& p) {\n\tconst point dif = l.b - l.a;\n\tconst double tmp = dot(p - l.a, dif) / norm(dif);\n\treturn l.a + dif * tmp;\n}\n\nbool intersect(const line& l, const line& m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const line& l, const segment& s) {\n\treturn cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersect(const line& l, const point& p) {\n\treturn abs(ccw(l.a, l.b, p)) != -1;\n}\n\nbool intersect(const segment& s, const segment& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const segment& s, const point& p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const circle& c, const point& p) {\n\treturn abs(c.c - p) <= c.r + EPS;\n}\n\nbool intersect(const circle& c, const circle& d) {\n\treturn abs(c.c - d.c) <= c.r + d.r && abs(c.c - d.c) >= abs(c.r - d.r);\n}\n\ndouble dist(const line& l, const point& p) {\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist(const line& l, const line& m) {\n\treturn intersect(l, m) ? 0 : dist(l, m.a);\n}\n\ndouble dist(const line& l, const segment& s) {\n\treturn intersect(l, s) ? 0 : min(dist(l, s.a), dist(l, s.b));\n}\n\ndouble dist(const segment& s, const point& p) {\n\tconst point tmp = projection(line(s.a, s.b), p);\n\treturn intersect(s, tmp) ? abs(tmp - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist(const segment& s, const segment& t) {\n\tif(intersect(s, t))\n\t\treturn 0;\n\treturn min(min(dist(s, t.a), dist(s, t.b)), min(dist(t, s.a), dist(t, s.b)));\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn l.a + (l.b - l.a) * cross(m.b - m.a, m.b - l.a) * (1.0 / tmp);\n}\n\npoint crosspoint(const segment& s, const segment& t) {\n\tif(!intersect(s, t)) // 交点を持たない\n\t\treturn s.a; // 用改善\n\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\n\treturn t.a + (t.b - t.a) * cross(s.b - s.a, s.b - t.a) * (1.0 / tmp);\n}\n\nvector<point> crosspoint(const circle &c, const circle& d) {\n\tvector<point> res;\n\tif(abs(c.c - d.c) < EPS) // 中心の座標が同じ\n\t\treturn res;\n\n\tconst double tmp = abs(c.c - d.c);\n\tconst double rc = (tmp * tmp + c.r * c.r - d.r * d.r) / (tmp + tmp);\n\tconst double rs = sqrt(c.r * c.r - rc * rc);\n\tconst point diff = (d.c - c.c) / tmp;\n\tres.push_back(point(c.c + diff * point(rc, rs)));\n\tres.push_back(point(c.c + diff * point(rc, -rs)));\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const line& l) {\n\tvector<point> res;\n\tconst point h = projection(l, c.c);\n\tconst double d = abs(h - c.c);\n\tif(d > c.r - EPS) {\n\t\tres.push_back(h);\n\t}\n\telse if(d <= c.r - EPS) {\n\t\tpoint v = l.b - l.a;\n\t\tv = v * sqrt(c.r * c.r - d * d) / abs(v);\n\t\tres.push_back(h + v);\n\t\tres.push_back(h - v);\n\t}\n\n\treturn res;\n}\n\nvector<point> crosspoint(const circle& c, const segment& s) {\n\tvector<point> res;\n\tvector<point> tmp = crosspoint(c, line(s.a, s.b));\n\tfor(int i = 0; i < tmp.size(); ++i)\n\t\tif(intersect(s, tmp[i]))\n\t\t\tres.push_back(tmp[i]);\n\n\treturn res;\n}\n\ndouble area(const polygon& p) {\n\tdouble res = 0.0;\n\tconst int num = p.size();\n\tfor(int i = 0; i < num; ++i) {\n\t\tres += cross(p[i], p[(i + 1) % num]);\n\t}\n\n\treturn res * 0.5;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint t;\n\tcin >> t;\n\n\twhile(t--) {\n\t\tint xs, ys, xt, yt;\n\t\tcin >> xs >> ys >> xt >> yt;\n\t\tsegment newRoad(point(xs, ys), point(xt, yt));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<pair<point, bool> > cross_road;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tbool o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\n\t\t\tsegment existing(point(xs, ys), point(xt, yt));\n\t\t\tif(intersect(newRoad, existing))\n\t\t\t\tcross_road.push_back(make_pair(crosspoint(newRoad, existing), ((!o) ^ l)));\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tif(cross_road.size()) {\n\t\t\tsort(cross_road.begin(), cross_road.end());\n\t\t\tbool over = cross_road[0].second;\n\t\t\t\n\t\t\tfor(int i = 1; i < (int)cross_road.size(); ++i) {\n\t\t\t\tif(over ^ cross_road[i].second) {\n\t\t\t\t\t++ans;\n\t\t\t\t\tover = !over;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\nbool equal(double a, double b){\n\treturn fabs(a-b) < EPS ;\n}\n\ndouble dot(P a, P b){ return real( conj(a) * b ); }\n\ndouble cross(P a, P b){ return imag( conj(a) * b ); }\n\n\n\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){ a = a_; b = b_; }\n\tSegment(){}\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) && (cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) ) ;\n\t}\n\tbool parallel( Segment s1 , Segment s2 ){\n\t\treturn equal( dot(s1.a - s1.b, s2.a - s2.b) , 0 );\n\t}\n\tbool intersection(Segment s, P& p){\n\t\tbool result = is_intersection( s );\n\n\t\t//if( parallel( *this , s ) ) return false;\n\t\tif( result ){\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ){\n\t\t\t\tp = s.a;\n\t\t\t\treturn false;\n\t\t\t}else if( abs(d1) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdouble t = d1 / (d1+d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_=0 ; t_ < T ; t_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\n\t\tP start(xa,ya), goal(xb,yb);\n\t\tSegment S( start , goal );\n\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tSegment s( P(xs,ys) , P(xt,yt) );\n\n\t\t\tP p(0,0);\n\t\t\tif( S.intersection( s , p ) ){\n\t\t\t\tint d = (start.X - p.X)*(start.X - p.X) + (start.Y - p.Y)*(start.Y - p.Y);\n\t\t\t\tv.push_back( pair<int,int> ( d , o^l ) );\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tsort( v.begin() , v.end() );\n\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\tif( v[i-1].second != v[i].second ){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nP A, B;\nint N;\nP S[100], T[100];\nint O[100], L[100];\n\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\nbool is_crossing(P a1, P a2, P b1, P b2)\n{\n\tbool l = cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n\tbool r = cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n\treturn l && r;\n}\n\nP intersection_is(P a1, P a2, P b1, P b2)\n{\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\nint solve()\n{\n\tvector<pair<double, int> > vp;\n\n\trep(i, 0, N) if (is_crossing(A, B, S[i], T[i]))\n\t{\n\t\tP c = intersection_is(A, B, S[i], T[i]);\n\n\t\tdouble d = abs(c - A);\n\n\t\tint place;\n\n\t\tif (O[i] == 1)\n\t\t\tplace = L[i];\n\t\telse\n\t\t\tplace = 1 - L[i];\n\n\t\tvp.push_back(make_pair(d, place));\n\t}\n\n\tsort(vp.begin(), vp.end());\n\n\tint ans = 0;\n\trep(i, 1, vp.size())\n\t{\n\t\tassert(EPS < abs(vp[i].first - vp[i - 1].first));\n\t\tif (vp[i].second != vp[i - 1].second) ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(i, 0, dn)\n\t{\n\t\tdouble x, y;\n\n\t\tcin >> x >> y; A = P(x, y);\n\t\tcin >> x >> y; B = P(x, y);\n\t\tcin >> N;\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tcin >> x >> y; S[j] = P(x, y);\n\t\t\tcin >> x >> y; T[j] = P(x, y);\n\t\t\tcin >> O[j] >> L[j];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-9\n#define INF 1e10\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tif(z == 0)return(point(INF,INF));\n\tlong double r = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\tif((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(tmpx,(o+l)%2));\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n    double x, y;\n    int id;\n    point (): x(0), y(0), id(0) {}\n\n    point(double a, double b): x(a), y(b), id(-1) {}\n    point(double a, double b, int c): x(a), y(b), id(c) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.y;\n    }\n\n    bool operator > (const point& o) const {\n        return x == o.x ? y > o.y : x > o.y;\n    }\n};\n\ndouble put (point p, point l1, point l2) {\n    double a = l1.y - l2.y, b = l2.x - l1.x, c = l1.x*l2.y - l2.x*l1.y;\n    return a * p.x + b * p.y + c;\n}\n\npoint intersect(point k1, point k2, point l1, point l2) {\n    double ret_x = (k1.x + k2.x) / 2, ret_y = (k1.y + k2.y) / 2;\n    double sig = put(k1, l1, l2) > 0 ? 1 : -1;\n    for (int j = 0; j < 200; ++j) {\n        double val = put(point(ret_x, ret_y), l1, l2);\n        if (abs(val - sig)  < EPS) {\n            return point(ret_x, ret_y);\n        } else if (val * sig > 0) {\n            ret_x = (ret_x + k2.x) / 2;\n            ret_y = (ret_y + k2.y) / 2;\n        } else {\n            ret_x = (ret_x + k1.x) / 2;\n            ret_y = (ret_y + k1.y) / 2;\n        }\n    }\n    return point(ret_x, ret_y);\n}\n\nbool cross(point k1, point k2, point l1, point l2) {\n    bool b1 = put(k1, l1, l2) * put(k2, l1, l2) < 0;\n    bool b2 = put(l1, k1, k2) * put(l2, k1, k2) < 0;\n    return b1 && b2;\n}\n\nint xa, ya, xb, yb, N;\npoint s[1000], t[1000];\nint   o[1000], l[1000];\n\nint solve() {\n    point start(xa, ya), goal(xb, yb);\n    vector<point> itss;\n    for (int j = 0; j < N; ++j) if (cross(start, goal, s[j], t[j])) {\n        point it = intersect(start, goal, s[j], t[j]);\n        it.id = j;\n        itss.push_back(it);\n    }\n\n    sort(begin(itss), end(itss));\n    if (start > goal) reverse(begin(itss), end(itss));\n\n    int ret = 0, height = -1;\n    for (const point& it : itss) {\n        int id = it.id;\n        int expected = o[id] == 1 ? l[id] : 1-l[id];\n        if (height == -1) {\n            height = expected;\n        } else if (height != expected) {\n            ++ret;\n            height = expected;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            cin >> s[j].x >> s[j].y >> t[j].x >> t[j].y >> o[j] >> l[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nstruct Segment{ Point p1, p2; };\n\nclass C{\npublic:\n  Point p;\n  int o, l;\n  double d;\n  C(){}\n  C(Point p, int o, int l, double d): p(p), o(o), l(l), d(d) {}\n  bool operator < (const C& s) const {\n    return d < s.d;\n  }\n};\n\nvector<C> vec;\nPoint A, B;\nint n, T;\n\nconst double EPS = 1e-10;\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\n\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\n\nmain(){\n  cin >> T;\n  while(T--){\n    vec.clear();\n    cin >> A.real() >> A.imag() >> B.real() >> B.imag();\n    cin >> n;\n    for(int i=0;i<n;i++){\n      Point s, t;\n      int o, l;\n      cin >> s.real() >> s.imag() >> t.real() >> t.imag() >> o >> l;\n      Segment s1 = (Segment){A, B};\n      Segment s2 = (Segment){s, t};\n      if(isIntersect(s1, s2)){\n        Point p = getCrossPoint(s1, s2);\n        vec.push_back(C(p, o, l, abs(p-A)));\n      }\n    }\n    sort(vec.begin(), vec.end());\n    int cnt = 0;\n    int p = (vec[0].o == vec[0].l ? 1 : 0);\n    for(int i=0;i<vec.size();i++){\n      int t = (vec[i].o == vec[i].l ? 1 : 0);\n      if(p != t) cnt++;\n      p = t;\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS 1e-16\n\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n/* àÏ */\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n/* OÏ */\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\n/* _Æûü©ç */\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n/* 2_©ç */\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\n/* 2ÂÌ¼üÌð_ */\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n/* _Æ¼üÌ£ */\ndouble dist(const Line &l, const P &p){\n  return std::abs(outp(l.d, p-l.p) / abs(l.d));\n}\n\nint main(){\n  int d; cin>>d;\n  while(d --> 0){\n    P a, b; cin>>a.real()>>a.imag()>>b.real()>>b.imag();\n    Line l1 = LinePos(a,b);\n    int n; cin>>n;\n    vector<pair<double,int> > cp; //cross point\n    REP(i,n){\n      P c,d; int o; int l;\n      cin>>c.real()>>c.imag()>>d.real()>>d.imag()>>o>>l;\n      Line l2 = LinePos(c,d);\n      if(abs((l1.d / l2.d).imag()) < EPS) continue;\n      P p = crossPoint(l1,l2);\n      double dist = ((p-a)/(b-a)).real();\n      if(dist < 0.0 || dist > 1.0) continue;\n      cp.push_back(mp(dist,(o^l)));\n    }\n    int ans = 0;\n    if(cp.size() > 1){\n      sort(cp.begin(), cp.end());\n      for(int i=1; i<cp.size(); i++){\n        int f1 = cp[i].s;\n        int f2 = cp[i-1].s;\n        if(f1 != f2) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)<<\" \"\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace geo{\n    const double EPS = 1e-9;\n    typedef double PT;typedef complex<PT> P;\n    typedef P vecP;typedef vector<P> Polygon;\n\n    template<typename T>bool LT(T a,T b){return a+EPS<b;}\n    template<typename T>bool GT(T a,T b){return LT(b,a);}\n    template<typename T>bool EQ(T a,T b){return !LT(a,b) && !GT(a,b);}\n\n    namespace VU{\n            static PT x(const vecP& a){return real(a);}\n            static PT y(const vecP& a){return imag(a);}\n            \n            // ベクタの長さ\n            static PT length(const vecP& a){return abs(a);}\n            // 単位ベクトル\n            static vecP unit_vector(const vecP& a){return a / abs(a);}\n            // 法線ベクトル\n            static pair<vecP,vecP> normal_vector(const vecP& a){return make_pair(a * vecP(0,1),a * vecP(0,-1));}\n            // 内積 (dot product) : a・b = |a||b|cosΘ\n            PT dot(const vecP& a,const vecP& b){return x(conj(a)*b);}\n            // 外積 (cross product) : |a×b| = |a||b|sinΘ\n            PT cross(const vecP& a,const vecP& b){return y(conj(a)*b);}\n            //点aと点bの距離\n            static PT dist(const P& a,const P& b){return abs(a-b);}\n\n            // 点の進行方向\n            int ccw(P a,P b,P c){\n                b -= a;c -= a;\n                if(LT(cross(b,c),0.0)) return +1;    // counter clockwise\n                if(GT(cross(b,c) ,0.0)) return -1;    // clockwise\n                if(EQ(dot(b,c),0.0)) return +2;      // c -- a -- b\n                if(norm(b) < norm(c)) return -2; // a -- b -- c\n                return 0;\n            }\n\n    }\n    using namespace VU;\n};\nusing namespace geo;\nnamespace std{\n    bool operator <(const P &lhs,const P &rhs){\n        if(x(lhs) == x(rhs))return y(lhs) < y(rhs);\n        return x(lhs) < x(rhs);\n    }\n}\n\nnamespace geo{\n    struct L{\n        P p1,p2;\n        L(P p1,P p2):p1(p1),p2(p2){}\n        vecP vec(){\n            return p2-p1;\n        }\n        //点との距離\n        double line_dist(const P& b){\n            return abs(cross(vec(),b-p1)) / abs(vec());\n        }\n        double linesegment_dist(const P& b){\n                if(EQ(dot(p2-p1,b-p1),0.0)) return abs(b-p1);\n                if(EQ(dot(p1-p2,b-p2) ,0.0)) return abs(b-p2);\n                return line_dist(b);\n        }\n        double linesegment_dist(L& b){\n            if(is_intersected(b))return 0;\n            return min(min( linesegment_dist(b.p1),linesegment_dist(b.p2) ),\n            min(b.linesegment_dist(p1),b.linesegment_dist(p2)));\n        }\n\n             //線分同士の交差判定\n        bool is_intersected(L& b){\n            if(LT(max(x(p1),x(p2)),min(x(b.p1),x(b.p2)))) return false;\n            if(LT(max(x(b.p1),x(b.p2)),min(x(p1),x(p2)))) return false;\n            if(LT(max(y(p1),y(p2)),min(y(b.p1),y(b.p2)))) return false;\n            if(LT(max(y(b.p1),y(b.p2)),min(y(p1),y(p2)))) return false;\n            return cross(vec(),b.p1-p1)*cross(vec(),b.p2-p1)<EPS  && cross(b.vec(),p1-b.p1)*cross(b.vec(),p2-b.p1)<EPS ;\n        }\n\n        bool is_intersected_line(L& b) {\n            return !is_parallel(b);\n        }\n\n        P intersection_point(L& b) {\n            if(EQ(p1,b.p1) || EQ(p1,b.p2)) return p1;if(EQ(p2,b.p1) || EQ(p2,b.p2)) return p2;\n            return p1 + vec() * cross(b.vec(), b.p1-p1) / cross(b.vec(), vec());\n        }\n        // 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n        // みけんしょう\n        bool is_orthogonal(L& b) {return EQ(dot(vec(),b.vec()),0.0);}\n        // 2直線の平行判定 : a//b <=> cross(a, b) = 0\n        bool is_parallel(L& b) {return EQ(cross(vec(),b.vec()),0.0);}\n\n        // 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\n        P nearest_point_line(P b){\n            return p1 + vec() * dot(vec(),b-p1) / norm(vec());\n        }\n        // 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\n        P nearest_point_linesegment(P b){\n            if(EQ(dot(vec(),b-p1),0.0)) return p1;\n            if(EQ(dot(vec(),b-p2),0.0)) return p2;\n            return nearest_point_line(b);\n        }\n    };\n}\n\nint INF=1<<28;\nint main(){\n\tint C;cin >> C;\n\twhile(C--!=0){\n\t\tint xa,ya,xb,yb;cin >> xa >> ya >> xb >> yb;\n\t\tL base(P(xa,ya),P(xb,yb));\n\t\tint n;cin >> n;\n\t\tvector<pair<pair<P,int>,int>> inps;\n\t\tREP(i,n){\n     \t\t\tint xs,ys,xt,yt,o,l;cin >> xs >> ys >> xt >> yt >>o >> l;\n\t\t\tL line=L(P(xs,ys),P(xt,yt));\n\t\t\tif(base.is_intersected(line))inps.push_back(make_pair(make_pair(base.intersection_point(line),o),l));\n\t\t}\n\t\tsort(ALL(inps));\n                        int prev=-1;\n                        {\n                            int o=inps[0].first.second,l=inps[0].second;\n                            if(o)prev=l;else prev=!l;\n                        }\n                        int res=0;\n                        for(int i=1;i<inps.size();i++){\n                            int o=inps[i].first.second,l=inps[i].second;\n                            if(o){\n                                if(prev!=l)res++;\n                                prev=l;\n                            }else{\n                                if(prev!=!l)res++;\n                                prev=!l;\n                            }\n                        }\n                        cout <<res<<endl;\n            }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = long double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nstruct poi {\n\tdb x, y;\n\tvoid r() { cin >> x >> y; }\n\tpoi op -(poi p) {\n\t\treturn {x - p.x, y - p.y};\n\t}\n\tdb cross(poi p) {\n\t\treturn x * p.y - y * p.x;\n\t}\n};\ndb xmul(poi a, poi b, poi c) {\n\treturn (b - a).cross(c - a);\n}\ndb li(poi a, poi b, poi c, poi d) {\n\tif(xmul(a, b, c) * xmul(a, b, d) > 0) return 2;\n\treturn (c - a).cross(d - c) / (b - a).cross(d - c);\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(0);\n\n\tint t; cin >> t;\n\twhile(t --) {\n\t\tpoi a, b; a.r(); b.r();\n\t\tint n; cin >> n;\n\t\tvector <pair <db, int>> v;\n\t\twhile(n --) {\n\t\t\tpoi p, q; p.r(); q.r();\n\t\t\tint o, l; cin >> o >> l;\n\t\t\tdb t = li(a, b, p, q);\n\t\t\tif(t > 0 && t < 1)\n\t\t\t\tv.pb({t, o ^ l});\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\t\tint ans = 0;\n\t\tfor(int i = 1; i < v.size(); i ++)\n\t\t\tif(v[i].second != v[i - 1].second)\n\t\t\t\tans ++;\n\t\tcout << ans << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble crosspointSS(L l1, L l2) {\n    double d1 = abs(cross(l2.v, l1.a - l2.a));\n    double d2 = abs(cross(l2.v, l1.b - l2.a));\n    double t = d1 / (d1 + d2);\n    // return l1.a + t * l1.v;\n    return t;\n}\n\nL readL() {\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return L(xa, ya, xb, yb);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int T;\n    cin >> T;\n    rep(_, T) {\n        L blue = readL();\n        int n;\n        cin >> n;\n        vector<L> lines(n);\n        V layer(n);\n        rep(i, n) {\n            lines[i] = readL();\n            int o, l;\n            cin >> o >> l;\n            layer[i] = l;\n            if (o == 0) layer[i] ^= 1;\n        }\n\n        // rep(i, n) {\n        //     cout << layer[i] << \" \";\n        // }\n        // cout << endl;\n\n        vector<pair<double, int>> v; // ?????????????????????????????????????????????????????????t??¨?????????????????????\n        rep(i, n) {\n            if (!intersectSS(blue, lines[i])) continue;\n            v.emplace_back(make_pair(crosspointSS(blue, lines[i]), i));\n            // printf(\"%.5f %d\\n\", v.back().first, v.back().second);\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n        rep(i, v.size() - 1) {\n            if (layer[v[i].second] != layer[v[i + 1].second]) {\n                ans++;\n            }\n        }\n\n        cout << ans << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <complex>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c)>0) return 1;\n\tif(cross(b, c)<0) return -1;\n\tif(dot(b, c)<0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersect(const P& a1, const P& a2, const P& b1, const P& b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\nP crosspoint(const P& a1, const P& a2, const P& b1, const P& b2) {\n\tdouble a = cross(a2-a1, b2-b1);\n\tdouble b = cross(a2-a1, a2-b1);\n\treturn b1 + b/a*(b2-b1);\n}\n\nint main()\n{\n\tint Q;\n\tscanf(\"%d\", &Q);\n\trep(q, Q) {\n\t\tint xa, ya, xb, yb;\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tP s(xa, ya), e(xb, yb);\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<pair<double, int> > v;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tscanf(\"%d%d%d%d%d%d\", &xs, &ys, &xt, &yt, &o, &l);\n\t\t\tP cs(xs, ys), ce(xt, yt);\n\t\t\tint k = (o==l) ? 1 : 0;\n\t\t\tif(intersect(s, e, cs, ce)) {\n\t\t\t\tdouble d = abs(dot(s-cs, ce-cs)/abs(s-crosspoint(s, e, cs, ce)));\n\t\t\t\tv.push_back(make_pair(d, k));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint c=0;\n\t\tfor(int i=1; i<(int)v.size(); i++) {\n\t\t\tif(v[i].second!=v[i-1].second) c++;\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> pint;\ntypedef const pint &refpint;\ntypedef pair<double,bool> pdb;\n\n\n#define INF 1e99\n\nint cross(refpint a, refpint b){\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble intersect(refpint a, refpint dif1, refpint f, refpint dif2){\n\tint A_ = cross(dif1, -dif2);\n\tif( A_ == 0.0 ) return INF;\n\tdouble A = A_;\n\t\n\tpint ddif = f - a;\n\tdouble t = cross(ddif, -dif2) / A;\n\tdouble s = cross(dif1, ddif) / A;\n\t\n\tif(t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0){\n\t\treturn t;\n\t}\n\treturn INF;\n}\n\n\nint main(){\n\tint dataset;\n\tfor(scanf(\"%d\", &dataset); dataset--; ){\n\t\tpint a, b, from, to, dif1, dif2;\n\t\tint n, o, l, x1, x2, y1, y2;\n\t\tvector<pdb> ts;\n\n\t\tscanf(\"%d%d%d%d%d\", &x1, &y1, &x2, &y2, &n);\n\t\ta = pint(x1, y1);\n\t\tb = pint(x2, y2);\n\t\tdif1 = b - a;\n\n\t\tts.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &o, &l);\n\t\t\tfrom = pint(x1, y1);\n\t\t\tto = pint(x2, y2);\n\t\t\tdif2 = to - from;\n\n\t\t\tdouble t = intersect(a, dif1, from, dif2);\n\t\t\tif( t != INF ){\n\t\t\t\tts.push_back( pdb(t, o != l) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ts.begin(), ts.end());\n\t\tint res = 0;\n\t\tfor(int i = 1; i < ts.size(); ++i){\n\t\t\tif(ts[i-1].second != ts[i].second){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T & a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n\nusing namespace std;\n#include \"bits/stdc++.h\"\n\n\n//////////////////////////////////////\nusing ld = long double;\nusing Point = std::complex<ld>;\nconst ld  pi = std::acos(-1);\nconstexpr ld eps = 1e-9;\n\nstruct Line {\n\tPoint a, b;\n};\n\nstruct Lseg {\n\tPoint a, b;\n};\n\nstruct Circle {\n\tPoint p;\n\tld r;\n};\nbool eq(ld a, ld b) {\n\treturn std::abs(a - b) < eps;\n}\n\nld dot(Point a, Point b) {\n\treturn std::real(std::conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn std::imag(std::conj(a) * b);\n}\n\nld norm(Point a) {\n\treturn dot(a, a);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1; //a,b,c: anticlockwise\n\tif (cross(b, c) < -eps) return -1;//a,b,c: clockwise\n\tif (dot(b, c) < 0) return 2; //c,a,b:liner\n\tif (norm(b) < norm(c)) return -2;// a,b,c: liner\n\treturn 0;// a,c,b:liner\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.a - m.b), 0);\n}\n\nbool isis_ls(Line l, Lseg s) {\n\treturn cross(l.b - l.a, l.a - s.a) * cross(l.b - l.a, l.a - s.b) < eps;\n}\n\nbool isis_ss(Lseg s, Lseg t) {\n\treturn ccw(s.a, s.b, t.a)* ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn std::abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Lseg s, Point p) {\n\treturn eq(abs(s.a - p) + abs(s.b - p), abs(s.b - s.a));\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint proj(Lseg l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Lseg s) {\n\treturn isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Lseg s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nld dist_ss(Lseg s, Lseg t) {\n\tif (isis_ss(s, t))return 0;\n\treturn std::min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint t; cin >> t;\n\tREP(aa, t) {\n\t\tld xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tLseg l{ Point{xa,ya},Point{xb,yb} };\n\t\tint n; cin >> n;\n\t\tvector<Lseg> v(n);\n\t\tvi p(n);\n\t\tvector<pair<ld, int>> pos;\n\t\tREP(i, n) {\n\t\t\tld xs, ys, xt, yt;\n\t\t\tcin >> xs >> ys >> xt >> yt;\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tLseg tmp = Lseg{ Point{xs,ys},Point{xt,yt} };\n\t\t\tld d = isis_ss(l, tmp);\n\t\t\tif (d > eps) {\n\t\t\t\tPoint p = is_ll(Line{ l.a,l.b }, Line{ tmp.a,tmp.b });\n\t\t\t\tpos.push_back({ real(p),a ^ b });\n\t\t\t}\n\t\t}\n\t\tsort(ALL(pos));\n\t\tint ans = 0;\n\t\tREP(i, (int)pos.size() - 1) {\n\t\t\tif (pos[i].second != pos[i + 1].second)ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    long double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(long double d){\n        return (vec){x*d,y*d};\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\n\nconst double eps = 0.0000001;\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    long double o = ab.cross(ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(ab.dot(ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(ab.dot(ab)<ac.dot(ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nvec interSection(vec& p0,vec& p1,vec& p2,vec& p3){\n    vec p23=p3-p2,p02=p2-p0,p01=p1-p0;\n    double k = p23.cross(p02)/p23.cross(p01);\n    return p0+p01*k;\n}\n\nint isInterSection(vec& p0,vec& p1,vec& p2,vec& p3){//??????p[0]p[1]??¨p[2]p[3]\n    switch(ccw(p0,p1,p2)*ccw(p0,p1,p3)){\n        case -1:\n        case -4:\n            break;\n        case 0:\n            return ~(ccw(p0,p1,p2)|ccw(p0,p1,p3))?2:-1;//?§???§??\\??????????????´???\n        default:\n            return 0;\n    }\n    switch(ccw(p2,p3,p0)*ccw(p2,p3,p1)){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return 0;\n    }\n    return 1;\n}\n\ntypedef pair<vec,int> P;\n\nstruct Section{\n    vec v1,v2;//?§??????¨??????\n    vector<P> cp;//??????(????????????????????¨?????????)\n};\n\nint main(void){\n    int N;\n    Section line;\n    vector<Section> S;\n    cin>>N;\n    while(N--){\n        S.clear();\n        line.cp.clear();\n        cin >> line.v1.x >> line.v1.y >> line.v2.x >> line.v2.y;\n        int n; cin >> n;\n        for(int i=0;i<n;i++){\n            vec v1,v2;\n            int o,l;\n            cin >> v1.x >> v1.y >> v2.x >> v2.y >> o >> l;\n            if(isInterSection(v1,v2,line.v1,line.v2)){\n                line.cp.push_back(P(interSection(v1,v2,line.v1,line.v2),o?l:l^1));\n            }\n        }\n        sort(line.cp.begin(),line.cp.end());\n        int c=0,h=line.cp[0].second;\n        for(int i=1;i<line.cp.size();i++){\n            if(h!=line.cp[i].second){\n                c++;\n                h=line.cp[i].second;\n            }\n        }\n        cout << c << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L:public vector<P> {\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\n\ndouble dot(P a, P b) {\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return dot(P(-a.imag(),a.real()),b);\n}\n\n#define EPS 1.0e-9\n\nint ccw(P a, P b, P c) {\n  b-=a; c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool hit(const L& s, const L& t) {\n  return ccw(s[0],t[0],s[1])*ccw(s[0],t[1],s[1])<=0;\n}\n\nbool same(const L& s, const L& t) {\n  return abs((s[1]-s[0]).real()*(t[1]-t[0]).imag()-(s[1]-s[0]).imag()*(t[1]-t[0]).real())<=EPS;\n}\n\ndouble crosslen(const L& s, const L& t) {\n  \n  P ab=s[1]-s[0], ac=t[0]-s[0], ad=t[1]-s[0];\n  ab/=norm(ab);\n  double lac=dot(ab,ac), lad=dot(ab,ad);\n  double dac=abs(ac-ab*lac), dad=abs(ad-ab*lad);\n  return (lac*dad+lad*dac)/(dad+dac);\n}\n\nstruct LINE {\n  L line;\n  int o,l;\n};\n\nstruct POINT {\n  LINE line;\n  double len;\n  bool uch;\n};\n\nbool comp (POINT a, POINT b) {\n  return a.len < b.len;\n}\n\nint main () {\n  int m;cin>>m;\n  while(m--){\n    vector<POINT> points;\n    vector<LINE> lines;\n    double xa,ya,xb,yb;cin>>xa>>ya>>xb>>yb;\n    int n;cin>>n;\n    L self(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;++i){\n      double a,b,c,d;int e,f;cin>>a>>b>>c>>d>>e>>f;\n      lines.push_back((LINE){L(P(a,b),P(c,d)),e,f});\n    }\n    for(int i=0;i<n;++i){\n      if(hit(self,lines[i].line)){\n\tif(same(self,lines[i].line)){\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[0]-self[0]),true});\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[1]-self[0]),true});\n\t}else{\n\t  points.push_back((POINT){lines[i],crosslen(self,lines[i].line)});\n\t}\n      }\n    }\n    sort(points.begin(),points.end(),comp);\n    vector<POINT> newpoints=points; points.clear();\n    int len=newpoints.size(); double srclen=abs(self[1]-self[0]);\n    if(len==0){cout<<0<<endl;continue;}\n    for(int i=0;i<len;++i){\n      if(newpoints[i].len>srclen)break;\n      points.push_back(newpoints[i]);\n    }\n    LINE line=points[0].line;\n    int precur,cur=0,result=0;bool ch=true;\n    if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n    for(int i=1;i<len;++i){\n      line=points[i].line;\n      if(points[i].uch)ch=true;\n      if(ch){\n\tprecur=cur; if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n\tif(precur!=cur){++result;}\n\tif(points[i].uch)ch=false;\n      }\n    }\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\nbool equal(double a, double b){\n\treturn fabs(a-b) < EPS ;\n}\n\ndouble dot(P a, P b){ return real( conj(a) * b ); }\n\ndouble cross(P a, P b){ return imag( conj(a) * b ); }\n\n\n\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){ a = a_; b = b_; }\n\tSegment(){}\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) && (cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) ) ;\n\t}\n\tbool parallel( Segment s1 , Segment s2 ){\n\t\treturn equal( dot(s1.a - s1.b, s2.a - s2.b) , 0 );\n\t}\n\tbool intersection(Segment s, P& p){\n\t\tbool result = is_intersection( s );\n\n\t\tif( parallel( *this , s ) ) return false;\n\t\tif( result ){\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else if( abs(d1) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdouble t = d1 / (d1+d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_=0 ; t_ < T ; t_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\n\t\tP start(xa,ya), goal(xb,yb);\n\t\tSegment S( start , goal );\n\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tSegment s( P(xs,ys) , P(xt,yt) );\n\n\t\t\tP p(0,0);\n\t\t\tif( S.intersection( s , p ) ){\n\t\t\t\tint d = (start.X - p.X)*(start.X - p.X) + (start.Y - p.Y)*(start.Y - p.Y);\n\t\t\t\tv.push_back( pair<int,int> ( d , (o^l)? 0 : 1 ) );\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tsort( v.begin() , v.end() );\n\t\tif( v.size() >= 2 ){\n\t\t\tint pos = v[0].second;\n\t\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\t\tif( pos != v[i].second ){\n\t\t\t\t\tpos = v[i].second;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <array>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\ntypedef array<point, 2> line;\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (eq(A, 0.) && eq(B, 0.)) return m[0]; // same line\n\tif (eq(A, 0.)) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nline read_line() {\n\tline res;\n\tfor (auto& p : res) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp = point(x, y);\n\t}\n\treturn res;\n}\n\nint solve() {\n\tline new_road = read_line();\n\tint n;\n\tcin >> n;\n\ttypedef tuple<point, bool, bool> pinfo;\n\tvector<pinfo> points;\n\tfor (int i = 0; i < n; i++) {\n\t\tline l = read_line();\n\t\tbool own, ground;\n\t\tcin >> own >> ground;\n\t\tif (intersectSS(new_road, l)) {\n\t\t\tpoints.emplace_back(crosspoint(new_road, l), own, ground);\n\t\t}\n\t}\n//\tcout << points.size() << endl;\n\tsort(points.begin(), points.end(), [&new_road](const pinfo& a, const pinfo& b) {\n\t\treturn abs(get<0>(a) - new_road[0]) < abs(get<0>(b) - new_road[0]);\n\t});\n\tif (points.empty()) return 0;\n\tbool cur = get<1>(points[0]) ? get<2>(points[0]) : !get<2>(points[0]);\n\tint cnt = 0;\n\tfor (int i = 1; i < points.size(); i++) {\n\t\tif ((get<1>(points[i]) && cur != get<2>(points[i])) ||\n\t\t\t(!get<1>(points[i]) && cur == get<2>(points[i]))) {\n\t\t\tcur = !cur;\n\t\t\tcnt++;\n//\t\t\tcout << i << endl;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS 1e-16\n\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n/* àÏ */\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n/* OÏ */\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\n/* _Æûü©ç */\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n/* 2_©ç */\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\n/* 2ÂÌ¼üÌð_ */\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n/* _Æ¼üÌ£ */\ndouble dist(const Line &l, const P &p){\n  return std::abs(outp(l.d, p-l.p) / abs(l.d));\n}\n\nint main(){\n  int d; cin>>d;\n  while(d --> 0){\n    P a, b; cin>>a.real()>>a.imag()>>b.real()>>b.imag();\n    Line l1 = LinePos(a,b);\n    int n; cin>>n;\n    vector<pair<double,int> > cp; //cross point\n    REP(i,n){\n      P c,d; int o; int l;\n      cin>>c.real()>>c.imag()>>d.real()>>d.imag()>>o>>l;\n      Line l2 = LinePos(c,d);\n      if(abs(outp(l1.d, l2.d)) < EPS) continue;\n      P p = crossPoint(l1,l2);\n      double dd=((p-a)/(b-a)).real();\n      if(dd < 0 || dd > 1.0) continue;\n      cp.push_back(mp(abs(p-a), (l+o)%2));\n    }\n    int ans = 0;\n    if(cp.size() > 1){\n      sort(cp.begin(), cp.end());\n      for(int i=1; i<cp.size(); i++){\n        int f1 = cp[i].s;\n        int f2 = cp[i-1].s;\n        if(f1 != f2) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\n \nconst double eps = 1e-8;\n \nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n \ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n \ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n \nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n \nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n \nP A, B;\nint N;\nvector<P> S, T;\nvector<int> Own, Pos;\n \nint main() {\n  int Tc;\n  cin >> Tc;\n  while(Tc--) {\n    cin >> A.real() >> A.imag() >> B.real() >> B.imag();\n    cin >> N;\n    S.resize(N);\n    T.resize(N);\n    Own.resize(N);\n    Pos.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].real() >> S[i].imag() >> T[i].real() >> T[i].imag()\n          >> Own[i] >> Pos[i];\n    }\n \n    vector<pair<double, int> > v;\n    for(int i = 0; i < N; ++i) {\n      if(isIntersect(A,B,S[i],T[i])) {\n        P p = getCrossP(A,B,S[i],T[i]);\n        v.push_back(make_pair(norm(p-A), i));\n      }\n    }\n    int cnt = 0;\n    if(v.size()) {\n      sort(v.begin(), v.end());\n      int pos = (Pos[v[0].second] ^ ~Own[v[0].second]);\n       \n      for(int i = 1; i < v.size(); ++i) {\n        int npos = Pos[v[i].second] ^ ~Own[v[i].second];\n        if(npos != pos) ++cnt;\n        pos = npos;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, int xo, int yo, int dx, int dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tdouble r = sqrt((double)dx * dx + dy * dy);\n\tx = _x * dx / r + _y * dy / r;\n\ty = _y * dx / r - _x * dy / r;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tif (r == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << sqrt((double)dx * dx + dy * dy) << endl;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tcout << x << endl;\n\t\t\tif (x < -EPS || x > sqrt((double)dx * dx + dy * dy) + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (11111)\nstruct F{\n  double a,b;\n  bool ng;\n\n  double xs,ys,xt,yt;\n  F(int xs,int ys,int xt,int yt)\n  {\n    this->xs = (double)xs;\n    this->ys = (double)ys;\n    this->xt = (double)xt;\n    this->yt = (double)yt;\n    if(xt-xs==0){\n      ng = true;\n      a = INF;\n      b = INF;\n      return;\n    }\n    ng = false;\n    a = (this->yt-this->ys)/(this->xt-this->xs);\n    b = this->ys - a * this->xs;\n  }\n};\nint N;\nvector<PP> s;\n//vector<F> f;\ninline double abd(double a){ return a>0?a:-a; };\ninline void Fcheck(F a, F b,double& x,double& y){\n  if(a.ng){\n    if(b.ng){\n      x = INF;\n      y = INF;\n    }else{\n      x = a.xs;\n      y = b.ys+(a.xs-b.xs)*b.a;\n    }\n  }else if(b.ng){\n    if(a.ng){\n      x = INF;\n      y = INF;\n    }else{\n      x = b.xs;\n      y = a.ys+(b.xs-a.xs)*a.a;\n    }\n  }else if(b.a==a.a){\n    x = INF;\n    y= INF;\n  }else{\n    y =  (a.b*b.a - b.b*a.a)/(b.a - a.a);\n    x =  (b.b - a.b)/(b.a - a.a);\n  }\n\t//Y=（ａ１ｃ２−ａ２ｃ１）／（ａ１ｂ２−ａ２ｂ１）\n}\nmain(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int xa,ya,xb,yb;\n    scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n    F fs = F(xa,ya,xb,yb);\n    double nx = (double)min(xa,xb);\n    double ny = (double)min(ya,yb);\n    double xx = (double)max(xa,xb);\n    double xy = (double)max(ya,yb);\n    //    printf(\"y = %lfx + %lf\\n\",fs.a,fs.b);\n    int n;\n    scanf(\"%d\\n\",&n);\n    for(int i=0;i<n;i++){\n      int xs,ys,xt,yt,o,l;\n      scanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&xt,&yt,&o,&l);\n      F f = F(xs,ys,xt,yt);\n      //     printf(\"y = %lfx + %lf\\n\",f.a,f.b);\n      double X,Y;\n      Fcheck(f,fs,X,Y);\n      //      printf(\"X=%lf : Y=%lf\\n\",X,Y);\n      if((nx <= X && xx >= X && \n\t  ny <= Y && xy >= Y)){\n\t //\t(fs.a==0.0f && (double)min(xs,xt) <= X && (double)max(xs,xt) >= X) ||\n\t //\t (fs.ng && (double)min(ys,yt) <= Y && (double)max(ys,yt) >= Y)){\n\ts.push_back(PP(sqrt((X-xs)*(X-xs)+(Y-ys)*(Y-ys)),P(o,l)));\n      }\n    }\n    sort(s.begin(),s.end());\n\n    /*    for(int i=0;i<s.size();i++)\n\t  printf(\"xk=%lf, o=%d, l=%d\\n\",s[i].first,s[i].second.first,s[i].second.first);*/\n\n    int count=0;\n    int res=0;\n    int R;\n    if(!s.empty()){\n      if(!s[0].second.first){\n\tif(s[0].second.second)\n\t  R = 0;\n\telse\n\t  R = 1;\n      }\n      else{\n\tif(s[0].second.second)\n\t  R = 1;\n\telse\n\t  R = 0;\n      }\n      for(int i=1;i<s.size();i++){\n\tif(s[i].second.second == R){\n\t  if(!s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}else{\n\t  if(s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}\n      }\n      res = count;\n\n      count = 0;\n      if(!s[s.size()-1].second.first){\n\tif(s[0].second.second)\n\t  R = 0;\n\telse\n\t  R = 1;\n      }\n      else{\n\tif(s[s.size()-1].second.second)\n\t  R = 1;\n\telse\n\t  R = 0;\n      }\n      for(int i=s.size()-2;i>-1;i--){\n\tif(s[i].second.second == R){\n\t  if(!s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}else{\n\t  if(s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}\n      }\n      res = min(res,count);\n    }\n\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <complex>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD dot(P a, P b){\n\treturn (conj(a)* b).real();\n}\n\nD cross(P a, P b){\n\treturn (conj(a)* b).imag();\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS) return 1;\n\tif (cross(b, c) > -EPS) return -1;\n\tif (dot(b, c) > -EPS) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\n\t\tdouble sy, sx, gy, gx;\n\t\tcin >> sx >> sy >> gx >> gy;\n\n\t\tL sl(pair<P,P>(P(sx,sy),P(gx,gy)));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\ttypedef pair<L, pair<int, int>> LL;\n\t\tvector<LL> l;\n\n\t\trep(i, n){\n\t\t\tcin >> sx >> sy >> gx >> gy;\n\t\t\tint o, tl;\n\t\t\tcin >> o >> tl;\n\n\t\t\tLL t;\n\t\t\tt.first.first._Val[0] = sx;\n\t\t\tt.first.first._Val[1] = sy;\n\t\t\tt.first.second._Val[0] = gx;\n\t\t\tt.first.second._Val[1] = gy;\n\n\t\t\tt.second.first = o;\n\t\t\tt.second.second = tl;\n\n\t\t\tl.push_back(t);\n\t\t}\n\t\tvector<int> vo, vl;\n\t\tvector<P> point;\n\n\t\trep(i, l.size()){\n\t\t\tauto lp1 = l[i].first.first;\n\t\t\tauto lp2 = l[i].first.first;\n\t\t\tauto data = l[i].second;\n\n\t\t\tif (isecLL(sl.first, sl.second, lp1, lp2)){\n\t\t\t\tauto p = crosspointLL(sl.first, sl.second, lp1, lp2);\n\t\t\t\tpoint.push_back(p);\n\t\t\t\tvo.push_back(data.first);\n\t\t\t\tvl.push_back(data.second);\n\t\t\t}\n\t\t}\n\n\t\tbool f = true;\n\t\twhile (f){\n\t\t\tf = false;\n\t\t\trep(i, point.size() - 1){\n\t\t\t\tdouble x, y, tx, ty;\n\t\t\t\tx = point[i].imag(); y = point[i].real();\n\t\t\t\ttx = point[i+1].imag(); ty = point[i+1].real();\n\t\t\t\tdouble l1 = (x - sx) * (x - sx) + (y - sy) * (y - sy), l2 = (tx - sx) * (tx - sx) + (ty - sy) * (ty - sy);\n\n\t\t\t\tif (l1 > l2){\n\t\t\t\t\tswap(point[i], point[i + 1]);\n\t\t\t\t\tswap(vo[i], vo[i + 1]);\n\t\t\t\t\tswap(vl[i], vl[i + 1]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(j, 2){\n\t\t\tint val = 0;\n\t\t\tint sj = j;\n\t\t\trep(i, point.size()){\n\n\t\t\t\tif (vo[i] == 1){\n\t\t\t\t\tif (vl[i] != sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = vl[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vo[i] == 0){\n\t\t\t\t\tif (vl[i] == sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = (1-sj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans = min(ans, val);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef pair<P,bool> Q;\nD eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool comp(const Q& xx,const Q& yy){\n\tP x=xx.fs,y=yy.fs;\n\tif(abs(x.real()-y.real())<eps){\n\t\treturn x.imag()<y.imag();\n\t}else{\n\t\treturn x.real()<y.real();\n\t}\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\tccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\tvector<Q> vc;\n\t\tD ax,ay,bx,by;\n\t\tint N;\n\t\tcin>>ax>>ay>>bx>>by>>N;\n\t\tL l=L(P(ax,ay),P(bx,by));\n\t\trep(i,N){\n\t\t\tD a,b,c,d;\n\t\t\tint e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tL s=L(P(a,b),P(c,d));\n\t\t\tif(iSS(l,s)){\n\t\t\t\tvc.pb(Q(intLL(l,s),e^f));\n\t\t\t}\n\t\t}\n\t\tif(vc.size()==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(vc),comp);\n\t\tint ans=0;\n\t\tbool now=vc[0].sc;\n\t\trep(i,vc.size()){\n\t\t\tif(now^vc[i].sc){\n\t\t\t\tans++;\n\t\t\t\tnow=vc[i].sc;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n\ntypedef long double ld;\n\nstruct po{\n\tld x;\n\tld y;\n\tpo(ld a){ x = a; y = 0; }\n\tpo(){}\n\tinline ld operator()(const po& rhs) const {\n\t\treturn x*rhs.x+y*rhs.y;\n\t}\n\tinline po& operator+=(const po& rhs){\n\t\tx += rhs.x;\n\t\ty += rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator-=(const po& rhs){\n\t\tx -= rhs.x;\n\t\ty -= rhs.y;\n\t\treturn *this;\n\t}\n\tinline po& operator*=(const po& rhs){\n\t\tld x_ = x*rhs.x-y*rhs.y;\n\t\ty = x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\treturn *this;\n\t}\n\tinline po& operator/=(const po& rhs){\n\t\tld x_ = x*rhs.x+y*rhs.y;\n\t\ty = -x*rhs.y+y*rhs.x;\n\t\tx = x_;\n\t\tld nor = rhs(rhs);\n\t\tx /= nor;\n\t\ty /= nor;\n\t\treturn *this;\n\t}\n\tinline void in(){\n\t\tscanf(\"%Lf%Lf\",&x,&y);\n\t}\n};\npo operator+(const po& a, const po& b){ return po(a) += b; }\npo operator-(const po& a, const po& b){ return po(a) -= b; }\npo operator*(const po& a, const po& b){ return po(a) *= b; }\npo operator/(const po& a, const po& b){ return po(a) /= b; }\n\ninline po similar(const po& a,const po& b,const po& c,const po& p,const po& q){\n\treturn p+(q-p)*(c-a)/(b-a);\n}\n\nstruct li{\n\tld a;\n\tld b;\n\tld c;\n\tli(po p,po q){\n\t\ta = q.y-p.y;\n\t\tb = p.x-q.x;\n\t\tc = p.y*q.x-p.x*q.y;\n\t}\n\tli(){}\n\tinline ld operator()(const po& p) const {\n\t\treturn a*p.x+b*p.y+c;\n\t}\n};\n\nvoid intersect(const li &l,const li &m,po* &ret){\n\tret = new po;\n\tret->x = -(l.c*m.b-m.c*l.b)/(l.a*m.b-m.a*l.b);\n\tret->y = -(l.a*m.c-m.a*l.c)/(l.a*m.b-m.a*l.b);\n}\n\ntypedef pair<po,po> se;\n#define fr first\n#define sc second\n\nbool on(const po &p,const se &s){\n\treturn (s.fr-p)(s.sc-p) <= 1e-9;\n}\n\nvoid intersect(se s,se t,po* &ret){\n\tli l = li(s.fr,s.sc);\n\tli m = li(t.fr,t.sc);\n\tpo *p;\n\tintersect(l,m,p);\n\tif(on(*p,s)&&on(*p,t))ret = p;\n\telse ret = nullptr;\n}\n\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\trep(loop,T){\n\t\tpo a,b;\n\t\tint n;\n\t\tpo s[102],t[102];\n\t\tint o[102],l[102];\n\t\ta.in();\n\t\tb.in();\n\t\tscanf(\"%d\",&n);\n\t\trep1(i,n){\n\t\t\ts[i].in();\n\t\t\tt[i].in();\n\t\t\tscanf(\"%d%d\",&o[i],&l[i]);\n\t\t}\n\t\tmap<ld,int> M;\n\t\trep1(i,n){\n\t\t\tpo *p;\n\t\t\tintersect(se(a,b),se(s[i],t[i]),p);\n\t\t\tif(p == nullptr)continue;\n\t\t\tpo q = similar(a,b,*p,0,1000000000.0);\n\t\t\tM[q.x] = o[i]^l[i];\n\t\t}\n\t\tif(M.size() == 1){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint ret = 0;\n\t\tint pre = M.begin()->sc;\n\t\tfor(pair<ld,int> p: M){\n\t\t\tif(p.sc != pre){\n\t\t\t\tret ++;\n\t\t\t\tpre = p.sc;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define sz(a) a.size()\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(\"%d \",a[_X]);}puts(\"\");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(\"%d \",a[_X][_Y]);puts(\"\");}\n#define bitcount(b) __builtin_popcount(b)\n#define REP(i, s, e) for ( int i = s; i <= e; i++ )  \n \nconst double INF = 1e12;\ntypedef complex<double> P,point;\ntypedef vector<P> G,polygon;\nnamespace std {bool operator < (const P& a, const P& b) {return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);} }\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\nstruct L : public vector<P> {L(const P &a, const P &b) {push_back(a); push_back(b);} };\nstruct C {P p; double r;C(const P &p, double r) : p(p), r(r) { } C(){} };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\n\tif (cross(b, c) < 0)   return -1;\n\tif (dot(b, c) < 0) return +2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n \n// Check Funcs //\nbool intersectLL(const L &l, const L &m) {return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;}\nbool intersectLS(const L &l, const L &s) {return cross(l[1]-l[0], s[0]-l[0])*cross(l[1]-l[0], s[1]-l[0]) < EPS;}\nbool intersectLP(const L &l, const P &p) {return abs(cross(l[1]-p, l[0]-p)) < EPS;}\nbool intersectSS(const L &s, const L &t) {return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;}\nbool intersectSP(const L &s, const P &p) {return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;}\n \n// Where is Point in Polygon? //\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nenum { OUT, ON, IN };\nint contains(const polygon& P, const point& p) {\n\tbool in = false;\n\tfor (int i = 0; i < P.size(); ++i) {\n\t\tpoint a = curr(P,i) - p, b = next(P,i) - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n\t}\n\treturn in ? IN : OUT;\n}\n// Area of Polygon //\ndouble area2(const polygon& P) {\n\tdouble A = 0;\n\tfor (int i = 0; i < P.size(); ++i)A += cross(curr(P, i), next(P, i));\n\treturn A;\n}\n// Totsuhou! Andrew's Monotone Chain //\n \nvector<point> convex_hull(vector<point> ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  vector<point> ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n \nP projection(const L &l, const P &p) {double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);return l[0] + t*(l[0]-l[1]);}\nP reflection(const L &l, const P &p) {return p + 2.0 * (projection(l, p) - p);}\n \ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n \nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n\nvector<int> X;\nvector<int> Y;\n\nint simulate(int id,int ue,vector<int> idx){\n\tint ans = 0;\n\tfor(int i = 0 ; i < idx.size() ; i++){\n\t\tint x = X[idx[i]];\n\t\tint y = Y[idx[i]];\n\t\tif( x == id ){\n\t\t\tif( y == ue ){\n\t\t\t\t\t\n\t\t\t}else{\n\t\t\t\tue ^= 1;\n\t\t\t\tans++;\n\t\t\t}\t\t\t\n\t\t}else{\n\t\t\tif( y == ue ){\n\t\t\t\tue ^= 1;\n\t\t\t\tans++;\t\n\t\t\t}else{\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tP a,b;\n\t\tcin >> a.real() >> a.imag() >> b.real() >> b.imag();\n\t\tint n;\n\t\tvector< pair< double , int> > v;\n\t\tcin >> n;\n\t\tvector<L> l; \n\t\tX.clear();\n\t\tY.clear();\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x1,y1,x2,y2;\n\t\t\tint d,w;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> w >> d;\n\t\t\tl.push_back(L(P(x1,y1),P(x2,y2)));\n\t\t\tX.push_back(w);\n\t\t\tY.push_back(d);\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif(  intersectSS(L(a,b),l[i]) ){\n\t\t\t\tP c = crosspoint(L(a,b),l[i]);\n\t\t\t\tv.push_back(make_pair(abs(c-a),i));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tvector<int> iidx;\n\t\tfor(int i = 0 ; i < v.size() ; i++) iidx.push_back(v[i].second);\n\t\tint ans = 1e9;\n\t\tfor(int i = 0 ; i < 2 ; i++)\n\t\t\tfor(int j = 0 ; j < 2 ; j++)\n\t\t\t\tans = min( simulate(i,j,iidx) , ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\nstruct P {\n  complex<double> p;\n  int h;\n  P(complex<double> p,int h) : p(p),h(h) {;}\n};\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return real(a.p) != real(b.p) ? real(a.p) < real(b.p) : imag(a.p) < imag(b.p);\n  }\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P &a, const P &b) {\n  return imag(conj(a.p)*b.p);\n}\n\n//inner product\ndouble dot(const P &a, const P &b) {\n  return real(conj(a.p)*b.p);\n}\n\nint ccw(P a, P b, P c) {\n  b.p -= a.p;\n  c.p -= a.p;\n  if( cross(b, c) > 0 ) return +1; // counter clockwise\n  if( cross(b, c) < 0 ) return -1; // clockwise\n  if( dot(b, c) < 0 ) return +2;   // c--a--b on line\n  if( norm(b.p) < norm(c.p) ) return -2; // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0]) * ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// a1,a2ツづーツ端ツ点ツづつキツづゥツ静シツ閉ェツづ1,b2ツづーツ端ツ点ツづつキツづゥツ静シツ閉ェツづ個古ーツ点ツ計ツ算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = P(b2.p-b1.p,b1.h);\n  double d1 = abs(cross(b, P(a1.p-b1.p,b1.h)));\n  double d2 = abs(cross(b, P(a2.p-b1.p,b1.h)));\n  double t = d1 / (d1 + d2);\n  return P(a1.p + (a2.p-a1.p) * t,b1.h);\n}\n\nint main() {\n  int num,n,i;\n  cin>>num;\n  while(num--) {\n    vector<L> in;\n    double xa,ya,xb,yb,sx,sy,o,l;\n    cin>>sx>>sy>>xb>>yb;\n    in.push_back(L(P(complex<double>(0,0),0),P(complex<double>(xb-sx,yb-sy),0)));\n    cin>>n;\n    for(int i=0; i<n; ++i) {\n      cin>>xa>>ya>>xb>>yb>>o>>l;\n      int h = (o == 1) ? l : (l == 1) ? 0 : 1;\n      in.push_back(L(P(complex<double>(xa-sx,ya-sy),h),\n\t\t     P(complex<double>(xb-sx,yb-sy),h)));\n    }\n\n    vector<P> cr;\n    for(int i=1; i<=n; ++i) {\n      if(intersectSS(in[0],in[i])) {\n\tcr.push_back(intersection_ls(in[0][0],in[0][1],in[i][0],in[i][1]));\n      }\n    }\n\n    sort(cr.begin(), cr.end());\n    int ans = 0;\n    if(!cr.empty()) {\n      for(int i=0; i<cr.size()-1; ++i) {\n\tif(cr[i].h != cr[i+1].h) {\n\t  ans++;\n\t}\n      }\n    }\n\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<point, point> line;\n\n//b??????a??????????????????\ndouble dis(point a, point b){\n  return abs(a - b);\n}\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\n\ndouble line_to_point_dis(line l, point p){\n  return abs(cross(p - l.first, l.second - l.first))/\n    abs(l.second - l.first);\n}\n\ndouble seg_to_point_dis(line l, point p){\n  point a = l.first, b = l.second, c = p;\n  if(dot(b - a, c - a) < eps)return abs(c - a);\n  if(dot(a - b, c - b) < eps)return abs(c - b);\n  return line_to_point_dis(l, p);\n}\n\ndouble seg_to_seg_dis(line a, line b){\n  double res = seg_to_point_dis(a, b.first);\n  res = min(res, seg_to_point_dis(a, b.second));\n  res = min(res, seg_to_point_dis(b, a.first));\n  res = min(res, seg_to_point_dis(b, a.second));\n  return res;\n}\n\nbool is_cross(line a, line b){\n  if(ccw(a.first, a.second, b.first) *\n     ccw(a.first, a.second, b.second) <= 0 &&\n     ccw(b.first, b.second, a.first) *\n     ccw(b.first, b.second, a.second) <= 0){\n    return true;\n  }\n  return false;\n}\n\n//point a, b, point c, d\npoint seg_to_seg_cross_point(line a, line c){\n  if(not is_cross(a, c)) return point(1e9, 1e9);\n  double xa = a.first.real(),  ya = a.first.imag();\n  double xb = a.second.real(), yb = a.second.imag();\n  double xc = c.first.real(),  yc = c.first.imag();\n  double xd = c.second.real(), yd = c.second.imag();\n  double s  = (ya - yc)*(xb - xa) + (yb - ya)*(xc - xa);\n  double t  = (xb - xa)*(yd - yc) - (xd - xc)*(yb - ya);\n  if(abs(t) < eps) return point(1e9, 1e9);\n  return c.first + s*(c.second - c.first)/t;\n}\n\ntypedef struct ColorLine{\n  ColorLine(){};\n  ColorLine(line _ll, int _o, int _l, point _cp):\n    ll(_ll), o(_o), l(_l), cp(_cp){};\n  void calc(point a){\n    d = dis(a, cp);\n  }\n  line ll;\n  int o, l;\n  point cp;\n  double d;\n  bool operator<(const ColorLine &c){\n    return d < c.d;\n  }\n}ColorLine;\n\nint main(int argc, char *argv[]){\n  point a, b;\n  int n, roop;\n  std::cin >> roop;\n  for (int r = 0; r < roop; r++) {\n    double x, y;\n    int o, l;\n    std::cin >> x >> y;\n    a = point(x, y);\n    std::cin >> x >> y >> n;\n    b = point(x, y);\n    line ll = line(a, b);\n    vector<ColorLine> vl(n);\n    for (int i = 0; i < n; i++) {\n      std::cin >> x >> y;\n      a = point(x, y);\n      std::cin >> x >> y >> o >> l;\n      b = point(x, y);\n      point cp = seg_to_seg_cross_point(line(a, b), ll);\n      vl[i] = ColorLine{line(a, b), o, l, cp};\n      vl[i].calc(ll.first);\n    }\n    sort(vl.begin(), vl.end());\n    bool up = (vl[0].o and vl[0].l) or (not vl[0].o and not vl[0].l);\n    int ans = 0;\n    for (int i = 1; i < n and vl[i].cp != point(1e9, 1e9); i++) {\n      // std::cout << ((vl[i].o)?\"b\":\"r\") << \" \" << ((vl[i].l)?\"o\":\"u\") << std::endl;\n      // std::cout << \"bool:\" << ((vl[i].o and vl[i].l) or (not vl[i].o and not vl[i].l)) << std::endl;\n      // std::cout << up << std::endl;\n      if(up != ((vl[i].o and vl[i].l) or (not vl[i].o and not vl[i].l))){\n        up = not up, ans++;        \n      }\n      //std::cout << \"up:\" << up << std::endl;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\n\n#include <complex>\ntypedef complex<double> P;\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが線分a,b上にあるかないか(2)\nint is_point_on_line(P a, P b, P c) {\n  // |a-c| + |c-b| <= |a-b| なら線分上\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  if (( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS ) &&\n      ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS ))\n\t  return true;\n  return is_point_on_line(a1, a2, b1) || is_point_on_line(a1, a2, b2) ||\n         is_point_on_line(b1, b2, a1) || is_point_on_line(b1, b2, a2);\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// 2つのスカラーが等しいかどうか\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\ntypedef vector<double> vd;\nstruct line{\n\tP start,goal;\n\tint o,l;\n\tP intersection;\n\tbool intersect;\n\tline(P start,P goal,int o,int l):start(start),goal(goal),o(o),l(l),intersect(false){\n\t}\n};\nP start,goal;\nbool pred(const line &left, const line &right){\n\treturn abs(left.intersection-start)<abs(right.intersection-start);\n}\nint main(){\n\tint n_data;\n\tcin>>n_data;\n\tREP(i_data,n_data){\n\t\tint xa,ya,xb,yb;\n\t\tcin>>xa>>ya>>xb>>yb;\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<line> lines;\n\t\tREP(i,n){\n\t\t\tint xs,ys,xt,yt,o,l;\n\t\t\tcin>>xs>>ys>>xt>>yt>>o>>l;\n\t\t\tlines.push_back(line(P(xs,ys),P(xt,yt),o,l));\n\t\t}\n\t\tvector<line> intersections;\n\t\tstart=P(xa,ya);\n\t\tgoal=P(xb,yb);\n\t\tREP(i,n){\n\t\t\tif(is_intersected_ls(start,goal,lines[i].start,lines[i].goal)){\n\t\t\t\tlines[i].intersection=intersection_ls(start,goal,lines[i].start,lines[i].goal);\n\t\t\t\tlines[i].intersect=true;\n\t\t\t\tintersections.push_back(lines[i]);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(intersections),pred);\n\t\tint res=0;\n\t\tint ll=-1;\n\t\tREP(i,intersections.size()){\n\t\t\tif(!intersections[i].intersect)continue;\n\t\t\tif(ll!=-1){\n\t\t\t\tif(ll!=(intersections[i].l+(intersections[i].o==1?0:1))%2){\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll=(intersections[i].l+(intersections[i].o==1?0:1))%2;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<EPS\n\ntypedef pair<double, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      double d1 = (ya-yb)/(xa-xb);\n      double d2 = (y1-y2)/(x1-x2);\n      if(EQ(xa,xb)){\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\t//assert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS ){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(nx, (o==l)));\n      }\n    }\n\n    sort(all(points), sorter);\n\n    rep(i,points.size()) cout<<points[i].second<<\",\";\n    cout<<endl;\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-9)\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected(P a1, P a2, P b1, P b2) {\n  return ( ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS ) );\n}\n\nP s[101], t[101];\nint c[101], l[101];\n\nstruct intersection {\n  double t; // parameter t\n  int n;    // index of intersected line\n\n  bool operator<(const intersection &a) const {\n    return (t < a.t);\n  }\n};\n\nint main() {\n  int N;\n  cin >> N;\n  while (N--) {\n    P a, b;\n    cin >> a.real() >> a.imag();\n    cin >> b.real() >> b.imag();\n\n    int n;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n      cin >> s[i].real() >> s[i].imag();\n      cin >> t[i].real() >> t[i].imag();\n      cin >> c[i] >> l[i];\n    }\n\n    vector<intersection> is;\n    for (int i=0; i<n; i++) {\n      if (!is_intersected(a, b, s[i], t[i])) { continue; }\n      if (abs(cross(b-a, t[i]-s[i])) < EPS) { continue; }\n\n      P x = t[i] - s[i];\n      double d1 = abs(cross(x, a-s[i]));\n      double d2 = abs(cross(x, b-s[i]));\n      double t = d1 / (d1 + d2);\n\n      intersection tmp = {t, i};\n      is.push_back(tmp);\n    }\n\n    sort(is.begin(), is.end());\n\n    int curr; // current status: up (=1) or down (=0)\n    if (is.size() > 0) {\n      int idx = is[0].n;\n      curr = (c[idx] == 1 ? l[idx] : !l[idx]);\n    }\n\n    int cnt = 0;\n    for (int i=1; i<is.size(); i++) {\n      int idx = is[i].n;\n      if ( (c[idx] == 1 && curr != l[idx]) ||\n           (c[idx] == 0 && curr == l[idx]) ) {\n        curr = !curr;\n        cnt++;\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\nstruct Point{double high,x,y;};\n\nbool Intersection(Point p1,Point p2,Point p3,Point p4,Point *ret){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(d==0 || u<0 || u>1 || v<0 || v>1)return false;\n    ret->x = p1.x+u*(p2.x-p1.x);\n    ret->y = p1.y+u*(p2.y-p1.y);\n    return true;\n}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n            Point ret={o==l};\n            if(Intersection(a,b,s,t,&ret)){\n                cross.push_back(ret);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\n// const ll LLINF = (1LL<<60);\n// const int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int T;\n  cin >> T;\n  REP(_, T) {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    if(ax > bx) swap(ax,bx), swap(ay,by);\n    L line(P(ax,ay), P(bx,by));\n\n    // 交点の位置とその交点が高架か地下か\n    vector<pair<P, int>> po;\n    int n;\n    cin >> n;\n    REP(i, n) {\n      int xs, ys, xt, yt, o, l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L l2(P(xs,ys), P(xt,yt));\n      P c = crosspoint(line, l2);\n      if(ax > c.real() || c.real() > bx) continue;\n      po.PB({c, o^l});\n    }\n    sort(ALL(po));\n    // cout << po << endl;\n    int ret = 0;\n    FOR(i, 1, po.size()) {\n      if(po[i].second != po[i-1].second) ret++;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dist(P a, P b) {\n\treturn (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);\n}\nbool isPointOnLine(P a, P b, P c) {\n\treturn abs(a - c) + abs(c - b) < abs(a - b) + EPS;\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\tif (EQ(d2, 0))return P(INF, INF);\n\tP ret = a1 + d1 / d2 * (a2 - a1);\n\tif (isPointOnLine(b1, b2, ret) && isPointOnLine(a1, a2, ret)) {\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn P(INF, INF);\n\t}\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tL N(A, B);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb &t0, pbb &t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L:public vector<P> {\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\n\ndouble dot(P a, P b) {\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return dot(P(-a.imag(),a.real()),b);\n}\n\nint ccw(P a, P b, P c) {\n  b-=a; c-=a;\n  if(cross(b,c)>0)return +1;\n  if(cross(b,c)<0)return -1;\n  if(dot(b,c)<0)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool hit(const L& s, const L& t) {\n  return ccw(s[0],t[0],s[1])*ccw(s[0],t[1],s[1])<=0;\n}\n\ndouble crosslen(const L& s, const L& t) {\n  P ab=s[1]-s[0], ac=t[0]-s[0], ad=t[1]-s[0];\n  ab/=norm(ab);\n  double lac=dot(ab,ac), lad=dot(ab,ad);\n  double dac=abs(ac-ab*lac), dad=abs(ad-ab*lad);\n  return (lac*dad+lad*dac)/(dad+dac);\n}\n\nstruct LINE {\n  L line;\n  int o,l;\n};\n\nstruct POINT {\n  LINE line;\n  double len;\n};\n\nbool comp (POINT a, POINT b) {\n  return a.len < b.len;\n}\n\nint main () {\n  int m;cin>>m;\n  while(m--){\n    vector<POINT> points;\n    vector<LINE> lines;\n    double xa,ya,xb,yb;cin>>xa>>ya>>xb>>yb;\n    int n;cin>>n;\n    L self(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;++i){\n      double a,b,c,d;int e,f;cin>>a>>b>>c>>d>>e>>f;\n      lines.push_back((LINE){L(P(a,b),P(c,d)),e,f});\n    }\n    for(int i=0;i<n;++i)\n      if(hit(self,lines[i].line))\n\tpoints.push_back((POINT){lines[i],crosslen(self,lines[i].line)});\n    sort(points.begin(),points.end(),comp);\n    int len=points.size();\n    LINE line=points[0].line;\n    int precur,cur=0,result=0;\n    if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n    for(int i=1;i<len;++i){\n      line=points[i].line;\n      precur=cur; if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n      if(precur!=cur){++result;}\n    }\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <assert.h>\nusing namespace std;\n\ntypedef pair<double, double> Pdd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef L Segment;\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Segment &s, const Segment &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  \n  int Tc; cin >> Tc;\n  while(Tc--) {\n    vector<pair<Pdd, int> > vec;\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    Segment express(P(xa, ya), P(xb, yb));\n    int N; cin >> N;\n    int O, I;\n    for(int i=0; i<N; i++) {\n      cin >> xa >> ya >> xb >> yb >> O >> I;\n      Segment line(P(xa, ya), P(xb, yb));\n      if(intersectSS(express, line)) {\n\tP crs = crosspoint(express, line);\n\tvec.push_back(make_pair(Pdd(crs.real(), crs.imag()), (O+I)%2));\n      }\n    }\n    \n    sort(vec.begin(), vec.end());\n    \n    int ans = 1<<29;\n    for(int s=0; s<2; s++) {\n      int cnt = 0, now = s;\n      for(int i=0; i<vec.size(); i++) {\n\tif(now == vec[i].second) {\n\t  cnt ++; now = 1-now;\n\t}\n      }\n      ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-13)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<long double,int> Pair;\n\nint u, n;\nlong double xa, ya, xb, yb;\nlong double x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\nlong double cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  long double d1 = abs(cross(b, a1-b1));\n  long double d2 = abs(cross(b, a2-b1));\n  long double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<limits>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntemplate<typename T> bool equals(T a, T b){ return (fabs(a - b)) < EPS;};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstatic const int NOTCROSS = 4;\nstatic const int CIRCUMSCRIBED = 3; \nstatic const int INTERSECT = 2;\nstatic const int INSCRIBED = 1;\nstatic const int INCLUDE = 0;\n\nconst double PI = acos(-1);\n\nclass Point{\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(const Point &p) { x = p.x; y = p.y;};\n\t\n\tPoint operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (const double &a) { return Point(x * a, y * a); }\n\tPoint operator / (const double &a) { return Point(x / a, y / a); }\n\t\n\tPoint & operator = (const Point& p) {x = p.x; y = p.y; return *this;};\n\tPoint & operator += (const Point& p) {x += p.x; y += p.y; return *this;};\n\tPoint & operator -= (const Point& p) {x -= p.x; y -= p.y; return *this;};\n\tPoint & operator *= (const Point& p) {x *= p.x; y *= p.y; return *this;};\n\tPoint & operator /= (const Point& p) {x /= p.x; y /= p.y; return *this;};\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\t\n\tbool operator > (const Point &p) const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\t\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\t\n\tdouble abs() { return sqrt(norm()); };\n\tdouble norm() { return x * x + y * y;};\n};\n\ntypedef Point Vector;\n\n\ndouble norm(Vector a){\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Segment{\n\tPoint p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isPrallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < - EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersect(Circle c1, Circle c2){\n\tdouble dis = abs(c1.c - c2.c);\n\t\n\tif(dis > c1.r + c2.r + EPS) return NOTCROSS;\n\tif(fabs(dis - c1.r - c2.r) < EPS) return CIRCUMSCRIBED;\n\tif(dis > fabs(c1.r - c2.r) + EPS) return INTERSECT;\n\tif(fabs(dis - fabs(c1.r - c2.r)) < EPS) return INSCRIBED;\n\treturn INCLUDE;\n}\n\ndouble getDistance(Point a, Point b){\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrosPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l){\n\treturn getDistanceLP(l, c.c) < c.r + EPS;\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\tassert(intersect(c,l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e *base);\n}\n\ndouble arg(Vector p) {return atan2(p.y, p.x);}\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a);}\n\n\npair<Point, Point> getCrosPoint(Circle c1, Circle c2){\n\tPoint res1, res2;\n\tint ins = intersect(c1, c2);\n\tif(ins == NOTCROSS || ins == INCLUDE) {\n\t\tassert(false); // 0\n\t}\n\tif(ins == INSCRIBED && equals(c1.r, c2.r)){\n\t\tassert(false); // infinity\n\t}\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tres1 = c1.c + polar(c1.r, t + a);\n\tres2 = c1.c + polar(c1.r, t - a);\n\treturn make_pair(res1, res2);\n}\n\n\ndouble getArea(Circle c){\n\treturn c.r*c.r*PI;\n}\n\ndouble getArea(Polygon& p){\n\tdouble area = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tarea += (p[i].x * p[(i + 1) % p.size()].y - p[(i + 1) % p.size()].x * p[i].y);\n\t}\n\t\n\treturn fabs(area)/2;\n}\n\nbool isConvex(Polygon& p){\n\tint b = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tint j = (i + 1) % p.size(), k = (i + 2) % p.size();\n\t\tint c = ccw(p[i], p[j], p[k]);\n\t\tif(c == ON_SEGMENT || c == ONLINE_BACK || c == ONLINE_FRONT) continue;\n\t\tif(c*b < 0) return false;\n\t\tif(!b) b = c;\n\t}\n\t\n\treturn 1;\n}\n\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N;\n\t\n\tcin>>N;\n\t\n\tfor(int _ = 0; _ < N; _++) {\n\t\tint n;\n\t\tint ans = 0;\n\t\tSegment S;\n\t\tvector<pair<double,bool>> dis;\n\t\t\n\t\t// cin>>n;\n\t\tcin>>S.p1.x>>S.p1.y>>S.p2.x>>S.p2.y;\n\t\t\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint o, l;\n\t\t\tbool X = true;\n\t\t\tSegment T;\n\t\t\t\n\t\t\tcin>>T.p1.x>>T.p1.y>>T.p2.x>>T.p2.y;\n\t\t\t\n\t\t\tcin>>o>>l;\n\t\t\t\n\t\t\tif(o == l) X = false;\n\t\t\t\n\t\t\tif(intersect(S, T)) {\n\t\t\t\tPoint p = getCrosPoint(S, T);\n\t\t\t\t\n\t\t\t\tdis.push_back({getDistance(S.p1, p), X});\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(dis.begin(), dis.end());\n\t\t\n\t\tfor(int i = 1; i < dis.size(); i++){\n\t\t\tif(dis[i].second != dis[i-1].second)  ans++;\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <limits>\n\nusing namespace std;\n\ntypedef struct {\n    double x, y;\n} pt;\n\ntypedef pair<pt, pt> seg;\n\nseg mkseg(double ax, double ay, double bx, double by) {\n    pt a = {ax, ay};\n    pt b = {bx, by};\n    return seg(a, b);\n}\n\ndouble inf = numeric_limits<double>::infinity();\n\npt seg_cross(seg a, seg b) {\n    double A = (a.second.x - a.first.x) / (a.second.y - a.first.y);\n    double B = (b.second.x - b.first.x) / (b.second.y - b.first.y);\n\n    if (A == inf) {\n        double y = a.second.y;\n        double x = B * (y - b.first.y) + b.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    if (B == inf) {\n        double y = b.second.y;\n        double x = A * (y - a.first.y) + a.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    double y = (A * a.first.y - B * b.first.y + b.first.x - a.first.x) / (A - B);\n    double x = A * (y - a.first.y) + a.first.x;\n    pt p = {x, y};\n    return p;\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n\n    seg new_seg = mkseg(ax, ay, bx, by);\n\n    int n;\n    cin >> n;\n\n    vector< pair<pt, bool> > pts;\n\n    while (n--) {\n        int ax_, ay_, bx_, by_;\n        int pos, owner;\n        cin >> ax_ >> ay_ >> bx_ >> by_ >> pos >> owner;\n\n        seg s = mkseg(ax_, ay_, bx_, by_);\n\n        double minx = min(ax_, bx_);\n        double maxx = max(ax_, bx_);\n\n        pt c = seg_cross(new_seg, s);\n        cerr << \"CROSS AT \" << c.x << \",\" << c.y << endl;\n\n        bool flag = (pos == 1) ^ (owner == 1);\n        if (minx <= c.x && c.x <= maxx && min(ax, bx) <= c.x && c.x <= max(ax, bx)) {\n            cerr << \"PUSH \" << c.x << \",\" << c.y << endl;\n            pts.push_back(make_pair(c, flag));\n        }\n\n        // route r;\n        // line l = line_from_point(ax_, ay_, bx_, by_);\n        // r.minx = min(ax_, bx_);\n        // r.maxx = max(ax_, bx_);\n        // r.flag = (pos == 1) ^ (owner == 1);\n\n        // point cp = cross_point(new_line, l);\n        // double cpx = cp.first;\n        // if (r.minx <= cpx && cpx <= r.maxx && ax <= cpx && cpx <= bx) {\n        //     cross_points.push_back(make_pair(cp, r.flag));\n        // }\n    }\n\n    struct {\n        bool operator()(pair<pt, bool> a, pair<pt, bool> b) {\n            return a.first.x < b.first.x;\n        }\n    } by_x;\n\n    sort(pts.begin(), pts.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<pt, bool> >::iterator it = pts.begin(); it != pts.end(); it++) {\n        pair<pt, bool> p = *it;\n        cerr << \"FOUND \" << p.first.x << \" \" << p.first.y << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n\n    /*\n    struct {\n        bool operator()(pair<point, bool> a, pair<point, bool> b) {\n            return a.first.first < b.first.first;\n        }\n    } by_x;\n\n    sort(cross_points.begin(), cross_points.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<point, bool> >::iterator it = cross_points.begin(); it != cross_points.end(); it++) {\n        pair<point, bool> p = *it;\n        // cout << p.first.first << \" \" << p.first.second << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n    */\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef complex<FP> P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nbool onl(P a1,P a2,P b){\n  return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;\n}\n\nint xs[100],ys[100],xt[100],yt[100],o[100],l[100];\n\nvoid solve(){\n  int xa,ya,xb,yb;\n  cin >> xa >> ya >> xb >> yb;\n  vector<pair<FP,int> > arr;\n  int n;\n  cin >> n;\n  rep(i,n) cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n  rep(i,n){\n    P a(xs[i],ys[i]),b(xt[i],yt[i]);\n    P c(xa,ya),d(xb,yb);\n    P cr=crspt(a,b,c,d);\n    if(onl(a,b,cr) && onl(c,d,cr))\n      arr.pb(mp(abs(c-cr),o[i]^l[i]));\n  }\n  sort(ALL(arr));\n  int ans=0;\n  rep(i,SZ(arr)-1) ans += arr[i].S != arr[i+1].S;\n  cout << ans << endl;\n}\n    \n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nstruct rail{\n\tint sx;\n\tint sy;\n\tint gx;\n\tint gy;\n};\n\ndouble cross(rail v1,rail v2){//?????????v1?????????????????????\n\tint cv1v2=(v1.gx - v1.sx)*(v2.gy - v2.sy) - (v1.gy - v1.sy)*(v2.gx - v2.sx);\n\tint cvv2 = (v2.sx - v1.sx)*(v2.gy - v2.sy) - (v2.sy-v1.sy)*(v2.gx - v2.sx);\n\tif (cv1v2 == 0)\n\t\treturn 0.0;\n\treturn (double)cvv2/(double)cv1v2;\n}\nstruct cross_t{\n\tint no;\n\tdouble dis;\n};\n\nbool operator < (const cross_t &left, const cross_t &right){\n\treturn left.dis < right.dis;\n};\nint main() {\n\t\n\tint dataset;\n\tcin >> dataset;\n\twhile (dataset--){\n\t\trail atob;\n\t\tcin >> atob.sx;\n\t\tcin >> atob.sy;\n\t\tcin >> atob.gx;\n\t\tcin >> atob.gy;\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<rail> vr(n);\n\t\tvector<bool> high_b(n);\n\t\tpriority_queue<cross_t> P;\n\t\tREP(i, n){\n\t\t\tcin >> vr[i].sx;\n\t\t\tcin >> vr[i].sy;\n\t\t\tcin >> vr[i].gx;\n\t\t\tcin >> vr[i].gy;\n\t\t\tint mine,high;\n\t\t\tcin >> mine;\n\t\t\tcin >> high;\n\t\t\thigh_b[i] = (mine == high);\n\t\t\tdouble t = cross(atob, vr[i]);\n\t\t\tif (0.0f<t && t<1.0f)P.push({ i, t });\n\t\t}\n\t\tbool b=false;\n\t\tint ans = 0;\n\t\tint ps = P.size();\n\n\t\tREP(i, ps){\n\t\t\tcross_t p = P.top();\n\t\t\tP.pop();\n\t\t\tif (i == 0){\n\t\t\t\tb = high_b[p.no];\n\t\t\t}else{\n\t\t\t\tif (b != high_b[p.no]){\n\t\t\t\t\tans++;\n\t\t\t\t\tb = high_b[p.no];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << (ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n    double x, y;\n    \n    Point(double x = 0, double y = 0): x(x), y(y) {}\n\n    Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n    Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n    Point operator * (double a) { return Point(a * x, a * y); }\n    Point operator / (double a) { return Point(x / a, y / a); }\n\n    double norm() {return x * x + y * y; }\n    double abs() {return sqrt(norm()); }\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2): p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\nbool intersection(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n    double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n    double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n    double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n    return (ta * tb < 0 && tc * td < 0);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nint main(){\n    int q; cin>>q;\n    while(q--){\n        double xa, ya, xb, yb; cin>>xa>>ya>>xb>>yb;\n        Segment s1 = {Point(xa, ya), Point(xb, yb)};\n        int n; cin>>n;\n        vector<tuple<double, double, bool>> point;\n        for(int i=0; i<n; i++){\n            double xs, ys, xt, yt; \n            int o, l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            Segment s2 = {Point(xs, ys), Point(xt, yt)};\n\n            if(intersection(xa, ya, xb, yb, xs, ys, xt, yt)){\n                Point p1 = getCrossPoint(s1, s2);\n                double px = p1.x;\n                double py = p1.y;\n\n                if((o == 1 && l == 1) || (o == 0 && l == 0)){\n                    point.emplace_back(px, py, true);\n                }\n                else{\n                    point.emplace_back(px, py, false);\n                }\n            }\n        }\n\n        sort(point.begin(), point.end());\n\n        int ans = 0;\n        for(int i=0; i<(int)point.size()-1; i++){\n            if(get<2>(point[i]) != get<2>(point[i+1])){\n                ans++;\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> Point\ntemplate <class T>\nstruct Point {\n    T x,y;\n    constexpr Point(T x = 0, T y = 0) : x(x), y(y) {}\n    constexpr pair<T,T> to_pair() const { return {x,y}; }\n    constexpr Point inv() const { return {x/norm(),-y/norm()}; }\n    constexpr Point conj() const { return {x,-y}; }\n    constexpr T norm() const { return x*x + y*y; }\n    constexpr Point rot90(int n = 1) const {\n        n %= 4; if (n < 0) n += 4;\n        if (n == 1) return *this * Point(0,1);\n        if (n == 2) return *this * (-1);\n        if (n == 3) return *this * Point(0,-1);\n        return *this;\n    }\n    constexpr Point operator+() const { return *this; }\n    constexpr Point operator-() const { return {-x,-y}; }\n    constexpr Point operator+(Point const& p) const { return {x+p.x, y+p.y}; }\n    constexpr Point operator-(Point const& p) const { return {x-p.x, y-p.y}; }\n    constexpr Point operator*(Point const& p) const { return {x*p.x-y*p.y, x*p.y+y*p.x}; }\n    constexpr Point operator/(Point const& p) const { return *this * p.inv(); }\n    constexpr Point& operator+=(Point const& p) { return *this = *this + p; }\n    constexpr Point& operator-=(Point const& p) { return *this = *this - p; }\n    constexpr Point& operator*=(Point const& p) { return *this = *this * p; }\n    constexpr Point& operator/=(Point const& p) { return *this = *this / p; }\n    constexpr friend Point operator*(T const& a, Point const& p) { return Point(a)*p; }\n    constexpr friend Point operator/(T const& a, Point const& p) { return Point(a)/p; }\n    constexpr T dot(Point const& q) const { return x*q.x + y*q.y; }\n    constexpr T cross(Point const& q) const { return x*q.y - y*q.x; }\n\n    constexpr friend Point conj(Point const& p) { return p.conj(); }\n    constexpr friend T norm(Point const& p) { return p.x*p.x + p.y*p.y; }\n    constexpr friend T dot(Point const& p, Point const& q) { return p.dot(q); }\n    constexpr friend T cross(Point const& p, Point const& q) { return p.cross(q); }\n#ifdef LOCAL\n    friend string to_s(Point const& p) { return to_s(p.to_pair()); }\n#endif\n    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n};\n// <<<\n\nusing Real = double;\nusing P = Point<Real>;\nconstexpr Real eps = 1e-10;\nconstexpr Real pi = acos(-1.0L);\nconstexpr Real to_rad(int deg) { return Real(deg) * pi / 180; }\nconstexpr Real to_deg(Real rad) { return rad * 180 / pi; }\n\nconstexpr bool operator==(Point<int> const& p, Point<int> const& q) {\n    return p.x == q.x && p.y == q.y;\n}\nconstexpr bool operator==(Point<Real> const& p, Point<Real> const& q) {\n    return abs(p.x-q.x) < eps && abs(p.y-q.y) < eps;\n}\ntemplate <class T>\nconstexpr bool operator!=(Point<T> const& p, Point<T> const& q) {\n    return !(p == q);\n}\n\ntemplate <class T>\nconstexpr bool operator<(Point<T> const& p, Point<T> const& q) {\n    return p.to_pair() < q.to_pair();\n}\n\nconstexpr Real abs(Point<Real> const& p) { return sqrt(p.norm()); }\nconstexpr Point<Real> normalize(Point<Real> const& p) { return p/abs(p); }\n\ntemplate <class T> constexpr T sq(T const& x) { return x*x; }\n\nconstexpr int sgn(Real x) {\n    if (x > +eps) return +1;\n    if (x < -eps) return -1;\n    return 0;\n}\n\nstruct Segment {\n    Point<Real> p,q;\n    constexpr Segment() : p{},q{} {};\n    constexpr Segment(Point<Real> const& p, Point<Real> const& q) : p(p), q(q) {};\n};\n\n#ifdef LOCAL\nstring to_s(Segment const& a) {\n    return to_s(make_pair(a.p,a.q));\n}\n#endif\n\nbool intersect(Segment a, Segment b) {\n    auto f = [](Real l1, Real r1, Real l2, Real r2) {\n        if (l1 > r1) swap(l1,r1);\n        if (l2 > r2) swap(l2,r2);\n        return sgn(max(l1,l2)-min(r1,r2));\n    };\n    return f(a.p.x, a.q.x, b.p.x, b.q.x) <= 0\n        && f(a.p.y, a.q.y, b.p.y, b.q.y) <= 0\n        && sgn(cross(a.q-a.p, b.p-a.p))*sgn(cross(a.q-a.p, b.q-a.p)) <= 0\n        && sgn(cross(b.q-b.p, a.p-b.p))*sgn(cross(b.q-b.p, a.q-b.p)) <= 0;\n}\n\n// >>> RLE for vector\ntemplate <class T>\nvector<pair<T,int> > RLE(vector<T> const& v) {\n    if (v.empty()) return {};\n    vector<pair<T,int> > ret;\n    int ii = -1, n = v.size();\n    rep (i,n) if (i == n-1 || v[i] != v[i+1]) {\n        ret.emplace_back(v[i],i-ii);\n        ii = i;\n    }\n    return ret;\n}\n// <<<\nvoid solve() {\n    P A,B; cin >> A >> B;\n    int n; cin >> n;\n    vector<P> s(n),t(n);\n    vector<int> owner(n),type(n);\n    rep (i,n) cin >> s[i] >> t[i] >> owner[i] >> type[i];\n    rep (i,n) type[i] ^= owner[i];\n\n    vector<pair<double,int>> v;\n    rep (i,n) if (intersect(Segment(A,B),Segment(s[i],t[i]))) {\n        auto x = abs(cross(s[i]-A,t[i]-A));\n        auto y = abs(cross(s[i]-B,t[i]-B));\n        auto d = abs(A-B)/(x+y)*x;\n        v.eb(d,i);\n    }\n    sort(all(v));\n    dump(v);\n    vector<int> a(v.size());\n    rep (i,v.size()) a[i] = type[v[i].snd];\n\n    int len = RLE(a).size();\n    cout << max(0LL,len-1) << \"\\n\";\n\n\n}\n\nint32_t main() {\n    int t; cin >> t;\n    while (t--) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int64_t a, int64_t b, int64_t c, int64_t d, int64_t e, int64_t f, int64_t g, int64_t h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int64_t a, int64_t b, int64_t c, int64_t d, int64_t e, int64_t f, int64_t g, int64_t h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int64_t n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int64_t e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n         << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\nconst D EPS = 1e-9;\n#define se second\n#define fi first\n#define mk make_pair\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n  if (EQ(d2, 0)) throw \"c7c7\";\n  return a1 + d1/d2 * (a2-a1);\n}\nP x;\nL a,t;\nvector<pair<pair<double,double>,pair<int,int> > >v;\nint main(){\n  int m,n,a1,a2;\n  cin>>m;\n  while(m--){\n    int ans=0;\n    v.clear();\n    D p1,p2,p3,p4;\n    cin>>p1>>p2>>p3>>p4>>n;\n    a.fi=P(p1,p2),a.se=P(p3,p4);\n    rep(i,n){\n      cin>>p1>>p2>>p3>>p4>>a1>>a2;\n      t.fi=P(p1,p2),t.se=P(p3,p4);\n      if(!isecSS(a.fi,a.se,t.fi,t.se))continue;\n      x=crosspointLL(a.fi,a.se,t.fi,t.se);\n      v.push_back(mk(mk(x.Y,x.X),mk(a1,a2)));\n    }\n    sort(v.begin(),v.end());\n    rep(i,v.size())if(i){\n      int q1=v[i-1].se.fi,q2=v[i].se.fi;\n      int q3=v[i-1].se.se,q4=v[i].se.se;\n      if(q1==q2&&q3!=q4)ans++;\n      if(q1!=q2&&q4==q3)ans++;\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<EPS\n\ntypedef pair<double, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      if(EQ(xa,xb)){\n      double d1 = (ya-yb)/(xa-xb);\n      double d2 = (y1-y2)/(x1-x2);\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n      double d1 = (ya-yb)/(xa-xb);\n      double d2 = (y1-y2)/(x1-x2);\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n      double d1 = (ya-yb)/(xa-xb);\n      double d2 = (y1-y2)/(x1-x2);\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\tassert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS ){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(nx, (o==l)));\n      }\n    }\n\n    sort(all(points), sorter);\n\n    rep(i,points.size()) cout<<points[i].second<<\",\";\n    cout<<endl;\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nstruct  Coordinate {\n\tlong double x;\n\tlong double y;\n\tCoordinate(long double a, long double b) {\n\t\tx = a, y = b;\n\t}\n\tCoordinate() {\n\t}\n\tCoordinate operator + (const Coordinate& c)const {\n\t\tCoordinate box;\n\t\tbox.x = x + c.x;\n\t\tbox.y = y + c.y;\n\t\treturn box;\n\t}\n\tCoordinate operator - (const Coordinate& c)const {\n\t\tCoordinate box;\n\t\tbox.x = x - c.x;\n\t\tbox.y = y - c.y;\n\t\treturn box;\n\t}\n};\n\nstruct Line {\n\tlong double a, b, c;\n\tLine(const int aa, const int bb, const int cc) {\n\t\ta = aa, b = bb, c = cc;\n\t}\n\tLine(const Coordinate s, const Coordinate t) {\n\t\tif (abs(s.x - t.x) < EPS) {\n\t\t\ta = 1;\n\t\t\tb = 0;\n\t\t}\n\t\telse {\n\t\t\tb = 1;\n\t\t\ta = (t.y - s.y) / (s.x - t.x);\n\t\t}\n\t\tc = s.x*a + s.y*b;\n\t}\n};\n\nlong double dot(Coordinate a, Coordinate b) {\n\treturn a.x*b.x + a.y*b.y;\n}\n\nlong double cross(Coordinate a, Coordinate b) {\n\treturn a.x*b.y - b.x*a.y;\n}\n\nlong double Distance(Coordinate a, Coordinate b) {\n\treturn sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n}\n\nbool LineCross(Coordinate a1, Coordinate a2, Coordinate b1, Coordinate b2) {\n\treturn cross(a2 - a1, b1 - a1)*cross(a2 - a1, b2 - a1) < EPS&&cross(b2 - b1, a1 - b1)*cross(b2 - b1, a2 - b1) < EPS && !((a1 - a2).x*(a1 - b1).y == (a1 - a2).y*(a1 - b1).x && (a1 - a2).x*(a1 - b2).y == (a1 - a2).y*(a1 - b2).x&&abs(Distance(a1, a2) - Distance(a1, b1) - Distance(a2, b1)) > EPS&&abs(Distance(a1, a2) - Distance(a2, b2) - Distance(a1, b2)) > EPS&&abs(Distance(b1, b2) - Distance(a1, b1) - Distance(a1, b2)) > EPS&&abs(Distance(b1, b2) - Distance(a2, b1) - Distance(a2, b2)) > EPS);\n}\n\nCoordinate LineCross(Line a, Line b) {\n\tCoordinate ret;\n\tret.x = (a.c*b.b - a.b*b.c) / (a.a*b.b - a.b*b.a);\n\tret.y = -(a.c*b.a - a.a*b.c) / (a.a*b.b - a.b*b.a);\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> T;\n\twhile (T--) {\n\t\tlong double ax, ay, bx, by;\n\t\tcin >> ax >> ay >> bx >> by;\n\t\tcin >> N;\n\t\tvector<long double>sx(N);\n\t\tvector<long double>sy(N);\n\t\tvector<long double>gx(N);\n\t\tvector<long double>gy(N);\n\t\tvector<int>a(N);\n\t\tvector<int>b(N);\n\t\tvector<pair<long double, int>>p;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> sx[i] >> sy[i] >> gx[i] >> gy[i] >> a[i] >> b[i];\n\t\t\tif (!a[i])b[i] ^= 1;\n\t\t\tif (LineCross(Coordinate(sx[i], sy[i]), Coordinate(gx[i], gy[i]), Coordinate(ax, ay), Coordinate(bx, by))) {\n\t\t\t\tauto c = LineCross(Line(Coordinate(sx[i], sy[i]), Coordinate(gx[i], gy[i])), Line(Coordinate(ax, ay), Coordinate(bx, by)));\n\t\t\t\tp.push_back({ Distance(c,Coordinate(ax,ay)),b[i] });\n\t\t\t}\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < p.size(); i++) {\n\t\t\tif (p[i].second != p[i - 1].second)ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n         << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\n// const ll LLINF = (1LL<<60);\n// const int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nbool contain(const L &l, const P &p) {\n  double ax = l[0].real(), ay = l[0].imag();\n  double bx = l[1].real(), by = l[1].imag();\n  if(ax > bx) swap(ax, bx);\n  if(ay > by) swap(ay, by);\n  return (ax > p.real() || bx < p.real() || ay > p.imag() || by < p.imag());\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int T;\n  cin >> T;\n  REP(_, T) {\n    double ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    L line(P(ax,ay), P(bx,by));\n\n    // 交点の位置とその交点が高架か地下か\n    vector<pair<P, int>> po;\n    int n;\n    cin >> n;\n    REP(i, n) {\n      double xs, ys, xt, yt;\n      int o, l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L l2(P(xs,ys), P(xt,yt));\n      P c = crosspoint(line, l2);\n      if(contain(line, c) || contain(l2, c)) continue;\n      po.PB({c, o^l});\n    }\n    sort(ALL(po));\n    // cout << po << endl;\n    int ret = 0;\n    FOR(i, 1, po.size()) {\n      if(po[i].second != po[i-1].second) ret++;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n\nusing namespace std;\n#define EPS 1e-12\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nconst double PI = 4*atan(1.0);\n\ntypedef complex<double> C;\nstruct L : public vector<C>\n{\n  L(){}\n  L(const C a, const C b){\n    push_back(a); push_back(b);\n  }\n  L(double xa,double ya,double xb,double yb){\n    push_back(C(xa,ya));push_back(C(xb,yb));\n  }\n};\n\nstruct mycp\n{\n  C cp;\n  int ul;\n  int st;\n  bool operator<(const mycp& another) const {\n    return cp.real()<another.cp.real();\n  }\n  mycp(const C cpp,int ull,int stt){\n    cp = cpp; ul = ull; st = stt;\n  }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n\nint main(){\n  int dn;\n  cin >>dn;\n  rep(fdsa,dn){\n    int xa,ya,xb,yb,n;\n    cin >> xa >> ya >> xb >> yb >> n;\n    if (xa>xb){swap(xa,xb);swap(ya,yb);}\n    L newl(xa,ya,xb,yb);\n\n    vector<int> o(n),l(n);\n    vector<L> s,t;\n    vector<int> s_ul,t_ul;\n\n    rep(i,n){\n      int xs,ys,xt,yt,o,l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L line(xs,ys,xt,yt);\n      if (o==1){\n        s.push_back(line);\n        s_ul.push_back(l);\n      } else {\n        t.push_back(line);\n        t_ul.push_back(l);\n      }\n    }\n\n    vector<mycp> mycps;\n    rep(i,s.size()){\n      if (intersectSS(newl,s[i])){\n        mycp m(crosspointLL(newl,s[i]),s_ul[i],1);\n        mycps.push_back(m);\n      }\n    }\n    rep(i,t.size()){\n      if (intersectSS(newl,t[i])){\n        mycp m(crosspointLL(newl,t[i]),t_ul[i],0);\n        mycps.push_back(m);\n      }\n    }\n    sort(mycps.begin(),mycps.end());\n    int minn = 1e9;\n    rep(i,2){rep(j,2){\n      int cur_ul_end = j;\n      int cur_ul = i;\n      int cnt = 0;\n      for(auto s:mycps){\n        if (s.st==1){\n          if (s.ul!=cur_ul){\n            cnt++;\n            cur_ul = 1-cur_ul;\n          }\n        } else {\n          if (s.ul==cur_ul){\n            cnt++;\n            cur_ul = 1-cur_ul;\n          }\n        }\n      }\n      if (cur_ul!=cur_ul_end)cnt++;\n      if (cnt<minn)minn=cnt;\n    }}\n\n    cout << minn << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "homono"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double>P;\ntypedef vector<P>POL;\n\nconst double INF = 1e12;\n\nnamespace std{\n  bool operator < (const P&a, const P& b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct Data{\n  P p;\n  bool mine,up;\n  bool operator < (const Data &d)const{\n    return p < d.p;\n  }\n};\n\nstruct L : public POL{\n  L(){};\n  bool mine,up;\n  L(const P &a, const P &b){\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b){\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P&b){\n  return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c) > 0)return 1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) < norm(c))return -2;\n  return 0;\n}\n\nbool intersectSS(const L &s,const L&t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP intersection_ss(L line1, L line2){\n  if(!intersectSS(line1,line2))return P(INF,INF);\n  P a = line1[1] - line1[0]; P b = line2[1] - line2[0];\n  return line1[0] + a * cross(b,line2[0]-line1[0]) / cross(b,a);\n}\n\nvector<Data>vec;\nL line;\n\nvoid input(){\n  P p1,p2;\n  cin >> p1.X >> p1.Y >> p2.X >> p2.Y;\n  line = L(p1,p2);\n  line.mine = true;\n\n  int n;\n  cin >> n;\n  for(int i = 0 ; i < n ; i++){\n    cin >> p1.X >> p1.Y >> p2.X >> p2.Y;\n    L l = L(p1,p2);\n    cin >> l.mine >> l.up;\n    if(intersectSS(line,l)){\n      Data d;\n      d.p = intersection_ss(line,l);\n      d.mine = l.mine;\n      d.up = l.up;\n      vec.push_back(d);\n    }\n  }\n}\n\nint solve(){\n  vec.clear();\n  input();\n\n  bool up;\n  int res = 0;\n\n\n  if(vec.size() == 0)return 0;\n\n  sort(vec.begin(),vec.end());\n  \n  if(vec[0].mine) up = vec[0].up;\n  else up = !vec[0].up;\n\n  for(int i = 1 ; i < vec.size() ; i++){\n    if(vec[i].mine){\n      if(up != vec[i].up){\n\tup = !up;\n\tres++;\n      }\n    }\n    else {\n      if(up == vec[i].up){\n\tup = !up;\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int tc;\n  cin >> tc;\n  while(tc--){\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<complex>\n#include<assert.h>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int yy;\n  cin >> yy;\n  REP(k,yy){\n    double a,b,c,d;\n    cin >> a >> b >> c >> d;\n    P f,t;\n    f = P(a,b);\n    t = P(c,d);\n    L one = L(f,t);\n    ll n;\n    cin >> n;\n    vector <L> l;\n    vector <ll> o;\n    vector <ll> r;\n    REP(i,n){\n      double s2,s1,t1,t2;\n      ll o1,r1;\n      cin >> s1 >> s2 >> t1 >> t2 >> o1 >> r1;\n      f = P(s1,s2);\n      t = P(t1,t2);\n      L te = L(f,t);\n      o.pb(o1);\n      r.pb(r1);\n      l.pb(te);\n    }\n    ll index = 0;\n    P com = P(-1000,-1000);\n    vector <P> crossp;\n    REP(i,l.size()){\n      P comp;\n      if(intersectSS(one,l[i])){\n\tcomp = crosspoint(one,l[i]);\n\tcrossp.pb(comp);\n      }\n      \n      \n    }\n    sort(crossp.begin(),crossp.end());\n    \n    ll fl = 1;\n    \n    /*REP(i,crossp.size())\n      cout << crossp[i].real() << \"  \" << crossp[i].imag() << endl; \n    */\n    ll cnt = 0,cnt2 = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    index = 0;\n    fl = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt2++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt2++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    cout << min(cnt,cnt2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint crs(double x1, double y1, double x2, double y2) {\n    double z = x1*y2-y1*x2;\n    return (0 < z ? 1 : (z < 0 ? -1 : 0));\n}\n\nbool intersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (0 <= crs(x2-x1, y2-y1, x3-x1, y3-y1) * crs(x2-x1, y2-y1, x4-x1, y4-y1)) return false;\n    if (0 <= crs(x4-x3, y4-y3, x1-x3, y1-y3) * crs(x4-x3, y4-y3, x2-x3, y2-y3)) return false;\n    return true;\n}\n\npair<double,double> intersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (x3 == x4) {\n        swap(x1, x3); swap(y1, y3); swap(x2, x4); swap(y2, y4);\n    }\n    double x, y, a, b, c, d;\n    if (x1 == x2) {\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = x1;\n        y = c*x+d;\n    } else {\n        a = (y2-y1)/(x2-x1);\n        b = y1-a*x1;\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = (d-b)/(a-c);\n        y = a*x+b;\n    }\n    return make_pair(x,y);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        double xa, ya, xb, yb;\n        int n;\n        cin >> xa >> ya >> xb >> yb >> n;\n        bool vertical = abs(xa-xb) < abs(ya-yb);\n\n        double xs, ys, xt, yt;\n        int o, l;\n        vector<pair<double,int> > levels;\n        for (int i=0; i<n; ++i) {\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            if (intersect(xa, ya, xb, yb, xs, ys, xt, yt)) {\n                if (vertical) {\n                    double y = intersection(xa, ya, xb, yb, xs, ys, xt, yt).second;\n                    levels.push_back(make_pair(y, o==1 ? l : 1-l));\n                } else {\n                    double x = intersection(xa, ya, xb, yb, xs, ys, xt, yt).first;\n                    levels.push_back(make_pair(x, o==1 ? l : 1-l));\n                }\n            }\n        }\n\n        sort(levels.begin(), levels.end());\n        int res = 0;\n        for (int i=1; i<(int)levels.size(); ++i) {\n            if (levels[i].second != levels[i-1].second) {\n                res ++;\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//XY座標\n#define X real()\n#define Y imag()\n\n// 許容する誤差ε\nconst double EPS = (1e-8);\n// 円周率\nconst double PI = 3.14159265358979;\n// infinity\nconst double INF = 1e12;\n\n// 点の表現\ntypedef complex<double> P;\n\n// complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// 2乗する\ndouble sq(double x){\n\treturn x * x;\n}\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n// 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b){\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a){\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a){\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a){\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross( P a, P b) {\n\treturn imag( conj(a) * b );\n}\n\n// 2 直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n\treturn equal( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点 c が直線 a, b 上にあるかどうか \nint is_point_on_line(P a, P b, P c) {\n\treturn equal( cross(b-a, c-a), 0.0 );\n}\n\n// 下記は (1) より (2) のほうが簡潔で良い.\n\n// 点 c が線分 a, b 上にあるかどうか (1)\nint is_point_on_line_1(P a, P b, P c) {\n  return equal( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点 c が線分 a, b 上にあるかないか(2)\nint is_point_on_line_2(P a, P b, P c) {\n\t// |a-c| + |c-b| <= |a-b| なら線分上\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点 a, bを通る直線と点 c との距離\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点 a, b を端点とする線分と点 c との距離\ndouble distance_ls_p(P a, P b, P c) {\n\tif( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\t\n\treturn a1 + (a2-a1) * t;\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n\treturn !equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n\tP a = a2 - a1; P b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i_=0 ; i_ < N ; i_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa,ya), B(xb,yb);\n\t\t\n\t\t// 点Aと交点の距離と交点で地下と高架のどちらを通るべきか保持\n\t\tvector< pair<double,int> > v;\n\t\t\n\t\tcin >> n;\n\t\tfor(int j_=0 ; j_ < n ; j_++ ){\n\t\t\tint sx,sy,tx,ty,o,l;\n\t\t\tcin >> sx >> sy >> tx >> ty >> o >> l;\n\t\t\tP S(sx,sy), T(tx,ty);\n\t\t\t\n\t\t\t// 交差するかどうか\n\t\t\tif( is_intersected_ls( A , B , S , T ) ){\n\t\t\t\t// 平行かどうか\n\t\t\t\tif( is_parallel( A , B , S , T ) ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// 交点\n\t\t\t\tP p = intersection_l( A , B , S , T );\n\t\t\t\t// 距離\n\t\t\t\tdouble dist = abs(A-p);\n\t\t\t\t\n\t\t\t\tv.push_back( pair<double,int>(dist,o^l) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort( v.begin() , v.end() );\n\t\tint ans=0;\n\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\tif( v[i-1].second != v[i].second ){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\n#define N 100\ntypedef complex<double> Point;\ntypedef pair<Point,Point> Vector;\ntypedef pair<double,int> P;\n\ndouble dot(Point a,Point b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(Point a,Point b) {\n  return imag(conj(a)*b);\n}\n\nint ccw(Point a,Point b,Point c){\n  b-=a;\n  c-=a;\n  if(cross(b,c)<0)return -1;//counterclockwise\n  if(cross(b,c)>0)return 1;//clockwise\n  if(dot(b,c)<0)return -2;\n  if(norm(b)<norm(c))return 2;\n  return 0;\n}\n\nbool isIntersect(Vector a,Vector b){\n  return (ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second)<=0)&&(ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second)<=0);  \n}\n\nPoint crosspoint(Vector l,Vector m){\n  double A=cross(l.second-l.first,m.second-m.first);\n  double B=cross(l.second-l.first,l.second-m.first);\n  if(fabs(A)<0&&fabs(B)<0) return m.first;\n  else if(fabs(A)>=0) return m.first+B/A*(m.second-m.first);\n}\n\nint main(){\n  int d,n,o[N],l[N],ans,cnt;\n  Vector b,s[N];\n  vector<P> v;\n  cin>>d;\n  while(d--){\n    cin>>b.first.real()>>b.first.imag()>>b.second.real()>>b.second.imag();\n    cin>>n;\n    for(int i=0;i<n;i++){\n      cin>>s[i].first.real()>>s[i].first.imag()>>s[i].second.real()>>s[i].second.imag()>>o[i]>>l[i];\n      if(isIntersect(b,s[i])){\n\tPoint x=crosspoint(b,s[i]);\n\tdouble A=x.real()-b.first.real(),B=x.imag()-b.first.imag();\n\tv.push_back(P(A*A+B*B,i));\n      }\n    }\n    sort(v.begin(),v.end());\n    ans=INF;\n    for(int i=0;i<2;i++){\n      int x=i;\n      cnt=0;\n      for(int j=0;j<v.size();j++){\n\tint idx=v[j].second;\n\tif(o[idx]==1){\n\t  if(x==0&&l[idx]==1) x=1,cnt++;\n\t  if(x==1&&l[idx]==0) x=0,cnt++;\n\t}else{\n\t  if(x==0&&l[idx]==0) x=1,cnt++;\n\t  if(x==1&&l[idx]==1) x=0,cnt++;\n\t}\n      }\n      ans=min(ans,cnt);\n    }\n    cout<<ans<<endl;\n    v.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\n\nconst D EPS = 1e-8;\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return !sig(norm(a - b));}\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n}\n\nP vec(L a) {return a.b - a.a;}\n\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  if (near(a, c) || near(b, c)) return ON;\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\nbool iSSs(L a, L b) {\n  int cwa = ccw(a.a, a.b, b.a) | ccw(a.a, a.b, b.b);\n  int cwb = ccw(b.a, b.b, a.a) | ccw(b.a, b.b, a.b);\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\n\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\nvoid solve() {\n  D x1, y1, x2, y2;\n  cin >> x1 >> y1 >> x2 >> y2;\n  L a = {P(x1, y1), P(x2, y2)};\n  int n;\n  cin >> n;\n  vector<pair<P, bool> > vp;\n  rep (i, n) {\n    int o, l;\n    cin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n    L b = {P(x1, y1), P(x2, y2)};\n    if (iSSs(a, b)) vp.push_back(make_pair(pLL(a, b), o == l));\n  }\n  sort(vp.begin(), vp.end());\n  int res = 0;\n  rep (i, vp.size() - 1) if (vp[i].second != vp[i + 1].second) ++res;\n  cout << res << endl;\n}\n\nint main() {\n  int t;\n  cin >> t;\n  rep (i, t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nusing ll=long long int;\nusing pii=pair<int,int>;\nusing pil=pair<int,ll>;\nusing pli=pair<ll,int>;\nusing pll=pair<ll,ll>;\nusing psi=pair<string,int>;\nusing pis=pair<int,string>;\nusing psl=pair<string,ll>;\nusing pls=pair<ll,string>;\nusing pss=pair<string,string>;\n\n\n\ntemplate<typename T> using vc=vector<T>;\ntemplate<typename T> using vvc=vector<vector<T>>;\ntemplate<typename T> using vvvc=vector<vector<vector<T>>>;\ntemplate<typename T> using vvvvc=vector<vvvc<T>>;\ntemplate<typename T> using vvvvvc=vector<vvvvc<T>>;\n\ntemplate<class T,class U>inline constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>inline constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\ninline void bin101(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); \n    cout<<fixed<<setprecision(20);\n}\n\n//デバッグ\ntemplate<typename T>\ninline void vout(const vector<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<v[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            cout<<i<<\" \"<<j<<\" \"<<v[i][j]<<'\\n';\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n//デバッグ\ntemplate<typename T>\ninline void vout(const vvvc<T> &v){\n    cout<<\"\\nstart\\n\";\n    const int sz=v.size();\n    for(int i=0;i<sz;i++){\n        int ssz=v[i].size();\n        for(int j=0;j<ssz;j++){\n            int sssz=v[i][j].size();\n            for(int k=0;k<sssz;k++){\n                cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<v[i][j][k]<<'\\n';\n            }\n        }\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//pair cout\ntemplate<typename T, typename U>\ninline ostream &operator<<(ostream &os,const pair<T,U> &p) {\n  os<<p.first<<\" \"<<p.second;\n  return os;\n}\n\n//pair cin\ntemplate<typename T, typename U>\ninline istream &operator>>(istream &is,pair<T,U> &p) {\n  is>>p.first>>p.second;\n  return is;\n}\n\n//ソート\ntemplate<typename T>\ninline void vsort(vector<T> &v){\n    sort(v.begin(),v.end());\n}\n\n//逆順ソート\ntemplate<typename T>\ninline void rvsort(vector<T> &v){\n  sort(v.rbegin(),v.rend());\n}\n\n//要素数a 初期値x\ntemplate<typename T>\ninline vector<T> vmake(int a,T x){\n  return vector<T>(a,x);\n}\n\n//data[a][b] 初期値x\ntemplate<typename T>\ninline vector<vector<T>> vmake(int a,int b,T x){\n  return vector<vector<T>>(a, vector<T>(b,x));\n}\n\n//data[a][b][c] 初期値x\ntemplate<typename T>\ninline vector<vector<vector<T>>> vmake(int a,int b,int c,T x){\n  return vector<vector<vector<T>>> (a, vector<vector<T>>(b, vector<T>(c, x)));\n}\n\n//data[a][b][c][d]　初期値x\ntemplate<typename T>\ninline vector<vector<vector<vector<T>>>> vmake(int a,int b,int c,int d,T x){\n  return vector<vector<vector<vector<T>>>> (a,vvvc<T>(b,vvc<T>(c,vc<T>(d,x))));\n}\n\n//data[a][b][c][d][e] 初期値x\ntemplate<typename T>\ninline vvvvvc<T> vmake(int a,int b,int c,int d,int e,T x){\n  return vvvvvc<T> (a,vvvvc<T>(b,vvvc<T>(c,vvc<T>(d,vc<T>(e,x)))));\n}\n\n//1ビットの数を返す\ninline int popcount(int x){\n  return __builtin_popcount(x);\n}\n//1ビットの数を返す\ninline int popcount(ll x){\n  return __builtin_popcountll(x);\n}\n\n//queのfront() pop()\ntemplate<typename T>\ninline T pop(queue<T> &que){\n    T x=que.front();\n    que.pop();\n    return x;\n}\n\n//priority_que top() pop()\ntemplate<typename T>\ninline T pop(priority_queue<T> &que){\n  T x=que.top();\n  que.pop();\n  return x;\n}\n\n//stack top() pop()\ntemplate<typename T>\ninline T pop(stack<T> &st){\n  T x=st.top();\n  st.pop();\n  return x;\n}\n\n#define intsz(x) ( (int)x.size()  )\n\n/*\n満たすものの個数を返す\nmode:0 x未満\nmode:1 x以下の数\nmode:2 x以上の数\nmode:3 x超\nmode:4 x\n*/\ntemplate<typename T>\ninline int count_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return lower_bound(v.begin(),v.end(),x)-v.begin();\n        case 1:\n            return upper_bound(v.begin(),v.end(),x)-v.begin();\n        case 2:\n            return v.end()-lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return v.end()-upper_bound(v.begin(),v.end(),x);\n        case 4:\n            return upper_bound(v.begin(),v.end(),x)-lower_bound(v.begin(),v.end(),x);\n    }\n}\n\n/*\nmode:0 xより小さい数で最大の数\nmode:1 x以下の数で最大の数\nmode:2 x以上の数で最小の数\nmode:3 xより大きい数で最小の数\n*/\ntemplate<typename T>\ninline T value_bound(vector<T> &v,T x,int mode){\n    switch(mode){\n        case 0:\n            return *(--lower_bound(v.begin(),v.end(),x));\n        case 1:\n            return *(--upper_bound(v.begin(),v.end(),x));\n        case 2:\n            return *lower_bound(v.begin(),v.end(),x);\n        case 3:\n            return *upper_bound(v.begin(),v.end(),x);\n    }\n}\n\n\n\nconstexpr int MAX=1<<30;\n//constexpr ll INF=1LL<<62;\nconstexpr ll MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nusing DD=double;\n\n\n#define EPS 1e-10\n#define eq(a,b) (abs( (a) - (b) )<EPS)\nconst DD PI=acosl(-1.0);\nconstexpr DD INF=1LL<<62;\n\n//点\nusing P=complex<DD>;\n//ベクトル\nusing V=P;\n//線分\nstruct Segment{\n    P a,b;\n    Segment()=default;\n    Segment(P a,P b) :a(a),b(b){}\n    Segment(DD ax,DD ay,DD bx,DD by):a(ax,ay),b(bx,by){}\n    Segment(DD r,P a) :a(a),b(a+polar(1.0,r)){} \n\n};\n//直線\nusing Line=Segment;\n//円\nstruct Circle{\n    P p;\n    DD r;\n    Circle()=default;\n    Circle(P p,DD r):p(p),r(r){}\n};\nusing Polygon=vector<P>;\n\n//++++++++++++++++基本計算++++++++++++++//\ninline DD torad(const DD &deg){return deg*PI/180;}\ninline DD todeg(const DD &rad){return rad*180/PI;}\n//内積\ninline DD dot(const V &a,const V &b){\n    return real(a*conj(b));\n}\n//外積\ninline DD cross(const V &a,const V &b){\n    return imag(conj(a)*b);\n}\n//ベクトルvを反時計回りにr度回転\ninline V rotate(const V &v,const DD r){\n    return v*V(cos(r),sin(r));\n}\ninline bool xy(const P &a,const P &b){\n    if(real(a)+EPS<=real(b)) return true;\n    if(eq(real(a),real(b)) && imag(a)+EPS<imag(b)) return true;\n    return false;\n}\ninline bool yx(const P &a,const P &b){\n    if(imag(a)+EPS<imag(b)) return true;\n    if(eq(imag(a),imag(b)) && real(a)+EPS<real(b)) return true;\n    return false;\n}\n\n//++++++++++++++++平行や直交+++++++++++++++//\ninline bool isOrthogonal(const V &a,const V &b){\n    return eq(dot(a,b),0.0);\n}\ninline bool isOrthogonal(const Segment &a,const Segment &b){\n    return eq(dot(a.a-a.b,b.a-b.b),0);\n}\ninline bool isParallel(const V &a,const V &b){\n    return eq(cross(a,b),0.0);\n}\ninline bool isParallel(const Segment &a,const Segment &b){\n    return eq(cross(a.a-a.b,b.a-b.b),0);\n}\n//線分a-bに対してcがどの位置にあるか\n//ccwの簡略版 反時計回り:1 時計回り:-1 直線上:0\ninline int ccw(const P &a,const P &b,const P &c){\n    DD cr=cross(b-a,c-a);\n    if(cr>EPS) return 1;\n    if(cr<-EPS) return -1;\n    return 0;\n}\n\n//線分a-bに対してcがどの位置にあるか\n//反時計回り:1　時計回り:-1 直線上(a,b,c:-2 a,c,b:0 c,a,b:2) \ninline int ccwH(P a,P b,P c){\n    b-=a;c-=a;\n    if(cross(b,c)>EPS) return 1;\n    if(cross(b,c)<-EPS) return -1;\n    if(dot(b,c)<-EPS) return 2;\n    if(norm(b)<norm(c)) return -2;\n    return 0;\n}\n\n\n//+++++++++++++++射影+++++++++++++++++++++//\ninline P project(const P &p,const Segment &s){\n    V base=s.b-s.a;\n    DD r=dot(p-s.a,base)/norm(base);\n    return s.a+base*r;\n}\ninline P reflect(const P &p,const Segment &s){\n    return p+(project(p,s)-p)*2.0;\n}\n/*++++++++++点との距離++++++++++++++++++*/\n//点と直線の距離\ninline DD dis(const P &p,const Line &l){return abs(cross(l.b-l.a,p-l.a))/abs(l.b-l.a);}\n//点と線分の距離\ninline DD disPS(const P &p,const Segment &s){\n    if( dot(s.b-s.a,p-s.a)<0.0 ) return abs(p-s.a);\n    if( dot(s.a-s.b,p-s.b)<0.0 ) return abs(p-s.b);\n    return dis(p,s); //点と直線の距離\n}\n\n\n//+++++++++++++++線分と直線+++++++++++++++++//\n\n//線分a-b,c-dは交差するか?\ninline bool intersect(const P &a,const P &b,const P &c,const P &d){\n    return(ccwH(a,b,c)*ccwH(a,b,d)<=0 && ccwH(c,d,a)*ccwH(c,d,b)<=0);\n}\n//線分s,tは交差するか？\ninline bool intersect(const Segment &s,const Segment &t){\n    return intersect(s.a,s.b,t.a,t.b);\n}\n//線分と線分の交点\n//これをやる前にintersectで判定\ninline P crossPoint(const Segment &s,const Segment &t){\n    V base=t.b-t.a;\n    DD d1=abs(cross(base,s.a-t.a));\n    DD d2=abs(cross(base,s.b-t.a));\n    DD r=d1/(d1+d2);\n    return s.a+(s.b-s.a)*r;\n}\n//線分と線分の距離\ninline DD dis(const Segment &s,const Segment t){\n    if(intersect(s,t)) return 0.0;\n    return min(min(disPS(t.a,s),disPS(t.b,s)),min(disPS(s.a,t),disPS(s.b,t)) );\n}\n\n\nvoid solve(){\n    DD sx,sy,tx,ty;\n    cin>>sx>>sy>>tx>>ty;\n    Segment seg(sx,sy,tx,ty);\n    int n;\n    cin>>n;\n    vector<Segment> s;\n    vector<int> O;\n    for(int i=0;i<n;i++){\n        int o,l;\n        cin>>sx>>sy>>tx>>ty>>o>>l;\n        s.emplace_back(sx,sy,tx,ty);\n        O.push_back(l^o);\n    }\n    vector<pair<P,int>> v;\n    for(int i=0;i<n;i++){\n        if(intersect(seg,s[i])){\n            v.emplace_back(crossPoint(seg,s[i]),O[i]);\n        }\n    }\n    sort(v.begin(),v.end(),[](pair<P,int> a,pair<P,int> b){\n        return xy(a.first,b.first);\n    });\n\n    int now=-1;\n    int cnt=-1;\n    for(int i=0;i<v.size();i++){\n        if(v[i].second!=now){\n            now=v[i].second;\n            cnt++;\n        }\n    }\n    if(cnt==-1) cnt=0;\n    cout<<cnt<<endl;\n\n}\n\nsigned main(){\n    bin101();\n    \n\n    int t;\n    cin>>t;\n    while(t--) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<double, double> P;\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\nconst double EPS = 1e-10;\n\n/*使い方\nPoint P(-2, 1), Q;\nQ = {2, -1};\ncout<< P.real() << \" \" << P.imag() <<endl;\nQ = P + Point(5, -2);\nQ += Point(cos(a), sin(a));\ncout << abs(P) <<endl;\t//opの長さ\ncout << norm(P) <<endl;\t//abs((P)^2)\n*/\n\n// 内積 |a||b|cosθ\ndouble dot(Point a, Point b){\n\t// return a.real() * b.real() + a.imag() * b.imag();\n\treturn (conj(a) * b).real();\n}\n// 外積、符号付面積の２倍　|a||b|sinθ\ndouble cross(Point a, Point b){\n\t// return a.real() * b.imag() - a.imag() * b.real();\n\treturn (conj(a) * b).imag();\n}\n// 点の位置関係　2点a,bから見た点cの位置関係\nint ccw(Point a, Point b, Point c){\n    // COUNTER_CLOCKWISE\n    if(cross(b - a, c - a) > EPS) return 1;\n    // CLOCKWISE\n    if(cross(b - a, c - a) < -EPS) return -1;\n    // ONLINE_BACK\n    if(dot(b - a, c - a) < -EPS) return 2;\n    // ONLINE_FRONT\n    if(abs(b - a) + EPS < abs(c - a)) return -2;\n    // ON_SEGMENT\n    return 0;\n}\n// 線分の交差判定\nbool is_cross(Line a, Line b){\n    if(ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0 && ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0){\n        return true;\n    }\n    return false;\n}\n// 直線の交点\nPoint cross_point(Line a, Line b){\n    double d1 = cross(b.second - b.first, b.first - a.first);\n    double d2 = cross(b.second - b.first, a.second - a.first);\n    return a.first + (a.second - a.first) * d1 / d2;\n}\n\nint main(){\n    int ts;\n    cin >> ts;\n    rep(it, 0, ts){\n        double xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        Point a = {xa, ya};\n        Point b = {xb, yb};\n        Line h = {a, b};\n        int n;\n        cin >> n;\n        vector<Line> ls; \n        vector<int> owner(n), l(n);\n        rep(i, 0, n){\n            double xs, ys, xt, yt;\n            cin >> xs >> ys >> xt >> yt >> owner[i] >> l[i];\n            Point s = {xs, ys};\n            Point t = {xt, yt};\n            ls.push_back({s, t});\n        }\n        vector<pair<P, int> > crossPnt;\n        rep(i, 0, n){\n            if(is_cross(h, ls[i])){\n                Point tmp = cross_point(h, ls[i]);\n                int tmpl = l[i];\n                if(owner[i] == 0) tmpl = (tmpl + 1) % 2;\n                crossPnt.push_back({P(tmp.real(), tmp.imag()), tmpl});\n            }\n        }\n        int ans = 0;\n        sort(crossPnt.begin(), crossPnt.end());\n        rep(i, 1, crossPnt.size()){\n            if(crossPnt[i - 1].second != crossPnt[i].second){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble crosspointSS(L l1, L l2) {\n    double d1 = abs(cross(l2.v, l1.a - l2.a));\n    double d2 = abs(cross(l2.v, l1.b - l2.a));\n    double t = d1 / (d1 + d2);\n    // return l1.a + t * l1.v;\n    return t;\n}\n\nL readL() {\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return L(xa, ya, xb, yb);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int T;\n    cin >> T;\n    rep(_, T) {\n        L blue = readL();\n        int n;\n        cin >> n;\n        vector<L> lines(n);\n        V layer(n);\n        rep(i, n) {\n            lines[i] = readL();\n            int o, l;\n            cin >> o >> l;\n            layer[i] = l;\n            if (o == 0) layer[i] ^= 1;\n        }\n\n        vector<pair<double, int>> v; // {t, id} \n        rep(i, n) {\n            if (!intersectSS(blue, lines[i])) continue;\n            v.emplace_back(make_pair(crosspointSS(blue, lines[i]), i));\n        }\n        sort(all(v));\n\n        int ans = 0;\n        rep(i, (int)v.size() - 1) {\n            if (layer[v[i].second] != layer[v[i + 1].second]) {\n                ans++;\n            }\n        }\n\n        cout << ans << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> point;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define pb push_back\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin(); itr!=(c).end(); itr++)\n\ndouble cross(point a, point b){\n  return ( a.real()*b.imag() - a.imag()*b.real() );\n}\nbool is_intersection_ls(point a1, point a2, point b1, point b2){\n  return ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS &&\n           cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS );\n}\npoint intersection_ls(point a1, point a2, point b1, point b2){\n  point b = b2 - b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1+d2);\n  return a1 + (a2-a1)*t;\n}\n\nclass sen{\npublic:\n  point p;\n  int o,l;\n  sen(point _p, int _o, int _l){\n    p = _p;\n    o = _o;\n    l = _l;\n  }\n  bool operator<(const sen& a)const{\n    if( p.real() == a.p.real() ) return p.imag() < a.p.imag();\n    return p.real() < a.p.real();\n  }\n};\n\npoint s,e;\npoint ds[110], de[110];\nint O[110], L[110];\nint n;\n\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    cin >> s.real() >> s.imag() >> e.real() >> e.imag();\n    cin>>n;\n    rep(i,n){\n      cin >> ds[i].real() >> ds[i].imag();\n      cin >> de[i].real() >> de[i].imag();\n      cin >> O[i] >> L[i];\n    }\n#if DEB\n    rep(i,n){\n      cout << ds[i] << \" : \" << de[i] << \" ,\" << O[i] << \" \" << L[i] << endl;\n    }\n#endif\n\n    vector<sen> v;\n    rep(i,n){\n      if( is_intersection_ls(s,e,ds[i],de[i]) ){\n        point p = intersection_ls(s,e,ds[i],de[i]);\n        v.push_back(sen(p,O[i],L[i]));\n      }\n    }\n\n    // o ª1Èç©Ð\n    // l ª\n    int nl;\n    int cnt = 0;\n    sort(all(v));\n    rep(i,v.size()){\n#if DEB\n      cout << v[i].p << \" \" << v[i].o << \" \" << v[i].l << endl;\n#endif\n\n      if( i==0 ){\n        if( v[i].o==1 ){\n          nl = v[i].l;\n        }else{\n          nl = (v[i].l == 1 ? 0 : 1);\n        }\n      }else{\n        if( v[i].o==1 ){\n          if( v[i].l!=nl ){\n            nl = v[i].l;\n            cnt++;\n          }\n        }else{\n          if( v[i].l==nl ){\n            nl = (v[i].l==1 ? 0 : 1);\n            cnt++;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b)))\n\t\treturn 0;\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {};\n\tP(double x_, double y_) : x(x_), y(y_) { }\n\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\n\tP operator * (double d) {\n\t\treturn P(x * d, y * d);\n\t}\n\n\tP operator / (double d) {\n\t\treturn P(x / d, y / d);\n\t}\n\n\tbool operator < (const P &p) const {\n\t\treturn x < p.x + EPS;\n\t}\n\n\t// ??????\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\n\t// ??????\n\tdouble det(P p) {\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n// ??´?????¨??´????????????\nP intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\n\n// ???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n\treturn (p1 - q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n}\n\n\n//////////////////////\n\nstruct Line {\n\tP s, t;\n\tbool owner;\n\tbool layer;\n\n\tbool operator < (const Line &l) const {\n\t\treturn s < l.s;\n\t}\n};\n\nvoid solve() {\n\t// input\n\tP a, b;\n\tcin >> a.x >> a.y >> b.x >> b.y;\n\t\n\tint n;\n\tcin >> n;\n\n\tvector<Line> lines(n);\n\tfor (auto &l : lines) {\n\t\tcin >> l.s.x >> l.s.y >> l.t.x >> l.t.y >> l.owner >> l.layer;\n\t}\n\n\t// ??????????±???????\n\tvector<pair<P, Line>> ps;\n\tfor (auto &l : lines) {\n\t\tP p = intersection(a, b, l.s, l.t);\n\t\tif (on_seg(a, b, p) && on_seg(l.s, l.t, p)) {\n\t\t\tps.EB(p, l);\n\t\t}\n\t}\n\n\tsort(ALL(ps));\n\n\t// ??´???????????????\n\tint cnt = 0;\n\n\tbool current = ps[0].snd.layer ? false : true;\n\tif (ps[0].snd.owner) {\n\t\tcurrent = !current;\n\t}\n\n\tfor (int i = 1; i < (int)ps.size(); i++) {\n\t\tbool expect = ps[i].snd.layer ? false : true;\n\t\tif (ps[i].snd.owner) {\n\t\t\texpect = !expect;\n\t\t}\n\n\t\tif (expect != current) {\n\t\t\tcurrent = expect;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\t// ??????\n\tcout << cnt << endl;\n}\n\nint main(void) {\n\tint T;\n\tcin >> T;\n\n\tfor (int i = 0; i < T; i++) {\n//\t\tcout << \"case: \" << i << endl;\n\t\tsolve();\n//\t\tcout << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X real()\n#define Y imag()\n#define INF 1e9\nusing namespace std;\ntypedef complex <double> point;\n\ndouble cross(point a,point b){\n  return a.X*b.Y-a.Y*b.X;\n}\n\npoint CrossPoint(point a,point b,point c,point d){\n  point base=b-a;\n  double d1=abs(cross(base,(c-a)));\n  double d2=abs(cross(base,(d-a)));\n  double t=d1/(d1+d2);\n  point e=(d-c)*t+c;\n  if(a.X<=e.X&&e.X<=b.X&&t<=abs(d-c)) return e;\n  return  point(INF,INF);\n}\n\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int sx,sy,gx,gy;\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n\n    int o[101],l[101];\n    point D[101];\n    for(int i=0,a,b,c,d;i<n;i++){\n      cin>>a>>b>>c>>d>>o[i]>>l[i];\n      D[i]=CrossPoint(point(sx,sy),point(gx,gy),point(a,b),point(c,d));\n    }\n\n\n    for(int i=0;i<n-1;i++)\n      for(int j=n-1;j>i;j--)\n\tif(abs(D[j]-point(sx,sy))<abs(D[j-1]-point(sx,sy))){\n\t  swap(D[j],D[j-1]);\n\t  swap(o[j],o[j-1]);\n\t  swap(l[j],l[j-1]);\n\t}\n    \n    int ans=0;\n    bool pos=l[0];\n    if(!o[0]) pos =!pos;\n    for(int i=1;i<n;i++) {\n      if(D[i].X==INF)continue;\n      if(o[i]&&pos!=l[i])pos=!pos,ans++;\n      if(!o[i]&&pos==l[i])pos=!pos,ans++;\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//XY座標\n#define X real()\n#define Y imag()\n\n// 許容する誤差ε\nconst double EPS = (1e-10);\n// 円周率\nconst double PI = 3.14159265358979;\n\nconst int INF = 1e+8;\n\n// 点の表現\ntypedef complex<double> P;\n\n// complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// 2乗する\ndouble sq(double x){\n\treturn x * x;\n}\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n// 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b){\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a){\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a){\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a){\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2 直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n\treturn equal( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点 c が直線 a, b 上にあるかどうか \nint is_point_on_line(P a, P b, P c) {\n\treturn equal( cross(b-a, c-a), 0.0 );\n}\n\n// 下記は (1) より (2) のほうが簡潔で良い.\n\n// 点 c が線分 a, b 上にあるかどうか (1)\nint is_point_on_line_1(P a, P b, P c) {\n  return equal( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点 c が線分 a, b 上にあるかないか(2)\nint is_point_on_line_2(P a, P b, P c) {\n\t// |a-c| + |c-b| <= |a-b| なら線分上\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点 a, bを通る直線と点 c との距離\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点 a, b を端点とする線分と点 c との距離\ndouble distance_ls_p(P a, P b, P c) {\n\tif( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\t\n\treturn a1 + (a2-a1) * t;\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n\treturn !equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n\tP a = a2 - a1; P b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nstruct Rail{\n\tP p1, p2;\n\tint o, l;\n\tRail(P p1_, P p2_, int o_, int l_){\n\t\tp1 = p1_; p2 = p2_; o = o_; l = l_;\n\t}\n};\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i_=0 ; i_ < N ; i_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa,ya), B(xb,yb);\n\t\t\n\t\tcin >> n;\n\t\tvector<Rail> vr;\n\t\tfor(int j_=0 ; j_ < n ; j_++ ){\n\t\t\tint sx,sy,tx,ty,o,l;\n\t\t\tcin >> sx >> sy >> tx >> ty >> o >> l;\n\t\t\tvr.push_back( Rail( P(sx,sy) , P(tx,ty) , o , l ) );\n\t\t}\n\t\t\n\t\t// 交点計算\n\t\tvector< pair< double , pair<P,pair<int,int> > > > vp;\n\t\tfor(int i=0 ; i < vr.size() ; i++ ){\n\t\t\t// 交差するかどうか\n\t\t\tif( is_intersected_ls( A , B , vr[i].p1 , vr[i].p2 ) ){\n\t\t\t\t// 交点\n\t\t\t\tP p = intersection_l( A , B , vr[i].p1 , vr[i].p2 );\n\t\t\t\t// 交点との距離\n\t\t\t\tdouble d = abs(A-p);\n\t\t\t\t// o=0 => 他社, o=1 => 自社, l=0 => 地下, l=1 => 高架\n\t\t\t\tpair<int,int> p2( vr[i].o , vr[i].l );\n\t\t\t\t\n\t\t\t\tpair<P,pair<int,int> > p3( p , p2 );\n\t\t\t\tpair< double , pair<P,pair<int,int> > > p4(d,p3) ;\n\t\t\t\tvp.push_back( p4 );\n\t\t\t}\n\t\t}\n\t\tsort( vp.begin() , vp.end() );\n\t\t\n\t\tint ans = INF;\n\t\t// d=0 のとき地下, d=1 のとき高架\n\t\t{\n\t\t\tint d=0;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\tint o = vp[i].second.second.first;\n\t\t\t\tint l = vp[i].second.second.second;\n\t\t\t\t\n\t\t\t\t// o = 0 のとき他社\n\t\t\t\tif( o == 0 ){\n\t\t\t\t\tif( l == d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( l != d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min( ans , cnt );\n\t\t}\n\t\t{\n\t\t\tint d=1;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\tint o = vp[i].second.second.first;\n\t\t\t\tint l = vp[i].second.second.second;\n\t\t\t\t\n\t\t\t\t// o = 0 のとき他社\n\t\t\t\tif( o == 0 ){\n\t\t\t\t\tif( l == d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( l != d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min( ans , cnt );\n\t\t}\n\t\tif( ans == INF ) ans = 0;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\t\t     \n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define MOD 1000000007\n\ntypedef complex<double> P;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\nconst double EPS = 1e-9;\nconst double INF = 1e12;\n// ??????(dot product) : ab = |a||b|cos theta\ndouble dot(P a, P b)\n{\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????(cross product) : axb = |a||b|sin theta\ndouble cross(P a, P b)\n{\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´?????????  dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2)\n{\n  return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n// 2??´?????????????????? cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2)\n{\n  return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// ???c?????´???a,b????????????????????????\nint is_point_on_line(P a, P b, P c)\n{\n  return EQ(cross(b-a, c-a), 0.0);\n}\n\n// ???c?????????a,b????????????????????????\nint is_point_on_line_seg(P a, P b, P c)\n{\n  // |a - c| + |c - b| <= |a - b|???????????????\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c)\n{\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c)\n{\n  if(dot(b-a, c-a) < EPS) return abs(c-a);\n  if(dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2, double c)\n{\n  return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < c) &&\n    (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2)\n{\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2 - a1) * t;\n}\n\ntypedef pair< P, pi > S;\nP a(0, 0), b(0, 0);\n\nbool comp(const S& ls, const S& rs)\n{\n  P l = ls.first, r = rs.first;\n  return abs(l-a) < abs(r-a); \n}\n\nint in[8];\n\nint solve()\n{\n  rep(i, 4) cin >> in[i];\n  a = P(in[0], in[1]), b = P(in[2], in[3]);\n  int N;\n  cin >> N;\n  vector<S>V;\n  rep(i, N){\n    rep(j,6) cin >> in[j];\n    P c(in[0], in[1]), d(in[2], in[3]);\n    if(is_intersected_ls(a, b, c, d, 0)){\n      P p = intersection_ls(a, b, c, d);\n      V.push_back(make_pair(p, pi(in[4], in[5])));\n    }\n  }\n\n  if(V.size() == 0) return 0;\n  //  cout << V.size() << endl;\n  sort(V.begin(), V.end(), comp);\n  int res = 0;\n  int pos = (~(V[0].second.first^V[0].second.second))&1;\n  for(int i=1;i<V.size();i++){\n    int o = V[i].second.first&1, l = V[i].second.second&1;\n    res += (pos!=((~(o^l))&1));\n    pos = (~(o^l))&1;\n  }\n  return res;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  rep(i, T)\n    cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(ll& x, ll& y, ll& xo, ll& yo, ll& dx, ll& dy) {\n\tll _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<ll> xs(N), ys(N), xt(N), yt(N), o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (double)(yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef pair<P,bool> Q;\nD eps=1e-11;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool comp(const Q& xx,const Q& yy){\n\tP x=xx.fs,y=yy.fs;\n\tif(abs(x.real()-y.real())<eps){\n\t\treturn x.imag()<y.imag();\n\t}else{\n\t\treturn x.real()<y.real();\n\t}\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\tvector<Q> vc;\n\t\tD ax,ay,bx,by;\n\t\tint N;\n\t\tcin>>ax>>ay>>bx>>by>>N;\n\t\tL l=L(P(ax,ay),P(bx,by));\n\t\trep(i,N){\n\t\t\tD a,b,c,d;\n\t\t\tbool e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tL s=L(P(a,b),P(c,d));\n\t\t\tif(iSS(l,s)){\n\t\t\t\tvc.pb(Q(intLL(l,s),e^f));\n\t\t\t}\n\t\t}\n\t\tif(vc.size()==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(vc),comp);\n\t\tint ans=0;\n\t\tbool now=vc[0].sc;\n\t\trep(i,vc.size()){\n\t\t\tif(now^vc[i].sc){\n\t\t\t\tans++;\n\t\t\t\tnow=vc[i].sc;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> point;\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define pb push_back\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin(); itr!=(c).end(); itr++)\n\ndouble cross(point a, point b){\n  return ( a.real()*b.imag() - a.imag()*b.real() );\n}\nbool is_intersection_ls(point a1, point a2, point b1, point b2){\n  return ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS &&\n           cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS );\n}\npoint intersection_ls(point a1, point a2, point b1, point b2){\n  point b = b2 - b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1+d2);\n  return a1 + (a2-a1)*t;\n}\n\nclass sen{\npublic:\n  point p;\n  int o,l;\n  sen(point _p, int _o, int _l){\n    p = _p;\n    o = _o;\n    l = _l;\n  }\n  bool operator<(const sen& a)const{\n    if( abs(p.real()-a.p.real())>EPS ) return p.imag() < a.p.imag();\n    return p.real() < a.p.real();\n  }\n};\n\npoint s,e;\npoint ds[110], de[110];\nint O[110], L[110];\nint n;\n\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    cin >> s.real() >> s.imag() >> e.real() >> e.imag();\n    cin>>n;\n    rep(i,n){\n      cin >> ds[i].real() >> ds[i].imag();\n      cin >> de[i].real() >> de[i].imag();\n      cin >> O[i] >> L[i];\n    }\n#if DEB\n    rep(i,n){\n      cout << ds[i] << \" : \" << de[i] << \" ,\" << O[i] << \" \" << L[i] << endl;\n    }\n#endif\n\n    vector<sen> v;\n    rep(i,n){\n      if( is_intersection_ls(s,e,ds[i],de[i]) ){\n        point p = intersection_ls(s,e,ds[i],de[i]);\n        v.push_back(sen(p,O[i],L[i]));\n      }\n    }\n\n    // o ª1Èç©Ð\n    // l ª\n    int nl;\n    int cnt = 0;\n    sort(all(v));\n\n    if( v.size()>0 ){\n      nl = (v[0].o==1 ? v[0].l : !v[0].l);\n    }\n\n    \n    REP(i,1,v.size()){\n      if( (v[i].o==1 && v[i].l!=nl) ||\n          (v[i].o==0 && v[i].l==nl) ){\n        nl = !nl;\n        cnt++;\n      }\n      /*\n      if( v[i].o==1 ){\n        if( v[i].l!=nl ){\n          nl = v[i].l;\n          cnt++;\n        }\n      }else{\n        if( v[i].l==nl ){\n          nl = (v[i].l==1 ? 0 : 1);\n          cnt++;\n        }\n      }\n      */\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n// ??\\??? ????????¨???\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\n\n\n// ??????????????????\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\ninline B cmp(const pair<P,int> &a,const pair<P,int> &b){ return cmp_x(a.first,b.first);}\n\n// ?????¬??????\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n// ccw\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //???a??¨???b???????????????????????????\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????? ??´???\n\t// ?????¨??´???????????¢\n\t// ?????¨??????????????¢\n\t// ??´?????¨??´???????????¢\n\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// ??????\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// ?????¨??´?????¨????????¢??£???????????????\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n\nint main(void){\n\tint t;\n\tcin >> t;\n\trep(loop,t){\n\t\tL orignal;\n\t\tcin >> orignal.first.X >> orignal.first.Y >> orignal.second.X >> orignal.second.Y;\n\n\t\tvector<pair<P,int> > res;\n\n\t\tint n;\n\t\tcin >> n;\n\t\trep(i,n){\n\t\t\tL in;\n\t\t\tcin >> in.first.X >> in.first.Y >> in.second.X >> in.second.Y;\n\t\t\tint o,l;\n\t\t\tcin >> o >> l;\n\t\t\tif(iSS(orignal,in)){\n\t\t\t\tP cross=pLL(orignal,in);\n\t\t\t\tres.pb(mp(cross,o^l));\n\t\t\t}\n\t\t}\n\n\t\tsort(res.begin(),res.end(),cmp);\n\t\tint ans=0;\n\t\tint rn=res.size();\n\t\trep(i,rn-1){\n\t\t\tif(res[i].second!=res[i+1].second)\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define  range(i, l, r) for (int i = (int)(l); i < (int)(r); (i) += 1)\n#define rrange(i, l, r) for (int i = (int)(r) - 1; i >= (int)(l); (i) -= 1)\n\n#define  whole(f, x, ...) ([&](decltype((x)) container) { return (f)(  begin(container),  end(container), ## __VA_ARGS__); })(x)\n#define rwhole(f, x, ...) ([&](decltype((x)) container) { return (f)( rbegin(container), rend(container), ## __VA_ARGS__); })(x)\n\n#define debug(x) cerr << \"(\" << __LINE__ << \")\" << #x << \": \" << (x) << endl\n\nusing i32 = int;\nusing u32 = unsigned int;\nusing i64 = long long;\nusing u64 = unsigned long long;\n\n// constexpr i32 mod   = 998244353;\nconstexpr i32 mod   = 1e9 + 7;\nconstexpr i32 inf   = 1001001001;\nconstexpr i64 infll = 1001001001001001001ll;\n\nconstexpr int dx[] = {0, -1, 1, 0, -1, 1, -1, 1};\nconstexpr int dy[] = {-1, 0, 0, 1, -1, -1, 1, 1};\n\nstruct IoSetup { IoSetup(int x = 15){ cin.tie(0); ios::sync_with_stdio(0); cout << fixed << setprecision(x); cerr << fixed << setprecision(x); } } iosetup;\n\ntemplate <typename T = i64> T input() { T x; cin >> x; return x; }\n\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> &v) { range(i, 0, v.size()) { os << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return os; }\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in : v) is >> in; return is; }\n\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\ntemplate <typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\n\ntemplate <typename T> vector<T> make_vector(size_t a, T b) { return vector<T>(a, b); }\ntemplate <typename... Ts> auto make_vector(size_t a, Ts... ts) { return vector<decltype(make_vector(ts...))>(a, make_vector(ts...)); }\n\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n// }}}\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  return os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nusing Points = vector< Point >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\" c-a-b\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\" a-b-c\n  return 0;                         // \"ON_SEGMENT\" a-c-b\n}\n\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\nvoid solver() {\n    Point a, b;\n    cin >> a >> b;\n\n    Segment hi(a, b);\n\n    int n;\n    cin >> n;\n\n    vector< pair< Point, bool > > pts;\n\n    range(i, 0, n) {\n        Point s, t;\n        cin >> s >> t;\n        bool o, l;\n        cin >> o >> l;\n        if (o == 1) l = !l;\n\n        Segment sg(s, t);\n        if (intersect(hi, sg)) {\n            pts.emplace_back(crosspoint(hi, sg), l);\n        }\n    }\n\n    whole(sort, pts);\n    if (pts.size() == 0) {\n        cout << 0 << endl;\n        return;\n    }\n\n    bool f = pts[0].second;\n    int ans = 0;\n    range(i, 1, pts.size()) {\n        if (pts[i].second == f) continue;\n        ans++;\n        f = !f;\n    }\n\n    cout << ans << endl;\n}\n\nsigned main(int argc, char *argv[]) {\n    int T = input();\n    range(i, 0, T) solver();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef long long int Int;\ntypedef complex<double> P;\ntypedef pair<int, P> PP;\ntypedef pair<Int, bool> PIB;\nconst double EPS = 1e-12;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nInt distance2(P &a, P &b){ return (a.real() - b.real()) * (a.real() - b.real()) * (a.imag() - b.imag()) * (a.imag() - b.imag()); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return PP(1, m[0]); // same line\n  if (abs(A) < EPS) PP(0, P(0, 0));\n  return PP(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nP inputP(){\n  int x, y; cin >>x >>y;\n  return P(x, y);\n}\n\nint main() {\n  int T; cin >>T;\n  while(T--){\n    P a = inputP(), b = inputP();\n    int N; cin >>N;\n    vector<PIB> ps;\n    REP(i, N){\n      P s = inputP(), t = inputP();\n      int o, l; cin >>o >>l;\n      L l1 = L(a, b), l2 = L(s, t);\n      if(!intersectSS(l1, l2)) continue;\n      PP r = crosspointLL(l1, l2);\n      if(r.first == 0) continue;\n      bool f = 0;\n      if((o == 1 && l == 1) || (o == 0 && l == 0)) f = 1;\n      ps.push_back(PIB(distance2(a, r.second), f));\n    }\n    SORT(ps);\n    int ans = 0;\n    FOR(i, 1, ps.size()) if(ps[i].second != ps[i - 1].second) ++ans;\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n \n#define EPS (1e-10)\n \nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  double abs(){return sqrt(norm());}\n  double norm(){return x*x+y*y;}\n};\ntypedef Point Vector;\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point s=Point(),Point t=Point()):p1(s),p2(t){}\n};\ndouble norm(Vector a){return a.x*a.x + a.y*a.y;}\ndouble abs(Vector a){return sqrt(norm(a));}\ndouble getDistance(Vector a,Vector b){return abs(a-b);}\ndouble dot (Vector a,Vector b){return a.x*b.x + a.y*b.y;}\ndouble cross(Vector a,Vector b){return a.x*b.y - a.y*b.x;}\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n  if ( cross(a, b) < -EPS ) return CLOCKWISE;\n  if ( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  Point p1=s1.p1, p2=s1.p2, p3=s2.p1, p4=s2.p2;\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n      ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n \nPoint getCrossPoint(Segment s1,Segment s2){\n \n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n \n \nint n,o,l;\nSegment seg,input;\n \nvector<PP> t;\n \nint main(){\n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    t.clear();\n    cin>>seg.p1.x>>seg.p1.y>>seg.p2.x>>seg.p2.y;\n    cin>>n;\n    for(int i=0;i<n;i++){\n \n      cin>>input.p1.x>>input.p1.y>>input.p2.x>>input.p2.y;\n      cin>>o>>l;\n      //cout<<i<<' '<<o<<' '<<l<<endl;\n       \n      if(isIntersect(seg,input)==false)continue;\n      Point a = getCrossPoint(seg,input);\n      double b = getDistance(a,seg.p1);\n       \n      //cout<<input.p1.x<<' '<<input.p1.y<<endl;\n      //cout<<input.p2.x<<' '<<input.p2.y<<endl;\n       \n      t.push_back(PP(b,P(o,l)));\n    }\n \n    if(t.size()<=1){cout<<\"0\"<<endl;continue;}\n \n    sort(t.begin(),t.end());\n    int ans=0,now;\n    if(t[0].second.first==1)now=t[0].second.second;\n    else now=1-t[0].second.second;\n    for(int i=1;i<(int)t.size();i++){\n      if(t[i].second.first==1){\n    if(now!=t[i].second.second)ans++;\n    now=t[i].second.second;\n      }else if(t[i].second.first==0){\n    if(now==t[i].second.second)ans++;\n    now=1-t[i].second.second;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-9\n#define INF 1e10\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tif(z == 0)return(point(INF,INF));\n\tlong double r = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\tif((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(tmpx,(o+l)%2));\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nstruct Info{\n\tdouble x,y;\n};\n\nstruct Data{\n\tData(double arg_distance,bool arg_is_under_ground){\n\t\tdistance = arg_distance;\n\t\tis_under_ground = arg_is_under_ground;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn distance > arg.distance;\n\t};\n\n\tdouble distance;\n\tbool is_under_ground;\n};\n\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\nInfo calc(double x1,double y1,double x2,double y2,double x3,double y3,double x4,double y4){\n\tInfo ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\ndouble calc_dist(double x1,double y1,double x2,double y2){\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nvoid func(){\n\n\tdouble start_x,start_y,goal_x,goal_y;\n\tscanf(\"%lf %lf %lf %lf\",&start_x,&start_y,&goal_x,&goal_y);\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tpriority_queue<Data> Q;\n\n\tdouble x1,y1,x2,y2;\n\tint Owner,L;\n\n\tInfo ret;\n\tdouble tmp_dist;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%lf %lf %lf %lf %d %d\",&x1,&y1,&x2,&y2,&Owner,&L);\n\n\t\tif(func(x1,y1,x2,y2,start_x,start_y)*func(x1,y1,x2,y2,goal_x,goal_y) <= 0 &&\n\t\t\t\tfunc(start_x,start_y,goal_x,goal_y,x1,y1) * func(start_x,start_y,goal_x,goal_y,x2,y2) <= 0){\n\t\t\tret = calc(start_x,start_y,goal_x,goal_y,x1,y1,x2,y2);\n\t\t\ttmp_dist = calc_dist(start_x,start_y,ret.x,ret.y);\n\t\t\tif(Owner == 1){\n\t\t\t\tif(L == 1){\n\t\t\t\t\tQ.push(Data(tmp_dist,false));\n\t\t\t\t}else{\n\t\t\t\t\tQ.push(Data(tmp_dist,true));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(L == 1){\n\t\t\t\t\tQ.push(Data(tmp_dist,true));\n\t\t\t\t}else{\n\t\t\t\t\tQ.push(Data(tmp_dist,false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(Q.empty()){\n\t\tprintf(\"0\\n\");\n\t\treturn;\n\t}\n\n\tbool under_ground = Q.top().is_under_ground;\n\tQ.pop();\n\n\tint ans = 0;\n\n\twhile(!Q.empty()){\n\t\tif(under_ground == Q.top().is_under_ground){\n\t\t\t//Do nothing\n\t\t}else{\n\t\t\tans++;\n\t\t\tunder_ground = Q.top().is_under_ground;\n\t\t}\n\t\tQ.pop();\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\tint num;\n\tscanf(\"%d\",&num);\n\n\tfor(int i = 0; i < num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < - EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < - EPS );\n}\n\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    int N;\n    cin >> N;\n\n    vec sx(N), sy(N), tx(N), ty(N), o(N), l(N);\n    for (int i = 0; i < N; i++) {\n        cin >> sx[i] >> sy[i] >> tx[i] >> ty[i] >> o[i] >> l[i];\n    }\n\n    P ap(ax, ay);\n    P bp(bx, by);\n    vec crossed_idx;\n    for (int i = 0; i < N; i++) {\n        P sp(sx[i], sy[i]);\n        P tp(tx[i], ty[i]);\n        if (is_intersected_ls(ap, bp, sp, tp)) crossed_idx.push_back(i);\n    }\n\n    vector<pair<double,int> > points;\n    for (int i = 0, len = crossed_idx.size(); i < len; i++) {\n        int c = crossed_idx[i];\n        P sp(sx[c], sy[c]);\n        P tp(tx[c], ty[c]);\n        P point = intersection_l(ap, bp, sp, tp);\n        double dist = abs(point - ap);\n        points.push_back(pair<double,int>(dist, c));\n    }\n\n    sort(points.begin(), points.end());\n\n    int fst;\n    bool is_over;\n    if (points.size()) {\n        fst = points[0].second;\n        if (o[fst]) {\n            if (l[fst]) is_over = true;\n            else is_over = false;\n        } else {\n            if (!l[fst]) is_over = true;\n            else is_over = false;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0, len = points.size(); i < len; i++) {\n        int now = points[i].second;\n        if (o[now]) {\n            if (l[now] != is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        } else {\n            if (l[now] == is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    int N; cin>> N;\n    while (N--) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing namespace std;\n\nconst double eps = 1e-10;\ntypedef complex<double> point;\nstruct circle { point c; double r; };\nstruct line { point s, t; };\nstruct segment { point s, t; };\nstruct ray { point s, t; };\ndouble   dot(point p, point q) { return real(p * conj(q)); }\ndouble cross(point p, point q) { return imag(conj(p) * q); }\nint ccw(point a, point b, point c) { double z = cross(b - a, c - a); return z > eps ? 1 : z < - eps ? -1 : 0; }\nbool does_intersect(point a, line b) {\n    return ccw(0, a - b.s, b.t - b.s) == 0;\n}\nbool does_intersect(line a, point b) {\n    return does_intersect(b, a);\n}\nbool is_parallel(line a, line b) {\n    return ccw(0, a.t - a.s, b.t - b.s) == 0;\n}\nbool is_overwraped(line a, line b) {\n    return does_intersect(a.s, b)\n        and does_intersect(a.t, b);\n}\nbool does_intersect(line a, line b) {\n    return not is_parallel(a, b)\n        and not is_overwraped(a, b);\n}\npoint intersection(line a, line b) {\n    assert (does_intersect(a, b));\n    double p = cross(a.t - a.s, b.t - b.s);\n    double q = cross(a.t - a.s, a.t - b.s);\n    return (q / p) * (b.t - b.s) + b.s;\n}\nbool does_intersect(point a, segment b) {\n    return abs(cross(b.t - b.s, a - b.s)) < eps\n        and dot(b.t - b.s, a - b.s) > - eps\n        and dot(b.s - b.t, a - b.t) > - eps;\n}\nbool does_intersect(segment a, point b) {\n    return does_intersect(b, a);\n}\ntemplate <typename T, typename U>\nbool does_intersect_linelikes(T const & a, U const & b) {\n    if (not does_intersect(to_line(a), to_line(b))) return false;\n    point c = intersection(to_line(a), to_line(b));\n    return does_intersect(a, c)\n        and does_intersect(b, c);\n}\nline to_line(segment a) {\n    return { a.s, a.t };\n}\nbool does_intersect(segment a, segment b) {\n    return does_intersect_linelikes(a, b);\n}\npoint intersection(segment a, segment b) {\n    assert (does_intersect(a, b));\n    return intersection(to_line(a), to_line(b));\n}\n\nint main() {\n    int testcase; scanf(\"%d\", &testcase);\n    while (testcase --) {\n        segment a; { double ax, ay, bx, by; scanf(\"%lf%lf%lf%lf\", &ax, &ay, &bx, &by); a = { point(ax, ay), point(bx, by) }; }\n        int n; scanf(\"%d\", &n);\n        vector<pair<double, bool> > events;\n        repeat (i, n) {\n            segment b; { double ax, ay, bx, by; scanf(\"%lf%lf%lf%lf\", &ax, &ay, &bx, &by); b = { point(ax, ay), point(bx, by) }; }\n            int o, t; scanf(\"%d%d\", &o, &t);\n            if (does_intersect(a, b)) {\n                point p = intersection(to_line(a), to_line(b));\n                events.emplace_back(abs(p - a.s), o ^ t);\n            }\n        }\n        whole(sort, events);\n        int last = -1;\n        int result = 0;\n        for (auto event : events) {\n            bool type = event.second;\n            if (last != -1 and last != int(type)) {\n                result += 1;\n            }\n            last = int(type);\n        }\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n};\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x1,double y1,double x2,double y2):pos(x1,y1),dir(x2,y2){}\n};\ntypedef Line Segment;\nostream& operator<<(ostream& os,const Point& p){ return os<<'('<<p.x<<','<<p.y<<')'; }\nostream& operator<<(ostream& os,const Line& l){ return os<<'('<<l.pos<<','<<l.dir<<')'; }\n\nPoint operator+(Point a,Point b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\nPoint operator-(Point a,Point b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\nPoint operator*(double c,Point p){\n\treturn Point(c*p.x,c*p.y);\n}\n\nint Signum(double x){\n\treturn abs(x)<EPS?0:x<0?-1:1;\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nint CCW(Point a,Point b,Point c){\n\tPoint d1=b-a,d2=c-a;\n\tif(int sign=Signum(Cross(d1,d2)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(d1,d2)<-EPS)\n\t\treturn -2; // c-a-b\n\tif(Abs2(d1)<Abs2(d2)-EPS)\n\t\treturn 2; // a-b-c\n\treturn 0; // a-c-b\n}\nbool IsInterSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\nPoint InterLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS)\n\t\treturn a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tLine nl;\n\t\tvector<Line> ml,mu,yl,yu;\n\t\t{\n\t\t\tdouble x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;\n\t\t\tnl=Line(x1,y1,x2-x1,y2-y1);\n\t\t\tint n; cin>>n;\n\t\t\tint owner,layer; // owner=0/1:他社/自社, layer=0/1:地下/高架\n\t\t\trep(i,n){\n\t\t\t\tcin>>x1>>y1>>x2>>y2>>owner>>layer;\n\t\t\t\tif(owner) (layer?mu:ml).emplace_back(x1,y1,x2-x1,y2-y1);\n\t\t\t\telse      (layer?yu:yl).emplace_back(x1,y1,x2-x1,y2-y1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<pair<Point,int>> p; // (座標,地下と高架のどちらにあるべきか)\n\t\tfor(Line l:ml) if(IsInterSS(nl,l)) p.emplace_back(InterLL(nl,l),0);\n\t\tfor(Line l:mu) if(IsInterSS(nl,l)) p.emplace_back(InterLL(nl,l),1);\n\t\tfor(Line l:yl) if(IsInterSS(nl,l)) p.emplace_back(InterLL(nl,l),1);\n\t\tfor(Line l:yu) if(IsInterSS(nl,l)) p.emplace_back(InterLL(nl,l),0);\n\t\t\n\t\tsort(all(p),[nl](pair<Point,int> a,pair<Point,int> b){\n\t\t\treturn Abs2(a.first-nl.pos)<Abs2(b.first-nl.pos);\n\t\t});\n\t\t\n\t\tint res=0;\n\t\trep(i,p.size()-1) res+=p[i].second^p[i+1].second;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-9;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n    return equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n\t\t         ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( is_intersection(s) ) return 0.0;\n\t\treturn min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i_=0 ; i_ < N ; i_++ ){\n        int xa, ya, xb, yb, n;\n        cin >> xa >> ya >> xb >> yb;\n        // 駅A と 駅B を結ぶ 線分AB\n        P A(xa,ya), B(xb,yb);\n        Segment AB( A, B );\n         \n        // 点Aと交点の距離と交点で地下と高架のどちらを通るべきか保持\n        // v[i] := (点Aからの距離, 0 or 1 )\n        vector< pair<double,int> > v;\n         \n        cin >> n;\n        for(int j_=0 ; j_ < n ; j_++ ){\n            int sx,sy,tx,ty,o,l;\n            cin >> sx >> sy >> tx >> ty >> o >> l;\n            P S(sx,sy), T(tx,ty);\n            Segment ST( S, T );\n             \n            // 交差するかどうか\n            if( AB.is_intersection(ST) ){\n            \tP p;\n            \tAB.intersection(ST, p);\n                // 平行かどうか\n                /*if( is_parallel( A , B , S , T ) ){\n                    continue;\n                }*/\n                // 距離\n                double d = dist( A , p );\n                v.push_back( pair<double,int>(d, o^l) );\n            }\n        }\n         \n        sort( v.begin() , v.end() );\n        int ans=0;\n        for(int i=1 ; i < v.size() ; i++ ){\n            if( v[i-1].second != v[i].second ){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\n\nstruct Point {\n\tdouble x, y;\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\n\nstruct Segment {\n\tPoint a, b;\n\texplicit Segment(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Segment invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Segment(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Segment &s) const {\n\t\treturn (a == s.a) ? (b < s.b) : (a < s.a);\n\t}\n};\n\nbool tolerant_eq(const Segment &a, const Segment &b){\n\tif(tolerant_eq(a.a, b.a) && tolerant_eq(a.b, b.b)){ return true; }\n\tif(tolerant_eq(a.a, b.b) && tolerant_eq(a.b, b.a)){ return true; }\n\treturn false;\n}\n\n\nbool intersect(const Segment &a, const Segment &b){\n\tif(ccw(a.a, a.b, b.a) * ccw(a.a, a.b, b.b) > 0){ return false; }\n\tif(ccw(b.a, b.b, a.a) * ccw(b.a, b.b, a.b) > 0){ return false; }\n\treturn true;\n}\n\n\nPoint crosspoint(const Segment &a, const Segment &b){\n\tif(!intersect(a, b)){ return Point::invalid(); }\n\tdouble x = cross(a.b - a.a, b.b - b.a);\n\tdouble y = cross(a.b - a.a, a.b - b.a);\n\tif(abs(x) < EPS && abs(y) < EPS){\n\t\treturn b.a;\n\t}else if(abs(x) < EPS){\n\t\treturn Point::invalid();\n\t}else{\n\t\treturn b.a + y / x * (b.b - b.a);\n\t}\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\twhile(T--){\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tSegment s(Point(xa, ya), Point(xb, yb));\n\t\tint N;\n\t\tcin >> N;\n\t\tvector< pair<Point, int> > v;\n\t\twhile(N--){\n\t\t\tdouble x1, y1, x2, y2;\n\t\t\tint o, l;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tSegment t(Point(x1, y1), Point(x2, y2));\n\t\t\tPoint cp = crosspoint(s, t);\n\t\t\tif(cp.is_valid()){\n\t\t\t\tif(xa == xb){ cp.x = xa; }\n\t\t\t\tv.push_back(make_pair(cp, o ^ l));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint answer = 0;\n\t\tfor(int i = 1; i < v.size(); ++i){\n\t\t\tif(v[i - 1].second != v[i].second){ ++answer; }\n\t\t}\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<double, int> pdi;\n\nstruct point { int x, y; };\nstruct line { point p, q; };\n\nint T, N, O[110], L[110];\nline A, S[110];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double ux = l.q.x - l.p.x;\n  double uy = l.q.y - l.p.y;\n  double vx = p.x - l.p.x;\n  double vy = p.y - l.p.y;\n  double cross = abs(ux * vy - uy * vx);\n  double ul = sqrt(ux * ux + uy * uy);\n  return cross / ul;\n}\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> A.p.x >> A.p.y >> A.q.x >> A.q.y;\n    cin >> N;\n    REP(i, 0, N) cin >> S[i].p.x >> S[i].p.y >> S[i].q.x >> S[i].q.y >> O[i] >> L[i];\n\n    vector<pdi> E;\n    REP(i, 0, N) if(intersect(A, S[i])) {\n      double da = distance(S[i], A.p);\n      double db = distance(S[i], A.q);\n      double d = da / (da + db);\n      E.push_back(pdi(d, i));\n    }\n\n    sort(E.begin(), E.end());\n\n    vector<int> g;\n    REP(i, 0, E.size()) {\n      int k = E[i].second;\n      g.push_back(O[k] == 1 ? L[k] : (L[k] ^ 1));\n    }\n\n    int ans = 0;\n    REP(i, 0, g.size() - 1) if(g[i] != g[i + 1]) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-9\n#define INF 1e10\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tlong double r = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\tif((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(tmpx,(o+l)%2));\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < - EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < - EPS );\n}\n\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    int N;\n    cin >> N;\n\n    vec sx(N), sy(N), tx(N), ty(N), o(N), l(N);\n    for (int i = 0; i < N; i++) {\n        cin >> sx[i] >> sy[i] >> tx[i] >> ty[i] >> o[i] >> l[i];\n    }\n\n    P ap(ax, ay);\n    P bp(bx, by);\n    vec crossed_idx;\n    for (int i = 0; i < N; i++) {\n        P sp(sx[i], sy[i]);\n        P tp(tx[i], ty[i]);\n        if (is_intersected_ls(ap, bp, sp, tp)) crossed_idx.push_back(i);\n    }\n\n    vector<pair<int,int> > points;\n    for (int i = 0, len = crossed_idx.size(); i < len; i++) {\n        int c = crossed_idx[i];\n        P sp(sx[c], sy[c]);\n        P tp(tx[c], ty[c]);\n        P point = intersection_l(ap, bp, sp, tp);\n        double dist = abs(point - ap);\n        points.push_back(pair<int,int>(dist, c));\n    }\n\n    sort(points.begin(), points.end());\n\n    int fst;\n    bool is_over;\n    if (points.size()) {\n        fst = points[0].second;\n        if (o[fst]) {\n            if (l[fst]) is_over = true;\n            else is_over = false;\n        } else {\n            if (!l[fst]) is_over = true;\n            else is_over = false;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0, len = points.size(); i < len; i++) {\n        int now = points[i].second;\n        if (o[now]) {\n            if (l[now] != is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        } else {\n            if (l[now] == is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    int N; cin>> N;\n    while (N--) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> C;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs(a-b) < EPS)\n#define EQV(a,b) (EQ(a.real(),b.real()) && EQ(a.imag(),b.imag()))\n\nC s[100], e[100];\n\ndouble cross(C a, C b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool is_crossed(C a1, C a2, C b1, C b2) {\n  return cross(a2-a1, b2-a1) * cross(a2-a1, b1-a1) < EPS &&\n         cross(b2-b1, a2-b1) * cross(b2-b1, a1-b1) < EPS;\n}\n\nC intersection(C a1, C a2, C b1, C b2) {\n  C b = b2 - b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1 + (a2-a1) * t;\n}\n\nvoid solve() {\n  int xa, ya, xb, yb, n;\n  cin>>xa>>ya>>xb>>yb>>n;\n  C a(xa, ya), b(xb, yb);\n  C ab = b - a;\n  \n  vector<pair<double,pair<int,int> > > iss;\n  rep(i,n) {\n    int xs, ys, xt, yt, o, l;\n    cin>>xs>>ys>>xt>>yt>>o>>l;\n    C s(xs, ys), t(xt, yt);\n    C st = t - s;\n    \n    if(!is_crossed(a, b, s, t)) continue;\n    C is = intersection(a, b, s, t);\n    iss.push_back(make_pair(is.real(), make_pair(o,l)));\n  }\n  \n  sort(iss.begin(), iss.end());\n  int res = 1000;\n  rep(z,2) {\n    int mode = z, tres = 0;\n    rep(i,iss.size()) {\n      int to = iss[i].second.first, tl = iss[i].second.second;\n      bool flag = false;\n      if ((to == 1 && tl != mode) || (to == 0 && tl == mode)) {\n        tres++; mode++;\n        if (mode >= 2) mode = 0;\n      }\n    }\n    res = min(tres, res);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  int n;\n  cin>>n;\n  rep(i,n)\n    solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <ccomplex>\n#include <cstring>\n#include <algorithm>\n#include <tuple>\n\n#define For(i,a,b) for(int i = a;i < b; i++)\n#define rep(i,n) For(i,0,n)\n#define clr(n)\tmemset(n,0,sizeof n)\n\nusing namespace std;\n\ntypedef long double d;\ntypedef complex<d> P;\ntypedef pair<P, P> L;\nconst d EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\nd dot(P a, P b){\n\treturn (conj(a) * b).X;\n}\n\nd cross(P a, P b){\n\treturn (conj(a) * b).Y;\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS)return 1;\n\tif (cross(b, c) < -EPS)return -1;\n\tif (dot(b, c) < -EPS)return 2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\n\nbool isecLL(P a1, P a2, P b1,P b2){\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nbool isecLL(L l1, L l2){\n\treturn isecLL(l1.first, l1.second, l2.first, l2.second);\n}\n\nconst int INF = 1e9;\n\nP crosspointLL(P a1, P a2, P b1, P b2){\n\td d1 = cross(b2 - b1, b1 - a1);\n\td d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\tif (EQ(d2, 0))return P(INF,INF);\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\nP crosspointLL(L l1, L l2){\n\treturn crosspointLL(l1.first, l1.second, l2.first, l2.second);\n}\n\ntypedef tuple<P, int, int> T;\n\nint main(){\n\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\t\tint xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tL sl(P(xa, ya), P(xb, yb));\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<L> vL;\n\t\tvector<int> vo;\n\t\tvector<int> vl;\n\n\t\trep(i, n){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\n\t\t\tvL.push_back(L(P(xs, ys), P(xt, yt)));\n\t\t\tvo.push_back(o);\n\t\t\tvl.push_back(l);\n\t\t}\n\n\t\tvector<T> vp;\n\n\t\trep(i, n){\n\t\t\tif (isecLL(sl, vL[i])){\n\t\t\t\tvp.push_back(T(crosspointLL(sl, vL[i]),vo[i],vl[i]));\n\t\t\t}\n\t\t}\n\n\t\tbool f = false;\n\t\twhile (!f){\n\t\t\tf = true;\n\t\t\trep(i,vp.size()-1){\n\t\t\t\tauto p1 = get<0>(vp[i]);\n\t\t\t\tauto p2 = get<0>(vp[i+1]);\n\t\t\t\tint dist1 = (p1.X - sl.first.X)*(p1.X - sl.first.X) + (p1.Y - sl.first.Y)*(p1.Y - sl.first.Y);\n\t\t\t\tint dist2 = (p2.X - sl.first.X)*(p2.X - sl.first.X) + (p2.Y - sl.first.Y)*(p2.Y - sl.first.Y);\n\n\t\t\t\tif (dist1 > dist2){\n\t\t\t\t\tswap(vp[i], vp[i + 1]);\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, 2){\n\t\t\tint val = 0;\n\t\t\tint sf = i;\n\t\t\trep(j, vp.size()){\n\t\t\t\tif (get<1>(vp[j]) == 1){\n\t\t\t\t\tif (get<2>(vp[j]) != sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (get<2>(vp[j]) == sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(val, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint crs(double x1, double y1, double x2, double y2) {\n    double z = x1*y2-y1*x2;\n    return (0 < z ? 1 : (z < 0 ? -1 : 0));\n}\n\nbool intersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (0 <= crs(x2-x1, y2-y1, x3-x1, y3-y1) * crs(x2-x1, y2-y1, x4-x1, y4-y1)) return false;\n    if (0 <= crs(x4-x3, y4-y3, x1-x3, y1-y3) * crs(x4-x3, y4-y3, x2-x3, y2-y3)) return false;\n    return true;\n}\n\npair<double,double> intersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (x3 == x4) {\n        swap(x1, x3); swap(y1, y3); swap(x2, x4); swap(y2, y4);\n    }\n    double x, y, a, b, c, d;\n    if (x1 == x2) {\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = x1;\n        y = c*x+d;\n    } else {\n        a = (y2-y1)/(x2-x1);\n        b = y1-a*x1;\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = (d-b)/(a-c);\n        y = a*x+b;\n    }\n    return make_pair(x,y);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        double xa, ya, xb, yb;\n        int n;\n        cin >> xa >> ya >> xb >> yb >> n;\n        bool vertical = fabs(xa-xb) < fabs(ya-yb);\n\n        double xs, ys, xt, yt;\n        int o, l;\n        vector<pair<double,int> > levels;\n        for (int i=0; i<n; ++i) {\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            if (intersect(xa, ya, xb, yb, xs, ys, xt, yt)) {\n                if (vertical) {\n                    double y = intersection(xa, ya, xb, yb, xs, ys, xt, yt).second;\n                    levels.push_back(make_pair(y, o==1 ? l : 1-l));\n                } else {\n                    double x = intersection(xa, ya, xb, yb, xs, ys, xt, yt).first;\n                    levels.push_back(make_pair(x, o==1 ? l : 1-l));\n                }\n            }\n        }\n\n        sort(levels.begin(), levels.end());\n        int res = 0;\n        for (int i=1; i<(int)levels.size(); ++i) {\n            if (levels[i].second != levels[i-1].second) {\n                res ++;\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> pint;\ntypedef const pint &refpint;\ntypedef pair<double,bool> pdb;\n\n\n#define INF 1e99\n\nint cross(refpint a, refpint b){\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble intersect(refpint a, refpint dif1, refpint f, refpint dif2){\n\tint A_ = cross(dif1, -dif2);\n\tif( A_ == 0.0 ) return INF;\n\tdouble A = A_;\n\t\n\tpint ddif = f - a;\n\tdouble t = cross(ddif, -dif2) / A;\n\tdouble s = cross(dif1, ddif) / A;\n\t\n\tif(t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0){\n\t\treturn t;\n\t}\n\treturn INF;\n}\n\n\nint main(){\n\tint dataset;\n\tfor(scanf(\"%d\", &dataset); dataset--; ){\n\t\tpint a, b, from, to, dif1, dif2;\n\t\tint n, o, l, x1, x2, y1, y2;\n\t\tvector<pdb> ts;\n\n\t\tscanf(\"%d%d%d%d%d\", &x1, &y1, &x2, &y2, &n);\n\t\ta = pint(x1, y1);\n\t\tb = pint(x2, y2);\n\t\tdif1 = b - a;\n\n\t\tts.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &o, &l);\n\t\t\tfrom = pint(x1, y1);\n\t\t\tto = pint(x2, y2);\n\t\t\tdif2 = to - from;\n\n\t\t\tdouble t = intersect(a, dif1, from, dif2);\n\t\t\tif( t != INF ){\n\t\t\t\tts.push_back( pdb(t, o != l) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ts.begin(), ts.end());\n\t\tint res = 0;\n\t\tfor(int i = 1; i < ts.size(); ++i){\n\t\t\tif(ts[i-1].second != ts[i].second){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\n// const ll LLINF = (1LL<<60);\n// const int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int T;\n  cin >> T;\n  REP(_, T) {\n    double ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    L line(P(ax,ay), P(bx,by));\n\n    // 交点の位置とその交点が高架か地下か\n    vector<pair<P, int>> po;\n    int n;\n    cin >> n;\n    REP(i, n) {\n      double xs, ys, xt, yt;\n      int o, l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L l2(P(xs,ys), P(xt,yt));\n      if(intersectSS(line, l2)) {\n        P c = crosspoint(line, l2);\n        po.PB({c, o^l});\n      }\n    }\n    sort(ALL(po));\n    // cout << po << endl;\n    int ret = 0;\n    FOR(i, 1, po.size()) {\n      if(po[i].second != po[i-1].second) ret++;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n#define mp(a, b) make_pair(a, b)\nconst double eps = 1e-9;\n\ndouble cross(const P &a, const P &b){\n    return imag(conj(a) * b);\n}\n\ndouble dot(const P &a, const P &b){\n    return real(conj(a) * b);\n}\n\nint ccw(P a, P b, P c){\n    b -= a; c -= a;\n    if(cross(b, c) > eps)return 1;\n    if(cross(b, c) < -eps)return -1;\n    if(dot(b, c) < 0)return 2;\n    if(norm(b) < norm(c))return -2;\n    return 0;\n}\n\nstruct L:vector<P>{\n    L(const P &a, const P &b){\n        push_back(a); push_back(b);\n    }\n};\n\nbool interSS(const L &s, const L &t){\n    return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n           ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP xptLL(const L &l, const L &m){\n    double d = cross(l[1] - l[0], m[1] - m[0]);\n    if(abs(d) < eps)return l[0];\n    return m[0] + (m[1] - m[0]) * cross(l[1] - l[0], l[1] - m[0]) / d;\n}\n\nint solve(vector<pair<int, int> > info, int l){\n    int res = 0;\n    for(auto x: info){\n        if(x.second & 2){\n            res += l != (x.second & 1);\n            l = x.second & 1;\n        }else{\n            res += l == (x.second & 1);\n            l = x.second ^ 1;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int T;\n    cin >> T;\n    while(T--){\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        L linear(P(xa, ya), P(xb, yb));\n        int n;\n        cin >> n;\n        vector<L> line;\n        vector<pair<int, int> > info;\n        rep(i, n){\n            int xs, ys, xt, yt, o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            if(!interSS(linear, L(P(xs, ys), P(xt, yt))))continue;\n            line.push_back(L(P(xs, ys), P(xt, yt)));\n            info.push_back(mp((int)line.size() - 1, o << 1 | l << 0));\n        }\n        sort(all(info), [&](const pair<int, int> &a, const pair<int, int> &b){\n                return abs(linear[0] - xptLL(linear, line[a.first]))\n                           < abs(linear[0] - xptLL(linear, line[b.first]));});\n        cout << min(solve(info, 0), solve(info, 1)) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, bool> PIB;\nconst double EPS = 1e-12;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b) { return imag(conj(a)*b); }\ndouble dot(const P& a, const P& b) { return real(conj(a)*b); }\nint distance2(P &a, P &b){ return (a.real() - b.real()) * (a.real() - b.real()) * (a.imag() - b.imag()) * (a.imag() - b.imag()); }\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nPP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return PP(1, m[0]); // same line\n  if (abs(A) < EPS) PP(0, P(0, 0));\n  return PP(1, m[0] + B / A * (m[1] - m[0]));\n}\n\nP inputP(){\n  int x, y; cin >>x >>y;\n  return P(x, y);\n}\n\nint main() {\n  int T; cin >>T;\n  while(T--){\n    P a = inputP(), b = inputP();\n    int N; cin >>N;\n    vector<PIB> ps;\n    REP(i, N){\n      P s = inputP(), t = inputP();\n      int o, l; cin >>o >>l;\n      L l1 = L(a, b), l2 = L(s, t);\n      if(!intersectSS(l1, l2)) continue;\n      PP r = crosspointLL(l1, l2);\n      if(r.first == 0) continue;\n      bool f = 0;\n      if((o == 1 && l == 1) || (o == 0 && l == 0)) f = 1;\n      ps.push_back(PIB(distance2(a, r.second), f));\n    }\n    SORT(ps);\n    int ans = 0;\n    FOR(i, 1, ps.size()) if(ps[i].second != ps[i - 1].second) ++ans;\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2003\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nconst double EPS=1e-10;\n\ntypedef pair<double,int> P;\n\n#define EQ(a,b) fabs(a-b)<EPS\n\nstruct Vector{\n\tdouble x,y;\n\tVector(double x=0.0,double y=0.0):x(x),y(y){}\n\n\tVector operator + (const Vector &a)const{\n\t\treturn Vector(x+a.x,y+a.y);\n\t}\n\tVector operator - (const Vector &a)const{\n\t\treturn Vector(x-a.x,y-a.y);\n\t}\n\tVector operator * (double k)const{\n\t\treturn Vector(x*k,y*k);\n\t}\n\tVector operator / (double k)const{\n\t\treturn Vector(x/k,y/k);\n\t}\n\tbool operator == (const Vector &a)const{\n\t\treturn EQ(x,a.x) && EQ(y,a.y);\n\t}\n\tdouble norm(){\n\t\treturn x*x+y*y;\n\t}\n\tdouble abs(){\n\t\treturn sqrt(norm());\n\t}\n\tbool operator < (const Vector &a)const{\n\t\treturn x!=a.x ? x<a.x : y<a.y;\n\t}\n};\n\ndouble dot(Vector a,Vector b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\ntypedef Vector Point;\n\nstruct Segment{\n\tPoint p1,p2;\n};\n\nconst int MAX_N=100;\n\nSegment x;\nint n;\nSegment s[MAX_N];\nint o[MAX_N],l[MAX_N];\n\nstruct Rail{\n\tPoint p;\n\tint l;\n\tRail(Point p=Point(),int l=0):p(p),l(l){};\n};\n\nvector<Rail> r;\nvector<P> d;\n\nconst int COUNTER_CLOCKWISE=1,CLOCKWISE=-1,ONLINE_BACK=2,ONLINE_FRONT=-2,ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n\tVector a=p1-p0,b=p2-p0;\n\tif (cross(a,b)>EPS){\n\t\treturn COUNTER_CLOCKWISE;\n\t}\n\tif (cross(a,b)<-EPS){\n\t\treturn CLOCKWISE;\n\t}\n\tif (dot(a,b)<-EPS){\n\t\treturn ONLINE_BACK;\n\t}\n\tif (a.norm()<b.norm()){\n\t\treturn ONLINE_FRONT;\n\t}\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n\treturn intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n\tVector base=s2.p2-s2.p1;\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n}\n\nint main(){\n\tint T;\n\tscanf(\"%d\",&T);\n\tREP(t,T){\n\t\tint xa,ya,xb,yb;\n\t\tscanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n\t\tx.p1=Point(xa,ya);\n\t\tx.p2=Point(xb,yb);\n\t\tscanf(\"%d\",&n);\n\t\tREP(i,n){\n\t\t\tscanf(\"%d %d %d %d %d %d\",&xa,&ya,&xb,&yb,&o[i],&l[i]);\n\t\t\ts[i].p1=Point(xa,ya);\n\t\t\ts[i].p2=Point(xb,yb);\n\t\t}\n\t\tr.clear();\n\t\tREP(i,n){\n\t\t\tif (intersect(x,s[i])){\n\t\t\t\tr.push_back(Rail(getCrossPoint(x,s[i]), o[i] ? l[i] : 1-l[i]));\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\td.clear();\n\t\tREP(i,r.size()){\n\t\t\td.push_back(P((x.p1-r[i].p).norm(),r[i].l));\n\t\t}\n\t\tsort(d.begin(),d.end());\n\t\tif (d.empty()){\n\t\t\tprintf(\"0\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tint m=d[0].second;\n\t\tREP(i,d.size()){\n\t\t\tif (m!=d[i].second){\n\t\t\t\tm=d[i].second;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //  << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y =\n      (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n/*\n\nTodo:\nLine??¨Segment?????????????????????\n\n*/\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\nclass Road {\npublic:\n\tPoint s;\n\tbool o, l;\n\tRoad(Point s, bool o, bool l) :s(s), o(o), l(l) {}\n\tbool operator<(const Road &that) {\n\t\treturn s < that.s;\n\t}\n};\n\nsigned main() {\n\tint M; cin >> M;\n\trep(h, 0, M) {\n\t\tvector<Road> v;\n\t\tPoint a, b; cin >> a >> b;\n\t\tSegment B(a, b);\n\t\tint n; cin >> n;\n\n\t\trep(i, 0, n) {\n\t\t\tPoint s, t; cin >> s >> t;\n\t\t\tbool o, l; cin >> o >> l;\n\t\t\tSegment S(s, t);\n\t\t\tif (intersect(B, S)) {\n\t\t\t\tPoint res = get_cross_point(B, S);\n\t\t\t\tv.emplace_back(res, o, l);\n\t\t\t}\n\t\t}\n\n\t\tsort(all(v));\n\t\tbool ll = v[0].l;\n\t\tint cnt = 0;\n\t\trep(i, 0, v.size()) {\n\t\t\tRoad r = v[i];\n\t\t\tif (r.o) {\n\t\t\t\tif (ll != r.l) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tll = r.l;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ll == r.l) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tll = !r.l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << --cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nstruct Point{bool high; double x,y;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nPoint* Intersection(Point p1,Point p2,Point p3,Point p4,Point *ret=new Point()){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(d==0 || u<0 || u>1 || v<0 || v>1)return NULL;\n    ret->x = p1.x+u*(p2.x-p1.x);\n    ret->y = p1.y+u*(p2.y-p1.y);\n\n    return ret;\n}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n\n            Point *ret = Intersection(a,b,s,t);\n            if(ret != NULL){\n                ret->high = o==l;\n                cross.push_back(*ret);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n\n        int cnt=0;\n        for(int i=0;i+1<cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<complex>\n#include<assert.h>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int yy;\n  cin >> yy;\n  REP(k,yy){\n    double a,b,c,d;\n    cin >> a >> b >> c >> d;\n    P f,t;\n    f = P(a,b);\n    t = P(c,d);\n    L one = L(f,t);\n    ll n;\n    cin >> n;\n    vector <L> l;\n    vector <ll> o;\n    vector <ll> r;\n    REP(i,n){\n      double s2,s1,t1,t2;\n      ll o1,r1;\n      cin >> s1 >> s2 >> t1 >> t2 >> o1 >> r1;\n      f = P(s1,s2);\n      t = P(t1,t2);\n      L te = L(f,t);\n      o.pb(o1);\n      r.pb(r1);\n      l.pb(te);\n    }\n    ll index = 0;\n    P com = P(-1000,-1000);\n    vector <P> crossp;\n    REP(i,l.size()){\n      P comp;\n      if(intersectSS(one,l[i])){\n\tcomp = crosspoint(one,l[i]);\n\tcrossp.pb(comp);\n      }\n      \n      \n    }\n    sort(crossp.begin(),crossp.end());\n    \n    ll fl = 1;\n    \n    REP(i,crossp.size())\n      //cout << crossp[i].real() << \"  \" << crossp[i].imag() << endl; \n    ll cnt = 0,cnt2 = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    index = 0;\n    fl = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt2++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt2++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    cout << min(cnt,cnt2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            place[i] = (a ? b : b^1);\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n) v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n        sort(all(v));\n        rep(i,n){\n            if(s.empty()) s.emplace_back(place[i]);\n            if(s.back() == place[i]) continue;\n            s.emplace_back(place[i]);\n        }\n        cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<complex>\n\nusing namespace std;\n#define EPS 1e-12\n#define rep(i,n) for(int i=0;i<(int)n;i++)\nconst double PI = 4*atan(1.0);\n\ntypedef complex<double> C;\nstruct L : public vector<C>\n{\n  L(){}\n  L(const C a, const C b){\n    push_back(a); push_back(b);\n  }\n  L(double xa,double ya,double xb,double yb){\n    push_back(C(xa,ya));push_back(C(xb,yb));\n  }\n};\n\nstruct mycp\n{\n  C cp;\n  int ul;\n  int st;\n  bool operator<(const mycp& another) const {\n    return cp.real()<another.cp.real();\n  }\n  mycp(const C cpp,int ull,int stt){\n    cp = cpp; ul = ull; st = stt;\n  }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n\n\nint main(){\n\n  int xa,ya,xb,yb,n;\n  cin >> xa >> ya >> xb >> yb >> n;\n  if (xa>xb){swap(xa,xb);swap(ya,yb);}\n  L newl(xa,ya,xb,yb);\n\n  vector<int> o(n),l(n);\n  vector<L> s,t;\n  vector<int> s_ul,t_ul;\n\n  rep(i,n){\n    int xs,ys,xt,yt,o,l;\n    cin >> xs >> ys >> xt >> yt >> o >> l;\n    L line(xs,ys,xt,yt);\n    if (o==1){\n      s.push_back(line);\n      s_ul.push_back(l);\n    } else {\n      t.push_back(line);\n      t_ul.push_back(l);\n    }\n  }\n\n  vector<mycp> mycps;\n  rep(i,s.size()){\n    if (intersectSS(newl,s[i])){\n      mycp m(crosspointLL(newl,s[i]),s_ul[i],1);\n      mycps.push_back(m);\n    }\n  }\n  rep(i,t.size()){\n    if (intersectSS(newl,t[i])){\n      mycp m(crosspointLL(newl,t[i]),t_ul[i],0);\n      mycps.push_back(m);\n    }\n  }\n  sort(mycps.begin(),mycps.end());\n  int minn = 1e9;\n  rep(i,2){rep(j,2){\n    int cur_ul_end = j;\n    int cur_ul = i;\n    int cnt = 0;\n    for(auto s:mycps){\n      if (s.st==1){\n        if (s.ul!=cur_ul){\n          cnt++;\n          cur_ul = 1-cur_ul;\n        }\n      } else {\n        if (s.ul==cur_ul){\n          cnt++;\n          cur_ul = 1-cur_ul;\n        }\n      }\n    }\n    if (cur_ul!=cur_ul_end)cnt++;\n    if (cnt<minn)minn=cnt;\n  }}\n\n  cout << minn << endl;\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-9\n\nstruct Point{\n  double x,y;\n  \n  Point(){}\n  Point(double x,double y) : x(x),y(y) {}\n  \n  Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n  Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n  Point operator * (const double &k)const{ return Point(x*k,y*k); }\n  Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n  return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n\nistream &operator >> (istream &is,Point &p){\n  return is >> p.x >> p.y;\n}\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS){ return COUNTER_CLOCKWISE; }\n  if(cross(a,b) < -EPS){ return CLOCKWISE; }\n  if(dot(a,b) < -EPS){ return ONLINE_BACK; }\n  if(norm(a) < norm(b)){ return ONLINE_FRONT; }\n  return ON_SEGMENT;\n}\n\nstruct Segment{\n  Point s,t;\n  Segment(){}\n  Segment(Point s,Point t) : s(s),t(t) {}\n};\n\nbool isIntersectSS(const Segment &a,const Segment &b){\n  Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n  return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n          ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n\nPoint crosspointSS(const Segment &a,const Segment &b){\n  Vector va = a.t-a.s, vb = b.t-b.s;\n  double d = cross(vb,va);\n  return a.s+va*cross(vb,b.t-a.s)*(1.0/d);\n}\n\nstruct P{\n  int comp;\n  int pos;\n  double dist;\n\n  bool operator < (const P &p)const{\n    if(dist != p.dist){\n      return dist < p.dist;\n    }\n  }\n};\n\nint solve(int idx,int p,vector<P> &v){\n  if(idx == (int)v.size()){ return 0; }\n  int res;\n  if(v[idx].comp == 0){\n    if(p == v[idx].pos){\n      res = solve(idx+1,!p,v)+1;\n    }else{\n      res = solve(idx+1,p,v);\n    }\n  }else{\n    if(p == v[idx].pos){\n      res = solve(idx+1,p,v);\n    }else{\n      res = solve(idx+1,!p,v)+1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int Tc,N,comp,pos;\n  cin >> Tc;\n  while(Tc--){\n    Segment s,line;\n    cin >> s.s >> s.t >> N;\n    vector<P> vec;\n    for(int i = 0 ; i < N ; i++){\n      cin >> line.s >> line.t >> comp >> pos;\n      if(isIntersectSS(line,s)){\n        Point p = crosspointSS(line,s);\n        double d = dist(p,s.s);\n        vec.push_back((P){comp,pos,d});\n      }\n    }\n    sort(vec.begin(),vec.end());\n    cout << min(solve(0,0,vec),solve(0,1,vec)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\n\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\n  \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nint main(){\n  int N;\n  cin >> N;\n  double x_s, y_s, x_t, y_t;\n  for(int i = 0; i < N; ++i){\n    cin >> x_s >> y_s >> x_t >> y_t;\n    P a = P(x_s,y_s), b = P(x_t, y_t);\n    L S = L(a,b);\n    int n, o, l;\n    cin >> n;\n    vector<pair<P,int> > cp;\n    for(int i = 0; i < n; ++i){\n      cin >> x_s >> y_s >> x_t >> y_t >> o >> l;\n      L T = L(P(x_s,y_s),P(x_t,y_t));\n      if(is_cross(S,T))\n\tcp.push_back(make_pair(intersection(S,T),o^l));\n    }\n    sort(cp.begin(),cp.end());\n    int t = cp[0].second, ans = 0;\n    for(int i = 1; i < (int)cp.size(); ++i){\n      if(t != cp[i].second){\n\t++ans;\n\tt = cp[i].second;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-10\n\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble dist2(P& a, P& b)\n{\n\treturn (a.real()-b.real())*(a.real()-b.real())+(a.imag()-b.imag())*(a.imag()-b.imag());\n}\n\nclass XP\n{\npublic:\n\tint cg;\n\tdouble dist;\n\tXP(int cg, double dist)\n\t:cg(cg),dist(dist)\n\t{}\n\t\n\tbool operator<(const XP& a) const\n\t{\n\t\treturn dist<a.dist;\n\t}\n};\n\nint main()\n{\n\tint N,M;\n\tscanf(\"%d\", &N);\n\twhile(N--)\n\t{\n\t\tint xa,ya,xb,yb;\n\t\tscanf(\"%d%d%d%d\", &xa,&ya,&xb,&yb);\n\t\tL line=L(P(xa,ya),P(xb,yb));\n\t\t\n\t\tscanf(\"%d\", &M);\n\t\tvector<XP> xp;\n\t\twhile(M--)\n\t\t{\n\t\t\tint xs,ys,xt,yt,o,l;\n\t\t\tscanf(\"%d%d%d%d%d%d\",&xs,&ys,&xt,&yt,&o,&l);\n\t\t\tL road=L(P(xs,ys),P(xt,yt));\n\t\t\t\n\t\t\tif(intersectSS(line, road))\n\t\t\t{\n\t\t\t\tint cg=(o==l?1:0);\n\t\t\t\tP p=crosspoint(line, road);\n\t\t\t\txp.push_back(XP(cg, dist2(line[0], p)));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tsort(xp.begin(), xp.end());\n\t\tif(xp.size()>0)\n\t\t{\n\t\t\tint ps=xp[0].cg;\n\t\t\tfor(int i=1; i<xp.size(); i++)\n\t\t\t{\n\t\t\t\tif(xp[i].cg!=ps)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\tps=xp[i].cg;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-10\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョテ」ツ?療」ツ?ヲティツカツウテ」ツ?療ァツョツ?\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2テヲツャツ。テ・ツ?ε」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p)const{\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p)const{\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d)const{\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d)const{\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p)const{//テ・ツ??ァツゥツ?\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p)const{//テ・ツ、ツ姪ァツゥツ?\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p)const{\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//テァツキツ堙・ツ按?1-p2テ、ツクツ甘」ツ?ォテァツつケqテ」ツ?古」ツ?づ」ツつ凝」ツ?凝・ツ按、テ・ツョツ?\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//テァツ崢エテァツキツ嗔1-p2テ」ツ?ィテァツ崢エテァツキツ嘔1-q2テ」ツ?ョテ、ツコツ、テァツつケ\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//テァツキツ堙・ツ按?1-p2テ」ツ?ィテァツキツ堙・ツ按?1-q2テ」ツ?古、ツコツ、テ・ツキツョテ」ツ?凖」ツつ凝」ツ??\nbool exist_intersection(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//テ・ツケツウティツ。ツ?\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//テ・ツ篠淌ァツつケテ、ツクツュテ・ツソツε・ツ崢榲ィツサツ「\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ崢榲ィツサツ「\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//テ、ツコツ古ァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//テ・ツ??・ツ青古・ツ」ツォテ」ツ?ョテ、ツコツ、テァツつケテ」ツつ津ィツィツ暗ァツョツ?\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//テ、ツコツ、テァツつケテ」ツ?ェテ」ツ??\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ?\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//ティツァツ」テ」ツ?ェテ」ツ??\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tif(exist_intersection(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//テァツキツ堙・ツ按?ゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(exist_intersection(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\n\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ?\ndouble plain_area(vector<P> &poly){\n\tdouble s=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\ts += poly[i].det(poly[(i+1)%poly.size()]);\n\t}\n\treturn abs(s/2);\n}\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ??ゥツδィテ」ツ?ォテァツつケpテ」ツ?古」ツ?づ」ツつ凝」ツ??\nbool contains(vector<P> &poly,P p,double inf=INF){\n\tint cnt=0;\n\tP q(p.x+inf,p.y);\n\tfor(int i=0;i<poly.size();i++){\n\t\tif(exist_intersection(poly[i],poly[(i+1)%poly.size()],p,q))cnt++;\n\t}\n\treturn cnt&1;\n}\n//テァツつケpテ」ツつ津ゥツ?堙」ツつ凝・ツ??」ツ?ョテヲツ篠・テァツキツ?\npair<P,P> tangent_CP(double x,double y,double r,P p){\n\t//P q(x,y), m((x+p.x)/2,(y+p.y)/2);\n\tdouble d=sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y))/2;\n\treturn circle_intersection(x,y,r,(x+p.x)/2,(y+p.y)/2,d);\n}\n\n\nstruct CP{\n\tP p;\n\tint f;\n\tCP(P p,int f):p(p),f(f){}\n\tbool operator<(CP a)const{\n\t\tif(abs(p.x-a.p.x)>EPS)return p.x<a.p.x;\n\t\treturn p.y<a.p.y;\n\t}\n};\n\nint main(){\n\tint testcase;\n\tcin>>testcase;\n\twhile(testcase--){\n\t\tvector<CP> cp;\n\t\tP a,b;\n\t\tint n;\n\t\tcin>>a.x>>a.y>>b.x>>b.y;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tP s,t;\n\t\t\tint o,l,f;\n\t\t\tcin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n\t\t\tf=o^1^l;\n\t\t\tif(exist_intersection(a,b,s,t)){\n\t\t\t\tcp.push_back( CP(intersection(a,b,s,t),f) );\n\t\t\t}\n\t\t}\n\t\tsort(cp.begin(),cp.end());\n\t\tint f=-1,ans=0;\n\t\tfor(int i=0;i<cp.size();i++){\n\t\t\tif(f!=cp[i].f)ans++;\n\t\t\tf=cp[i].f;\n\t\t}\n\t\tcout<<ans-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ld = long double;\nusing Point = complex<ld>;\n\nstruct Line{\n    Point a, b;\n    Line (Point a, Point b) : a(a), b(b) {}\n    Line () : Line(Point(), Point()) {}\n};\n\nconstexpr ld eps=1e-9, pi=acos(-1.0);\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nnamespace Geometry{\n    bool eq(ld a, ld b){\n        return abs(a-b) < eps;\n    }\n    //内積\n    ld dot(Point a, Point b){\n        return real(conj(a) * b);\n    }\n    //外積\n    ld cross(Point a, Point b){\n        return imag(conj(a) * b);\n    }\n    //3点の位置関係\n    int ccw (Point a, Point b, Point c) {\n        b -= a; c -= a;\n        if (cross(b, c) > eps) return 1;//a,b,cで反時計周り\n        if (cross(b, c) < -eps) return -1;//a,b,cで時計周り\n        if (dot(b, c) < 0) return 2;//c,a,bで直線\n        if (norm(b) < norm(c)) return -2;//a,b,cで直線\n        return 0;//a,c,bで直線\n    }\n\n//====================================================\n    Point inputPoint(){\n        ld x, y;\n        cin>>x>>y;\n        return Point(x, y);\n    }\n    //2直線の交差判定\n    bool isCrossed_ll(Line l, Line m){\n        return !eq(cross(l.b-l.a, m.b-m.a), 0);\n    }\n    //直線と線分の交差判定\n    bool isCrossed_ls(Line l, Line s){\n        return isCrossed_ll(l, s) && \n            cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n    }\n    //線分と線分の交差判定\n    bool isCrossed_ss(Line s, Line t){\n        return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n            ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    }\n    //点が直線上にあるか\n    bool isON_l(Line l, Point p){\n        return abs(cross(l.b-p, l.a-p)) < eps;\n    }\n    //点が線分上にあるか\n    bool isON_s(Line s, Point p){\n        return abs(s.a-p)+abs(s.b-p)-abs(s.b-s.a) < eps;\n    }\n\n    //点から直線への垂線の足\n    Point foot(Line l, Point p){\n        ld t = dot(p-l.a,l.a-l.b)/norm(l.a-l.b);\n        return l.a+t*(l.a-l.b);\n    }\n    //直線と直線の交点\n    Point intersection_ll(Line l, Line m){\n        Point lv=l.b-l.a, mv=m.b-m.a;\n        assert(cross(lv,mv)!=0);//平行\n        return l.a+lv*cross(mv,m.a-l.a)/cross(mv,lv);\n    }\n    //線分と線分の交点\n    Point intersection_ss(Line s, Line t){\n        assert(isCrossed_ll(s, t));\n        return intersection_ll(s,t);\n    }\n\n    //点と直線の距離\n    ld dist_lp(Line l, Point p) {\n        return abs(p - foot(l, p));\n    }\n    //直線と直線の距離\n    ld dist_ll(Line l, Line m){\n        return isCrossed_ll(l, m)?0:dist_lp(l, m.a);\n    }\n    //直線と線分の距離\n    ld dist_ls(Line l, Line s){\n        return isCrossed_ls(l, s)?0:min(dist_lp(l, s.a), dist_lp(l, s.b));\n    }\n    //線分と点の距離\n    ld dist_sp (Line s, Point p) {\n        Point r = foot(s, p);\n        return isON_s(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n    }\n    //線分と線分の距離\n    ld dist_ss (Line s, Line t) {\n        if (isCrossed_ss(s, t)) return 0;\n        return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n    }\n};\n\nstruct train{\n    Point p;\n    bool lc;\n    train(Point p, bool lc):p(p), lc(lc) {}\n    bool operator < (const train &right)const{\n        return p < right.p;\n    }\n};\n\nint main(){\n    int n;\n    cin>>n;\n    using namespace Geometry;\n    for(int i=0;i<n;++i){\n        Point a(inputPoint()), b(inputPoint());\n        int m;\n        cin>>m;\n        vector<train>mp;\n        for(int j=0;j<m;++j){\n            bool o,l;\n            Point s(inputPoint()), t(inputPoint());\n            cin>>o>>l;\n            bool loc;\n            if(isCrossed_ss(Line(s, t),Line(a, b))){\n                if(o)loc=l;\n                else loc=(!l);\n                mp.emplace_back(intersection_ss(Line(s, t),Line(a, b)),loc);\n            }\n        }\n        sort(mp.begin(),mp.end());\n        int ans=0;\n        for(int j=1;j<mp.size();++j){\n            if(mp[j].lc != mp[j-1].lc)++ans;\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <assert.h>\nusing namespace std;\n\ntypedef pair<double, double> Pdd;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef L Segment;\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Segment &s, const Segment &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main() {\n  \n  int Tc; cin >> Tc;\n  while(Tc--) {\n    vector<pair<Pdd, int> > vec;\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    Segment express(P(xa, ya), P(xb, yb));\n    int N; cin >> N;\n    int O, I;\n    for(int i=0; i<N; i++) {\n      cin >> xa >> ya >> xb >> yb >> O >> I;\n      Segment line(P(xa, ya), P(xb, yb));\n      if(intersectSS(express, line)) {\n        P crs = crosspoint(express, line);\n        vec.push_back(make_pair(Pdd(crs.real(), crs.imag()), (O+I)%2));\n      }\n    }\n    \n    sort(vec.begin(), vec.end());\n    \n    int ans = 1<<29;\n    for(int s=0; s<2; s++) {\n      int cnt = 0, now = s;\n      for(int i=0; i<vec.size(); i++) {\n        if(now == vec[i].second) {\n          cnt ++; now = 1-now;\n        }\n      }\n      ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define EPS 1e-9\n \nstruct Point{\n    double x,y;\n   \n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n   \n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n    Point operator / (const double &k)const{ return Point(x/k,y/k); }\n};\n \ndouble dot(const Point &a,const Point &b){ return a.x*b.x+a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble dist(const Point &a,const Point &b){\n    return sqrt(pow(a.x-b.x,2) + pow(a.y-b.y,2));\n}\n \nistream &operator >> (istream &is,Point &p){\n    return is >> p.x >> p.y;\n}\n \n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n \nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE; \n    if(dot(a,b) < -EPS) return ONLINE_BACK; \n    if(norm(a) < norm(b)) return ONLINE_FRONT; \n    return ON_SEGMENT;\n}\n \nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n \nbool isIntersectSS(const Segment &a,const Segment &b){\n    Point s[2] = {a.s,a.t}, t[2] = {b.s,b.t};\n    return (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0);\n}\n \nPoint crosspointSS(const Segment &a,const Segment &b){\n    Vector va = a.t-a.s, vb = b.t-b.s;\n    double d = cross(vb,va);\n    return a.s+va*cross(vb,b.t-a.s)*(1.0/d);\n}\n \nstruct P{\n    int comp;\n    int pos;\n    double dist;\n \n    bool operator < (const P &p)const{\n\tif(dist != p.dist){\n\t    return dist < p.dist;\n\t}\n    }\n};\n \nint solve(int idx,int p,vector<P> &v){\n    if(idx == (int)v.size()) return 0;\n    int res;\n    if(v[idx].comp == 0){\n\tif(p == v[idx].pos){\n\t    res = solve(idx+1,!p,v)+1;\n\t}else{\n\t    res = solve(idx+1,p,v);\n\t}\n    }else{\n\tif(p == v[idx].pos){\n\t    res = solve(idx+1,p,v);\n\t}else{\n\t    res = solve(idx+1,!p,v)+1;\n\t}\n    }\n    return res;\n}\n \nint main(){\n    int Tc,N,comp,pos;\n    cin >> Tc;\n    while(Tc--){\n\tSegment s,line;\n\tcin >> s.s >> s.t >> N;\n\tvector<P> vec;\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> line.s >> line.t >> comp >> pos;\n\t    if(isIntersectSS(line,s)){\n\t\tPoint p = crosspointSS(line,s);\n\t\tdouble d = dist(p,s.s);\n\t\tvec.push_back((P){comp,pos,d});\n\t    }\n\t}\n\tsort(vec.begin(),vec.end());\n\tcout << min(solve(0,0,vec),solve(0,1,vec)) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define\tmp\t\t\tmake_pair\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef\tcomplex<double>\tPoint;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a),pb(b); }\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(real(s[0]),real(s[1]))<min(real(t[0]),real(t[1]))-EPS\n\t|| max(real(t[0]),real(t[1]))<min(real(s[0]),real(s[1]))-EPS\n\t|| max(imag(s[0]),imag(s[1]))<min(imag(t[0]),imag(t[1]))-EPS\n\t|| max(imag(t[0]),imag(t[1]))<min(imag(s[0]),imag(s[1]))-EPS)\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\trep(i,3){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t*p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint n;\nPoint A,B;\nSegment AB,S[100];\nbool own[100],loc[100];\n\nint solve(){\n\tvector< pair<double,int> > pts;\n\trep(i,n){\n\t\tPoint Q;\n\t\tif(intersect(AB,S[i],&Q))\tpts.pb(mp(abs(A-Q),i));\n\t}\n\tif(pts.size()==0)\treturn 0;\n\n\tsort(pts.begin(),pts.end());\n\n\tint cnt=0,id=pts[0].second;\n\tbool now=(own[id]?loc[id]:!loc[id]);\n\tfor(int i=1;i<pts.size();i++){\n\t\tid=pts[i].second;\n\t\tif(own[id]){\n\t\t\tif(now!=loc[id]){ cnt++; now=!now; }\n\t\t}\n\t\telse{\n\t\t\tif(now==loc[id]){ cnt++; now=!now; }\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint T;\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint xa,ya,xb,yb;\tscanf(\"%d%d%d%d%d\",&xa,&ya,&xb,&yb,&n);\n\t\tA=Point(xa,ya);\n\t\tB=Point(xb,yb);\n\t\tAB=Segment(A,B);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,o,l;\tscanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&o,&l);\n\t\t\tS[i]=Segment(Point(x1,y1),Point(x2,y2));\n\t\t\town[i]=o;\n\t\t\tloc[i]=l;\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<(EPS)\n\ntypedef pair<pair<double, double>, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      if(EQ(xa,xb)){\n\tdouble d2 = (y1-y2)/(x1-x2);\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n\tdouble d1 = (ya-yb)/(xa-xb);\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n\tdouble d1 = (ya-yb)/(xa-xb);\n\tdouble d2 = (y1-y2)/(x1-x2);\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\t//assert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS ){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(mp(nx,ny), (o==l)));\n      }\n    }\n\n    sort(all(points), sorter);\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-9\n#define INF 1e10\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tlong double r = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\tif((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(tmpx,(o+l)%2));\n\t\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=200005,INF=1<<30;\nconst long double eps=1e-10;\n\nstruct point{\n    long double x;\n    long double y;\n    bool up;\n};\n\nint ccw(point a,point b,point c){\n    point d={b.x-a.x,b.y-a.y};\n    point e={c.x-a.x,c.y-a.y};\n    \n    long double cross=d.x*e.y-d.y*e.x;\n    long double dot=d.x*e.x+d.y*e.y;\n    \n    if(cross>eps) return 1;\n    if(cross<-eps) return -1;\n    if(dot<-eps) return 2;\n    if((d.x*d.x+d.y*d.y)<(e.x*e.x+e.y*e.y)) return -2;\n    return 0;\n}//反時計回り、時計回り、直線上で後ろ、前、線分上\n\nbool intersect(point a,point b,point s,point t){\n    if(ccw(a,b,s)*ccw(a,b,t)<=0&&ccw(s,t,a)*ccw(s,t,b)<=0) return 1;\n    else return 0;\n}//1なら交差\n\npoint GetCrossPoint(point a,point b,point c,point d,bool up){\n    point base={d.x-c.x,d.y-c.y};\n    point vec1={a.x-c.x,a.y-c.y};\n    point vec2={b.x-c.x,b.y-c.y};\n    long double d1=abs(base.x*vec1.y-base.y*vec1.x),d2=abs(base.x*vec2.y-base.y*vec2.x);\n    long double t=d1/(d1+d2);\n    \n    return {a.x+(b.x-a.x)*t,a.y+(b.y-a.y)*t,up};\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        point s,g;cin>>s.x>>s.y>>g.x>>g.y;\n        vector<point> use;\n        \n        int N;cin>>N;\n        for(int i=0;i<N;i++){\n            point a,b;cin>>a.x>>a.y>>b.x>>b.y;\n            int o,l;cin>>o>>l;\n            \n            if(intersect(s,g,a,b)){\n                point p=GetCrossPoint(s,g,a,b,bool((o+l)%2));\n                use.push_back(p);\n            }\n        }\n        \n        sort(all(use),[](point a,point b){\n            if(a.x==b.x) return a.y<b.y;\n            return a.x<b.x;\n        });\n        int ans=0;\n        \n        for(int i=0;i+1<use.size();i++){\n            if(use[i].up!=use[i+1].up) ans++;\n        }\n        \n        cout<<ans<<endl;\n    }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n#define S first\n#define T second\n#define EX P(INF,INF)\n\nbool operator < (const P& a, const P& b) {\n\treturn a.X != b.X ? a.X < b.X : a.Y < b.Y;\n}\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dot(P a, P b) {\n\treturn (conj(a) * b).X;\n}\ndouble dist(P a, P b) {\n\treturn (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);\n}\n\n//??????(a,b)??????c????????¨????????? isPointOnLine\nbool isPOL(P a, P b, P c) {\n\treturn abs(a - c) + abs(c - b) < abs(a - b) + EPS;\n}\n\n//????????¨?????????????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d2, 0)) {\n\t\treturn EX; //??????\n\t}\n\tP ret = a1 + d1 / d2 * (a2 - a1);\n\tif (isPOL(b1, b2, ret) && isPOL(a1, a2, ret)) {\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn EX; //????????????????????????\n\t}\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb &t0, pbb &t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            //cout << a << ' ' << b << endl;\n            if(not a) b = (b ? 0 : 1);\n            place[i] = b;\n            //cout << a << ' ' << b << endl;\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n) v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n        sort(all(v));\n        rep(i,n){\n            if(s.empty()) s.emplace_back(v[i].second);\n            if(s.back() == v[i].second) continue;\n            s.emplace_back(v[i].second);\n        }\n        cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {x.first+y.first,x.second+y.second};\n}\n\nP operator-(const P& x,const P& y){\n    return {x.first-y.first,x.second-y.second};\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return x.first*y.first+x.second*y.second;\n\n}\n\ndouble det(P x,P y){\n    return x.first*y.second-x.second*y.first;\n\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(wrtwrt,n){\n        P s,t;\n        cin>>s.first>>s.second>>t.first>>t.second;\n        int m;cin>>m;\n        map<P,int> mp;\n        rep(i,m){\n            P x,y;\n            cin>>x.first>>x.second>>y.first>>y.second;\n            int a,b;\n            cin>>a>>b;\n            if(cross(s,t,x,y))mp[intersection(s,t,x,y)]=a^b;\n        }\n        int ans=-1;\n        int pos=-1;\n        for(auto x:mp){\n            if(x.second!=pos)ans++;\n            pos=x.second;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(double& x, double& y, int xo, int yo, int dx, int dy) {\n\tll _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\ndouble add(double a, double b) {\n\tif (abs(a + b) < EPS * (abs(a) + abs(b)))\n\t\treturn 0;\n\treturn a + b;\n}\n\nstruct P {\n\tdouble x, y;\n\tP() {};\n\tP(double x_, double y_) : x(x_), y(y_) { }\n\n\tP operator + (P p) {\n\t\treturn P(add(x, p.x), add(y, p.y));\n\t}\n\n\tP operator - (P p) {\n\t\treturn P(add(x, -p.x), add(y, -p.y));\n\t}\n\n\tP operator * (double d) {\n\t\treturn P(x * d, y * d);\n\t}\n\n\tP operator / (double d) {\n\t\treturn P(x / d, y / d);\n\t}\n\n\tbool operator < (const P &p) const {\n\t\treturn x < p.x + EPS;\n\t}\n\n\t// ??????\n\tdouble dot(P p) {\n\t\treturn add(x * p.x, y * p.y);\n\t}\n\n\t// ??????\n\tdouble det(P p) {\n\t\treturn add(x * p.y, -y * p.x);\n\t}\n};\n\n// ??´?????¨??´????????????\nP intersection(P p1, P p2, P q1, P q2) {\n\treturn p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));\n}\n\n// ???????????????????????????\nbool on_seg(P p1, P p2, P q) {\n\treturn (p1 - q).det(p2 - q) == 0 && (p1 - q).dot(p2 - q) <= 0;\n}\n\n\n//////////////////////\n\nstruct Line {\n\tP s, t;\n\tbool owner;\n\tbool layer;\n\n\tbool operator < (const Line &l) const {\n\t\treturn s < l.s;\n\t}\n};\n\nvoid solve() {\n\t// input\n\tP a, b;\n\tcin >> a.x >> a.y >> b.x >> b.y;\n\t\n\tint n;\n\tcin >> n;\n\n\tvector<Line> lines(n);\n\tfor (auto &l : lines) {\n\t\tcin >> l.s.x >> l.s.y >> l.t.x >> l.t.y >> l.owner >> l.layer;\n\t}\n\n\t// ??????????±???????\n\tvector<pair<P, Line>> ps;\n\tfor (auto &l : lines) {\n\t\tP p = intersection(a, b, l.s, l.t);\n\t\tif (on_seg(a, b, p) && on_seg(l.s, l.t, p)) {\n\t\t\tps.EB(p, l);\n\t\t}\n\t}\n\n\tsort(ALL(ps));\n\n\t// ??´???????????????\n\tint cnt = 0;\n\n\tif (!ps.size()) {\n\t\tcout << cnt << endl;\n\t\treturn;\n\t}\n\n\tbool current = ps[0].snd.layer ? false : true;\n\tif (ps[0].snd.owner) {\n\t\tcurrent = !current;\n\t}\n\n\tfor (int i = 1; i < (int)ps.size(); i++) {\n\t\tbool expect = ps[i].snd.layer ? false : true;\n\t\tif (ps[i].snd.owner) {\n\t\t\texpect = !expect;\n\t\t}\n\n\t\tif (expect != current) {\n\t\t\tcurrent = expect;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\t// ??????\n\tcout << cnt << endl;\n}\n\nint main(void) {\n\tint T;\n\tcin >> T;\n\n\tfor (int i = 0; i < T; i++) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef complex<double> C;\n\n#define EPS (1e-9)\n\ndouble cross(C a, C b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint is_intersected(C a1, C a2, C b1, C b2) {\n  return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n         (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS);  \n}\n\nint t;\nC s[100], e[100];\nint o[100], l[100];\n\nvoid solve() {\n  double xa, ya, xb, yb;\n  cin>>xa>>ya>>xb>>yb;\n  C a(xa, ya), b(xb, yb);\n  C ab = b - a;\n  \n  int n;\n  cin>>n;\n  for (int i = 0; i < n; i += 1) {\n    cin>>s[i].real()>>s[i].imag();\n    cin>>e[i].real()>>e[i].imag();\n    cin>>o[i]>>l[i];\n  }\n  \n  // ð_ÌWðßé\n  // xÀWÆù¶Hüf[^ÌY\n  vector<pair<double,int> > iss;\n  for (int i = 0; i < n; i += 1) {\n    if (!is_intersected(a, b, s[i], e[i])) continue;\n    C ex = e[i] - s[i];\n    /*\n    C pp = xa + ab * cross(ex, s[i] - xa) / cross(ex, ab);\n    iss.push_back(make_pair(pp.real(), i));\n    */\n    double d1 = abs(cross(ex, a - s[i]));\n    double d2 = abs(cross(ex, b - s[i]));\n    double t = d1 / (d1 + d2);\n    iss.push_back(make_pair(t, i));\n  }\n  \n  sort(iss.begin(), iss.end());\n  int res = 100;\n  for (int z = 0; z < 2; z += 1) {\n    int mode = z, tres = 0;\n    for (int i = 0; i < iss.size(); i += 1) {\n      int num = iss[i].second;\n      \n      bool flag = false;\n      if (o[num] == 1 && l[num] != mode) {\n        flag = true;\n      } else if (o[num] == 0 && l[num] == mode) {\n        flag = true;\n      }\n      \n      if (flag) {\n        tres++;\n        mode = !mode;\n        //mode = (mode == 1) ? 0 : 1 ;\n      }\n    }\n    res = min(res, tres);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  cin>>t;\n  \n  for(int i=0;i<t;i++) solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<math.h>\n#include<iostream>\nusing namespace std;\n\nstruct st_data{\n\tdouble jp;\n\tint l;\n};\n\nint size;\nst_data *data;\ndouble xa,ya,xb,yb;\ndouble xs,ys,xt,yt;\nint o,l;\ndouble a,b,c;//ax+by+c=0\nint n;\n\nint jpn;\n\n//len=|ax+by+c|/sqrt(a^2+b^2)\n//point=(x,y)-(ax+by+c)/(a^2+b^2) (a,b)\n//joint=(x0,y0)+((x1,y1)-(x0,y0))*len0/(len0+len1)\nvoid set();\ndouble lpp(double,double);\ndouble len(double,double);\ndouble lenn(double,double);\ndouble lenp(double,double);\nvoid point(double*,double*,double,double);\nvoid joint(double*,double*,double,double,double,double,double,double);\nvoid sort();\nvoid swap(st_data*,st_data*);\n\nint main(){\n\tcin>>size;\n\tdouble len0,len1;\n\tint i;\n\tdouble x,y;\n\tdouble eps=1.0e-9;\n\tfor(int roop=0;roop<size;roop++){//dataset-roop\n\t\tcin>>xa>>ya>>xb>>yb;\n\t\t//cout<<\"@\"<<xa<<\"@\"<<ya<<\"@\"<<xb<<\"@\"<<yb<<endl;\n\t\tset();\n\t\tcin>>n;\n\t\tdata=new st_data[n];\n\t\tjpn=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>xs>>ys>>xt>>yt>>o>>l;\n\t\t\tlen0=len(xs,ys);\n\t\t\tlen1=len(xt,yt);\n\t\t\tif(len0*len1>0){\n\t\t\t\t//cout<<\" continue\"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlen0=fabs(len0);\n\t\t\tlen1=fabs(len1);\n\t\t\tpoint(&xs,&ys,xs,ys);\n\t\t\tpoint(&xt,&yt,xt,yt);\n\t\t\tjoint(&x,&y,xs,ys,len0,xt,yt,len1);\n\t\t\tcout<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\tdouble px0,py0,px1,py1;\n\t\t\tif(xa>xb){\n\t\t\t\tpx0=xb;\n\t\t\t\tpx1=xa;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpx0=xa;\n\t\t\t\tpx1=xb;\n\t\t\t}\n\t\t\tif(ya>yb){\n\t\t\t\tpy0=yb;\n\t\t\t\tpy1=ya;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpy0=ya;\n\t\t\t\tpy1=yb;\n\t\t\t}\n\t\t\tif(((px0-x)<=eps && (x-px1)<=eps) && ((py0-y)<=eps && (y-py1)<=eps)){\n\t\t\t\tif(o==l) data[jpn].l=1;\n\t\t\t\telse data[jpn].l=0;\n\t\t\t\tdata[jpn++].jp=lpp(x,y);\n\t\t\t}\n\t\t}\n\t\tsort();\n\t\tint p=data[0].l;\n\t\tint q=0;\n\t\t//cout<<\" \"<<data[0].jp<<\",\"<<data[0].l<<endl;\n\t\tfor(i=1;i<jpn;i++){\n\t\t\t//cout<<\" \"<<data[i].jp<<\",\"<<data[i].l<<endl;\n\t\t\tif(p!=data[i].l){\n\t\t\t\tp=data[i].l;\n\t\t\t\tq++;\n\t\t\t}\n\t\t}\n\t\tcout<<q<<endl;\n\t\tdelete []data;\n\t}\n\treturn 0;\n}\n\nvoid set(){\n\ta=yb-ya;\n\tb=xa-xb;\n\tc=xb*ya-xa*yb;\n}\n\ndouble lpp(double x,double y){\n\treturn sqrt((x-xa)*(x-xa)+(y-ya)*(y-ya));\n}\n\ndouble len(double x,double y){\n\t//len=|ax+by+c|/sqrt(a^2+b^2)\n\treturn ((double)(a*x+b*y+c));\n}\n\ndouble lenn(double x,double y){\n\t//len=|ax+by+c|/sqrt(a^2+b^2)\n\treturn ((double)(a*x+b*y+c)/sqrt(a*a+b*b));\n}\n\ndouble lenp(double x,double y){\n\treturn ((double)(a*x+b*y+c)/(a*a+b*b));\n}\n\nvoid point(double *x,double *y,double x0,double y0){\n\t//point=(x,y)-(ax+by+c)/(a^2+b^2) (a,b)\n\tdouble l=lenp(x0,y0);\n\t*x=x0-l*a;\n\t*y=y0-l*b;\n\treturn;\n}\n\nvoid joint(double *x,double *y,double x0,double y0,double l0,double x1,double y1,double l1){\n\t//joint=(x0,y0)+((x1,y1)-(x0,y0))*len0/(len0+len1)\n\t*x=x0+(x1-x0)*l0/(l0+l1);\n\t*y=y0+(y1-y0)*l0/(l0+l1);\n\treturn;\n}\n\nvoid sort(){\n\tfor(int i=0;i<jpn-1;i++){\n\t\tfor(int j=0;j<jpn-i-1;j++){\n\t\t\tif(data[j].jp>data[j+1].jp){\n\t\t\t\tst_data buf=data[j];\n\t\t\t\tdata[j]=data[j+1];\n\t\t\t\tdata[j+1]=buf;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid swap(st_data *d0,st_data *d1){\n\tst_data *buf;\n\tbuf->jp=d1->jp;\n\tbuf->l=d1->l;\n\td1->jp=d0->jp;\n\td1->l=d0->l;\n\td0->jp=buf->jp;\n\td0->l=buf->l;\n\treturn;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> C;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct Point {\n  C p;\n  int my, up;\n};\n\nbool operator<(const Point &a, const Point &b) {\n  return a.p.real() < b.p.real();\n}\n\ndouble cross(const C &a, const C &b) {\n  return imag(conj(a) * b);\n}\n\nvoid intersectSS(C p1, C p2, C q1, C q2, vector<Point> &v, int my, int up) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 0 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 0) {\n    C q = q2 - q1;\n    double d1 = abs(cross(q, p1 - q1));\n    double d2 = abs(cross(q, p2 - q1));\n    double t = d1 / (d1 + d2);\n\n    v.pb((Point{p1 + (p2 - p1) * t, my, up}));\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t;\n  cin >> t;\n  rep(ii, t) {\n    int x1, y1, x2, y2, o, l, n;\n    cin >> x1 >> y1 >> x2 >> y2;\n    C s = C(x1, y1), e = C(x2, y2);\n\n    cin >> n;\n    vector<Point> point;\n    rep(i, n) {\n      cin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n      intersectSS(s, e, C(x1, y1), C(x2, y2), point, o, l);\n    }\n\n    sort(all(point));\n    P p[2] = {P(1, 0), P(0, 0)};\n    rep(i, 2) {\n      rep(j, point.size()) {\n        if (point[j].my) {\n          if (p[i].fi != point[j].up) {\n            p[i].fi = point[j].up;\n            p[i].se++;\n          }\n        } else {\n          if (p[i].fi == point[j].up) {\n            p[i].fi = (p[i].fi + 1) % 2;\n            p[i].se++;\n          }\n        }\n      }\n    }\n\n    cout << min(p[0].se, p[1].se) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\n// const ll LLINF = (1LL<<60);\n// const int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nbool contain(const L &l, const P &p) {\n  double ax = l[0].real(), ay = l[0].imag();\n  double bx = l[1].real(), by = l[1].imag();\n  if(ax > bx) swap(ax, bx);\n  if(ay > by) swap(ay, by);\n  return (ax > p.real() || bx < p.real() || ay > p.imag() || by < p.imag());\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int T;\n  cin >> T;\n  REP(_, T) {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    L line(P(ax,ay), P(bx,by));\n\n    // 交点の位置とその交点が高架か地下か\n    vector<pair<P, int>> po;\n    int n;\n    cin >> n;\n    REP(i, n) {\n      int xs, ys, xt, yt, o, l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L l2(P(xs,ys), P(xt,yt));\n      P c = crosspoint(line, l2);\n      if(contain(line, c) || contain(l2, c)) continue;\n      po.PB({c, o^l});\n    }\n    sort(ALL(po));\n    // cout << po << endl;\n    int ret = 0;\n    FOR(i, 1, po.size()) {\n      if(po[i].second != po[i-1].second) ret++;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nnamespace geo{\n    using real_num = double;\n    constexpr real_num eps = 1e-9;\n    constexpr real_num PI = 3.14159265358979323846264338327950;\n\n    inline int sgn(real_num x){\n        if(x < -eps) return -1;\n        if(x > eps) return 1;\n        return 0;\n    }\n \n    inline bool eq(real_num x, real_num y){\n        return sgn(x-y) == 0;\n    }\n \n    inline bool ge(real_num x, real_num y){\n        return sgn(x-y) == 1;\n    }\n \n    inline bool le(real_num x, real_num y){\n        return sgn(x-y) == -1;\n    }\n \n    inline bool geq(real_num x, real_num y){\n        return sgn(x-y) >= 0;\n    }\n \n    inline bool leq(real_num x, real_num y){\n        return sgn(x-y) <= 0;\n    }\n\n    struct Point{\n        real_num x, y;\n        Point(real_num x=0, real_num y=0): x(x), y(y){}\n \n        Point operator+(const Point &p){\n            return {x+p.x, y+p.y};\n        }\n \n        Point operator-(const Point &p){\n            return {x-p.x, y-p.y};\n        }\n \n        Point operator*(const real_num k){\n            return {k*x, k*y};\n        }\n \n        Point operator/(const real_num k){\n            return {x/k, y/k};\n        }\n \n        real_num operator*(const Point &p){\n            return x*p.x + y*p.y;\n        }\n \n        real_num operator^(const Point &p){\n            return x*p.y - y*p.x;\n        }\n \n        bool operator==(const Point &p){\n            return eq(x, p.x) && eq(y, p.y);\n        }\n \n        bool operator<(const Point &p) const{\n            if(eq(x, p.x)) return le(y, p.y);\n            return le(x, p.x);\n        }\n    };\n\n    using Vec = Point;\n    using Points = vector<Point>;\n    using Polygon = vector<Point>;\n\n    real_num norm(Point p){\n        return p.x*p.x+p.y*p.y;\n    }\n \n    real_num abs(Point p){\n        return sqrt(norm(p));\n    }\n \n    real_num arg(Point p){\n        return atan2(p.y, p.x);\n    }\n\n    real_num angle(Point a, Point b){\n        return arg({a*b, a^b});\n    }\n \n    Point rot(Point p, real_num t){\n        return {p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t)};\n    }\n \n    Point proj(Point a, Vec v, Point p){\n        real_num t=v*(p-a)/norm(v);\n        return a+v*t;\n    }\n \n    Point refl(Point a, Vec v, Point p){\n        return proj(a, v, p)*2-p;\n    }\n\n    constexpr int CCW_COUNTER_CLOCKWISE = 1;\n    constexpr int CCW_CLOCKWISE = -1;\n    constexpr int CCW_ONLINE_BACK = -2; // C->A->B\n    constexpr int CCW_ONLINE_FRONT = 2; // A->B->C\n    constexpr int CCW_ON_SEGMENT = 0; // A->C->B\n \n    inline int ccw(Point a, Point b, Point c){\n        Vec v = b-a, w = c-a;\n        if(ge(v^w, 0)) return CCW_COUNTER_CLOCKWISE;\n        if(le(v^w, 0)) return CCW_CLOCKWISE;\n        if(le(v*w, 0)) return CCW_ONLINE_BACK;\n        if(le((a-b)*(c-b), 0)) return CCW_ONLINE_FRONT;\n        return CCW_ON_SEGMENT;\n    }\n\n    bool is_parallel(Vec v, Vec w){\n        return eq(v^w, 0);\n    }\n\n    bool is_orthogonal(Vec v, Vec w){\n        return eq(v*w, 0);\n    }\n\n    bool has_intersection_ls(Point p, Vec v, Point a, Point b){\n        return sgn(v^(a-p)) * sgn(v^(b-p)) <= 0;\n    }\n\n    bool has_intersection_ss(Point a, Point b, Point c, Point d){\n        return ccw(a, b, c)*ccw(a, b, d) <= 0 && ccw(c, d, a)*ccw(c, d, b) <= 0;\n    }\n\n    Point intersection_ll(Point a, Vec v, Point b, Vec w){\n        real_num t = ((b-a)^w) / (v^w);\n        return a + v*t;\n    }\n\n    real_num distance_lp(Point a, Vec v, Point p){\n        return abs(v^(p-a)/abs(v));\n    }\n\n    real_num distance_sp(Point a, Point b, Point p){\n        if(le((b-a)*(p-a), 0)) return abs(p-a);\n        if(le((a-b)*(p-b), 0)) return abs(p-b);\n        return distance_lp(a, b-a, p);\n    }\n\n    real_num distance_ll(Point a, Vec v, Point b, Vec w){\n        if(is_parallel(v, w)) return distance_lp(a, v, b);\n        return 0;\n    }\n\n    real_num distance_ls(Point p, Vec v, Point a, Point b){\n        if(has_intersection_ls(p, v, a, b)) return 0;\n        return min(distance_lp(p, v, a), distance_lp(p, v, b));\n    }\n\n    real_num distance_ss(Point a, Point b, Point c, Point d){\n        if(has_intersection_ss(a, b, c, d)) return 0;\n        return min({distance_sp(a, b, c), distance_sp(a, b, d),\n                distance_sp(c, d, a), distance_sp(c, d, b)});\n    }\n\n    real_num area(Polygon &p){\n        real_num ret = 0;\n        rep(i, p.size()) ret += p[i] ^ p[(i+1)%p.size()] / 2;\n        return abs(ret);\n    }\n\n    bool is_convex(Polygon &p){\n        int n = p.size();\n        bool flag1 = false, flag2 = false;\n        rep(i, n){\n            int tmp = ccw(p[(i+n-1)%n], p[i], p[(i+1)%n]);\n            if(tmp == CCW_COUNTER_CLOCKWISE){\n                if(flag2) return false;\n                flag1=true;\n            }\n            else if(tmp == CCW_CLOCKWISE){\n                if(flag1) return false;\n                flag2 = true;\n            }\n        }\n        return true;\n    }\n\n    int point_in_polygon(Point a, Polygon &p){\n        int n = p.size(), wn = 0;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(distance_sp(p[i], p[j], a) == 0) return 1;\n            else if(p[i].y <= a.y && a.y < p[j].y){\n                wn += (ccw(a, p[i], p[j]) == CCW_COUNTER_CLOCKWISE);\n            }\n            else if(p[j].y <= a.y && a.y < p[i].y){\n                wn -= (ccw(a, p[i], p[j]) == CCW_CLOCKWISE);\n            }\n        }\n        return wn == 0 ? 0 : 2;\n    }\n\n    Polygon convex_hull(Points p){\n        int n = p.size();\n        sort(p.begin(), p.end());\n        Polygon ch(2*n);\n        int k = 0;\n        rep(i, n){\n            while(k>1 && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        for(int i=n-2, t=k; i>=0; --i){\n            while(k>t && le((ch[k-1]-ch[k-2])^(p[i]-ch[k-1]), 0)) --k;\n            ch[k++] = p[i];\n        }\n        ch.resize(k-1);\n        return ch;\n    }\n\n    pair<real_num, pii> farthest_pair(Polygon &p){\n        int n = p.size();\n        if(n == 2){\n            return {abs(p[0]-p[1]), {0, 1}};\n        }\n        int i = 0, j = 0;\n        rep(k, n){\n            if(le(p[k].x, p[i].x)) i = k;\n            if(ge(p[k].x, p[j].x)) j = k;\n        }\n        real_num d = 0;\n        int a = i, b = j, si = i, sj = j;\n        while(i != sj || j != si){\n            if(chmax(d, abs(p[i]-p[j]))) a = i, b = j;\n            if(le((p[(i+1)%n]-p[i]) ^ (p[(j+1)%n]-p[j]), 0)){\n                i = (i+1) % n;\n            }\n            else j = (j+1) % n;\n        }\n        return {d, {a, b}};\n    }\n\n    real_num convex_cut(Polygon &p, Point a, Vec v){\n        int n = p.size();\n        Polygon q;\n        rep(i, n){\n            int j = (i+1) % n;\n            if(geq(v^(p[i]-a), 0)) q.push_back(p[i]);\n            if(has_intersection_ls(a, v, p[i], p[j]) && !is_parallel(v, p[j]-p[i])){\n                q.push_back(intersection_ll(a, v, p[i], p[j]-p[i]));\n            }\n        }\n        return area(q);\n    }\n\n    pair<real_num, pii> closest_pair_rec(vector<pair<Point, int>> &p, int l, int r){\n        if(r-l <= 1) return {INF, {p.size(), p.size()}};\n\n        int m = (l+r) / 2;\n        real_num x = p[m].fi.x;\n        auto d = min(closest_pair_rec(p, l, m), closest_pair_rec(p, m, r));\n        auto cmp = [](pair<Point, int> a, pair<Point, int> b){return a.fi.y < b.fi.y;};\n        inplace_merge(p.begin()+l, p.begin()+m, p.begin()+r, cmp);\n\n        vector<pair<Point, int>> q;\n        For(i, l, r){\n            if(ge(abs(p[i].fi.x-x), d.fi)) continue;\n            rrep(j, q.size()){\n                real_num dy = p[i].fi.y - q[j].fi.y;\n                if(geq(dy, d.fi)) break;\n                chmin(d, {abs(p[i].fi-q[j].fi), {p[i].se, q[j].se}});\n            }\n            q.push_back(p[i]);\n        }\n        return d;\n    }\n\n    pair<real_num, pii> closest_pair(Points &p){\n        vector<pair<Point, int>> pid(p.size());\n        rep(i, p.size()) pid[i] = {p[i], i};\n        sort(pid.begin(), pid.end());\n        return closest_pair_rec(pid, 0, p.size());\n    }\n\n    int has_intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        if(r1 < r2){\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        real_num d = abs(c1-c2), r = r1 + r2;\n        if(ge(d, r)) return 4;\n        if(eq(d, r)) return 3;\n        if(eq(d+r2, r1)) return 1;\n        if(le(d+r2, r1)) return 0;\n        return 2;\n    }\n\n    bool has_intersection_cl(Point c, real_num r, Point a, Vec v){\n        return leq(distance_lp(a, v, c), r);\n    }\n\n    bool has_intersection_cs(Point c, real_num r, Point a, Point b){\n        return leq(distance_sp(a, b, c), r) && geq(max(abs(a-c), abs(b-c)), r);\n    }\n\n    Points intersection_cl(Point c, real_num r, Point a, Vec v){   \n        Points ps;\n        if(!has_intersection_cl(c, r, a, v)) return ps;\n        Point p = proj(a, v, c);\n        real_num t = sqrt(max((real_num)0.0, (r*r-norm(p-c)) / norm(v)));\n        ps.push_back(p + v*t);\n        if(!eq(t, 0)) ps.push_back(p - v*t);\n        return ps;\n    }\n\n    Points intersection_cs(Point c, real_num r, Point a, Point b){\n        Points ps = intersection_cl(c, r, b, a-b);\n        Points qs;\n        for(auto p: ps){\n            if(ccw(a, b, p) == CCW_ON_SEGMENT) qs.push_back(p);\n        }\n        return qs;\n    }\n\n    Points intersection_cc(Point c1, real_num r1, Point c2, real_num r2){\n        Points ps;\n        Vec v = c2-c1, w = {v.y*-1, v.x};\n        real_num d = abs(v);\n        real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n        real_num y = sqrt(max(r1*r1-x*x, (real_num)0.0));\n        ps.push_back(c1 + v*x/d + w*y/d);\n        if(has_intersection_cc(c1, r1, c2, r2)!=2) return ps;\n        ps.push_back(c1 + v*x/d - w*y/d);\n        return ps;\n    }\n\n    real_num common_area_ct(Point c, real_num r, Point a, Point b){\n        Vec va = a-c, vb = b-c;\n        if(eq(va^vb, 0)) return 0;\n        else if(leq(abs(va), r) && leq(abs(vb), r)) return (va^vb)/2;\n        else if(geq(distance_sp(a, b, c), r)) return r*r*angle(va, vb)/2;\n        else{\n            auto ps = intersection_cs(c, r, a, b);\n            if(ps.size() == 1) return common_area_ct(c, r, a, ps[0]) + common_area_ct(c, r, ps[0], b);\n            else return common_area_ct(c, r, a, ps[0]) + common_area_ct(c, r, ps[0], ps[1]) + common_area_ct(c, r, ps[1], b);\n        }\n    }\n\n    real_num common_area_cp(Point c, real_num r, Polygon &p){\n        int n = p.size();\n        real_num ret = 0;\n        rep(i, n){\n            ret += common_area_ct(c, r, p[i], p[(i+1)%n]);\n        }\n        return ret;\n    }\n\n    real_num commn_area_cc(Point c1, real_num r1, Point c2, real_num r2){\n        int flag = has_intersection_cc(c1, r1, c2, r2);\n        if(flag >= 3) return 0;\n        if(flag <= 1){\n            real_num r = min(r1, r2);\n            return PI*r*r;\n        }\n        real_num d = abs(c1-c2);\n        real_num ret = 0;\n        rep(i, 2) {\n            real_num x = (d*d + r1*r1 - r2*r2) / (2*d);\n            real_num t = acos(x/r1)* 2;\n            ret += (t-sin(t))*r1*r1/2;\n            swap(c1, c2);\n            swap(r1, r2);\n        }\n        return ret;\n    }\n\n    Points tangent(Point c, real_num r, Point p){\n        Points ps;\n        real_num d = abs(p-c);\n        real_num t = acos(r/d);\n        ps.push_back(c + rot(p-c, t)*r/d);\n        ps.push_back(c + rot(p-c, -t)*r/d);\n        return ps;\n    }\n\n    Points common_tangent(Point c1, real_num r1, Point c2, real_num r2){       \n        Points ps;\n        int flag = has_intersection_cc(c1, r1,c2, r2);\n        if(flag >= 2){\n            real_num d = abs(c2-c1);\n            real_num t = acos(abs(r1-r2)/d);\n            if(le(r1, r2)) t = PI-t;\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 4){\n            real_num d = abs(c2-c1);\n            real_num L = d*r1/(r1+r2);\n            real_num t = acos(r1/L);\n            ps.push_back(c1 + rot(c2-c1, t)*r1/d);\n            ps.push_back(c1 + rot(c2-c1, -t)*r1/d);\n        }\n        if(flag == 3 || flag == 1){\n            Polygon tg = intersection_cc(c1, r1, c2, r2);\n            ps.push_back(tg[0]);\n        }\n        return ps;\n    }\n\n    Point get_o(Point a, Point b, Point c){\n        Point M = (a+b)/2, N = (a+c)/2;\n        Vec v = {-(b-a).y, (b-a).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(M, v, N, w);\n    }\n\n    Point get_i(Point a, Point b, Point c){\n        real_num A = abs(b-c), B = abs(c-a), C = abs(a-b);\n        return (a*A+b*B+c*C)/(A+B+C);\n    }\n\n    Point get_h(Point a, Point b, Point c){\n        Vec v = {-(c-b).y, (c-b).x}, w = {-(c-a).y, (c-a).x};\n        return intersection_ll(a, v, b, w);\n    }\n\n    pair<Point, real_num> minimum_bounding_circle(Points &p){\n        Point C;\n        real_num r;\n        if(p.size() == 1) C = p[0], r = 0;\n        else if(p.size() == 2) C = (p[0]+p[1])/2, r = abs(p[0]-C);\n        else{\n            r = INF;\n            Points ch = convex_hull(p);\n            int K = ch.size();\n            auto check = [&](Point tc, real_num tr){\n                rep(i, K){\n                    if(ge(abs(ch[i]-tc), tr)) return false;\n                }\n                return true;\n            };\n            rep(i, K)For(j, i+1, K){\n                Point tc = (ch[i]+ch[j])/2;\n                real_num tr = abs(ch[i]-tc);\n                if(check(tc, tr) && chmin(r, tr)) C = tc;\n                For(k, j+1, K){\n                    int ccw_flag = ccw(ch[i], ch[j], ch[k]);\n                    if(ccw_flag != CCW_COUNTER_CLOCKWISE && ccw_flag != CCW_CLOCKWISE) continue;\n                    tc = get_o(ch[i], ch[j], ch[k]);\n                    tr = abs(ch[i]-tc);\n                    if(check(tc, tr) && chmin(r, tr)) C=tc;\n                }\n            }\n        }\n        return {C, r};\n    }\n}\n\nvoid solve(){\n    using namespace geo;\n    Point a, b;\n    scanf(\"%lf%lf%lf%lf\", &a.x, &a.y, &b.x, &b.y);\n    int n;\n    scanf(\"%d\", &n);\n    vector<pair<Point, int>> ps;\n    rep(_, n){\n        Point p, q;\n        int o, l;\n        scanf(\"%lf%lf%lf%lf%d%d\", &p.x, &p.y, &q.x, &q.y, &o, &l);\n        if(has_intersection_ss(a, b, p, q)){\n            auto s = intersection_ll(a, b-a, p, q-p);\n            ps.emplace_back(s, o^l^1);\n        }\n    }\n    sort(ps.begin(), ps.end());\n    int ans = 0;\n    rep(i, (int)ps.size()-1) ans += (ps[i+1].se != ps[i].se);\n    printf(\"%d\\n\", ans);\n}\n\nint main(){\n    int t;\n    scanf(\"%d\", &t);\n    rep(tt, t){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<long double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(ll& x, ll& y, ll xo, ll yo, ll dx, ll dy) {\n\tll _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<ll> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tlong double x = (long double)(yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(0,0),Point p2=Point(0,0)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\nint main()\n{\n  int n,N,a,b,c,d,e,f;\n  Segment AB;\n  vector<pair<Segment,pair<int,int> > > railroad;\n\n  cin>>n;\n  for(int k=0;k<n;k++){\n    railroad.clear();\n    cin>>AB.p1.x>>AB.p1.y>>AB.p2.x>>AB.p2.y;\n    cin>>N;\n    for(int i=0;i<N;i++){\n      cin>>a>>b>>c>>d>>e>>f;\n      railroad.push_back(mp(Segment(Point(a,b),Point(c,d)),mp(e,f)));\n    }\n    vector<pair<Point,pair<int,int> > > vp;\n    for(int i=0;i<N;i++){\n      if(!intersect(AB,railroad[i].f))continue;\n      Point p=getCrossPointSS(AB,railroad[i].f);\n      vp.push_back(mp(p,mp(railroad[i].s.f,railroad[i].s.s)));\n    }\n    sort(vp.begin(),vp.end());\n    if(AB.p1<AB.p2)reverse(vp.begin(),vp.end());\n    int ans=0,s;\n    if(vp[0].s.f==1)s=vp[0].s.s;\n    if(vp[0].s.f==0)s=(vp[0].s.s+1)%2;\n    for(int i=1;i<vp.size();i++){\n      if(vp[i].s.f==1){\n\tif(vp[i].s.s!=s){\n\t  ans++;\n\t  s=vp[i].s.s;\n\t}\n      }\n      if(vp[i].s.f==0){\n\tif(vp[i].s.s==s){\n\t  ans++;\n\t  s=(vp[i].s.s+1)%2;\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef complex<double> C;\n\n#define EPS (1e-9)\n\ndouble cross(C a, C b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint is_intersected(C a1, C a2, C b1, C b2) {\n  return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n         (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS);  \n}\n\nint t;\nC s[100], e[100];\nint o[100], l[100];\n\nvoid solve() {\n  double xa, ya, xb, yb;\n  cin>>xa>>ya>>xb>>yb;\n  C a(xa, ya), b(xb, yb);\n  C ab = b - a;\n  \n  int n;\n  cin>>n;\n  for (int i = 0; i < n; i += 1) {\n    cin>>s[i].real()>>s[i].imag();\n    cin>>e[i].real()>>e[i].imag();\n    cin>>o[i]>>l[i];\n  }\n  \n  // ð_ÌWðßé\n  // xÀWÆù¶Hüf[^ÌY\n  vector<pair<double,int> > iss;\n  for (int i = 0; i < n; i += 1) {\n    if (!is_intersected(a, b, s[i], e[i])) continue;\n    if (abs(cross(b-a, e[i]-s[i])) < EPS) continue;\n    C ex = e[i] - s[i];\n    //double d1 = abs(cross(ex, xa - s[i]));\n    double d1 = abs(cross(ex, a - s[i]));\n    //double d2 = abs(cross(ex, xb - s[i]));\n    double d2 = abs(cross(ex, b - s[i]));\n    double t = d1 / (d1 + d2);\n    iss.push_back(make_pair(t, i));\n  }\n  \n  sort(iss.begin(), iss.end());\n  int res = 100;\n  for (int z = 0; z < 2; z += 1) {\n    int mode = z, tres = 0;\n    for (int i = 0; i < iss.size(); i += 1) {\n      int num = iss[i].second;\n      \n      bool flag = false;\n      if (o[num] == 1 && l[num] != mode) {\n        flag = true;\n      } else if (o[num] == 0 && l[num] == mode) {\n        flag = true;\n      }\n      \n      if (flag) {\n        tres++;\n        mode = !mode;\n        //mode = (mode == 1) ? 0 : 1 ;\n      }\n    }\n    res = min(res, tres);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  cin>>t;\n  \n  for(int i=0;i<t;i++) solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,int>dat[1000];\n//Y*(tx-sx)=(X-sx)*(ty-sy)+sy*(tx-sx)\n//Y*(bx-ax)=(X-ax)*(by-ay)+ay*(bx-ax)\n//X=ax\n//Y*(tx-sx)=(ax-sx)*(ty-sy)+sy*(tx-sx)\n//(bx-ax)*(X*(ty-sy)+sy*tx-sx*ty)=(tx-sx)*(X*(by-ay)+ay*bx-ax*by)\n//(bx-ax)*(ty-sy)*X+(bx-ax)*(sy*tx-sx*ty)=(tx-sx)*(by-ay)*X+(tx-sx)*(ay*bx-ax*by)\n//((bx-ax)*(ty-sy)-(tx-sx)*(by-ay))*X=(tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty)\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tlong long ax,ay,bx,by;\n\t\tscanf(\"%lld%lld%lld%lld\",&ax,&ay,&bx,&by);\n\t\tint c;\n\t\tif(ax>bx){\n\t\t\tlong long cx=ax;\n\t\t\tax=bx;\n\t\t\tbx=cx;\n\t\t\tlong long cy=ay;\n\t\t\tay=by;\n\t\t\tby=cy;\n\t\t}\n\t\tscanf(\"%d\",&c);\n\t\tint now=0;\n\t\tif(ax==bx){\n\t\t\tif(ay>by){\n\t\t\t\tlong long cy=ay;\n\t\t\t\tay=by;\n\t\t\t\tby=cy;\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tlong long sx,sy,tx,ty;\n\t\t\t\tint type,z;\n\t\t\t\tscanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n\t\t\t\ttype^=z;\n\t\t\t\tif(tx!=sx){\n\t\t\t\t\tdouble Y=(double)((ax-sx)*(ty-sy)+sy*(tx-sx))/(tx-sx);\n\t\t\t\t\tif((double)ay<Y&&Y<(double)by){\n\t\t\t\t\t\tdat[now++]=make_pair(Y,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tlong long sx,sy,tx,ty;\n\t\t\t\tint type,z;\n\t\t\t\tscanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n\t\t\t\ttype^=z;\n\t\t\t\tif((bx-ax)*(ty-sy)-(tx-sx)*(by-ay)!=0){\n\t\t\t\t\tdouble X=(double)((tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty))/((bx-ax)*(ty-sy)-(tx-sx)*(by-ay));\n\t\t\t\t\tif((double)ax<X&&X<(double)bx){\n\t\t\t\t\t\tdat[now++]=make_pair(X,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(dat,dat+now);\n\t\tint val=dat[0].second;\n\t\tint ret=0;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tif(dat[i].second!=val){\n\t\t\t\tret++;\n\t\t\t\tval=dat[i].second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<complex>\n#include<assert.h>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int yy;\n  cin >> yy;\n  REP(k,yy){\n    double a,b,c,d;\n    cin >> a >> b >> c >> d;\n    P f,t;\n    f = P(a,b);\n    t = P(c,d);\n    L one = L(f,t);\n    ll n;\n    cin >> n;\n    vector <L> l;\n    vector <ll> o;\n    vector <ll> r;\n    REP(i,n){\n      double s2,s1,t1,t2;\n      ll o1,r1;\n      cin >> s1 >> s2 >> t1 >> t2 >> o1 >> r1;\n      f = P(s1,s2);\n      t = P(t1,t2);\n      L te = L(f,t);\n      o.pb(o1);\n      r.pb(r1);\n      l.pb(te);\n    }\n    ll index = 0;\n    P com = P(-1000,-1000);\n    vector <P> crossp;\n    REP(i,l.size()){\n      P comp;\n      if(intersectSS(one,l[i])){\n\tcomp = crosspoint(one,l[i]);\n\tcrossp.pb(comp);\n      }\n      \n      \n    }\n    sort(crossp.begin(),crossp.end());\n    \n    ll fl = 1;\n    \n    /*REP(i,crossp.size())\n      cout << crossp[i].real() << \"  \" << crossp[i].imag() << endl; \n    */\n    ll cnt = 0,cnt2 = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    index = 0;\n    fl = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt2++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt2++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    cout << min(cnt,cnt2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst double EPS = 1e-10;\n\ndouble intersect(double xa, double ya, double xb, double yb, double xc, double yc, double xd, double yd){\n    double g =  (xb - xa)*(yd - yc) - (yb - ya)*(xd - xc);\n    if (fabs(g) < EPS) return -1;\n    return ((yd - yc)*(xc - xa) - (xd - xc)*(yc - ya)) / g;\n}\n\nint calc(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int n;\n    cin >> n;\n    vector<pair<double, int> > a;\n    while (n--){\n        double xs, ys, xt, yt;\n        int p, q;\n        cin >> xs >> ys >> xt >> yt >> p >> q;\n        double r = intersect(xa, ya, xb, yb, xs, ys, xt, yt);\n        if (r > 0 && r < 1){\n            a.push_back(make_pair(r, p^q));\n        }\n    }\n    if (a.size() <= 1) return 0;\n    int ans = 0;\n    REP(i,a.size()-1){\n        if (a[i].second != a[i+1].second) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int m;\n    cin >> m;\n    while (m--){\n        cout << calc() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL() {}\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n\n\n\n\n\nL ab;\nint n;\nL st[100];\nint o[100], l[100];\n\nvoid init()\n{\n\tdouble x, y;\n\n\tcin >> x >> y; P a(x, y);\n\tcin >> x >> y; P b(x, y);\n\tab = L(a, b);\n\n\tcin >> n;\n\n\trep(i, 0, n)\n\t{\n\t\tcin >> x >> y; P s(x, y);\n\t\tcin >> x >> y; P t(x, y);\n\t\tst[i] = L(s, t);\n\t\tcin >> o[i] >> l[i];\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(_dn, 0, dn)\n\t{\n\t\tinit();\n\t\t\n\t\tvector<pair<double, int> > v;\n\t\trep(i, 0, n)\n\t\t{\n\t\t\tif (!intersectSS(ab, st[i])) continue;\n\t\t\t\n\t\t\tP c = crosspoint(ab, st[i]);\n\t\t\tdouble d = abs(c - ab[0]);\n\n\t\t\tint p;\n\t\t\tif (o[i] == 0)\n\t\t\t\tp = 1 - l[i];\n\t\t\telse\n\t\t\t\tp = l[i];\n\n\t\t\tv.push_back(make_pair(d, p));\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tint ans = 0;\n\t\trep(i, 0, v.size() - 1)\n\t\t{\n\t\t\tif (v[i].second != v[i + 1].second) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nstruct point {\n    double x, y;\n    point() {}\n    point(double x, double y): x(x), y(y) {}\n\n    point operator + (const point& o) const { return point(x+o.x, y+o.y); }\n    point operator - (const point& o) const { return point(x-o.x, y-o.y); }\n    point operator * (const double a) const { return point(x*a, y*a); }\n    bool operator < (const point& o) const { return x == o.x ? y < o.y : x < o.x; }\n};\n\ndouble abs(point p) {\n    return sqrt(p.x*p.x + p.y*p.y);\n}\n\ndouble dot(point a, point b) { return a.x*b.x + a.y*b.y; }\n\ndouble cross(point a, point b) {\n    return a.x*b.y - a.y*b.x;\n}\n\nbool has_intersect(point l1a, point l1b, point l2a, point l2b) {\n    double c1a = cross(l1b - l1a, l2a - l1a), c1b = cross(l1b - l1a, l2b - l1a);\n    double c2a = cross(l2b - l2a, l1a - l2a), c2b = cross(l2b - l2a, l1b - l2a);\n\n    return c1a * c1b < 0 && c2a * c2b < 0;\n}\n\npoint intersect(point l1a, point l1b, point l2a, point l2b) {\n    assert(has_intersect(l1a, l1b, l2a, l2b));\n\n    double c1 = abs(cross(l2b - l2a, l1a - l2a));\n    double c2 = abs(cross(l2b - l2a, l1b - l2a));\n\n    return l1a + (l1b - l1a) * (c1 / (c1 + c2));\n}\n\nstruct railroad {\n    point a, b;\n    int owner;\n    int loc;\n    railroad() {}\n};\n\nint N;\nrailroad W;\nvector<railroad> Ls;\n\nint solve() {\n    vector<pair<point, int>> ps;\n    for (int i = 0; i < N; ++i) {\n        if (has_intersect(W.a, W.b, Ls[i].a, Ls[i].b))\n            ps.emplace_back(intersect(W.a, W.b, Ls[i].a, Ls[i].b), i);\n    }\n\n    if (ps.size() == 0) return 0;\n\n    sort(begin(ps), end(ps));\n\n    int h = (Ls[ps[0].second].owner == 1) ? Ls[ps[0].second].loc : (1 - Ls[ps[0].second].loc);\n    int ans = 0;\n    for (auto pr : ps) {\n        railroad r = Ls[pr.second];\n        if (h != (r.owner == 1 ? r.loc : 1 - r.loc)) {\n            ++ans;\n            h = 1 - h;\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    int T; cin >> T;\n    W.owner = 1;\n    for (int i = 0; i < T; ++i) {\n        cin >> W.a.x >> W.a.y >> W.b.x >> W.b.y >> N;\n        Ls.resize(N);\n        for (int j = 0; j < N; ++j)\n            cin >> Ls[j].a.x >> Ls[j].a.y >> Ls[j].b.x >> Ls[j].b.y\n                >> Ls[j].owner >> Ls[j].loc;\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(double& x, double& y, int xo, int yo, int dx, int dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tdouble r = sqrt((double)dx * dx + dy * dy);\n\tx = _x * dx / r + _y * dy / r;\n\ty = _y * dx / r - _x * dy / r;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < -EPS || x > sqrt((double)dx * dx + dy * dy) + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dist(P a, P b) {\n\treturn (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\tif (EQ(d2, 0))return P(INF, INF);\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tL N(A, B);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb t0, pbb t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\n\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\n  \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nint main(){\n  int N;\n  cin >> N;\n  double x_s, y_s, x_t, y_t;\n  for(int i = 0; i < N; ++i){\n    cin >> x_s >> y_s >> x_t >> y_t;\n    P a = P(x_s,y_s), b = P(x_t, y_t);\n    L S = L(a,b);\n    int n, o, l;\n    cin >> n;\n    vector<pair<P,int> > cp;\n    for(int i = 0; i < n; ++i){\n      cin >> x_s >> y_s >> x_t >> y_t >> o >> l;\n      L T = L(P(x_s,y_s),P(x_t,y_t));\n      if(is_cross(S,T))\n\tcp.push_back(make_pair(intersection(S,T),o^l));\n    }\n    sort(cp.begin(),cp.end());\n    int t = cp[0].second, ans = 0;\n    for(int i = 1; i < (int)cp.size(); ++i){\n      if(t != cp[i].second){\n\t++ans;\n\tt = cp[i].second;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<(EPS)\n\ntypedef pair<pair<double, double>, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      double ll=min(x1,x2), rr=max(x1,x2);\n      double bb=min(y1,y2), tt=max(y1,y2);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      if(EQ(xa,xb)){\n\tdouble d2 = (y1-y2)/(x1-x2);\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n\tdouble d1 = (ya-yb)/(xa-xb);\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n\tdouble d1 = (ya-yb)/(xa-xb);\n\tdouble d2 = (y1-y2)/(x1-x2);\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\t//assert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS &&\n\t  nx-ll>-EPS &&rr-nx>-EPS && ny-bb>-EPS&&tt-ny>-EPS){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(mp(nx,ny), (o==l)));\n      }\n    }\n\n    sort(all(points));\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n// variable update\ninline void modAdd(int& _a, int _b, int _m) { _a = (_a + _b) % _m; }\ninline void modAdd(lint& _a, lint _b, lint _m) { _a = (_a + _b) % _m; }\ninline void minUpdate(int& _a, int _b) { _a = min(_a, _b); }\ninline void minUpdate(lint& _a, lint _b) { _a = min(_a, _b); }\ninline void maxUpdate(int& _a, int _b) { _a = max(_a, _b); }\ninline void maxUpdate(lint& _a, lint _b) { _a = max(_a, _b); }\n\n// Point & Vector\ntypedef struct Point {\n\tDouble x, y;\n\tint type;\n\tPoint() {}\n\tPoint(Double _x, Double _y) : x(_x), y(_y) {}\n} Vector;\n// operator\nPoint operator + (const Point& _a, const Point& _b) { return Point(_a.x + _b.x, _a.y + _b.y); }\nPoint operator - (const Point& _a, const Point& _b) { return Point(_a.x - _b.x, _a.y - _b.y); }\nPoint operator * (const Point& _a, const Point& _b) { return Point(_a.x * _b.x, _a.y * _b.y); }\nPoint operator / (const Point& _a, const Point& _b) { return Point(_a.x / _b.x, _a.y / _b.y); }\nPoint operator * (const Point& _a, Double _b) { return Point(_a.x * _b, _a.y * _b); }\nPoint operator / (const Point& _a, Double _b) { return Point(_a.x / _b, _a.y / _b); }\nbool operator < (const Point& _a, const Point& _b) { return _a.x != _b.x ? _a.x < _b.x : _a.y < _b.y; }\nbool operator > (const Point& _a, const Point& _b) { return _b < _a; }\nbool operator == (const Point& _a, const Point& _b) { return fabs(_a.x - _b.x) < EPS && fabs(_a.y - _b.y) < EPS; }\n\n//\nDouble norm(const Point& _a) { return _a.x * _a.x + _a.y * _a.y; }\nDouble abs(const Point& _a) { return sqrt(norm(_a)); }\nDouble dot(const Vector& _a, const Vector& _b) { return _a.x * _b.x + _a.y * _b.y; }\nDouble cross(const Vector& _a, const Vector& _b) { return _a.x * _b.y - _a.y * _b.x; }\n\n//\nint ccw(const Point& _a, const Point& _b, const Point&  _c) {\n\tVector ba = _b - _a, ca = _c - _a;\n\tif (cross(ba, ca) > EPS) return +1; // ccw\n\tif (cross(ba, ca) < -EPS) return -1; // cw\n\tif (dot(ba, ca) < -EPS) return +2; // c-a-b\n\tif (abs(ba) + EPS < abs(ca)) return -2; // a-b-c\n\treturn 0; // a-c-b\n}\n\n// Line & Segment\ntypedef struct Line {\n\tPoint s, e;\n\tLine() {}\n\tLine(Point _s, Point _e) : s(_s), e(_e) {}\n} Segment;\n\n//\nbool is_cross(const Segment& _a, const Segment& _b) {\n\treturn (ccw(_a.s, _a.e, _b.s) * ccw(_a.s, _a.e, _b.e) <= 0\n\t\t\t&& ccw(_b.s, _b.e, _a.s) * ccw(_b.s, _b.e, _a.e) <= 0);\n}\n\n//\nPoint cross_point(const Line& _a, const Line& _b) {\n\tDouble d1 = cross(_b.e - _b.s, _b.s - _a.s);\n\tDouble d2 = cross(_b.e - _b.s, _a.e - _a.s);\n\treturn _a.s + (_a.e - _a.s) * d1 / d2;\n}\n\nSegment ab;\nint n;\nvector< Segment > segs;\nArray pos, type;\n\nvoid solve() {\n\tvector< Point > vp;\n\t\n\tfor_(i,0,n) {\n\t\tif (!is_cross(ab, segs[i])) continue;\n\t\t\n\t\tPoint p = cross_point(ab, segs[i]);\n\t\t\n\t\tif (pos[i]) p.type = type[i];\n\t\telse p.type = 1 - type[i];\n\t\t\n\t\tvp.push_back(p);\n\t}\n\t\n\tsort(allof(vp));\n\t\n\tint ans = 0;\n\tint v_size = size_of(vp);\n\t\n\tfor_(i,0,v_size-1) if (vp[i].type != vp[i + 1].type) ++ans;\n\tcout << ans << endl;\n}\n\nint main() {\n\tint CASE; cin >> CASE;\n\t\n\tfor_(c,0,CASE) {\n\t\tsegs.clear();\n\t\tpos.clear();\n\t\ttype.clear();\n\t\t\n\t\tDouble xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n\t\tab = Segment(Point(xa, ya), Point(xb, yb));\n\t\t\n\t\tcin >> n;\n\t\tfor_(i,0,n) {\n\t\t\tDouble xs, ys, xe, ye;\n\t\t\tint o, l;\n\t\t\tcin >> xs >> ys >> xe >> ye >> o >> l;\n\t\t\tsegs.push_back(Segment(Point(xs, ys), Point(xe, ye)));\n\t\t\tpos.push_back(o);\n\t\t\ttype.push_back(l);\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\npair<double, double> getkouten(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)\n{\n    if(x1 - x2 == 0){\n        if(x3 - x4 == 0){\n            return make_pair(100000.0, 1000000.0);\n        } else {\n            return make_pair(x1, (y3 - y4) / (x3 - x4) * x1 + (y4 * x3 - x4 * y3) / (x3 - x4));\n        }\n    } else {\n        if(x3 - x4 == 0){\n            return make_pair(x3, (y1 - y2) / (x1 - x2) * x3 + (y2 * x1 - x2 * y1) / (x1 - x2));\n        } else {\n            if((x3 - x4) * (y1 - y2) - (x1 - x2) * (y3 - y4) == 0){\n                return make_pair(100000.0, 100000.0);\n            } else {\n                double x = (double)(((y4 * x3) - (x4 * y3)) * (x1 - x2) - ((y2 * x1) - (x2 * y1)) * (x3 - x4)) / ((x3 - x4) * (y1 - y2) - (x1 - x2) * (y3 - y4));\n                return make_pair(x, (y3 - y4) / (x3 - x4) * x + (y4 * x3 - x4 * y3) / (x3 - x4));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n        double xa, ya, xb, yb, n;\n        cin >> xa >> ya >> xb >> yb >> n;\n        double xs[101], ys[101], xt[101], yt[101], o, l;\n        vector<pair<pair<double, double>, int> >  kouten;\n        int shouldupper[101];\n        for(int j = 0; j < n; j++){\n            cin >> xs[j] >> ys[j] >> xt[j] >> yt[j] >> o >> l;\n            if((o == 1 && l == 1) || (o == 0 && l == 0)) shouldupper[j] = 1;\n            else shouldupper[j] = 0;\n        }\n        for(int j = 0; j < n; j++){\n            pair<double, double> ans = getkouten(xa, ya, xb, yb, xs[j], ys[j], xt[j], yt[j]);\n            // cout << ans.first << \" \" << ans.second << endl;\n            if(ans.first <= max(xa, xb) && ans.first >= min(xa, xb)) kouten.push_back(make_pair(ans, shouldupper[j]));\n        }\n        // cout << kouten.size() << endl;\n        sort(kouten.begin(), kouten.end());\n\n        int now = kouten[0].second, result = 0;\n        // cout << \"ho\" << endl;\n        for(int j = 1; j < kouten.size(); j++){\n            // cout << (kouten[j].first).first << \" \" << (kouten[j].first).second << endl;\n            if(kouten[j].second != now){\n                result++;\n                now = kouten[j].second;\n            }\n        }\n        cout << result << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nusing namespace std;\nvector<pair<pair<double,double>,bool> > cp;\npair<double,double> relv(pair<double,double> a,pair<double,double> b)\n{\n  return make_pair(a.first-b.first,a.second-b.second);\n}\ndouble cross(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.second-va.second*vb.first;\n}\nvoid crosspoint(pair<double,double> a,pair<double,double> b,pair<double,double> c,pair<double,double> d,bool e)\n{\n  auto ab=relv(a,b),cd=relv(c,d);\n  if(!(cross(ab,relv(a,c))*cross(ab,relv(a,d)) < 0 &&\n       cross(cd,relv(c,a))*cross(cd,relv(c,b)) < 0)) return;\n  double midrat=cross(cd,relv(c,a))/(cross(cd,relv(c,a))+cross(cd,relv(b,d)));\n  cp.push_back(make_pair(make_pair(a.first+midrat*ab.first,a.second+midrat*ab.second),e));\n}\n\nint main(void)\n{\n  cout << fixed << setprecision(10) << endl;\n  int n;\n  cin >> n;\n  REP(i,n){\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    pair<double,double> s,e;\n    s=make_pair(sx,sy),e=make_pair(ex,ey);\n    cp.clear();\n    int m;\n    cin >> m;\n    REP(i,m){\n      int x[2],y[2],p,q;\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> p >> q;\n      crosspoint(s,e,make_pair(x[0],y[0]),make_pair(x[1],y[1]),p==q);\n    }\n    SORT(cp);\n    int answer=0;\n    REP(i,cp.size()-1) if(cp[i].second!=cp[i+1].second) ++answer;\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nstruct Point{double high,x,y;};\n\nbool Intersection(Point p1,Point p2,Point p3,Point p4,Point *ret){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(d==0 || u<0 || u>1 || v<0 || v>1)return false;\n    ret->x = p1.x+u*(p2.x-p1.x);\n    ret->y = p1.y+u*(p2.y-p1.y);\n    return true;\n}\n\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n            Point ret={o==l};\n            if(Intersection(a,b,s,t,&ret)){\n                cross.push_back(ret);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, double xo, double yo, double dx, double dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tdouble dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n    double x, y;\n    int id;\n    point (): x(0), y(0), id(0) {}\n\n    point(double a, double b): x(a), y(b), id(-1) {}\n    point(double a, double b, int c): x(a), y(b), id(c) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.y;\n    }\n\n    bool operator > (const point& o) const {\n        return x == o.x ? y > o.y : x > o.y;\n    }\n};\n\ndouble put (point p, point l1, point l2) {\n    double a = l1.y - l2.y, b = l2.x - l1.x, c = l1.x*l2.y - l2.x*l1.y;\n    return a * p.x + b * p.y + c;\n}\n\npoint intersect(point k1, point k2, point l1, point l2) {\n    double sig = put(k1, l1, l2) > 0 ? 1 : -1;\n    double x1 = k1.x, y1 = k1.y,   x2 = k2.x, y2 = k2.y;\n    for (int j = 0; j < 500; ++j) {\n        double mid_x = (x1 + x2) / 2, mid_y = (y1 + y2) / 2;\n        double val = put(point(mid_x, mid_y), l1, l2);\n        if (abs(val)  < EPS) {\n            return point(mid_x, mid_y);\n        } else if (val * sig > 0) {\n            x1 = mid_x, y1 = mid_y;\n        } else {\n            x2 = mid_x, y2 = mid_y;\n        }\n    }\n    return point(x1, x2);\n}\n\nbool cross(point k1, point k2, point l1, point l2) {\n    bool b1 = put(k1, l1, l2) * put(k2, l1, l2) < 0;\n    bool b2 = put(l1, k1, k2) * put(l2, k1, k2) < 0;\n    return b1 && b2;\n}\n\nint xa, ya, xb, yb, N;\npoint s[1000], t[1000];\nint   o[1000], l[1000];\n\nint solve() {\n    point start(xa, ya), goal(xb, yb);\n    vector<point> itss;\n    for (int j = 0; j < N; ++j) if (cross(start, goal, s[j], t[j])) {\n        point it = intersect(start, goal, s[j], t[j]);\n        it.id = j;\n        itss.push_back(it);\n    }\n\n    sort(begin(itss), end(itss));\n    if (start > goal) reverse(begin(itss), end(itss));\n\n    int ret = 0, height = -1;\n    for (const point& it : itss) {\n        int id = it.id;\n        int expected = o[id] == 1 ? l[id] : 1-l[id];\n        if (height == -1) {\n            height = expected;\n        } else if (height != expected) {\n            ++ret;\n            height = expected;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            cin >> s[j].x >> s[j].y >> t[j].x >> t[j].y >> o[j] >> l[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(double x = 0, double y = 0) :x(x), y(y) {};\n\n\tpoint operator + (point p) { return point(x + p.x, y + p.y); }\n\tpoint operator - (point p) { return point(x - p.x, y - p.y); }\n\tpoint operator * (double s) { return point(x * s, y * s); }\n\tpoint operator / (double s) { return point(x / s, y / s); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const point &p) const\n\t{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const point &p) const\n\t{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\ntypedef vector<point> polygon;\n\ndouble dot(point a, point b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(point a, point b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(point a, point b, point c)\n{\n\tb = b - a; c = c - a;\n\tif (cross(b, c) > EPS) return 1;\n\tif (cross(b, c) < -EPS) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (b.norm() < c.norm()) return -2;\n\treturn 0;\n}\n\nstruct line\n{\n\tpoint a, b;\n\tline(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0) :a(point(x1, y1)), b(point(x2, y2)) {};\n\n\tpoint univec() { return (b - a) / (b - a).norm(); }\n};\n\npoint cross_point(line s1, line s2)\n{\n\tpoint sv = s1.b - s1.a;\n\tpoint tv = s2.b - s2.a;\n\treturn s1.a + sv*cross(tv, s2.a - s1.a) / cross(tv, sv);\n}\nbool isis_ss(line s, line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tline sin(xa, ya, xb, yb);\n\t\tint k;\n\t\tcin >> k;\n\t\tvector<pair<double, int>> v;\n\t\tREP(i, k)\n\t\t{\n\t\t\tdouble xs, ys, xt, yt; int o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tline den(xs, ys, xt, yt);\n\t\t\tif (isis_ss(sin, den))\n\t\t\t{\n\t\t\t\tpoint cp = cross_point(sin, den);\n\t\t\t\tv.push_back(make_pair((cp - point(xa, ya)).norm(), o^l));\n\t\t\t}\n\t\t}\n\t\tsort(ALL(v));\n\t\tint cnt = 0;\n\t\tif (v.size() != 0)\n\t\t{\n\t\t\tint tmp = v[0].second;\n\t\t\tREP(i, v.size())\n\t\t\t{\n\t\t\t\tif (v[i].second != tmp)\n\t\t\t\t{\n\t\t\t\t\tcnt++;\n\t\t\t\t\ttmp = v[i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : VP{\n    L(const P& a, const P& b){ resize(2); at(0)=a; at(1)=b; }\n    L(){ resize(2); }\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X, b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //counter clockwise\n    if(cross(b,c) <-EPS) return -1; //clockwise\n    if(dot(b,c) < EPS) return +2; //c-a-b\n    if(norm(b) < norm(c)) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& s, const L& t){\n    return ( ccw(s[0],s[1],t[0]) *ccw(s[0],s[1],t[1]) <= 0 ) &&\n        ( ccw(t[0],t[1],s[0]) *ccw(t[0],t[1],s[1]) <= 0 );\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B /A *(m[1]-m[0]);\n}\n\n\nint main(){\n  int num;\n  cin >> num;\n  for(int rep=0; rep<num; rep++){ \n    int xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int n;\n    cin >> n;\n    L mine(P(xa,ya), P(xb,yb));\n\n    vector<pair<P, int> > cp;\n    for(int i=0; i<n; i++){\n      int xs,ys,xt,yt, o,l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L line(P(xs, ys), P(xt,yt));\n      if(intersectSS(mine, line)){\n        cp.push_back(make_pair(crosspointLL(mine, line), o^l));\n      }\n    }\n    sort(cp.begin(), cp.end());\n\n    int ans=0;;\n    for(int i=0; i<(int)cp.size()-1; i++){\n      if(cp[i].second != cp[i+1].second){\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-10)\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y):x(x),y(y){}\n  Point operator+(Point p){return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  int o,l;\n  Point c;\n  double x;\n  bool operator<(const Segment &s)const{\n    return x < s.x;\n  }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\n\n\ndouble dot(Vector a,Vector b){\n  return a.x*b.y+a.y*b.x;\n}\n\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS ) return CLOCKWISE;\n  if(dot(a,b) < -EPS ) return ONLINE_BACK;\n  if(norm(a) < norm(b) ) return ONLINE_FRONT;\n  \n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1, Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1 / (d1+d2);\n  return s1.p1 + (s1.p2-s1.p1) * t;\n}\n\nint main(){\n  int t;cin >> t;\n  while(t--){\n    Segment r;\n    cin >> r.p1.x >> r.p1.y >> r.p2.x >> r.p2.y;\n    int n;cin>>n;\n    int i,j,k;\n    vector<Segment> vs;vs.clear();\n    Segment seg;\n    for(i=0;i<n;i++){\n      cin >> seg.p1.x >> seg.p1.y >> seg.p2.x >> seg.p2.y >> seg.o >> seg.l;\n      if(intersect(r,seg)) {\n\tseg.x = abs(getCrossPoint(r,seg)-r.p1);\n\tvs.push_back(seg);\n      }\n    }\n    sort(vs.begin(),vs.end());\n    int num = vs.size();\n    //cout << num << endl;\n    //for(i=0;i<num;i++) cout << vs[i].x << endl;\n\n    int inf = 1 << 20;\n    int o = inf;\n    \n    int dp[105][2]={{}};\n    fill(dp[0],dp[105],inf);\n    \n    dp[0][0]=0;dp[0][1]=0;\n\n    for(i=0;i<num;i++){\n      if(vs[i].o==1&&vs[i].l==0){\n\tdp[i+1][0] = min(dp[i][0],dp[i][1]+1);\n      }else if(vs[i].o==1&&vs[i].l==1){\n\tdp[i+1][1] = min(dp[i][0]+1,dp[i][1]);\n      }else if(vs[i].o==0&&vs[i].l==0){\n\tdp[i+1][1] = min(dp[i][0]+1,dp[i][1]);\n      }else if(vs[i].o==0&&vs[i].l==1){\n\tdp[i+1][0] = min(dp[i][0],dp[i][1]+1);\n      }\n      \n    }\n    o=min(dp[num][0],dp[num][1]);\n    cout << o << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <complex>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\nusing namespace std;\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c)>0) return 1;\n\tif(cross(b, c)<0) return -1;\n\tif(dot(b, c)<0) return 2;\n\tif(norm(b)<norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersect(const P& a1, const P& a2, const P& b1, const P& b2) {\n\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t\t&& ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n}\n\nP crosspoint(const P& a1, const P& a2, const P& b1, const P& b2) {\n\tdouble a = cross(a2-a1, b2-b1);\n\tdouble b = cross(a2-a1, a2-b1);\n\treturn b1 + b/a*(b2-b1);\n}\n\nint main()\n{\n\tint Q;\n\tscanf(\"%d\", &Q);\n\trep(q, Q) {\n\t\tint xa, ya, xb, yb;\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tP s(xa, ya), e(xb, yb);\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tvector<pair<double, int> > v;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tscanf(\"%d%d%d%d%d%d\", &xs, &ys, &xt, &yt, &o, &l);\n\t\t\tP cs(xs, ys), ce(xt, yt);\n\t\t\tint k = (o==l) ? 1 : 0;\n\t\t\tif(intersect(s, e, cs, ce)) {\n\t\t\t\tdouble d = abs(s-crosspoint(s, e, cs, ce));\n\t\t\t\tv.push_back(make_pair(d, k));\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint c=0;\n\t\tfor(int i=1; i<(int)v.size(); i++) {\n\t\t\tif(v[i].second!=v[i-1].second) c++;\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y =\n      (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // // xはチェック済み\n    // if (b < d) {\n    //   if (!(b <= cross_y && cross_y <= d)) return false;\n    // } else {\n    //   if (!(d <= cross_y && cross_y <= b)) return false;\n    // }\n    // if (f < h) {\n    //   if (!(f <= cross_y && cross_y <= h)) return false;\n    // } else {\n    //   if (!(h <= cross_y && cross_y <= f)) return false;\n    // }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n         << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y =\n      (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\t\t     \n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define MOD 1000000007\n\ntypedef complex<double> P;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n// ??????(dot product) : ab = |a||b|cos theta\ndouble dot(P a, P b)\n{\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????(cross product) : axb = |a||b|sin theta\ndouble cross(P a, P b)\n{\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´?????????  dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2)\n{\n  return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n// 2??´?????????????????? cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2)\n{\n  return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// ???c?????´???a,b????????????????????????\nint is_point_on_line(P a, P b, P c)\n{\n  return EQ(cross(b-a, c-a), 0.0);\n}\n\n// ???c?????????a,b????????????????????????\nint is_point_on_line_seg(P a, P b, P c)\n{\n  // |a - c| + |c - b| <= |a - b|???????????????\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c)\n{\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c)\n{\n  if(dot(b-a, c-a) < EPS) return abs(c-a);\n  if(dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2, double c)\n{\n  return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < c) &&\n    (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2)\n{\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2 - a1) * t;\n}\n\ntypedef pair< P, pi > S;\n\nbool comp(const S& ls, const S& rs)\n{\n  P l = ls.first, r = rs.first;\n  return l.real()==r.real()?l.imag()<r.imag():l.real()<r.real();\n}\n\nint in[8];\n\nint solve()\n{\n  rep(i, 4) cin >> in[i];\n  P a(in[0], in[1]), b(in[2], in[3]);\n  int N;\n  cin >> N;\n  vector<S>V;\n  rep(i, N){\n    rep(j,6) cin >> in[j];\n    P c(in[0], in[1]), d(in[2], in[3]);\n    if(is_intersected_ls(a, b, c, d, EPS)){\n      P p = intersection_ls(a, b, c, d);\n      V.push_back(make_pair(p, pi(in[4], in[5])));\n    }\n  }\n  if(V.size() == 0) return 0;\n  sort(V.begin(), V.end(), comp);\n  int res = 0;\n  int pos = (~(V[0].second.first^V[0].second.second))&1;\n  for(int i=1;i<V.size();i++){\n    int o = V[i].second.first, l = V[i].second.second;\n    res += (pos!=((~(o^l))&1));\n    pos = (~(o^l))&1;\n  }\n  return res;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  rep(i, T)\n    cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nusing Real = double;\nusing Point = complex<Real>;\nconst Real EPS = 1e-8;\n\nstruct Circle {\n    Point p;\n    Real r;\n    Circle() :p(Point(0, 0)), r(0) {}\n    Circle(Point _p, Real _r) :p(_p), r(_r) {}\n};\n\nusing Points = vector<Point>;\nusing Circles = vector<Circle>;\n\nbool eq(Real a, Real b) { return abs(a - b) < EPS; }\n\nint intersect(Circle c1, Circle c2) {\n    if (c1.r < c2.r) swap(c1, c2);\n    Real d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d) return 4;\n    if (eq(c1.r + c2.r, d)) return 3;\n    if (c1.r - c2.r < d) return 2;\n    if (eq(c1.r - c2.r, d)) return 1;\n    return 0;\n}\n\npair<Point, Point> crosspoint(Circle& c1, Circle& c2) {\n    Real d = abs(c1.p - c2.p);\n    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    Real t = arg(c2.p - c1.p);\n    Point p1 = c1.p + polar(c1.r, t + a);\n    Point p2 = c1.p + polar(c1.r, t - a);\n    return { p1, p2 };\n}\n\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if (eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n};\n\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\n\n\nReal cross(const Point& a, const Point& b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point& a, const Point& b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n    if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n    return 0;                         // \"ON_SEGMENT\"\n}\n\nbool intersect(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint crosspoint(const Line& l, const Line& m) {\n    Real A = cross(l.b - l.a, m.b - m.a);\n    Real B = cross(l.b - l.a, l.b - m.a);\n    if (eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n}\n\nbool intersect(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\n\n\nPoint crosspoint(const Segment& l, const Segment& m) {\n    return crosspoint(Line(l), Line(m));\n}\n\nvoid solve() {\n    Real xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n    Segment seg(Point(xa, ya), Point(xb, yb));\n    vector<Points> vp(2);\n    if (seg.a.real() > seg.b.real()) swap(seg.a, seg.b);\n    int n; cin >> n;\n    for (int i = 0; i < n; i++) {\n        int xa, ya, xb, yb, f, t;\n        cin >> xa >> ya >> xb >> yb >> f >> t;\n        Segment s(Point(xa, ya), Point(xb, yb));\n        if (intersect(s, seg)) {\n            if (f) {\n                if (t) vp[0].push_back(crosspoint(s, seg));\n                else vp[1].push_back(crosspoint(s, seg));\n            }\n            else {\n                if (t) vp[1].push_back(crosspoint(s, seg));\n                else vp[0].push_back(crosspoint(s, seg));\n            }\n        }\n    }\n    sort(vp[0].begin(), vp[0].end(), [&](auto a, auto b) { return a.real() < b.real(); });\n    sort(vp[1].begin(), vp[1].end(), [&](auto a, auto b) { return a.real() < b.real(); });\n    int d = 0, u = 0;\n    int pre = -1;\n    int res = 0;\n\n    while (d < vp[0].size() or u < vp[1].size()) {\n        if (d < vp[0].size() and (vp[1].size() == u or vp[0][d].real() < vp[1][u].real())) {\n            if (pre == 1) res++;\n            pre = 0;\n            d++;\n        }\n        else {\n            if (pre == 0) res++;\n            pre = 1;\n            u++;\n        }\n    }\n    cout << res << endl;\n}\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint q; cin >> q; while (q--) solve();\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n#define S first\n#define T second\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dist(P a, P b) {\n\treturn (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);\n}\nbool isPointOnLine(P a, P b, P c) {\n\treturn abs(a - c) + abs(c - b) < abs(a - b) + EPS;\n}\n\n//????????¨?????????????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d2, 0))return P(INF, INF);\n\tP ret = a1 + d1 / d2 * (a2 - a1);\n\tif (isPointOnLine(b1, b2, ret) && isPointOnLine(a1, a2, ret)) {\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn P(INF, INF);\n\t}\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb &t0, pbb &t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dist(P a, P b) {\n\treturn sqrt((a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y));\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\tif (EQ(d2, 0))return P(INF, INF);\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tL N(A, B);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb t0, pbb t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L:public vector<P> {\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\n\ndouble dot(P a, P b) {\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return dot(P(-a.imag(),a.real()),b);\n}\n\n#define EPS 1.0e-5\n\nint ccw(P a, P b, P c) {\n  b-=a; c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool hit(const L& s, const L& t) {\n  return ccw(s[0],t[0],s[1])*ccw(s[0],t[1],s[1])<=0;\n}\n\nbool same(const L& s, const L& t) {\n  return abs((s[1]-s[0]).real()*(t[1]-t[0]).imag()-(s[1]-s[0]).imag()*(t[1]-t[0]).real())<=EPS;\n}\n\ndouble crosslen(const L& s, const L& t) {\n  \n  P ab=s[1]-s[0], ac=t[0]-s[0], ad=t[1]-s[0];\n  ab/=norm(ab);\n  double lac=dot(ab,ac), lad=dot(ab,ad);\n  double dac=abs(ac-ab*lac), dad=abs(ad-ab*lad);\n  return (lac*dad+lad*dac)/(dad+dac);\n}\n\nstruct LINE {\n  L line;\n  int o,l;\n};\n\nstruct POINT {\n  LINE line;\n  double len;\n  bool uch;\n};\n\nbool comp (POINT a, POINT b) {\n  return a.len < b.len;\n}\n\nint main () {\n  int m;cin>>m;\n  while(m--){\n    vector<POINT> points;\n    vector<LINE> lines;\n    double xa,ya,xb,yb;cin>>xa>>ya>>xb>>yb;\n    int n;cin>>n;\n    L self(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;++i){\n      double a,b,c,d;int e,f;cin>>a>>b>>c>>d>>e>>f;\n      lines.push_back((LINE){L(P(a,b),P(c,d)),e,f});\n    }\n    for(int i=0;i<n;++i){\n      if(hit(self,lines[i].line)){\n\tif(same(self,lines[i].line)){\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[0]-self[0]),true});\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[1]-self[0]),true});\n\t}else{\n\t  points.push_back((POINT){lines[i],crosslen(self,lines[i].line)});\n\t}\n      }\n    }\n    sort(points.begin(),points.end(),comp);\n    vector<POINT> newpoints=points; points.clear();\n    int len=newpoints.size(); double srclen=abs(self[1]-self[0]);\n    if(len==0){cout<<0<<endl;continue;}\n    for(int i=0;i<len;++i){\n      if(newpoints[i].len>srclen)break;\n      points.push_back(newpoints[i]);\n    }\n    LINE line=points[0].line;\n    int precur,cur=0,result=0;bool ch=true;\n    if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n    for(int i=1;i<len;++i){\n      line=points[i].line;\n      if(points[i].uch)ch=true;\n      if(ch){\n\tprecur=cur; if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n\tif(precur!=cur){++result;}\n\tif(points[i].uch)ch=false;\n      }\n    }\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nstruct rail{\n\tint sx;\n\tint sy;\n\tint gx;\n\tint gy;\n};\n\ndouble cross(rail v1,rail v2){//?????????v1?????????????????????\n\tint cv1v2=(v1.gx - v1.sx)*(v2.gy - v2.sy) - (v1.gy - v1.sy)*(v2.gx - v2.sx);\n\tint cvv2 = (v2.sx - v1.sx)*(v2.gy - v2.sy) - (v2.sy-v1.sy)*(v2.gx - v2.sx);\n\tif (cv1v2 == 0)\n\t\treturn 0.0;\n\treturn (double)cvv2/(double)cv1v2;\n}\nstruct cross_t{\n\tint no;\n\tdouble dis;\n};\n\nbool operator < (const cross_t &left, const cross_t &right){\n\treturn left.dis < right.dis;\n};\nint main() {\n\tint dataset;\n\tcin >> dataset;\n\twhile (dataset--){\n\t\trail atob;\n\t\tcin >> atob.sx;\n\t\tcin >> atob.sy;\n\t\tcin >> atob.gx;\n\t\tcin >> atob.gy;\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<rail> vr(n);\n\t\tvector<bool> high_b(n);\n\t\tpriority_queue<cross_t> P;\n\t\tREP(i, n){\n\t\t\tcin >> vr[i].sx;\n\t\t\tcin >> vr[i].sy;\n\t\t\tcin >> vr[i].gx;\n\t\t\tcin >> vr[i].gy;\n\t\t\tint mine,high;\n\t\t\tcin >> mine;\n\t\t\tcin >> high;\n\t\t\thigh_b[i] = (mine == high);\n\t\t\tP.push({ i, cross(atob, vr[i]) });\n\t\t}\n\t\tbool b=false;\n\t\tint ans = 0;\n\t\tint ps = P.size();\n\t\tREP(i, ps){\n\t\t\tcross_t p = P.top();\n\t\t\tP.pop();\n\t\t\tif (i == 0){\n\t\t\t\tb = high_b[p.no];\n\t\t\t}else{\n\t\t\t\tif (b != high_b[p.no]){\n\t\t\t\t\tans++;\n\t\t\t\t\tb = high_b[p.no];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,int>dat[1000];\n//Y*(tx-sx)=(X-sx)*(ty-sy)+sy*(tx-sx)\n//Y*(bx-ax)=(X-ax)*(by-ay)+ay*(bx-ax)\n//X=ax\n//Y*(tx-sx)=(ax-sx)*(ty-sy)+sy*(tx-sx)\n//(bx-ax)*(X*(ty-sy)+sy*tx-sx*ty)=(tx-sx)*(X*(by-ay)+ay*bx-ax*by)\n//(bx-ax)*(ty-sy)*X+(bx-ax)*(sy*tx-sx*ty)=(tx-sx)*(by-ay)*X+(tx-sx)*(ay*bx-ax*by)\n//((bx-ax)*(ty-sy)-(tx-sx)*(by-ay))*X=(tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty)\nint main(){\n    int t;\n    scanf(\"%d\",&t);\n    while(t--){\n        long long ax,ay,bx,by;\n        scanf(\"%lld%lld%lld%lld\",&ax,&ay,&bx,&by);\n        int c;\n        if(ax>bx){\n            long long cx=ax;\n            ax=bx;\n            bx=cx;\n            long long cy=ay;\n            ay=by;\n            by=cy;\n        }\n        scanf(\"%d\",&c);\n        int now=0;\n        if(ax==bx){\n            if(ay>by){\n                long long cy=ay;\n                ay=by;\n                by=cy;\n            }\n            for(int i=0;i<c;i++){\n                long long sx,sy,tx,ty;\n                int type,z;\n                scanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n                type^=z;\n                if(tx!=sx&&!(sx>ax&&tx>ax)&&!(sx<ax&&tx<ax)){\n                    double Y=(double)((ax-sx)*(ty-sy)+sy*(tx-sx))/(tx-sx);\n                    if((double)ay<Y&&Y<(double)by){\n                        dat[now++]=make_pair(Y,type);\n                    }\n                }\n            }\n        }else{\n            for(int i=0;i<c;i++){\n                long long sx,sy,tx,ty;\n                int type,z;\n                scanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n                type^=z;\n                if((bx-ax)*(ty-sy)-(tx-sx)*(by-ay)!=0){\n                    double X=(double)((tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty))/((bx-ax)*(ty-sy)-(tx-sx)*(by-ay));\n                    if(sx==tx){\n                        double Y=(double)((sx-ax)*(by-ay)+ay*(bx-ax))/(bx-ax);\n                        if((double)sy<Y&&(double)ty<Y)continue;\n                        if((double)sy>Y&&(double)ty>Y)continue;\n                    }else{\n                        if((double)sx<X&&(double)tx<X)continue;\n                        if((double)sx>X&&(double)tx>X)continue;\n                    }\n                    if((double)ax<X&&X<(double)bx){\n            //          printf(\"%f \",X);\n                        dat[now++]=make_pair(X,type);\n                    }\n                }\n            }\n        }\n        std::sort(dat,dat+now);\n        int val=dat[0].second;\n        int ret=0;\n        for(int i=0;i<now;i++){\n            if(dat[i].second!=val){\n                ret++;\n                val=dat[i].second;\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<utility>\n#include<complex>\n#include<assert.h>\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int yy;\n  cin >> yy;\n  REP(k,yy){\n    double a,b,c,d;\n    cin >> a >> b >> c >> d;\n    P f,t;\n    f = P(a,b);\n    t = P(c,d);\n    L one = L(f,t);\n    ll n;\n    cin >> n;\n    vector <L> l;\n    vector <ll> o;\n    vector <ll> r;\n    REP(i,n){\n      double s2,s1,t1,t2;\n      ll o1,r1;\n      cin >> s1 >> s2 >> t1 >> t2 >> o1 >> r1;\n      f = P(s1,s2);\n      t = P(t1,t2);\n      L te = L(f,t);\n      o.pb(o1);\n      r.pb(r1);\n      l.pb(te);\n    }\n    ll index = 0;\n    P com = P(-1000,-1000);\n    vector <P> crossp;\n    REP(i,l.size()){\n      P comp;\n      if(intersectSS(one,l[i])){\n\tcomp = crosspoint(one,l[i]);\n\tcrossp.pb(comp);\n      }\n      \n      \n    }\n    sort(crossp.begin(),crossp.end());\n    \n    ll fl = 1;\n    \n    /*REP(i,crossp.size())\n      cout << crossp[i].real() << \"  \" << crossp[i].imag() << endl; \n    */\n    ll cnt = 0,cnt2 = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    index = 0;\n    fl = 0;\n    REP(j,crossp.size()){\n      REP(i,l.size()){\n\tif(intersectSP(l[i],crossp[j])){\n\t  index = i;\n\t}\n      }\n      \n      if(o[index] == 1 && r[index] == fl){\n\t\n      }\n      else if(o[index] == 1 && r[index] != fl){\n\tcnt2++;\n\tfl += 1;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else if(o[index] == 0 && r[index] == fl){\n\tcnt2++;\n\tif(fl == 2)\n\t  fl = 0;\n      }\n      else{\n\t\n      }\n    }\n    cout << min(cnt,cnt2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nint main(){\n  int T; cin>>T;\n  int xa,ya,xb,yb;\n  while(cin>>xa>>ya>>xb>>yb){\n    L newline(P(xa,ya),P(xb,yb));\n    vector< pair<P,int> > cps;\n    int n; cin>>n;\n    while(n--){\n      int x1,y1,x2,y2,o,l;\n      cin>>x1>>y1>>x2>>y2>>o>>l;\n      L ln(P(x1,y1),P(x2,y2));\n      if(intersectLL(newline, ln)){\n        cps.push_back(make_pair(crosspoint(newline,ln), o ^ l));\n      }\n    }\n    sort(cps.begin(), cps.end());\n\n    int ans = 0;\n    FOR(i,1,cps.size()){\n      if(cps[i].second != cps[i-1].second)ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef pair<P,bool> Q;\nD eps=1e-12;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool comp(const Q& xx,const Q& yy){\n\tP x=xx.fs,y=yy.fs;\n\tif(abs(x.real()-y.real())<eps){\n\t\treturn x.imag()<y.imag();\n\t}else{\n\t\treturn x.real()<y.real();\n\t}\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\tvector<Q> vc;\n\t\tD ax,ay,bx,by;\n\t\tint N;\n\t\tcin>>ax>>ay>>bx>>by>>N;\n\t\tL l=L(P(ax,ay),P(bx,by));\n\t\trep(i,N){\n\t\t\tD a,b,c,d;\n\t\t\tint e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tL s=L(P(a,b),P(c,d));\n\t\t\tif(iSS(l,s)){\n\t\t\t\tvc.pb(Q(intLL(l,s),e^f));\n\t\t\t}\n\t\t}\n\t\tif(vc.size()==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(vc),comp);\n\t\tint ans=0;\n\t\tbool now=vc[0].sc;\n\t\trep(i,vc.size()){\n\t\t\tif(now^vc[i].sc){\n\t\t\t\tans++;\n\t\t\t\tnow=vc[i].sc;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//XY座標\n#define X real()\n#define Y imag()\n\n// 許容する誤差ε\nconst double EPS = (1e-10);\n// 円周率\nconst double PI = 3.14159265358979;\n\nconst int INF = 1e+8;\n\n// 点の表現\ntypedef complex<double> P;\n\n// complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// 2乗する\ndouble sq(double x){\n\treturn x * x;\n}\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n// 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b){\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a){\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a){\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a){\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2 直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n\treturn equal( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点 c が直線 a, b 上にあるかどうか \nint is_point_on_line(P a, P b, P c) {\n\treturn equal( cross(b-a, c-a), 0.0 );\n}\n\n// 下記は (1) より (2) のほうが簡潔で良い.\n\n// 点 c が線分 a, b 上にあるかどうか (1)\nint is_point_on_line_1(P a, P b, P c) {\n  return equal( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点 c が線分 a, b 上にあるかないか(2)\nint is_point_on_line_2(P a, P b, P c) {\n\t// |a-c| + |c-b| <= |a-b| なら線分上\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点 a, bを通る直線と点 c との距離\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点 a, b を端点とする線分と点 c との距離\ndouble distance_ls_p(P a, P b, P c) {\n\tif( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\t\n\treturn a1 + (a2-a1) * t;\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n\treturn !equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n\tP a = a2 - a1; P b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nstruct Rail{\n\tP p1, p2;\n\tint o, l;\n\tRail(P p1_, P p2_, int o_, int l_){\n\t\tp1 = p1_; p2 = p2_; o = o_; l = l_;\n\t}\n};\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i_=0 ; i_ < N ; i_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa,ya), B(xb,yb);\n\t\t\n\t\tcin >> n;\n\t\tvector<Rail> vr;\n\t\tfor(int j_=0 ; j_ < n ; j_++ ){\n\t\t\tint sx,sy,tx,ty,o,l;\n\t\t\tcin >> sx >> sy >> tx >> ty >> o >> l;\n\t\t\tvr.push_back( Rail( P(sx,sy) , P(tx,ty) , o , l ) );\n\t\t}\n\t\t\n\t\t// 交点計算\n\t\tvector< pair< double , pair<P,pair<int,int> > > > vp;\n\t\tfor(int i=0 ; i < vr.size() ; i++ ){\n\t\t\t// 交差するかどうか\n\t\t\tif( is_intersected_ls( A , B , vr[i].p1 , vr[i].p2 ) ){\n\t\t\t\t// 交点\n\t\t\t\tP p = intersection_l( A , B , vr[i].p1 , vr[i].p2 );\n\t\t\t\t// 交点との距離\n\t\t\t\tdouble d = abs(A-p);\n\t\t\t\t// \n\t\t\t\tpair<int,int> p2( vr[i].o , vr[i].l );\n\t\t\t\tpair<P,pair<int,int> > p3( p , p2 );\n\t\t\t\tpair< double , pair<P,pair<int,int> > > p4(d,p3) ;\n\t\t\t\tvp.push_back( p4 );\n\t\t\t}\n\t\t}\n\t\tsort( vp.begin() , vp.end() );\n\t\t\n\t\tint ans = INF;\n\t\t// d=0 のとき地下, d=1 のとき高架\n\t\t{\n\t\t\tint d=0;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\tint o = vp[i].second.second.first;\n\t\t\t\tint l = vp[i].second.second.second;\n\t\t\t\t\n\t\t\t\t// o = 0 のとき他社\n\t\t\t\tif( o == 0 ){\n\t\t\t\t\tif( l == d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( l != d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"(\" << vp[i].first.X << \",\" << vp[i].second.Y << \")\" << endl;\n\t\t\t}\n\t\t\tans = min( ans , cnt );\n\t\t}\n\t\t{\n\t\t\tint d=1;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\tint o = vp[i].second.second.first;\n\t\t\t\tint l = vp[i].second.second.second;\n\t\t\t\t\n\t\t\t\t// o = 0 のとき他社\n\t\t\t\tif( o == 0 ){\n\t\t\t\t\tif( l == d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( l != d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"(\" << vp[i].first.X << \",\" << vp[i].second.Y << \")\" << endl;\n\t\t\t}\n\t\t\tans = min( ans , cnt );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dist(P a, P b) {\n\treturn (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);\n}\nbool isPointOnLine(P a, P b, P c) {\n\treturn abs(a - c) + abs(c - b) < abs(a - b) + EPS;\n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tP ret;\n\tif (EQ(d1, 0) && EQ(d2, 0)) {\n\t\tret = a1;\n\t}else\n\tif (EQ(d2, 0))return P(INF, INF);\n\tret = a1 + d1 / d2 * (a2 - a1);\n\tif (isPointOnLine(b1, b2, ret) && isPointOnLine(a1, a2, ret)) {\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn P(INF, INF);\n\t}\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb &t0, pbb &t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;\n#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-9);\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((ll)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if(CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if(CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if(CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if(CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if(CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if(CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if(CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#endif\n/*}}}*/\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\nstruct interpoint {\n\tbool mine;\n\tbool overground;\n\tdouble dist;\n\tOPOVER(<, interpoint) {\n\t\treturn dist < t.dist;\n\t}\n};\nvector<interpoint> interpoints;\n\nint main(int argc, char const* argv[])\n{\n\tint N;\n\tcin >> N;\n\tREP (ii, N) {\n\t\tinterpoints.clear();\n\n\t\tint xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tP a = P(xa, ya);\n\t\tP b = P(xb, yb);\n\t\t//cout << a.real() << \",\" << a.imag() << endl << b.real() << \",\" << b.imag() << endl;\n\t\tdprt(\"a-b =  (%lf, %lf)-(%lf, %lf)\\n\", a.real(), a.imag());\n\n\t\tREP (i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s = P(xs, ys);\n\t\t\tP t = P(xt, yt);\n\t\t\tdprt(\"line_seg (%lf, %lf)-(%lf, %lf)\\n\", s.real(), s.imag(), t.real(), t.imag());\n\t\t\t//if(ii==10)cout << endl << s.real() << \",\" << s.imag() << endl << t.real() << \",\" << t.imag() << endl;\n\t\t\tif (is_intersected_ls(a, b, s, t)) {\n\t\t\t\tif(!(abs(cross(b-a, t-s)) < EPS)){\n\t\t\t\t\tP _ip = intersection_ls(a, b, s, t);\n\t\t\t\t\tinterpoint ip = { o, l, abs(a - _ip) };\n\t\t\t\t\tinterpoints.PB(ip);\n\t\t\t\t\tdprt(\"\\tintersects at (%lf, %lf), dist from a: %lf, (mine, over) = (%d, %d)\\n\", _ip.real(), _ip.imag(), abs(a - _ip), o, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSORT(interpoints);\n\n\t\tcerr << endl << \"after sorted:\" << endl;\n\t\tREP (i, SZ(interpoints)) {\n\t\t\tdprt(\"interpoint #%d: dist(%lf)\\n\", i, interpoints[i].dist);\n\t\t}\n\n\t\tint ans = 0;\n\t\tif (SZ(interpoints) > 0) {\n\t\t\tinterpoint ip = interpoints[0];\n\t\t\tbool cur_over = ip.mine? ip.overground : !ip.overground;\n\t\t\tdprt(\"nearest point: dist(%lf)\\n\", ip.dist);\n\t\t\tdprt(\"start: cur_over = %d\\n\", cur_over);\n\t\t\tFOR (i, 1, interpoints.size()) {\n\t\t\t\tinterpoint ip = interpoints.at(i);\n\t\t\t\tdprt(\"interpoint #%d, dist: %lf, cur_over: %d, points: (mine, over) = (%d, %d)\\n\", i, ip.dist, cur_over, ip.mine, ip.overground);\n\t\t\t\tif ( (ip.mine && cur_over != ip.overground) ||\n\t\t\t\t\t\t(!ip.mine && cur_over == ip.overground) ) {\n\t\t\t\t\t++ans;\n\t\t\t\t\tcur_over = !cur_over;\n\t\t\t\t\tdprt(\"\\tchange state: cur_over = %d\\n\", cur_over);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\n#include<cmath>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\nstruct Point;\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\nstruct Circle;\nstruct Segment;\ntypedef Segment Line;\ndouble norm(Point a);\ndouble abs(Point a);\ndouble dot(Vector a, Vector b);\ndouble cross(Vector a, Vector b);\ndouble getDistance(Point a, Point b);\ndouble getDistanceLP(Line l, Point p);\ndouble getDistanceSP(Segment s, Point p);\ndouble getDistance(Segment s1, Segment s2);\nbool isOrthogonal(Vector a, Vector b);\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2);\nbool isOrthogonal(Segment s1, Segment s2);\nbool isParallel(Vector a, Vector b);\nbool isParallel(Point a1, Point a2, Point b1, Point b2);\nbool isParallel(Segment s1, Segment s2);\nint ccw(Point p0, Point p1, Point p2);\nbool intersect(Point p1, Point p2, Point p3, Point p4);\nbool intersect(Segment s1, Segment s2);\nbool intersect(Circle c, Line l); // 誤差の検証をしていない\nbool intersect(Circle c1, Circle c2); // 誤差の検証をしていない\n\nPoint project(Segment s, Point p);\nPoint reflect(Segment s, Point p);\nPoint getCrossPoint(Segment s1, Segment s2);\npair<Point,Point> getCrossPoints(Circle c, Line l);\npair<Point,Point> getCrossPoints(Circle c1, Circle c2); // 誤差の検証をしていない\npair<Point,Point> getContactPoints(Circle c, Point p); // 接点 点は円の外部\n\ndouble area(Polygon g); // convexでなくてもよい. absを消せば符号付き面積\nbool isConvex(Polygon g); // O(n^2) 線形時間アルゴリズムが存在するらしい\nint contains(Polygon g, Point p);\n\ndouble arg(Vector p);   // 偏角\nVector polar(double a, double r); // 極座標系->ベクトル\n\nPolygon andrewScan(Polygon g); // 凸包の辺上の点も含めたければ!=CLOCKWISEを==COUNTER_CLOCKWISEに\ndouble convexDiameter(Polygon g); // gはconvex \n\n\nstruct Point{\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    Point operator + (Point p){ return Point(x+p.x, y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x, y-p.y); }\n    Point operator * (double a){ return Point(a*x, a*y); }\n    Point operator / (double a){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm()); }\n    double norm() { return x*x + y*y; }\n\n    bool operator < (const Point &p) const{\n        return x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n    Point c;\n    double r;\n    Circle(Point c = Point(), double r = 0.0) : c(c), r(r) {}\n};\n\nstruct Segment{\n    Point p1, p2;\n    Segment(Point p1, Point p2) : p1(p1), p2(p2) {}\n};\n\ntypedef Segment Line;\n\n\ndouble norm(Point a){\n    return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Point a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble getDistance(Point a, Point b){\n    return abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n    return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\ndouble getDistanceSP(Segment s, Point p){\n    if(dot(s.p2-s.p1, p-s.p1) < 0.0)    return abs(p-s.p1);\n    if(dot(s.p1-s.p2, p-s.p2) < 0.0)    return abs(p-s.p2);\n    return getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n    if(intersect(s1, s2))   return 0.0;\n    return min({getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2), \n                getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)});\n}\n\n\nbool isOrthogonal(Vector a, Vector b){\n    return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n    return isOrthogonal(a1-a2, b1-b2);\n}\nbool isOrthogonal(Segment s1, Segment s2){\n    return equals(dot(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\nbool isParallel(Vector a, Vector b){\n    return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n    return isParallel(a1-a2, b1-b2);\n}\nbool isParallel(Segment s1, Segment s2){\n    return equals(cross(s1.p2-s1.p1, s2.p2-s2.p1), 0.0);\n}\n\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;   // p2->p0->p1\nstatic const int ONLINE_FRONT = -2; // p0->p1->p2\nstatic const int ON_SEGMENT = 0;    // p0->p2->p1\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a, b) > EPS)   return COUNTER_CLOCKWISE;\n    if(cross(a, b) < -EPS)  return CLOCKWISE;\n    if(dot(a, b) < -EPS)    return ONLINE_BACK;\n    if(norm(a) < norm(b))   return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n    return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n            ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2){\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\nbool intersect(Circle c, Line l){\n    return getDistanceLP(l, c.c) < c.r+EPS;\n}\nbool intersect(Circle c1, Circle c2){\n    return abs(c1.r-c2.r) <= getDistance(c1.c, c2.c) && getDistance(c1.c, c2.c) < c1.r+c2.r+EPS;\n}\n\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n    return p + (project(s, p) - p) * 2.0;\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1-s2.p1));\n    double d2 = abs(cross(base, s1.p2-s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\npair<Point,Point> getCrossPoints(Circle c, Line l){\n    assert(intersect(c, l));\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e*base, pr - e*base);\n}\n\npair<Point,Point> getCrossPoints(Circle c1, Circle c2){\n    assert(intersect(c1, c2));\n    double d = abs(c1.c - c2.c);\n    double a = acos( (c1.r*c1.r + d*d - c2.r*c2.r)/(2*c1.r*d) );\n    double t = arg(c2.c - c1.c);\n    return make_pair(c1.c + polar(c1.r, t+a), c1.c + polar(c1.r, t-a));\n}\n\npair<Point,Point> getContactPoints(Circle c, Point p){\n    assert(c.r < getDistance(c.c, p));\n    double d = getDistance(c.c, p);\n    return getCrossPoints(c, Circle(p, sqrt(d*d-c.r*c.r)));\n}\n\ndouble area(Polygon g){\n    if(g.size() < 3)    return 0;\n    int n = g.size();\n    Point o(0.0, 0.0);\n    double s = 0.0;\n    for(int i = 0; i < n; i++)  s += cross(g[i]-o, g[(i+1)%n]-o);\n    return abs(s) / 2.0;\n}\n\nbool isConvex(Polygon g){\n    bool ret = true;\n    int n = g.size();\n    for(int i = 0; i < n; i++){\n        for(int j = i+1; j < n; j++){\n            if(cross(g[i]-g[(i+n-1)%n], g[j]-g[(i+n-1)%n]) < -EPS || cross(g[(i+1)%n]-g[i], g[j]-g[i]) < -EPS){\n                ret = false;\n            }\n        }\n    }\n    return ret;\n}\n\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    for(int i = 0; i < n; i++){\n        Point a = g[i] - p, b = g[(i+1)%n] - p;\n        if(abs(cross(a, b)) < EPS && dot(a, b) < EPS)   return ON;\n        if(a.y > b.y)   swap(a, b);\n        if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n    }\n    return x ? IN : OUT;\n}\n\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nVector polar(double a, double r){\n    return Point(a * cos(r), a * sin(r));\n}\n\n\nPolygon andrewScan(Polygon g){\n    Polygon u, l;\n    if(g.size() < 3)    return g;\n    sort(g.begin(), g.end());\n    u.push_back(g[0]);\n    u.push_back(g[1]);\n    l.push_back(g[g.size()-1]);\n    l.push_back(g[g.size()-2]);\n\n    // upper\n    for(int i = 2; i < g.size(); i++){\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], g[i]) != CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(g[i]);\n    }\n\n    // lower\n    for(int i = g.size()-3; i >= 0; i--){\n        for(int n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], g[i]) != CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(g[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for(int i = u.size()-2; i >= 1; i--)    l.push_back(u[i]);\n\n    return l;\n}\n\ndouble convexDiameter(Polygon g){\n    double d = 0.0;\n    int n = g.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n        if(g[i].y > g[is].y)    is = i;\n        if(g[i].y < g[js].y)    js = i;\n    }\n    d = getDistance(g[is], g[js]);\n\n    int i = is, j = js, maxi = is, maxj = js;\n    do{\n        if(cross(g[(i+1)%n]-g[i], g[(j+1)%n]-g[j]) >= 0.0)  j = (j+1)%n;\n        else    i = (i+1)%n;\n        if(getDistance(g[i], g[j]) > d){\n            d = getDistance(g[i], g[j]);\n            maxi = i, maxj = j;\n        }\n    }while(i != is || j != js);\n\n    return d; // farthest pair is (maxi, maxj).\n}\n\nint main(){\n    int q;\n    cin >> q;\n    while(q-- > 0){\n        Point a, b;\n        cin >> a.x >> a.y >> b.x >> b.y;\n        int n;\n        cin >> n;\n        vector<pair<double,int>> v;\n        for(int i = 0; i < n; i++){\n            Point s, t;\n            int o, l;\n            cin >> s.x >> s.y >> t.x >> t.y >> o >> l;\n            l = (l + 1-o)%2;\n            if(intersect(s, t, a, b)){\n                v.push_back({getDistance(a, getCrossPoint(Segment(a,b), Segment(s,t))), l});\n            }\n        }\n        sort(v.begin(), v.end());\n        int ans = 0;\n        for(int i = 1; i < v.size(); i++){\n            ans += (v[i].second!=v[i-1].second);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& p,const Point& q){\n  return real(conj(p)*q);\n}\n\ndouble det(const Point& p,const Point& q){\n  return imag(conj(p)*q);\n}\n\nbool on_seg(const Point& p1,const Point&p2,\n\t    const Point& q){\n  return abs(det(p1-q,p2-q)) <= EPS && dot(p1-q,p2-q) < EPS;\n}\n\ndouble compute_scale(const Point& p1,const Point& p2,\n\t     const Point& q1,const Point& q2) {\n  return det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nPoint compute_intersection(const Point& p1,const Point& p2,\n\t\t\t   const Point& q1,const Point& q2) {\n  return p1 + (p2-p1) * det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nint compute_location(int owner,int location){\n  //owner 1:me 0:other\n  //location 1:high way 0:under ground\n  if(owner == 1){\n    return location;\n  }\n  else if(owner == 0){\n    return !location;\n  }\n}\n\nint main(){\n  int total_dataset = 0;\n  while(~scanf(\"%d\",&total_dataset)){\n    for(int dataset_idx=0;dataset_idx<total_dataset;dataset_idx++){\n      int xa,ya,xb,yb;\n      scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n      Point p1(xa,ya);\n      Point p2(xb,yb);\n\n      int n;\n      scanf(\"%d\",&n);\n\t\n      vector<pair<double,int> > intersections;\n      for(int i=0;i<n;i++){\n\tint xs,ys,xt,yt,owner,location;\n\tscanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&owner,&location);\n\tPoint p3(xs,ys);\n\tPoint p4(xt,yt);\n\tPoint intersection = compute_intersection(p1,p2,p3,p4);\n\t\n\tif(!on_seg(p1,p2,intersection)) continue;\n\tdouble scale = compute_scale(p1,p2,p3,p4);\n\tint next_location = compute_location(owner,location);\n\n\tpair<double,int> tmp(scale,next_location);\n\tintersections.push_back(tmp);\n      }\n\n      sort(intersections.begin(),intersections.end());\n      int prev = intersections.size() == 0 ? -1 : intersections[0].second;\n      int res = 0;\n      for(int i=1;i<intersections.size();i++){\n\tif(prev != intersections[i].second) res++;\n\tprev = intersections[i].second;\n      }\n      printf(\"%d\\n\",res);\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        //show(t)\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n        //show(n)\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            //cout << a << ' ' << b << endl;\n            if(not a) b = (b ? 0 : 1);\n            place[i] = b;\n            //cout << a << ' ' << b << endl;\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n){\n            if(isIntersectedLs(rail, old[i])){\n                    v.emplace_back(make_pair(intersectionLs(rail, old[i]) - rail.p1,place[i]));\n            }\n        }\n        if(v.empty()){\n            cout << 0 << endl;\n            continue;\n        }\n        sort(all(v),greater<pair<Point,int>>());\n        int ans = 0, now = v[0].second;\n        rep(i,v.size()){\n            if(v[i].second != now){\n                ans++;\n                now = v[i].second;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, int xo, int yo, int dx, int dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tdouble r = sqrt((double)dx * dx + dy * dy);\n\tx = _x * dx / r + _y * dy / r;\n\ty = _y * dx / r - _x * dy / r;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tif (r == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << sqrt((double)dx * dx + dy * dy) << endl;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] >= 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tcout << x << endl;\n\t\t\tif (x < -EPS || x > sqrt((double)dx * dx + dy * dy) + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,pair<int,int> > CP;\n\nconst double PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + (a.sc-a.fs)*( d /(d * abs(cross(b.sc-b.fs,a.sc-b.fs))) );\n}\n\nint main(){\n  int t,n;\n  int xa,ya,xb,yb;\n  int xs[110],ys[110],xt[110],yt[110],o[110],l[110];\n\n  cin >> t;\n\n  while(t--){\n    cin >> xa >> ya >> xb >> yb;\n    cin >> n;\n    for(int i=0;i<n;i++)cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n   \n    vector<CP> cp;\n    L nl = L(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;i++){\n      L tmpl = L(P(xs[i],ys[i]),P(xt[i],yt[i]));\n      if( is_cp(nl,tmpl) )cp.push_back(CP(seg_cp(nl,tmpl),make_pair(o[i],l[i])));\n    }\n    sort(cp.begin(),cp.end());\n    \n    int ans = 0;\n    for(int i=1;i<(int)cp.size();i++){\n      if( (cp[i-1].sc.fs==cp[i].sc.fs)^(cp[i-1].sc.sc==cp[i].sc.sc) )ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define fst first\n#define scn second\n\ncomplex<int> rot;\nvoid rotate(pii *p){\n\tcomplex<int> P(p->fst,p->scn);\n\tP*=rot;\n\t*p=mp(P.real(),P.imag());\n}\n\npii getpair(){\n\tpii ret;\n\tcin>>ret.fst>>ret.scn;\n\treturn ret;\n}\n\nint main(){\n\tint m;\tcin>>m;\n\twhile(m--){\n\t\tpii s=getpair(),t=getpair();\n\t\trot=complex<int>(s.scn-t.scn,s.fst-t.fst);\n\t\trotate(&s);\trotate(&t);\n\t\tif(s.scn>t.scn)\tswap(s,t);\n\t\tint n;\tcin>>n;\n\t\tvector<pair<double,int>> ls;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpii p=getpair(),q=getpair();\n\t\t\tint o,l;\tcin>>o>>l;\n\t\t\tif(o==0)\tl^=1;\n\t\t\trotate(&p);\trotate(&q);\n\t\t\tif(p.fst==q.fst)\tcontinue;\n\t\t\tdouble r=(double)(s.fst-q.fst)/(p.fst-q.fst);\n\t\t\tif(r<0||1<r)\tcontinue;\n\t\t\tdouble y=(p.scn-q.scn)*r+q.scn;\n\t\t\tif(s.scn<=y&&y<=t.scn){\n\t\t\t\tls.push_back(mp(y,l));\n\t\t\t}\n\t\t}\n\t\tsort(ls.begin(),ls.end());\n\t\tint ret=0;\n\t\tfor(int i=1;i<ls.size();i++){\n\t\t\tif(ls[i].scn!=ls[i-1].scn)\tret++;\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& p,const Point& q){\n  return real(conj(p)*q);\n}\n\ndouble det(const Point& p,const Point& q){\n  return imag(conj(p)*q);\n}\n\nbool on_seg(const Point& p1,const Point&p2,\n\t    const Point& q){\n  return abs(det(p1-q,p2-q)) <= EPS && dot(p1-q,p2-q) < EPS;\n}\n\nPoint compute_intersection(const Point& p1,const Point& p2,\n\t\t\t   const Point& q1,const Point& q2) {\n  return p1 + (p2-p1) * det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nint ccw(Point a,Point b,Point c) {\n  b -= a; c -= a;\n  if (det(b, c) > 0)   return +1;       // counter clockwise\n  if (det(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const Point& p1, const Point& p2,\n\t\t const Point& q1, const Point& q2) {\n  return (ccw(p1,p2,q1) *\n\t  ccw(p1,p2,q2) <= 0 &&\n\t  ccw(q1,q2,p1) *\n\t  ccw(q1,q2,p2) <= 0);\n}\n\ndouble compute_distance(const Point& p,const Point &q){\n  return abs(q-p);\n}\n\nint compute_location(int owner,int location){\n  //owner 1:me 0:other\n  //location 1:high way 0:under ground\n  if(owner == 1){\n    return location;\n  }\n  else if(owner == 0){\n    return !location;\n  }\n}\n\nint main(){\n  int total_dataset = 0;\n  while(~scanf(\"%d\",&total_dataset)){\n    for(int dataset_idx=0;dataset_idx<total_dataset;dataset_idx++){\n      int xa,ya,xb,yb;\n      scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n      Point p1(xa,ya);\n      Point p2(xb,yb);\n\n      int n;\n      scanf(\"%d\",&n);\n\t\n      vector<pair<double,int> > intersections;\n      for(int i=0;i<n;i++){\n\tint xs,ys,xt,yt,owner,location;\n\tscanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&owner,&location);\n\tPoint p3(xs,ys);\n\tPoint p4(xt,yt);\n\n\tif(!intersectSS(p1,p2,p3,p4)) continue;\n\n\tPoint intersection = compute_intersection(p1,p2,p3,p4);\n\tdouble dist = compute_distance(p1,intersection);\n\tint next_location = compute_location(owner,location);\n\n\tpair<double,int> tmp(dist,next_location);\n\tintersections.push_back(tmp);\n      }\n\n      sort(intersections.begin(),intersections.end());\n      int prev = intersections.size() == 0 ? -1 : intersections[0].second;\n      int res = 0;\n      for(int i=1;i<intersections.size();i++){\n\tif(prev != intersections[i].second) res++;\n\tprev = intersections[i].second;\n      }\n      printf(\"%d\\n\",res);\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\nconst double EPS = 1e-9;\n\n// xy平面上の点(ベクトル)を表現するには、complex型を利用するとよい\ntypedef complex<double> P;\n\n// 辺の表現 (座標を2つ pair でもつ)\ntypedef pair<P, P> L;\n\n// 円の表現 (座標 P と 半径 d で表現する)\ntypedef pair<P, double> C;\n\n// 成分を取り出すのを簡単にする\n#define X real()\n#define Y imag()\n\n// 誤差(epsilon)の定義\n#define EPS (1e-10)\n\n// 2つの要素が等しいかどうか\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n\n// m は n より大きい(以上)かどうか\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n\n// m は n より小さい(以下)かどうか\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\n// 2つのベクトルの内積を求める\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2つのベクトルの外積を求める\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ccw (c が直線(線分) ab に対してどのような位置関係か？)\n// Verified: AOJ CGL_1_C: Counter-Clockwise\n// +1 ... a → b で半時計方向に折れて b → c (COUNTER_CLOCKWISE)\n// -1 ... a → b で時計方向に折れて b → c (CLOCKWISE)\n// +2 ... c, a, b がこの順で同一直線状にある場合 (ONLINE_BACK)\n// -2 ... a, b, c がこの順で同一直線状にある場合 ( or a == b ) (ONLINE_FRONT)\n//  0 ... c が線分 ab 上にある場合 (点 a, b 上を含む) (ON_SEGMENT)\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// 線分 a1, a2 と線分 b1, b2 の交差判定\n// Verified: CGL_2_B: Intersection\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// 直線 a1, a2 と直線b1, b2の交点を求める\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\nstruct Elem {\n    P l, r;\n    int comp, land;\n    Elem(int xs, int ys, int xt, int yt, int o, int p) {\n        l = P(xs, ys);\n        r = P(xt, yt);\n        comp = o;\n        land = p;\n    }\n};\n \nstruct itsect {\n    double x, y;\n    int idx;\n    bool operator<(const itsect &e) const {\n        if(x != e.x) return x < e.x;\n        return y < e.y;\n    }\n};\n\nsigned main() {\n    int T; cin >> T;\n    while(T--) {\n        int xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n        P p(xa, ya), q(xb, yb);\n        int N; cin >> N;\n        vector<Elem> es;\n        rep(i,0,N) {\n            int xs, ys, xt, yt, o, l; cin >> xs >> ys >> xt >> yt >> o >> l;\n            es.push_back(Elem(xs, ys, xt, yt, o, l));\n        }\n\n        vector<itsect> points;\n        rep(i,0,N) {\n            if(isec_ss(p, q, es[i].l, es[i].r)) {\n                P its = crossp_ll(p, q, es[i].l, es[i].r);\n                points.push_back(itsect{its.X, its.Y, i});\n            }\n        }\n        sort(points.begin(), points.end());\n\n        int prev = -1, ans = 0;\n        rep(i,0,points.size()) {\n            int num = es[points[i].idx].comp ^ es[points[i].idx].land;\n            if(prev != num) {\n                ans++;\n                prev = num;\n            }\n        }\n        cout << max(0LL, ans - 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int i,j;\n    int t;\n    cin >> t;\n    rep(j,t){\n        L l = inL();//a:l[0],b:l[1]\n        int n;\n        cin >> n;\n\n        vector<pair<double,int> > v;\n\n        rep(i,n){\n            L seg = inL();\n            int a,b;\n            cin >> a >> b;//会社、地上地下\n            if(!intersectSS(l,seg))continue;\n            P p = crosspointSS(l,seg);\n            double dist = distancePP(p, l[0]);\n            v.push_back(make_pair(dist,(int)a!=b));\n        }\n\n        if(v.size() <= 1){\n            cout << 0 << endl;\n            continue;\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n\n        rep(i,v.size()-1){\n            if(v[i].second != v[i+1].second) ans++;\n        }\n\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nusing Point = complex<double>;\nusing Polygon = vector<Point>;\n\ninline int sgn(const double &a) { return (a < -EPS ? -1 : (a > EPS ? 1 : 0)); }\n\ninline bool eq(const Point &a, const Point &b) { return abs(a - b) < EPS; }\n\nnamespace std {\ninline bool operator<(const Point &a, const Point &b) {\n    if (sgn(a.real() - b.real()))\n        return sgn(a.real() - b.real()) < 0;\n    return sgn(a.imag() - b.imag()) < 0;\n}\n} // namespace std\n\ndouble dot(const Point &a, const Point &b) { return real(conj(a) * b); }\n\ndouble det(const Point &a, const Point &b) { return imag(conj(a) * b); }\n\nstruct Line {\n    Point p1, p2;\n\n    Line(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\n    bool operator<(const Line &rhs) const {\n        if (eq(p2, rhs.p2))\n            return p1 < rhs.p1;\n        return p2 < rhs.p2;\n    }\n    bool operator==(const Line &rhs) const {\n        return (eq(p1, rhs.p1) && eq(p2, rhs.p2)) ||\n               (eq(p1, rhs.p2) && eq(p2, rhs.p1));\n    }\n};\n\ninline Point curr(const Polygon &p, const int &i) { return p[i % p.size()]; }\n\ninline Point next(const Polygon &p, const int &i) {\n    return p[(i + 1) % p.size()];\n}\n\ninline Point prev(const Polygon &p, const int &i) {\n    return p[(i + p.size() - 1) % p.size()];\n}\n\nenum CCW {\n    ONLINE_FRONT = -2,\n    CLOCKWISE,\n    ON_SEGMENT,\n    COUNTER_CLOCKWISE,\n    ONLINE_BACK\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Point a = p1 - p0;\n    Point b = p2 - p0;\n    if (sgn(det(a, b)) == 1)\n        return COUNTER_CLOCKWISE;\n    if (sgn(det(a, b)) == -1)\n        return CLOCKWISE;\n    if (sgn(dot(a, b)) == -1)\n        return ONLINE_BACK;\n    if (sgn(norm(b) - norm(a)) == 1)\n        return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersectLS(Line a, Line b, bool segflag) {\n    if (segflag)\n        return (ccw(a.p1, a.p2, b.p1) * ccw(a.p1, a.p2, b.p2) <= 0) &&\n               (ccw(b.p1, b.p2, a.p1) * ccw(b.p1, b.p2, a.p2) <= 0);\n    else\n        return (sgn(det(a.p2 - a.p1, b.p1 - a.p1) *\n                    det(a.p2 - a.p1, b.p2 - a.p1)) <= 0) &&\n               (sgn(det(b.p2 - b.p1, a.p1 - b.p1) *\n                    det(b.p2 - b.p1, a.p2 - b.p1)) <= 0);\n}\n\nPoint intersection(Line a, Line b) {\n    Point v1 = a.p2 - a.p1, v2 = b.p2 - b.p1;\n    return a.p1 + v1 * det(v2, b.p1 - a.p1) / det(v2, v1);\n}\n\nint main(){\n    int T;\n    cin >> T;\n    for(int t=0;t<T;++t){\n        double xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        Line new_rail(Point(xa, ya), Point(xb, yb));\n        int n;\n        cin >> n;\n        vector<pair<Point, int>> intersections;\n        for(int j=0;j<n;++j){\n            double xs, ys, xt, yt;\n            int o, i;\n            cin >> xs >> ys >> xt >> yt >> o >> i;\n            i ^= o;\n            Line rail(Point(xs, ys), Point(xt, yt));\n            if(!intersectLS(new_rail, rail, true))continue;\n            intersections.emplace_back(intersection(new_rail, rail), i);\n        }\n        if(intersections.size() == 0){\n            cout << 0 << endl;\n            continue;\n        }\n        sort(intersections.begin(), intersections.end());\n        int ans = 0, f = intersections[0].second;\n        for(int i=1;i<intersections.size();++i){\n            if(f != intersections[i].second){\n                ans++;\n                f = intersections[i].second;\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    double dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cosθ\n    }\n    double cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sinθ\n    }\n};\n\nclass Line\n{\npublic:\n    double a, b, c; // a*x + b*y + c = 0\n    Line(){\n        a = c = 0.0;\n        b = 1.0;\n    }\n    Line(double a0, double b0, double c0){\n        a = a0;\n        b = b0;\n        c = c0;\n    }\n    Line(const Point& p1, const Point& p2){ // 2点を結ぶ直線\n        double dy = p2.y - p1.y;\n        double dx = p2.x - p1.x;\n        if(abs(dy / dx) < EPS){\n            a = 0.0;\n            b = 1.0;\n            c = -p1.y;\n        }else if(abs(dx / dy) < EPS){\n            a = 1.0;\n            b = 0.0;\n            c = -p1.x;\n        }else{\n            a = - dy / dx;\n            b = 1.0;\n            c = dy / dx * p1.x - p1.y;\n        }\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) + EPS || min(b1.x, b2.x) > max(a1.x, a2.x) + EPS || min(a1.y, a2.y) > max(b1.y, b2.y) + EPS || min(b1.y, b2.y) > max(a1.y, a2.y) + EPS)\n        return false;\n\n    return ((a2-a1).cross(b1-a1) * (a2-a1).cross(b2-a1) <= EPS) && ((b2-b1).cross(a1-b1) * (long long)(b2-b1).cross(a2-b1) <= EPS);\n}\n\nbool linesIntersection(const Line& l1, const Line& l2, Point& intersection)\n{\n    double s = l1.a*l2.b - l2.a*l1.b;\n    if(abs(s) < EPS)\n        return false;\n\n    intersection = Point(l2.a*l1.c - l1.a*l2.c, l1.b*l2.c - l2.b*l1.c) / s;\n    return true;\n}\n\nint main()\n{\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        Point a, b;\n        cin >> a.x >> a.y >> b.x >> b.y;\n\n        int n;\n        cin >> n;\n        vector<pair<pair<double, double>, int> > v;\n        for(int i=0; i<n; ++i){\n            Point s, t;\n            int o, l;\n            cin >> s.x >> s.y >> t.x >> t.y >> o >> l;\n\n            if(segmentsCollide(a, b, s, t)){\n                Point p;\n                linesIntersection(Line(a, b), Line(s, t), p);\n                v.push_back(make_pair(make_pair(p.x, p.y), o ^ l));\n            }\n        }\n\n        int m = v.size();\n        if(abs(b.y-a.y) > abs(b.x-b.y)){\n            for(int i=0; i<m; ++i)\n                swap(v[i].first.first, v[i].first.second);\n        }\n        sort(v.begin(), v.end());\n\n        int ret = 0;\n        for(int i=1; i<m; ++i){\n            if(v[i].second != v[i-1].second)\n                ++ ret;\n        }\n        cout << ret << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n#define EPS 1.0e-10\ntypedef complex<double> P;\n\nstruct L { P pos, dir; };\n\ninline int signum(double x) {\n\treturn (abs(x) < EPS ? 0 : x > 0 ? 1 : -1);\n}\n\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a) * b).imag();\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n\tP a(r - p), b(s - p);\n\tint sgn = signum(outp(a, b));\n\tif (sgn != 0)\n\t\treturn sgn;\n\tif (a.real() * b.real() < -EPS || a.imag() * b.imag() < -EPS)\n\t\treturn -1;\n\tif (norm(a) < norm(b) - EPS)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nbool ss_intersects(const L& s, const L& t) {\n\treturn (ccw(s.pos, s.pos + s.dir, t.pos) *\n\t\tccw(s.pos, s.pos + s.dir, t.pos + t.dir) <= 0 &&\n\t\tccw(t.pos, t.pos + t.dir, s.pos) *\n\t\tccw(t.pos, t.pos + t.dir, s.pos + s.dir) <= 0);\n}\n\nP line_cross(const L& l, const L& m) {\n\tdouble num = outp(m.dir, m.pos - l.pos);\n\tdouble denom = outp(m.dir, l.dir);\n\treturn P(l.pos + l.dir * num / denom);\n}\n\nstruct S {\n\tP p;\n\tbool up;\n};\n\nbool comp(S s1, S s2) {\n\treturn s1.p.real() < s2.p.real();\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint T;\n\tcin >> T;\n\tfor (int loop = 0; loop < T; loop++) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\t\tvector<S> vs;\n\t\tL line = L{P(xa, ya), P(xb, yb) - P(xa, ya)};\n\t\t//vs.push_back(S{line.pos, false});\n\t\t//vs.push_back(S{line.pos + line.dir, false});\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tif (l == 1) o = 1 - o;\n\n\t\t\tL t = L{P(xs, ys), P(xt, yt) - P(xs, ys)};\n\t\t\tif (ss_intersects(line, t)) {\n\t\t\t\tP p = line_cross(line, t);\n\t\t\t\tvs.push_back(S{p, o});\n\t\t\t}\n\t\t}\n\n\t\tsort(vs.begin(), vs.end(), comp);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < vs.size() - 1; i++) {\n\t\t\tans += vs[i].up != vs[i + 1].up;\n\t\t}\n\t\t//ans += vs[0].up != vs[vs.size() - 1].up;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nconst double mEPS = 1e-10;\n\n//???????????????????????????\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\nclass Circle{\npublic:\n\tPoint c;\n\tdouble r;\n};\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn(ccw(s1.p1, s1.p2, s2.p1) * ccw(s1.p1, s1.p2, s2.p2) <= 0 &&\n\t\tccw(s2.p1, s2.p2, s1.p1) * ccw(s2.p1, s2.p2, s1.p2) <= 0);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int T; cin >> T;\n  while(T--){\n\tSegment st;\n\tcin >> st.p1.x >> st.p1.y >> st.p2.x >> st.p2.y;\n\tint N; cin >> N;\n\tvector<tuple<double,int,int>> crp;\n\tREP(i,N){\n\t  Segment u;\n\t  int o, l;\n\t  cin >> u.p1.x >> u.p1.y >> u.p2.x >> u.p2.y >> o >> l;\n\t  if(intersect(st,u)){\n\t\tPoint cp = getCrossPoint(st,u);\n\t\tcrp.PB(make_tuple((cp-st.p1).abs(), o, l));\n\t  }\n\t}\n\tSORT(crp);\n\tint b = 0, sum1 = 0;\n\tfor(int i=0;i<SZ(crp);++i){\n\t  if(get<1>(crp[i])){\n\t\tif(b != get<2>(crp[i])){\n\t\t  b = 1-b;\n\t\t  ++sum1;\n\t\t}\n\t  }\n\t  else{\n\t\tif(b == get<2>(crp[i])){\n\t\t  b = 1 - b;\n\t\t  ++sum1;\n\t\t}\n\t  }\n\t}\n\tint sum2 = 0; b = 1;\n\tfor(int i=0;i<SZ(crp);++i){\n\t  if(get<1>(crp[i])){\n\t\tif(b != get<2>(crp[i])){\n\t\t  b = 1-b;\n\t\t  ++sum2;\n\t\t}\n\t  }\n\t  else{\n\t\tif(b == get<2>(crp[i])){\n\t\t  b = 1 - b;\n\t\t  ++sum2;\n\t\t}\n\t  }\n\t}\n\tcout << min(sum1, sum2) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint crs(double x1, double y1, double x2, double y2) {\n    double z = x1*y2-y1*x2;\n    return (0 < z ? 1 : (z < 0 ? -1 : 0));\n}\n\nbool intersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (0 <= crs(x2-x1, y2-y1, x3-x1, y3-y1) * crs(x2-x1, y2-y1, x4-x1, y4-y1)) return false;\n    if (0 <= crs(x4-x3, y4-y3, x1-x3, y1-y3) * crs(x4-x3, y4-y3, x2-x3, y2-y3)) return false;\n    return true;\n}\n\npair<double,double> intersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (x3 == x4) {\n        swap(x1, x3); swap(y1, y3); swap(x2, x4); swap(y2, y4);\n    }\n    double x, y, a, b, c, d;\n    if (x1 == x2) {\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = x1;\n        y = c*x+d;\n    } else {\n        a = (y2-y1)/(x2-x1);\n        b = y1-a*x1;\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = (d-b)/(a-c);\n        y = a*x+b;\n    }\n    return make_pair(x,y);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        double xa, ya, xb, yb;\n        int n;\n        cin >> xa >> ya >> xb >> yb >> n;\n        bool vertical = abs(xa-xb) < abs(ya-yb);\n\n        double xs, ys, xt, yt;\n        int o, l;\n        vector<pair<double,int> > levels;\n        for (int i=0; i<n; ++i) {\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            if (intersect(xa, ya, xb, yb, xs, ys, xt, yt)) {\n                if (vertical) {\n                    double y = intersection(xa, ya, xb, yb, xs, ys, xt, yt).second;\n                    levels.push_back(make_pair(y, o==1 ? l : 1-l));\n                } else {\n                    double x = intersection(xa, ya, xb, yb, xs, ys, xt, yt).first;\n                    levels.push_back(make_pair(x, o==1 ? l : 1-l));\n                }\n            }\n        }\n\n        sort(levels.begin(), levels.end());\n        int res = 0;\n        for (int i=1; i<(int)levels.size(); ++i) {\n            if (levels[i].second != levels[i-1].second) {\n                res ++;\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\nbool equal(double a, double b){\n\treturn fabs(a-b) < EPS ;\n}\n\ndouble dot(P a, P b){ return real( conj(a) * b ); }\n\ndouble cross(P a, P b){ return imag( conj(a) * b ); }\n\n\n\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){ a = a_; b = b_; }\n\tSegment(){}\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) && (cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) ) ;\n\t}\n\tbool parallel( Segment s1 , Segment s2 ){\n\t\treturn equal( dot(s1.a - s1.b, s2.a - s2.b) , 0 );\n\t}\n\tbool intersection(Segment s, P& p){\n\t\tbool result = is_intersection( s );\n\n\t\tif( parallel( *this , s ) ) return false;\n\t\tif( result ){\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ){\n\t\t\t\tp = s.a;\n\t\t\t\treturn true;\n\t\t\t}else if( abs(d1) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdouble t = d1 / (d1+d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_=0 ; t_ < T ; t_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\n\t\tP start(xa,ya), goal(xb,yb);\n\t\tSegment S( start , goal );\n\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tSegment s( P(xs,ys) , P(xt,yt) );\n\n\t\t\tP p(0,0);\n\t\t\tif( S.intersection( s , p ) ){\n\t\t\t\tint d = (start.X - p.X)*(start.X - p.X) + (start.Y - p.Y)*(start.Y - p.Y);\n\t\t\t\tv.push_back( pair<int,int> ( d , (o^l)? 0 : 1 ) );\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tsort( v.begin() , v.end() );\n\t\tif( v.size() >= 2 ){\n\t\t\tint pos = v[0].second;\n\t\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\t\tif( pos != v[i].second ){\n\t\t\t\t\tpos = v[i].second;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\n// const ll LLINF = (1LL<<60);\n// const int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nbool contain(const L &l, const P &p) {\n  double ax = l[0].real(), ay = l[0].imag();\n  double bx = l[1].real(), by = l[1].imag();\n  if(ax > bx) swap(ax, bx);\n  if(ay > by) swap(ay, by);\n  return (ax > p.real() || bx < p.real() || ay > p.imag() || by < p.imag());\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int T;\n  cin >> T;\n  REP(_, T) {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    L line(P(ax,ay), P(bx,by));\n\n    // 交点の位置とその交点が高架か地下か\n    vector<pair<P, int>> po;\n    int n;\n    cin >> n;\n    REP(i, n) {\n      int xs, ys, xt, yt, o, l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L l2(P(xs,ys), P(xt,yt));\n      P c = crosspoint(line, l2);\n      if(contain(line, c)) continue;\n      po.PB({c, o^l});\n    }\n    sort(ALL(po));\n    // cout << po << endl;\n    int ret = 0;\n    FOR(i, 1, po.size()) {\n      if(po[i].second != po[i-1].second) ret++;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nusing namespace std;\nvector<pair<pair<double,double>,bool> > cp;\npair<double,double> relv(pair<double,double> a,pair<double,double> b)\n{\n  return make_pair(a.first-b.first,a.second-b.second);\n}\ndouble cross(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.second-va.second*vb.first;\n}\nvoid crosspoint(pair<double,double> a,pair<double,double> b,pair<double,double> c,pair<double,double> d,bool e)\n{\n  auto ab=relv(a,b),cd=relv(c,d);\n  if(!(cross(ab,relv(a,c))*cross(ab,relv(a,d)) < 0 &&\n       cross(cd,relv(c,a))*cross(cd,relv(c,b)) < 0)) return;\n  double midrat=cross(cd,relv(c,a))/(cross(cd,relv(c,a))+cross(cd,relv(b,d)));\n  cp.push_back(make_pair(make_pair(a.first+midrat*ab.first,a.second+midrat*ab.second),e));\n}\n\nint main(void)\n{\n  int n;\n  cin >> n;\n  REP(i,n){\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    pair<double,double> s,e;\n    s=make_pair(sx,sy),e=make_pair(ex,ey);\n    cp.clear();\n    int m;\n    cin >> m;\n    REP(i,m){\n      int x[2],y[2],p,q;\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> p >> q;\n      crosspoint(s,e,make_pair(x[0],y[0]),make_pair(x[1],y[1]),p==q);\n    }\n    SORT(cp);\n    int answer=0;\n    REP(i,(int)cp.size()-1) if(cp[i].second!=cp[i+1].second) ++answer;\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n#define fst first\n#define scn second\n\nint main(){\n\tint t;\tcin>>t;\n\twhile(t--){\n\t\tpair<double,double> s,t;\n\t\tcin>>s.fst>>s.scn>>t.fst>>t.scn;\n\t\tcomplex<double> rot(s.scn-t.scn,t.fst-s.fst);\n\t\trot/=abs(rot);\n\t\tcomplex<double> S(s.fst,s.scn);\n\t\tcomplex<double> T(t.fst,t.scn);\n\t\tS/=rot;\tT/=rot;\n\t\ts=make_pair(S.real(),S.imag());\n\t\tt=make_pair(T.real(),T.imag());\n\t\tif(s.scn>t.scn)\tswap(s,t);\n\t\tvector<pair<double,int>> cross;\n\t\tint n;\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpair<double,double> p,q;\n\t\t\tint o,l;\n\t\t\tcin>>p.fst>>p.scn>>q.fst>>q.scn>>o>>l;\n\t\t\tif(o==0)\tl^=1;\n\t\t\tcomplex<double> z(p.fst,p.scn);\n\t\t\tz/=rot;\n\t\t\tp=make_pair(z.real(),z.imag());\n\t\t\tz.real(q.fst);\tz.imag(q.scn);\n\t\t\tz/=rot;\n\t\t\tq=make_pair(z.real(),z.imag());\n\t\t\tif(p.fst==q.fst)\tcontinue;\n\t\t\tdouble y=(q.scn-p.scn)*(t.fst-p.fst)/(q.fst-p.fst)+p.scn;\n\t\t\tif(s.scn<=y&&y<=t.scn){\n\t\t\t\tcross.push_back(make_pair(y,l));\n\t\t\t}\n\t\t}\n\t\tsort(cross.begin(),cross.end());\n\t\tint ret=0;\n\t\tfor(int i=1;i<cross.size();i++){\n\t\t\tif(cross[i].second!=cross[i-1].second)\tret++;\n\t\t}\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\n#define N 100\n#define INFF 100.0\n\ndouble f(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) {\n\tif( (Y1-Y2)*(x1-x2)==(X1-X2)*(y1-y2) ) return INFF;\n\treturn (double)( (X1-X2)*(y2-Y2)-(Y1-Y2)*(x2-X2) )/(double)( (Y1-Y2)*(x1-x2)-(X1-X2)*(y1-y2) );\n}\n\nint main() {\n\tint nn, n, xa, ya, xb, yb, p, ans;\n\tint xs, ys, xt, yt, o, l;\n\tmap<double, int> tl; double t1, t2;\n\tmap<double, int>::iterator it;\n\tcin >> nn;\n\tfor(int q=0; q<nn; ++q) {\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\t\ttl.clear(); ans = 0;\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tt1 = f(xa, ya, xb, yb, xs, ys, xt, yt);\n\t\t\tt2 = f(xs, ys, xt, yt, xa, ya, xb, yb);\n\t\t\tif(0.000000<=t1&&t1<=1.000000&&0.000000<=t2&&t2<=1.000000) {\n\t\t\t\ttl[t1] = (o==1?l:1-l);\n\t\t\t}\n\t\t}\n\t\tif(tl.size()>1) {\n\t\t\tit = tl.begin(); p = (*it).second;\n\t\t\tfor(++it; it!=tl.end(); ++it) {\n\t\t\t\tif((*it).second!=p) {\n\t\t\t\t\tans++; p = (*it).second;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n//#include <complex>\n#include <algorithm>\nusing namespace std;\n\n//typedef complex<double> P;\n\nstruct P {\n\tdouble real, imag;\n\n\tP operator - (const P& obj)\n\t{\n\t\treturn P{ real - obj.real,imag - obj.imag };\n\t}\n};\n\n#define EPS (1e-9)\n\ndouble cross(P a, P b) {\n\treturn (a.real * b.imag - a.imag * b.real);\n}\n\nint is_intersected(P a1, P a2, P b1, P b2) {\n\treturn ((cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS) &&\n\t\t(cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS));\n}\n\nP s[101], t[101];\nint c[101], l[101];\n\nstruct intersection {\n\tdouble t; // parameter t\n\tint n;    // index of intersected line\n\n\tbool operator<(const intersection &a) const {\n\t\treturn (t < a.t);\n\t}\n};\n\nint main() {\n\tint N;\n\tcin >> N;\n\twhile (N--) {\n\t\tP a, b;\n\t\tcin >> a.real >> a.imag;\n\t\tcin >> b.real >> b.imag;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tcin >> s[i].real >> s[i].imag;\n\t\t\tcin >> t[i].real >> t[i].imag;\n\t\t\tcin >> c[i] >> l[i];\n\t\t}\n\n\t\tvector<intersection> is;\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tif (!is_intersected(a, b, s[i], t[i])) { continue; }\n\t\t\tif (abs(cross(b - a, t[i] - s[i])) < EPS) { continue; }\n\n\t\t\tP x = t[i] - s[i];\n\t\t\tdouble d1 = abs(cross(x, a - s[i]));\n\t\t\tdouble d2 = abs(cross(x, b - s[i]));\n\t\t\tdouble t = d1 / (d1 + d2);\n\n\t\t\tintersection tmp = { t, i };\n\t\t\tis.push_back(tmp);\n\t\t}\n\n\t\tsort(is.begin(), is.end());\n\n\t\tint curr; // current status: up (=1) or down (=0)\n\t\tif (is.size() > 0) {\n\t\t\tint idx = is[0].n;\n\t\t\tcurr = (c[idx] == 1 ? l[idx] : !l[idx]);\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i<is.size(); i++) {\n\t\t\tint idx = is[i].n;\n\t\t\tif ((c[idx] == 1 && curr != l[idx]) ||\n\t\t\t\t(c[idx] == 0 && curr == l[idx])) {\n\t\t\t\tcurr = !curr;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nstruct L : public vector<P> {\n\tL(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nvector<L> mylines[2];//1なら高架\nvector<L> yourlines[2];\nL target;//新しく開通する路線\nvector<pair<P,int>> cp; //2bit目で自社他社、1bit目で地上地下\nint main()\n{\n\tint allcases,n;\n\tcin>>allcases;\n\tfor(int test=0;test<allcases;test++)\n\t{\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tmylines[i].clear();\n\t\t\tyourlines[i].clear();\n\t\t}\n\t\tcp.clear();\n\t\tdouble a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tP p1=P(a,b);\n\t\tP p2=P(c,d);\n\t\tif(p2<p1)\n\t\t\tswap(p1,p2);\n\t\ttarget=L(p1,p2);//x座標が小さい方が先にくるようにする\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint o,l;\n\t\t\tcin>>a>>b>>c>>d>>o>>l;\n\t\t\tif(o&1)\n\t\t\t\tmylines[l].push_back(L(P(a,b),P(c,d)));\n\t\t\telse\n\t\t\t\tyourlines[l].push_back(L(P(a,b),P(c,d)));\n\t\t}\n\t\t//全路線での交差地点が知りたい\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tint tmp=(i|2);\n\t\t\tfor(int j=0;j<mylines[i].size();j++)\n\t\t\t{\n\t\t\t\tif(intersectSS(mylines[i][j],target))\n\t\t\t\t\tcp.push_back(make_pair(crosspoint(mylines[i][j],target),tmp));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tint tmp=i;\n\t\t\tfor(int j=0;j<yourlines[i].size();j++)\n\t\t\t{\n\t\t\t\tif(intersectSS(yourlines[i][j],target))\n\t\t\t\t\tcp.push_back(make_pair(crosspoint(yourlines[i][j],target),tmp));\n\t\t\t}\n\t\t}\n\t\tsort(cp.begin(),cp.end());\n\t\tint ans=1e8-1;\n\t\tint tmp=0;\n\t\t//最初が地上のケースを調べる\n\t\tbool tijou=true;\n\t\tfor(int i=0;i<cp.size();i++)\n\t\t{\n\t\t\t//cerr<<cp[i].first<<\" \"<<cp[i].second<<endl;\n\t\t\t//現在地上かつ自社cpが地下、もしくは現在地下かつ自社cpが地上のとき\n\t\t\tif(cp[i].second&2)\n\t\t\t{\n\t\t\t\tif((tijou && (cp[i].second==2))||(!tijou && (cp[i].second==3)))\n\t\t\t\t{\n\t\t\t\t\ttijou^=true;\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//現在地上かつ他社cpが地上、もしくは現在地下かつ他社cpが地下のとき\n\t\t\t\tif((tijou && (cp[i].second==1))||(!tijou && (cp[i].second==0)))\n\t\t\t\t{\n\t\t\t\t\ttijou^=true;\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=min(ans,tmp);\n\t\t//最初が地下のケースを調べる\n\t\ttmp=0;\n\t\ttijou=false;\n\t\tfor(int i=0;i<cp.size();i++)\n\t\t{\n\t\t\t//現在地上かつ自社cpが地下、もしくは現在地下かつ自社cpが地上のとき\n\t\t\tif(cp[i].second&2)\n\t\t\t{\n\t\t\t\tif((tijou && (cp[i].second==2))||(!tijou && (cp[i].second==3)))\n\t\t\t\t{\n\t\t\t\t\ttijou^=true;\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t//現在地上かつ他社cpが地上、もしくは現在地下かつ他社cpが地下のとき\n\t\t\t\tif((tijou && (cp[i].second==1))||(!tijou && (cp[i].second==0)))\n\t\t\t\t{\n\t\t\t\t\ttijou^=true;\n\t\t\t\t\ttmp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cerr<<ans<<\" \"<<tmp<<endl;\n\t\tans=min(ans,tmp);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P ,pair<int,int> > CP;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + ( d /(d + abs(cross(b.sc-b.fs,a.sc-b.fs))) ) * (a.sc-a.fs);\n}\n\nint main(){\n  int t,n;\n  int xa,ya,xb,yb;\n  int xs[110],ys[110],xt[110],yt[110],o[110],l[110];\n\n  cin >> t;\n\n  while(t--){\n    cin >> xa >> ya >> xb >> yb;\n    cin >> n;\n    for(int i=0;i<n;i++)cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n   \n    vector<CP> cp;\n    L nl = L(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;i++){\n      L tmpl = L(P(xs[i],ys[i]),P(xt[i],yt[i]));\n      if( is_cp(nl,tmpl) )cp.push_back(CP(seg_cp(nl,tmpl),make_pair(o[i],l[i])));\n    }\n    sort(cp.begin(),cp.end());\n    \n    int ans = 0;\n    for(int i=1;i<(int)cp.size();i++){\n      if( (cp[i-1].sc.fs==cp[i].sc.fs)^(cp[i-1].sc.sc==cp[i].sc.sc) )ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<iomanip>\n#include<stack>\n#include<set>\n#include<functional>\n#include<map>\n#include<complex>\n#include<tuple>\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\ntypedef vector<P> Poly;\ntypedef pair<P, P> L;\ntypedef L LS;\n#define X real()\n#define Y imag()\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define DCl(a,b,l) P(a),(b);tie(a,b)=l;\nconst int dr[] = { 0, 1, 0, -1 };\nconst int dc[] = { 1, 0, -1, 0 };\nconst D EPS = 1e-9;\n\nstruct cww{\n\tcww(){\n\t\tcin.tie();\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\nD dot(P a, P b){\n\treturn a.X*b.X + a.Y*b.Y;\n}\nD cross(P a, P b){\n\treturn a.X*b.Y - a.Y*b.X;\n}\nD ccw(P a, P b, P c){\n\treturn cross(b - a, c - a);\n}\nint sgn(P a, P b, P c){\n\tif (cross(b - a, c - a) > EPS)return 1;\n\tif (cross(b - a, c - a) < -EPS)return -1;\n\tif (dot(b - a, c - a) > -EPS)return 2;\n\tif (dot(a - b, c - b) > -EPS)return -2;\n\treturn 0;\n}\n\n\nD signed_distance_P_L(P p,L l){\n\tDCl(a, b, l);\n\treturn ccw(a, b, p) / abs(b - a);\n}\n\nB is_LS_LS(LS p,LS q){\n\tDCl(a, b, p);\n\tDCl(c, d, q);\n\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n}\nP cross_L_L(LS p,LS q){\n\tDCl(a, b, p);\n\tD d1 = signed_distance_P_L(a, q);\n\tD d2 = signed_distance_P_L(b, q);\n\treturn (a*d2 - b*d1) / (d2 - d1);\n}\n\n\nP input(){\n\tdouble x, y;\n\tcin >> x >> y;\n\treturn P(x, y);\n}\nint main(){\n\tint T; cin >> T;\n\twhile(T--){\n\t\tP A = input();\n\t\tP B = input();\n\t\tint N;\n\t\tcin >> N;\n\t\tvector<pair<LS,int>> M, O;\n\t\tREP(i, N){\n\t\t\tLS in = LS(input(), input());\n\t\t\tint type,pos; cin >> type>>pos;\n\t\t\tif (type)M.push_back({ in, pos });\n\t\t\telse O.push_back({ in, 1-pos });\n\t\t}\n\t\tmap<D, int> m;\n\t\tfor (auto ls : M)if (is_LS_LS({ A, B }, ls.first))m[abs(A-cross_L_L({ A, B }, ls.first))] = ls.second;\n\t\tfor (auto ls : O)if (is_LS_LS({ A, B }, ls.first))m[abs(A - cross_L_L({ A, B }, ls.first))] = ls.second;\n\t\tif (m.size()){\n\t\t\tint res = 0;\n\t\t\tint prv = m.begin()->second;\n\t\t\tfor (auto &it : m){\n\t\t\t\tif (prv != it.second)res++;\n\t\t\t\tprv = it.second;\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L:public vector<P> {\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\n\ndouble dot(P a, P b) {\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return dot(P(-a.imag(),a.real()),b);\n}\n\n#define EPS 1.0e-9\n\nint ccw(P a, P b, P c) {\n  b-=a; c-=a;\n  if(cross(b,c)>EPS)return +1;\n  if(cross(b,c)<-EPS)return -1;\n  if(dot(b,c)<-EPS)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool hit(const L& s, const L& t) {\n  return ccw(s[0],t[0],s[1])*ccw(s[0],t[1],s[1])<=0;\n}\n\nbool same(const L& s, const L& t) {\n  return (s[1]-s[0]).real()*(t[1]-t[0]).imag()==(s[1]-s[0]).imag()*(t[1]-t[0]).real();\n}\n\ndouble crosslen(const L& s, const L& t) {\n  \n  P ab=s[1]-s[0], ac=t[0]-s[0], ad=t[1]-s[0];\n  ab/=norm(ab);\n  double lac=dot(ab,ac), lad=dot(ab,ad);\n  double dac=abs(ac-ab*lac), dad=abs(ad-ab*lad);\n  return (lac*dad+lad*dac)/(dad+dac);\n}\n\nstruct LINE {\n  L line;\n  int o,l;\n};\n\nstruct POINT {\n  LINE line;\n  double len;\n  bool uch;\n};\n\nbool comp (POINT a, POINT b) {\n  return a.len < b.len;\n}\n\nint main () {\n  int m;cin>>m;\n  while(m--){\n    vector<POINT> points;\n    vector<LINE> lines;\n    double xa,ya,xb,yb;cin>>xa>>ya>>xb>>yb;\n    int n;cin>>n;\n    L self(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;++i){\n      double a,b,c,d;int e,f;cin>>a>>b>>c>>d>>e>>f;\n      lines.push_back((LINE){L(P(a,b),P(c,d)),e,f});\n    }\n    for(int i=0;i<n;++i){\n      if(hit(self,lines[i].line)){\n\tif(same(self,lines[i].line)){\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[0]-self[0]),true});\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[1]-self[0]),true});\n\t}else{\n\t  points.push_back((POINT){lines[i],crosslen(self,lines[i].line)});\n\t}\n      }\n    }\n    sort(points.begin(),points.end(),comp);\n    vector<POINT> newpoints=points; points.clear();\n    int len=newpoints.size(); double srclen=abs(self[1]-self[0]);\n    if(len==0){cout<<0<<endl;continue;}\n    for(int i=0;i<len;++i){\n      if(newpoints[i].len>srclen)break;\n      points.push_back(newpoints[i]);\n    }\n    LINE line=points[0].line;\n    int precur,cur=0,result=0;bool ch=true;\n    if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n    for(int i=1;i<len;++i){\n      line=points[i].line;\n      if(points[i].uch)ch=true;\n      if(ch){\n\tprecur=cur; if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n\tif(precur!=cur){++result;}\n\tif(points[i].uch)ch=false;\n      }\n    }\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<tuple>\nusing namespace std;\nstruct Point { long double px, py; };\nstruct Line { Point p1, p2; };\nPoint Minus(const Point&a, const Point&b) { return{ a.px - b.px,a.py - b.py }; }\nPoint Plus(const Point&a, const Point&b) { return{ a.px + b.px,a.py + b.py }; }\nPoint Times(const Point&a, const long double&b) { return{ a.px *b,a.py *b }; }\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double arg(const Point& a) { return atan2l(a.py, a.px); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = Minus(p1, p0), b = Minus(p2, p0);\n\tif (crs(a, b) > 1e-10) return 1;\n\tif (crs(a, b) < -1e-10) return -1;\n\tif (dot(a, b) < -1e-10) return 2;\n\tif (norm(a) < norm(b)) return -2;\n\treturn 0;\n}\nbool its(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nPoint crp(Line a, Line b) {\n\tPoint c = Minus(b.p2, b.p1);\n\tlong double d1 = abs(crs(c, Minus(a.p1, b.p1)));\n\tlong double d2 = abs(crs(c, Minus(a.p2, b.p1)));\n\treturn Plus(a.p1, Times((Minus(a.p2, a.p1)), (d1 / (d1 + d2))));\n}\nint n, o[1000], l[1000]; Line p, x[1000];\nvector<tuple<long double, long double, int>>vec;\nint main() {\n\tint t; cin >> t;\n\tfor (int i = 0; i < t; i++) {\n\t\tcin >> p.p1.px >> p.p1.py >> p.p2.px >> p.p2.py; vec.clear();\n\t\tcin >> n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i].p1.px >> x[i].p1.py >> x[i].p2.px >> x[i].p2.py >> o[i] >> l[i];\n\t\t\tif (its(p.p1, p.p2, x[i].p1, x[i].p2) == true) {\n\t\t\t\tvec.push_back(make_tuple(crp(p, x[i]).px, crp(p, x[i]).py, (o[i] + l[i] + 1) % 2));\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\tif (get<2>(vec[i]) != get<2>(vec[i - 1]))cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nstruct Point{bool high;double x,y;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nPoint* Intersection(Point p1,Point p2,Point p3,Point p4){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(d==0 || u<0 || u>1 || v<0 || v>1)return NULL;\n    Point *ret = new Point();\n    ret->x = p1.x+u*(p2.x-p1.x);\n    ret->y = p1.y+u*(p2.y-p1.y);\n    return ret;\n}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n            Point *ret = Intersection(a,b,s,t);\n            if(ret!=NULL){\n                ret->high = o==l;\n                cross.push_back(*ret);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<(int)cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2003&lang=jp\nusing namespace std;\ntypedef long long ll;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n/* ???????????? */\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\nstruct train {\n\tPoint A, B;\n\tLine L;\n\tint o;\n\tint l;\n\ttrain() {}\n\ttrain(int xs, int ys, int xt, int yt, int o, int l) {\n\t\tA = Point(xs, ys);\n\t\tB = Point(xt, yt);\n\t\tL = Line(A, B);\n\t\tthis->o = o;\n\t\tthis->l = l;\n\t}\n};\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint T; cin >> T;\n\tfor (int t = 1; t <= T;t++) {\n\t\tint xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n\t\tPoint a(xa, ya), b(xb, yb);\n\t\tLine Bullet(a, b);\n\t\tint n; cin >> n;\n\t\tvector<train> trains;\n\t\tvector<pair<ld, int>> check_line;\n\t\tfor (int i = 0; i < n;i++) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tLine line(Point(xs, ys), Point(xt, yt));\n\t\t\tif (isis_ss(Bullet, line)) {\n\t\t\t\ttrains.push_back(train(xs, ys, xt, yt, o, l));\n\t\t\t\tPoint cross_v = is_ll(Bullet, line);\n\t\t\t\tld dist = (cross_v.real() - xa)*(cross_v.real() - xa) + (cross_v.imag() - ya)*(cross_v.imag() - ya);\n\t\t\t\tcheck_line.push_back({ dist,trains.size() - 1 });\n\t\t\t}\n\t\t}\n\t\tsort(check_line.begin(), check_line.end());\n\n\t\tint c = 0;\n\t\tint pre_l = -1;\n\t\tfor (int i = 0; i < check_line.size();i++) {\n\t\t\tint next_o = trains[check_line[i].second].o;\n\t\t\tint next_l = trains[check_line[i].second].l;\n\t\t\tif (i == 0) {\n\t\t\t\tpre_l = (next_o == 0) ? (next_l == 0 ? 1 : 0) : next_l;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint check_l = (next_o == 0) ? (next_l == 0 ? 1 : 0) : next_l;\n\t\t\tif (pre_l != check_l) {\n\t\t\t\tpre_l = check_l;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tcout << c << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& p,const Point& q){\n  return real(conj(p)*q);\n}\n\ndouble det(const Point& p,const Point& q){\n  return imag(conj(p)*q);\n}\n\nbool on_seg(const Point& p1,const Point&p2,\n\t    const Point& q){\n  return abs(det(p1-q,p2-q)) <= EPS && dot(p1-q,p2-q) <= 0;\n}\n\ndouble compute_scale(const Point& p1,const Point& p2,\n\t     const Point& q1,const Point& q2) {\n  return det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nPoint compute_intersection(const Point& p1,const Point& p2,\n\t\t\t   const Point& q1,const Point& q2) {\n  return p1 + (p2-p1) * det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nint compute_location(int owner,int location){\n  //owner 1:me 0:other\n  //location 1:high way 0:under ground\n  if(owner == 1){\n    return location;\n  }\n  else if(owner == 0){\n    return !location;\n  }\n}\n\nint main(){\n  int total_dataset = 0;\n  while(~scanf(\"%d\",&total_dataset)){\n    for(int dataset_idx=0;dataset_idx<total_dataset;dataset_idx++){\n      int xa,ya,xb,yb;\n      scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n      Point p1(xa,ya);\n      Point p2(xb,yb);\n\n      int n;\n      scanf(\"%d\",&n);\n\t\n      vector<pair<double,int> > intersections;\n      for(int i=0;i<n;i++){\n\tint xs,ys,xt,yt,owner,location;\n\tscanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&owner,&location);\n\tPoint p3(xs,ys);\n\tPoint p4(xt,yt);\n\tPoint intersection = compute_intersection(p1,p2,p3,p4);\n\t\n\tif(!on_seg(p1,p2,intersection)) continue;\n\tdouble scale = compute_scale(p1,p2,p3,p4);\n\tint next_location = compute_location(owner,location);\n\n\tpair<double,int> tmp(scale,next_location);\n\tintersections.push_back(tmp);\n      }\n\n      sort(intersections.begin(),intersections.end());\n      int prev = -1;\n      int res = -1;\n      for(int i=0;i<intersections.size();i++){\n\tif(prev != intersections[i].second) res++;\n\tprev = intersections[i].second;\n      }\n      printf(\"%d\\n\",res);\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nusing namespace std;\nvector<pair<pair<double,double>,bool> > cp;\npair<double,double> relv(pair<double,double> a,pair<double,double> b)\n{\n  return make_pair(a.first-b.first,a.second-b.second);\n}\ndouble cross(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.second-va.second*vb.first;\n}\nvoid crosspoint(pair<double,double> a,pair<double,double> b,pair<double,double> c,pair<double,double> d,bool e)\n{\n  auto ab=relv(a,b),cd=relv(c,d);\n  if(!(cross(ab,relv(a,c))*cross(ab,relv(a,d)) < 0 &&\n       cross(cd,relv(c,a))*cross(cd,relv(c,b)) < 0)) return;\n  double midrat=cross(cd,relv(c,a))/(cross(cd,relv(c,a))+cross(cd,relv(b,d)));\n  cp.push_back(make_pair(make_pair(a.first+midrat*ab.first,a.second+midrat*ab.second),e));\n}\n\nint main(void)\n{\n  cout << fixed << setprecision(10) << endl;\n  int n;\n  cin >> n;\n  REP(i,n){\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    pair<double,double> s,e;\n    s=make_pair(sx,sy),e=make_pair(ex,ey);\n    cp.clear();\n    int m;\n    cin >> m;\n    REP(i,m){\n      int x[2],y[2],p,q;\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> p >> q;\n      crosspoint(s,e,make_pair(x[0],y[0]),make_pair(x[1],y[1]),p==q);\n    }\n    SORT(cp);\n    int answer=0;\n    REP(i,cp.size()-1) if(cp[i].second!=cp[i+1].second) ++answer;\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (11111)\nstruct F{\n  double a,b;\n  bool ng;\n\n  double xs,ys,xt,yt;\n  F(int xs,int ys,int xt,int yt)\n  {\n    this->xs = (double)xs;\n    this->ys = (double)ys;\n    this->xt = (double)xt;\n    this->yt = (double)yt;\n    if(xt-xs==0){\n      ng = true;\n      a = INF;\n      b = INF;\n      return;\n    }\n    ng = false;\n    a = (this->yt-this->ys)/(this->xt-this->xs);\n    b = this->ys - a * this->xs;\n  }\n};\nint N;\nvector<PP> s;\n//vector<F> f;\ninline double abd(double a){ return a>0?a:-a; };\ninline void Fcheck(F a, F b,double& x,double& y){\n  if(a.ng){\n    if(b.ng){\n      x = INF;\n      y = INF;\n    }else{\n      x = a.xs;\n      y = b.ys+(a.xs-b.xs)*b.a;\n    }\n  }else if(b.ng){\n    if(a.ng){\n      x = INF;\n      y = INF;\n    }else{\n      x = b.xs;\n      y = a.ys+(b.xs-a.xs)*a.a;\n    }\n  }else if(b.a==a.a){\n    x = INF;\n    y= INF;\n  }else{\n    y =  (a.b*(-b.a) - b.b*(-a.a))/(-b.a - (-a.a));\n    x =  (b.b - a.b)/(-b.a - (-a.a));\n  }\n\n  if( !((double)min(a.xs,a.xt) <= x && (double)max(a.xs,a.xt) >= x &&\n\t(double)min(a.ys,a.yt) <= y && (double)max(a.ys,a.yt) >= y ) ){\n    x = INF;\n    y = INF;\n  }\n\n\t//Y=（ａ１ｃ２−ａ２ｃ１）／（ａ１ｂ２−ａ２ｂ１）\n}\nmain(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int xa,ya,xb,yb;\n    scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n    F fs = F(xa,ya,xb,yb);\n    double nx = (double)min(xa,xb);\n    double ny = (double)min(ya,yb);\n    double xx = (double)max(xa,xb);\n    double xy = (double)max(ya,yb);\n    //    printf(\"y = %lfx + %lf\\n\",fs.a,fs.b);\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int xs,ys,xt,yt,o,l;\n      scanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&o,&l);\n      F f = F(xs,ys,xt,yt);\n      //     printf(\"y = %lfx + %lf\\n\",f.a,f.b);\n      double X,Y;\n      Fcheck(f,fs,X,Y);\n      //      printf(\"X=%lf : Y=%lf\\n\",X,Y);\n      if(nx <= X && xx >= X && \n\t  ny <= Y && xy >= Y){\n\t//\tprintf(\"input : k=%lf \\n\",sqrt((X-fs.xs)*(X-fs.xs)+(Y-fs.ys)*(Y-fs.ys)));\n\ts.push_back(PP(sqrt((X-fs.xs)*(X-fs.xs)+(Y-fs.ys)*(Y-fs.ys)),P(o,l)));\n      }\n    }\n    sort(s.begin(),s.end());\n\n    /*     for(int i=0;i<s.size();i++)\n\t  printf(\"xk=%lf, o=%d, l=%d\\n\",s[i].first,s[i].second.first,s[i].second.first);\n    */\n    int count=0;\n    int res=0;\n    int R;\n    if(!s.empty()){\n      if(!s[0].second.first){\n\tif(s[0].second.second)\n\t  R = 0;\n\telse\n\t  R = 1;\n      }\n      else{\n\tif(s[0].second.second)\n\t  R = 1;\n\telse\n\t  R = 0;\n      }\n      for(int i=1;i<s.size();i++){\n\tif(s[i].second.second == R){\n\t  if(!s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}else{\n\t  if(s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}\n      }\n      res = count;\n\n      count = 0;\n      if(!s[s.size()-1].second.first){\n\tif(s[0].second.second)\n\t  R = 0;\n\telse\n\t  R = 1;\n      }\n      else{\n\tif(s[s.size()-1].second.second)\n\t  R = 1;\n\telse\n\t  R = 0;\n      }\n      for(int i=s.size()-2;i>-1;i--){\n\tif(s[i].second.second == R){\n\t  if(!s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}else{\n\t  if(s[i].second.first){\n\t    R = (++R)%2;\n\t    count++;\n\t  }\n\t}\n      }\n      res = min(res,count);\n      s.clear();\n    }\n\n    printf(\"%d\\n\",res);\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//38\n#include<vector>\n#include<iostream>\n#include<complex>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct C{\n  P p;\n  int o,l;\n  bool operator<(C a)const{\n    return p.real()<a.p.real();\n  }\n};\n\ndouble cr(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint main(){\n  int t;\n  cin>>t;\n  while(t--){\n    double xa,ya,xb,yb;\n    cin>>xa>>ya>>xb>>yb;\n    P a=P(xa,ya),b=P(xb,yb);\n    int n;\n    cin>>n;\n    vector<C> c;\n    while(n--){\n      double xs,ys,xt,yt;\n      int o,l;\n      cin>>xs>>ys>>xt>>yt>>o>>l;\n      P s=P(xs,ys),t=P(xt,yt);\n      if(cr(a-s,t-s)*cr(b-s,t-s)<0&&cr(s-a,b-a)*cr(t-a,b-a)<0){\n\tdouble d1=fabs(cr(t-s,a-s));\n\tdouble d2=fabs(cr(t-s,b-s));\n\tP cp=(b-a)*d1/(d1+d2)+a;\n\tC cc={cp,o,l};\n\tc.push_back(cc);\n      }\n    }\n    sort(c.begin(),c.end());\n    int p=-1;\n    int cn=0;\n    for(int i=0;i<c.size();i++){\n      int cp=c[i].o==c[i].l;\n      cn+=p!=cp;\n      p=cp;\n    }\n    cout<<(c.empty()?0:cn-1)<<endl;\n  }\n  return 0;\n}\n      "
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nusing namespace std;\nvector<pair<pair<double,double>,bool> > cp;\npair<double,double> relv(pair<double,double> a,pair<double,double> b)\n{\n  return make_pair(a.first-b.first,a.second-b.second);\n}\ndouble cross(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.second-va.second*vb.first;\n}\nvoid crosspoint(pair<double,double> a,pair<double,double> b,pair<double,double> c,pair<double,double> d,bool e)\n{\n  auto ab=relv(a,b),cd=relv(c,d);\n  if(!(cross(ab,relv(a,c))*cross(ab,relv(a,d)) < 0 &&\n       cross(cd,relv(c,a))*cross(cd,relv(c,b)) < 0)) return;\n  double midrat=cross(cd,relv(c,a))/(cross(cd,relv(c,a))+cross(cd,relv(b,d)));\n  cp.push_back(make_pair(make_pair(a.first+midrat*ab.first,a.second+midrat*ab.second),e));\n}\n\nint main(void)\n{\n  cout << fixed << setprecision(10) << endl;\n  int n;\n  cin >> n;\n  REP(i,n){\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    pair<double,double> s,e;\n    s=make_pair(sx,sy),e=make_pair(ex,ey);\n    cp.clear();\n    int m;\n    cin >> m;\n    REP(i,m){\n      int x[2],y[2],p,q;\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> p >> q;\n      crosspoint(s,e,make_pair(x[0],y[0]),make_pair(x[1],y[1]),p==q);\n    }\n    SORT(cp);\n    int answer=0;\n    REP(i,(int)cp.size()-1) if(cp[i].second!=cp[i+1].second) ++answer;\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst double EPS = 1e-10;\n\ndouble intersect(double xa, double ya, double xb, double yb, double xc, double yc, double xd, double yd){\n    double g =  (xb - xa)*(yd - yc) - (yb - ya)*(xd - xc);\n    if (fabs(g) < EPS) return -1;\n    double r = ((yd - yc)*(xc - xa) - (xd - xc)*(yc - ya)) / g;\n    double s = ((yb - ya)*(xc - xa) - (xb - xa)*(yc - ya)) / g;\n    if (r < 0 || r > 1 || s < 0 || s > 1) return -1;\n    return r;\n}\n\nint calc(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int n;\n    cin >> n;\n    vector<pair<double, int> > a;\n    while (n--){\n        double xs, ys, xt, yt;\n        int p, q;\n        cin >> xs >> ys >> xt >> yt >> p >> q;\n        double r = intersect(xa, ya, xb, yb, xs, ys, xt, yt);\n        if (r > 0 && r < 1){\n            a.push_back(make_pair(r, p^q));\n        }\n    }\n    sort(a.begin(), a.end());\n    if (a.size() <= 1) return 0;\n    int ans = 0;\n    REP(i,a.size()-1){\n        if (a[i].second != a[i+1].second) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int m;\n    cin >> m;\n    while (m--){\n        cout << calc() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\ntypedef long long ll;\n\n\n\nstruct Point{double x,y,mine,high;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nbool Intersection(Point p1,Point p2,Point p3,Point p4,Point *cross){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    if (d == 0) return false;\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if (u<0.0 || u>1.0 || v<0.0 || v>1.0)return false;\n    Point *res;\n    res->x = p1.x + u * (p2.x - p1.x);\n    res->y = p1.y + u * (p2.y - p1.y);\n    res->high = (p3.mine == p3.high);\n\n    return true;\n}\n\nint main(void){\n    int N,xa,ya,xb,yb,n,xs,ys,xt,yt,o,l;\n    cin>>N;\n    while(N--){\n        vector<Point> cross;\n        cin>>xa>>ya>>xb>>yb>>n;\n        Point a = {xa,ya,true,true};\n        Point b = {xb,yb,true,true};\n        rep(i,n){\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            Point s = {xs,ys,o,l};\n            Point t = {xt,yt,o,l};\n            Point res;\n            if(Intersection(a,b,s,t,&res)){\n                cross.push_back(res);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\n//???\nclass Point\n{\n    public:\n    double x,y;\n\n    Point(double x=0, double y=0): x(x), y(y) {}\n\n    Point operator + (Point p)\n    {\n        return Point(x+p.x, y+p.y);\n    }\n    Point operator - (Point p)\n    {\n        return Point(x-p.x, y-p.y);\n    }\n    Point operator * (double a)\n    {\n        return Point(a*x,a*y);\n    }\n\n};\n\n//????????????\ntypedef Point Vector;\n\n//??????\nstruct Segment\n{\n    Point p1,p2;\n};\n\ndouble dist(Point p0, Point p1)\n{\n    return sqrt((p0.x-p1.x)*(p0.x-p1.x) + (p0.y-p1.y)*(p0.y-p1.y));\n}\n\n//??????\ndouble dot(Vector a, Vector b)\n{\n    return a.x*b.x+a.y*b.y;\n}\n\n//??????\ndouble cross(Vector a, Vector b)\n{\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble EPS=1e-9;\n\ndouble norm(Vector a)\n{\n    return a.x*a.x+a.y*a.y;\n}\n\nint ccw(Point p0, Point p1, Point p2)\n{\n    Vector a=p1-p0, b=p2-p0;\n    if(cross(a,b)>EPS) return 1;\n    if(cross(a,b)<-EPS) return -1;\n    if(dot(a,b)<-EPS) return 2;\n    if(norm(a)<norm(b)) return -2;\n\n    return 0;\n}\n\n//????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n    return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n    Vector base=s2.p2-s2.p1;\n    double d1=fabs(cross(base, s1.p1-s2.p1));\n    double d2=fabs(cross(base, s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\n//?§??????????????????¢,?????¶or??°???(0/1)\ntypedef pair<double,int> P;\n\nint main()\n{\n    int t;\n    cin >>t;\n    rep(T,t)\n    {\n        Segment newline;\n        cin >>newline.p1.x >>newline.p1.y >>newline.p2.x    >>newline.p2.y;\n\n        int n;\n        cin >>n;\n\n        vector<Segment> line(n);\n        vector<int> o(n),l(n);\n        rep(i,n) cin >>line[i].p1.x >>line[i].p1.y >>line[i].p2.x >>line[i].p2.y >>o[i] >>l[i];\n\n        //cross points\n        vector<P> cps;\n\n        //i???????????????????????????\n        rep(i,n)\n        {\n            //??°????????¨????????????????????????\n            if(intersect(newline,line[i]))\n            {\n                Point cp=getCrossPoint(newline,line[i]);\n                cps.pb(P(dist(newline.p1,cp),(o[i]==l[i])));\n            }\n        }\n\n        sort(all(cps));\n\n        int ans=0;\n        if(cps.size()>0)\n        {\n            rep(i,cps.size()-1)\n            {\n                if(cps[i].se!=cps[i+1].se) ++ans;\n            }\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,pair<int,int> > CP;\n\nconst double PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + (a.sc-a.fs)*( d /(d * abs(cross(b.sc-b.fs,a.sc-b.fs))) );\n}\n\nint main(){\n  int t,n;\n  int xa,ya,xb,yb;\n  int xs[110],ys[110],xt[110],yt[110],o[110],l[110];\n\n  cin >> t;\n\n  while(t--){\n    cin >> xa >> ya >> xb >> yb;\n    cin >> n;\n    for(int i=0;i<n;i++)cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n   \n    vector<CP> cp;\n    L nl = L(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;i++){\n      L tmpl = L(P(xs[i],ys[i]),P(xt[i],yt[i]));\n      if( is_cp(nl,tmpl) )cp.push_back(CP(seg_cp(nl,tmpl),make_pair(o[i],l[i])));\n    }\n    sort(cp.begin(),cp.end());\n    \n    int ans = 0;\n    for(int i=1;i<(int)cp.size();i++){\n      if( (cp[i-1].sc.fs==cp[i].sc.fs)^(cp[i-1].sc.sc==cp[i].sc.sc) )ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nstruct Point{double x,y; bool high;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nPoint* Intersection(Point p1,Point p2,Point p3,Point p4,bool high){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(d==0 || u<0 || u>1 || v<0 || v>1) return NULL;\n    return new Point{p1.x+u*(p2.x-p1.x), p1.y+u*(p2.y-p1.y), high};\n}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n            Point *ret = Intersection(a,b,s,t,o==l);\n            if(ret!=NULL)cross.push_back(*ret);\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<(int)cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nint main(){\n  int T; cin>>T;\n  int xa,ya,xb,yb;\n  while(cin>>xa>>ya>>xb>>yb){\n    L newline(P(xa,ya),P(xb,yb));\n    vector< pair<P,int> > cps;\n    int n; cin>>n;\n    while(n--){\n      int x1,y1,x2,y2,o,l;\n      cin>>x1>>y1>>x2>>y2>>o>>l;\n      L ln(P(x1,y1),P(x2,y2));\n      if(intersectLL(newline, ln)){\n        cps.push_back(make_pair(crosspoint(newline,ln)-newline[0], o ^ l));\n      }\n    }\n    sort(cps.begin(), cps.end());\n\n    int ans = 0;\n    FOR(i,1,cps.size()){\n      if(cps[i].second != cps[i-1].second)ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef pair<P,bool> Q;\nD eps=1e-12;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool comp(const Q& xx,const Q& yy){\n\tP x=xx.fs,y=yy.fs;\n\tif(abs(x.real()-y.real())<eps){\n\t\treturn x.imag()<y.imag();\n\t}else{\n\t\treturn x.real()<y.real();\n\t}\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\tvector<Q> vc;\n\t\tD ax,ay,bx,by;\n\t\tint N;\n\t\tcin>>ax>>ay>>bx>>by>>N;\n\t\tL l=L(P(ax,ay),P(bx,by));\n\t\trep(i,N){\n\t\t\tD a,b,c,d;\n\t\t\tbool e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tL s=L(P(a,b),P(c,d));\n\t\t\tif(iSS(l,s)){\n\t\t\t\tvc.pb(Q(intLL(l,s),e^f));\n\t\t\t}\n\t\t}\n\t\tif(vc.size()==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(vc),comp);\n\t\tint ans=0;\n\t\tbool now=vc[0].sc;\n\t\trep(i,vc.size()){\n\t\t\tif(now^vc[i].sc){\n\t\t\t\tans++;\n\t\t\t\tnow=vc[i].sc;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#include<algorithm>\n#include<array>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\ntypedef double Real;\nconst Real EPS = 1e-8;\nint sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\n//define class ...\n\nstruct Point {\n\tReal x, y;\n\texplicit Point(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(Real s) const { return Point(x * s, y * s); }\n\tPoint operator/(Real s) const { return Point(x / s, y / s); }\n\tbool operator<(const Point &p) const {\n\t\treturn sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1);\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn sign(x - p.x) == 0 && sign(y - p.y) == 0;\n\t}\n};\n\nstruct Entrance {\n\tReal dist;\n\tint o, l;\n\texplicit Entrance(Real dist_, int o_, int l_):dist(dist_), o(o_), l(l_) {}\n\tbool operator<(const Entrance &e) const {\n\t\treturn dist < e.dist;\n\t}\n};\n\nistream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\nstruct Line : public array<Point, 2> { //??????\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> { //??´???\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Circle {\n\tPoint c;\n\tReal r;\n\tCircle(const Point &c_, Real r_): c(c_), r(r_) {}\n};\n\ntypedef vector<Point> Polygon;\n\n// define function\nPoint rotate90(const Point &p) { // ???????¨???¨???\n\treturn Point(-p.y, p.x);\n}\n\nPoint rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nReal angle(const Point &p) {\n\treturn atan2(p.y, p.x);\n}\n\nReal norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nReal abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\nReal dot(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool is_parallel(const Line &a, const Line &b) {\n\treturn sign( cross(a[1] - a[0], b[1] - b[0]) ) == 0;\n} \n\n// define app function\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst Real crs = cross(p, q); \n\t\n\tif(sign(crs) == 1) return CCW;\n\tif(sign(crs) == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a, b) / norm(b));\n}\n\nPoint reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t - p);\n}\n\nbool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\nbool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n\treturn abs(ccw(l[0], l[1], p)) != 1;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n\treturn sign(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0])) <= 0; \n}\n\nbool intersect(const Line &a, const Line &b) {\n\treturn sign(cross(a[1] - a[0], b[1] - b[0])) != 0\n\t\t\t|| sign(cross(a[1] - a[0], b[1] - a[0])) == 0;\n}\n\nReal dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\n\nReal dist(const Line &l, const Point &p) {\n\tconst Point a = l[1] - l[0];\n\tconst Point b = p - l[0];\t\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nReal dist(const Line &l, const Segment &s) {\n\tif(intersect(l, s)) return 0;\n\treturn min(dist(l, s[0]), dist(l, s[1]));\n}\n\nReal dist(const Line &a, const Line & b) {\n\tif(intersect(a, b)) return 0;\n\treturn dist(a, b[0]);\n}\n\nReal dist(const Segment &s, const Point &p) {\n\tif(sign(dot(s[1] - s[0], p - s[0])) == -1) return dist(s[0], p);\n\tif(sign(dot(s[0] - s[1], p - s[1])) == -1) return dist(s[1], p);\n\treturn dist(Line(s[0], s[1]), p);\n}\n\nReal dist(const Segment &a, const Segment &b) {\n\tif(intersect(a, b)) return 0;\n\treturn min({dist(a, b[0]), dist(a, b[1]), dist(b, a[0]), dist(b, a[1])});\t\n}\n\nbool intersect(const Circle &a, const Circle &b) {\n\treturn sign(dist(a.c, b.c) - (a.r + b.r)) <= 0\n\t\t&& sign(dist(a.c, b.c) - abs(a.r - b.r)) >= 0;\n}\n\nbool intersect(const Circle &c, const Segment &s) {\n\treturn sign(dist(s, c.c) - c.r) <= 0;\n}\n\nbool intersect(const Circle &c, const Line &l) {\n\treturn sign(dist(l, c.c) - c.r) <= 0;\n}\n\nbool contain(const Circle &c, const Point &p) {\n\treturn sign(dist(c.c, p) - c.r) <= 0;\n}\n\nint contain(const Polygon &P, const Point &p) {\n\tbool res = 0;\n\tfor(int i = 0; i < P.size(); ++i) {\n\t\tPoint v1 = P[i] - p;\n\t\tPoint v2 = P[(i + 1) % P.size()] - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\n\t\tif(sign(cross(v1, v2)) == 0 && sign(dot(v1, v2)) <= 0) {\n\t\t\treturn 1; //on edge\n\t\t}\n\t\tif(sign(v1.y) <= 0 && sign(v2.y) == 1 && sign(cross(v1, v2)) == 1) {\n\t\t\tres = !res;\n\t\t}\n\t}\n\treturn (res ? 2 : 0);\n}\n\nPoint crosspoint(const Line &a, const Line &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) return a[0];\t// same line\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\n// ???????????????????????¨?????°????????§???????????????intersect????????????\nPoint crosspoint(const Segment &a, const Segment &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) { //on same line\n\t\tif(intersect(a, b[0])) return b[0];\n\t\tif(intersect(a, b[1])) return b[1];\n\t\tif(intersect(b, a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\nvector<Point> crosspoint(const Circle &c, const Line &l) {\n\tconst Point p = project(l, c.c);\n\tconst Real h = dist(p, c.c);\n\n\tvector<Point> res;\n\tif(sign(h - c.r) == 1) {\n\t\t// nothing\n\t}\n\telse if(sign(h - c.r) == 0) {\n\t\tres.emplace_back(p);\n\t}\n\telse {\n\t\tconst Real b = sqrt(c.r * c.r - h * h);\n\t\tconst Point e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\t\tres.emplace_back(p + e * b);\n\t\tres.emplace_back(p - e * b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &c, const Segment &s) {\n\tvector<Point> res;\n\tfor(const Point &p : crosspoint(c, Line(s[0], s[1]))) {\n\t\tif(intersect(s, p)) res.emplace_back(p);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a, const Circle &b) {\n\tif(!intersect(a, b)) return vector<Point>();\n\tvector<Point> res;\n\tconst Real d = dist(a.c, b.c);\n\n\tif(sign(d - (a.r - b.r)) == 0) {\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r / abs(v))));\n\t}\n\telse {\n\t\tconst Real theta = acos((a.r * a.r + d * d - b.r * b.r) / (2 * a.r * d));\n\t\tconst Real phi = angle(b.c - a.c);\n\t\tres.emplace_back(a.c + rotate(Point(a.r, 0), phi + theta));\n\t\tres.emplace_back(a.c + rotate(Point(a.r, 0), phi - theta));\n\t}\n\treturn res;\n}\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tint T; \n\tcin >> T;\n\trep(nth, T)\t {\n\t\tPoint a, b, s, t;\n\t\tint n, o, l;\t\n\t\tcin >> a >> b;\n\t\tcin >> n;\n\n\t\tSegment s0 = Segment(a, b);\t\n\t\tvector<Entrance> res;\t\n\t\trep(i, n) {\n\t\t\tcin >> s >> t;\n\t\t\tcin >> o >> l;\n\t\t\tSegment si = Segment(s, t);\n\t\t\tif(!intersect(s0, si)) continue;\n\t\t\tPoint c = crosspoint(s0, si);\t\n\t\t\tres.push_back(Entrance(dist(a, c), o, l));\t\t\t\n\t\t}\n\t\n\t\tint ans = 0;\t\n\t\tif(res.size() != 0) {\n\t\t\tint prev = (res[0].o == 1) ? 1 : 0;\n\t\t\trep(i, res.size()) {\n\t\t\t\tif((res[i].o == 1 && res[i].l != prev) || (res[i].o == 0 && res[i].l == prev)) {\n\t\t\t\t\t++ans;\t\n\t\t\t\t\tprev = !prev;\n\t\t\t\t}\t\n\t\t\t}\n\t\t} \t\n\t\tcout << ans << endl;\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "fow"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\nSeg side_G(const G& g, int i)\n{\n    return Seg(g[i], g[(i + 1) % g.size()]);\n}\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n/////////////////// \n\n\nint main()\n{\n    fast_io();\n\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        Seg s;\n        cin >> s.first >> s.second;\n        Point rota(1, -arg(s.second - s.first));\n        s.first *= rota, s.second *= rota;\n        \n        \n        vector<pair<Point, bool> > c;\n        int n;\n        cin >> n;\n        rep(i, n)\n        {\n            Seg t;\n            int o, l;\n            cin >> t.first >> t.second >> o >> l;\n            t.first *= rota, t.second *= rota;\n            if (intersect_SS(s, t))\n                c.pb(mp(ip_SS(s, t), (o ^ l)));\n        }\n        sort(all(c));\n\n        int res = 0;\n        rep(i, (int)c.size() - 1)\n            if (c[i].second != c[i + 1].second)\n                ++res;\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\ntypedef pair<double, int> P;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator <(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\nclass Line {\npublic:\n\tPoint a, b;\n\tint own;//a?????????1 b?????????0\n\tint pos;//?????¶??????1 ??°?????????0\n\tLine():a(Point(0,0)),b(Point(0,0)),own(-1),pos(-1){}\n\tLine(Point a, Point b,int own,int pos) :a(a), b(b),own(own),pos(pos) {}\n};\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;//a,b,c??????????¨???????\n\tif (cross(b, c) < -eps) return - 1;//a,b,c???????¨???????\n\tif (dot(b, c) < 0) return 2;//c,a,b????????§??´??????\n\tif (norm(b) < norm(c)) return -2;//a,b,c????????§??´??????\n\treturn 0;//a,c,b??§??´??????\n}\n\nbool isis_ss(Line s, Line t) {//????????¨?????????????????????\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_sp(Line s, Point p) {//?????????????????????\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint is_ll(Line s, Line t) {//??´?????¨??´????????????\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv*cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint num; cin >> num;\n\twhile (num--) {\n\t\tld xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n\t\tPoint a(xa, ya), b(xb, yb);\n\t\tint n; cin >> n;\n\t\tvector<Line> rosen;//????????¨??¨\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tld xs, ys, xt, yt; int o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tPoint s(xs, ys), t(xt, yt);\n\t\t\tLine li(s, t, o, l);\n\t\t\trosen.push_back(li);\n\t\t}\n\t\tLine route(a, b, 1, -1);//?§??????????\n\t\tvector<P> lines;//P(?????¢???index) ???????????????????????????\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (cross(route.b - route.a, rosen[i].b - rosen[i].a) == 0) continue;\n\t\t\tif (isis_ss(route, rosen[i])) {\n\t\t\t\tPoint kouten = is_ll(route, rosen[i]);\n\t\t\t\tdouble dis = norm(route.a - kouten);\n\t\t\t\tlines.push_back(P(dis, i));\n\t\t\t}\n\t\t}\n\t\tsort(lines.begin(), lines.end());\n\t\tint res = 0, pos;\n\t\tif (lines.size() == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint idx = lines[0].second;\n\t\tif (rosen[idx].own == 1) {\n\t\t\tpos = rosen[idx].pos;\n\t\t}\n\t\telse {\n\t\t\tpos = 1 - rosen[idx].pos;\n\t\t}\n\t\tfor (int i = 0; i < (int)lines.size(); i++) {\n\t\t\tint idx = lines[i].second;\n\t\t\t//cout << idx<<\" \"<<pos << \" \" << rosen[idx].own << \" \" << rosen[idx].pos << endl;\n\t\t\tif (rosen[idx].own == 1) {\n\t\t\t\tif (rosen[idx].pos == pos) continue;\n\t\t\t\telse {\n\t\t\t\t\tpos = 1 - pos;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (rosen[idx].pos != pos) continue;\n\t\t\t\telse {\n\t\t\t\t\tpos = 1 - pos;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << i<<\" \"<<pos << endl;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nusing Point = std::complex<ld>;\nconst ld pi = acos(-1.0);\nnamespace std {\nbool operator<(const Point &lhs, const Point &rhs) {\n  if (lhs.real() < rhs.real() - eps) return true;\n  if (lhs.real() > rhs.real() + eps) return false;\n  return lhs.imag() < rhs.imag();\n}\n}\nPoint input_point() {\n  ld x, y;\n  std::cin >> x >> y;\n  return Point(x, y);\n}\nbool eq(ld a, ld b) { return (abs(a - b) < eps); }\nld dot(Point a, Point b) { return real(conj(a) * b); }\nld cross(Point a, Point b) { return imag(conj(a) * b); }\nint ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nclass Line {\n public:\n  Point a, b;\n  Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line(Point a, Point b) : a(a), b(b) {}\n};\nld dot(Line l, Line m) { return dot((l.a - l.b), (m.a - m.b)); }\nbool isis_ll(Line l, Line m) { return !eq(cross(l.b - l.a, m.b - m.a), 0); }\nbool isis_ls(Line l, Line s) {\n  return isis_ll(l, s) &&\n         (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nbool isis_lp(Line l, Point p) { return (abs(cross(l.b - p, l.a - p)) < eps); }\nbool isis_sp(Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nPoint proj(Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\nPoint is_ll(Line l, Line m) {\n  Point lv = l.b - l.a, mv = m.b - m.a;\n  assert(cross(lv, mv) != 0);\n  return l.a + lv * cross(mv, m.a - l.a) / cross(mv, lv);\n}\nld dist_lp(Line l, Point p) { return abs(p - proj(l, p)); }\nld dist_ll(Line l, Line m) { return isis_ll(l, m) ? 0 : dist_lp(l, m.a); }\nld dist_ls(Line l, Line s) {\n  return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\nld dist_sp(Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : std::min(abs(s.a - p), abs(s.b - p));\n}\nld dist_ss(Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return std::min(\n      {dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\nLine bisector(Point a, Point b) {\n  Point mid = (a + b) * Point(0.5, 0);\n  return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\nld degree_ll(Line l, Line m) {\n  ld cos_shita = dot(l, m) / (abs(l.b - l.a) * abs(m.b - m.a));\n  if (cos_shita < -1.0) cos_shita = -1.0;\n  if (cos_shita > 1.0) cos_shita = 1.0;\n  ld shita = acos(cos_shita);\n  return shita;\n}\nvoid solve() {\n  auto p1 = input_point();\n  auto p2 = input_point();\n  Line newl(p1, p2);\n  int n; cin >> n;\n  vector<pair<Line, int>> v(n);\n  for(int i=0;i<n;++i) {\n    auto p1 = input_point();\n    auto p2 = input_point();\n    Line l(p1, p2);\n    int a, b; cin >> a >> b;\n    v[i] = {l, a ^ b};\n  }\n  vector<pair<double, int>> d;\n  for(int i=0;i<n;++i) {\n    if(isis_ss(newl, v[i].first)) {\n      d.push_back({abs(newl.a - is_ll(newl, v[i].first)), i});\n    }\n  }\n  sort(d.begin(), d.end());\n  int cnt = 0;\n  for(int i=0;i<(int)(d.size())-1;++i) {\n    cnt += (v[d[i].second].second != v[d[i+1].second].second);\n  }\n  cout << cnt << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int q; cin >> q;\n  while(q) {\n    q--;\n    solve();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define FOR(i, s, n) for (int i = (s); i < (n); i++)\n#define RFOR(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define ALL(a) a.begin(),a.end()\n#define IN(a,x,b) (a<=x && x<b)\nconst long long MOD = 1e9+7, INF = 1e18;\ntemplate<class T>inline bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\ndouble EPS = 1e-10;\n\ndouble add(double a,double b){\n\tif(abs(a+b)<EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\n\n\nstruct P{\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator +(P p){\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator -(P p){\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tdouble dot(P p){//内積\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){//外積\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\n//交差判定\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0&&(p1-q).dot(p2-q)<=0;\n}\n\n//交差座標\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1 + (p2-p1) * ((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nint solve(){\n\tint xa,ya,xb,yb;\n\tint N;\n\tcin>>xa>>ya>>xb>>yb>>N;\n\tauto st = P(xa,ya);\n\tauto en = P(xb,yb);\n\tvector<pair<double,pair<int,int>>>kousa;\n\tint XS,YS,XT,YT,O,L;\n\tREP(i,N){\n\t\tcin>>XS>>YS>>XT>>YT>>O>>L;\n\t\tauto S = P(XS,YS);\n\t\tauto T = P(XT,YT);\n\t\tif((st-en).det(S-T)==0)continue;\n\t\tP r = intersection(st,en,S,T);\n\t\tif(on_seg(S,T,r)&&on_seg(st,en,r))kousa.push_back({r.x,{O,L}});\n\t}\n\tsort(ALL(kousa));\n\tvector<int>now;\n\tfor(auto e:kousa){\n\t\tnow.push_back(e.second.first==e.second.second);\n\t\tif(now.size()>=2&&now[now.size()-1]==now[now.size()-2])now.pop_back();\n\t}\n\treturn max(0ll,(int)now.size()-1ll);\n}\n\nsigned main(){\n\tint N;\n\tcin>>N;\n\tvector<int>ans;\n\tREP(i,N)ans.push_back(solve());\n\tfor(auto e:ans)cout<<e<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<double, int> pdi;\n\nstruct point { double x, y; };\nstruct line { point p, q; };\n\nint T, N, O[110], L[110];\nline A, S[110];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double ux = l.q.x - l.p.x;\n  double uy = l.q.y - l.p.y;\n  double vx = p.x - l.p.x;\n  double vy = p.y - l.p.y;\n  double cross = abs(ux * vy - uy * vx);\n  double ul = sqrt(ux * ux + uy * uy);\n  return cross / ul;\n}\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> A.p.x >> A.p.y >> A.q.x >> A.q.y;\n    cin >> N;\n    REP(i, 0, N) cin >> S[i].p.x >> S[i].p.y >> S[i].q.x >> S[i].q.y >> O[i] >> L[i];\n\n    double d = sqrt((A.p.x - A.q.x) * (A.p.x - A.q.x) + (A.p.y - A.q.y) * (A.p.y - A.q.y));\n\n    vector<pdi> E;\n    REP(i, 0, N) if(intersect(A, S[i])) {\n      double da = distance(S[i], A.p);\n      double db = distance(S[i], A.q);\n      double dx = d * da / (da + db);\n      E.push_back(pdi(dx, i));\n    }\n\n    sort(E.begin(), E.end());\n\n    vector<int> g;\n    REP(i, 0, E.size()) {\n      int k = E[i].second;\n      g.push_back(O[k] == 1 ? L[k] : (L[k] ^ 1));\n    }\n\n    int ans = 0;\n    REP(i, 0, g.size() - 1) if(g[i] != g[i + 1]) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *  Railroad Conflict (Problem D, Practice Contest for Japan Domestic, 2006-06-18)\n *  by Kenji Inoue, 2007-01-07\n **/\n\n#include <iostream>\n#include <vector>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-9)\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected(P a1, P a2, P b1, P b2) {\n  return ( ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS ) );\n}\n\nP s[101], t[101];\nint c[101], l[101];\n\nstruct intersection {\n  double t; // parameter t\n  int n;    // index of intersected line\n\n  bool operator<(const intersection &a) const {\n    return (t < a.t);\n  }\n};\n\nint main() {\n  int N;\n  cin >> N;\n  while (N--) {\n    P a, b;\n    cin >> a.real() >> a.imag();\n    cin >> b.real() >> b.imag();\n\n    int n;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n      cin >> s[i].real() >> s[i].imag();\n      cin >> t[i].real() >> t[i].imag();\n      cin >> c[i] >> l[i];\n    }\n\n    vector<intersection> is;\n    for (int i=0; i<n; i++) {\n      if (!is_intersected(a, b, s[i], t[i])) { continue; }\n    //  if (abs(cross(b-a, t[i]-s[i])) < EPS) { continue; }\n\n      P x = t[i] - s[i];\n      double d1 = abs(cross(x, a-s[i]));\n      double d2 = abs(cross(x, b-s[i]));\n      double t = d1 / (d1 + d2);\n\n      intersection tmp = {t, i};\n      is.push_back(tmp);\n    }\n\n    sort(is.begin(), is.end());\n\n    int curr; // current status: up (=1) or down (=0)\n    if (is.size() > 0) {\n      int idx = is[0].n;\n      curr = (c[idx] == 1 ? l[idx] : !l[idx]);\n    }\n\n    int cnt = 0;\n    for (int i=1; i<is.size(); i++) {\n      int idx = is[i].n;\n      if ( (c[idx] == 1 && curr != l[idx]) ||\n           (c[idx] == 0 && curr == l[idx]) ) {\n        curr = !curr;\n        cnt++;\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define _USE_MATH_DEFINES\n#include<cmath>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n\n#define INF 1e+10\n#define EPS 1e-8\n#define EQ(a,b) (abs(a-b)<EPS)\n\n//ティツェツ、テ・ツキツョテ」ツつ津ィツ?εヲツ?ョテ」ツ?療」ツ?ヲティツカツウテ」ツ?療ァツョツ?\ndouble add(double a,double b){\n\tif(abs(a+b) < EPS*(abs(a)+abs(b)))return 0;\n\treturn a+b;\n}\nstruct P{//2テヲツャツ。テ・ツ?ε」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tdouble x,y;\n\tP(){}\n\tP(double x,double y):x(x),y(y){}\n\tP operator + (P p)const{\n\t\treturn P(add(x,p.x),add(y,p.y));\n\t}\n\tP operator - (P p)const{\n\t\treturn P(add(x,-p.x),add(y,-p.y));\n\t}\n\tP operator * (double d)const{\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator / (double d)const{\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p)const{//テ・ツ??ァツゥツ?\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p)const{//テ・ツ、ツ姪ァツゥツ?\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n\tbool equal(P p)const{\n\t\treturn (x-p.x)*(x-p.x)+(y-p.y)*(y-p.y) < EPS*EPS;\n\t}\n};\n//typedef pair<P,P> Line;\n\n//テァツキツ堙・ツ按?1-p2テ、ツクツ甘」ツ?ォテァツつケqテ」ツ?古」ツ?づ」ツつ凝」ツ?凝・ツ按、テ・ツョツ?\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n//テァツ崢エテァツキツ嗔1-p2テ」ツ?ィテァツ崢エテァツキツ嘔1-q2テ」ツ?ョテ、ツコツ、テァツつケ\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*( (q2-q1).det(q1-p1)/(q2-q1).det(p2-p1) );\n}\n\n\n//テァツキツ堙・ツ按?1-p2テ」ツ?ィテァツキツ堙・ツ按?1-q2テ」ツ?古、ツコツ、テ・ツキツョテ」ツ?凖」ツつ凝」ツ??\nbool exist_intersection(P p1,P p2,P q1,P q2){\n\tif(on_seg(p1,p2,q1)||on_seg(p1,p2,q2)||on_seg(q1,q2,p1)||on_seg(q1,q2,p2))return true;\n\tif((p1-p2).det(q1-q2)==0 )return false;//テ・ツケツウティツ。ツ?\n\tP a=intersection(p1,p2,q1,q2);\n\treturn on_seg(p1,p2,a) && on_seg(q1,q2,a);\n}\n//テ・ツ篠淌ァツつケテ、ツクツュテ・ツソツε・ツ崢榲ィツサツ「\nP rotate(P p,double rad){\n\tdouble s=sin(rad),c=cos(rad);\n\treturn P(c*p.x-s*p.y, s*p.x+c*p.y);\n}\n//originテ」ツつ津、ツクツュテ・ツソツε」ツ?ォテ・ツ崢榲ィツサツ「\nP rotate(P p,double rad,P origin){\n\treturn origin + rotate(p - origin,rad);\n}\n//テ、ツコツ古ァツつケテゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist(P p,P q){\n\tp = p-q;\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\n//テ・ツ債佚、ツスツ催」ツδ凖」ツつッテ」ツδ暗」ツδォテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\nP to_unit(P p){\n\tdouble d = sqrt(p.x*p.x+p.y*p.y);\n\treturn p/d;\n}\n//テ・ツ??・ツ青古・ツ」ツォテ」ツ?ョテ、ツコツ、テァツつケテ」ツつ津ィツィツ暗ァツョツ?\npair<P,P> circle_intersection(double x1,double y1,double r1,double x2,double y2,double r2){\n\tdouble rad = atan2(y2-y1,x2-x1);\n\tx2 -= x1;\n\ty2 -= y1;\n\tP tmp = rotate(P(x2,y2),-rad);\n\tx2 = tmp.x;\n\ty2 = tmp.y;\n\tdouble x = (r1*r1-r2*r2+x2*x2)/(2*x2);\n\tif(abs(r1) < abs(x))return make_pair(P(0,0),P(0,0));//テ、ツコツ、テァツつケテ」ツ?ェテ」ツ??\n\tdouble y = sqrt(r1*r1-x*x);\n\treturn make_pair( P(x1,y1)+rotate(P(x,y),rad) ,  P(x1,y1)+rotate(P(x,-y),rad) );\n}\n//2テァツつケテ」ツつ津ゥツ?堙」ツつ凝・ツ債甘・ツセツвテ」ツ?ョテ・ツ??」ツ?ョテ、ツクツュテ・ツソツε・ツコツァテヲツィツ?\nvector<P> circle_on_2P(P p,P q,double r){\n\tvector<P> res; \n\tif(2*r+EPS < dist(p,q))return res;//ティツァツ」テ」ツ?ェテ」ツ??\n\tif(q.x < p.x)swap(p,q);\n\tq = q - p;\n\tdouble rad = atan2(q.y,q.x);\n\tP tmp = rotate(q,-rad);\n\tdouble x = tmp.x/2;\n\tdouble y = sqrt(4*r*r-tmp.x*tmp.x)/2;\n\tP a = p+rotate(P(x,y),rad) , b = p+rotate(P(x,-y),rad);\n\tres.push_back(a);\n\tif(!a.equal(b))res.push_back(b);\n\treturn res;\n}\n//テァツキツ堙・ツ按?」ツ?ィテァツつケテ」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LP(P p1,P p2,P q){\n\tdouble dx,dy;\n\tdx = p1.x-p2.x;\n\tdy = p1.y-p2.y;\n\tdouble d = min(dist(p1,q) ,dist(p2,q));\n\tpair<P,P> normal = make_pair(q+to_unit(P(-dy,dx))*d ,q+to_unit(P(dy,-dx))*d);//テヲツウツ陛ァツキツ堙」ツδ凖」ツつッテ」ツδ暗」ツδォ\n\tif(exist_intersection(p1,p2,normal.first,normal.second)){\n\t\treturn dist(q, intersection(p1,p2,normal.first,normal.second));\n\t}\n\treturn d;\n}\n//テァツキツ堙・ツ按?ゥツ鳴禿」ツ?ョティツキツ敕ゥツ崢「\ndouble dist_LL(P p1,P p2,P q1,P q2){\n\tif(exist_intersection(p1,p2,q1,q2))return 0;\n\treturn min( min(dist_LP(p1,p2,q1),dist_LP(p1,p2,q2))\n\t\t,min(dist_LP(q1,q2,p1),dist_LP(q1,q2,p2)) );\n}\n//テ」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble radian(double angle){\n\treturn angle/180.0*M_PI;\n}\n\n\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ」ツ?ョテゥツ敖「テァツゥツ?\ndouble plain_area(vector<P> &poly){\n\tdouble s=0;\n\tfor(int i=0;i<poly.size();i++){\n\t\ts += poly[i].det(poly[(i+1)%poly.size()]);\n\t}\n\treturn abs(s/2);\n}\n//テ・ツ、ツ堙ィツァツ津・ツスツ「テ・ツ??ゥツδィテ」ツ?ォテァツつケpテ」ツ?古」ツ?づ」ツつ凝」ツ??\nbool contains(vector<P> &poly,P p,double inf=INF){\n\tint cnt=0;\n\tP q(p.x+inf,p.y);\n\tfor(int i=0;i<poly.size();i++){\n\t\tif(exist_intersection(poly[i],poly[(i+1)%poly.size()],p,q))cnt++;\n\t}\n\treturn cnt&1;\n}\n//テァツつケpテ」ツつ津ゥツ?堙」ツつ凝・ツ??」ツ?ョテヲツ篠・テァツキツ?\npair<P,P> tangent_CP(double x,double y,double r,P p){\n\t//P q(x,y), m((x+p.x)/2,(y+p.y)/2);\n\tdouble d=sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y))/2;\n\treturn circle_intersection(x,y,r,(x+p.x)/2,(y+p.y)/2,d);\n}\n\n\nstruct CP{\n\tP p;\n\tint f;\n\tCP(P p,int f):p(p),f(f){}\n\tbool operator<(CP a)const{\n\t\tif(abs(p.x-a.p.x)>EPS)return p.x<a.p.x;\n\t\treturn p.y<a.p.y;\n\t}\n};\n\n\nbool xcmp(CP a, CP b){\n\treturn a.p.x<b.p.x;\n}\nbool ycmp(CP a, CP b){\n\treturn a.p.y<b.p.y;\n}\nint main(){\n\tint testcase;\n\tcin>>testcase;\n\twhile(testcase--){\n\t\tvector<CP> cp;\n\t\tP a,b;\n\t\tint n;\n\t\tcin>>a.x>>a.y>>b.x>>b.y;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tP s,t;\n\t\t\tint o,l,f;\n\t\t\tcin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n\t\t\tf=o^1^l;\n\t\t\tif(exist_intersection(a,b,s,t)){\n\t\t\t\tcp.push_back( CP(intersection(a,b,s,t),f) );\n\t\t\t}\n\t\t}\n\t\t//sort(cp.begin(),cp.end());\n\t\tif(a.x==b.x)sort(cp.begin(),cp.end(),ycmp);\n\t\telse sort(cp.begin(),cp.end(),xcmp);\n\t\tint f=-1,ans=0;\n\t\tfor(int i=0;i<cp.size();i++){\n\t\t\tif(f!=cp[i].f)ans++;\n\t\t\tf=cp[i].f;\n\t\t}\n\t\tcout<<ans-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef pair<P,bool> Q;\nD eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool comp(const Q& xx,const Q& yy){\n\tP x=xx.fs,y=yy.fs;\n\tif(abs(x.real()-y.real())<eps){\n\t\treturn x.imag()<y.imag();\n\t}else{\n\t\treturn x.real()<y.real();\n\t}\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\treturn 0;\n}\nbool iSS(L a,L b){\n\tccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\tvector<Q> vc;\n\t\tD ax,ay,bx,by;\n\t\tint N;\n\t\tcin>>ax>>ay>>bx>>by>>N;\n\t\tL l=L(P(ax,ay),P(bx,by));\n\t\trep(i,N){\n\t\t\tD a,b,c,d;\n\t\t\tint e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tL s=L(P(a,b),P(c,d));\n\t\t\tif(iSS(l,s)){\n\t\t\t\tvc.pb(Q(intLL(l,s),e^f));\n\t\t\t}\n\t\t}\n\t\tif(vc.size()==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(vc),comp);\n\t\tint ans=0,now=vc[0].sc;\n\t\trep(i,vc.size()){\n\t\t\tif(now!=vc[i].sc){\n\t\t\t\tans++;\n\t\t\t\tnow=vc[i].sc;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n\nint cmp(double a, double b) {\n    double d = a-b;\n    if(abs(d) < EPS) return 0;\n    else if(d < 0) return -1;\n    return 1;\n}\n\ninline double dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\ninline double cross(const P& a, const P& b) { return a.real()*b.imag() - b.real()*a.imag(); }\n\nint ccw(const P& a, P b, P c)\n{\n  b -= a;\n  c -= a;\n  if (cross(b, c) > EPS) {\n    return +1;\n  } else if (cross(b, c) < -EPS) {\n    return -1;\n  } else if (dot(b, c) < -EPS) {\n    return +2;\n  } else if (dot(b, b) + EPS < dot(c, c)) {\n    return -2;\n  } else {\n    return 0;\n  }\n}\n\nstruct line/*{{{*/\n{\n  P a, b;\n  line() {}\n  line(const P& p, const P& q) : a(p), b(q) {}\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  inline bool intersects(const line& ln) const\n  {\n    return !parallel(ln);\n  }\n\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline double distance(const P& p) const\n  {\n    return abs(cross(p - a, b - a)) / abs(b - a);\n  }\n\n  // AOJ 1171 Laser Beam Reflections\n  inline P perpendicular(const P& p) const\n  {\n    // 点 p から直線上に下ろした垂線の足\n    const double t = dot(p-a, a-b) / dot(b-a, b-a);\n    return a + t*(a-b);\n  }\n};/*}}}*/\n\nstruct segment/*{{{*/\n{\n  P a, b;\n  segment() {}\n  segment(const P& x, const P& y) : a(x), b(y) {}\n\n  inline bool intersects(const line& ln) const\n  {\n    return cross(ln.b - ln.a, a - ln.a) * cross(ln.b - ln.a, b - ln.a) < EPS;\n  }\n\n  // AOJ 2402 Milkey Way\n  inline bool intersects(const segment& seg) const\n  {\n    return ccw(a, b, seg.a) * ccw(a, b, seg.b) <= 0\n      && ccw(seg.a, seg.b, a) * ccw(seg.a, seg.b, b) <= 0;\n  }\n\n  // AOJ 1171 Laser Beam Relections\n  inline P intersection(const line& ln) const\n  {\n    // assert(intersects(ln))\n    const P x = b - a;\n    const P y = ln.b - ln.a;\n    return a + x*(cross(y, ln.a - a))/cross(y, x);\n  }\n\n  inline P intersection(const segment &s) const {\n      return this->intersection(line(s.a, s.b));\n  }\n\n  inline bool parallel(const line& ln) const\n  {\n    return abs(cross(ln.b - ln.a, b - a)) < EPS;\n  }\n\n  // AOJ 2402 Milkey Way\n  inline double distance(const P& p) const\n  {\n    if (dot(b-a, p-a) < EPS) {\n      return abs(p-a);\n    } else if (dot(a-b, p-b) < EPS) {\n      return abs(p-b);\n    } else {\n      return abs(cross(b-a, p-a))/abs(b-a);\n    }\n  }\n\n  // AOJ 2402 Milkey Way\n  inline double distance(const segment& seg) const\n  {\n    if (intersects(seg)) {\n      return 0;\n    } else {\n      return\n        min(\n            min(distance(seg.a), distance(seg.b)),\n            min(seg.distance(a), seg.distance(b)));\n    }\n  }\n};/*}}}*/\n\nstruct Tag {\n    double dist;\n    int state;\n\n    Tag() {}\n    Tag(double d, int s) : dist(d), state(s) {}\n\n    bool operator <(const Tag &other) const {\n        return dist < other.dist;\n    }\n};\n\nbool solve() {\n    double Xa, Ya, Xb, Yb;\n    cin >> Xa >> Ya >> Xb >> Yb;\n    const P start(Xa, Ya), goal(Xb, Yb);\n    const segment seg1(start, goal);\n\n    int N;\n    cin >> N;\n    vector<Tag> v;\n    for(int i = 0; i < N; ++i) {\n        double Xs, Ys, Xt, Yt;\n        int o, l;\n        cin >> Xs >> Ys >> Xt >> Yt >> o >> l;\n        const segment seg2(P(Xs, Ys), P(Xt, Yt));\n        if(seg1.intersects(seg2)) {\n            const P p = seg1.intersection(seg2);\n            double dist = abs(p - start);\n            v.push_back(Tag(dist, l ^ (1-o)));\n        }\n    }\n    sort(v.begin(), v.end());\n    int ans = N+10;\n    for(int sl = 0; sl <= 1; ++sl) {\n        int cnt = 0;\n        int cur = sl;\n        for(const auto &t : v) {\n            if(t.state != cur) ++cnt;\n            cur = t.state;\n        }\n        ans = min(ans, cnt);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int N;\n    cin >> N;\n    while(N--) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\nclass point2d {\npublic:\n\tdouble x, y;\n\tpoint2d() : x(0), y(0) {};\n\tpoint2d(double x_, double y_) : x(x_), y(y_) {};\n\tbool operator==(const point2d& p) { return x == p.x && y == p.y; }\n\tbool operator!=(const point2d& p) { return x != p.x || y != p.y; }\n\tpoint2d& operator+=(const point2d& p) { x += p.x; y += p.y; return *this; }\n\tpoint2d& operator-=(const point2d& p) { x -= p.x; y -= p.y; return *this; }\n\tpoint2d& operator*=(const double v) { x *= v; y *= v; return *this; }\n\tpoint2d operator+(const point2d& p) const { return point2d(*this) += p; }\n\tpoint2d operator-(const point2d& p) const { return point2d(*this) -= p; }\n\tpoint2d operator*(const double v) const { return point2d(*this) *= v; }\n\tdouble norm() const { return x * x + y * y; }\n\tdouble abs() const { return std::sqrt(x * x + y * y); }\n\tdouble dot(const point2d& p) const { return x * p.x + y * p.y; }\n\tdouble cross(const point2d& p) const { return x * p.y - y * p.x; }\n};\n\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct crossing {\n\tdouble place; int sky;\n};\nbool operator<(const crossing& c1, const crossing& c2) {\n\treturn c1.place < c2.place;\n}\nint main() {\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tpoint2d S, G; int N;\n\t\tcin >> S.x >> S.y >> G.x >> G.y >> N;\n\t\tvector<point2d> rs(N), rg(N); vector<int> own(N), sky(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> rs[i].x >> rs[i].y >> rg[i].x >> rg[i].y >> own[i] >> sky[i];\n\t\t}\n\t\tvector<crossing> dats;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (((G - S).cross(rs[i] - S) > 0) != ((G - S).cross(rg[i] - S) > 0)) {\n\t\t\t\tdouble t1 = (G - S).dot(rs[i] - S) / (G - S).abs(), h1 = (G - S).cross(rs[i] - S) / (G - S).abs(); h1 = abs(h1);\n\t\t\t\tdouble t2 = (G - S).dot(rg[i] - S) / (G - S).abs(), h2 = (G - S).cross(rg[i] - S) / (G - S).abs(); h2 = abs(h2);\n\t\t\t\tdouble pl = (h2 * t1 + h1 * t2) / (h1 + h2);\n\t\t\t\tpl /= (G - S).abs();\n\t\t\t\tif (0 <= pl && pl <= 1) {\n\t\t\t\t\tdats.push_back(crossing{ pl, own[i] ^ sky[i] });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(dats.begin(), dats.end());\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i < dats.size(); ++i) {\n\t\t\tif (dats[i].sky != dats[i - 1].sky) {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            //cout << a << ' ' << b << endl;\n            if(not a) b = (b ? 0 : 1);\n            place[i] = b;\n            //cout << a << ' ' << b << endl;\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n){\n            if(isIntersectedL(rail, old[i])){\n                    v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n            }\n        }\n        sort(all(v));\n        rep(i,n){\n            //show(v[i].first)\n            if(s.empty()) s.emplace_back(v[i].second);\n            if(s.back() == v[i].second) continue;\n            s.emplace_back(v[i].second);\n        }\n        rep(i,s.size() - 1) assert(s[i] != s[i + 1]);\n\n        cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\nbool equal(double a, double b){\n\treturn fabs(a-b) < EPS ;\n}\n\ndouble dot(P a, P b){ return real( conj(a) * b ); }\n\ndouble cross(P a, P b){ return imag( conj(a) * b ); }\n\n\n\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){ a = a_; b = b_; }\n\tSegment(){}\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) && (cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) ) ;\n\t}\n\tbool parallel( Segment s1 , Segment s2 ){\n\t\treturn equal( dot(s1.a - s1.b, s2.a - s2.b) , 0 );\n\t}\n\tbool intersection(Segment s, P& p){\n\t\tbool result = is_intersection( s );\n\n\t\t//if( parallel( *this , s ) ) return false;\n\t\tif( result ){\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ){\n\t\t\t\tp = s.a;\n\t\t\t\treturn true;\n\t\t\t}else if( abs(d1) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdouble t = d1 / (d1+d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_=0 ; t_ < T ; t_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\n\t\tP start(xa,ya), goal(xb,yb);\n\t\tSegment S( start , goal );\n\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tSegment s( P(xs,ys) , P(xt,yt) );\n\n\t\t\tP p(0,0);\n\t\t\tif( S.intersection( s , p ) ){\n\t\t\t\tint d = (start.X - p.X)*(start.X - p.X) + (start.Y - p.Y)*(start.Y - p.Y);\n\t\t\t\tv.push_back( pair<int,int> ( d , o^l ) );\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tsort( v.begin() , v.end() );\n\t\tif( v.size() >= 2 ){\n\t\t\t//int pos = v[0].second;\n\t\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\t\tif( v[i-1].second != v[i].second ){\n\t\t\t\t\t//pos = v[i].second;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\ntypedef pair<double, double> P;\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\nconst double EPS = 1e-10;\n\n// 内積 |a||b|cosθ\ndouble dot(Point a, Point b){\n\t// return a.real() * b.real() + a.imag() * b.imag();\n\treturn (conj(a) * b).real();\n}\n// 外積、符号付面積の２倍　|a||b|sinθ\ndouble cross(Point a, Point b){\n\t// return a.real() * b.imag() - a.imag() * b.real();\n\treturn (conj(a) * b).imag();\n}\n// 点の位置関係　2点a,bから見た点cの位置関係\nint ccw(Point a, Point b, Point c){\n    // COUNTER_CLOCKWISE\n    if(cross(b - a, c - a) > EPS) return 1;\n    // CLOCKWISE\n    if(cross(b - a, c - a) < -EPS) return -1;\n    // ONLINE_BACK\n    if(dot(b - a, c - a) < -EPS) return 2;\n    // ONLINE_FRONT\n    if(abs(b - a) + EPS < abs(c - a)) return -2;\n    // ON_SEGMENT\n    return 0;\n}\n// 線分の交差判定\nbool is_cross(Line a, Line b){\n    if(ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) <= 0 && ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) <= 0){\n        return true;\n    }\n    return false;\n}\n// 直線の交点\nPoint cross_point(Line a, Line b){\n    double d1 = cross(b.second - b.first, b.first - a.first);\n    double d2 = cross(b.second - b.first, a.second - a.first);\n    return a.first + (a.second - a.first) * d1 / d2;\n}\n\nint main(){\n    int ts;\n    cin >> ts;\n    rep(it, 0, ts){\n        double xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        Point a = {xa, ya};\n        Point b = {xb, yb};\n        Line h = {a, b};\n        int n;\n        cin >> n;\n        vector<Line> ls; \n        vector<int> owner(n), l(n);\n        rep(i, 0, n){\n            double xs, ys, xt, yt;\n            cin >> xs >> ys >> xt >> yt >> owner[i] >> l[i];\n            Point s = {xs, ys};\n            Point t = {xt, yt};\n            ls.push_back({s, t});\n        }\n        vector<pair<P, int> > crossPnt;\n        rep(i, 0, n){\n            if(is_cross(h, ls[i])){\n                Point tmp = cross_point(h, ls[i]);\n                int tmpl = l[i];\n                if(owner[i] == 0) tmpl = (tmpl + 1) % 2;\n                crossPnt.push_back({P(tmp.real(), tmp.imag()), tmpl});\n            }\n        }\n        int ans = 0;\n        sort(crossPnt.begin(), crossPnt.end());\n        rep(i, 1, crossPnt.size()){\n            if(crossPnt[i - 1].second != crossPnt[i].second){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nint main(){\n  int T; cin>>T;\n  int xa,ya,xb,yb;\n  while(cin>>xa>>ya>>xb>>yb){\n    L newline(P(xa,ya),P(xb,yb));\n    vector< pair<double, int> > cps;\n    int n; cin>>n;\n    while(n--){\n      int x1,y1,x2,y2,o,l;\n      cin>>x1>>y1>>x2>>y2>>o>>l;\n      L ln(P(x1,y1),P(x2,y2));\n      if(intersectSS(newline, ln)){\n        cps.push_back(make_pair(abs(crosspoint(newline,ln)-newline[0]), o ^ l));\n      }\n    }\n    sort(cps.begin(), cps.end());\n\n    int ans = 0;\n    FOR(i,1,cps.size()){\n      if(cps[i].second != cps[i-1].second)ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing CP = complex<long double>;\n#define X real()\n#define Y imag()\nconst long double PI = acos(-1);\nconst long double EPS = 1e-10;\n// conj(x) : complex conjugate,(0,1)->(0,-1)\n// abs(x) : dist between(0,0) and x\n// norm(x) : abs(x) * abs(x)\n// arg(x) : argment\nlong double dot(CP a, CP b) { return (a * conj(b)).X; }\nlong double cross(CP a, CP b) { return (a * conj(b)).Y; }\nlong double corner(CP a, CP b) {\n  //[0,pi]\n  return acos(dot(a, b) / (abs(a) * abs(b)));\n}\n\nCP intersection(CP a, CP b, CP c, CP d) {\n  return a + (b - a) * (cross(d - c, c - a) /\n                        cross(d - c, b - a));\n}\n\nbool on_seg(CP a, CP b, CP p) {\n  // if not use end point, dot(a - p, b - p) < 0\n  return abs(cross(a - p, b - p)) <= 1e-10 &&\n         dot(a - p, b - p) <= 0;\n}\n\n// crossing lines? (a,b) and (c,d)\nbool iscross(CP a, CP b, CP c, CP d) {\n  // parallel\n  if(abs(cross(a - b, c - d)) <= 1e-10) {\n    return on_seg(a, b, c) || on_seg(a, b, d) ||\n           on_seg(c, d, a) || on_seg(c, d, b);\n  }\n  CP isp = intersection(a, b, c, d);\n  return on_seg(a, b, isp) && on_seg(c, d, isp);\n}\n\nstruct line {\n  CP s, t;\n  bool l;\n};\n\nline newline;\n\nbool operator<(const line &l, const line &r) {\n  CP pl = intersection(newline.s, newline.t, l.s, l.t),\n     pr = intersection(newline.s, newline.t, r.s, r.t);\n  return abs(pl - newline.s) < abs(pr - newline.s);\n}\n\nint n, t;\nvector<line> v;\n\nint solve();\n\nint main() {\n  cin >> t;\n  while(t--) {\n    long double a, b, c, d;\n    cin >> a >> b >> c >> d >> n;\n    newline.s = CP(a, b);\n    newline.t = CP(c, d);\n    v.clear();\n    for(int i = 0; i < n; ++i) {\n      bool o, l;\n      cin >> a >> b >> c >> d >> o >> l;\n      if(iscross(newline.s, newline.t, CP(a, b), CP(c, d)))\n        v.push_back({CP(a, b), CP(c, d), o ^ l});\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  int ans = 0;\n  sort(v.begin(), v.end());\n  for(int i = 1; i < v.size(); ++i)\n    if(v[i].l ^ v[i - 1].l) ++ans;\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //  << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  int cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  return (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g);\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-9\n#define INF 1e8\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tlong double r = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\n\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\t\t\t\t\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\tif((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(tmpx,(o+l)%2));\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tif(v.size() == 0)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\t\n\t\tREP(i,v.size())\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define EPS 1e-9\ntypedef complex<double> P;\n\nclass comp{\npublic:\n  double length;\n  bool up,my;\n  bool operator < (const comp & a)const{\n    return length <  a.length;\n  }\n};\n\nclass point{\npublic:\n  P data[2];\n  bool up,my;\n};\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\ndouble dot(P a,P b){\n  return a.real()*b.real()+a.imag()*b.imag();\n}\nbool ispointonline(P a1,P a2,P b){\n  if ( abs(b-a1)+abs(b-a2)< abs(a1-a2)+EPS)return true;\n  else return false;\n}\nbool isintersect(P a1,P a2,P b1,P b2){\n  if ( ispointonline(a1,a2,b1) )return true;\n  if ( ispointonline(a1,a2,b2) )return true;\n  if ( ispointonline(b1,b2,a1) )return true;\n  if ( ispointonline(b1,b2,a2) )return true;\n  if ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1) < 0 && \n       cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1) < 0)return true;\n  else return false;\n}\ndouble distance_ls_p(P a1,P a2,P b1){\n  if ( dot(a2-a1,b1-a1) <0)return abs(b1-a1);\n  if ( dot(a1-a2,b1-a2) <0)return abs(b1-a2);\n  return abs(cross(a2-a1,b1-a1))/abs(b1-a1);\n}\n\nP intersectpoint(P a1,P a2,P b1,P b2){\n  double d1 = abs(cross(b2-b1,a1-b1));\n  double d2 = abs(cross(b2-b1,a2-b1));\n  double t = d1/(d1+d2);\n  return a1 + (a2-a1)*t;\n}\n\nint compute(vector<point> a,P inp[2],int n){\n  vector<comp> res;\n  for(int i=0;i<a.size();i++){\n    if ( isintersect(inp[0],inp[1],a[i].data[0],a[i].data[1])==false)continue;\n    P tmp = intersectpoint(inp[0],inp[1],a[i].data[0],a[i].data[1]);\n    double leng = abs(tmp-inp[0]);\n    comp ins = {leng,a[i].up,a[i].my};\n    res.push_back(ins);\n  }\n  if ( res.size() == 0)return 0;\n  sort(res.begin(),res.end());\n  int cnt = 0,myup,mymy = 1;\n  if ( res[0].my == 1){\n    myup = res[0].up;\n  }else{\n    myup = !res[0].up;\n  }\n  //cout << myup << endl;\n  for(int i=1;i<res.size();i++){\n    bool  my  = res[i].my,up = res[i].up;\n    //cout << \" up \"  << up << \" my \" << my << \" now \" << myup << endl;\n    if ( my == 1){\n      if ( up != myup){\n\tcnt++;\n\tmyup = !myup;\n      }\n    }else {\n      if ( up == myup){\n\tcnt++;\n\tmyup= !myup;\n      }\n    }\n  }\n\n  return cnt;\n}\n\n\nint main(){\n  int te;\n  for(cin >> te;te;te--){\n    P inp[2];\n    cin >> inp[0].real() >> inp[0].imag() >> inp[1].real() >> inp[1].imag();\n    vector<point> a;\n    int n;\n    cin >> n;\n    for(int i=0;i<n;i++){\n      point temp;\n      cin >> temp.data[0].real() >> temp.data[0].imag() \n\t  >> temp.data[1].real() >> temp.data[1].imag() \n\t  >> temp.my >> temp.up;\n      a.push_back(temp);\n    }\n    cout       << compute(a,inp,n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define int long long\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nconst double PI = asinl(1) * 2;\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n// intercsect of circles\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1;\n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int Q;\n  cin >> Q;\n  \n  while ( Q-- ) {\n    Point a, b;\n    cin >> a >> b;\n\n    int n;\n    cin >> n;\n\n    vector<Segment> ss(n);\n    vector<int> own(n), high(n);\n    for ( int i = 0; i < n; i++ ) {\n      cin >> ss[i] >> own[i] >> high[i];\n    }\n\n    using S = pair<Point, int>;  \n    vector<S> cross;\n    Segment ab(a, b);\n    for ( int i = 0; i < n; i++ ) {      \n      if ( intersectSS(ab, ss[i]) ) {\n\tPoint cp = getCrossPointSS(ab, ss[i]);\n\tcross.push_back(S(cp, i));      \n      }\n    }\n\n    if ( cross.size() == 0 ) {\n      cout << 0 << endl;\n      continue;     \n    }\n\n    sort(cross.begin(), cross.end());\n    int ans = 0;\n    {\n      int h = 0;    \n      for ( int i = 0; i < cross.size(); i++ ) {\n\tint hi = high[cross[i].second];\n\tint ci = own[cross[i].second];\n\t\n\tif ( ci == 1 && hi != h ) {\n\t  ans++;\n\t  h = hi;\n\t} else if ( ci == 0 && hi == h ) {\n\t  ans++;\n\t  h = 1-h;      \n\t}\n      }\n    }\n    {\n      int ans2 = 0;\n      int h = 1;\n      for ( int i = 0; i < cross.size(); i++ ) {\n\tint hi = high[cross[i].second];\n\tint ci = own[cross[i].second];\n\t\n\tif ( ci == 1 && hi != h ) {\n\t  ans2++;\n\t  h = hi;\n\t} else if ( ci == 0 && hi == h ) {\n\t  ans2++;\n\t  h = 1-h;      \n\t}\n      }\n      ans = min(ans, ans2);\n    }\n    reverse(cross.begin(), cross.end());    \n    {\n      int ans2 = 0;\n      int h = 0;\n      for ( int i = 0; i < cross.size(); i++ ) {\n\tint hi = high[cross[i].second];\n\tint ci = own[cross[i].second];\n\t\n\tif ( ci == 1 && hi != h ) {\n\t  ans2++;\n\t  h = hi;\n\t} else if ( ci == 0 && hi == h ) {\n\t  ans2++;\n\t  h = 1-h;      \n\t}\n      }\n      ans = min(ans, ans2);\n    }\n    {\n      int ans2 = 0;\n      int h = 1;\n      for ( int i = 0; i < cross.size(); i++ ) {\n\tint hi = high[cross[i].second];\n\tint ci = own[cross[i].second];\n\t\n\tif ( ci == 1 && hi != h ) {\n\t  ans2++;\n\t  h = hi;\n\t} else if ( ci == 0 && hi == h ) {\n\t  ans2++;\n\t  h = 1-h;      \n\t}\n      }\n      ans = min(ans, ans2);\n    }\n    cout << ans << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n    return (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\n// ?????????????????? a->b->c\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\n// ??´???a??¨??????b\nbool isecLS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0;\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n    D d1 = cross(b2-b1, b1-a1);\n    D d2 = cross(b2-b1, a2-a1);\n    return a1 + d1/(d1 + d2) * (a2-a1);\n}\n\nclass CrossPoint{\npublic:\n    double x, y;\n    int o, l;\n    bool is_underground;\n    CrossPoint(double x, double y, int o, int l): x(x), y(y), o(o), l(l){\n        is_underground = o^l;\n    };\n};\n\nbool cmp(CrossPoint p1, CrossPoint p2){\n    if(EQ(p1.x, p2.x))\n        return p1.y < p2.y;\n    else\n        return p1.x < p2.x;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T; cin>>T;\n    while(T--){\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        \n        int N; cin >> N;\n        \n        vector<CrossPoint> crosspoints;\n        for(int i=0; i<N; i++){\n            int xs, ys, xt, yt, o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            \n            if(isecLS(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt))){\n                P p = crosspointLL(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt));\n                crosspoints.push_back(CrossPoint(p.X, p.Y, o, l));\n            }\n        }\n        \n        if(crosspoints.size()){\n            sort(crosspoints.begin(), crosspoints.end(), cmp);\n            \n            int count = 0;\n            bool is_underground = crosspoints[0].is_underground;\n            int i = 0;\n            while(i<crosspoints.size()){\n                while(i<crosspoints.size() && crosspoints[i].is_underground == is_underground) i++;\n                if(i<crosspoints.size()){\n                    is_underground = crosspoints[i].is_underground;\n                    count++;\n                }\n                i++;\n            }\n            cout << count << endl;\n        }else{\n            cout << 0 << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int i,j;\n    int t;\n    cin >> t;\n    rep(j,t){\n        L l = inL();//a:l[0],b:l[1]\n        int n;\n        cin >> n;\n\n        vector<pair<double,int> > v;\n\n        rep(i,n){\n            L seg = inL();\n            int a,b;\n            cin >> a >> b;//会社、地上地下\n            if(!intersectSS(l,seg) || isparallel(l,seg))continue;\n            P p = crosspointSS(l,seg);\n            double dist = distancePP(p, l[0]);\n            v.push_back(make_pair(dist,(int)a!=b));\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n\n        rep(i,v.size()-1){\n            if(v[i].second != v[i+1].second) ans++;\n        }\n\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\ntypedef pair<double, int> P;\n\nint main()\n{\n  int T; cin >> T;\n  while(T--) {\n    Segment ab;\n    cin >> ab.p1.x >> ab.p1.y >> ab.p2.x >> ab.p2.y;\n    \n    int n; cin >> n;\n    vector<Segment> s(n);\n    vector<int> o(n), l(n);\n    for(int i = 0; i < n; i++) {\n      cin >> s[i].p1.x >> s[i].p1.y >> s[i].p2.x >> s[i].p2.y >> o[i] >> l[i];\n    }\n\n    vector<P> isct_s;\n    for(int i = 0; i < n; i++) {\n      if(!intersect(ab, s[i]) || isParallel(ab, s[i])) continue;\n      double dist = getDistance(ab.p1, getCrossPoint(ab, s[i]));\n      isct_s.push_back(P(dist, i));\n    }\n    sort(isct_s.begin(), isct_s.end());\n\n    if(isct_s.empty()) {\n      cout << 0 << endl;\n      continue;\n    }\n    \n    int level = (o[isct_s[0].second] ? l[isct_s[0].second] : !l[isct_s[0].second]);\n    int ans = 0;\n    for(int i = 1; i < isct_s.size(); i++) {\n      if(o[isct_s[i].second] == 1 && level != l[isct_s[i].second] ||\n\t o[isct_s[i].second] == 0 && level == l[isct_s[i].second]) ans++, level = !level;\n    }\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& p,const Point& q){\n  return real(conj(p)*q);\n}\n\ndouble det(const Point& p,const Point& q){\n  return imag(conj(p)*q);\n}\n\nbool on_seg(const Point& p1,const Point&p2,\n\t    const Point& q){\n  return abs(det(p1-q,p2-q)) <= EPS && dot(p1-q,p2-q) < EPS;\n}\n\ndouble compute_scale(const Point& p1,const Point& p2,\n\t     const Point& q1,const Point& q2) {\n  return det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nPoint compute_intersection(const Point& p1,const Point& p2,\n\t\t\t   const Point& q1,const Point& q2) {\n  return p1 + (p2-p1) * det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nint compute_location(int owner,int location){\n  //owner 1:me 0:other\n  //location 1:high way 0:under ground\n  if(owner == 1){\n    return location;\n  }\n  else if(owner == 0){\n    return !location;\n  }\n}\n\nint main(){\n  int total_dataset = 0;\n  while(~scanf(\"%d\",&total_dataset)){\n    for(int dataset_idx=0;dataset_idx<total_dataset;dataset_idx++){\n      int xa,ya,xb,yb;\n      scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n      Point p1(xa,ya);\n      Point p2(xb,yb);\n\n      int n;\n      scanf(\"%d\",&n);\n\t\n      vector<pair<double,int> > intersections;\n      for(int i=0;i<n;i++){\n\tint xs,ys,xt,yt,owner,location;\n\tscanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&owner,&location);\n\tPoint p3(xs,ys);\n\tPoint p4(xt,yt);\n\tPoint intersection = compute_intersection(p1,p2,p3,p4);\n\t\n\tif(!on_seg(p1,p2,intersection)) continue;\n\tdouble scale = compute_scale(p1,p2,p3,p4);\n\tint next_location = compute_location(owner,location);\n\n\tpair<double,int> tmp(scale,next_location);\n\tintersections.push_back(tmp);\n      }\n\n      sort(intersections.begin(),intersections.end());\n      int prev = intersections[0].second;\n      int res = 0;\n      for(int i=1;i<intersections.size();i++){\n\tif(prev != intersections[i].second) res++;\n\tprev = intersections[i].second;\n      }\n      printf(\"%d\\n\",res);\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            place[i] = (a ? b : b^1);\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n) v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n        sort(all(v));\n        rep(i,n){\n            if(s.empty()) s.emplace_back(v[i].second);\n            if(s.back() == v[i].second) continue;\n            s.emplace_back(v[i].second);\n        }\n        cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 110;\n\nconst double EPS = 1e-9;\n\nbool on(double cx, double cy, double x1, double y1, double x2, double y2){\n\tif (x1 > x2) swap(x1, x2);\n\tif (y1 > y2) swap(y1, y2);\n\n\treturn x1 < cx + EPS && cx - EPS < x2 && y1 < cy + EPS && cy - EPS < y2;\n}\n\nint main(){\n\tint T;\n\tcin >> T;\n\twhile (T--){\n\t\tint xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint dx = xb - xa, dy = yb - ya;\n\t\tdouble aa = 0, bb = 0;\n\t\tif (dx) aa = 1.*(dy) / dx; bb = ya - aa*xa;\n\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<tuple<double, double, int>> v;\n\t\trep(i, n){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tbool vert = xt - xs == 0;\n\n\t\t\tdouble a = 0, b = 0;\n\t\t\tif (!vert) a = 1.*(yt - ys) / (xt - xs), b = ys - a*xs;\n\n\t\t\tdouble cx, cy;\n\t\t\tif (dx == 0){\n\t\t\t\tif (vert) continue;\n\t\t\t\tcx = xa, cy = a*cx + b;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (vert){\n\t\t\t\t\tcx = xt, cy = aa*cx + bb;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble lb = -1e5, ub = 1e5;\n\n\t\t\t\t\tdouble a1 = aa, b1 = bb, a2 = a, b2 = b;\n\t\t\t\t\tif (a1 * lb + b1 > a2*lb + b2) swap(a1, a2), swap(b1, b2);\n\n\t\t\t\t\trep(abc, 1000){\n\t\t\t\t\t\tdouble mid = (lb + ub) / 2;\n\t\t\t\t\t\tif (a1 * mid + b1 > a2 * mid + b2) ub = mid;\n\t\t\t\t\t\telse lb = mid;\n\t\t\t\t\t}\n\t\t\t\t\tcx = lb, cy = a*cx + b;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (on(cx, cy, xs, ys, xt, yt) && on(cx, cy, xa, ya, xb, yb)){\n\t\t\t\tv.emplace_back(cx, cy, o^l);\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(v));\n\t\tint ans = 0, prv = -1;\n\t\tfor (auto t : v){\n\t\t\tdouble x, y;\n\t\t\tint type;\n\t\t\ttie(x, y, type) = t;\n\t\t\t//cout << x << ' ' << y << ' ' << type << endl;\n\t\t\tif (prv >= 0 && prv != type) ++ans;\n\t\t\tprv = type;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//XY座標\n#define X real()\n#define Y imag()\n\n// 許容する誤差ε\nconst double EPS = (1e-8);\n// 円周率\nconst double PI = 3.14159265358979;\n\nconst double INF = 1e12;\n\n// 点の表現\ntypedef complex<double> P;\n// 無限遠方\n#define INF_P (P(999999999,999999999))\n\n// complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// 2乗する\ndouble sq(double x){\n\treturn x * x;\n}\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n// 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b){\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a){\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a){\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a){\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross( P a, P b) {\n\treturn imag( conj(a) * b );\n}\n\n// 2 直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n\treturn equal( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点 c が直線 a, b 上にあるかどうか \nint is_point_on_line(P a, P b, P c) {\n\treturn equal( cross(b-a, c-a), 0.0 );\n}\n\n// 下記は (1) より (2) のほうが簡潔で良い.\n\n// 点 c が線分 a, b 上にあるかどうか (1)\nint is_point_on_line_1(P a, P b, P c) {\n  return equal( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点 c が線分 a, b 上にあるかないか(2)\nint is_point_on_line_2(P a, P b, P c) {\n\t// |a-c| + |c-b| <= |a-b| なら線分上\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点 a, bを通る直線と点 c との距離\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点 a, b を端点とする線分と点 c との距離\ndouble distance_ls_p(P a, P b, P c) {\n\tif( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tif( equal(d1+d2,0.0) ) return INF_P;\n\tdouble t = d1 / (d1 + d2);\n\t\n\treturn a1 + (a2-a1) * t;\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n\treturn !equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n\tP a = a2 - a1; P b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i_=0 ; i_ < N ; i_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa,ya), B(xb,yb);\n\t\t\n\t\t// 点Aと交点の距離と交点で地下と高架のどちらを通るべきか保持\n\t\tvector< pair<double,int> > v;\n\t\t\n\t\tcin >> n;\n\t\tfor(int j_=0 ; j_ < n ; j_++ ){\n\t\t\tint sx,sy,tx,ty,o,l;\n\t\t\tcin >> sx >> sy >> tx >> ty >> o >> l;\n\t\t\tP S(sx,sy), T(tx,ty);\n\t\t\t\n\t\t\t// 交差するかどうか\n\t\t\tif( is_intersected_ls( A , B , S , T ) ){\n\t\t\t\t// 交点\n\t\t\t\tP p = intersection_l( A , B , S , T );\n\t\t\t\tif( p == INF_P ) continue;\n\t\t\t\t// 距離\n\t\t\t\tdouble dist = abs(A-p);\n\t\t\t\t\n\t\t\t\tv.push_back( pair<double,int>(dist,o^l) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort( v.begin() , v.end() );\n\t\tif( v.empty() ){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tint ans = 0;\n\t\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\t\tif( v[i-1].second != v[i].second ){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 1000\nusing namespace std;\n\n// library --- start\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// library --- end\n\nstruct Pox\n{\n  Segment s;\n  double dist;\n  bool o,l;\n  Pox(Segment s=Segment(),double dist=inf,bool o=false,bool l=false):s(s),dist(dist),o(o),l(l){}\n\n  bool operator < (const Pox& a)const{ return dist < a.dist; }\n\n};\n\nPoint a,b;\nint n;\nSegment seg[MAX];\nPox     pox[MAX];\n\nint compute(bool state)\n{\n  int cnt = 0;\n  rep(i,n)//0\n    {\n      if(pox[i].dist == inf)break;\n      if(pox[i].o)\n\t{//it's me\n\t  if(pox[i].l != state)\n\t    {\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n      else\n\t{//mario\n\t  if(pox[i].l == state)\n\t    {\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n    }\n  return cnt;\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> a.x >> a.y >> b.x >> b.y;\n\t  cin >> n;\n\t  rep(i,n)\n\t    {\n\t      cin >> seg[i].p1.x >> seg[i].p1.y >> seg[i].p2.x >> seg[i].p2.y >> pox[i].o >> pox[i].l;\n\t      pox[i].s = seg[i];\n\t      Point p = (intersectSS(Segment(a,b),seg[i])?crosspoint(Segment(a,b),seg[i]):Point(inf,inf));\n\t      pox[i].dist = (intersectSS(Segment(a,b),seg[i])?sqrt(norm(a-p)):inf);\n\t    }\t  \n\t  sort(pox,pox+n); \n\n\t  cout << min(compute(false),compute(true)) << endl;\n\t}\n    }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-25)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> Pair;\n\nint u, n;\ndouble xa, ya, xb, yb;\ndouble x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((a1.real()-a2.real())*(b1.imag()-b2.imag()) + EPS > (a1.imag()-a2.imag())*(b1.real()-b2.real()) &&\n\t   (a1.real()-a2.real())*(b1.imag()-b2.imag()) < EPS + (a1.imag()-a2.imag())*(b1.real()-b2.real())) return 0;\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int i,j;\n    int t;\n    cin >> t;\n    rep(j,t){\n        L l = inL();//a:l[0],b:l[1]\n        int n;\n        cin >> n;\n\n        vector<pair<double,int> > v;\n\n        rep(i,n){\n            L seg = inL();\n            int a,b;\n            cin >> a >> b;//会社、地上地下\n            if(!intersectSS(l,seg))continue;\n            P p = crosspointSS(l,seg);\n            double dist = distancePP(p, l[0]);\n            v.push_back(make_pair(dist,(int)a!=b));\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n\n        rep(i,v.size()-1){\n            if(v[i].second != v[i+1].second) ans++;\n        }\n\n        cout << ans << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nstruct edgeInfo{\n    P a;\n    P b;\n    int o;\n    int l;\n};\n\nP p1,p2;\n\nclass Point{\npublic:\n    P p;\n    int l;\n    int o;\n\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<edgeInfo> edges;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            edgeInfo e;\n            e.a=P(xs,ys);\n            e.b=P(xt,yt);\n            e.l=l;\n            e.o=o;\n            edges.push_back(e);\n        }\n        vector<Point> crossPoint;\n        // ð_ðßé\n        for(int i = 0;i < n; i++){\n\n            if (abs(cross(p2-p1, edges[i].a-edges[i].b)) < EPS) { continue; }\n            if(is_intersected_ls(edges[i].a,edges[i].b,p1,p2)){\n                P res=intersection_ls(edges[i].a,edges[i].b,p1,p2);\n                Point pp;\n                pp.l=edges[i].l;\n                pp.o=edges[i].o;\n                pp.p=res;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n\n        if(crossPoint.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit;\n        if(crossPoint[0].l==1){\n            if(crossPoint[0].o==1)\n                sit=1;\n            else\n                sit=0;\n        }\n        else{\n            if(crossPoint[0].o==1)\n                sit=0;\n            else\n                sit=1;\n        }\n        // ð_ðp1Éß¢ÔÉ\n        int cnt=0;\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].o==1){\n                if(crossPoint[i].l==0){\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n            }\n            else{\n                if(crossPoint[i].l==0){\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS 1e-16\n\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n/* àÏ */\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n/* OÏ */\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\n/* _Æûü©ç */\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n/* 2_©ç */\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\n/* 2ÂÌ¼üÌð_ */\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n/* _Æ¼üÌ£ */\ndouble dist(const Line &l, const P &p){\n  return std::abs(outp(l.d, p-l.p) / abs(l.d));\n}\n\nint main(){\n  int d; cin>>d;\n  while(d --> 0){\n    P a, b; cin>>a.real()>>a.imag()>>b.real()>>b.imag();\n    Line l1 = LinePos(a,b);\n    int n; cin>>n;\n    vector<pair<double,int> > cp; //cross point\n    REP(i,n){\n      P c,d; int o; int l;\n      cin>>c.real()>>c.imag()>>d.real()>>d.imag()>>o>>l;\n      Line l2 = LinePos(c,d);\n      if(abs(outp(l1.d, l2.d)) < EPS) continue;\n      P p = crossPoint(l1,l2);\n      double dd = ((p-a)/(b-a)).real();\n      if(dd < 0.0 || dd > 1.0) continue;\n      cp.push_back(mp(abs(p-a),(o^l)));\n    }\n    int ans = 0;\n    if(cp.size() > 1){\n      sort(cp.begin(), cp.end());\n      for(int i=1; i<cp.size(); i++){\n        int f1 = cp[i].s;\n        int f2 = cp[i-1].s;\n        if(f1 != f2) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define EPS (1e-10)\n#define INF (P(999999999,999999999))\n\ntypedef complex<double> P;\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn\n\t\t( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tif(d1 + d2 == 0) return INF;\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\nint main(void){\n\tint n;\n\tcin>>n;\n\n\twhile(n--){\n\t\tP sa,sb;\n\t\tcin>>sa.real()>>sa.imag()>>sb.real()>>sb.imag();\n\n\t\tint m;\n\t\tcin>>m;\n\n\t\tvector< pair<double,bool> > s,r;\n\t\twhile(m--){\n\t\t\tbool flgRS,flg; //flgRS : 0 - Co 1 - ©ª\n\t\t\tP a,b;\n\t\t\tcin>>a.real()>>a.imag()>>b.real()>>b.imag()>>flgRS>>flg;\n\n\t\t\tif(is_intersected_ls(a,b,sa,sb)){\n\t\t\t\tP its = intersection_ls(a,b,sa,sb);\n\t\t\t\tif(its == INF) continue;\n\n\t\t\t\tdouble dist = abs(sa - its);\n\t\t\t\tif(flgRS)\n\t\t\t\t\ts.push_back(pair<double,bool>(dist,flg));\n\t\t\t\telse\n\t\t\t\t\tr.push_back(pair<double,bool>(dist,flg));\n\t\t\t}\n\t\t}\n\n\t\tsort(s.begin(),s.end());\n\t\tsort(r.begin(),r.end());\n\n\t\tbool flg = false, firstFlg = true;\n\t\tint ans = 0, i = 0, j = 0;\n\n\t\twhile(i < r.size() || j < s.size()){\n\t\t\tif(j == s.size() || i != r.size() && r[i].first < s[j].first){\n\t\t\t\tif(!firstFlg && flg != !r[i].second) ans++;\n\t\t\t\tflg = !r[i].second;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!firstFlg && flg != s[j].second) ans++;\n\t\t\t\tflg = s[j].second;\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tfirstFlg = false;\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n#define eps 1e-9\n\nstruct Point{double x,y; bool high;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nPoint* Intersection(Point p1,Point p2,Point p3,Point p4,bool high){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(fabs(d)<=eps || u<0 || u>1 || v<0 || v>1) return NULL;\n    return new Point{p1.x+u*(p2.x-p1.x), p1.y+u*(p2.y-p1.y), high};\n}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n            Point *ret = Intersection(a,b,s,t,o==l);\n            if(ret)cross.push_back(*ret);\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        rep(i,(int)cross.size()-1){\n            cnt += (cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nP A, B;\nint N;\nP S[100], T[100];\nint O[100], L[100];\n\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\nbool is_crossing(P a1, P a2, P b1, P b2)\n{\n\tbool l = cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n\tbool r = cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n\treturn l && r;\n}\n\nP intersection_is(P a1, P a2, P b1, P b2)\n{\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\nint solve()\n{\n\tvector<pair<double, int> > vp;\n\n\trep(i, 0, N) if (is_crossing(A, B, S[i], T[i]))\n\t{\n\t\tP c = intersection_is(A, B, S[i], T[i]);\n\n\t\tdouble d = abs(c - A);\n\n\t\tint place;\n\n\t\tif (O[i] == 1)\n\t\t\tplace = L[i];\n\t\telse\n\t\t\tplace = 1 - L[i];\n\n\t\tvp.push_back(make_pair(d, place));\n\t}\n\n\tsort(vp.begin(), vp.end());\n\n\tint ans = 0;\n\trep(i, 1, vp.size())\n\t{\n\t\tif (abs(vp[i].first - vp[i - 1].first) < EPS)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tif (vp[i].second != vp[i - 1].second) ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(i, 0, dn)\n\t{\n\t\tdouble x, y;\n\n\t\tcin >> x >> y; A = P(x, y);\n\t\tcin >> x >> y; B = P(x, y);\n\t\tcin >> N;\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tcin >> x >> y; S[j] = P(x, y);\n\t\t\tcin >> x >> y; T[j] = P(x, y);\n\t\t\tcin >> O[j] >> L[j];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {x.first+y.first,x.second+y.second};\n}\n\nP operator-(const P& x,const P& y){\n    return {x.first-y.first,x.second-y.second};\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return x.first*y.first+x.second*y.second;\n\n}\n\ndouble det(P x,P y){\n    return x.first*y.second-x.second*y.first;\n\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(wrtwrt,n){\n        P s,t;\n        cin>>s.first>>s.second>>t.first>>t.second;\n        int m;cin>>m;\n        map<P,int> mp;\n        rep(i,m){\n            P x,y;\n            cin>>x.first>>x.second>>y.first>>y.second;\n            int a,b;\n            cin>>a>>b;\n            if(cross(s,t,x,y))mp[intersection(s,t,x,y)]=a^b;\n        }\n        int ans=-1;\n        int pos=-1;\n        for(auto x:mp){\n            if(x.second!=pos)ans++;\n            pos=x.second;\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\n/**\n * @brief\n * 二次元幾何\n * @author habara-k\n * @date 2020/05/05\n */\n\n// template {{{\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point &a, const Point &b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\n\nstruct Line {\n    Point a, b;\n\n    Line() {}\n\n    Line(const Point &a, const Point &b) : a(a), b(b) {}\n\n    friend ostream &operator<<(ostream &os, const Line &l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\n\nstruct Segment : Line {\n    Segment() {}\n    // Segment() = default;\n\n    Segment(const Point &a, const Point &b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < eps; }\n\n// }}}\n\n\n// utils {{{\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real) 1.0, theta);\n}\n\nReal cross(const Point &a, const Point &b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point &a, const Point &b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\n// }}}\n\n\n/**\n* @brief 点p の直線l への射影を求める.\n*/\nPoint projection(const Line &l, const Point &p) {\n    Real A = dot(l.b - l.a, p - l.a),\n            B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\n/**\n* @brief 2直線の並行判定\n*/\nbool parallel(const Line &l1, const Line &l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\n/**\n* @brief 2直線の直行判定\n*/\nbool orthogonal(const Line &l1, const Line &l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\n\n/**\n* @brief 有向線分と点の位置関係\n* @param[in] a, b, c: 線分a->b, 点c\n* @return 線分a->b からみて, 点c がどこにあるか.\n*/\nconst int COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = -2,\n        ON_SEGMENT = 0;\n\nint ccw(const Point &a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > eps) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -eps) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n// 交差 {{{\n\n/**\n* @brief 直線と点の交差判定\n*/\nbool intersected(const Line &l, const Point &p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n/**\n* @brief 線分と点の交差判定\n*/\nbool intersected(const Segment &s, const Point &p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\n/**\n* @brief 直線と線分の交差判定\n*/\nbool intersected(const Line &l, const Segment &s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n}\n\n/**\n* @brief 2つの線分の交差判定\n*/\nbool intersected(const Segment &s1, const Segment &s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\n\n/**\n* @brief 2直線の交点\n*/\nPoint crosspoint(const Line &l1, const Line &l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n            B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\n// }}}\n\n\n// 距離 {{{\n\n/**\n* @brief 直線と点の距離\n*/\nReal distance(const Line &l, const Point &p) {\n    return abs(p - projection(l, p));\n}\n\n/**\n* @brief 線分と点の距離\n*/\nReal distance(const Segment &s, const Point &p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\n/**\n* @brief 直線と線分の距離\n*/\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\n/**\n* @brief 2つの線分の距離\n*/\nReal distance(const Segment &s1, const Segment &s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({distance(s1, s2.a), distance(s1, s2.b),\n                distance(s2, s1.a), distance(s2, s1.b)});\n}\n\n// }}}\n\n\n\n// 円 {{{\n\nstruct Circle {\n    Point p;\n    Real r;\n\n    Circle() {}\n\n    Circle(const Point &p, Real r) : p(p), r(r) {}\n};\n\n\n/**\n* @brief 2つの円の交点の数\n*/\nint intersected(Circle c1, Circle c2) {\n    if (c1.r < c2.r) swap(c1, c2);\n    Real d = abs(c1.p - c2.p);\n    if (c1.r + c2.r < d) return 4;\n    if (eq(c1.r + c2.r, d)) return 3;\n    if (c1.r - c2.r < d) return 2;\n    if (eq(c1.r - c2.r, d)) return 1;\n    return 0;\n}\n\n/**\n* @brief 円と直線の交点のペア\n* @details 交差することを確認してから呼ぶこと.\n*/\npair<Point, Point> crosspoint(const Circle &c, const Line &l) {\n    Real h = distance(l, c.p);\n    Point p = projection(l, c.p);\n    if (eq(h, c.r)) return {p, p};\n    Point u = l.a - l.b;\n    u /= abs(u);\n    Real d = sqrt(c.r * c.r - h * h);\n    return {p + u * d, p - u * d};\n}\n\n/**\n* @brief 2つの円の交点のペア\n* @details 交差することを確認してから呼ぶこと.\n*/\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2) {\n    Real d = abs(c2.p - c1.p), t = arg(c2.p - c1.p);\n    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    return {c1.p + polar(c1.r, t + a),\n            c1.p + polar(c1.r, t - a)};\n}\n\n/**\n* @brief 点p, 円c に対し, pを通るcの接線を返す(c上の2点のペアで返す).\n* @details 点p が円c の外側にあることを確認してから呼ぶこと.\n*/\npair<Point, Point> tangent(const Point &p, const Circle &c) {\n    return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));\n};\n\n/**\n* @brief 2つの円に共通する接線を返す(最大4本).\n* @details 点p が円c の外側にあることを確認してから呼ぶこと.\n*/\nvector<Line> common_tangent(const Circle &c1, const Circle &c2) {\n    vector<Line> lines;\n    Point u = c2.p - c1.p;\n    Real d = abs(u);\n    if (eq(d, 0.0)) return lines;\n    u /= d;\n    for (Real s : {-1, 1}) {\n        // s = -1: 同じ側に2つの円があるとき.\n        // s =  1: 反対側に2つの円があるとき.\n        Real h = (c1.r + s * c2.r) / d;\n        if (eq(abs(h), 1.0)) {\n            // 2つの円が接しているとき.\n            lines.emplace_back(\n                    c1.p + u * h * c1.r,\n                    c1.p + u * h * c1.r + rotate(u, PI / 2.0));\n        } else if (abs(h) < 1) {\n            // 2本の接線が引けるとき.\n            Real a = acos(h);\n            lines.emplace_back(\n                    c1.p + u * polar(c1.r, a),\n                    c2.p - s * u * polar(c2.r, a));\n            lines.emplace_back(\n                    c1.p + u * polar(c1.r, -a),\n                    c2.p - s * u * polar(c2.r, -a));\n        }\n    }\n    return lines;\n}\n\n// }}}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int T; cin >> T;\n    while (T--) {\n        double xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        Point A = {xa, ya}, B = {xb, yb};\n        Segment AB = {A, B};\n        int n; cin >> n;\n        vector<pair<double,int>> ps;\n        REP(i, n) {\n            double xs, ys, xt, yt;\n            int o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            Segment s = {{xs, ys}, {xt, yt}};\n            if (!intersected(AB, s)) continue;\n            Point p = crosspoint(AB, s);\n            ps.emplace_back(abs(p - A), o ^ l);\n        }\n        sort(ALL(ps));\n\n        int ans = 0;\n        for (int i = 0; i + 1 < SZ(ps); ++i) {\n            ans += ps[i].second ^ ps[i + 1].second;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef float FP;\ntypedef complex<FP> pt;\ntypedef complex<FP> P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return (conj(a)*b).real();}\nFP crs(P a,P b){return (conj(a)*b).imag();}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nbool onl(P a1,P a2,P b){\n  return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;\n}\n\nint xs[100],ys[100],xt[100],yt[100],o[100],l[100];\n\nvoid solve(){\n  int xa,ya,xb,yb;\n  cin >> xa >> ya >> xb >> yb;\n  vector<pair<FP,int> > arr;\n  int n;\n  cin >> n;\n  rep(i,n) cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n  rep(i,n){\n    P a(xs[i],ys[i]),b(xt[i],yt[i]);\n    P c(xa,ya),d(xb,yb);\n    P cr=crspt(a,b,c,d);\n    if(onl(a,b,cr) && onl(c,d,cr))\n      arr.pb(mp(abs(c-cr),o[i]^l[i]));\n  }\n  sort(ALL(arr));\n  int ans=0;\n  rep(i,SZ(arr)-1) ans += arr[i].S != arr[i+1].S;\n  cout << ans << endl;\n}\n    \n\nint main(int argc, char *argv[])\n{\n  int n;\n  cin >> n;\n  rep(i, n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(a) a.begin(),a.end()\n#define EPS 1e-9\ntypedef complex<double> Point;\ntypedef vector<Point> VP;\n#define X real()\n#define Y imag()\n\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nPoint crosspointLL(Point a1, Point a2, Point b1, Point b2) {\n  double d1 = cross(b2-b1, b1-a1);\n  double d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  assert(!EQ(d2, 0)); // ???????????????\n  return a1 + d1/d2 * (a2-a1);\n}\n\nint main(void){\n    int N;\n    cin>>N;\n    while(N--){\n        vector<pair<Point,bool>> cross;\n        double ax,ay,bx,by,sx,sy,tx,ty;\n        int n,o,l;\n        cin>>ax>>ay>>bx>>by>>n;\n        Point a={ax,ay},b={bx,by};\n        rep(i,n){\n            cin>>sx>>sy>>tx>>ty>>o>>l;\n            Point s={sx,sy},t={tx,ty};\n            if(isecSS(a,b,s,t)){\n                cross.push_back({crosspointLL(a,b,s,t),o==l});\n            }\n        }\n\n        sort(all(cross));\n        int cnt=0;\n        rep(i,(int)cross.size()-1){\n            cnt += (cross[i].second!=cross[i+1].second);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nusing namespace std;\nvector<pair<pair<double,double>,bool> > cp;\npair<double,double> relv(pair<double,double> a,pair<double,double> b)\n{\n  return make_pair(a.first-b.first,a.second-b.second);\n}\ndouble cross(pair<double,double> va,pair<double,double> vb)\n{\n  return va.first*vb.second-va.second*vb.first;\n}\nvoid crosspoint(pair<double,double> a,pair<double,double> b,pair<double,double> c,pair<double,double> d,bool e)\n{\n  auto ab=relv(a,b),cd=relv(c,d);\n  if(!(cross(ab,relv(a,c))*cross(ab,relv(a,d)) < 0 &&\n       cross(cd,relv(c,a))*cross(cd,relv(c,b)) < 0)) return;\n  if((cross(cd,relv(c,a))+cross(cd,relv(b,d)))==0) return;\n  double midrat=cross(cd,relv(c,a))/(cross(cd,relv(c,a))+cross(cd,relv(b,d)));\n  cp.push_back(make_pair(make_pair(a.first+midrat*ab.first,a.second+midrat*ab.second),e));\n}\n\nint main(void)\n{\n  cout << fixed << setprecision(10) << endl;\n  int n;\n  cin >> n;\n  REP(i,n){\n    int sx,sy,ex,ey;\n    cin >> sx >> sy >> ex >> ey;\n    pair<double,double> s,e;\n    s=make_pair(sx,sy),e=make_pair(ex,ey);\n    cp.clear();\n    int m;\n    cin >> m;\n    REP(i,m){\n      int x[2],y[2],p,q;\n      cin >> x[0] >> y[0] >> x[1] >> y[1] >> p >> q;\n      crosspoint(s,e,make_pair(x[0],y[0]),make_pair(x[1],y[1]),p==q);\n    }\n    SORT(cp);\n    int answer=0;\n    REP(i,cp.size()-1) if(cp[i].second!=cp[i+1].second) ++answer;\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\n\n#ifdef ccout\n#define cout ccout\n#define endl cendl\n#endif\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n\n\n//// geometry ////\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n\tdouble arg() const { return atan2(y, x); }\n\tstatic P2 polar(double length, double theta) { return P2(std::polar(length, theta)); }\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline ostream & operator<<(ostream & out, const P2 & p) { out << p.x << ' ' << p.y; return out; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\n// a から b に向かって、cが右手か左手か。\ninline int clockwise(P2 a, P2 b, P2 c)\n{\n\tconst P2 u = b - a, v = c - a;\n\tif (u.cross(v) > EPS) { return 1; }\n\tif (u.cross(v) < -EPS) { return -1; }\n\tif (u.dot(v) < -EPS) { return -1; }\n\tif (u.sqlength() < v.sqlength() - EPS) { return 1; }\n\treturn 0;\n}\n\n/// 直線\nstruct Line\n{\n\tP2 p, d;\n\texplicit Line(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic Line FromPD(P2 pos, P2 dir) { return Line(pos, dir); }\n\tstatic Line From2Point(P2 a, P2 b) { return Line(a, b - a); }\n};\n\n/// 線分\nstruct LineSeg\n{\n\tP2 p, d;\n\texplicit LineSeg(P2 pos = P2(), P2 dir = P2()) : p(pos), d(dir) { }\n\tstatic LineSeg FromPD(P2 pos, P2 dir) { return LineSeg(pos, dir); }\n\tstatic LineSeg From2Point(P2 a, P2 b) { return LineSeg(a, b - a); }\n\toperator Line() { return Line(p, d); }\n};\n\ninline P2 projective(P2 a, P2 b) { return b * (a.dot(b) / b.sqlength()); }\ninline P2 perpendicular_foot(P2 a, Line b) { Line l = Line(b.p - a, b.d); return a + l.p - projective(l.p, l.d); }\ninline LineSeg projective(LineSeg a, Line b) { return LineSeg(perpendicular_foot(a.p, b), projective(a.d, b.d)); }\n\n// 交点\ninline P2 crossPoint(Line a, Line b) { return a.p + a.d * (b.d.cross(b.p - a.p) / b.d.cross(a.d)); }\n\n// 包括判定\ninline bool contains(LineSeg a, P2 p) { return abs(a.p - p) + abs(a.p + a.d - p) - abs(a.d) < EPS; }\n\n// 交差判定\ninline bool isCross(Line a, Line b) { return abs(a.d.cross(b.d)) > EPS; }\ninline bool isCross(Line a, LineSeg b) { return sign(a.d.cross(b.p - a.p)) * sign(a.d.cross(b.p + b.d - a.d)) <= 0; }\ninline bool isCross(LineSeg a, Line b) { return isCross(b, a); }\ninline bool isCross(LineSeg a, LineSeg b)\n{\n\tP2 ae = a.p + a.d, be = b.p + b.d;\n\treturn clockwise(a.p, ae, b.p) * clockwise(a.p, ae, be) <= 0\n\t\t&& clockwise(b.p, be, a.p) * clockwise(b.p, be, ae) <= 0;\n}\n\n// 重なり判定\ninline bool isOverlap(Line a, Line b) { return abs(a.d.cross(b.p - a.p)) < EPS; }\ninline bool isOverlap(Line a, LineSeg b) { return isOverlap(a, Line(b.p, b.d)); }\ninline bool isOverlap(LineSeg a, Line b) { return isOverlap(b, a); }\ninline bool isOverlap(LineSeg a, LineSeg b)\n{\n\treturn 0 + contains(a, b.p) + contains(a, b.p + b.d)\n\t\t+ contains(b, a.p) + contains(b, a.p + a.d) >= 2;\n}\n\n// 距離\ninline double getDistance(P2 a, P2 b) { return (a - b).length(); }\ninline double getDistance(P2 a, Line b) { return abs(b.d.cross(a - b.p) / b.d.length()); }\ninline double getDistance(P2 a, LineSeg b) {\n\tP2 h = perpendicular_foot(a, (Line)b);\n\treturn contains(b, h) ? getDistance(h, a)\n\t\t: min(getDistance(b.p, a), getDistance(b.p + b.d, a));\n}\ninline double getDistance(Line a, P2 b) { return getDistance(b, a); }\ninline double getDistance(Line a, Line b) { return isCross(a, b) ? 0 : getDistance(a, b.p); }\ninline double getDistance(Line a, LineSeg b) { return isCross(a, b) ? 0 : min(getDistance(a, b.p), getDistance(a, b.p + b.d)); }\ninline double getDistance(LineSeg a, P2 b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, Line b) { return getDistance(b, a); }\ninline double getDistance(LineSeg a, LineSeg b)\n{\n\treturn isCross(a, b) ? 0 :\n\t\tmin(min(getDistance(a, b.p), getDistance(a, b.p + b.d)),\n\t\tmin(getDistance(a.p, b), getDistance(a.p + a.d, b)));\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, xa, ya, xb, yb);\n\t\tLineSeg rt = LineSeg::From2Point(P2(xa, ya), P2(xb, yb));\n\t\tREAD(int, n);\n\t\ttypedef tuple<double, bool, bool> L;\n\t\tvector<L> v;\n\t\tREP(_,n)\n\t\t{\n\t\t\tREAD(int, xs, ys, xt, yt, o, l);\n\t\t\tLineSeg lt = LineSeg::From2Point(P2(xs, ys), P2(xt, yt));\n\t\t\tif (isCross(rt, lt))\n\t\t\t{\n\t\t\t\tv.emplace_back(abs(crossPoint(rt, lt) - rt.p), !o, l);\n\t\t\t}\n\t\t}\n\t\tsort(allof(v));\n\t\t\n\t\tif (v.size() <= 1) { WRITE(0); }\n\t\telse\n\t\t{\n\t\t\tint ret = 0;\n\t\t\tbool cur = get<1>(v[0]) ^ get<2>(v[0]);\n\t\t\tFOR(i, 1, v.size())\n\t\t\t{\n\t\t\t\tbool cond = get<1>(v[i]) ^ get<2>(v[i]);\n\t\t\t\tif (cur != cond) { cur = cond; ret++; }\n\t\t\t}\n\t\t\tWRITE(ret);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <cmath>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n#define USE_MATH_DEFINES\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\ntypedef pair<xy_t, bool> dat;\n\nnamespace std{\n\tbool operator < (const xy_t &a, const xy_t &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\ndouble cross(const xy_t &a, const xy_t &b){\n\treturn imag(conj(a)*b);\n}\n\ndouble dot(const xy_t &a, const xy_t &b){\n\treturn real(conj(a) * b);\n}\n\nint ccw(xy_t a, xy_t b, xy_t c){\n\tb -= a; c -= a;\n\tif(cross(b, c) > EPS) return +1;\n\tif(cross(b, c) < EPS) return -1;\n\tif(dot(b, c) < 0) return  +2;\n\tif(norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool intersectSS(const line &s, const line &t){\n\treturn ccw(s.first, s.second, t.first) *\n\t\tccw(s.first, s.second, t.second) <= 0 &&\n\t\tccw(t.first, t.second, s.first) * \n\t\tccw(t.first, t.second, s.second) <= 0;\n}\n\nxy_t crosspoint(const line &l1, const line &l2){\n\tdouble a = cross(l1.second - l1.first, l2.second - l2.first);\n\tdouble b = cross(l1.second - l2.first, l1.second - l2.first);\n\treturn l2.first + b / a * (l2.second - l2.first);\n}\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint n;\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tline l1(xy_t(xa, ya), xy_t(xb, yb));\n\t\tcin >> n;\n\t\tvector<dat> vd;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdouble xs, ys, xt, yt;\n\t\t\tint o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tline l2(xy_t(xs, ys), xy_t(xt, yt));\n\t\t\tif(intersectSS(l1, l2)){\n\t\t\t\tvd.push_back(dat(crosspoint(l1, l2), l ^ o));\n\t\t\t}\n\t\t}\n\t\tsort(vd.begin(), vd.end());\n\t\tint res = 0;\n\t\tfor(int i = 0; i < (int)vd.size() - 1; i++) if(vd[i].second != vd[i+1].second) res++;\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\tint ismine=-1;\n\tint isunder=-1;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\tpoint(double a,double b,int o,int l)\n\t{\n\t\tx=a;y=b;ismine=o;isunder=l;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn abs((p1-q).cross(p2-q))<EPS && (p1-q).dot(p2-q)<=EPS;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...on_seg(p1,p2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\tint set;\n\tcin>>set;\n\tfor(int chain=0;chain<set;chain++)\n\t{\n\t\tpoint shin[2]; //新路線の始点と終点\n\t\tpoint kizo[100][2]; //既存路線の始点と終点\n\t\tdouble a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tshin[0]=point(a,b);\n\t\tshin[1]=point(c,d);\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint o,l;\n\t\t\tcin>>a>>b>>c>>d>>o>>l;\n\t\t\tkizo[i][0]=point(a,b,o,l);\n\t\t\tkizo[i][1]=point(c,d,o,l);\n\t\t}\n\n\t\t//新路線と既存路線のすべての交点を調べる\n\t\tvector<point> inter;//交点\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif((kizo[i][1]-kizo[i][0]).cross(shin[1]-shin[0])!=0)\n\t\t\t{\n\t\t\t\tpoint kari = intersection(shin[1],shin[0],kizo[i][1],kizo[i][0]);\n\t\t\t\tif(on_seg(kizo[i][1],kizo[i][0],kari))\n\t\t\t\t{\n\t\t\t\t\tkari.ismine=kizo[i][1].ismine;\n\t\t\t\t\tkari.isunder=kizo[i][1].isunder;\n\t\t\t\t\tinter.push_back(kari);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(inter.begin(),inter.end());\n\t\tint ans=99999999;\n\t\tint now;\n\t\tint cnt=0;\n\t\t//x座標y座標昇順にソートした交点を順番に調べながらシミュレートする\n\t\t//最初が地上の場合\n\t\tnow=1;\n\t\tcnt=0;\n\t\tfor(int i=0;i<inter.size();i++)\n\t\t{\n\t\t\tif(inter[i].ismine==1)\n\t\t\t{\n\t\t\t\tif(inter[i].isunder!=now)\n\t\t\t\t{\n\t\t\t\t\tnow=inter[i].isunder;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(inter[i].isunder==now)\n\t\t\t\t{\n\t\t\t\t\tnow=(now+1)%2;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=min(ans,cnt);\n\t\t//最初が地下の場合\n\t\tnow=0;\n\t\tcnt=0;\n\t\tfor(int i=0;i<inter.size();i++)\n\t\t{\n\t\t\tif(inter[i].ismine==1)\n\t\t\t{\n\t\t\t\tif(inter[i].isunder!=now)\n\t\t\t\t{\n\t\t\t\t\tnow=inter[i].isunder;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(inter[i].isunder==now)\n\t\t\t\t{\n\t\t\t\t\tnow=(now+1)%2;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=min(ans,cnt);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nint main(){\n  int T; cin>>T;\n  int xa,ya,xb,yb;\n  while(cin>>xa>>ya>>xb>>yb){\n    L newline(P(xa,ya),P(xb,yb));\n    vector< pair<P,int> > cps;\n    int n; cin>>n;\n    while(n--){\n      int x1,y1,x2,y2,o,l;\n      cin>>x1>>y1>>x2>>y2>>o>>l;\n      L ln(P(x1,y1),P(x2,y2));\n      if(intersectLL(newline, ln)){\n        cps.push_back(make_pair(abs(crosspoint(newline,ln)-newline[0]), o ^ l));\n      }\n    }\n    sort(cps.begin(), cps.end());\n\n    int ans = 0;\n    FOR(i,1,cps.size()){\n      if(cps[i].second != cps[i-1].second)ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> C;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define EPS (1e-8)\n#define EQ(a,b) (abs(a-b) < EPS)\n#define EQV(a,b) (EQ(a.real(),b.real()) && EQ(a.imag(),b.imag()))\n\ndouble cross(C a, C b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nbool is_crossed(C a1, C a2, C b1, C b2) {\n  return cross(a2-a1, b2-a1) * cross(a2-a1, b1-a1) < EPS &&\n         cross(b2-b1, a2-b1) * cross(b2-b1, a1-b1) < EPS;\n}\n\nC intersection(C a1, C a2, C b1, C b2) {\n  C b = b2 - b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1 + (a2-a1) * t;\n}\n\nC s[100], e[100];\n\nvoid solve() {\n  int xa, ya, xb, yb, n;\n  cin>>xa>>ya>>xb>>yb>>n;\n  C a(xa, ya), b(xb, yb);\n  C ab = b - a;\n  \n  vector<pair<double,pair<int,int> > > iss;\n  rep(i,n) {\n    int xs, ys, xt, yt, o, l;\n    cin>>xs>>ys>>xt>>yt>>o>>l;\n    C s(xs, ys), t(xt, yt);\n    C st = t - s;\n    \n    if(!is_crossed(a, b, s, t)) continue;\n    if(abs(cross(ab, st)) < EPS) continue;\n    C is = intersection(a, b, s, t);\n    iss.push_back(make_pair(is.real(), make_pair(o,l)));\n  }\n  \n  sort(iss.begin(), iss.end());\n  int res = 1000;\n  rep(z,2) {\n    int mode = z, tres = 0;\n    rep(i,iss.size()) {\n      int to = iss[i].second.first, tl = iss[i].second.second;\n      bool flag = false;\n      if ((to == 1 && tl != mode) || (to == 0 && tl == mode)) {\n        tres++; mode++;\n        if (mode >= 2) mode = 0;\n      }\n    }\n    res = min(tres, res);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  int n;\n  cin>>n;\n  rep(i,n)\n    solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, int xo, int yo, int dx, int dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tdouble r = sqrt((double)dx * dx + dy * dy);\n\tx = _x * dx / r + _y * dy / r;\n\ty = _y * dx / r - _x * dy / r;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < -EPS || x > sqrt((double)dx * dx + dy * dy) + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(double& x, double& y, int xo, int yo, int dx, int dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tint r = dx * dx + dy * dy;\n\tx = _x * dx / r + _y * dy / r;\n\ty = _y * dx / r - _x * dy / r;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > 1) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> point;\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define pb push_back\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin(); itr!=(c).end(); itr++)\n\ndouble cross(point a, point b){\n  return ( a.real()*b.imag() - a.imag()*b.real() );\n}\nbool is_intersection_ls(point a1, point a2, point b1, point b2){\n  return ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS &&\n           cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS );\n}\npoint intersection_ls(point a1, point a2, point b1, point b2){\n  point b = b2 - b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1+d2);\n  return a1 + (a2-a1)*t;\n}\n\nclass sen{\npublic:\n  point p;\n  int o,l;\n  sen(point _p, int _o, int _l){\n    p = _p;\n    o = _o;\n    l = _l;\n  }\n  bool operator<(const sen& a)const{\n    if( abs(p.real()-a.p.real())>EPS ) return p.imag() < a.p.imag();\n    return p.real() < a.p.real();\n  }\n};\n\npoint s,e;\npoint ds[110], de[110];\nint O[110], L[110];\nint n;\n\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    cin >> s.real() >> s.imag() >> e.real() >> e.imag();\n    cin>>n;\n    rep(i,n){\n      cin >> ds[i].real() >> ds[i].imag();\n      cin >> de[i].real() >> de[i].imag();\n      cin >> O[i] >> L[i];\n    }\n#if DEB\n    rep(i,n){\n      cout << ds[i] << \" : \" << de[i] << \" ,\" << O[i] << \" \" << L[i] << endl;\n    }\n#endif\n\n    vector<sen> v;\n    rep(i,n){\n      if( abs(cross(e-s,de[i]-ds[i]))<EPS )continue;\n      if( is_intersection_ls(s,e,ds[i],de[i]) ){\n        point p = intersection_ls(s,e,ds[i],de[i]);\n        v.push_back(sen(p,O[i],L[i]));\n      }\n    }\n\n    // o ª1Èç©Ð\n    // l ª\n    int nl;\n    int cnt = 0;\n    sort(all(v));\n\n    if( v.size()>0 ){\n      nl = (v[0].o==1 ? v[0].l : !v[0].l);\n    }\n\n    \n    REP(i,1,v.size()){\n      if( (v[i].o==1 && v[i].l!=nl) ||\n          (v[i].o==0 && v[i].l==nl) ){\n        nl = !nl;\n        cnt++;\n      }\n      /*\n      if( v[i].o==1 ){\n        if( v[i].l!=nl ){\n          nl = v[i].l;\n          cnt++;\n        }\n      }else{\n        if( v[i].l==nl ){\n          nl = (v[i].l==1 ? 0 : 1);\n          cnt++;\n        }\n      }\n      */\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nstruct Segment{ Point p1, p2; };\n\nclass C{\npublic:\n  Point p;\n  int o, l;\n  double d;\n  C(){}\n  C(Point p, int o, int l, double d): p(p), o(o), l(l), d(d) {}\n  bool operator < (const C& s) const {\n    return d < s.d;\n  }\n};\n\nvector<C> vec;\nPoint A, B;\nint n, T;\n\nconst double EPS = 1e-10;\n\ndouble dot(Point a, Point b){\n  return real(conj(a) * b);\n}\n\ndouble cross(Point a, Point b){\n  return imag(conj(a) * b);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool isIntersect(Segment s1, Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n  assert(isIntersect(s1, s2));\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\n\nmain(){\n  cin >> T;\n  while(T--){\n    vec.clear();\n    cin >> A.real() >> A.imag() >> B.real() >> B.imag();\n    cin >> n;\n    for(int i=0;i<n;i++){\n      Point s, t;\n      int o, l;\n      cin >> s.real() >> s.imag() >> t.real() >> t.imag() >> o >> l;\n      Segment s1 = (Segment){A, B};\n      Segment s2 = (Segment){s, t};\n      if(isIntersect(s1, s2)){\n        Point p = getCrossPoint(s1, s2);\n        vec.push_back(C(p, o, l, abs(p-A)));\n      }\n    }\n    sort(vec.begin(), vec.end());\n    int cnt = 0;\n    int p = (vec[0].o == vec[0].l ? 1 : 0);\n    for(int i=0;i<vec.size();i++){\n      int t = (vec[i].o == vec[i].l ? 1 : 0);\n      if(p != t) cnt++;\n      p = t;\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <limits>\n\nusing namespace std;\n\ntypedef struct {\n    double x, y;\n} pt;\n\ntypedef pair<pt, pt> seg;\n\nseg mkseg(double ax, double ay, double bx, double by) {\n    pt a = {ax, ay};\n    pt b = {bx, by};\n    return seg(a, b);\n}\n\ndouble inf = numeric_limits<double>::infinity();\n\npt seg_cross(seg a, seg b) {\n    double A = (a.second.x - a.first.x) / (a.second.y - a.first.y);\n    double B = (b.second.x - b.first.x) / (b.second.y - b.first.y);\n\n    if (A == inf) {\n        double y = a.second.y;\n        double x = B * (y - b.first.y) + b.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    if (B == inf) {\n        double y = b.second.y;\n        double x = A * (y - a.first.y) + a.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    double y = (A * a.first.y - B * b.first.y + b.first.x - a.first.x) / (A - B);\n    double x = A * (y - a.first.y) + a.first.x;\n    pt p = {x, y};\n    return p;\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n\n    seg new_seg = mkseg(ax, ay, bx, by);\n\n    int n;\n    cin >> n;\n\n    vector< pair<pt, bool> > pts;\n\n    while (n--) {\n        int ax_, ay_, bx_, by_;\n        int pos, owner;\n        cin >> ax_ >> ay_ >> bx_ >> by_ >> pos >> owner;\n\n        seg s = mkseg(ax_, ay_, bx_, by_);\n\n        double minx = min(ax_, bx_);\n        double maxx = max(ax_, bx_);\n\n        pt c = seg_cross(new_seg, s);\n        cerr << \"CROSS AT \" << c.x << \",\" << c.y << endl;\n\n        bool flag = (pos == 1) ^ (owner == 1);\n        if (minx <= c.x && c.x <= maxx && min(ax, bx) <= c.x && c.x <= max(ax, bx)) {\n            cerr << \"PUSH \" << c.x << \",\" << c.y << endl;\n            pts.push_back(make_pair(c, flag));\n        }\n\n        // route r;\n        // line l = line_from_point(ax_, ay_, bx_, by_);\n        // r.minx = min(ax_, bx_);\n        // r.maxx = max(ax_, bx_);\n        // r.flag = (pos == 1) ^ (owner == 1);\n\n        // point cp = cross_point(new_line, l);\n        // double cpx = cp.first;\n        // if (r.minx <= cpx && cpx <= r.maxx && ax <= cpx && cpx <= bx) {\n        //     cross_points.push_back(make_pair(cp, r.flag));\n        // }\n    }\n\n    struct {\n        bool operator()(pair<pt, bool> a, pair<pt, bool> b) {\n            return a.first.x < b.first.x;\n        }\n    } by_x;\n\n    sort(pts.begin(), pts.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<pt, bool> >::iterator it = pts.begin(); it != pts.end(); it++) {\n        pair<pt, bool> p = *it;\n        cerr << \"FOUND \" << p.first.x << \" \" << p.first.y << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n\n    /*\n    struct {\n        bool operator()(pair<point, bool> a, pair<point, bool> b) {\n            return a.first.first < b.first.first;\n        }\n    } by_x;\n\n    sort(cross_points.begin(), cross_points.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<point, bool> >::iterator it = cross_points.begin(); it != cross_points.end(); it++) {\n        pair<point, bool> p = *it;\n        // cout << p.first.first << \" \" << p.first.second << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n    */\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\ntypedef pair<double, int> P;\n\nint main()\n{\n  int T; cin >> T;\n  while(T--) {\n    Segment ab;\n    cin >> ab.p1.x >> ab.p1.y >> ab.p2.x >> ab.p2.y;\n    \n    int n; cin >> n;\n    vector<Segment> s(n);\n    vector<int> o(n), l(n);\n    for(int i = 0; i < n; i++) {\n      cin >> s[i].p1.x >> s[i].p1.y >> s[i].p2.x >> s[i].p2.y >> o[i] >> l[i];\n    }\n\n    vector<P> isct_s;\n    for(int i = 0; i < n; i++) {\n      if(!intersect(ab, s[i]) || isParallel(ab, s[i])) continue;\n      double dist = getDistance(ab.p1, getCrossPoint(ab, s[i]));\n      isct_s.push_back(P(dist, i));\n    }\n    sort(isct_s.begin(), isct_s.end());\n    \n    int level = (o[isct_s[0].second] ? l[isct_s[0].second] : !l[isct_s[0].second]);\n    int ans = 0;\n    for(int i = 1; i < isct_s.size(); i++) {\n      if(o[isct_s[i].second] == 1 && level != l[isct_s[i].second] ||\n\t o[isct_s[i].second] == 0 && level == l[isct_s[i].second]) ans++, level = !level;\n    }\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T> bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T> bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n// 実数\nusing Real = double;\n// 点\nusing Point = complex<Real>;\nconst Real EPS = 1e-10, PI = acos(-1);\n\n// 実数同士の比較\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point& p, const Real& d) {\n    return Point(real(p) * d, imag(p) * d);\n}\n\n// 点の入力\nistream& operator>>(istream& is, Point& p) {\n    Real a, b;\n    is >> a >> b;\n    p = Point(a, b);\n    return is;\n}\n\n//// 点の出力\n//ostream &operator<<(ostream &os, Point &p) {\n//  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n//}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point& p) {\n    return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\n// ラジアンを度数に変換\nReal radian_to_degree(Real r) {\n    return (r * 180.0 / PI);\n}\n\n// 度数をラジアンに変換\nReal degree_to_radian(Real d) {\n    return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point& a, const Point& b, const Point& c) {\n    const Point v(b - a), w(c - a);\n    Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n    if (alpha > beta) swap(alpha, beta);\n    Real theta = (beta - alpha);\n    return min(theta, 2 * acos(-1) - theta);\n}\n\n// ソート x座標が小さい順に並べる x座標が同じならy座標が小さい順\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        return !eq(a.real(), b.real()) ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\n// 2点を通る直線\nstruct Line {\n    Point a, b;\n\n    Line() = default;\n\n    Line(Point a, Point b) : a(a), b(b) {}\n\n    Line(Real A, Real B, Real C) // Ax + By = C\n    {\n        if (eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n        else if (eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n        else a = Point(0, C / B), b = Point(C / A, 0);\n    }\n\n    friend ostream& operator<<(ostream& os, Line& p) {\n        return os << p.a << \" to \" << p.b;\n    }\n\n    friend istream& operator>>(istream& is, Line& a) {\n        return is >> a.a >> a.b;\n    }\n};\n\n// 2点を結ぶ線分\nstruct Segment : Line {\n    Segment() = default;\n    Segment(Point a, Point b) : Line(a, b) {}\n};\n\n\n// 円\nstruct Circle {\n    // 中心\n    Point p;\n    // 半径\n    Real r;\n\n    Circle() = default;\n\n    Circle(Point p, Real r) : p(p), r(r) {}\n};\n\n// 点集合\nusing Points = vector< Point >;\n// ポリゴン 反時計回り\nusing Polygon = vector< Point >;   // 注意!! 凸多角形は反時計回りに与える.(保証されない場合は面積が負なら reverse をかける)\n// 線分集合\nusing Segments = vector< Segment >;\n// 直線集合\nusing Lines = vector< Line >;\n// 円集合\nusing Circles = vector< Circle >;\n\n// 外積\nReal cross(const Point& a, const Point& b) {\n    return real(a) * imag(b) - imag(a) * real(b);\n}\n\n// 内積\nReal dot(const Point& a, const Point& b) {\n    return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// 点の回転方向\n//          +1\n//          \n//  +2   a   0   b  -2\n//\n//          -1\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n    if (cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n    if (dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n    if (norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n    return 0;                         // \"ON_SEGMENT\"\n}\n\n// 線分同士の交差判定\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment& s, const Segment& t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 直線同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\nPoint crosspoint(const Line& l, const Line& m) {\n    Real A = cross(l.b - l.a, m.b - m.a);\n    Real B = cross(l.b - l.a, l.b - m.a);\n    if (eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n    return m.a + (m.b - m.a) * B / (A + 1e-18);\n}\n\n// 線分同士の交点を返す (交差することが要請されるのかな (事前にintersect を呼べばいい))\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment& l, const Segment& m) {\n    return crosspoint(Line(l), Line(m));\n}\n\nReal CalcDist(const Segment& s, const Point& p) {\n    double t = dot(s.b - s.a, p - s.a) / norm(s.b - s.a);\n    Point c = s.a + (s.b - s.a) * t;\n    Real res = 1000000.0;\n    if (t > -EPS && t < 1.0 + EPS) return sqrt(norm(p - c));\n    chmin(res, sqrt(norm(p - s.b)));\n    chmin(res, sqrt(norm(p - s.a)));\n    return res;\n}\n\nReal CalcDist(const Segment& a, const Segment& b) {\n    return min({CalcDist(a, b.a), CalcDist(a, b.b), CalcDist(b, a.a), CalcDist(b, a.b)});\n}\n\nint InPolygon(Point& p, const Polygon& pol) {\n    int n = pol.size();\n\n    bool is_in = false;\n    for(int i = 0; i < n; ++i) {\n        Point a = pol[i] - p;\n        Point b = pol[(i + 1) % n] - p;\n\n        //　辺上にあるか\n        if (eq(cross(a, b), 0) && dot(a, b) < EPS) return 1;\n        // 交わっているか\n        if (a.imag() < b.imag()) swap(a, b);\n        if (a.imag() > EPS && b.imag() < EPS && cross(a, b) > EPS) is_in = !is_in;\n    }\n\n    return (is_in) ? 2 : 0;\n}\n\nbool CmpX(const Point& lhs, const Point& rhs) {\n    if (lhs.real() != rhs.real()) return lhs.real() < rhs.real();\n    return lhs.imag() < rhs.imag();\n}\n\nPolygon ConvexHull(vector<Point>& points) {\n    int n = points.size();\n    sort(points.begin(), points.end(), CmpX);\n\n    int k = 0;\n    vector<Point> qs(n * 2);\n\n    // 下側凸包を作成\n    for (int i = 0; i < n; ++i) {\n        // 凸じゃなくなった\n        while (k >= 2 && cross(qs[k - 1] - qs[k - 2], points[i] - qs[k - 2]) < -EPS) --k;\n        qs[k++] = points[i];\n    }\n\n    // 上側凸包を作成\n    for (int i = n - 2, tmp = k; i >= 0; --i) {\n        while (k > tmp && cross(qs[k - 1] - qs[k - 2], points[i] - qs[k - 2]) < -EPS) --k;\n        qs[k++] = points[i];\n    }\n\n    // 作った\n    qs.resize(k - 1);\n    return qs;\n}\n\nReal CalcDist(vector<Segment>& a, vector<Segment>& b) {\n\n    Real ret = 1000000.0;\n\n    // 線分同士の距離\n    for (auto& segA : a) {\n        for (auto& segB : b) {\n            if (intersect(segA, segB)) return 0.0;\n            chmin(ret, CalcDist(segA, segB));\n        }\n    }\n\n    return ret;\n}\n\nstruct Info {\n    Segment seg;\n    int type;\n\n    Info() = default;\n    Info(Segment seg, int type) : seg(seg), type(type) {}\n};\n\nint main() {\n\n    int query;\n    cin >> query;\n    vector<int> ans(query);\n\n    for (int i = 0; i < query; ++i) {\n        Point a, b;\n        cin >> a >> b;\n\n        Segment train(a, b);\n\n        int n;\n        cin >> n;\n\n        vector<Info> stations;\n\n        for (int j = 0; j < n; ++j) {\n            Point s, t;\n            cin >> s >> t;\n            int o, l;\n            cin >> o >> l;\n            Segment seg(s, t);\n            if (intersect(seg, train)) {\n                if (l == 0) o = 1 - o;\n                stations.emplace_back(seg, o);\n            }\n        }\n\n        if (stations.size() == 0) {\n            ans[i] = 0;\n            continue;\n        }\n\n        // 駅の始点からの距離が近い順にソート\n        sort(stations.begin(), stations.end(), [&](Info& lhs, Info& rhs) {\n            return norm(crosspoint(lhs.seg, train) - train.a) < norm(crosspoint(rhs.seg, train) - train.a);\n            });\n\n        int res = 0;\n        int prev_type = stations[0].type;\n        for (int j = 1; j < stations.size(); ++j) {\n            Info& info = stations[j];\n            if (info.type != prev_type) {\n                prev_type = info.type;  \n                ++res;\n            }\n        }\n        ans[i] = res;\n    }\n\n    for (auto res : ans) cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef complex<double> C;\n\n#define EPS (1e-9)\n\ndouble cross(C a, C b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint is_intersected(C a1, C a2, C b1, C b2) {\n  return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS) &&\n         (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS);  \n}\n\nint t;\nC s[100], e[100];\nint o[100], l[100];\n\nvoid solve() {\n  double xa, ya, xb, yb;\n  cin>>xa>>ya>>xb>>yb;\n  C a(xa, ya), b(xb, yb);\n  C ab = b - a;\n  \n  int n;\n  cin>>n;\n  for (int i = 0; i < n; i += 1) {\n    cin>>s[i].real()>>s[i].imag();\n    cin>>e[i].real()>>e[i].imag();\n    cin>>o[i]>>l[i];\n  }\n  \n  // ð_ÌWðßé\n  // xÀWÆù¶Hüf[^ÌY\n  vector<pair<double,int> > iss;\n  for (int i = 0; i < n; i += 1) {\n    if (!is_intersected(a, b, s[i], e[i])) continue;\n    if (abs(cross(b-a, e[i]-s[i])) < EPS) continue;\n    C ex = e[i] - s[i];\n    /*\n    C pp = xa + ab * cross(ex, s[i] - xa) / cross(ex, ab);\n    iss.push_back(make_pair(pp.real(), i));\n    */\n    double d1 = abs(cross(ex, xa - s[i]));\n    double d2 = abs(cross(ex, xb - s[i]));\n    double t = d1 / (d1 + d2);\n    iss.push_back(make_pair(t, i));\n  }\n  \n  sort(iss.begin(), iss.end());\n  int res = 100;\n  for (int z = 0; z < 2; z += 1) {\n    int mode = z, tres = 0;\n    for (int i = 0; i < iss.size(); i += 1) {\n      int num = iss[i].second;\n      \n      bool flag = false;\n      if (o[num] == 1 && l[num] != mode) {\n        flag = true;\n      } else if (o[num] == 0 && l[num] == mode) {\n        flag = true;\n      }\n      \n      if (flag) {\n        tres++;\n        mode = !mode;\n        //mode = (mode == 1) ? 0 : 1 ;\n      }\n    }\n    res = min(res, tres);\n  }\n  cout<<res<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  cin>>t;\n  \n  for(int i=0;i<t;i++) solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef pair <double,int> P;\n\ndouble cross(point a,point b){return a.X*b.Y-a.Y*b.X;}\ndouble dot(point a,point b){return a.X*b.X+a.Y*b.Y;}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<0) return 2;//\"ONLINE_BACK\"\n  if(abs(d)<abs(e)) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\nbool intersection(point a,point b,point c,point d){\n  return (ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0);\n}\n\npoint CrossPoint(point a,point b,point c,point d){\n  point base=d-c;\n  double d1=abs(cross(base,(a-c)));\n  double d2=abs(cross(base,(b-c)));\n  double t=d1/(d1+d2);\n  return (b-a)*t+a;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int sx,sy,gx,gy,n,o[101],l[101];\n    cin>>sx>>sy>>gx>>gy;\n    cin>>n;\n    \n    P D[101];\n    for(int i=0,a,b,c,d;i<n;i++){\n      cin>>a>>b>>c>>d>>o[i]>>l[i];\n      point S=point(sx,sy),G=point(gx,gy),S2=point(a,b),G2=point(c,d);\n      if(!intersection(S,G,S2,G2))i--,n--;\n      else D[i].first=abs(CrossPoint(S,G,S2,G2)-S),D[i].second=i;\n    }\n    \n\n    sort(D,D+n);\n    int ans=0,pos=l[D[0].second];\n    if(!o[D[0].second]) pos =!pos;\n    for(int i=1;i<n;i++) {\n      int I=D[i].second;\n      if(o[I]&&pos!=l[I])pos=!pos,ans++;\n      if(!o[I]&&pos==l[I])pos=!pos,ans++;\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X real()\n#define Y imag()\n#define z 0.00000002\n#define INF 1e9\nusing namespace std;\ntypedef complex <double> point;\n\n\ndouble cross(point a,point b){\n  return a.X*b.Y-a.Y*b.X;\n}\n\ndouble dot(point a,point b){\n  return a.X*b.X+a.Y*b.Y;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)-z>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)+z<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<z) return 2;//\"ONLINE_BACK\"\n  if(abs(d)-abs(e)<z) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\n\npoint CrossPoint(point a,point b,point c,point d){\n  point base=d-c;\n  double d1=abs(cross(base,(a-c)));\n  double d2=abs(cross(base,(b-c)));\n  double t=d1/(d1+d2);\n  point e=(b-a)*t+a;\n  if(!ccw(a,b,e)&&!ccw(c,d,e)) return e;\n  return  point(INF,INF);\n}\n\n\nint main(){\n  /*  int a,b,c,d,e,f,g,h;\n  cin>>a>>b>>c>>d>>e>>f>>g>>h;\n  point res=CrossPoint(point(a,b),point(c,d),point(e,f),point(g,h));\n  cout <<res.X<<\" \"<<res.Y<<endl;*/\n\n  int q;\n  cin>>q;\n  while(q--){\n    int sx,sy,gx,gy,o[101],l[101];\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    \n    point D[101];\n    for(int i=0,a,b,c,d;i<n;i++){\n      cin>>a>>b>>c>>d>>o[i]>>l[i];\n      D[i]=CrossPoint(point(sx,sy),point(gx,gy),point(a,b),point(c,d));\n      if(D[i].X==INF)i--,n--;\n    }\n\n\n    for(int i=0;i<n-1;i++)\n      for(int j=n-1;j>i;j--)\n\tif(abs(D[j]-point(sx,sy))<abs(D[j-1]-point(sx,sy))){\n\t  swap(D[j],D[j-1]);\n\t  swap(o[j],o[j-1]);\n\t  swap(l[j],l[j-1]);\n\t}\n    \n    int ans=0;\n    bool pos=l[0];\n    if(!o[0]) pos =!pos;\n    for(int i=1;i<n;i++) {\n      if(o[i]&&pos!=l[i])pos=!pos,ans++;\n      if(!o[i]&&pos==l[i])pos=!pos,ans++;\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass Road\n{\npublic:\n    Road(int _xs, int _ys, int _xt, int _yt, bool _l)\n    {\n        xs = _xs;\n        ys = _ys;\n        xt = _xt;\n        yt = _yt;\n        l = _l;\n    }\n\n    int xs, ys, xt, yt;\n\n    //l : true??§?????¶\n    bool l;\n\n};\n\n//https://qiita.com/ykob/items/ab7f30c43a0ed52d16f2\nbool crossed(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) \n{\n  int ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  int tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  int tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  int td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n  return tc * td < 0 && ta * tb < 0;\n  // return tc * td <= 0 && ta * tb <= 0; // ?????????????????´???\n};\nint main()\n{\n    auto data_num = 0;\n    cin >> data_num;\n    for(auto i = 0; i < data_num; i++)\n    {\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n\n        int n;\n        cin >> n;\n        vector<Road> roads;\n        roads.reserve(n);\n\n        vector< pair<float, bool> > crossPoints{};\n\n        for(int j = 0; j < n; j++)\n        {\n\n            int xs, ys, xt, yt;\n            bool o, l;\n\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n\n            //???????????¢?????????\n            roads.push_back( Road(xs, ys, xt, yt, !(o ^ l) ) );\n        }\n\n        for(const auto& r : roads)\n        {\n            if(crossed(xa, ya, xb, yb, r.xs, r.ys, r.xt, r.yt))\n            {\n                float cross_x = ((r.ys * r.xt - r.xs * r.yt) * (xb - xa) - (ya * xb - xa * yb) * (r.xt - r.xs)) / (float)((yb - ya) * (r.xt - r.xs) - (xb - xa) * (r.yt - r.ys)); \n                float cross_y = ((r.ys * r.xt - r.xs * r.yt) * (yb - ya) - (ya * xb - xa * yb) * (r.yt - r.ys)) / (float)((yb - ya) * (r.xt - r.xs) - (xb - xa) * (r.yt - r.ys)); \n                float differ_x = xa - cross_x;\n                float differ_y = ya - cross_y;\n                float dist = differ_x * differ_x + differ_y * differ_y;\n\n                crossPoints.push_back( make_pair(dist, r.l) );\n            }\n        }\n        sort(crossPoints.begin(), crossPoints.end());\n\n\n\n        auto ans = 0;\n        bool nowHeight = crossPoints[0].second;\n        for(const auto& cp : crossPoints)\n        {\n            if(nowHeight != cp.second)\n            {\n                nowHeight = cp.second;\n                ans++;\n            }\n        }\n\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ndouble pi=3.14159265359; //円周率\ndouble EPS = 1e-10; //誤差\n\nclass point\n{\n\tpublic:\n\tdouble x,y;\n\tint ismine=-1;\n\tint isunder=-1;\n\n\tpoint()\n\t{x=0;y=0;}\n\t//コンストラクタ\n\tpoint(double a,double b)\n\t{\n\t\tx=a;y=b;\n\t}\n\tpoint(double a,double b,int o,int l)\n\t{\n\t\tx=a;y=b;ismine=o;isunder=l;\n\t}\n\n\t//足し算\n\tpoint operator + (point p)\n\t{\n\t\treturn point(x+p.x,y+p.y);\n\t}\n\t//引き算\n\tpoint operator - (point p)\n\t{\n\t\treturn point(x-p.x,y-p.y);\n\t}\n\t//d倍\n\tpoint operator * (double d)\n\t{\n\t\treturn point(x*d,y*d);\n\t}\n\t//x座標昇順でソートする\n\tbool operator < (const point &p)\n\tconst {\n\t\tif(std::abs(x-p.x)>EPS)\n\t\t\treturn x<p.x;\n\t\telse\n\t\t\treturn y<p.y;\n\t}\n\t//内積\n\t//直交判定...abs(dot())<EPS\n\tdouble dot(point p)\n\t{\n\t\treturn x*p.x+y*p.y;\n\t}\n\t//外積\n\t//平行判定...abs(cross())<EPS\n\tdouble cross(point p)\n\t{\n\t\treturn x*p.y-y*p.x;\n\t}\n\t//絶対値を求める\n\tdouble abs()\n\t{\n\t\treturn sqrt(x*x+y*y);\n\t}\n\t//単位ベクトルを求める\n\tpoint ev()\n\t{\n\t\treturn point(x/abs(),y/abs());\n\t}\n\t//単位法線ベクトル（の1つ）を求める\n\t//もうひとつは-1倍することで求まる\n\tpoint nev()\n\t{\n\t\treturn point(-y/abs(),x/abs());\n\t}\n\t//2点間の距離を求める\n\t//distがEPS未満なら2点は同じ位置にあるとみなす\n\tdouble pdist(point p)\n\t{\n\t\tpoint v=point(p.x-x,p.y-y);\n\t\treturn v.abs();\n\t}\n\t//この点と直線p1-p2の距離を求める\n\tdouble ldist(point p1,point p2)\n\t{\n\t\treturn std::abs((p2.y-p1.y)*x-(p2.x-p1.x)*y+p2.x*p1.y+p2.y*p1.x)/(p2-p1).abs();\n\t}\n\n};\n\n//線分p1-p2上に点qがあるか判定\nbool on_seg(point p1,point p2,point q)\n{\n\treturn abs((p1-q).cross(p2-q))<EPS && (p1-q).dot(p2-q)<=EPS;\n}\n//直線p1-p2と直線q1-q2の交点\n//線分の交差判定はこれの戻り値が線分上にあるかどうかで判定する...on_seg(p1,p2,intersection(p1,p2,q1,q2))\npoint intersection(point p1,point p2,point q1,point q2)\n{\n\treturn p1 + (p2-p1) * ((q2-q1).cross(q1-p1) / (q2-q1).cross(p2-p1));\n}\n//n頂点からなる多角形の面積を求める(vectorで頂点は与えられる)\ndouble area(vector<point> p)\n{\n\tdouble ret=0;\n\tfor(int i=0;i<p.size()-1;i++)\n\t{\n\t\tret+=p[i].cross(p[i+1]);\n\t}\n\tret+=p[p.size()-1].cross(p[0]);\n\tret/=2;\n\treturn ret;\n}\n/*\n3点a,b,cをa->b->cと進むとき、\n* a->bで時計方向に折れてb->c (clockwise)\n* a->bで反時計方向に折れてb->c(counter clockwise)\n* a->bで逆を向いてaを通り越してb->c(c--a--b on line)\n* a->bでそのままb->c(a--b--c on line)\n* a->bで逆を向いてb->c(a--c--b on line)\n\nのいずれのパターンかを判定する\n*/\nint ccw(point a,point b,point c)\n{\n\tb=b-a;c=c-a;\n\tif(b.cross(c)>EPS)\n\t\treturn 1; //counter clockwise\n\tif(b.cross(c)<-EPS)\n\t\treturn -1; //clockwise\n\tif(b.dot(c)<-EPS)\n\t\treturn 2; //c--a--b on line\n\tif(b.x*b.x+b.y*b.y < c.x*c.x+c.y*c.y)\n\t\treturn -2; //a--b--c on line\n\treturn 0; //a--c--b on line\n}\n//凸包を求める\nvector<point> convex_hull(vector<point> p)\n{\n\tint n=p.size();\n\tint k=0;\n\tsort(p.begin(),p.end());\n\tvector<point> ch(2*n);\n\t//lower-hull 下側凸包\n\tfor(int i=0;i<n;ch[k++]=p[i++])\n\t{\n\t\twhile(k>=2 && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\t//upper-hull 上側凸包\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=p[i--])\n\t{\n\t\twhile(k>=t && ccw(ch[k-2],ch[k-1],p[i])<=0)\n\t\t\tk--;\n\t}\n\tch.resize(k-1);\n\treturn ch;\n}\n\nint main()\n{\n\tint set;\n\tcin>>set;\n\tfor(int chain=0;chain<set;chain++)\n\t{\n\t\tpoint shin[2]; //新路線の始点と終点\n\t\tpoint kizo[100][2]; //既存路線の始点と終点\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tshin[0]=point(a,b);\n\t\tshin[1]=point(c,d);\n\t\tint n;\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint o,l;\n\t\t\tcin>>a>>b>>c>>d>>o>>l;\n\t\t\tkizo[i][0]=point(a,b,o,l);\n\t\t\tkizo[i][1]=point(c,d,o,l);\n\t\t}\n\n\t\t//新路線と既存路線のすべての交点を調べる\n\t\tvector<point> inter;//交点\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif((kizo[i][1]-kizo[i][0]).cross(shin[1]-shin[0])!=0)\n\t\t\t{\n\t\t\t\tpoint kari = intersection(shin[1],shin[0],kizo[i][1],kizo[i][0]);\n\t\t\t\tif(on_seg(kizo[i][1],kizo[i][0],kari))\n\t\t\t\t{\n\t\t\t\t\tkari.ismine=kizo[i][1].ismine;\n\t\t\t\t\tkari.isunder=kizo[i][1].isunder;\n\t\t\t\t\tinter.push_back(kari);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(inter.begin(),inter.end());\n\t\tint ans=99999999;\n\t\tint now;\n\t\tint cnt=0;\n\t\t//x座標y座標昇順にソートした交点を順番に調べながらシミュレートする\n\t\t//最初が地上の場合\n\t\tnow=1;\n\t\tcnt=0;\n\t\tfor(int i=0;i<inter.size();i++)\n\t\t{\n\t\t\tif(inter[i].ismine==1)\n\t\t\t{\n\t\t\t\tif(inter[i].isunder!=now)\n\t\t\t\t{\n\t\t\t\t\tnow=inter[i].isunder;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(inter[i].isunder==now)\n\t\t\t\t{\n\t\t\t\t\tnow=(now+1)%2;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=min(ans,cnt);\n\t\t//最初が地下の場合\n\t\tnow=0;\n\t\tcnt=0;\n\t\tfor(int i=0;i<inter.size();i++)\n\t\t{\n\t\t\tif(inter[i].ismine==1)\n\t\t\t{\n\t\t\t\tif(inter[i].isunder!=now)\n\t\t\t\t{\n\t\t\t\t\tnow=inter[i].isunder;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(inter[i].isunder==now)\n\t\t\t\t{\n\t\t\t\t\tnow=(now+1)%2;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=min(ans,cnt);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 0.000000001\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nclass Point {\npublic:\n  double x, y;\n  Point (double x = 0,double y = 0): x(x),y(y) {}\n  Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n  Point operator * (double a) { return Point(a*x,a*y); }\n  Point operator / (double a) { return Point(x/a,y/a); }\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x+y*y; }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\nstruct Segment { \n  Point p1, p2;\n  int o,l;\n};\ntypedef Segment Line;\n\nstruct CrossPoint {\n  Point p1;\n  int o,l;\n  bool operator<( const CrossPoint& CP ) const {\n    return p1.x == CP.p1.x ? p1.y < CP.p1.y : p1.x < CP.p1.x;\n  }\n};\n\nPoint MakePoint(int x,int y);\nSegment MakeSegment(Point x,Point y);\nint ccw(Point p1,Point p2,Point p3);\nbool intersect(Point p1,Point p2,Point p3,Point p4);\nbool intersect(Segment s1,Segment s2);\ndouble dot(Vector a,Vector b);\ndouble cross(Vector a,Vector b);\nPoint getCrossPoint(Segment s1,Segment s2);\n\nPoint MakePoint(int x,int y){\n  Point a;\n  a.x= x;\n  a.y= y;\n  return a;\n}\n\nLine MakeSegment(Point x,Point y){\n  Line a;\n  a.p1 = x;\n  a.p2 = y;\n  return a;\n}\n\nCrossPoint MakeCrossPoint(Point p,int o,int l){\n  CrossPoint a;\n  a.p1 = p; a.o = o; a.l = l;\n  return a;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n/* 反時計回り CCW */\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\n/* 線分p1,p2と線分p3,p4の交差判定 */\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return ( ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t   ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\nbool intersect(Segment s1,Segment s2) {\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n/* ベクトルaとbの内積 */\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\n\n/* ベクトルaとbの外積 */\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\n/* 線分s1と線分s2の交点 */\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base = s2.p2-s2.p1;\n  double d1 = abs(cross(base,s1.p1 - s2.p1));\n  double d2 = abs(cross(base,s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nint main(){\n  int data;\n  cin >> data;\n  while(data--){\n    int xa,ya,xb,yb,n;\n    cin >> xa >> ya >> xb >> yb;\n    Point s,t;\n    s = MakePoint(xa,ya);\n    t = MakePoint(xb,yb);\n    Segment M = MakeSegment(s,t);\n    Segment seg[101];\n    cin >> n;\n    int c=0;\n    CrossPoint crosspoint[101];\n    for(int i=0;i<n;i++){\n      Point a,b;\n      int o,l;\n      cin >> a.x >> a.y >> b.x >> b.y >> o >> l;\n      seg[i].p1 = a; seg[i].p2 = b; seg[i].o = o; seg[i].l = l;\n      bool flag = intersect(M,seg[i]);\n      if(flag){\n\tPoint p = getCrossPoint(M,seg[i]);\n\tcrosspoint[c] = MakeCrossPoint(p,seg[i].o,seg[i].l); \n\tc++;\n      }\n    }\n    sort(crosspoint,crosspoint+c);\n    int ans = 100000000;\n    for(int z=0;z<2;z++){\n      int now = z;\n      int cou = 0;\n      for(int i=0;i<c;i++){\n\tif(crosspoint[i].o == 1){\n\t  if(crosspoint[i].l != now){\n\t    cou++;\n\t    now = crosspoint[i].l;\n\t  }\n\t}\n\telse {\n\t  if(crosspoint[i].l == now){\n\t    cou++;\n\t    if(now == 1) now = 0;\n\t    else now = 1;\n\t  }\n\t}\n      }\n      ans = min(ans,cou);\n    }\n    cout << ans << endl;\n  }\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define EQV(a, b) (EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\t\t     \n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define MOD 1000000007\n\ntypedef complex<double> P;\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n// ??????(dot product) : ab = |a||b|cos theta\ndouble dot(P a, P b)\n{\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// ??????(cross product) : axb = |a||b|sin theta\ndouble cross(P a, P b)\n{\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´?????????  dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2)\n{\n  return EQ(dot(a1-a2, b1-b2), 0.0);\n}\n// 2??´?????????????????? cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2)\n{\n  return EQ(cross(a1-a2, b1-b2), 0.0);\n}\n\n// ???c?????´???a,b????????????????????????\nint is_point_on_line(P a, P b, P c)\n{\n  return EQ(cross(b-a, c-a), 0.0);\n}\n\n// ???c?????????a,b????????????????????????\nint is_point_on_line_seg(P a, P b, P c)\n{\n  // |a - c| + |c - b| <= |a - b|???????????????\n  return (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distance_l_p(P a, P b, P c)\n{\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distance_ls_p(P a, P b, P c)\n{\n  if(dot(b-a, c-a) < EPS) return abs(c-a);\n  if(dot(a-b, c-b) < EPS) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nint is_intersected_ls(P a1, P a2, P b1, P b2, double c)\n{\n  return (cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < c) &&\n    (cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨????????¨??????????????????????¨????\nP intersection_ls(P a1, P a2, P b1, P b2)\n{\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2 - a1) * t;\n}\n\ntypedef pair< P, pi > S;\n\nbool comp(const S& ls, const S& rs)\n{\n  P l = ls.first, r = rs.first;\n  return l.real()==r.real()?l.imag()<r.imag():l.real()<r.real();\n}\n\nint solve()\n{\n  int in[6]; rep(i, 4) cin >> in[i];\n  P a(in[0], in[1]), b(in[2], in[3]);\n  int N;\n  cin >> N;\n  vector<S>V;\n  rep(i, N){\n    rep(j,6) cin >> in[j];\n    P c(in[0], in[1]), d(in[2], in[3]);\n    if(is_intersected_ls(a, b, c, d, EPS)){\n      P p = intersection_ls(a, b, c, d);\n      V.push_back(make_pair(p, pi(in[4], in[5])));\n    }\n  }\n  sort(V.begin(), V.end(), comp);\n  int res = 0;\n  unsigned int pos = (~(V[0].second.first^V[0].second.second))&1;\n  //  cout << pos << endl;\n  for(int i=1;i<V.size();i++){\n    int o = V[i].second.first, l = V[i].second.second;\n    //    cout << o << \" \" << l << endl;\n    res += (pos!=((~(o^l))&1));\n    pos = (~(o^l))&1;\n    //    cout << pos << endl;\n  }\n  return res;\n}\n\nint main()\n{\n  int T;\n  cin >> T;\n  rep(i, T)\n    cout << solve() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <complex>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e10\n#define EPS 1e-10\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef complex<double> P;\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b){\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b){\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n  L(const P &a, const P &b){\n    pb(a); pb(b);\n  }\n};\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return +-2;\n  return 0;\n  \n}\n\nbool intersectSS(const L &s, const L &t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspointLL(const L &l, const L &m){\n  double A = cross(l[1] -l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0];\n  if(abs(A) < EPS) return P(INF,INF);\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint main(){\n  int z;\n  cin >> z;\n  while(z--){\n    P a, b;\n    cin >> a.real() >> a.imag() >> b.real() >> b.imag();\n    L ab(a,b);\n    int n;\n    cin >> n;\n    vector<pair<double,int> > cr;\n    while(n--){\n      P s, t;\n      int o, l;\n      cin >> s.real() >> s.imag() >> t.real() >> t.imag();\n      cin >> o >> l;\n      L st(s,t);\n      if(intersectSS(ab,st)){\n\tP p = crosspointLL(ab,st);\n\tdouble d = sqrt((a.real()-p.real())*(a.real()-p.real()) + (a.imag()-p.imag())*(a.imag()-p.imag()));\n\tif(!o) l = (l)? 0: 1;\n\tcr.pb(mp(d,l));\n      }\n    }\n    sort(all(cr));\n    int l = cr[0].second;\n    int ans = 0;\n    repi(i,1,cr.size()){\n      if(l != cr[i].second){\n\tans++;\n\tl = cr[i].second;\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n#define EPS 1.0e-10\ntypedef complex<double> P;\n\nstruct L { P pos, dir; };\n\ninline int signum(double x) {\n\treturn (abs(x) < EPS ? 0 : x > 0 ? 1 : -1);\n}\n\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a) * b).imag();\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n\tP a(r - p), b(s - p);\n\tint sgn = signum(outp(a, b));\n\tif (sgn != 0)\n\t\treturn sgn;\n\tif (a.real() * b.real() < -EPS || a.imag() * b.imag() < -EPS)\n\t\treturn -1;\n\tif (norm(a) < norm(b) - EPS)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nbool ss_intersects(const L& s, const L& t) {\n\treturn (ccw(s.pos, s.pos + s.dir, t.pos) *\n\t\tccw(s.pos, s.pos + s.dir, t.pos + t.dir) <= 0 &&\n\t\tccw(t.pos, t.pos + t.dir, s.pos) *\n\t\tccw(t.pos, t.pos + t.dir, s.pos + s.dir) <= 0);\n}\n\nP line_cross(const L& l, const L& m) {\n\tdouble num = outp(m.dir, m.pos - l.pos);\n\tdouble denom = outp(m.dir, l.dir);\n\treturn P(l.pos + l.dir * num / denom);\n}\n\nstruct S {\n\tP p;\n\tbool up;\n};\n\nbool comp(S s1, S s2) {\n\treturn s1.p.real() < s2.p.real();\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint T;\n\tcin >> T;\n\tfor (int loop = 0; loop < T; loop++) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\t\tvector<S> vs;\n\t\tL line = L{P(xa, ya), P(xb, yb) - P(xa, ya)};\n\t\t//vs.push_back(S{line.pos, false});\n\t\t//vs.push_back(S{line.pos + line.dir, false});\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tif (l == 1) o = 1 - o;\n\n\t\t\tL t = L{P(xs, ys), P(xt, yt) - P(xs, ys)};\n\t\t\tif (ss_intersects(line, t)) {\n\t\t\t\tP p = line_cross(line, t);\n\t\t\t\tvs.push_back(S{p, o});\n\t\t\t}\n\t\t}\n\n\t\tsort(vs.begin(), vs.end(), comp);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < vs.size() - 1; i++) {\n\t\t\tans += vs[i].up != vs[i + 1].up;\n\t\t}\n\t\t//ans += vs[0].up != vs[vs.size() - 1].up;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-10;\n\nclass Route\n{\npublic:\n\tPoint s, t;\n\tint o, l;\n\tRoute(Point p1, Point p2, int oo, int ll)\n\t\t:s(p1), t(p2), o(oo), l(ll) {}\n};\n\nclass Intersection\n{\npublic:\n\tint o, l;\n\tdouble d;\n\tIntersection(int oo, int ll, double dd)\n\t\t:o(oo), l(ll), d(dd) {}\n};\n\nclass LessDistance\n{\npublic:\n\tbool operator() (const Intersection& lhs, const Intersection& rhs)\n\t{\n\t\treturn lhs.d < rhs.d;\n\t}\n};\n\ndouble cross(Point a, Point b)\n{\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(Point a1, Point a2, Point b1, Point b2)\n{\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nPoint intersection_ls(Point a1, Point a2, Point b1, Point b2) {\n\tPoint b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\nint main()\n{\n\tint t;\n\tcin >> t;\n\twhile (t--) {\n\t\tdouble xa, ya, xb, yb;\n\t\tscanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\t\tPoint A(xa, ya), B(xb, yb);\n\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<Route> route;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tdouble xs, ys, xt, yt;\n\t\t\tint o, l;\n\t\t\tscanf(\"%lf %lf %lf %lf %d %d\", &xs, &ys, &xt, &yt, &o, &l);\n\t\t\tif (l == 0)\n\t\t\t\tl = -1;\n\t\t\troute.push_back(Route(Point(xs, ys), Point(xt, yt), o, l));\n\t\t}\n\n\t\tvector<Intersection> inter;\n\t\tfor (unsigned int i = 0; i < route.size(); ++i) {\n\t\t\tif (abs(cross(B-A, route[i].t-route[i].s)) < EPS)\n\t\t\t\tcontinue;\n\t\t\tif (is_intersected_ls(A, B, route[i].s, route[i].t)) {\n\t\t\t\tPoint p = intersection_ls(A, B, route[i].s, route[i].t);\n\t\t\t\tinter.push_back(Intersection(route[i].o, route[i].l, abs(B-p)));\n\t\t\t}\n\t\t}\n\n\t\tsort(inter.begin(), inter.end(), LessDistance());\n\n\t\tint ans = 0, location;\n\t\tif (!inter.empty()) {\n\t\t\tif (inter.front().o == 1)\n\t\t\t\tlocation = inter.front().l;\n\t\t\telse\n\t\t\t\tlocation = -inter.front().l;\n\n\t\t\tfor (unsigned int i = 1; i < inter.size(); ++i) {\n\t\t\t\tif (inter[i].o == 1) {\n\t\t\t\t\tif (inter[i].l != location) {\n\t\t\t\t\t\t++ans;\n\t\t\t\t\t\tlocation = -location;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (inter[i].l == location) {\n\t\t\t\t\t\t++ans;\n\t\t\t\t\t\tlocation = -location;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n    return (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\n// ?????????????????? a->b->c\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\n// ??´???a??¨??????b\nbool isecLS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0;\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n    D d1 = cross(b2-b1, b1-a1);\n    D d2 = cross(b2-b1, a2-a1);\n    return a1 + d1/(d1 + d2) * (a2-a1);\n}\n\nclass CrossPoint{\npublic:\n    double x, y;\n    int o, l;\n    bool is_underground;\n    CrossPoint(double x, double y, int o, int l): x(x), y(y), o(o), l(l){\n        is_underground = o^l;\n    };\n};\n\nbool cmp(CrossPoint p1, CrossPoint p2){\n    if(EQ(p1.x, p2.x))\n        return p1.y < p2.y;\n    else\n        return p1.x < p2.x;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T; cin>>T;\n    while(T--){\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        \n        int N; cin >> N;\n        \n        vector<CrossPoint> crosspoints;\n        for(int i=0; i<N; i++){\n            int xs, ys, xt, yt, o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            \n            if(isecLS(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt))){\n                P p = crosspointLL(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt));\n                crosspoints.push_back(CrossPoint(p.X, p.Y, o, l));\n            }\n        }\n        sort(crosspoints.begin(), crosspoints.end(), cmp);\n        \n        int count = 0;\n        bool is_underground = crosspoints[0].is_underground;\n        int i = 0;\n        while(i<N){\n            while(i<N && crosspoints[i].is_underground == is_underground) i++;\n            if(i<N){\n                is_underground = crosspoints[i].is_underground;\n                count++;\n            }\n            i++;\n        }\n        \n        cout << count << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nclass Road\n{\npublic:\n    Road(int _xs, int _ys, int _xt, int _yt, bool _l)\n    {\n        xs = _xs;\n        ys = _ys;\n        xt = _xt;\n        yt = _yt;\n        l = _l;\n    }\n\n    int xs, ys, xt, yt;\n\n    //l : true??§?????¶\n    bool l;\n\n};\n\n//https://qiita.com/ykob/items/ab7f30c43a0ed52d16f2\nbool crossed(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) \n{\n  int ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  int tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  int tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  int td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n  return tc * td < 0 && ta * tb < 0;\n  // return tc * td <= 0 && ta * tb <= 0; // ?????????????????´???\n};\nint main()\n{\n    auto data_num = 0;\n    cin >> data_num;\n    for(auto i = 0; i < data_num; i++)\n    {\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n\n        int n;\n        cin >> n;\n        vector<Road> roads;\n        roads.reserve(n);\n\n        vector< pair<float, bool> > crossPoints{};\n\n        for(int j = 0; j < n; j++)\n        {\n\n            int xs, ys, xt, yt;\n            bool o, l;\n\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n\n            //???????????¢?????????\n            roads.push_back( Road(xs, ys, xt, yt, !(o ^ l) ) );\n        }\n\n        for(const auto& r : roads)\n        {\n            if(crossed(xa, ya, xb, yb, r.xs, r.ys, r.xt, r.yt))\n            {\n                float cross_x = ((r.ys * r.xt - r.xs * r.yt) * (xb - xa) - (ya * xb - xa * yb) * (r.xt - r.xs)) / (float)((yb - ya) * (r.xt - r.xs) - (xb - xa) * (r.yt - r.ys)); \n                float cross_y = ((r.ys * r.xt - r.xs * r.yt) * (yb - ya) - (ya * xb - xa * yb) * (r.yt - r.ys)) / (float)((yb - ya) * (r.xt - r.xs) - (xb - xa) * (r.yt - r.ys)); \n                float differ_x = xa - cross_x;\n                float differ_y = ya - cross_y;\n                float dist = differ_x * differ_x + differ_y * differ_y;\n\n                crossPoints.push_back( make_pair(dist, r.l) );\n            }\n        }\n        sort(crossPoints.begin(), crossPoints.end());\n\n\n\n        auto ans = 0;\n        bool nowHeight = crossPoints[0].second;\n        for(const auto& cp : crossPoints)\n        {\n            if(nowHeight != cp.second)\n            {\n                nowHeight = cp.second;\n                ans++;\n            }\n        }\n\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-10, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\n\nusing Point = complex<ld>;\nclass Line {\npublic:\n\tPoint a, b;\n};\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\nint ccw(Point a, Point b, Point c) {\n\tb -= a, c -= a;\n\tif (cross(b, c) > eps) return 1;\t// a,b,c counter-clockwise\n\tif (cross(b, c) < -eps) return -1;\t// a,b,c clockwise\n\tif (dot(b, c) < 0) return 2;\t\t// c,a,b on a line\n\tif (norm(b) < norm(c)) return -2;\t// a,b,c on a line\n\treturn 0;\t\t\t\t\t\t\t// a,c,b on a line\n}\n\nbool isis_ll(Line l, Line m) {\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(Line l, Point p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_sp(Line s, Point p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_ss(Line s, Line t) {\n\tif (isis_ll(s, t)) return isis_ls(s, t) && isis_ls(t, s);\n\treturn isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a);\n}\n\nint main()\n{\n\tint T;\n\tcin >> T;\n\twhile (T--) {\n\t\tld xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tPoint a(xa, ya), b(xb, yb);\n\t\tLine ab = { a, b };\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<pair<ld, int>> ll;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tld xs, ys, xt, yt;\n\t\t\tcin >> xs >> ys >> xt >> yt;\n\t\t\tPoint s(xs, ys), t(xt, yt);\n\t\t\tLine st = { s, t };\n\t\t\tint o, l;\n\t\t\tcin >> o >> l;\n\t\t\tif (!isis_ss(ab, st)) continue;\n\t\t\tll.emplace_back(abs(is_ll(ab, st) - a), o ^ l);\n\t\t}\n\t\tsort(ll.begin(), ll.end());\n\t\tint res = 0;\n\t\tfor (int i = 1; i < (int)ll.size(); i++) {\n\t\t\tif (ll[i - 1].second != ll[i].second) res++;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-25)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> Pair;\n\nint u, n;\ndouble xa, ya, xb, yb;\ndouble x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[10010];string s;ll l;double d;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tdouble nextDouble(){scanf(\"%lf\", &d);return d;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {return imag(conj(a)*b);}\ndouble dot(const P& a, const P& b) {return real(conj(a)*b);}\n\nstruct L : public vector<P>{\n\tL(const P& a, const P& b){\n\t\tclear(); pb(a); pb(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C{\n\tP p;\n\tdouble r;\n\tC(const P& p, double r):p(p), r(r){};\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble dist2(const P& a, const P& b){\n\tP p(a-b);\n\treturn dot(p, p);\n}\n\nbool getNext(bool a, bool b){\n\treturn a?b:!b;\n}\n\nvoid printP(const P& p){\n\tcout<<\" \"<<real(p)<<\" \"<<imag(p);\n}\n\nint main(){\n\tint N = in.nextInt();\n\twhile(N--){\n\t\tdouble xa = in.nextInt(), ya = in.nextInt(), xb = in.nextInt(), yb = in.nextInt();\n\t\tL l({{xa, ya}, {xb, yb}});\n\t\tint n = in.nextInt();\n\t\tvector<pii> ps;\n\t\tvector<pair<double, pair<int, int> > > ds;\n\t\trep(i, n){\n\t\t\tdouble xs = in.nextInt(), ys = in.nextInt(), xt = in.nextInt(), yt = in.nextInt();\n\t\t\tL t{{xs, ys}, {xt, yt}};\n\t\t\tps.pb({in.nextInt(), in.nextInt()});\n\t\t\t//printP(t[0]);\n\t\t\t//printP(t[1]);\n\t\t\t//cout<<endl;\n\t\t\tif(intersectSS(l, t))\n\t\t\t//if(ccw(l[0], crosspoint(l, t), l[1])==-2 && ccw(t[0], crosspoint(l, t), t[1]) == -2)\n\t\t\t\tds.pb({sqrt(dist2(crosspoint(l, t), l[0])), {ps.back().fi, ps.back().se}});\n\t\t\t//}\n\t\t}\n\t\t//cout<<\" \"<<ds.size()<<endl;\n\t\tsort(all(ds));\n\t\tint ans = 0;\n\t\tif(ds.size()==0){\n\t\t\tcout<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool now = getNext(ds[0].se.fi, ds[0].se.se);\n\t\trep(i, ds.size()){\n\t\t\tif(now!=getNext(ds[i].se.fi, ds[i].se.se)){\n\t\t\t\tans++;\n\t\t\t\tnow = !now; \n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nstruct rail{\n\tint sx;\n\tint sy;\n\tint gx;\n\tint gy;\n};\n\ndouble cross(rail v1,rail v2){//?????????v1?????????????????????\n\tint cv1v2=(v1.gx - v1.sx)*(v2.gy - v2.sy) - (v1.gy - v1.sy)*(v2.gx - v2.sx);\n\tint cvv2 = (v2.sx - v1.sx)*(v2.gy - v2.sy) - (v2.sy-v1.sy)*(v2.gx - v2.sx);\n\tif (cv1v2 == 0.0)\n\t\treturn 0.0;\n\treturn (double)cvv2/(double)cv1v2;\n}\nstruct cross_t{\n\tint no;\n\tdouble dis;\n};\n\nbool operator < (const cross_t &left, const cross_t &right){\n\treturn left.dis < right.dis;\n};\nint main() {\n\tofstream ofs(\"out.txt\");\n\tint dataset;\n\tcin >> dataset;\n\twhile (dataset--){\n\t\trail atob;\n\t\tcin >> atob.sx;\n\t\tcin >> atob.sy;\n\t\tcin >> atob.gx;\n\t\tcin >> atob.gy;\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<rail> vr(n);\n\t\tvector<bool> high_b(n);\n\t\tpriority_queue<cross_t> P;\n\t\tREP(i, n){\n\t\t\tcin >> vr[i].sx;\n\t\t\tcin >> vr[i].sy;\n\t\t\tcin >> vr[i].gx;\n\t\t\tcin >> vr[i].gy;\n\t\t\tint mine,high;\n\t\t\tcin >> mine;\n\t\t\tcin >> high;\n\t\t\thigh_b[i] = (mine == high);\n\t\t\tdouble t1 = cross(atob, vr[i]);\n\t\t\tdouble t2 = cross(vr[i], atob);\n\t\t\tif (0.0<t1 && t1<1.0&&0.0<t2 && t2<1.0)P.push({ i, t1 });\n\t\t}\n\t\tbool b=false;\n\t\tint ans = 0;\n\t\tint ps = P.size();\n\n\t\tREP(i, ps){\n\t\t\tcross_t p = P.top();\n\t\t\tP.pop();\n\t\t\tif (i == 0){\n\t\t\t\tb = high_b[p.no];\n\t\t\t}else{\n\t\t\t\tif (b != high_b[p.no]){\n\t\t\t\t\tans++;\n\t\t\t\t\tb = high_b[p.no];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << p.dis << \" : \" << high_b[p.no] << endl;\n\t\t}\n\t\tofs << ans << endl;\n\t\tcout << (ans) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n#define EPS 1.0e-10\ntypedef complex<double> P;\n\nstruct L { P pos, dir; };\n\ninline int signum(double x) {\n\treturn (abs(x) < EPS ? 0 : x > 0 ? 1 : -1);\n}\n\ninline double outp(const P& a, const P& b) {\n\treturn (conj(a) * b).imag();\n}\n\ninline int ccw(const P& p, const P& r, const P& s) {\n\tP a(r - p), b(s - p);\n\tint sgn = signum(outp(a, b));\n\tif (sgn != 0)\n\t\treturn sgn;\n\tif (a.real() * b.real() < -EPS || a.imag() * b.imag() < -EPS)\n\t\treturn -1;\n\tif (norm(a) < norm(b) - EPS)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nbool ss_intersects(const L& s, const L& t) {\n\treturn (ccw(s.pos, s.pos + s.dir, t.pos) *\n\t\tccw(s.pos, s.pos + s.dir, t.pos + t.dir) <= 0 &&\n\t\tccw(t.pos, t.pos + t.dir, s.pos) *\n\t\tccw(t.pos, t.pos + t.dir, s.pos + s.dir) <= 0);\n}\n\nP line_cross(const L& l, const L& m) {\n\tdouble num = outp(m.dir, m.pos - l.pos);\n\tdouble denom = outp(m.dir, l.dir);\n\treturn P(l.pos + l.dir * num / denom);\n}\n\nstruct S {\n\tP p;\n\tbool up;\n};\n\nbool comp(S s1, S s2) {\n\treturn s1.p.real() < s2.p.real();\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint T;\n\tcin >> T;\n\tfor (int loop = 0; loop < T; loop++) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\t\tvector<S> vs;\n\t\tL line = L{P(xa, ya), P(xb, yb) - P(xa, ya)};\n\t\t//vs.push_back(S{line.pos, false});\n\t\t//vs.push_back(S{line.pos + line.dir, false});\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tif (l == 1) o = 1 - o;\n\n\t\t\tL t = L{P(xs, ys), P(xt, yt) - P(xs, ys)};\n\t\t\tif (ss_intersects(line, t)) {\n\t\t\t\tP p = line_cross(line, t);\n\t\t\t\tvs.push_back(S{p, o});\n\t\t\t}\n\t\t}\n\n\t\tsort(vs.begin(), vs.end(), comp);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < (int)vs.size() - 1; i++) {\n\t\t\tans += vs[i].up != vs[i + 1].up;\n\t\t}\n\t\t//ans += vs[0].up != vs[vs.size() - 1].up;\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n// 以下 幾何部分\ntemplate<class T> bool operator==(T a, T b){return abs(a-b)< eps;}\ntemplate<class T> bool operator< (T a, T b){return a < b-eps;}\ntemplate<class T> bool operator<=(T a, T b){return a < b+eps;}\ntemplate<class T> int sig(T r) {return (r==0||r==-0) ? 0 : r > 0 ? 1 : -1;}\n#define X real()\n#define Y imag()\n#define mp make_pair\n\ntypedef bool B;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef vector<P> VP;\ntypedef pair <P,P> L;\ntypedef vector<L> VL;\ntypedef struct {P c;D r;} C;\ntypedef struct {P c;D a,b;} E; // 楕円も追加予定\ntypedef vector <P> Pol;\n\n// ソートのキー\ninline B cmp_x(const P &a,const P &b){ return (abs(a.X-b.X)<eps ) ?  a.Y<b.Y : a.X<b.X;}  // base x\ninline B cmp_y(const P &a,const P &b){ return (abs(a.Y-b.Y)<eps ) ?  a.X<b.X : a.Y<b.Y;}  // base y\ninline B cmp_a(const P &a,const P &b){ return (abs(arg(a)-arg(b))<eps ) ?  norm(a) < norm(b) : arg(a)<arg(b);} // base arg\n\n\n// 基本操作\n// verify\nD ip(P a, P b) {return a.X * b.X + a.Y * b.Y;}\nD ep(P a, P b) {return a.X * b.Y - a.Y * b.X;}\nD sr(D a) {return sqrt(max(a, (D)0));}\nP vec(L l){return l.second-l.first;}\n\n\n// 点\nD toRagian(D degree){ return degree*pi/180.0;}\nD ang (P p){return arg(p);}\nD ang (P base, P a, P b) {return arg( (b - base) / (a - base) );} // base 中心\nP rot (P base, P a, D theta){return base+polar( abs(a-base), arg(a-base)+theta );}\n\n// verify AOJ 2514\nP proj(P b,P p){ return b*ip(b,p)/norm(b);} \nP proj(L l,P p){ return l.first+proj(vec(l),p-l.first);}\nP refl(L l,P p){ return proj(l,p)*D(2.0)-p; }\n\n// ccw \nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, MID = 16, ON=FRONT|BACK|MID };\n\ninline int ccw(P base, P a, P b) {              //点aと点bが与えられた問いに\n  a -= base; b -= base;\n  if (ep(a, b) > eps)   \t return LEFT;    // counter clockwise\n  if (ep(a, b) < -eps)      return RIGHT;   // clockwise\n  if (ip(a, b) < -eps)      return BACK;    // b--base--a on line\n  if (norm(a) < norm(b)) return FRONT;   // base--a--b on line\n  \t\t\t\t\t\t return MID;      // base--b--a on line  aとbの線分判定はこれ\n}\n\n// 線分 直線\n\t// 点と直線の距離\n\t// 点と線分の距離\n\t// 直線と直線の距離\n\t\n\nB iver(L a, L b) {return ip(vec(a),vec(b) )== 0.0;}\nB ipar(L a, L b) {return ep(vec(a),vec(b) )== 0.0;}\n\n\n// 交点\nP pLL(L a,L b){ return a.first+vec(a)*ep(vec(b),b.first-a.first)/ep(vec(b), vec(a));}\n\n\n// 点と直線と線分関連の交差判定\n\nB iLL(L l1,L l2){ return !ipar(l1,l2);}\nB eqL(L a, L b) {return !iLL(a, b) && ep(vec(a), b.first - a.first)==0;}\nB iLS(L a, L b)  {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <= 0;}\nB iLSs(L a, L b) {return sig(ep(vec(a), b.first - a.first)) * sig(ep(vec(a), b.second - a.first)) <  0;}\nB iSS(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn ((cwa | cwb) & MID) || ((cwa & cwb) == (LEFT | RIGHT));\n}\nB iSSs(L a, L b) {\n\tint cwa = ccw(a.first,a.second, b.first) | ccw(a.first,a.second, b.second);\n\tint cwb = ccw(b.first,b.second, a.first) | ccw(b.first,b.second, a.second);\n\treturn (cwa & cwb) == (LEFT | RIGHT);\n}\n\n// 点と直線と線分関連の距離\n\nD dLP(L l,P p){ return abs( ep(vec(l),p-l.first) )/abs(vec(l));}\nD dSP(L s,P p){\n\tif (sig( ip( vec(s), p - s.first)) <= 0) return abs(p - s.first);\n\tif (sig( ip(-vec(s), p - s.second)) <= 0) return abs(p - s.second);\n\treturn dLP(s,p);\n}\nD dLL(L a,L b){ return iLL(a,b) ? 0 : dLP(a,b.first);}\nD dLS(L a,L b){ return iLS(a,b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\nD dSS(L a,L b){ return iSS(a,b) ? 0 : min( min(dSP(a,b.first),dSP(a,b.second)),min(dSP(b,a.first),dSP(b,a.second)));}\n\n\n// 円\n// Verify AOJ 1183\n\nenum RCC{A_IN_B=1,B_IN_A=2,A_ON_B=4,B_ON_A=8,ISC=16,ON_OUT=32,OUT=64,SAME=12,ONS=48 };\n\n\nint rCC(C a,C b){\n\tD d=abs(a.c-b.c);\n\tint res=0;\n\tif(a.r+b.r< d) res|=OUT;\n\tif(a.r+b.r==d) res|=ON_OUT;\n\tif(abs(a.r-b.r) < d && d < a.r+b.r) res|=ISC;\n\tif(d==b.r-a.r) res|=A_ON_B;\n\tif(d< b.r-a.r) res|=A_IN_B;\n\tif(d==a.r-b.r) res|=B_ON_A;\n\tif(d< a.r-b.r) res|=B_IN_A;\n\treturn res;\n}\n\n//2つの円の交点\n// Verify AOJ 1183\n\nVP pCC(C a,C b){\n\tVP res;\n\tint rel=rCC(a,b);\n\tif(rel==SAME){   // Same\n\t\tres.pb(a.c+P(a.r,0));\n\t\tres.pb(a.c+P(-a.r,0));\n\t\tres.pb(a.c+P(0,a.r));\n\t\tres.pb(a.c+P(0,-a.r));\n\t}else if(rel==ISC){         // 2points\n\t\tD d = abs(b.c - a.c);\n\t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n\t\tP e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, (D)0));\n\t\tres.pb(a.c + e * x - w);\n\t\tres.pb(a.c + e * x + w);\t\n\t}else if(rel&ONS){ // 1points\n\t\tD d = abs(b.c - a.c);\n \t\tD x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n \t\tP e = (b.c - a.c) / abs(b.c - a.c);\n  \t\tres.pb(a.c + e * x);\n\t}\n\treturn res;\n}\n\n\nVP pCL(C c, L l) {\n\tVP res;\n\tP h = proj(l, c.c);\n\tP e = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(h - c.c));\n\tres.pb(h - e);\n\tres.pb(h + e);\n\treturn res;\n}\n\n\n// 円の接線\n// Verify AOJ 2001\n\nL tanC(C c,D t){\n\tP p=c.c+polar(c.r,t);\n\tP d=polar(c.r,t)*P(0,1);\n\treturn L(p-d,p+d);\n}\n\n\n// 円の共通接線\n// Verify AOJ 2001\n\nVL common_tan(C a,C b){\n\tVL res;\n\tD d=ang(b.c-a.c);\n\tD i=acos((a.r+b.r)/abs(b.c-a.c));\n\tD o=acos((a.r-b.r)/abs(b.c-a.c));\n\tint r=rCC(a,b);\n\n\tif(r==OUT){\t\t//共通内接線\n\t\tres.pb(tanC(a,d+i));\n\t\tres.pb(tanC(a,d-i));\n\t}\n\n\tif(r>=ISC){\t\t// 共通外接線\n\t\tres.pb(tanC(a,d+o));\n\t\tres.pb(tanC(a,d-o));\n\t}\n\n\tif(r&ONS)\t\t//接点を共有する接線\n\t\tres.pb(tanC(a,d));\n\n\tif(r==SAME){\n\t\trep(i,5)\n\t\t\tres.pb(tanC(a,i));\n\t}\n\treturn res;\n}\n\n\n// 楕円\n\n// 多角形\n\n// 多角形の内外判定　(凹多角形も可)\n//verify AOJ CGL_3-C\nint in_polygon(Pol pol,P p){\n    int n=pol.size();\n    int res=0;\n    rep(i,n){\n        if(ccw(pol[i],pol[(i+1)%n],p)==MID)\n            return 1;\n        if ((pol[i].Y <= p.Y) && (pol[(i+1)%n].Y>p.Y)){\n            D vt=(p.Y-pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X < pol[i].X + vt*dx)\n                    res++;\n        }else if ((pol[i].Y>p.Y)&&(pol[(i+1)%n].Y<=p.Y)){\n            D vt=(p.Y - pol[i].Y)/(pol[(i+1)%n].Y-pol[i].Y);\n            D dx=pol[(i+1)%n].X-pol[i].X;\n            if(p.X <pol[i].X+vt*dx)\n                res--;\n        }\n    }\n    return res?2:0;\n}\n\n\n// 多角形の内外判定　(凹多角形も可)\n// Verify AOJ 2514\n\nbool in_polygon(Pol pol,L s){\n\tVP check;\n\tint n=pol.size();\n\n\trep(i,n){\n\t\tL tar=L(pol[i],pol[(i+1)%n]);\n\t\tif(iSS(s,tar))\n\t\t\tcheck.pb(pLL(s,tar));\n\t}\n\n\tcheck.pb(s.first);\n\tcheck.pb(s.second);\n\tsort(check.begin(),check.end(),cmp_x);\n\tn=check.size();\n\tbool res=true;\n\trep(i,n-1){\n\t\tP m=(check[i]+check[i+1])/P(2.0,0.0);\n\t\tif(!in_polygon(pol,m))\n\t\t\tres=false;\n\t}\n\treturn res;\n}\n\n\n// Area\n// Verify AOJ 1100\nD area(Pol pol){\n\tint n=pol.size();\n\tD xx,yy,sum=0.0;\n\trep(i,n){\n\t\txx=pol[i%n].X-pol[(i+1)%n].X;\n\t\tyy=pol[i%n].Y+pol[(i+1)%n].Y;\n\t\tsum+=xx*yy;\n\t}\n\treturn abs(sum/2.0);\n}\n\n// hough T\n// アフィン変換\n\n\n\n// Convex_hull\n// Verify AOJ 0063\nPol convex_hull(Pol pol){\n\tint n=pol.size();\n\tsort(pol.begin(),pol.end(),cmp_x);\n\tPol res(2*n);\n\tint k=0;\n\t\n\t// down\n\trep(i,n){\n\t\twhile( k>1 && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\t// up\n\tfor(int i=n-2,t=k;i>=0;i--){\n\t\twhile( k>t && ep(res[k-1]-res[k-2],pol[i]-res[k-1])<=0) k--;\n\t\tres[k++]=pol[i];\n\t}\n\tres.resize(k-1);\n\treturn res;\n}\n\n/*\n\n// now developing\nvector<L> merge_L(vector<L>){\n\n}\n\n\n\nPol normalize_polygon(Pol pol){\n\tint n=pol.size();\n\trep(i,n){\n\t\tif(ccw(pol[i],pol[(i+2)%n],pol[(i+1)%n])==MID)\n\t\t\t// remove pol[(i+1)%n]\n\t\t\tn--;\n\t}\n}\n*/\n\n#define F first\n#define S second\n\nint main(void){\n    int numDataset; cin >> numDataset;\n\n    while(numDataset--){\n        L ab;\n        cin >> ab.F.X >> ab.F.Y >> ab.S.X >> ab.S.Y;\n\n        int n; cin >> n;\n        vector< pair<D, pii> > points;\n        rep(i, n){\n            L line;\n            int ci, hi;\n\n            cin >> line.F.X >> line.F.Y >> line.S.X >> line.S.Y >> ci >> hi;\n\n            if(iSS(ab, line)){\n                P p = pLL(ab, line);\n                D d = sqr(p.X - ab.F.X) + sqr(p.Y - ab.F.Y);\n\n                points.pb(mp(d, mp(ci, hi)));\n            }\n        }\n        \n        sort(all(points));\n\n        int high, cnt = 0;\n        rep(i, points.size()){\n            if(!i){\n                if(points[i].S.F)\n                    high = points[i].S.S;\n                else high = !points[i].S.S;\n                continue;\n            }\n\n            if(points[i].S.F && points[i].S.S != high ||\n              !points[i].S.F && points[i].S.S == high){\n                high = !high;\n                cnt++;\n            }\n        }\n\n        cout << cnt << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <array>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\ntypedef array<point, 2> line;\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (eq(A, 0.) && eq(B, 0.)) return m[0]; // same line\n\tif (eq(A, 0.)) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nline read_line() {\n\tline res;\n\tfor (auto& p : res) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp = point(x, y);\n\t}\n\treturn res;\n}\n\nint solve() {\n\tline new_road = read_line();\n\tint n;\n\tcin >> n;\n\ttypedef tuple<point, bool, bool> pinfo;\n\tvector<pinfo> points;\n\tfor (int i = 0; i < n; i++) {\n\t\tline l = read_line();\n\t\tbool own, ground;\n\t\tcin >> own >> ground;\n\t\tif (intersectSS(new_road, l)) {\n\t\t\tpoints.emplace_back(crosspoint(new_road, l), own, ground);\n\t\t}\n\t}\n//\tcout << points.size() << endl;\n\tsort(points.begin(), points.end(), [&new_road](const pinfo& a, const pinfo& b) {\n\t\treturn abs(get<0>(a) - new_road[0]) < abs(get<0>(b) - new_road[0]);\n\t});\n\tbool cur = get<1>(points[0]) ? get<2>(points[0]) : !get<2>(points[0]);\n\tint cnt = 0;\n\tfor (int i = 1; i < points.size(); i++) {\n\t\tif ((get<1>(points[i]) && cur != get<2>(points[i])) ||\n\t\t\t(!get<1>(points[i]) && cur == get<2>(points[i]))) {\n\t\t\tcur = !cur;\n\t\t\tcnt++;\n//\t\t\tcout << i << endl;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //  << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (a - c);\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nstruct edgeInfo{\n    P a;\n    P b;\n    int o;\n    int l;\n};\n\nP p1,p2;\n\nclass Point{\npublic:\n    P p;\n    int l;\n    int o;\n    int t;\n\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n\n\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<edgeInfo> edges;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            edgeInfo e;\n            e.a=P(xs,ys);\n            e.b=P(xt,yt);\n            e.l=l;\n            e.o=o;\n            edges.push_back(e);\n        }\n        vector<Point> crossPoint;\n        // ð_ðßé\n        for(int i = 0;i < n; i++){\n            if (abs(cross(p2-p1, edges[i].a-edges[i].b)) < EPS) { continue; }\n            if(is_intersected_ls(edges[i].a,edges[i].b,p1,p2)){\n                P res=intersection_ls(edges[i].a,edges[i].b,p1,p2);\n                Point pp;\n                pp.l=edges[i].l;\n                pp.o=edges[i].o;\n                pp.p=res;\n                pp.t=pp.l^pp.o;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n\n        if(crossPoint.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit=0;\n        sit=crossPoint[0].t;\n        // ð_ðp1Éß¢ÔÉ\n        int cnt=0;\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].t!=sit){\n                sit=crossPoint[i].t;\n                cnt++;\n            }\n\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> Pair;\n\nint u, n;\ndouble xa, ya, xb, yb;\ndouble x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\tif((a1.real()-a2.real())*(b1.imag()-b2.imag()) + EPS > (a1.imag()-a2.imag())*(b1.real()-b2.real()) &&\n\t   (a1.real()-a2.real())*(b1.imag()-b2.imag()) < EPS + (a1.imag()-a2.imag())*(b1.real()-b2.real())) return 0;\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> pint;\ntypedef const pint &refpint;\ntypedef pair<double,bool> pdb;\n\n\n#define INF 1e99\n\ninline int cross(refpint a, refpint b){\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ninline double intersect(refpint a, refpint dif1, refpint f, refpint negdif2){\n\tint Aint = cross(dif1, negdif2);\n\tif( Aint == 0 ) return INF;\n\tdouble A = Aint;\n\t\n\tpint ddif = f - a;\n\tdouble t = cross(ddif, negdif2) / A;\n\tdouble s = cross(dif1, ddif) / A;\n\t\n\tif(t >= 0.0 && t <= 1.0 && s >= 0.0 && s <= 1.0){\n\t\treturn t;\n\t}\n\treturn INF;\n}\n\n\nint main(){\n\tint dataset;\n\tvector<pdb> ts;\n\tts.reserve(100);\n\tfor(scanf(\"%d\", &dataset); dataset--; ){\n\t\tts.clear();\n\t\tpint a, from, dif1, negdif2;\n\t\tint n, o, l, x1, x2, y1, y2;\n\n\t\tscanf(\"%d%d%d%d%d\", &x1, &y1, &x2, &y2, &n);\n\t\ta = pint(x1, y1);\n\t\tdif1 = pint(x2, y2) - a;\n\n\t\tts.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d%d%d%d%d%d\", &x1, &y1, &x2, &y2, &o, &l);\n\t\t\tfrom = pint(x1, y1);\n\t\t\tnegdif2 = from - pint(x2, y2);\n\n\t\t\tdouble t = intersect(a, dif1, from, negdif2);\n\t\t\tif( t != INF ){\n\t\t\t\tts.push_back( pdb(t, o != l) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(ts.begin(), ts.end());\n\t\tint res = 0;\n\t\tfor(int i = 1; i < ts.size(); ++i){\n\t\t\tif(ts[i-1].second != ts[i].second){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define X real()\n#define Y imag()\n\nusing namespace std;\n\ntypedef complex<double>P;\ntypedef vector<P>POL;\n\nconst double INF = 1e12;\n\nnamespace std{\n  bool operator < (const P&a, const P& b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\nstruct Data{\n  P p;\n  bool mine,up;\n  bool operator < (const Data &d)const{\n    return p < d.p;\n  }\n};\n\nstruct L : public POL{\n  L(){};\n  bool mine,up;\n  L(const P &a, const P &b){\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P& a, const P& b){\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P&b){\n  return real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n  b -= a; c -= a;\n  if(cross(b,c) > 0)return 1;\n  if(cross(b,c) < 0) return -1;\n  if(dot(b,c) < 0) return 2;\n  if(norm(b) < norm(c))return -2;\n  return 0;\n}\n\nbool intersectSS(const L &s,const L&t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP intersection_ss(L line1, L line2){\n  if(!intersectSS(line1,line2))return P(INF,INF);\n  P a = line1[1] - line1[0]; P b = line2[1] - line2[0];\n  return line1[0] + a * cross(b,line2[0]-line1[0]) / cross(b,a);\n}\n\nvector<Data>vec;\nL line;\n\nvoid input(){\n  P p1,p2;\n  cin >> p1.X >> p1.Y >> p2.X >> p2.Y;\n  line = L(p1,p2);\n  line.mine = true;\n\n  int n;\n  cin >> n;\n  for(int i = 0 ; i < n ; i++){\n    cin >> p1.X >> p1.Y >> p2.X >> p2.Y;\n    L l = L(p1,p2);\n    cin >> l.mine >> l.up;\n    if(intersectSS(line,l)){\n      Data d;\n      d.p = intersection_ss(line,l);\n      d.mine = l.mine;\n      d.up = l.up;\n      vec.push_back(d);\n    }\n  }\n}\n\nint solve(){\n  vec.clear();\n  input();\n\n  bool up;\n  int res = 0;\n\n\n  if(vec.size() == 0)return 0;\n\n  sort(vec.begin(),vec.end());\n  \n  if(vec[0].mine) up = vec[0].up;\n  else up = !vec[0].up;\n\n  for(int i = 1 ; i < vec.size() ; i++){\n    if(vec[i].mine){\n      if(up != vec[i].up){\n\tup = !up;\n\tres++;\n      }\n    }\n    else {\n      if(up == vec[i].up){\n\tup = !up;\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int tc;\n  cin >> tc;\n  while(tc--){\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n#include <complex>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nconst double EPS=1e-10;\n#define equals(a, b) (fabs((a)-(b))<EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\n\n\nstruct Segment {\n    Point p1, p2;\n};\n\ndouble dot(Vector a, Vector b) {\n    return a.X*b.X + a.Y*b.Y;\n}\n\ndouble cross(Vector a,Vector b) {\n    return a.X*b.Y - a.Y*b.X;\n}\n\nenum CCW {\n    COUNTER_CLOCKWISE=1,\n    CLOCKWISE=-1,\n    ONLINE_BACK=2,\n    ONLINE_FRONT=-2,\n    ON_SEGMENT=0,\n};\n\nint ccw(Point p0, Point p1, Point p2) {\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS) return CCW::COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS) return CCW::CLOCKWISE;\n    if(dot(a,b)<-EPS) return CCW::ONLINE_BACK;\n    if(norm(a)<norm(b)) return CCW::ONLINE_FRONT;\n\n    return CCW::ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4) {\n    return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2) {\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2) {\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\nPoint a,b;\nPoint s[102],t[102];\nint o[102],l[102];\nvector<pair<double,int>> intersections;\nint solve(int p) {\n    int ret=0;\n    rep(i,intersections.size()) {\n        int t=intersections[i].sc;\n        if(o[t]) {\n            if(l[t]!=p) {\n                ret++;\n                p=l[t];\n            }\n        }\n        else {\n            if(l[t]==p) {\n                ret++;\n                p=l[t]^1;\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid solve() {\n    intersections.clear();\n    int n;\n    cin>>n;\n    rep(i,n) {\n        int x1,y1;\n        int x2,y2;\n        cin>>x1>>y1>>x2>>y2>>o[i]>>l[i];\n        s[i]=Point(x1,y1);\n        t[i]=Point(x2,y2);\n    }\n    rep(i,n) {\n        if(intersect(Segment{a,b},Segment{s[i],t[i]})) {\n            Point p = getCrossPoint(Segment{a,b},Segment{s[i],t[i]});\n            double d=abs(p-a);\n            intersections.pb(mp(d,i));\n        }\n    }\n    sort(all(intersections));\n    cout<<min(solve(0),solve(1))<<endl;\n}\n\nint main() {\n    int n;\n    cin>>n;\n    rep(i,n) {\n\n        int x,y;\n        cin>>x>>y;\n        a.real(x);\n        a.imag(y);\n        cin>>x>>y;\n        b.real(x);\n        b.imag(y);\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\ndouble cross_product (xy_t a, xy_t b) {\n    return (conj(a) * b).imag();\n}\n\nbool seginter (xy_t a, xy_t b, xy_t c, xy_t d) {\n    double d1 = cross_product(b - a, c - a);\n    double d2 = cross_product(b - a, d - a);\n    double d3 = cross_product(d - c, a - c);\n    double d4 = cross_product(d - c, b - c);\n    // cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n    // cout << b - a << \" \" << c - a << endl;\n    // cout << conj(b - a) << endl;\n    // cout << conj(b - a) * (c - a) << endl;\n    // cout << d1 << \" \" << d2 << \" \" << d3 << \" \" << d4 << endl;\n    if (d1 * d2 < -eps && d3 * d4 < -eps) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\ndouble interpoint (xy_t a, xy_t b, xy_t c, xy_t d) {\n    xy_t p = b - a;\n    xy_t q = d - c;\n    return cross_product(q, c - a) / cross_product(q, p);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        xy_t p(xa, ya);\n        xy_t q(xb, yb);\n        int n;\n        cin >> n;\n        vector<pdlg> vec;\n        for (int j = 0; j < n; j++) {\n            int x1, y1, x2, y2, o, l;\n            cin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n            xy_t p1(x1, y1);\n            xy_t p2(x2, y2);\n            bool ok = seginter(p, q, p1, p2);\n            if (ok) {\n                double d = interpoint(p, q, p1, p2);\n                int mark = 1;\n                if ((o == 1 && l == 0) || (o == 0 && l == 1)) {\n                    mark = 0;\n                }\n                //cout << d << \" \" << mark << \" \" << j << endl;\n                vec.push_back(pdlg(d, mark));\n            }\n        }\n        sort(vec.begin(), vec.end());\n        if (vec.size() == 0) {\n            cout << 0 << endl;\n        } else {\n            int mark = vec[0].second;\n            int len = vec.size();\n            // for (int j = 0; j < len; j++) {\n            //     cout << vec[j].first << \" \" << vec[j].second << endl;\n            // }\n            ll ans = 0;\n            for (int j = 1; j < len; j++) {\n                if (vec[j].second != mark) {\n                    ans++;\n                    mark = vec[j].second;\n                }\n            }\n            cout << ans << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\ntypedef complex<double> P;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nint ccw(P p0, P p1, P p2) {\n    if (cross(p1 - p0, p2 - p0) > 0) return +1; // counter-clockwise\n    if (cross(p1 - p0, p2 - p0) < 0) return -1; // clockwise\n    if (dot(p1 - p0, p2 - p0) < 0) return +2;   // online_back\n    if (dot(p0 - p1, p2 - p1) < 0) return -2;   // online_front\n    return 0;                                   // on_segment\n}\n\nbool intersectSS(L l1, L l2) {\n    return (ccw(l1.a, l1.b, l2.a) * ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a) * ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\ndouble crosspointSS(L l1, L l2) {\n    double d1 = abs(cross(l2.v, l1.a - l2.a));\n    double d2 = abs(cross(l2.v, l1.b - l2.a));\n    double t = d1 / (d1 + d2);\n    // return l1.a + t * l1.v;\n    return t;\n}\n\nL readL() {\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return L(xa, ya, xb, yb);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int T;\n    cin >> T;\n    rep(_, T) {\n        L blue = readL();\n        int n;\n        cin >> n;\n        vector<L> lines(n);\n        V layer(n);\n        rep(i, n) {\n            lines[i] = readL();\n            int o, l;\n            cin >> o >> l;\n            layer[i] = l;\n            if (o == 0) layer[i] ^= 1;\n        }\n\n        // rep(i, n) {\n        //     cout << layer[i] << \" \";\n        // }\n        // cout << endl;\n\n        vector<pair<double, int>> v; // ?????????????????????????????????????????????????????????t??¨?????????????????????\n        rep(i, n) {\n            if (!intersectSS(blue, lines[i])) continue;\n            v.emplace_back(make_pair(crosspointSS(blue, lines[i]), i));\n            // printf(\"%.5f %d\\n\", v.back().first, v.back().second);\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n        rep(i, (int)v.size() - 1) {\n            if (layer[v[i].second] != layer[v[i + 1].second]) {\n                ans++;\n            }\n        }\n\n        cout << ans << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <complex>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD dot(P a, P b){\n\treturn (conj(a)* b).real();\n}\n\nD cross(P a, P b){\n\treturn (conj(a)* b).imag();\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS) return 1;\n\tif (cross(b, c) > -EPS) return -1;\n\tif (dot(b, c) > -EPS) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\n\t\tdouble sy, sx, gy, gx;\n\t\tcin >> sx >> sy >> gx >> gy;\n\n\t\tL sl(pair<P,P>(P(sx,sy),P(gx,gy)));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\ttypedef pair<L, pair<int, int>> LL;\n\t\tvector<LL> l;\n\n\t\trep(i, n){\n\t\t\tcin >> sx >> sy >> gx >> gy;\n\t\t\tint o, tl;\n\t\t\tcin >> o >> tl;\n\n\t\t\tLL t;\n\t\t\tt.first.first._Val[0] = sx;\n\t\t\tt.first.first._Val[1] = sy;\n\t\t\tt.first.second._Val[0] = gx;\n\t\t\tt.first.second._Val[1] = gy;\n\n\t\t\tt.second.first = o;\n\t\t\tt.second.second = tl;\n\n\t\t\tl.push_back(t);\n\t\t}\n\t\tvector<int> vo, vl;\n\t\tvector<P> point;\n\n\t\trep(i, l.size()){\n\t\t\tauto lp1 = l[i].first.first;\n\t\t\tauto lp2 = l[i].first.first;\n\t\t\tauto data = l[i].second;\n\n\t\t\tif (isecLL(sl.first, sl.second, lp1, lp2)){\n\t\t\t\tauto p = crosspointLL(sl.first, sl.second, lp1, lp2);\n\t\t\t\tpoint.push_back(p);\n\t\t\t\tvo.push_back(data.first);\n\t\t\t\tvl.push_back(data.second);\n\t\t\t}\n\t\t}\n\n\t\tbool f = true;\n\t\twhile (f){\n\t\t\tf = false;\n\t\t\trep(i, point.size() - 1){\n\t\t\t\tdouble x, y, tx, ty;\n\t\t\t\tx = point[i].imag(); y = point[i].real();\n\t\t\t\ttx = point[i+1].imag(); ty = point[i+1].real();\n\t\t\t\tdouble l1 = (x - sx) * (x - sx) + (y - sy) * (y - sy), l2 = (tx - sx) * (tx - sx) + (ty - sy) * (ty - sy);\n\n\t\t\t\tif (l1 > l2){\n\t\t\t\t\tswap(point[i], point[i + 1]);\n\t\t\t\t\tswap(vo[i], vo[i + 1]);\n\t\t\t\t\tswap(vl[i], vl[i + 1]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(j, 2){\n\t\t\tint val = 0;\n\t\t\tint sj = j;\n\t\t\trep(i, point.size()){\n\n\t\t\t\tif (vo[i] == 1){\n\t\t\t\t\tif (vl[i] != sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = vl[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vo[i] == 0){\n\t\t\t\t\tif (vl[i] == sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = (1-sj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans = min(ans, val);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<EPS\n\ntypedef pair<double, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      if(EQ(xa,xb)){\n      double d2 = (y1-y2)/(x1-x2);\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n      double d1 = (ya-yb)/(xa-xb);\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n      double d1 = (ya-yb)/(xa-xb);\n      double d2 = (y1-y2)/(x1-x2);\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\tassert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS ){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(nx, (o==l)));\n      }\n    }\n\n    sort(all(points), sorter);\n\n    rep(i,points.size()) cout<<points[i].second<<\",\";\n    cout<<endl;\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\nusing namespace std;\ntypedef complex<double> point;\ntypedef pair<point, point> line;\n\n//b??????a??????????????????\ndouble dis(point a, point b){\n  return abs(a - b);\n}\n\n//??????\ndouble dot(point a, point b){\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\n//??????\ndouble cross(point a, point b){\n  return imag(conj(a) * b);\n}\n\n//counter clock wise\nint ccw(point a, point b, point c){\n  if(cross(b - a, c - a) >  eps)return  1;//??????ab????????´\n  if(cross(b - a, c - a) < -eps)return -1;//??????ab????????´\n  if(dot(b - a, c - a) < -eps)return 2;//??´???ab??????a???????????????\n  if(abs(b - a) + eps < abs(c - a))return -2;//??´???ab??????b???????????????\n  return 0;//??´???ab???\n}\n\ndouble line_to_point_dis(line l, point p){\n  return abs(cross(p - l.first, l.second - l.first))/\n    abs(l.second - l.first);\n}\n\ndouble seg_to_point_dis(line l, point p){\n  point a = l.first, b = l.second, c = p;\n  if(dot(b - a, c - a) < eps)return abs(c - a);\n  if(dot(a - b, c - b) < eps)return abs(c - b);\n  return line_to_point_dis(l, p);\n}\n\ndouble seg_to_seg_dis(line a, line b){\n  double res = seg_to_point_dis(a, b.first);\n  res = min(res, seg_to_point_dis(a, b.second));\n  res = min(res, seg_to_point_dis(b, a.first));\n  res = min(res, seg_to_point_dis(b, a.second));\n  return res;\n}\n\nbool is_cross(line a, line b){\n  if(ccw(a.first, a.second, b.first) *\n     ccw(a.first, a.second, b.second) <= 0 &&\n     ccw(b.first, b.second, a.first) *\n     ccw(b.first, b.second, a.second) <= 0){\n    return true;\n  }\n  return false;\n}\n\n//point a, b, point c, d\npoint seg_to_seg_cross_point(line a, line c){\n  if(not is_cross(a, c)) return point(1e9, 1e9);\n  double xa = a.first.real(),  ya = a.first.imag();\n  double xb = a.second.real(), yb = a.second.imag();\n  double xc = c.first.real(),  yc = c.first.imag();\n  double xd = c.second.real(), yd = c.second.imag();\n  double s  = (ya - yc)*(xb - xa) + (yb - ya)*(xc - xa);\n  double t  = (xb - xa)*(yd - yc) - (xd - xc)*(yb - ya);\n  if(abs(t) < eps) return point(1e9, 1e9);\n  return c.first + s*(c.second - c.first)/t;\n}\n\ntypedef struct ColorLine{\n  ColorLine(){};\n  ColorLine(line _ll, int _o, int _l, point _cp):\n    ll(_ll), o(_o), l(_l), cp(_cp){};\n  void calc(point a){\n    d = dis(a, cp);\n  }\n  line ll;\n  int o, l;\n  point cp;\n  double d;\n  bool operator<(const ColorLine &c){\n    return d < c.d;\n  }\n}ColorLine;\n\nint main(int argc, char *argv[]){\n  point a, b;\n  int n, roop;\n  std::cin >> roop;\n  for (int r = 0; r < roop; r++) {\n    double x, y;\n    int o, l;\n    std::cin >> x >> y;\n    a = point(x, y);\n    std::cin >> x >> y >> n;\n    b = point(x, y);\n    line ll = line(a, b);\n    vector<ColorLine> vl(n);\n    for (int i = 0; i < n; i++) {\n      std::cin >> x >> y;\n      a = point(x, y);\n      std::cin >> x >> y >> o >> l;\n      b = point(x, y);\n      point cp = seg_to_seg_cross_point(line(a, b), ll);\n      vl[i] = ColorLine{line(a, b), o, l, cp};\n      vl[i].calc(ll.first);\n    }\n    sort(vl.begin(), vl.end());\n    bool up = (vl[0].o and vl[0].l) or (not vl[0].o and not vl[0].l);\n    int ans = 0;\n    for (int i = 1; i < n and vl[i].cp != point(1e9, 1e9); i++) {\n      // std::cout << ((vl[i].o)?\"b\":\"r\") << \" \" << ((vl[i].l)?\"o\":\"u\") << std::endl;\n      // std::cout << \"bool:\" << ((vl[i].o and vl[i].l) or (not vl[i].o and not vl[i].l)) << std::endl;\n      // std::cout << up << std::endl;\n      if(up != ((vl[i].o and vl[i].l) or (not vl[i].o and not vl[i].l))){\n        up = not up, ans++;        \n      }\n      //std::cout << \"up:\" << up << std::endl;\n    }\n    std::cout << ans << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n    double x, y;\n    int id;\n    point () {}\n    ~point() {}\n\n    point(double a, double b): x(a), y(b), id(-1) {}\n    point(double a, double b, int c): x(a), y(b), id(c) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.y;\n    }\n\n    bool operator > (const point& o) const {\n        return x == o.x ? y > o.y : x > o.y;\n    }\n};\n\ndouble put (point p, point l1, point l2) {\n    double a = l1.y - l2.y, b = l2.x - l1.x, c = l1.x*l2.y - l2.x*l1.y;\n    return a * p.x + b * p.y + c;\n}\n\npoint intersect(point k1, point k2, point l1, point l2) {\n    double ret_x = (k1.x + k2.x) / 2, ret_y = (k1.y + k2.y) / 2;\n    double sig = put(k1, l1, l2) > 0 ? 1 : -1;\n    for (int j = 0; j < 200; ++j) {\n        double val = put(point(ret_x, ret_y), l1, l2);\n        if (abs(val - sig)  < EPS) {\n            return point(ret_x, ret_y);\n        } else if (val * sig > 0) {\n            ret_x = (ret_x + k2.x) / 2;\n            ret_y = (ret_y + k2.y) / 2;\n        } else {\n            ret_x = (ret_x + k1.x) / 2;\n            ret_y = (ret_y + k1.y) / 2;\n        }\n    }\n    return point(ret_x, ret_y);\n}\n\nbool cross(point k1, point k2, point l1, point l2) {\n    bool b1 = put(k1, l1, l2) * put(k2, l1, l2) < 0;\n    bool b2 = put(l1, k1, k2) * put(l2, k1, k2) < 0;\n    return b1 && b2;\n}\n\nint xa, ya, xb, yb, N;\npoint s[1000], t[1000];\nint   o[1000], l[1000];\n\nint solve() {\n    point start(xa, ya), goal(xb, yb);\n    vector<point> itss;\n    for (int j = 0; j < N; ++j) if (cross(start, goal, s[j], t[j])) {\n        point it = intersect(start, goal, s[j], t[j]);\n        it.id = j;\n        itss.push_back(it);\n    }\n\n    sort(begin(itss), end(itss));\n    if (start > goal) reverse(begin(itss), end(itss));\n\n    int ret = 0, height = -1;\n    for (const point& it : itss) {\n        int id = it.id;\n        int expected = o[id] == 1 ? l[id] : 1-l[id];\n        if (height == -1) {\n            height = expected;\n        } else if (height != expected) {\n            ++ret;\n            height = expected;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            cin >> s[j].x >> s[j].y >> t[j].x >> t[j].y >> o[j] >> l[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nP A, B;\nint N;\nP S[100], T[100];\nint O[100], L[100];\n\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\nbool is_crossing(P a1, P a2, P b1, P b2)\n{\n\tbool l = cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n\tbool r = cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n\treturn l && r;\n}\n\nP intersection_is(P a1, P a2, P b1, P b2)\n{\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\nint solve()\n{\n\tvector<pair<double, int> > vp;\n\n\trep(i, 0, N) if (is_crossing(A, B, S[i], T[i]))\n\t{\n\t\tP c = intersection_is(A, B, S[i], T[i]);\n\n\t\tdouble d = abs(c - A);\n\n\t\tint place;\n\n\t\tif (O[i] == 1)\n\t\t\tplace = L[i];\n\t\telse\n\t\t\tplace = 1 - L[i];\n\n\t\tvp.push_back(make_pair(d, place));\n\t}\n\n\tsort(vp.begin(), vp.end());\n\n\tint ans = 0;\n\trep(i, 1, vp.size())\n\t{\n\t\t//assert(EPS < abs(vp[i].first - vp[i - 1].first));\n\t\tif (abs(vp[i].first - vp[i - 1].first) < EPS) continue;\n\t\tif (vp[i].second != vp[i - 1].second) ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(i, 0, dn)\n\t{\n\t\tdouble x, y;\n\n\t\tcin >> x >> y; A = P(x, y);\n\t\tcin >> x >> y; B = P(x, y);\n\t\tcin >> N;\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tcin >> x >> y; S[j] = P(x, y);\n\t\t\tcin >> x >> y; T[j] = P(x, y);\n\t\t\tcin >> O[j] >> L[j];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n/*                         */\n/* @@ Geometory Library @@ */\n/*                         */\nconst double EPS = 1e-8, PI = acos(-1);\n \ninline bool eq(double a,double b){ return abs(b - a) < EPS; }\n#define curr(P,i) P[i]\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1) % P.size()]\nenum { OUT, ON, IN };\nnamespace Geometory { // Geometory Library\n  struct Point {\n    double x, y;\n    Point(){};\n    Point(double x,double y):x(x),y(y){};\n    Point operator+(const Point& b) const { return Point(x + b.x,y + b.y); }\n    Point operator-(const Point& b) const { return Point(x - b.x,y - b.y); }\n    Point operator*(const double b) const { return Point(x * b,y * b); }\n    Point operator*(const Point& b) const { return Point(x * b.x - y * b.y,x * b.y + y * b.x); }\n    Point operator/(const double b) const { return Point(x / b,y / b); }\n    bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y;}\n    bool operator==(const Point& b) const { return eq(x,b.x) && eq(y,b.y); }\n    double norm(){ return x * x + y * y; }\n    double arg(){ return atan2(x,y); }\n    double abs(){ return sqrt(norm()); }\n    Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y,sin(theta) * x + cos(theta) * y); }\n    Point rotate90(){ return Point(-y,x); }\n    friend ostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\n    friend istream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\n  };\n    \n  struct Line {\n    Point a, b;\n    Line(){};\n    Line(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Line& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Line& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Segment {\n    Point a, b;\n    Segment(){};\n    Segment(Point a,Point b):a(a),b(b){};\n    friend ostream& operator<<(ostream& os, Segment& p){ return os<<\"(\"<<p.a.x<<\",\"<<p.a.y<<\") to (\"<<p.b.x<<\",\"<<p.b.y<<\")\"; }\n    friend istream& operator>>(istream& is, Segment& a){ return is>>a.a.x>>a.a.y>>a.b.x>>a.b.y; }\n  };\n  struct Circle {\n    Point p; double r;\n    Circle(){};\n    Circle(Point p, double r) : p(p),r(r){};\n  };\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n    \n  double cross(const Point& a,const Point& b){\n    return a.x * b.y - a.y * b.x;\n  }\n  double dot(const Point& a,const Point& b){\n    return a.x * b.x + a.y * b.y;\n  }\n    \n  int ccw(const Point& a,Point b,Point c){\n    b = b - a, c = c - a;\n    if(cross(b,c) > EPS)    return +1;  // a → b で 反時計方向におれて c\n    if(cross(b,c) < -EPS)    return -1; // a → b で 時計方向におれて c\n    if(dot(b,c) < 0)      return +2;  // c -- a -- bで一直線上\n    if(b.norm() < c.norm()) return -2; // a -- b -- cで一直線上\n    return 0;  // a -- c -- bで一直線上\n  }\n  Point Projection(const Line& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Projection(const Segment& l, const Point& p){\n    double t = dot( p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n  Point Reflection(const Line& l, const Point& p){\n    return p + (Projection( l, p) - p) * 2.0;\n  }\n    \n  double Distance( const Line& l,const Point& p) { //OK\n    return (p - Projection( l, p)).abs();\n  }\n    \n  bool Intersect(const Line& l, const Line& m){\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b-l.a, m.b-l.a)) < EPS;\n  }\n  bool Intersect(const Line& l, const Segment& s){\n    return cross( l.b - l.a, s.a - l.a) * cross( l.b - l.a, s.b - l.a) < EPS;\n  }\n  bool Intersect(const Line& l, const Point& p){\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n  bool Intersect(const Segment& s, const Segment& t){\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n  bool Intersect(const Segment& s, const Point& p){\n    return ccw(s.a, s.b, p) == 0;\n  }\n  bool Intersect(const Circle& c,const Line& l){\n    return Distance( l, c.p) <= c.r + EPS;\n  }\n  bool Intersect(const Circle& c,const Point& p){\n    return abs( ( p - c.p).abs() - c.r ) < EPS;\n  }\n  int Intersect(const Circle& c, const Segment& l){\n    if( (Projection( l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = ( c.p - l.a).abs(), d2 = ( c.p - l.b).abs();\n    if( d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if( d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS ) return 1;\n    const Point h = Projection( l, c.p);\n    if( dot( l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n  bool Intersect(const Circle& a,const Circle& b){\n    return ( ( a.p - b.p).norm() - ( a.r + b.r) * ( a.r + b.r) < EPS) &&\n      ( ( a.p - b.p).norm() - ( a.r - b.r) * ( a.r - b.r) > -EPS);\n  }\n  double Distance(const Segment& s,const Point& p){\n    Point r = Projection(s, p);\n    if ( Intersect( s, r)) return ( r - p).abs();\n    return min( ( s.a - p).abs(), ( s.b - p).abs());\n  }\n  double Distance(const Segment& a,const Segment& b){\n    if(Intersect( a, b)) return 0;\n    return min( min( Distance( a, b.a), Distance( a, b.b)), min( Distance( b, a.a), Distance( b, a.b)));\n  }\n  double Distance(const Line& l,const Line& m) {\n    return Intersect( l, m) ? 0 : Distance( l, m.a);\n  }\n  double Distance(const Line& l,const Segment& s) { //OK\n    if (Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n  double Distance(const Point& a,const Point& b){ //OK\n    return ( a - b).abs();\n  }\n  Point Crosspoint(const Segment& l,const Segment& m) { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if (abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n  PointPoint Crosspoint(const Circle& c,const Line l){\n    Point hp = Projection( l, c.p), h =  hp - c.p;\n    const double d2 = h.norm();\n    Point v = ( l.b - l.a) * sqrt( c.r * c.r - d2) / ( l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n  PointPoint Crosspoint(const Circle& c,const Segment& l) {\n    Line aa = Line( l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n  PointPoint Crosspoint(const Circle& c1,const Circle& c2){ //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt( s * ( s - c1.r) * ( s - c2.r) * ( s - d));\n    double h = 2 * S / d;\n    Point v = ( c2.p - c1.p) / ( c2.p - c1.p).abs();\n    double m = sqrt( c1.r * c1.r - h * h);\n    return PointPoint( c1.p + v * m + Point(0,1) * h * v, c1.p + v * m - Point(0,1) * h * v);\n  }\n  bool parallel(const Line& a,const Line& b){\n    return abs(cross( a.b - a.a, b.b - b.a)) < EPS;\n  }\n  bool orthogonal(const Line& a,const Line& b){\n    return abs(dot( a.a - a.b, b.a - b.b)) < EPS;\n  }\n  int Contains(const Polygon& Q,const Point& p){\n    bool in = false;\n    for(int i = 0 ; i < Q.size() ; i++ ){\n      Point a = curr(Q,i) - p, b = next(Q,i) - p;\n      if(a.y > b.y) swap(a,b);\n      if(a.y <= 0 && 0 < b.y && cross(a,b) < 0) in = !in;\n      if(cross(a,b) == 0 && dot(a,b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n  bool Contains(const Circle& c,const Point& p){\n    return ( c.p - p).abs() < c.r + EPS;\n  }\n  double Area2(const Polygon& p){ //OK\n    double A = 0;\n    for (int i = 0; i < p.size(); ++i){\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n  bool IsConvex(const Polygon& p){\n    for(int i = 0; i < p.size(); i++){\n      if(ccw(prev(p,i),curr(p,i),next(p,i)) == -1) return false;\n    }\n    return true;\n  }\n  Polygon Convex_Hull(Polygon& p){\n    int n = p.size(), k = 0;\n    if(n >= 3){\n      sort( p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]){\n        while(k >= 2 && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]){\n        while(k >= t && cross( ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize( k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n  double Convex_Diameter(Polygon& p){\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++){\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = ( p[is] - p[js]).norm();\n  \n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross( next( p, i) - curr( p, i), next( p, j) - curr( p, j)) >= 0){\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if(( p[i] - p[j]).norm() > maxdis){\n        maxdis = ( p[i] - p[j]).norm();\n        maxi = i; maxj = j;\n      }\n    }  while (i != is || j != js);\n    return maxdis;\n  }\n};\n\nint main()\n{\n  int A;\n  cin >> A;\n  while(A--) {\n    Geometory::Segment line;\n    int n;\n    vector< Geometory::Point > data[2]; // 必ず通らないといけないところ\n    cin >> line;\n    if(line.b < line.a) swap(line.a, line.b);\n\n    cin >> n;\n    for(int i = 0; i < n; i++) {\n      Geometory::Segment seg;\n      int o, l;\n      cin >> seg >> o >> l;\n      if(Geometory::Intersect(seg, line)) {\n        if(o == 1) {\n          if(l == 1) data[0].push_back(Geometory::Crosspoint(seg, line));\n          else data[1].push_back(Geometory::Crosspoint(seg, line));\n        } else {\n          if(l == 1) data[1].push_back(Geometory::Crosspoint(seg, line));\n          else data[0].push_back(Geometory::Crosspoint(seg, line));\n        }\n      }\n    }\n    sort(data[0].begin(), data[0].end());\n    sort(data[1].begin(), data[1].end());\n\n    int low = 0, high = 0;\n    int prev = -1, ret = 0;\n    while(low < data[0].size() || high < data[1].size()) {\n      if(low < data[0].size() && (data[1].size() == high || data[0][low] < data[1][high])) {\n        if(prev == 1) ++ret;\n        prev = 0;\n        ++low;\n      } else {\n        if(prev == 0) ++ret;\n        prev = 1;\n        ++high;\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <ccomplex>\n#include <cstring>\n#include <algorithm>\n#include <tuple>\n\n#define For(i,a,b) for(int i = a;i < b; i++)\n#define rep(i,n) For(i,0,n)\n#define clr(n)\tmemset(n,0,sizeof n)\n\nusing namespace std;\n\ntypedef long double d;\ntypedef complex<d> P;\ntypedef pair<P, P> L;\nconst d EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\nd dot(P a, P b){\n\treturn (conj(a) * b).X;\n}\n\nd cross(P a, P b){\n\treturn (conj(a) * b).Y;\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS)return 1;\n\tif (cross(b, c) < -EPS)return -1;\n\tif (dot(b, c) < -EPS)return 2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\n\nbool isecLL(P a1, P a2, P b1,P b2){\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nbool isecLL(L l1, L l2){\n\treturn isecLL(l1.first, l1.second, l2.first, l2.second);\n}\n\nconst int INF = 1e9;\n\nP crosspointLL(P a1, P a2, P b1, P b2){\n\td d1 = cross(b2 - b1, b1 - a1);\n\td d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\tif (EQ(d2, 0))return P(INF,INF);\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\nP crosspointLL(L l1, L l2){\n\treturn crosspointLL(l1.first, l1.second, l2.first, l2.second);\n}\n\ntypedef tuple<P, int, int> T;\n\nint main(){\n\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\t\td xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tL sl(P(xa, ya), P(xb, yb));\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<L> vL;\n\t\tvector<int> vo;\n\t\tvector<int> vl;\n\n\t\trep(i, n){\n\t\t\td xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\n\t\t\tvL.push_back(L(P(xs, ys), P(xt, yt)));\n\t\t\tvo.push_back(o);\n\t\t\tvl.push_back(l);\n\t\t}\n\n\t\tvector<T> vp;\n\n\t\trep(i, n){\n\t\t\tif (isecLL(sl, vL[i])){\n\t\t\t\tvp.push_back(T(crosspointLL(sl, vL[i]),vo[i],vl[i]));\n\t\t\t}\n\t\t}\n\n\t\tbool f = false;\n\t\twhile (!f){\n\t\t\tf = true;\n\t\t\trep(i,vp.size()-1){\n\t\t\t\tauto p1 = get<0>(vp[i]);\n\t\t\t\tauto p2 = get<0>(vp[i+1]);\n\t\t\t\td dist1 = (p1.X - sl.first.X)*(p1.X - sl.first.X) + (p1.Y - sl.first.Y)*(p1.Y - sl.first.Y);\n\t\t\t\td dist2 = (p2.X - sl.first.X)*(p2.X - sl.first.X) + (p2.Y - sl.first.Y)*(p2.Y - sl.first.Y);\n\n\t\t\t\tif (dist1 > dist2){\n\t\t\t\t\tswap(vp[i], vp[i + 1]);\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, 2){\n\t\t\tint val = 0;\n\t\t\tint sf = i;\n\t\t\trep(j, vp.size()){\n\t\t\t\tif (get<1>(vp[j]) == 1){\n\t\t\t\t\tif (get<2>(vp[j]) != sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (get<2>(vp[j]) == sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(val, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int a, int b, int c, int d, int e, int f, int g, int h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int a, int b, int c, int d, int e, int f, int g, int h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            //cout << a << ' ' << b << endl;\n            if(not a) b = (b ? 0 : 1);\n            place[i] = b;\n            //cout << a << ' ' << b << endl;\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n){\n            if(isIntersectedL(rail, old[i])){\n                    v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n            }\n        }\n        sort(all(v));\n        rep(i,v.size()){\n            //show(v[i].first)\n            if(s.empty()) s.emplace_back(v[i].second);\n            if(s.back() == v[i].second) continue;\n            s.emplace_back(v[i].second);\n        }\n        rep(i,s.size() - 1) assert(s[i] != s[i + 1]);\n\n        cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-19)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> Pair;\n\nint u, n;\ndouble xa, ya, xb, yb;\ndouble x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\ntypedef complex<double> P;\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b){\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b){\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P>{\n  L(const P &a, const P &b){\n    push_back(a); push_back(b);\n  }\n};\n\nstruct Line{\n  L l; int pos;\n  Line(L l, int pos):l(l),pos(pos){}\n};\ntypedef vector<P> G;\n\nint ccw(P a, P b, P c){\n  b -= a; c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t){\n  return ccw(s[0], s[1], t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n\nP projection(const L &l, const P &p){\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceSP(const L &s, const P &p){\n  const P r = projection(s,p);\n  if(intersectSP(s, r)) return abs(r-p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nP A,B;\nvector<pair<L, int> >exs;\n\nbool cmp(const pair<L,int>& a, const pair<L,int>& b){\n  return distanceSP(a.first, A) < distanceSP(b.first, A);\n  //  return a < b;\n}\n\nL newL(0.0,0.0);\nint n;\n\nint main(){\n  int T;\n  scanf(\"%d\",&T);\n  while(T--){\n    exs.clear();\n    int xa,ya,xb,yb;\n    scanf(\"%d%d%d%d\",&xa,&ya,&xb,&yb);\n    P a(xa,ya); P b(xb,yb);\n    newL = L(a,b);\n    scanf(\"%d\",&n);\n    rep(i,n){\n      int xs,ys,xt,yt,o,l;\n      scanf(\"%d%d%d%d%d%d\",&xs,&ys,&xt,&yt,&o,&l);\n      P s(xs,ys); P t(xt,yt);\n      if(!o) l = !l;\n      L tmp(s, t);\n      if(intersectSS(tmp, newL)) exs.push_back(MP(tmp, l));\n    }\n\n    sort(exs.begin(), exs.end(), cmp);\n    int res = 0;\n    int now = exs[0].second;\n    rep(i,exs.size()){\n      if(now != exs[i].second){\n\tres++;\n\tnow = exs[i].second;\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <complex>\n#include <math.h>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef complex<double> Complex;\nstatic const double E = 0.0000001;\n\nstruct Point {\n  Complex p;\n  int o;\n  int h;\n  Point() {;}\n  Point(Complex p1, int o1, int h1) : p(p1), o(o1), h(h1) {;}\n  bool operator<(const Point &rhs) const {\n    return p.real() + p.imag() < rhs.p.real() + rhs.p.imag();\n  }\n};\n\nstruct Line {\n  Complex p1;\n  Complex p2;\n  int o;\n  int h;\n  Line() {;}\n  Line(double x1, double y1, double x2, double y2, int o1, int h1) : p1(x1, y1), p2(x2, y2), o(o1), h(h1) {;}\n};\n\nstruct Comp {\n  bool operator()(const Complex &rhs, const Complex &lhs) const { return rhs.real() < lhs.real(); }\n};\n\n\ninline void line_to_equation(const Complex s1, const Complex e1, double *a, double *b, double *c);\ninline double ccw(const Complex vect1, const Complex vect2);\ninline double ccw3(const Complex s, const Complex e1, const Complex e2);\ninline double distance_point_line(const Complex p1, const double r1, const Complex s1, const Complex e1);\ninline double distance_point_segment(const Complex p1, const Complex s1, const Complex e1);\ninline double distance_line_line(const Complex s1, const Complex e1, const Complex s2, const Complex e2);\ninline double distance_segment_segment(const Complex s1, const Complex e1, const Complex s2, const  Complex e2);\ninline double distance_line_segment(const Complex s1, const Complex e1, const Complex s2, const Complex e2);\ninline bool collide_line_line(const Complex s1, const Complex e1, const Complex s2, const Complex e2);\ninline bool collide_rect_rect(const Complex p11, const Complex p12, const Complex p21, const Complex p22);\ninline bool collide_segment_segment(const Complex s1, const Complex e1, const Complex s2, const Complex e2);\ninline bool collide_circle_circle(const Complex p1, const double r1, const Complex p2, const double r2);\ninline bool collide_rect_point(const Complex p11, const Complex p12, const Complex p2);\ninline bool collide_rect_line(const Complex p11, const Complex p12, const Complex s1, const Complex e1);\ninline bool collide_rect_segment(const Complex p11, const Complex p12, const Complex s1, const Complex e1);\ninline bool collide_line_point(const Complex s1, const Complex e1, const Complex p1);\ninline bool collide_line_segment(const Complex s1, const Complex e1, const Complex s2, const Complex e2);\ninline bool collide_segment_point(const Complex s1, const Complex e1, const Complex p1);\ninline bool collide_circle_point(const Complex p1, const double r1, const Complex p2);\ninline bool collide_circle_line(const Complex p1, const double r1, const Complex s1, const Complex e1);\ninline bool collide_circle_segment(const Complex p1, const double r1, const Complex s1, Complex e1);\ninline Complex intersection_line_line(const Complex s1, const Complex e1, const Complex s2, Complex e2);\ninline void intersection_circle_circle(const Complex p1, const double r1, const Complex p2, const double r2, int *size, Complex *ret1, Complex *ret2);\ninline void intersection_circle_line(const Complex p1, const double r1, const Complex s1, const Complex e1, int *size, Complex *ret1, Complex *ret2);\ninline void intersection_circle_segment(const Complex p1, const double r1, const Complex s1, const Complex e1, int *size, Complex *ret1, Complex *ret2);\n\n\n\n\n\n\ntemplate<class T>\ninline T square(const T &x) { return x * x; }\n\n// ax+by+c=0\ninline void line_to_equation(const Complex s1, const Complex e1, double *a, double *b, double *c) {\n  assert(s1 != e1);\n  assert(a != NULL && b != NULL && c != NULL);\n  Complex vect = e1 - s1;\n  *a = vect.imag();\n  *b = -vect.real();\n  *c = s1.imag() * vect.real() - s1.real() * vect.imag();\n}\n\ninline double ccw(const Complex vect1, const Complex vect2) {\n  return vect1.real() * vect2.imag() - vect2.real() * vect1.imag();\n}\n\ninline double ccw3(const Complex s, const Complex e1, const Complex e2) {\n  return ccw(e1 - s, e2 - s);\n}\n\n\ninline bool collide_line_point(const Complex s1, const Complex e1, const Complex p1) {\n  double a, b, c;\n  line_to_equation(s1, e1, &a, &b, &c);\n  return fabs(a * p1.real() + b * p1.imag() + c ) < E;\n}\n\ninline bool collide_line_line(const Complex s1, const Complex e1, const Complex s2, const Complex e2) {\n  Complex vect1 = e1 - s1;\n  Complex vect2 = e2 - s2;\n  assert(abs(vect1) > E && abs(vect2) > E);\n  if (fabs(vect1.real() * vect2.imag() - vect2.real() * vect1.imag()) >= E) { return true; }\n  return collide_line_point(s1, e1, s2);\n\n}\n\ninline bool collide_rect_rect(const Complex p11, const Complex p12, const Complex p21, const Complex p22) {\n  return min(p11.real(), p12.real()) <= max(p21.real(), p22.real()) &&\n    max(p11.real(), p12.real()) >= min(p21.real(), p22.real()) &&\n    min(p11.imag(), p12.imag()) <= max(p21.imag(), p22.imag()) &&\n    max(p11.imag(), p12.imag()) >= min(p21.imag(), p22.imag());\n}\n\ninline bool collide_segment_segment(const Complex s1, const Complex e1, const Complex s2, const Complex e2) {\n  if (!collide_rect_rect(s1, e1, s2, e2)) { return false; }\n  if (ccw3(s1, e1, s2) * ccw3(s1, e1, e2) > 0 ||\n      ccw3(s2, e2, s1) * ccw3(s2, e2, e1) > 0) { return false; }\n  return collide_line_line(s1, e1, s2, e2);\n}\n\n// include rect inside\ninline bool collide_rect_point(const Complex p11, const Complex p12, const Complex p2) {\n  return collide_rect_rect(p11, p12, p2, p2);\n}\n\ninline bool collide_line_segment(const Complex s1, const Complex e1, const Complex s2, const Complex e2) {\n  double a, b, c;\n  line_to_equation(s1, e1, &a, &b, &c);\n  return (a * s2.real() + b * s2.imag() + c) * (a * e2.real() + b * e2.imag() + c) <= 0;\n}\n\ninline Complex intersection_line_line(const Complex s1, const Complex e1, const Complex s2, Complex e2) {\n  double a, b, c, d, e, f;\n  line_to_equation(s1, e1, &a, &b, &c);\n  line_to_equation(s2, e2, &d, &e, &f);\n  assert(fabs(a * e - b * d) > E && fabs(b * d - a * e) > E);\n  return Complex(-(b * f - c * e) / (a * e - b * d), -(a * f - c * d) / (b * d - a * e));\n}\n\n\ninline bool check_cross(const Line &l1, const Line &l2) {\n  return collide_segment_segment(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\ninline Complex cross(const Line &l1, const Line &l2) {\n  return intersection_line_line(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\nPoint cross_point[101];\nLine line[100];\n\nint main() {\n  int test;\n  scanf(\"%d\", &test);\n  while (test--) {\n    Line sinkansen;\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n    sinkansen = Line(a, b, c, d, 0, 0);\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n      int o, h;\n      scanf(\"%d %d %d %d %d %d\", &a, &b, &c, &d, &o, &h);\n      line[i] = Line(a, b, c, d, o, h);\n    }\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n      if (!check_cross(sinkansen, line[i])) { continue; }\n      cross_point[count] = Point(cross(line[i], sinkansen), line[i].o, line[i].h);\n      count++;\n    }\n    sort(cross_point, cross_point + count);\n    int ans = 0;\n    int prev;\n    if (cross_point[0].o == 1) {\n      prev = cross_point[0].h;\n    } else {\n      prev = 1 - cross_point[0].h;\n    }\n    for (int i = 1; i < count; i++) {\n    if (cross_point[i].o == 1) {\n      if (cross_point[i].h != prev) { ans++; }\n      prev = cross_point[i].h;\n    } else {\n      if (cross_point[i].h == prev) { ans++; }\n      prev = 1 - cross_point[i].h;\n    }\n    }\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\n// üªÌð·»è\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nelem areaOfPolygon(const vector<point> &vp){\n  elem ret = 0;\n  for(int i = 0; i < vp.size(); ++i){\n    ret += cross(vp[i],vp[(i+1)%vp.size()]);\n  }\n  return ret/2.0;\n}\n\nstruct Line{\n  seg s;\n  int o;\n  int l;\n  Line(seg s, int o, int l):s(s),o(o),l(l){}\n  Line(){}\n};\n\nstruct Exit{\n  int l;\n  int o;\n  elem distA;\n  bool operator<(const Exit &t)const{\n    return lt(distA,t.distA);\n  }\n};\n\nint minimumExits(int la, const point &A,\n\t\t  int lb, const point &B,\n\t\t  const vector<Line> &vl)\n{\n  int ret=0;\n  seg s(A,B);\n  vector<Exit> vexit;\n  for(int i = 0; i < vl.size(); ++i){\n    point tmp;\n    if(intersectionSS(s,vl[i].s,tmp)){\n      Exit exit;\n      exit.o = vl[i].o;\n      exit.l = vl[i].l;\n      exit.distA = abs(tmp-A);\n      vexit.push_back(exit);\n    }\n  }\n\n  sort(vexit.begin(),vexit.end());\n  int nowl=la;\n  for(int i = 0; i < vexit.size(); ++i){\n    if( vexit[i].l == nowl ){\n      if( vexit[i].o == 0 ){\n\t++ret;\n\tnowl = vexit[i].l?0:1;\n      }\n    }else{\n      if( vexit[i].o == 1 ){\n\t++ret;\n\tnowl = vexit[i].l;\n      }\n    }\n  }\n  if(nowl!=lb)++ret;\n  return ret;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int res=1<<28;\n    elem xa,ya,xb,yb;\n    cin >> xa >> ya >> xb >> yb;\n    point A(xa,ya);\n    point B(xb,yb);\n    int N;\n    cin >> N;\n    vector<Line> vl;\n    for(int i = 0; i < N; ++i){\n      elem xs,ys,xg,yg;\n      int o,l;\n      cin >> xs >> ys >> xg >> yg;\n      cin >> o >> l;\n      point start(xs,ys);\n      point goal(xg,yg);\n      vl.push_back( Line(seg(start,goal),o,l) );\n    }\n    for(int la=0;la<2;++la){\n      for(int lb=0;lb<2;++lb){\n\tres= min(res,minimumExits(la,A,lb,B,vl));\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\nclass Line {\npublic:\n\tPoint a, b;\n};\nbool well_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\tif (abs(cross(tv, sv)) < eps)return false;\n\treturn true;\n}\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\nbool comp(pair<Point,int> x, pair<Point,int> y) {\n\tPoint p = x.first; Point q = y.first;\n\tif (real(p) < real(q))return true;\n\tif (eq(real(p), real(q)) && imag(p) < imag(q))return true;\n\treturn false;\n}\nint main() {\n\tint aaaaa; cin >> aaaaa;\n\trep(i, aaaaa) {\n\t\tld x, y, z, w; cin >> x >> y >> z >> w;\n\t\tLine bas = { {x,y},{z,w} };\n\t\tint ud,compa;\n\t\tvector<pair<Point, int>> v;\n\t\tint n; cin >> n;\n\t\trep(i, n) {\n\t\t\tcin >> x >> y >> z >> w >> compa >> ud;\n\t\t\tLine alr = { {x,y},{z,w} };\n\t\t\tif (well_ll(bas, alr)) {\n\t\t\t\tPoint cap = is_ll(bas, alr);\n\t\t\t\tif (isis_sp(bas, cap) && isis_sp(alr, cap)) {\n\t\t\t\t\tv.push_back({ cap,compa^ud });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(), v.end(),comp);\n\t\tint len = v.size();\n\t\tint out = 0;\n\t\tif (len != 0) {\n\t\t\tint now = v[0].second;\n\t\t\tRep(i, 1, len) {\n\t\t\t\tif (now != v[i].second) {\n\t\t\t\t\tnow = v[i].second; out++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << out << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL() {}\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n\n\n\n\n\nL ab;\nint n;\nL st[100];\nint o[100], l[100];\n\nvoid init()\n{\n\tdouble x, y;\n\n\tcin >> x >> y; P a(x, y);\n\tcin >> x >> y; P b(x, y);\n\tab = L(a, b);\n\n\tcin >> n;\n\n\trep(i, 0, n)\n\t{\n\t\tcin >> x >> y; P s(x, y);\n\t\tcin >> x >> y; P t(x, y);\n\t\tst[i] = L(s, t);\n\t\tcin >> o[i] >> l[i];\n\t}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(_dn, 0, dn)\n\t{\n\t\tinit();\n\t\t\n\t\tvector<pair<double, int> > v;\n\t\trep(i, 0, n)\n\t\t{\n\t\t\tif (!intersectSS(ab, st[i])) continue;\n\t\t\t\n\t\t\tP c = crosspoint(ab, st[i]);\n\t\t\tdouble d = abs(c - ab[0]);\n\n\t\t\tint p;\n\t\t\tif (o[i] == 0)\n\t\t\t\tp = 1 - l[i];\n\t\t\telse\n\t\t\t\tp = l[i];\n\n\t\t\tv.push_back(make_pair(d, p));\n\t\t}\n\n\t\tif (v.size() == 0)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tint ans = 0;\n\t\trep(i, 0, v.size() - 1)\n\t\t{\n\t\t\tif (v[i].second != v[i + 1].second) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst double EPS = 1e-10;\n\ndouble intersect(double xa, double ya, double xb, double yb, double xc, double yc, double xd, double yd){\n    double g =  (xb - xa)*(yd - yc) - (yb - ya)*(xd - xc);\n    if (fabs(g) < EPS) return -1;\n    return ((yd - yc)*(xc - xa) - (xd - xc)*(yc - ya)) / g;\n}\n\nint calc(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int n;\n    cin >> n;\n    vector<pair<double, int> > a;\n    while (n--){\n        double xs, ys, xt, yt;\n        int p, q;\n        cin >> xs >> ys >> xt >> yt >> p >> q;\n        double r = intersect(xa, ya, xb, yb, xs, ys, xt, yt);\n        if (r > 0 && r < 1){\n            a.push_back(make_pair(r, p^q));\n        }\n    }\n    sort(a.begin(), a.end());\n    if (a.size() <= 1) return 0;\n    int ans = 0;\n    REP(i,a.size()-1){\n        if (a[i].second != a[i+1].second) ans++;\n    }\n    return ans;\n}\n\nint main() {\n    int m;\n    cin >> m;\n    while (m--){\n        cout << calc() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <ccomplex>\n#include <cstring>\n#include <algorithm>\n#include <tuple>\n\n#define For(i,a,b) for(int i = (a);i < (b); i++)\n#define rep(i,n) For(i,0,(n))\n#define clr(n)\tmemset(n,0,sizeof n)\n\nusing namespace std;\n\ntypedef long double d;\ntypedef complex<d> P;\n\ntypedef pair<P, P> L;\nconst d EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\nd dot(P a, P b){\n\treturn (conj(a) * b).X;\n}\n\nd cross(P a, P b){\n\treturn (conj(a) * b).Y;\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS)return 1;\n\tif (cross(b, c) < -EPS)return -1;\n\tif (dot(b, c) < -EPS)return 2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\n\nbool isecLL(P a1, P a2, P b1, P b2){\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nbool isecLL(L l1, L l2){\n\treturn isecLL(l1.first, l1.second, l2.first, l2.second);\n}\n\nconst d INF = 1e9;\n\nP crosspointLL(P a1, P a2, P b1, P b2){\n\td d1 = cross(b2 - b1, b1 - a1);\n\td d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\nP crosspointLL(L l1, L l2){\n\treturn crosspointLL(l1.first, l1.second, l2.first, l2.second);\n}\n\ntypedef tuple<d, int, int> T;\n\nint main(){\n\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\t\td xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tL sl(P(xa, ya), P(xb, yb));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<L> vL;\n\t\tvector<int> vo;\n\t\tvector<int> vl;\n\n\t\trep(i, n){\n\t\t\td xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\n\t\t\tvL.push_back(L(P(xs, ys), P(xt, yt)));\n\t\t\tvo.push_back(o);\n\t\t\tvl.push_back(l);\n\t\t}\n\n\t\tvector<T> vp;\n\n\t\trep(i, vL.size()){\n\t\t\tif (isecLL(sl, vL[i])){\n\t\t\t\tP p = crosspointLL(sl,vL[i]);\n\t\t\t\td dist1 = (p.X - sl.first.X)*(p.X - sl.first.X) + (p.Y - sl.first.Y)*(p.Y - sl.first.Y);\n\t\t\t\tvp.push_back(T(dist1, vo[i], vl[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(vp.begin(), vp.end());\n\n\t\tint ans = INF;\n\t\trep(i, 2){\n\t\t\tint val = 0;\n\t\t\tint sf = i;\n\t\t\trep(j, vp.size()){\n\t\t\t\tif (get<1>(vp[j]) == 1){\n\t\t\t\t\tif (get<2>(vp[j]) != sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (get<2>(vp[j]) == sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(val, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nconst double EPS = 1e-10;\ntemplate<class T>\nbool eq(const T& a, const T& b) {return abs(a - b) < EPS;}\n\ntypedef complex<double> point;\ndouble cross(const point& a, const point& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const point& a, const point& b) {\n\treturn real(conj(a)*b);\n}\nint ccw(point a, point b, point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;  // counter clockwise\n\tif (cross(b, c) < 0)   return -1;  // clockwise\n\tif (dot(b, c) < 0)     return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;  // a--c--b on line or a----bc\n}\n\ntypedef array<point, 2> line;\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t\tccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (eq(A, 0.) && eq(B, 0.)) return m[0]; // same line\n\tif (eq(A, 0.)) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\nline read_line() {\n\tline res;\n\tfor (auto& p : res) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp = point(x, y);\n\t}\n\treturn res;\n}\n\nint solve() {\n\tline new_road = read_line();\n\tint n;\n\tcin >> n;\n\ttypedef tuple<point, bool, bool> pinfo;\n\tvector<pinfo> points;\n\tfor (int i = 0; i < n; i++) {\n\t\tline l = read_line();\n\t\tbool own, ground;\n\t\tcin >> own >> ground;\n\t\tif (intersectSS(new_road, l)) {\n\t\t\tpoints.emplace_back(crosspoint(new_road, l), own, ground);\n\t\t}\n\t}\n//\tcout << points.size() << endl;\n\tsort(points.begin(), points.end(), [&new_road](const pinfo& a, const pinfo& b) {\n\t\treturn abs(get<0>(a) - new_road[0]) < abs(get<0>(b) - new_road[0]);\n\t});\n\tbool cur = get<1>(points[0]) ? get<2>(points[0]) : !get<2>(points[0]);\n\tint cnt = 0;\n\tfor (int i = 1; i < points.size(); i++) {\n\t\tif ((get<1>(points[i]) && cur != get<2>(points[i])) ||\n\t\t\t(!get<1>(points[i]) && cur == get<2>(points[i]))) {\n\t\t\tcur = !cur;\n\t\t\tcnt++;\n//\t\t\tcout << i << endl;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nusing T = long double;\nconst T INF = 1e10;\nconst T EPS = 1e-10;\nconst T PI = acos(-1.0);\nT torad(int deg) {return (T)(deg) * PI / 180;}\nT todeg(T ang) {return ang * 180 / PI;}\ntemplate <typename T> inline bool eq(T p, T q) { return abs(p - q) < EPS; }\ninline int sgn(T x) { return (T(0) < x) - (x < T(0)); }\n\n/* Point */\nusing P = complex<T>;\n#define x real()\n#define y imag()\ninline T dot(P v, P w) { return (conj(v) * w).x; }\ninline T cross(P v, P w) { return (conj(v) * w).y; }\ninline T orient(P a, P b, P c) { return cross(b - a, c - a); }\ninline bool isOrth(P v, P w) { return dot(v, w) == 0; }\ninline bool isPara(P v, P w) { return cross(v, w) == 0; }\ninline P unit(P v) { return v / abs(v); }\ninline P translate(P p, P v) { return p + v; }\ninline P scale(P p, P c, T k) { return c + (p - c) * k; }\ninline P rot(P p, T a) { return p * polar(T(1), a); }\ninline P rot90(P p) { return {-p.y, p.x}; }\ninline P linearTransform(P p, P q, P fp, P fq, P r) { return fp + (r - p) * (fq - fp) / (q - p); }\nbool cmpX(const P& a, const P& b) { return a.x != b.x ? a.x < b.x : a.y < b.y; }\nbool cmpY(const P& a, const P& b) { return a.y != b.y ? a.y < b.y : a.x < b.x; }\nnamespace std {\n    istream& operator>>(istream& is, P& p) { T xx, yy; is >> xx >> yy; p = P(xx, yy); return is; }\n    bool operator < (const P& a, const P& b) { return cmpX(a, b); }\n}\n\n/* Line */\nstruct L : array<P, 2> {\n    P v; T c;\n    L() = default;\n    explicit L(P a, P b) : array<P, 2>({a, b}), v(b - a), c(cross(v, a)) {}\n    T side(P p) { return cross(v, p) - c; }\n    P proj(P p) { return p - rot90(v) * side(p) / norm(v); }\n    P refl(P p) { return p - rot90(v) * T(2) * side(p) / norm(v); }\n    bool onLine(P p) { return abs(side(p)) < EPS; }\n    bool onSegment(P p) { return onLine(p) && dot(this->operator[](0) - p, this->operator[](1) - p) <= EPS; }\n    friend istream& operator>>(istream& is, L& l) { P p, q; is >> p >> q; l = L(p, q); return is; }\n    friend ostream& operator<<(ostream& os, const L& l) { return os << '{' << l[0] << \", \" << l[1] << '}'; }\n};\n\n/* Circle */\nstruct C : P {\n    T r;\n    C() = default;\n    C(P p, T r) : P(p), r(r) {}\n    friend istream& operator>>(istream& is, C& c) { P p; T r; is >> p >> r; c = C(p, r); return is; }\n    friend ostream& operator<<(ostream& os, const C& c) { return os << '(' << c.x << \", \" << c.y << \", \" << c.r << ')'; }\n};\n\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS) return 1;         // counter clockwise\n    if (cross(b, c) < -EPS) return -1;       // clockwise\n    if (dot(b, c) < -EPS) return 2;          // c--a--b on line\n    if (norm(b) < norm(c) - EPS) return -2;  // a--b--c on line or a==b\n    return 0;                                // a--c--b on line or a==c or b==c\n}\n\n// intersect\nbool isInterPL(P p, L l) { return (ccw(l[0], l[1], p) != 1); }\nbool isInterPS(P p, L s) { return (ccw(s[0], s[1], p) == 0); }\nbool isInterLL(L l, L m) { return (!isPara(l.v, m.v)); }\nbool isInterLS(L l, L s) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], l);\n    return (ccw(l[0], l[1], s[0]) * ccw(l[0], l[1], s[1]) <= 0);\n}\nbool isInterSS(L s, L t) {\n    if (eq(s[0], s[1])) return isInterPL(s[0], t);\n    if (eq(t[0], t[1])) return isInterPL(t[0], s);\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n            ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\nint isInterCC(C a, C b) {\n    T d = abs(b - a);\n    if (a == b && a.r == b.r) return 0;         // ∞ cp (A = B)\n    if (a.r + d - b.r < -EPS) return +1;        // 0 cp (A in B)\n    if (b.r + d - a.r < -EPS) return -1;        // 0 cp (B in A)\n    if (abs(a.r + d - b.r) < EPS) return +2;    // 1 cp (A in B)\n    if (abs(b.r + d - a.r) < EPS) return -2;    // 1 cp (B in A)\n    if (abs(a.r + b.r - d) < EPS) return 3;     // 1 cp (outside)\n    if (a.r + b.r - d < -EPS) return 4;         // 0 cp (outside)\n    return 5;                                   // 2 cp\n}\n\n// distance\nT distancePL(P p, L l) { return (abs(p - l.proj(p))); }\nT distancePS(P p, L s) {\n    P h = s.proj(p);\n    if (isInterPS(h, s)) return abs(p - h);\n    return min(abs(p - s[0]), abs(p - s[1]));\n}\nT distanceLL(L l, L m) {\n    if (isInterLL(l, m)) return 0.0;\n    return distancePL(m[0], l);\n}\nT distanceLS(L l, L s) {\n    if (isInterLS(l, s)) return 0;\n    return min(distancePL(s[0], l), distancePL(s[1], l));\n}\nT distanceSS(L s, L t) {\n    if (isInterSS(s, t)) return 0;\n    return min({distancePS(s[0], t), distancePS(s[1], t), distancePS(t[0], s), distancePS(t[1], s)});\n}\n\n// crosspoint\nvector<P> crosspointLL(L l, L m) {\n    if (!isInterLL(l, m)) return vector<P>();\n    vector<P> res;\n    T d = cross(m[1] - m[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLS(L l, L s) {\n    if (!isInterLS(l, s)) return vector<P>();\n    vector<P> res;\n    T d = cross(s[1] - s[0], l[1] - l[0]);\n    res.push_back(l[0] + (l[1] - l[0]) * cross(s[1] - s[0], s[1] - l[0]) / d);\n    return res;\n}\nvector<P> crosspointLC(L l, C c, bool dupl = false) {\n    if (abs(c - l.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, l), h2 = c.r * c.r - d * d;\n    assert(h2 >= -EPS);\n    P p = l.proj(c), h = l.v * sqrt(h2) / abs(l.v);\n    res.push_back(p - h);\n    if (dupl || abs(h) > EPS) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointSS(L s, L t) {\n    if (!isInterSS(s, t)) return vector<P>();\n    vector<P> res;\n    T d = cross(t[1] - t[0], s[1] - s[0]);\n    if (d) {\n        res.push_back(s[0] + (s[1] - s[0]) * cross(t[1] - t[0], t[1] - s[0]) / d);\n    } else {\n        if (ccw(s[0], s[1], t[0]) == 0) res.push_back(t[0]);\n        if (ccw(s[0], s[1], t[1]) == 0) res.push_back(t[1]);\n        if (ccw(t[0], t[1], s[0]) == 0) res.push_back(s[0]);\n        if (ccw(t[0], t[1], s[1]) == 0) res.push_back(s[1]);\n    }\n    return res;\n}\nvector<P> crosspointSC(L s, C c, bool dupl = false) {\n    if (abs(c - s.proj(c)) > c.r) return vector<P>();\n    vector<P> res;\n    T d = distancePL(c, s), h2 = c.r * c.r - d * d;\n    assert(h2 >= -EPS);\n    P p = s.proj(c), h = s.v * sqrt(h2) / abs(s.v);\n    if (isInterPS(p - h, s)) res.push_back(p - h);\n    if (dupl || (abs(h) > EPS && isInterPS(p + h, s))) res.push_back(p + h);\n    return res;\n}\nvector<P> crosspointCC(C c1, C c2, bool dupl = false) {\n    P d = c2 - c1; T d2 = norm(d);\n    if (d2 == 0) { assert(c1.r != c2.r); return vector<P>(); }\n    vector<P> res;\n    T pd = (d2 + c1.r * c1.r - c2.r * c2.r) / 2;\n    T h2 = c1.r * c1.r - pd * pd / d2;\n    if (h2 >= 0) {\n        P p = c1 + d * pd / d2, h = rot90(d) * sqrt(h2 / d2);\n        res.push_back(p - h);\n        if (dupl || abs(h) > EPS) res.push_back(p + h);\n    }\n    return res;\n}\n\nvoid solve() {\n    L s; int n;\n    cin >> s >> n;\n    vector<L> ls(n);\n    vector<int> o(n), l(n);\n    vector<pair<P, int>> cps;\n    REP (i, n) {\n        cin >> ls[i] >> o[i] >> l[i];\n        for (P& p : crosspointSS(s, ls[i])) {\n            cps.emplace_back(p, o[i] ^ l[i]);\n        }\n    }\n    sort(cps.begin(), cps.end());\n    int ans = 0, pre = -1;\n    for (auto cp : cps) {\n        if (cp.second != pre) {\n            pre = cp.second;\n            ans++;\n        }\n    }\n    cout << (ans ? ans - 1 : 0) << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    REP (i, T) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std{\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L &l, const P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint N,n,p[101],cp[101];\nP c[101];\nL l[101];\npair<P,int> cr[101];\n\nint main(){\n\tcin>>N;\n\twhile(N--){\n\t\tdouble xs,ys,xt,yt;\n\t\tcin>>xs>>ys>>xt>>yt;\n\t\tl[0]=L(P(xs,ys),P(xt,yt));\n\t\tcin>>n;\n\t\trep(i,n){\n\t\t\tint p1,p2;\n\t\t\tcin>>xs>>ys>>xt>>yt>>p1>>p2;\n\t\t\tl[i+1]=L(P(xs,ys),P(xt,yt));\n\t\t\tp[i+1]=p1^p2;\n\t\t}\n\t\tint cur=0,ans=0;\n\t\trep(i,n){\n\t\t\tif(intersectSS(l[0],l[i+1]))cr[cur++]=make_pair(crosspoint(l[0],l[i+1]),p[i+1]);\n\t\t}\n\t\tsort(cr,cr+cur);\n\t\trep(i,cur-1)ans+=cr[i].second^cr[i+1].second;\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 100000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(0,0),Point p2=Point(0,0)):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return (s1.p1+(s1.p2-s1.p1)*t);\n}\n\nint main()\n{\n  int n,N,a,b,c,d,e,f;\n  Segment AB;\n  vector<pair<Segment,pair<int,int> > > railroad;\n\n  cin>>n;\n  for(int k=0;k<n;k++){\n    railroad.clear();\n    cin>>AB.p1.x>>AB.p1.y>>AB.p2.x>>AB.p2.y;\n    cin>>N;\n    for(int i=0;i<N;i++){\n      cin>>a>>b>>c>>d>>e>>f;\n      railroad.push_back(mp(Segment(Point(a,b),Point(c,d)),mp(e,f)));\n    }\n    vector<pair<Point,pair<int,int> > > vp;\n    for(int i=0;i<N;i++){\n      if(!intersect(AB,railroad[i].f))continue;\n      Point p=getCrossPointSS(AB,railroad[i].f);\n      vp.push_back(mp(p,mp(railroad[i].s.f,railroad[i].s.s)));\n    }\n    sort(vp.begin(),vp.end());\n    if(AB.p1<AB.p2)reverse(vp.begin(),vp.end());\n    int ans=0,s;\n\n    for(int i=0;i<vp.size();i++){\n      if(i==0){\n\tif(vp[i].s.f==1)s=vp[0].s.s;\n\tif(vp[i].s.f==0)s=(vp[0].s.s+1)%2;\n      }\n      else {\n\tif(vp[i].s.f==1){\n\t  if(vp[i].s.s!=s){\n\t    ans++;\n\t    s=vp[i].s.s;\n\t  }\n\t}\n\tif(vp[i].s.f==0){\n\t  if(vp[i].s.s==s){\n\t    ans++;\n\t    s=(vp[i].s.s+1)%2;\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nconst double eps=1e-10;\ndouble add(double a,double b){\n    if(abs(a+b)<eps*(abs(a)+abs(b)))return 0;\n    return a+b;\n}\n\ntypedef pair<double,double> P;\nP operator+(const P& x,const P& y){\n    return {add(x.first,y.first),add(x.second,y.second)};\n}\n\nP operator-(const P& x,const P& y){\n    return {add(x.first,-y.first),add(x.second,-y.second)};\n\n}\n\nP operator*(const P& x,const double& y){\n    return {x.first*y,x.second*y};\n}\ndouble dot(P x,P y){\n    return add(x.first*y.first,x.second*y.second);\n\n\n}\n\ndouble det(P x,P y){\n    return add(x.first*y.second,-x.second*y.first);\n}\n\nbool onseg(P p1,P p2,P q){\n    return det(p1-q,p2-q)==0 &&dot(p1-q,p2-q)<=0; \n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1+(p2-p1)*(det(q2-q1,q1-p1)/det(q2-q1,p2-p1));\n}\n\nbool cross(P p1,P p2,P q1,P q2){\n    if(det(p1-p2,q1-q2)==0)return onseg(p1,p2,q1)||onseg(p1,p2,q2)||onseg(q1,q2,p1)||onseg(q1,q2,p2);\n    P ret=intersection(p1,p2,q1,q2);\n    return onseg(p1,p2,ret)&&onseg(q1,q2,ret);\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(wrtwrt,n){\n        P s,t;\n        cin>>s.first>>s.second>>t.first>>t.second;\n        int m;cin>>m;\n        map<P,int> mp;\n        vector<P> v;\n        rep(i,m){\n            P x,y;\n            cin>>x.first>>x.second>>y.first>>y.second;\n            int a,b;\n            cin>>a>>b;\n            if(cross(s,t,x,y)){\n                mp[intersection(s,t,x,y)]=a^b;\n                v.push_back(intersection(s,t,x,y));\n                }\n        }\n        if(v.empty()){cout<<0<<endl;continue;}\n        int ans=-1;\n        int pos=-1;\n        sort(v.begin(),v.end());\n        rep(i,v.size()){\n            if(mp[v[i]]!=pos)ans++;\n            pos=mp[v[i]];\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nP A, B;\nint N;\nvector<P> S, T;\nvector<int> Own, Pos;\n\nint main() {\n  int Tc;\n  cin >> Tc;\n  while(Tc--) {\n    cin >> A.real() >> A.imag() >> B.real() >> B.imag();\n    cin >> N;\n    S.resize(N);\n    T.resize(N);\n    Own.resize(N);\n    Pos.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].real() >> S[i].imag() >> T[i].real() >> T[i].imag()\n\t  >> Own[i] >> Pos[i];\n    }\n\n    vector<pair<double, int> > v;\n    for(int i = 0; i < N; ++i) {\n      if(isIntersect(A,B,S[i],T[i])) {\n\tP p = getCrossP(A,B,S[i],T[i]);\n\tv.push_back(make_pair(norm(p-A), i));\n      }\n    }\n    sort(v.begin(), v.end());\n    int pos = (Pos[v[0].second] ^ ~Own[v[0].second]);\n    int cnt = 0;\n    for(int i = 1; i < v.size(); ++i) {\n      int npos = Pos[v[i].second] ^ ~Own[v[i].second];\n      if(npos != pos) ++cnt;\n      pos = npos;\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define MOD_TYPE 1\n\n#pragma region Macros\n#include <bits/stdc++.h>\nusing namespace std;\n/*\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/multiprecision/cpp_dec_float.hpp>\nusing multiInt = boost::multiprecision::cpp_int;\nusing lld = boost::multiprecision::cpp_dec_float_100;\n*/\n/*\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n*/\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pld = pair<ld, ld>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconstexpr ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\n//constexpr ll MOD = 1;\nconstexpr int INF = (int)1e9;\nconstexpr ll LINF = (ll)4e18;\nconstexpr double PI = acos(-1.0);\nconstexpr double EPS = 1e-8;\nconstexpr int Dx[] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nconstexpr int Dy[] = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define REPI(i, m, n) for (int i = m; i < (int)(n); ++i)\n#define repi(i, n) REPI(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << \"\\n\"\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << \"\\n\"\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << \"\\n\"\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << \"\\n\"\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << \"\\n\"\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << \"\\n\";\n\ninline void init_main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n}\ntemplate <typename T>\ninline bool chmin(T &a, T b)\n{\n  if (a > b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <typename T>\ninline bool chmax(T &a, T b)\n{\n  if (a < b)\n  {\n    a = b;\n    return true;\n  }\n  return false;\n}\ninline ll CEIL(ll a, ll b)\n{\n  return (a + b - 1) / b;\n}\ntemplate <typename A, size_t N, typename T>\ninline void Fill(A (&array)[N], const T &val)\n{\n  fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T, typename U>\nconstexpr ostream &operator<<(ostream &os, pair<T, U> &p) noexcept\n{\n  os << p.first << \" \" << p.second;\n  return os;\n}\n#pragma endregion\n\nusing Real = double;\nusing Point = complex<Real>;\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d)\n{\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p)\n{\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p)\n{\n  return os << fixed << setprecision(20) << p.real() << \" \" << p.imag();\n}\n\n// 点 p を反時計回りに theta 回転\nPoint rotate(Real theta, const Point &p)\n{\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r)\n{\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d)\n{\n  return (d * PI / 180.0);\n}\n\n// a-b-c の角度のうち小さい方を返す\nReal get_angle(const Point &a, const Point &b, const Point &c)\n{\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if (alpha > beta)\n    swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std\n{\nbool operator<(const Point &a, const Point &b)\n{\n  return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n} // namespace std\n\nstruct Line\n{\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if (eq(A, 0))\n      a = Point(0, C / B), b = Point(1, C / B);\n    else if (eq(B, 0))\n      b = Point(C / A, 0), b = Point(C / A, 1);\n    else\n      a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p)\n  {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a)\n  {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line\n{\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle\n{\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector<Point>;\nusing Polygon = vector<Point>;\nusing Segments = vector<Segment>;\nusing Lines = vector<Line>;\nusing Circles = vector<Circle>;\n\nReal cross(const Point &a, const Point &b)\n{\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b)\n{\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\n// 点の回転方向\nint ccw(const Point &a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS)\n    return +1; // \"COUNTER_CLOCKWISE\"\n  if (cross(b, c) < -EPS)\n    return -1; // \"CLOCKWISE\"\n  if (dot(b, c) < 0)\n    return +2; // \"ONLINE_BACK\"\n  if (norm(b) < norm(c))\n    return -2; // \"ONLINE_FRONT\"\n  return 0;    // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 平行判定\nbool parallel(const Line &a, const Line &b)\n{\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\n// 垂直判定\nbool orthogonal(const Line &a, const Line &b)\n{\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\n// 射影\n// 直線 l に p から垂線を引いた交点を求める\nPoint projection(const Line &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p)\n{\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\n// 反射\n// 直線 l を対称軸として点 p  と線対称にある点を求める\nPoint reflection(const Line &l, const Point &p)\n{\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p)\n{\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m)\n{\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p)\n{\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s)\n{\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l)\n{\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p)\n{\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t)\n{\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l)\n{\n  if (norm(projection(l, c.p) - c.p) - c.r * c.r > EPS)\n    return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if (d1 < c.r + EPS && d2 < c.r + EPS)\n    return 0;\n  if (d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS)\n    return 1;\n  const Point h = projection(l, c.p);\n  if (dot(l.a - h, l.b - h) < 0)\n    return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2)\n{\n  if (c1.r < c2.r)\n    swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if (c1.r + c2.r < d)\n    return 4;\n  if (eq(c1.r + c2.r, d))\n    return 3;\n  if (c1.r - c2.r < d)\n    return 2;\n  if (eq(c1.r - c2.r, d))\n    return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b)\n{\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p)\n{\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m)\n{\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p)\n{\n  Point r = projection(s, p);\n  if (intersect(s, r))\n    return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b)\n{\n  if (intersect(a, b))\n    return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s)\n{\n  if (intersect(l, s))\n    return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m)\n{\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if (eq(abs(A), 0.0) && eq(abs(B), 0.0))\n    return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m)\n{\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair<Point, Point> crosspoint(const Circle &c, const Line l)\n{\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if (eq(distance(l, c.p), c.r))\n    return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair<Point, Point> crosspoint(const Circle &c, const Segment &l)\n{\n  Line aa = Line(l.a, l.b);\n  if (intersect(c, l) == 2)\n    return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if (dot(l.a - ret.first, l.b - ret.first) < 0)\n    ret.second = ret.first;\n  else\n    ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair<Point, Point> crosspoint(const Circle &c1, const Circle &c2)\n{\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\nvoid solve()\n{\n  Point a, b;\n  cin >> a >> b;\n  Segment ab(a, b);\n  int n;\n  cin >> n;\n  vector<pair<double, int>> v;\n  rep(i, n)\n  {\n    Point p, q;\n    cin >> p >> q;\n    Segment sg(p, q);\n    int o, l;\n    cin >> o >> l;\n    if (intersect(ab, sg))\n    {\n      Point crs = crosspoint(ab, sg);\n      v.push_back({distance(a, crs), o ^ l});\n    }\n  }\n\n  sort(all(v));\n  \n  int cnt = 0;\n  rep(i, (int)v.size() - 1)\n  {\n    if (v[i + 1].second != v[i].second)\n      cnt++;\n  }\n  cout << cnt << \"\\n\";\n}\n\nint main()\n{\n  init_main();\n\n  int testcase;\n  cin >> testcase;\n  rep(ti, testcase)\n  {\n    solve();\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef complex<double> P;\ndouble det(const P &a,const P &b){\n\treturn (conj(b)*a).imag();\n}\ndouble ratio(P s1,P d1,P s2,P d2){\n\treturn det(s2-s1,d2)/det(d1,d2);\n}\nint main(){\n\tint c; cin>>c;\n\twhile(c--){\n\t\tint n,xa,ya,xb,yb,o,l; cin>>xa>>ya>>xb>>yb>>n;\n\t\tP a(xa,ya),b(xb,yb);\n\t\tvector<pair<double,int> > cross;\n\t\trep(i,n){\n\t\t\tcin>>xa>>ya>>xb>>yb>>o>>l;\n\t\t\tP c(xa,ya),d(xb,yb);\n\t\t\tdouble s=ratio(a,b-a,c,d-c),t=ratio(c,d-c,a,b-a);\n\t\t\tif(0<s&&s<1&&0<t&&t<1)cross.push_back(make_pair(s,o^l));\n\t\t}\n\t\tsort(cross.begin(),cross.end());\n\t\tint ans=0;n=cross.size();\n\t\tif(n>1)rep(i,n-1)if(cross[i].second!=cross[i+1].second)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\n\nstruct point\n{\n\tdouble x, y;\n\tpoint(double x = 0, double y = 0) :x(x), y(y) {};\n\n\tpoint operator + (point p) { return point(x + p.x, y + p.y); }\n\tpoint operator - (point p) { return point(x - p.x, y - p.y); }\n\tpoint operator * (double s) { return point(x * s, y * s); }\n\tpoint operator / (double s) { return point(x / s, y / s); }\n\n\tdouble norm() { return x*x + y*y; }\n\tdouble abs() { return sqrt(norm()); }\n\n\tbool operator < (const point &p) const\n\t{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const point &p) const\n\t{\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\n};\ntypedef vector<point> polygon;\n\ndouble dot(point a, point b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\n\ndouble cross(point a, point b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\n\nint ccw(point a, point b, point c)\n{\n\tb = b - a; c = c - a;\n\tif (cross(b, c) > EPS) return 1;\n\tif (cross(b, c) < -EPS) return -1;\n\tif (dot(b, c) < 0) return 2;\n\tif (b.norm() < c.norm()) return -2;\n\treturn 0;\n}\n\nstruct line\n{\n\tpoint a, b;\n\tline(double x1 = 0, double y1 = 0, double x2 = 0, double y2 = 0) :a(point(x1, y1)), b(point(x2, y2)) {};\n\n\tpoint univec() { return (b - a) / (b - a).norm(); }\n};\n\npoint cross_point(line s1, line s2)\n{\n\tpoint sv = s1.b - s1.a;\n\tpoint tv = s2.b - s2.a;\n\treturn s1.a + sv*cross(tv, s2.a - s1.a) / cross(tv, sv);\n}\nbool isis_ss(line s, line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\twhile (n--)\n\t{\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tline sin(xa, ya, xb, yb);\n\t\tint k;\n\t\tcin >> k;\n\t\tvector<pair<double, int>> v;\n\t\tREP(i, k)\n\t\t{\n\t\t\tdouble xs, ys, xt, yt; int o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tline den(xs, ys, xt, yt);\n\t\t\tif (isis_ss(sin, den))\n\t\t\t{\n\t\t\t\tpoint cp = cross_point(sin, den);\n\t\t\t\tv.push_back(make_pair((cp - point(xa, ya)).norm(), o^l));\n\t\t\t}\n\t\t}\n\t\tsort(ALL(v));\n\t\tint cnt = 0;\n\t\tif (v.size() == 0) goto end;\n\t\tint tmp = v[0].second;\n\t\tREP(i, v.size())\n\t\t{\n\t\t\tif (v[i].second != tmp)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\ttmp = v[i].second;\n\t\t\t}\n\t\t}\n\tend:;\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            //cout << a << ' ' << b << endl;\n            if(not a) b = (b ? 0 : 1);\n            place[i] = b;\n            //cout << a << ' ' << b << endl;\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n){\n            if(isIntersectedL(rail, old[i])){\n                    v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n            }\n        }\n        sort(all(v));\n        rep(i,v.size()){\n            //show(v[i].first)\n            if(s.empty()) s.emplace_back(v[i].second);\n            if(s.back() == v[i].second) continue;\n            s.emplace_back(v[i].second);\n        }\n        int cnt = 0;\n        rep(i,v.size() - 1){\n            if(v[i].second != v[i + 1].second) cnt++;\n        }\n        //rep(i,s.size() - 1) assert(s[i] != s[i + 1]);\n\n        cout << cnt << endl;\n        //cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nconst double EPS = 1e-10;\n\n// ツ点\ntypedef complex<double> P;\n\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b)-EPS : imag(a) < imag(b)-EPS;\n  }\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){}\n};\n\nP line_cross(const L& l, const L& m) {\n  double num = cross(m[1]-m[0], m[0]-l[0]);\n  double denom = cross(m[1]-m[0], l[1]-l[0]);\n  return P(l[0] + (l[1]-l[0])*num/denom);\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\ntypedef pair<double, int> pdi;\nint main() {\n  int N;\n  cin >> N;\n  while(N--) {\n    int ax,ay,bx,by;\n    L nw;\n    cin >> ax>>ay>>bx>>by;\n    nw = L(P(ax,ay),P(bx,by));\n    int n;\n    cin >> n;\n    vector<pdi> v;\n    REP(i,n) {\n      int x1,y1,x2,y2;\n      cin >> x1>>y1>>x2>>y2;\n      L l = L(P(x1,y1),P(x2,y2));\n      bool o, s;\n      cin >> o>> s;\n\n      if (intersectSS(nw, l)) {\n        v.push_back(pdi(abs(line_cross(nw,l)-P(ax,ay)), (!o)^s));\n      }\n    }\n    sort(ALL(v));\n    int res = 0;\n    REP(i, v.size()-1) {\n//      cout << v[i].first << endl;\n      if (v[i].second^v[i+1].second) res++;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#define llint long long\n#define eps 1e-9\n\nusing namespace std;\ntypedef pair<double, llint> P;\ntypedef pair<P, P> S;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a)+fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n};\n\nbool isOnS(vec2d p, vec2d q, vec2d x)\n{\t\n\treturn (p-x).cross(q-x) == 0 && (p-x).dot(q-x) <= 0;\n}\nbool isCrossSS(vec2d p, vec2d q, vec2d r, vec2d s, double &t)\n{\n\tif((q-p).cross(s-r) == 0){\n\t\treturn isOnS(p, q, r) || isOnS(p, q, s) || isOnS(r, s, p) || isOnS(r, s, q);\n\t}\n\tt = (r-p).cross(s-r) / (q-p).cross(s-r);\n\tvec2d x = p + (q-p)*t;\n\treturn isOnS(p, q, x) && isOnS(r, s, x);\n}\n\nllint T;\nllint n;\nvec2d s, t;\nllint l[105], o[105];\nvec2d p[105], q[105];\nvector<pair<double, llint> > vec;\n\nint main(void)\n{\n\tcin >> T;\n\tfor(int z = 0; z < T; z++){\n\t\tcin >> s.x >> s.y >> t.x >> t.y;\n\t\tcin >> n;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> p[i].x >> p[i].y >> q[i].x >> q[i].y >> o[i] >> l[i];\n\t\t\tif(o[i] == 0) l[i] = 1 - l[i];\n\t\t}\n\t\t\n\t\tvec.clear();\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tdouble a;\n\t\t\tif(isCrossSS(s, t, p[i], q[i], a)) vec.push_back(P(a, l[i]));\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\t///for(int i = 0; i < vec.size(); i++) cout << vec[i].first << \" \" << vec[i].second << endl;\n\t\t\n\t\tllint ans = 0;\n\t\tfor(int i = 1; i < vec.size(); i++){\n\t\t\tif(vec[i].second != vec[i-1].second) ans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> C;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct Point {\n  C p;\n  int my, up;\n};\n\nbool operator<(const Point &a, const Point &b) {\n  return a.p.real() < b.p.real();\n}\n\ndouble cross(const C &a, const C &b) {\n  return imag(conj(a) * b);\n}\n\nvoid intersectSS(C p1, C p2, C q1, C q2, vector<Point> &v, int my, int up) {\n  if (cross(p2 - p1, q1 - p1) * cross(p2 - p1, q2 - p1) < 1e-9 && cross(q2 - q1, p1 - q1) * cross(q2 - q1, p2 - q1) < 1e-9) {\n    C q = q2 - q1;\n    double d1 = abs(cross(q, p1 - q1));\n    double d2 = abs(cross(q, p2 - q1));\n    double t = d1 / (d1 + d2);\n\n    v.pb((Point{p1 + (p2 - p1) * t, my, up}));\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int t;\n  cin >> t;\n  rep(ii, t) {\n    int x1, y1, x2, y2, o, l, n;\n    cin >> x1 >> y1 >> x2 >> y2;\n    C s = C(x1, y1), e = C(x2, y2);\n\n    cin >> n;\n    vector<Point> point;\n    rep(i, n) {\n      cin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n      intersectSS(s, e, C(x1, y1), C(x2, y2), point, o, l);\n    }\n\n    sort(all(point));\n    P p[2] = {P(1, 0), P(0, 0)};\n    rep(i, 2) {\n      rep(j, point.size()) {\n        if (point[j].my) {\n          if (p[i].fi != point[j].up) {\n            p[i].fi = point[j].up;\n            p[i].se++;\n          }\n        } else {\n          if (p[i].fi == point[j].up) {\n            p[i].fi = (p[i].fi + 1) % 2;\n            p[i].se++;\n          }\n        }\n      }\n    }\n\n    cout << min(p[0].se, p[1].se) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON_\nusing namespace std;\n#include <algorithm>/*{{{*/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((ll)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#endif\n/*}}}*/\n\ndouble cross(P a, P b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn a1 + (a2-a1) * t;\n}\n\nstruct interpoint {\n\tbool mine;\n\tbool overground;\n\tdouble dist;\n\tOPOVER(<, interpoint) {\n\t\treturn dist < t.dist;\n\t}\n};\nvector<interpoint> interpoints;\n\nint main(int argc, char const* argv[])\n{\n\tint N;\n\tcin >> N;\n\tREP (ii, N) {\n\t\tinterpoints.clear();\n\n\t\tint xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint n;\n\t\tcin >> n;\n\n\t\tP a = P(xa, ya);\n\t\tP b = P(xb, yb);\n\n\t\tREP (i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s = P(xs, ys);\n\t\t\tP t = P(xt, yt);\n\t\t\tif (is_intersected_ls(a, b, s, t)) {\n\t\t\t\tP _ip = intersection_ls(a, b, s, t);\n\t\t\t\tinterpoint ip = { o, l, abs(a - _ip) };\n\t\t\t\tinterpoints.PB(ip);\n\t\t\t\tdprt(\"intersects at (%lf, %lf)\\n\", _ip.real(), _ip.imag());\n\t\t\t}\n\t\t}\n\t\tSORT(interpoints);\n\n\t\tif (interpoints.size() <= 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tinterpoint ip = interpoints[0];\n\t\tbool cur_over = (!(ip.mine | ip.overground)) | (ip.mine & ip.overground);\n\t\tdprt(\"start: cur_over = %d\\n\", cur_over);\n\t\tint ans = 0;\n\t\tFOR (i, 1, interpoints.size()) {\n\t\t\tinterpoint ip = interpoints[i];\n\t\t\tdprt(\"interpoint #%d, cur_over: %d, points: (mine, over) = (%d, %d)\\n\", i, cur_over, ip.mine, ip.overground);\n\t\t\tif (cur_over != (!(ip.mine | ip.overground))| (ip.mine & ip.overground) ) {\n\t\t\t\t++ans;\n\t\t\t\tcur_over = !cur_over;\n\t\t\t\tdprt(\"\\tchange state: cur_over = %d\\n\", cur_over);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <cassert>\n#include <tuple>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-10;\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n    int o, l;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nint main() {\n    int m;\n    cin >> m;\n    for(int i=0; i<m; ++i) {\n        ld xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        segment shin(point(xa, ya), point(xb, yb));\n        int n;\n        cin >> n;\n        vector<segment> v;\n        for(int j=0; j<n; ++j) {\n            ld xs, ys, xt, yt;\n            int o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            segment ss(point(xs, ys), point(xt, yt));\n            ss.o = o; ss.l = l;\n            if(dist_ss(shin, ss) == 0) {\n                v.push_back(ss);\n            }\n        }\n        vector<tuple<point, int, int>> points(v.size());\n        for(int i=0; i<v.size(); ++i) {\n            line l1(shin.a, shin.b), l2(v[i].a, v[i].b);\n            point p = is_ll(l1, l2);\n            points[i] = make_tuple(p, v[i].o, v[i].l);\n        }\n        sort(points.begin(), points.end(), [p = shin.a](auto const& t1, auto const& t2) {\n            point p1 = get<0>(t1), p2 = get<0>(t2);\n            return abs(p - p1) < abs(p - p2);\n        });\n        int cnt = 0;\n        int now = 0;\n        if(points.size() != 0) {\n            if(get<1>(points[0]) == 1) {\n                now = get<2>(points[0]);\n            } else {\n                now = (get<2>(points[0])+1)%2;\n            }\n        }\n        for(int j=1; j<points.size(); ++j) {\n            if(get<1>(points[j]) == 1 && get<2>(points[j]) != now) {\n                cnt++;\n                now = get<2>(points[j]);\n            } else if(get<1>(points[j]) == 0 && get<2>(points[j]) == now) {\n                cnt++;\n                now = (get<2>(points[j])+1)%2;\n            }\n        }\n        cout << cnt << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//XY座標\n#define X real()\n#define Y imag()\n\n// 許容する誤差ε\nconst double EPS = (1e-10);\n// 円周率\nconst double PI = 3.14159265358979;\n\nconst int INF = 1e+8;\n\n// 点の表現\ntypedef complex<double> P;\n\n// complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// 2乗する\ndouble sq(double x){\n\treturn x * x;\n}\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n// 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b){\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a){\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a){\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a){\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2 直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n\treturn equal( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点 c が直線 a, b 上にあるかどうか \nint is_point_on_line(P a, P b, P c) {\n\treturn equal( cross(b-a, c-a), 0.0 );\n}\n\n// 下記は (1) より (2) のほうが簡潔で良い.\n\n// 点 c が線分 a, b 上にあるかどうか (1)\nint is_point_on_line_1(P a, P b, P c) {\n  return equal( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点 c が線分 a, b 上にあるかないか(2)\nint is_point_on_line_2(P a, P b, P c) {\n\t// |a-c| + |c-b| <= |a-b| なら線分上\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点 a, bを通る直線と点 c との距離\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点 a, b を端点とする線分と点 c との距離\ndouble distance_ls_p(P a, P b, P c) {\n\tif( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\t\n\treturn a1 + (a2-a1) * t;\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n\treturn !equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n\tP a = a2 - a1; P b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nstruct Rail{\n\tP p1, p2;\n\tint o, l;\n\tRail(P p1_, P p2_, int o_, int l_){\n\t\tp1 = p1_; p2 = p2_; o = o_; l = l_;\n\t}\n};\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i_=0 ; i_ < N ; i_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa,ya), B(xb,yb);\n\t\t\n\t\tcin >> n;\n\t\tvector<Rail> vr;\n\t\tfor(int j_=0 ; j_ < n ; j_++ ){\n\t\t\tint sx,sy,tx,ty,o,l;\n\t\t\tcin >> sx >> sy >> tx >> ty >> o >> l;\n\t\t\tvr.push_back( Rail( P(sx,sy) , P(tx,ty) , o , l ) );\n\t\t}\n\t\t\n\t\t// 交点計算\n\t\tvector< pair<P,pair<int,int> > > vp;\n\t\tfor(int i=0 ; i < vr.size() ; i++ ){\n\t\t\t// 交差するかどうか\n\t\t\tif( is_intersected_ls( A , B , vr[i].p1 , vr[i].p2 ) ){\n\t\t\t\tP p = intersection_l( A , B , vr[i].p1 , vr[i].p2 );\n\t\t\t\tpair<int,int> p2( vr[i].o , vr[i].l );\n\t\t\t\tvp.push_back( pair<P,pair<int,int> >( p , p2 ) );\n\t\t\t}\n\t\t}\n\t\tsort( vp.begin() , vp.end() );\n\t\t\n\t\tint ans = INF;\n\t\t// d=0 のとき地下, d=1 のとき高架\n\t\t{\n\t\t\tint d=0;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\tint o = vp[i].second.first;\n\t\t\t\tint l = vp[i].second.second;\n\t\t\t\t\n\t\t\t\t// o = 0 のとき他社\n\t\t\t\tif( o == 0 ){\n\t\t\t\t\tif( l == d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( l != d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"(\" << vp[i].first.X << \",\" << vp[i].second.Y << \")\" << endl;\n\t\t\t}\n\t\t\tans = min( ans , cnt );\n\t\t}\n\t\t{\n\t\t\tint d=1;\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t\t\tint o = vp[i].second.first;\n\t\t\t\tint l = vp[i].second.second;\n\t\t\t\t\n\t\t\t\t// o = 0 のとき他社\n\t\t\t\tif( o == 0 ){\n\t\t\t\t\tif( l == d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif( l != d ){\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\td = (d == 0)? 1 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//cout << \"(\" << vp[i].first.X << \",\" << vp[i].second.Y << \")\" << endl;\n\t\t\t}\n\t\t\tans = min( ans , cnt );\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// This code is from http://dai1741.github.io/maximum-algo-2012/cpp/geometry/geometries2d.h\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <math.h>\n#include <complex>\n\n#include <iomanip>\n#include <set>\n#include <queue>\n#include <string>\n\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n// 主に以下の資料を参考に作成した。\n// - http://www.prefield.com/algorithm\n// - http://www.deqnotes.net/acmicpc/2d_geometry/\n// - https://github.com/infnty/acm/tree/master/lib/geometry\n// - サークルの先輩が作ったライブラリ\n\n/* 基本要素 */\n\ntypedef double D;      // 座標値の型。doubleかlong doubleを想定\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // 許容誤差。問題によって変える\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積　cross(a,b) = |a||b|sinθ\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n\n// 点の進行方向\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n/* 交差判定　直線・線分は縮退してはならない。接する場合は交差するとみなす。isecはintersectの略 */\n\n// 直線と点\nbool isecLP(P a1, P a2, P b) {\n  return abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); と等価\n}\n\n// 直線と直線\nbool isecLL(P a1, P a2, P b1, P b2) {\n  return !isecLP(a2-a1, b2-b1, 0) || isecLP(a1, b1, b2);\n}\n\n// 直線と線分\nbool isecLS(P a1, P a2, P b1, P b2) {\n  return cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS;\n}\n\n// 線分と線分\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\n\n\n/* 距離　各直線・線分は縮退してはならない */\n\n// 点pの直線aへの射影点を返す\nP proj(P a1, P a2, P p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nP reflection(P a1, P a2, P p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\nD distLP(P a1, P a2, P p) {\n  return abs(proj(a1, a2, p) - p);\n}\n\nD distLL(P a1, P a2, P b1, P b2) {\n  return isecLL(a1, a2, b1, b2) ? 0 : distLP(a1, a2, b1);\n}\n\nD distLS(P a1, P a2, P b1, P b2) {\n  return isecLS(a1, a2, b1, b2) ? 0 : min(distLP(a1, a2, b1), distLP(a1, a2, b2));\n}\n\nD distSP(P a1, P a2, P p) {\n  P r = proj(a1, a2, p);\n  if (isecSP(a1, a2, r)) return abs(r-p);\n  return min(abs(a1-p), abs(a2-p));\n}\n\nD distSS(P a1, P a2, P b1, P b2) {\n  if (isecSS(a1, a2, b1, b2)) return 0;\n  return min(min(distSP(a1, a2, b1), distSP(a1, a2, b2)),\n             min(distSP(b1, b2, a1), distSP(b1, b2, a2)));\n}\n\n// 2直線の交点\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  if (EQ(d2, 0)) throw \"kouten ga nai\";   // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n\n/* 円 */\n\n// Line and Circle\nD distLC(P a1, P a2, P c, D r) {\n  return max(distLP(a1, a2, c) - r, 0.0);\n}\n\n// Segment and Circle\nD distSC(P a1, P a2, P c, D r) {\n  D dSqr1 = norm(c-a1), dSqr2 = norm(c-a2);\n  if (dSqr1 < r*r ^ dSqr2 < r*r) return 0;  // 円が線分を包含するとき距離0ならここをORに変える\n  if (dSqr1 < r*r & dSqr2 < r*r) return r - sqrt(max(dSqr1, dSqr2));\n  return max(distSP(a1, a2, c) - r, 0.0);\n}\n\n// VP = vector<P>\nVP crosspointLC(P a1, P a2, P c, D r) {\n  VP ps;\n  P ft = proj(a1, a2, c);\n  if (!GE(r*r, norm(ft-c))) return ps;\n\n  P dir = sqrt(max(r*r - norm(ft-c), 0.0)) / abs(a2-a1) * (a2-a1);\n  ps.push_back(ft + dir);\n  if (!EQ(r*r, norm(ft-c))) ps.push_back(ft - dir);\n  return ps;\n}\n\nD distCC(P a, D ar, P b, D br) {\n  D d = abs(a-b);\n  return GE(d, abs(ar-br)) ? max(d-ar-br, 0.0) : abs(ar-br) - d;\n}\n\n// 2円の交点\nVP crosspointCC(P a, D ar, P b, D br) {\n  VP ps;\n  P ab = b-a;\n  D d = abs(ab);\n  D crL = (norm(ab) + ar*ar - br*br) / (2*d);\n  if (EQ(d, 0) || ar < abs(crL)) return ps;\n\n  P abN = ab * P(0, sqrt(ar*ar - crL*crL) / d);\n  P cp = a + crL/d * ab;\n  ps.push_back(cp + abN);\n  if (!EQ(norm(abN), 0)) ps.push_back(cp - abN);\n  return ps;\n}\n\n// 点pから円aへの接線の接点\nVP tangentPoints(P a, D ar, P p) {\n  VP ps;\n  D sin = ar / abs(p-a);\n  if (!LE(sin, 1)) return ps;  // ここでNaNも弾かれる\n  D t = M_PI_2 - asin(min(sin, 1.0));\n  ps.push_back(                 a + (p-a)*polar(sin, t));\n  if (!EQ(sin, 1)) ps.push_back(a + (p-a)*polar(sin, -t));\n  return ps;\n}\n\n// 2円の共通接線。返される各直線に含まれる頂点は円との接点となる\nvector<L> tangentLines(P a, D ar, P b, D br) {\n  vector<L> ls;\n  D d = abs(b-a);\n  rep (i,2) {\n    D sin = (ar - (1-i*2)*br) / d;\n    if (!LE(sin*sin, 1)) break;\n    D cos = sqrt(max(1 - sin*sin, 0.0));\n    rep (j,2) {\n      P n = (b-a) * P(sin, (1-j*2)*cos) / d;\n      ls.push_back(L(a + ar*n, b + (1-i*2)*br*n));\n      if (cos < EPS) break;  // 重複する接線を無視（重複していいならこの行不要）\n    }\n  }\n  return ls;\n}\n\n// 三角形の外心。点a,b,cは同一線上にあってはならない\nP circumcenter(P a, P b, P c) {\n  a = (a-c)*0.5;\n  b = (b-c)*0.5;\n  return c + crosspointLL(a, a*P(1,1), b, b*P(1,1));\n}\n\n// 点aと点bを通り、半径がrの円の中心を返す\nVP circlesPointsRadius(P a, P b, D r) {\n  VP cs;\n  P abH = (b-a)*0.5;\n  D d = abs(abH);\n  if (d == 0 || d > r) return cs;  // 必要なら !LE(d,r) として円1つになる側へ丸める\n  D dN = sqrt(r*r - d*d);          // 必要なら max(r*r - d*d, 0) とする\n  P n = abH * P(0,1) * (dN / d);\n  cs.push_back(a + abH + n);\n  if (dN > 0) cs.push_back(a + abH - n);\n  return cs;\n}\n\n// 点aと点bを通り、直線lに接する円の中心\nVP circlesPointsTangent(P a, P b, P l1, P l2) {\n  P n = (l2-l1) * P(0,1);\n  P m = (b-a) * P(0,0.5);\n  D rC = dot((a+b)*0.5-l1, n);\n  D qa = norm(n)*norm(m) - dot(n,m)*dot(n,m);\n  D qb = -rC * dot(n,m);\n  D qc = norm(n)*norm(m) - rC*rC;\n  D qd = qb*qb - qa*qc;  // qa*k^2 + 2*qb*k + qc = 0\n\n  VP cs;\n  if (qd < -EPS) return cs;\n  if (EQ(qa, 0)) {\n    if (!EQ(qb, 0)) cs.push_back((a+b)*0.5 - m * (qc/qb/2));\n    return cs;\n  }\n  D t = -qb/qa;\n  cs.push_back(              (a+b)*0.5 + m * (t + sqrt(max(qd, 0.0))/qa));\n  if (qd > EPS) cs.push_back((a+b)*0.5 + m * (t - sqrt(max(qd, 0.0))/qa));\n  return cs;\n}\n\n// 点集合を含む最小の円の中心\nP minEnclosingCircle(const VP& ps) {\n  P c;\n  double move = 0.5;\n  rep(i,39) {  // 2^(-39-1) \\approx 0.9e-12\n    rep(t,50) {\n      D max = 0;\n      int k = 0;\n      rep (j, ps.size()) if (max < norm(ps[j]-c)) {\n        max = norm(ps[j]-c);\n        k = j;\n      }\n      c += (ps[k]-c) * move;\n    }\n    move /= 2;\n  }\n  return c;\n}\n\n\n/* 多角形 */\n\n// 頂点の順序（sortやmax_elementに必要）\nnamespace std {\n  bool operator<(const P a, const P b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n// 凸包\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n// 凸判定。縮退を認めないならccwの判定部分を != 1 とする\nbool isCcwConvex(const VP& ps) {\n  int n = ps.size();\n  rep (i, n) if (ccw(ps[i], ps[(i+1) % n], ps[(i+2) % n]) == -1) return false;\n  return true;\n}\n\n// 凸多角形の内部判定　O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inConvex(P p, const VP& ps) {\n  int n = ps.size();\n  int dir = ccw(ps[0], ps[1], p);\n  rep (i, n) {\n    int ccwc = ccw(ps[i], ps[(i + 1) % n], p);\n    if (!ccwc) return 2;  // 線分上に存在\n    if (ccwc != dir) return 0;\n  }\n  return 1;\n}\n\n// 凸多角形の内部判定　O(logn)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inCcwConvex(const VP& ps, P p) {\n  int n = ps.size();\n  P g = (ps[0] + ps[n / 3] + ps[n*2 / 3]) / 3.0;\n  if (g == p) return 1;\n  P gp = p - g;\n\n  int l = 0, r = n;\n  while (l + 1 < r) {\n    int mid = (l + r) / 2;\n    P gl = ps[l] - g;\n    P gm = ps[mid] - g;\n    if (cross(gl, gm) > 0) {\n      if (cross(gl, gp) >= 0 && cross(gm, gp) <= 0) r = mid;\n      else l = mid;\n    }\n    else {\n      if (cross(gl, gp) <= 0 && cross(gm, gp) >= 0) l = mid;\n      else r = mid;\n    }\n  }\n  r %= n;\n  D cr = cross(ps[l] - p, ps[r] - p);\n  return EQ(cr, 0) ? 2 : cr < 0 ? 0 : 1;\n}\n\n// 多角形の内部判定\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i, n) {\n    P a = ps[i] - p;\n    P b = ps[(i + 1) % n] - p;\n    if (EQ(cross(a,b), 0) && LE(dot(a,b), 0)) return 2;\n    if (a.Y > b.Y) swap(a,b);\n    if ((a.Y*b.Y < 0 || (a.Y*b.Y < EPS && b.Y > EPS)) && LE(cross(a, b), 0)) in = !in;\n  }\n  return in;\n}\n\n// 凸多角形クリッピング\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\n// 凸多角形の直径（最遠点対）\npair<int, int> convexDiameter(const VP& ps) {\n  int n = ps.size();\n  int i = min_element(ps.begin(), ps.end()) - ps.begin();\n  int j = max_element(ps.begin(), ps.end()) - ps.begin();\n  int maxI, maxJ;\n  D maxD = 0;\n  rep(_, 2*n) {\n    if (maxD < norm(ps[i]-ps[j])) {\n      maxD = norm(ps[i]-ps[j]);\n      maxI = i;\n      maxJ = j;\n    }\n    if (cross(ps[i]-ps[(i+1) % n], ps[(j+1) % n]-ps[j]) <= 0) j = (j+1) % n;\n    else                                                      i = (i+1) % n;\n  }\n  return make_pair(maxI, maxJ);\n}\n\n// 多角形の符号付面積\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\n\n// 多角形の幾何学的重心\nP centroid(const VP& ps) {\n  int n = ps.size();\n  D aSum = 0;\n  P c;\n  rep (i, n) {\n    D a = cross(ps[i], ps[(i+1) % n]);\n    aSum += a;\n    c += (ps[i] + ps[(i+1) % n]) * a;\n  }\n  return 1 / aSum / 3 * c;\n}\n\n// ボロノイ領域\nVP voronoiCell(P p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (EQ(norm(ps[i]-p), 0)) continue;\n    P h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );\n  }\n  return cl;\n}\n\n/* 幾何グラフ */\n\nstruct Edge {\n  int from, to;\n  D cost;\n  Edge(int from, int to, D cost) : from(from), to(to), cost(cost) {}\n};\nstruct Graph {\n  int n;\n  vector<vector<Edge> > edges;\n  Graph(int n) : n(n), edges(n) {}\n  void addEdge(Edge e) {\n    edges[e.from].push_back(e);\n    edges[e.to].push_back(Edge(e.to, e.from, e.cost));\n  }\n};\n\n// 線分アレンジメント（線分の位置関係からグラフを作成）\nGraph segmentArrangement(const vector<L>& segs, VP& ps) {\n  int n = segs.size();\n  rep (i, n) {\n    ps.push_back(segs[i].first);\n    ps.push_back(segs[i].second);\n    rep (j, i) {\n      if (isecSS(                 segs[i].first, segs[i].second, segs[j].first, segs[j].second))\n        ps.push_back(crosspointLL(segs[i].first, segs[i].second, segs[j].first, segs[j].second));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n  int m = ps.size();\n  Graph gr(m);\n  vector<pair<D, int> > list;\n  rep (i, n) {\n    list.clear();\n    rep (j, m) {\n      if (isecSP(segs[i].first, segs[i].second, ps[j]))\n        list.push_back(make_pair(norm(segs[i].first-ps[j]), j));\n    }\n    sort(list.begin(), list.end());\n    rep (j, list.size() - 1) {\n      int a = list[j  ].second;\n      int b = list[j+1].second;\n      gr.addEdge(Edge(a, b, abs(ps[a]-ps[b])));\n    }\n  }\n  return gr;\n}\n\n// 可視グラフ（点集合から見える位置へ辺を張ったグラフ）\nGraph visibilityGraph(const VP& ps, const vector<VP>& objs) {\n  int n = ps.size();\n  Graph gr(n);\n  rep (i,n) rep (j,i) {\n    P a = ps[i], b = ps[j];\n    if (!EQ(norm(a-b), 0)) rep (k, objs.size()) {\n      const VP& obj = objs[k];\n      int inStA = inConvex(a, obj);\n      int inStB = inConvex(b, obj);\n      if ((inStA ^ inStB) % 2 || inStA * inStB != 1 && inConvex((a+b)*0.5, obj) == 1) goto skip;\n      rep (l, obj.size()) {\n        P cur = obj[l];\n        P next = obj[(l + 1) % obj.size()];\n        if (isecSS(a, b, cur, next) && !isecSP(cur, next, a) && !isecSP(cur, next, b)) goto skip;\n      }\n    }\n    gr.addEdge( Edge(i, j, abs(a-b)) );\n    skip: {}\n  }\n  return gr;\n}\n\n\n/* その他 */\n\n// 重複する線分を併合する\nvector<L> mergeSegments(vector<L> segs) {\n  int n = segs.size();\n  rep (i,n) if (segs[i].second < segs[i].first) swap(segs[i].second, segs[i].first);\n\n  rep (i,n) rep (j,i) {\n    L &l1 = segs[i], &l2 = segs[j];\n    if (EQ(cross(l1.second-l1.first, l2.second-l2.first), 0)\n        && isecLP(l1.first, l1.second, l2.first)\n        && ccw   (l1.first, l1.second, l2.second) != 2\n        && ccw   (l2.first, l2.second, l1.second) != 2) {\n      segs[j] = L(min(l1.first, l2.first), max(l1.second, l2.second));\n      segs[i--] = segs[--n];\n      break;\n    }\n  }\n  segs.resize(n);\n  return segs;\n}\n\n\n// この辺にコードを載せるほどでもないが重要な定理とか図とか書いておくとよい気がします\n\n// 余弦定理\n// △ABC において、a = BC, b = CA, c = AB としたとき\n// a^2 = b^2 + c^2 ? 2bc cos ∠CAB\n\n// ヘロンの公式\n// 3辺の長さがa,b,cである三角形の面積T\n// T = sqrt{ s(s-a)(s-b)(s-c) }, s = (a+b+c)/2\n\n// ピックの定理\n// 多角形の頂点が全て格子点上にあり、内部に穴がないとき\n// S = i + b/2 - 1 (S:多角形の面積, i: 多角形の内部にある格子点の数, b: 辺上の格子点の数)\n\nint main()\n{\n\tint datasets;\n\tcin >> datasets;\n\tfor(int dataset=0;dataset<datasets;dataset++)\n\t{\n\t\tint xa,ya,xb,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP s=P(xa,ya);\n\t\tP t=P(xb,yb);\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<pair<L,int>> lines(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint xs,ys,xt,yt,o,l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tlines[i]=pair<L,int>(L(P(xs,ys),P(xt,yt)),((o+l)%2));\n\t\t}\n\n\t\tsort(lines.begin(),lines.end());\n\n\t\tvector<pair<P,int>> crossp;\n\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(isecSS(s,t,lines[i].first.first,lines[i].first.second))\n\t\t\t{\n\t\t\t\tcrossp.push_back(pair<P,int>(crosspointLL(s,t,lines[i].first.first,lines[i].first.second),lines[i].second));\n\t\t\t}\n\t\t}\n\n\t\tsort(crossp.begin(),crossp.end());\n\t\t\n\t\tint now=-1;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<crossp.size();i++)\n\t\t{\n\t\t\tif(now==-1)\n\t\t\t{\n\t\t\t\tnow=crossp[i].second;\n\t\t\t}\n\t\t\telse if(now==crossp[i].second)\n\t\t\t{\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnow=crossp[i].second;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 0.000000001\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nclass Point {\npublic:\n  double x, y;\n  Point (double x = 0,double y = 0): x(x),y(y) {}\n  Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n  Point operator * (double a) { return Point(a*x,a*y); }\n  Point operator / (double a) { return Point(x/a,y/a); }\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x+y*y; }\n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point &p) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\nstruct Segment { \n  Point p1, p2;\n  int o,l;\n  bool operator<( const Segment& right ) const {\n    return p1 == right.p1 ? p2 < right.p2 : p1 < right.p1;\n  }\n};\ntypedef Segment Line;\n\nPoint MakePoint(int x,int y);\nSegment MakeSegment(Point x,Point y);\nint ccw(Point p1,Point p2,Point p3);\nbool intersect(Point p1,Point p2,Point p3,Point p4);\nbool intersect(Segment s1,Segment s2);\ndouble dot(Vector a,Vector b);\ndouble cross(Vector a,Vector b);\nPoint getCrossPoint(Segment s1,Segment s2);\n\nPoint MakePoint(int x,int y){\n  Point a;\n  a.x= x;\n  a.y= y;\n  return a;\n}\n\nLine MakeSegment(Point x,Point y){\n  Line a;\n  a.p1 = x;\n  a.p2 = y;\n  return a;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\n/* 反時計回り CCW */\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n\n  return ON_SEGMENT;\n}\n\n/* 線分p1,p2と線分p3,p4の交差判定 */\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return ( ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t   ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\nbool intersect(Segment s1,Segment s2) {\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\n/* ベクトルaとbの内積 */\ndouble dot(Vector a,Vector b){\n  return a.x*b.x + a.y*b.y;\n}\n\n/* ベクトルaとbの外積 */\ndouble cross(Vector a,Vector b){\n  return a.x*b.y - a.y*b.x;\n}\n\n/* 線分s1と線分s2の交点 */\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base = s2.p2-s2.p1;\n  double d1 = abs(cross(base,s1.p1 - s2.p1));\n  double d2 = abs(cross(base,s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nint main(){\n  int data;\n  cin >> data;\n  while(data--){\n    int xa,ya,xb,yb,n;\n    cin >> xa >> ya >> xb >> yb;\n    Point s,t;\n    s = MakePoint(xa,ya);\n    t = MakePoint(xb,yb);\n    Segment M = MakeSegment(s,t);\n    Segment seg[101];\n    cin >> n;\n    for(int i=0;i<n;i++){\n      Point a,b;\n      int o,l;\n      cin >> a.x >> a.y >> b.x >> b.y >> o >> l;\n      seg[i].p1 = a; seg[i].p2 = b; seg[i].o = o; seg[i].l = l;\n    }\n    sort(seg,seg+n);\n    int ans = 100000000;\n    for(int z=0;z<2;z++){\n      int now = z;\n      int cou = 0;\n      for(int i=0;i<n;i++){\n\tbool flag = intersect(M,seg[i]);\n\tif(flag){\n\t  if(seg[i].o == 1){\n\t    if(seg[i].l != now){\n\t      cou++;\n\t      now = seg[i].l;\n\t    }\n\t  }\n\t  else {\n\t    if(seg[i].l == now){\n\t      cou++;\n\t      if(now == 1) now = 0;\n\t      else now = 1;\n\t    }\n\t  }\n\t}\n      }\n      ans = min(ans,cou);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,int>dat[1000];\n//Y*(tx-sx)=(X-sx)*(ty-sy)+sy*(tx-sx)\n//Y*(bx-ax)=(X-ax)*(by-ay)+ay*(bx-ax)\n//X=ax\n//Y*(tx-sx)=(ax-sx)*(ty-sy)+sy*(tx-sx)\n//(bx-ax)*(X*(ty-sy)+sy*tx-sx*ty)=(tx-sx)*(X*(by-ay)+ay*bx-ax*by)\n//(bx-ax)*(ty-sy)*X+(bx-ax)*(sy*tx-sx*ty)=(tx-sx)*(by-ay)*X+(tx-sx)*(ay*bx-ax*by)\n//((bx-ax)*(ty-sy)-(tx-sx)*(by-ay))*X=(tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty)\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tlong long ax,ay,bx,by;\n\t\tscanf(\"%lld%lld%lld%lld\",&ax,&ay,&bx,&by);\n\t\tint c;\n\t\tif(ax>bx){\n\t\t\tlong long cx=ax;\n\t\t\tax=bx;\n\t\t\tbx=cx;\n\t\t\tlong long cy=ay;\n\t\t\tay=by;\n\t\t\tby=cy;\n\t\t}\n\t\tscanf(\"%d\",&c);\n\t\tint now=0;\n\t\tif(ax==bx){\n\t\t\tif(ay>by){\n\t\t\t\tlong long cy=ay;\n\t\t\t\tay=by;\n\t\t\t\tby=cy;\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tint sx,sy,tx,ty,type,z;\n\t\t\t\tscanf(\"%d%d%d%d%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n\t\t\t\ttype^=z;\n\t\t\t\tif(tx!=sx){\n\t\t\t\t\tdouble Y=(double)((ax-sx)*(ty-sy)+sy*(tx-sx))/(tx-sx);\n\t\t\t\t\tif((double)ay<Y&&Y<(double)by){\n\t\t\t\t\t\tdat[now++]=make_pair(Y,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tlong long sx,sy,tx,ty;\n\t\t\t\tint type,z;\n\t\t\t\tscanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n\t\t\t\ttype^=z;\n\t\t\t\tif((bx-ax)*(ty-sy)-(tx-sx)*(by-ay)!=0){\n\t\t\t\t\tdouble X=(double)((tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty))/((bx-ax)*(ty-sy)-(tx-sx)*(by-ay));\n\t\t\t\t\tif((double)ax<X&&X<(double)bx){\n\t\t\t\t\t\tdat[now++]=make_pair(X,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(dat,dat+now);\n\t\tint val=dat[0].second;\n\t\tint ret=0;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tif(dat[i].second!=val){\n\t\t\t\tret++;\n\t\t\t\tval=dat[i].second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\npair<double, double> getkouten(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)\n{\n    if(x1 - x2 == 0){\n        if(x3 - x4 == 0){\n            return make_pair(100000.0, 1000000.0);\n        } else {\n            return make_pair(x1, (y3 - y4) / (x3 - x4) * x1 + (y4 * x3 - x4 * y3) / (x3 - x4));\n        }\n    } else {\n        if(x3 - x4 == 0){\n            return make_pair(x3, (y1 - y2) / (x1 - x2) * x3 + (y2 * x1 - x2 * y1) / (x1 - x2));\n        } else {\n            if((x3 - x4) * (y1 - y2) - (x1 - x2) * (y3 - y4) == 0){\n                return make_pair(100000.0, 100000.0);\n            } else {\n                double x = (double)(((y4 * x3) - (x4 * y3)) * (x1 - x2) - ((y2 * x1) - (x2 * y1)) * (x3 - x4)) / ((x3 - x4) * (y1 - y2) - (x1 - x2) * (y3 - y4));\n                return make_pair(x, (y3 - y4) / (x3 - x4) * x + (y4 * x3 - x4 * y3) / (x3 - x4));\n            }\n        }\n    }\n}\n\nint main()\n{\n    int m;\n    cin >> m;\n    for(int i = 0; i < m; i++){\n        double xa, ya, xb, yb, n;\n        cin >> xa >> ya >> xb >> yb >> n;\n        double xs[101], ys[101], xt[101], yt[101], o, l;\n        vector<pair<pair<double, double>, int> >  kouten;\n        int shouldupper[101];\n        for(int j = 0; j < n; j++){\n            cin >> xs[j] >> ys[j] >> xt[j] >> yt[j] >> o >> l;\n            if((o == 1 && l == 1) || (o == 0 && l == 0)) shouldupper[j] = 1;\n            else shouldupper[j] = 0;\n        }\n        for(int j = 0; j < n; j++){\n            pair<double, double> ans = getkouten(xa, ya, xb, yb, xs[j], ys[j], xt[j], yt[j]);\n            // cout << ans.first << \" \" << ans.second << endl;\n            if(ans.first <= max(xa, xb) && ans.first >= min(xa, xb)) kouten.push_back(make_pair(ans, shouldupper[j]));\n        }\n        if(kouten.size() == 0){\n            cout << 0 << endl;\n            continue;\n        }\n        // cout << kouten.size() << endl;\n        sort(kouten.begin(), kouten.end());\n        int now = kouten[0].second, result = 0;\n        // cout << \"ho\" << endl;\n        for(int j = 1; j < kouten.size(); j++){\n            // cout << (kouten[j].first).first << \" \" << (kouten[j].first).second << endl;\n            if(kouten[j].second != now){\n                result++;\n                now = kouten[j].second;\n            }\n        }\n        cout << result << endl;\n    } \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<long double> P;\ntypedef pair<long double,int> Pair;\n\nint u, n;\nlong double xa, ya, xb, yb;\nlong double x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\nlong double cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  long double d1 = abs(cross(b, a1-b1));\n  long double d2 = abs(cross(b, a2-b1));\n  long double t = d1 / (d1 + d2);\n  return a1+(a2-a1)*t; \n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\ta = P(xa,ya); b = P(xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = P(x1,y1), d = P(x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(abs(e.real()-a.real()),o));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\n#define x(p) real(p)\n#define y(p) imag(p)\n\nconst double eps=1e-8;\nconst double inf=1e12;\ntypedef complex<double> P;\n\nnamespace std{\n  bool operator<(const P& a,const P& b){\n    return x(a)==x(b)?y(a)<y(b):x(a)<x(b);\n  }\n}\ndouble cross(const P& a,const P& b){\n  return y(conj(a)*b);\n}\ndouble dot(const P& a,const P& b){\n  return x(conj(a)*b);\n}\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nP projection(const L& l,const P& p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*x(c/b);\n}\nP reflection(const L& l,const P& p){\n  return p+2.0*(projection(l,p)-p);\n}\n//// counter-clockwise\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L& l,const L& m){\n  return abs(cross(l[1]-l[0],m[1]-m[0]))>eps;\n}\nbool intersectSS(const L& s,const L& t){\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0&&ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0;\n}\nP crosspoint(const L& l,const L& m) {\n  double A=cross(l[1]-l[0],m[1]-m[0]);\n  double B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\nbool intersectSP(const L& s,const P& p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\ndouble distanceSP(const L& s,const P& p) {\n  const P r=projection(s,p);\n  return intersectSP(s,r)?abs(r-p):min(abs(s[0]-p),abs(s[1]-p));\n}\ndouble distanceSS(const L& s,const L& t) {\n  return intersectSS(s,t)?0:min(min(distanceSP(s,t[0]),distanceSP(s,t[1])),\n                                min(distanceSP(t,s[0]),distanceSP(t,s[1])));\n}\n\nstruct cpoint{\n  P p;\n  int state;\n};\nbool operator<(const cpoint& a,const cpoint& b){\n  return a.p<b.p;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  int cases; \n  cin>>cases;\n  while(cases--){\n    double x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    L sl(P(x1,y1),P(x2,y2));\n    int n;\n    cin>>n;\n    vector<cpoint> ps;\n    rep(i,n){\n      int o,l;\n      cin>>x1>>y1>>x2>>y2>>o>>l;\n      L nl(P(x1,y1),P(x2,y2));\n      if(intersectSS(nl,sl)){\n        ps.push_back((cpoint){crosspoint(nl,sl),~(o^l)&1});\n      }\n    }\n    sort(all(ps));\n    int res=10000000;\n    {\n      int state=0; // under ground\n      int cnt=0;\n      rep(i,ps.size()){\n        if(state!=ps[i].state){\n          state=ps[i].state;\n          cnt++;\n        }\n      }\n      minch(res,cnt);\n    }\n    {\n      int state=1; // ground\n      int cnt=0;\n      rep(i,ps.size()){\n        if(state!=ps[i].state){\n          state=ps[i].state;\n          cnt++;\n        }\n      }\n      minch(res,cnt);\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-9\n#define INF 1e10\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tlong double r = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\tif((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(tmpx,(o+l)%2));\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\t\n\t\tif(v.size() == 0)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-9\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < - EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < - EPS );\n}\n\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    int N;\n    cin >> N;\n\n    vec sx(N), sy(N), tx(N), ty(N), o(N), l(N);\n    for (int i = 0; i < N; i++) {\n        cin >> sx[i] >> sy[i] >> tx[i] >> ty[i] >> o[i] >> l[i];\n    }\n\n    P ap(ax, ay);\n    P bp(bx, by);\n    vec crossed_idx;\n    for (int i = 0; i < N; i++) {\n        P sp(sx[i], sy[i]);\n        P tp(tx[i], ty[i]);\n        if (is_intersected_ls(ap, bp, sp, tp)) crossed_idx.push_back(i);\n    }\n\n    vector<pair<int,int> > points;\n    for (int i = 0, len = crossed_idx.size(); i < len; i++) {\n        int c = crossed_idx[i];\n        P sp(sx[c], sy[c]);\n        P tp(tx[c], ty[c]);\n        P point = intersection_l(ap, bp, sp, tp);\n        double dist = abs(point - ap);\n        points.push_back(pair<int,int>(dist, c));\n    }\n\n    sort(points.begin(), points.end());\n\n    int fst = points[0].second;\n    bool is_over;\n    if (o[fst]) {\n        if (l[fst]) is_over = true;\n        else is_over = false;\n    } else {\n        if (!l[fst]) is_over = true;\n        else is_over = false;\n    }\n\n    int ans = 0;\n    for (int i = 0, len = points.size(); i < len; i++) {\n        int now = points[i].second;\n        if (o[now]) {\n            if (l[now] != is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        } else {\n            if (l[now] == is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    int N; cin>> N;\n    while (N--) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-14\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\ndouble cross (P a, P b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nbool is_intersected_ls(P a1, P a2, P b1, P b2) {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < - EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < - EPS );\n}\n\nP intersection_l(P a1, P a2, P b1, P b2) {\n    P a = a2 - a1; P b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    int N;\n    cin >> N;\n\n    vec sx(N), sy(N), tx(N), ty(N), o(N), l(N);\n    for (int i = 0; i < N; i++) {\n        cin >> sx[i] >> sy[i] >> tx[i] >> ty[i] >> o[i] >> l[i];\n    }\n\n    P ap(ax, ay);\n    P bp(bx, by);\n    vec crossed_idx;\n    for (int i = 0; i < N; i++) {\n        P sp(sx[i], sy[i]);\n        P tp(tx[i], ty[i]);\n        if (is_intersected_ls(ap, bp, sp, tp)) crossed_idx.push_back(i);\n    }\n\n    vector<pair<int,int> > points;\n    for (int i = 0, len = crossed_idx.size(); i < len; i++) {\n        int c = crossed_idx[i];\n        P sp(sx[c], sy[c]);\n        P tp(tx[c], ty[c]);\n        P point = intersection_l(ap, bp, sp, tp);\n        double dist = abs(point - ap);\n        points.push_back(pair<int,int>(dist, c));\n    }\n\n    sort(points.begin(), points.end());\n\n    int fst;\n    bool is_over;\n    if (points.size()) {\n        fst = points[0].second;\n        if (o[fst]) {\n            if (l[fst]) is_over = true;\n            else is_over = false;\n        } else {\n            if (!l[fst]) is_over = true;\n            else is_over = false;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0, len = points.size(); i < len; i++) {\n        int now = points[i].second;\n        if (o[now]) {\n            if (l[now] != is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        } else {\n            if (l[now] == is_over) {\n                ans++;\n                is_over = !is_over;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    int N; cin>> N;\n    while (N--) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <limits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef struct {\n    double x, y;\n} pt;\n\ntypedef pair<pt, pt> seg;\n\nseg mkseg(double ax, double ay, double bx, double by) {\n    pt a = {ax, ay};\n    pt b = {bx, by};\n    return seg(a, b);\n}\n\ndouble inf = numeric_limits<double>::infinity();\ndouble eps = pow(10, -9);\n\npt seg_cross(seg a, seg b) {\n    double A = (a.second.x - a.first.x) / (a.second.y - a.first.y);\n    double B = (b.second.x - b.first.x) / (b.second.y - b.first.y);\n\n    // cerr << \"A=\" << A << \" B=\" << B << endl;\n\n    if (A == inf || A == -inf) {\n        double y = a.first.y;\n        double x = B * (y - b.first.y) + b.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    if (B == inf || B == -inf) {\n        double y = b.first.y;\n        double x = A * (y - a.first.y) + a.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    double y = (A * a.first.y - B * b.first.y + b.first.x - a.first.x) / (A - B);\n    double x_ = A * (y - a.first.y) + a.first.x;\n    double x = B * (y - b.first.y) + b.first.x;\n    pt p = {x, y};\n    return p;\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n\n    seg new_seg = mkseg(ax, ay, bx, by);\n    double nminx = min(ax, bx);\n    double nmaxx = max(ax, bx);\n    double nminy = min(ay, by);\n    double nmaxy = max(ay, by);\n\n    int n;\n    cin >> n;\n\n    vector< pair<pt, bool> > pts;\n\n    while (n--) {\n        int ax_, ay_, bx_, by_;\n        int pos, owner;\n        cin >> ax_ >> ay_ >> bx_ >> by_ >> pos >> owner;\n\n        seg s = mkseg(ax_, ay_, bx_, by_);\n\n        double minx = max(nminx, double(min(ax_, bx_))) - eps;\n        double maxx = min(nmaxx, double(max(ax_, bx_))) + eps;\n        double miny = max(nminy, double(min(ay_, by_))) - eps;\n        double maxy = min(nmaxy, double(max(ay_, by_))) + eps;\n\n        pt c = seg_cross(new_seg, s);\n        // cerr << \"CROSS AT \" << c.x << \",\" << c.y << endl;\n\n        bool flag = (pos == 1) ^ (owner == 1);\n        if (minx <= c.x && c.x <= maxx && miny <= c.y && c.y <= maxy) {\n            // cerr << \"PUSH \" << c.x << \",\" << c.y << endl;\n            pts.push_back(make_pair(c, flag));\n        }\n    }\n\n    struct {\n        bool operator()(pair<pt, bool> a, pair<pt, bool> b) {\n            return a.first.x == b.first.x\n                       ? a.first.y < b.first.y\n                       : a.first.x < b.first.x;\n        }\n    } by_x;\n\n    sort(pts.begin(), pts.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<pt, bool> >::iterator it = pts.begin(); it != pts.end(); ++it) {\n        pair<pt, bool> p = *it;\n        // cerr << \"FOUND \" << p.first.x << \" \" << p.first.y << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define clr(n)\t\tmemset(n, 0, sizeof(n))\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\n\nconst double EPS = 1e-9;\nconst int INF = 1e9 + 10;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n#define S first\n#define T second\n#define EX P(INF,INF)\n\ndouble cross(P a, P b) {\n\treturn (conj(a) * b).Y;\n}\ndouble dist(P a, P b) {\n\treturn (a.X - b.X) * (a.X - b.X) + (a.Y - b.Y) * (a.Y - b.Y);\n}\nbool isPointOnLine(P a, P b, P c) {\n\treturn abs(a - c) + abs(c - b) < abs(a - b) + EPS;\n}\n\n//????????¨?????????????????????\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tdouble d1 = cross(b2 - b1, b1 - a1);\n\tdouble d2 = cross(b2 - b1, a2 - a1);\n\tP ret;\n\tif (EQ(d1, 0) && EQ(d2, 0)) {\n\t\tret = a1;\n\t}else\n\tif (EQ(d2, 0)) {\n\t\treturn EX;\n\t}else {\n\t\tret = a1 + d1 / d2 * (a2 - a1);\n\t}\n\tif (isPointOnLine(b1, b2, ret) && isPointOnLine(a1, a2, ret)) {\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn EX;\n\t}\n}\ntypedef tuple<P, bool, bool> pbb;\n\nint dp[102][2];\n\nsigned main() {\n\n\tint T;\n\tcin >> T;\n\trep(_, T) {\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa, ya), B(xb, yb);\n\t\tcin >> n;\n\t\tvector<pbb> vp;\n\t\trep(i, n) {\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tP s(xs, ys), t(xt, yt);\n\t\t\tif (crosspointLL(s, t, A, B) != P(INF, INF)) {\n\t\t\t\tvp.push_back(pbb(crosspointLL(s, t, A, B), o, l));\n\t\t\t}\n\t\t}\n\t\tsort(vp.begin(), vp.end(), [&](pbb &t0, pbb &t1) {\n\t\t\treturn dist(A, get<0>(t0)) < dist(A, get<0>(t1));\n\t\t});\n\t\trep(i, 102)rep(j, 2)dp[i][j] = INF;\n\t\tdp[0][0] = dp[0][1] = 0;\n\t\trep(i, vp.size()) {\n\t\t\tint o = get<1>(vp[i]), l = get<2>(vp[i]);\n\t\t\trep(j, 2) {\n\t\t\t\tif (o == 1) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t}else\n\t\t\t\tif (o == 0) {\n\t\t\t\t\tif (j == l) {\n\t\t\t\t\t\tdp[i + 1][1 - j] = min(dp[i + 1][1 - j], dp[i][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(j, 2) {\n\t\t\tans = min(dp[vp.size()][j], ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nclass Vector2{\npublic:\n  double x;\n  double y;\n  Vector2():x(0), y(0){}\n  Vector2(double a, double b):x(a), y(b){}\n  Vector2(const Vector2 &o):x(o.x), y(o.y){}\n\n  Vector2& operator+=(Vector2 o){x+=o.x;y+=o.y;return *this;}\n  Vector2& operator-=(Vector2 o){x-=o.x;y-=o.y;return *this; }\n  Vector2& operator*=(double o){x*=o;y*=o;return *this;}\n  Vector2& operator/=(double o){x/=o;y/=o;return *this;}\n\n  Vector2 operator+(Vector2 o){return Vector2(*this)+=o;}\n  Vector2 operator-(Vector2 o){return Vector2(*this)-=o;}\n  Vector2 operator-(){return Vector2(-x,-y);}\n  Vector2 operator*(double o){return Vector2(*this)*=o;}\n  Vector2 operator/(double o){return Vector2(*this)/=o;}\n\n  double abs(){\n    return sqrt(mag());\n  }\n\n  double mag(){\n    return x*x+y*y;\n  }\n\n  Vector2 normal(){\n    return (*this) / abs();\n  }\n\n  Vector2 rotate_90(){\n    return Vector2(-y,x);\n  }\n\n  static double dot(Vector2 a,Vector2 b){\n    return a.x * b.x + a.y * b.y;\n  }\n\n  static double cross(Vector2 a,Vector2 b){\n    return a.x * b.y - a.y * b.x;\n  }\n};\n\n\ndouble dot(Vector2 x, Vector2 y){\n  return Vector2::dot(x,y);\n}\n\ndouble cross(Vector2 x, Vector2 y){\n  return Vector2::cross(x,y);\n}\n\nvoid output(Vector2 x){\n  cout << x.x << \" \" << x.y << endl;\n}\n\nconst double EPS = 1e-7;\n\nclass Line{\npublic:\n  Vector2 f;\n  Vector2 s;\n  Line(){\n    f = Vector2(0,0);\n    s = Vector2(1,0);\n  }\n  Line(Vector2 a,Vector2 b):f(a),s(b){}\n\n  Vector2 projection(Vector2 pos){\n    pos -= f;\n    Vector2 n = (s-f).normal();\n    Vector2 res;\n    res = n * dot(pos,n) + f;\n    return res;\n  }\n\n  Vector2 reflection(Vector2 pos){\n    Vector2 n;\n    Vector2 res;\n    pos -= f;\n    double x = f.y-s.y;\n    double y = s.x-f.x;\n    n = Vector2(x,y).normal();\n    res = pos + f - n * dot(pos,n) * 2;\n    return res;\n  }\n\n  static bool is_cross(Line a,Line b){\n    Vector2 ap = a.s - a.f;\n    Vector2 bp = b.s - b.f;\n    if(abs(Vector2::dot(ap,bp))<EPS){\n      return true;\n    }\n    return false;\n  }\n\n  static bool is_cross_segment(Line a,Line b){\n    if(Line::is_parallel(a,b)){\n      return a.is_online(b.f) || a.is_online(b.s) || b.is_online(a.f) || b.is_online(a.s);\n    }\n\t  if(Vector2::cross(a.s-a.f,b.f-a.f)*Vector2::cross(a.s-a.f,b.s-a.f)>EPS)return false;\n\t  if(Vector2::cross(b.s-b.f,a.f-b.f)*Vector2::cross(b.s-b.f,a.s-b.f)>EPS)return false;\nreturn true;\n  }\n\n  static bool is_parallel(Line a,Line b){\n    Vector2 ap = a.s - a.f;\n    Vector2 bp = b.s - b.f;\n    if(abs(Vector2::cross(ap,bp))<EPS){\n      return true;\n    }\n    return false;\n  }\n\n  static Vector2 cul_cross(Line a,Line b){\n    if(a.is_online(b.f)){\n      return b.f;\n    }\n    if(a.is_online(b.s)){\n      return b.s;\n    }\n    if(b.is_online(a.f)){\n      return a.f;\n    }\n    if(b.is_online(a.s)){\n      return a.s;\n    }\n    Vector2 an = (a.s-a.f).rotate_90();\n    if(Vector2::dot(b.f-a.f,an)<0){\n      an = -an;\n    }\n    double dis_1 = Vector2::dot(b.f-a.f,an);\n    double dis_2 = Vector2::dot(b.s-a.f,an);\n    return b.f + (b.s - b.f) * dis_1 / (dis_1 - dis_2);\n  }\n\n  double cul_distance(Vector2 pos){\n    Vector2 v = s-f;\n    Vector2 n = v.normal();\n    double k = v.abs();\n    pos -= f;\n    double dis = Vector2::dot(pos,n);\n    if(dis>0){\n      if(dis>k)dis=k;\n      pos -= n * dis;\n    }\n    return pos.abs();\n  }\n\n  static double cul_distance(Line a,Line b){\n    if(Line::is_cross_segment(a,b))return 0;\n    return min({a.cul_distance(b.f),a.cul_distance(b.s),\n          b.cul_distance(a.f),b.cul_distance(a.s)});\n  }\n\n  bool is_online(Vector2 pos){\n    return cul_distance(pos) < EPS;\n  }\n};\n\nVector2 input_vector2(){\n  double x = in<double>();\n  double y = in<double>();\n  return Vector2(x,y);\n}\n\nint func(){\n  Vector2 from = input_vector2();\n  Vector2 to = input_vector2();\n  Line line(from,to);\n  vector<Line> lines;\n  vector<int> vals;\n  int n = in();\n  rep(i,n){\n    Vector2 f = input_vector2();\n    Vector2 s = input_vector2();\n    lines.emplace_back(f,s);\n    vals.emplace_back((in())^(in()));\n  }\n\n  using P = pair<double,int>;\n  vector<P> crosses;\n  rep(i,n){\n    if(Line::is_cross_segment(line,lines[i])){\n      Vector2 cross = Line::cul_cross(line,lines[i]);\n      double dis = (line.f - cross).abs();\n      crosses.emplace_back(dis,vals[i]);\n    }\n  }\n  if(crosses.empty())return 0;\n  sort(all(crosses));\n  int ans = 0;\n  int b = crosses[0].second;\n  rep(i,1,crosses.size()){\n    if(b!=crosses[i].second){\n      ++ans;\n      b = crosses[i].second;\n    }\n  }\n  return ans;\n}\nint main(){\n  int n = in();\n  rep(i,n){\n    cout << func() << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L:public vector<P> {\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\n\ndouble dot(P a, P b) {\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return dot(P(-a.imag(),a.real()),b);\n}\n\nint ccw(P a, P b, P c) {\n  b-=a; c-=a;\n  if(cross(b,c)>0)return +1;\n  if(cross(b,c)<0)return -1;\n  if(dot(b,c)<0)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool hit(const L& s, const L& t) {\n  return ccw(s[0],t[0],s[1])*ccw(s[0],t[1],s[1])<=0;\n}\n\nbool same(const L& s, const L& t) {\n  return (s[1]-s[0]).real()*(t[1]-t[0]).imag()==(s[1]-s[0]).imag()*(t[1]-t[0]).real();\n}\n\ndouble crosslen(const L& s, const L& t) {\n  \n  P ab=s[1]-s[0], ac=t[0]-s[0], ad=t[1]-s[0];\n  ab/=norm(ab);\n  double lac=dot(ab,ac), lad=dot(ab,ad);\n  double dac=abs(ac-ab*lac), dad=abs(ad-ab*lad);\n  return (lac*dad+lad*dac)/(dad+dac);\n}\n\nstruct LINE {\n  L line;\n  int o,l;\n};\n\nstruct POINT {\n  LINE line;\n  double len;\n  bool uch;\n};\n\nbool comp (POINT a, POINT b) {\n  return a.len < b.len;\n}\n\nint main () {\n  int m;cin>>m;\n  while(m--){\n    vector<POINT> points;\n    vector<LINE> lines;\n    double xa,ya,xb,yb;cin>>xa>>ya>>xb>>yb;\n    int n;cin>>n;\n    L self(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;++i){\n      double a,b,c,d;int e,f;cin>>a>>b>>c>>d>>e>>f;\n      lines.push_back((LINE){L(P(a,b),P(c,d)),e,f});\n    }\n    for(int i=0;i<n;++i){\n      if(hit(self,lines[i].line)){\n\tif(same(self,lines[i].line)){\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[0]-self[0]),true});\n\t  points.push_back((POINT){lines[i],abs(lines[i].line[1]-self[0]),true});\n\t}else{\n\t  points.push_back((POINT){lines[i],crosslen(self,lines[i].line)});\n\t}\n      }\n    }\n    sort(points.begin(),points.end(),comp);\n    vector<POINT> newpoints=points; points.clear();\n    int len=newpoints.size(); double srclen=abs(self[1]-self[0]);\n    if(len==0){cout<<0<<endl;continue;}\n    for(int i=0;i<len;++i){\n      if(newpoints[i].len>srclen)break;\n      points.push_back(newpoints[i]);\n    }\n    LINE line=points[0].line;\n    int precur,cur=0,result=0;bool ch=true;\n    if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n    for(int i=1;i<len;++i){\n      line=points[i].line;\n      if(points[i].uch)ch=true;\n      if(ch){\n\tprecur=cur; if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n\tif(precur!=cur){++result;}\n\tif(points[i].uch)ch=false;\n      }\n    }\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n\n#define X() real()\n#define Y() imag()\n#define x(p) (p).X()\n#define y(p) (p).Y()\n#define curr(P, i) P[i];\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i-1+P.size())%P.size()]\n\ntypedef double D;\ntypedef complex<D> P;\n\nnamespace std{\n  bool operator <(const P& a, const P& b) {\n    return x(a) != x(b) ? x(a) < x(b) : y(a) < y(b);\n  }\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P& a, const P& b) {\n    push_back(a);\n    push_back(b);\n  }\n};\n\nD dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nD cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a;\n  c -= a;\n  if(cross(b, c) > 0) return +1;\n  if(cross(b, c) < 0) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nconst D EPS = 1e-9;\n\nbool interSS(const L& s, const L& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nP crossP(const L& a, const L& b) {\n  D A = cross(a[1] - a[0], b[1] - b[0]);\n  D B = cross(a[1] - a[0], a[1] - b[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return b[0];\n  return b[0]+ B / A * (b[1] - b[0]);\n}\n\nP makeP(D arg, D r = 1.0) {\n  return r * P{cos(arg), sin(arg)};\n}\nP rotP(const P& a, D arg) {\n  return a * makeP(arg);\n}\nD getArgP(const P& a) {\n  return atan2(y(a), x(a));\n}\n\nstruct M{\n  P p;\n  int a, b;\n  bool operator < (const M& m) const {\n    return p != m.p ? p < m.p :(a != m.a ? a < m.a : b < m.b);\n  }\n};\n\nint calc(int idx, int isUp, const vector<M>& ms) {\n  int n = ms.size();\n  if(idx == n) return 0;\n  int f = (ms[idx].a ^ ms[idx].b) == 0;\n  return calc(idx+1, f, ms) + (f == isUp ? 0 : 1);\n}\n\nvoid printP(const P& p) {\n  cout << x(p) << \" \" << y(p);\n}\nvoid printL(const L& l) {\n  printP(l[0]);\n  cout << \" \";\n  printP(l[1]);\n  cout << endl;\n}\n\nint main() {\n  int datSet;\n  cin >> datSet;\n  while(datSet--) {\n    L l;\n    {\n      D xa, ya, xb, yb;\n      cin >> xa >> ya >> xb >> yb;\n      l = L(P{xa, ya}, P{xb, yb});\n      //if(l[1] < l[0]) swap(l[0], l[1]);\n    }\n    int n;\n    cin >> n;\n    vector<L> ls(n);\n    vector<int> a(n), b(n);\n    rep(i, n) {\n      D xa, ya, xb, yb;\n      cin >> xa >> ya >> xb >> yb >> a[i] >> b[i];\n      ls[i] = L(P{xa, ya}, P{xb, yb});\n    }\n    vector<M> ms;\n    rep(i, n) {\n      if(interSS(l, ls[i])) {\n\t// cout << \"intersect : \" << i << endl;\n\tms.push_back(M{crossP(l, ls[i]), a[i], b[i]});\n      }\n    }\n    sort(ms.begin(), ms.end());\n    cout << min(calc(0, 0, ms), calc(0, 1, ms)) << endl;\n    // cout << ms.size() << endl; \n    //printL(l);\n    //rep(i, n) printL(ls[i]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, double xo, double yo, double dx, double dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tdouble dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 - EPS || x > r + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<double, int> pdi;\n\nstruct point { int x, y; };\nstruct line { point p, q; };\n\nint T, N, O[110], L[110];\nline A, S[110];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double ux = l.q.x - l.p.x;\n  double uy = l.q.y - l.p.y;\n  double vx = p.x - l.p.x;\n  double vy = p.y - l.p.y;\n  double cross = abs(ux * vy - uy * vx);\n  double ul = sqrt(ux * ux + uy * uy);\n  return cross / ul;\n}\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> A.p.x >> A.p.y >> A.q.x >> A.q.y;\n    cin >> N;\n    REP(i, 0, N) cin >> S[i].p.x >> S[i].p.y >> S[i].q.x >> S[i].q.y >> O[i] >> L[i];\n\n    vector<pdi> E;\n    REP(i, 0, N) if(intersect(A, S[i])) {\n      double da = distance(S[i], A.p);\n      double db = distance(S[i], A.q);\n      double d = da / (da + db);\n      E.push_back(pdi(d, i));\n    }\n\n    sort(E.begin(), E.end());\n\n    vector<int> g;\n    REP(i, 0, E.size()) {\n      int k = E[i].second;\n      g.push_back(O[k] == 1 ? L[k] : (L[k] ^ 1));\n    }\n\n    int ans = 0;\n    REP(i, 1, (g.size())) if(g[i - 1] != g[i]) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <utility>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X * b.X + a.Y * b.Y;}\n\ndouble cross(P a, P b){return a.X * b.Y - a.Y * b.X;}\n\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\n  \nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b-a) + EPS < abs(c-a) ) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nint main(){\n  int N;\n  cin >> N;\n  double x_s, y_s, x_t, y_t;\n  for(int i = 0; i < N; ++i){\n    cin >> x_s >> y_s >> x_t >> y_t;\n    P a = P(x_s,y_s), b = P(x_t, y_t);\n    L S = L(a,b);\n    int n, o, l;\n    cin >> n;\n    vector<pair<P,int> > cp;\n    for(int i = 0; i < n; ++i){\n      cin >> x_s >> y_s >> x_t >> y_t >> o >> l;\n      L T = L(P(x_s,y_s),P(x_t,y_t));\n      if(is_cross(S,T))\n\tcp.push_back(make_pair(intersection(S,T),o^l));\n    }\n    sort(cp.begin(),cp.end());\n    if(!cp.size()){\n      cout << 0 << endl;\n      continue;\n    }\n    int t = cp[0].second, ans = 0;\n    for(int i = 1; i < (int)cp.size(); ++i){\n      if(t != cp[i].second){\n\t++ans;\n\tt = cp[i].second;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <set>\n\nusing namespace std;\ntypedef long double ld;\nconst ld EPS = 10e-9;\n\nstruct point {\n\n\tld x, y;\n\tld d;\n\tint id;\n\n\tbool operator<(const point& rhs) const {\n\t\treturn (d + EPS < rhs.d);\n\t}\n\n};\n\nstruct line {\n\tpoint s, t;\n\tint o, l;\n};\n\nint solve();\n\npoint getIntersection( const line l[2] ) {\n\n\tpoint ret;\n\tret.d = -1.0f;\n\tld a[2], b[2], c[2], det, M[2], m[2];\n\t\n\tfor (int i = 0; i < 2; i++) {\n\t\ta[i] = -l[i].s.y + l[i].t.y;\n\t\tb[i] = l[i].s.x - l[i].t.x;\n\t\tc[i] = -l[i].s.y*l[i].t.x + l[i].s.x*l[i].t.y;\n\t}\n\n\tdet = a[0] * b[1] - a[1] * b[0];\n\n\t// two lines are parallel\n\tif (abs(det) < EPS){ return ret; }\n\n\tret.x = b[1] * c[0] - a[1] * c[1];\n\tret.y = -b[0] * c[0] + a[0] * c[1];\n\tret.x /= det; ret.y /= det;\n\n\tm[0] = min(min(l[0].s.x, l[0].t.x), min(l[1].s.x, l[1].t.x));\n\tM[0] = max(max(l[0].s.x, l[0].t.x), max(l[1].s.x, l[1].t.x));\n\n\tm[1] = min(min(l[0].s.y, l[0].t.y), min(l[1].s.y, l[1].t.y));\n\tM[1] = max(max(l[0].s.y, l[0].t.y), max(l[1].s.y, l[1].t.y));\n\n\tif (m[0] + EPS < ret.x && ret.x + EPS < M[0]\n\t\t&& m[1] + EPS < ret.y && ret.y + EPS < M[1]) {\n\t\tret.d = sqrtl(ret.x*ret.x + ret.y*ret.y);\n\t}\n\n\treturn ret;\n\n}\n\nint isUnderground(const int o, const int l) {\n\t\n\tif (o) { return l; }\n\t\n\telse { return 1 - l; }\n\t\n}\n\nint main(void) {\n\n\tint n;\n\tcin >> n;\n\n\tfor (int i = 0; i < n; i++)\n\t\tsolve();\n\n\treturn 0;\n\n}\n\nint solve() {\n\n\tint n, flg, ans = 0;\n\tline l;\n\tvector<line> v;\n\tvector<point> ps;\n\n\t//input\n\tcin >> l.s.x >> l.s.y >> l.t.x >> l.t.y;\n\n\tcin >> n;\n\tv.resize(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> v[i].s.x >> v[i].s.y >> v[i].t.x >> v[i].t.y >> v[i].o >> v[i].l;\n\t\tv[i].s.x += 10000.0;\n\t\tv[i].s.y += 10000.0;\n\t\tv[i].t.x += 10000.0;\n\t\tv[i].t.y += 10000.0;\n\t}\n\t\n\t//get intersection points\n\tfor (int i = 0; i < n; i++) {\n\t\tline m[] = { l, v[i] };\n\t\tpoint p = getIntersection(m);\n\t\tif ( p.d > EPS ) {\n\t\t\tp.id = i;\n\t\t\tps.push_back(p);\n\t\t}\n\t}\n\n\t//sort intersection points\n\tsort(ps.begin(), ps.end());\n\n\tif (ps.size() > 0) {\n\n\t\tint index = ps[0].id;\n\t\tflg = isUnderground(v[index].o, v[index].l);\n\n\t\tfor (int i = 1; i < ps.size(); i++) {\n\t\t\tint nind = ps[i].id;\n\t\t\tint nflg = isUnderground(v[nind].o, v[nind].l);\n\t\t\tif (flg^nflg){ ans++; }\n\t\t\tflg = nflg;\n\t\t}\n\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\ntemplate <class T>\ninline T sq(T x) { return x * x; }\n\nusing Real = long double;\nusing Point = std::complex<Real>;\nusing Segment = std::pair<Point, Point>;\nusing Polygon = std::vector<Point>;\n\nbool operator<(const Point& a, const Point& b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n}\n\nstd::istream& operator>>(std::istream& is, Point& p) {\n    Real x, y;\n    is >> x >> y;\n    p = Point(x, y);\n    return is;\n}\n\nconst Real EPS = 1e-10;\n\n// 宇宙船演算子\ninline int compare(Real a, Real b) {\n    if (std::abs(a - b) < EPS) return 0;\n    return a - b > 0 ? 1 : -1;\n}\n\ninline Real dist(Point a, Point b) {\n    return std::abs(a - b);\n}\n\ninline Real length(Segment s) {\n    return dist(s.first, s.second);\n}\n\n// inner product\ninline Real dot(Point x, Point y) {\n    return std::real(std::conj(x) * (y));\n}\n\n// outer product\ninline Real cross(Point x, Point y) {\n    return std::imag(std::conj(x) * (y));\n}\n\n// lに対するxの正射影\nPoint proj(Segment s, Point p) {\n    Real ratio = dot(s.second - s.first, p - s.first) / sq(length(s));\n    return s.first + (s.second - s.first) * ratio;\n}\n\n// lを軸としてxに対称な点\nPoint refl(Segment s, Point p) {\n    Point t = proj(s, p);\n    return t + (t - p);\n}\n\n// lに対するpの位置\n// 0: on segment\n// 1: counter clockwise  -1: clockwise\n// 2: online front       -2: online back\nint side(Segment s, Point p) {\n    Real c = cross(s.second - s.first, p - s.first);\n    if (compare(c, 0) != 0) return compare(c, 0);\n\n    Real d = dot(s.second - s.first, p - s.first);\n    if (compare(d, 0) < 0) return -2;\n\n    return (compare(length(Segment(s.first, p)), length(s)) > 0 ? 2 : 0);\n}\n\ninline bool isorthogonal(Segment s1, Segment s2) {\n    return compare(dot(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\ninline bool isparallel(Segment s1, Segment s2) {\n    return compare(cross(s1.second - s1.first, s2.second - s2.first), 0) == 0;\n}\n\n// bound: 線分の端点を含むか\ninline bool intersect(Segment s1, Segment s2, bool bound) {\n    return (side(s1, s2.first) * side(s1, s2.second) < bound) &&\n           (side(s2, s1.first) * side(s2, s1.second) < bound);\n}\n\nPoint intersection(Segment s1, Segment s2) {\n    Real c1 = cross(s2.second - s2.first, s1.second - s1.first);\n    Real c2 = cross(s2.second - s2.first, s1.first - s2.first);\n    return s1.first + (s1.second - s1.first) * (-c2 / c1);\n}\n\n\nvoid solve() {\n    Segment l;\n    std::cin >> l.first >> l.second;\n\n    Int n;\n    std::cin >> n;\n\n    Vector<Tuple<Point, Bool>> ps;\n    for (Int i = 0; i < n; ++i) {\n        Segment s;\n        Int a, b;\n        std::cin >> s.first >> s.second >> a >> b;\n\n        if (intersect(l, s, false)) {\n            Point p = intersection(l, s);\n            ps.emplace_back(p, a == b);\n        }\n    }\n    std::sort(ps.begin(), ps.end(), [](auto a, auto b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n\n    Int ans = 0;\n    for (Int i = 0; i + 1 < ps.size(); ++i) {\n        if (std::get<1>(ps[i]) != std::get<1>(ps[i + 1])) ++ans;\n    }\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    Int n;\n    std::cin >> n;\n    for (Int i = 0; i < n; ++i) solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n/*\n\nTodo:\nLine??¨Segment?????????????????????\n\n*/\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\nclass Road {\npublic:\n\tPoint s;\n\tbool o, l;\n\tRoad(Point s, bool o, bool l) :s(s), o(o), l(l) {}\n\tbool operator<(const Road &that) {\n\t\treturn s < that.s;\n\t}\n};\n\nsigned main() {\n\tint M; cin >> M;\n\trep(h, 0, M) {\n\t\tvector<Road> v;\n\t\tPoint a, b; cin >> a >> b;\n\t\tSegment B(a, b);\n\t\tint n; cin >> n;\n\n\t\trep(i, 0, n) {\n\t\t\tPoint s, t; cin >> s >> t;\n\t\t\tbool o, l; cin >> o >> l;\n\t\t\tSegment S(s, t);\n\t\t\tif (intersect(B, S)) {\n\t\t\t\tPoint res = get_cross_point(B, S);\n\t\t\t\tv.emplace_back(res, o, l);\n\t\t\t}\n\t\t}\n\t\tsort(all(v));\n\t\tif (v.size() == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool ll = v[0].l;\n\t\tint cnt = 0;\n\t\trep(i, 0, v.size()) {\n\t\t\tRoad r = v[i];\n\t\t\tif (r.o) {\n\t\t\t\tif (ll != r.l) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tll = r.l;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ll == r.l) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tll = !r.l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << --cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nint main(){\n  int T; cin>>T;\n  int xa,ya,xb,yb;\n  while(cin>>xa>>ya>>xb>>yb){\n    L newline(P(xa,ya),P(xb,yb));\n    vector< pair<double, int> > cps;\n    int n; cin>>n;\n    while(n--){\n      int x1,y1,x2,y2,o,l;\n      cin>>x1>>y1>>x2>>y2>>o>>l;\n      L ln(P(x1,y1),P(x2,y2));\n      if(intersectLL(newline, ln)){\n        cps.push_back(make_pair(abs(crosspoint(newline,ln)-newline[0]), o ^ l));\n      }\n    }\n    sort(cps.begin(), cps.end());\n\n    int ans = 0;\n    FOR(i,1,cps.size()){\n      if(cps[i].second != cps[i-1].second)ans++;\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n    double x, y;\n    int id;\n    point () {}\n    ~point() {}\n    point(double a, double b): x(a), y(b), id(-1) {}\n    point(double a, double b, int c): x(a), y(b), id(c) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.y;\n    }\n\n    bool operator > (const point& o) const {\n        return x == o.x ? y > o.y : x > o.y;\n    }\n};\n\ndouble put (point p, point l1, point l2) {\n    double a = l1.y - l2.y, b = l2.x - l1.x, c = l1.x*l2.y - l2.x*l1.y;\n    return a * p.x + b * p.y + c;\n}\n\npoint intersect(point k1, point k2, point l1, point l2) {\n    double ret_x = (k1.x + k2.x) / 2, ret_y = (k1.y + k2.y) / 2;\n    double sig = put(k1, l1, l2) > 0 ? 1 : -1;\n    for (int j = 0; j < 200; ++j) {\n        double val = put(point(ret_x, ret_y), l1, l2);\n        if (abs(val - sig)  < EPS) {\n            return point(ret_x, ret_y);\n        } else if (val * sig > 0) {\n            ret_x = (ret_x + k2.x) / 2;\n            ret_y = (ret_y + k2.y) / 2;\n        } else {\n            ret_x = (ret_x + k1.x) / 2;\n            ret_y = (ret_y + k1.y) / 2;\n        }\n    }\n    return point(ret_x, ret_y);\n}\n\nbool cross(point k1, point k2, point l1, point l2) {\n    bool b1 = put(k1, l1, l2) * put(k2, l1, l2) < 0;\n    bool b2 = put(l1, k1, k2) * put(l2, k1, k2) < 0;\n    return b1 && b2;\n}\n\nint xa, ya, xb, yb, N;\npoint s[100], t[100];\nint   o[100], l[100];\n\nint solve() {\n    point start(xa, ya), goal(xb, yb);\n    vector<point> itss;\n    for (int j = 0; j < N; ++j) {\n        if (cross(start, goal, s[j], t[j])) {\n            point it = intersect(start, goal, s[j], t[j]);\n            it.id = j;\n            itss.push_back(it);\n        }\n    }\n\n    sort(begin(itss), end(itss));\n    if (start > goal) reverse(begin(itss), end(itss));\n\n    int ret = 0, height = -1;\n    for (const point& it: itss) {\n        int id = it.id;\n        int expected = o[id] == 1 ? l[id] : 1-l[id];\n        if (height == -1) {\n            height = expected;\n        } else if (height != expected) {\n            ++ret;\n            height = expected;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            cin >> s[j].x >> s[j].y >> t[j].x >> t[j].y >> o[j] >> l[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef Point Vector;\n//???????????¨????§???????\nstruct Segment{ Point p1, p2; };\n//??´????????¨????§???????\ntypedef Segment Line;\n//????§???¢?????¨????§???????\ntypedef vector<Point> Polygon;\n\nnamespace std{\n    bool operator < (const Point &a, const Point &b){\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n    bool operator == (const Point &a, const Point &b){\n        return a.real() == b.real() && a.imag() == b.imag();\n    }\n}\n\nclass Circle{\n    public:\n        Point c;\n        double r;\n        Circle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\n// ?¨±???????????????\n#define EPS (1e-10)\n\n// ????????????a?????¶??????????±???????\n//double length = abs(a);\n\n// 2???a,b???????????¢????±???????\n//double distance = abs(a-b);\n\n/*\n// ????????????a?????????????????????????±???????\nPoint b = a / abs(a);\n\n// ????????????a?????????????????????n1,n2????±???????\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2??????????????????????????????????????????\nbool EQ(double a, double b){\n    return (abs(a - b) < EPS);\n}\n\n// 2??????????????????????????????????????????\nbool EQV(Vector a, Vector b){\n    return ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// ?????? (dot product) : a???b = |a||b|cos??\ndouble dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// ?????? (cross product) : a??b = |a||b|sin??\ndouble cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2??´????????´????????? : a??\\b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) {\n    return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// 2??´?????????????????? : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n    return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) {\n    return isParallel(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ???c?????´???a,b????????????????????????\nbool isPointOnLine(Point a, Point b, Point c) {\n    return EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) {\n    return isPointOnLine(s.p1, s.p2, c);\n}\n\n// ???a,b???????????´?????¨???c??¨????????¢\ndouble distanceLPoint(Point a, Point b, Point c) {\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) {\n    return distanceLPoint(s.p1, s.p2, c);\n}\n\n// ???a,b???????????¨??????????????¨???c??¨????????¢\ndouble distanceLsPoint(Point a, Point b, Point c) {\n    if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n    if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n    return abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) {\n    return distanceLsPoint(s.p1, s.p2, c);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨???????????????????????????\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n    return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n            ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) {\n    return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????¨??????????????¨b1,b2???????????¨??????????????????????¨????\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n    Vector base = b2 - b1;\n    double d1 = abs(cross(base, a1 - b1));\n    double d2 = abs(cross(base, a2 - b1));\n    double t = d1 / (d1 + d2);\n\n    return Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) {\n    return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´??????????????????\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n    return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) {\n    return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// a1,a2???????????´?????¨b1,b2???????????´?????????????¨????\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n    Point a = a2 - a1; Point b = b2 - b1;\n    return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) {\n    return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distanceLL(Segment s1, Segment s2){\n    if(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n    return min(\n            min(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n                distanceLsPoint(s1.p1, s1.p2, s2.p2)),\n            min(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n                distanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n    Segment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n    return distanceLL(s1, s2);\n}\n\n// ??????s???????????????p????°???±\nPoint project(Segment s, Point p){\n    Vector base = s.p2 - s.p1;\n    double r = dot(p - s.p1, base) / norm(base);\n    return Point(s.p1 + base * r);\n}\n\n//??????s???????±??????¨?????????p??????????§°??????\nPoint reflect(Segment s, Point p){\n    return Point(p + (project(s, p) - p) * 2.0);\n}\n\n//???p???angle?????????????¨???????????????¢\nPoint rotation(Point p, double angle){\n    double x, y;\n    x = p.real() * cos(angle) - p.imag() * sin(angle);\n    y = p.real() * sin(angle) + p.imag() * cos(angle);\n    return Point(x, y);\n}\n\n//???c??¨??????l?????????\npair<Point, Point> getCrossPoints(Circle c, Line l){\n    Vector pr = project(l, c.c);\n    Vector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n    double base = sqrt(c.r * c.r - norm(pr - c.c));\n    return make_pair(pr + e * base, pr - e * base);\n}\n\n//???c1??¨???c2?????????\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n    double d = abs(c1.c - c2.c);\n    double a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n    double t = arg(c2.c - c1.c);\n    return make_pair(Point(c1.c + polar(c1.r, t + a)), Point(c1.c + polar(c1.r, t - a)));\n}\n\n//????????????\nstatic const int IN = 2;\nstatic const int ON = 1;\nstatic const int OUT = 0;\n\nint contains(Polygon g, Point p){\n    int n = g.size();\n    bool x = false;\n    rep(i,n){\n        Point a = g[i] - p, b = g[(i + 1) % n] - p;\n        if( abs(cross(a, b)) < EPS && dot(a,  b) < EPS ) return ON;\n        if( a.imag() > b.imag() ) swap(a, b);\n        if( a.imag() < EPS && EPS < b.imag() && cross(a, b) > EPS ) x = not x;\n    }\n    return ( x ? IN : OUT );\n}\n\n//???????????????????????????\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if( cross(a, b) < -EPS ) return CLOCKWISE;\n    if( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\n//??????\nPolygon convexHull( Polygon s ){\n    Polygon u;\n    if( s.size() < 3 ) return s;\n    sort(s.begin(), s.end());\n\n    range(i,0,s.size()){\n        //== COUNTER_CLOCKWISE?????¨????§????180??\\???????????´?????????????????§????????????????????¨????????°?????????\n        //!= CLOCKWISE?????¨????§????180??????????????´????????????????????°????????????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    for(int i = s.size() - 2; i >= 0; i--){\n        //????????? == ??¨ != ????????´??????\n        for(int n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.emplace_back(s[i]);\n    }\n\n    reverse(u.begin(), u.end());\n    u.pop_back();\n\n    //?????????????????????????????§??????????????????????????????????¨??????????????????????\n    /*\n       int i = 0;\n       while(i < u.size() - 1){\n       if(u[i].imag() > u[i + 1].imag()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }else if(u[i].imag() == u[i + 1].imag() && u[i].real() > u[i + 1].real()){\n       u.emplace_back(u[i]);\n       u.erase(u.begin());\n       continue;\n       }\n       break;\n       }\n       */\n\n    return u;\n}\n\n//?????£?????????????????¨?????????????§???¢?????´???????±???????\ndouble diameterOfConvexPolygon(Polygon p){\n    Polygon s = convexHull(p);\n    int n = s.size();\n\n    if(n == 2) return abs(s[1] - s[0]);\n\n    int i = 0, j = 0;\n    rep(k,n){\n        if(not (s[i] < s[k])) i = k;\n        if(s[j] < s[k]) j = k;\n    }\n\n    double ret = 0.0;\n    int is = i, js = j;\n\n    while(i != js || j != is){\n        ret = max(ret, abs(s[i] - s[j]));\n        if(cross(s[(i + 1) % n] - s[i], s[(j + 1) % n] - s[j]) < 0){\n            i = (i + 1) % n;\n        }else{\n            j = (j + 1) % n;\n        }\n    }\n    return ret;\n}\n\n//???????§???¢??????????????????????????¢??°??????????????????????????????????????\\????????????\nPoint getCrossPointLL(Line a, Line b){\n    double A = cross(a.p2 - a.p1, b.p2 - b.p1);\n    double B = cross(a.p2 - a.p1, a.p2 - b.p1);\n    if(abs(A) < EPS && abs(B) < EPS) return b.p1;\n    return b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n    Polygon q;\n    rep(i,p.size()){\n        Point a = p[i], b = p[(i + 1) % p.size()];\n        if (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n        if (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n            q.emplace_back(getCrossPointLL(Line{a, b}, l));\n        }\n    }\n    return q;\n}\n\n//????§???¢?????¢???\ndouble AreaOfTriangle(Point a, Point b, Point c){\n    double w, x, y, z;\n    w = b.real()-a.real();\n    x = b.imag()-a.imag();\n    y = c.real()-a.real();\n    z = c.imag()-a.imag();\n    return abs((w * z - x * y) / 2);\n}\n\n//????§???¢?????¢???\ndouble areaOfPolygon(Polygon g){\n    int n = g.size();\n    double ret = 0.0;\n    rep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n    return abs(ret) / 2.0;\n}\n\n//???????§???¢?????????????????????\nbool isConvex(Polygon g){\n    int n = g.size();\n    rep(i,n){\n        if(ccw(g[i], g[(i + 1) % n], g[(i + 2) % n]) == CLOCKWISE) return false;\n    }\n    return true;\n}\n\n//???????§???¢?????????l??§??????????????????????§???¢?????°\nint dividedPolygonNumber(Polygon p, Line l){\n    int cnt = 0;\n    rep(i,p.size()){\n        if(isIntersectedLs(p[i], p[(i + 1) % p.size()], l.p1, l.p2)) cnt++;\n    }\n    return cnt / 2 + 1;\n}\n\nLine inputLine(){\n    double xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    return Line{Point{xa, ya}, Point{xb, yb}};\n}\n\nint main(){\n    int t;\n    cin >> t;\n    while(t--){\n        Line rail = inputLine();\n        int n;\n        cin >> n;\n\n        Line old[105];\n        int place[105];\n        rep(i,n){\n            old[i] = inputLine();\n            int a,b;\n            cin >> a >> b;\n            //cout << a << ' ' << b << endl;\n            if(not a) b = (b ? 0 : 1);\n            place[i] = b;\n            //cout << a << ' ' << b << endl;\n        }\n\n        vector<pair<Point,int>> v;\n        vector<int> s;\n        rep(i,n){\n            if(isIntersectedL(rail, old[i])){\n                    v.emplace_back(make_pair(intersectionLs(rail, old[i]),place[i]));\n            }\n        }\n        sort(all(v));\n        rep(i,v.size()){\n            //show(v[i].first)\n            if(s.empty()) s.emplace_back(v[i].second);\n            if(s.back() == v[i].second) continue;\n            s.emplace_back(v[i].second);\n        }\n        //rep(i,s.size() - 1) assert(s[i] != s[i + 1]);\n\n        cout << s.size() - 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\nconst double EPS = 1e-9;\n\n// xy平面上の点(ベクトル)を表現するには、complex型を利用するとよい\ntypedef complex<double> P;\n\n// 辺の表現 (座標を2つ pair でもつ)\ntypedef pair<P, P> L;\n\n// 円の表現 (座標 P と 半径 d で表現する)\ntypedef pair<P, double> C;\n\n// 成分を取り出すのを簡単にする\n#define X real()\n#define Y imag()\n\n// 誤差(epsilon)の定義\n#define EPS (1e-10)\n\n// 2つの要素が等しいかどうか\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n\n// 2つのベクトルが等しいかどうか\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n\n// m は n より大きい(以上)かどうか\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n\n// m は n より小さい(以下)かどうか\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\n// 2つのベクトルの内積を求める\ndouble dot(P a, P b) {\n    return (a.X * b.X + a.Y * b.Y);\n}\n\n// 2つのベクトルの外積を求める\ndouble cross(P a, P b) {\n    return (a.X * b.Y - a.Y * b.X);\n}\n\n// ccw (c が直線(線分) ab に対してどのような位置関係か？)\n// Verified: AOJ CGL_1_C: Counter-Clockwise\n// +1 ... a → b で半時計方向に折れて b → c (COUNTER_CLOCKWISE)\n// -1 ... a → b で時計方向に折れて b → c (CLOCKWISE)\n// +2 ... c, a, b がこの順で同一直線状にある場合 (ONLINE_BACK)\n// -2 ... a, b, c がこの順で同一直線状にある場合 ( or a == b ) (ONLINE_FRONT)\n//  0 ... c が線分 ab 上にある場合 (点 a, b 上を含む) (ON_SEGMENT)\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if( cross(b,c) > EPS ) return +1;\n    if( cross(b,c) < -EPS ) return -1;\n    if( dot(b,c) < 0 ) return +2;\n    if( norm(b) < norm(c) ) return -2;\n    return 0;\n}\n\n// 線分 a1, a2 と線分 b1, b2 の交差判定\n// Verified: CGL_2_B: Intersection\nbool isec_ss(P a1, P a2, P b1, P b2) {\n    return ( ccw(a1,a2,b1) * ccw(a1,a2,b2) <= 0 ) &&\n           ( ccw(b1,b2,a1) * ccw(b1,b2,a2) <= 0 );\n}\n\n// 直線 a1, a2 と直線b1, b2の交点を求める\n// Verified: AOJ CGL_2_C.cpp\nP crossp_ll(P a1, P a2, P b1, P b2) {\n    double d1 = cross(b2-b1, b1-a1);\n    double d2 = cross(b2-b1, a2-a1);\n    if( EQ(d1,0) && EQ(d2,0) ) return a1; // same line\n    if( EQ(d2,0) ) assert(false); // precondition not satisfied\n    return a1 + d1 / d2 * (a2 - a1);\n}\n\nstruct Elem {\n    P l, r;\n    int comp, land;\n    Elem(int xs, int ys, int xt, int yt, int o, int p) {\n        l = P(xs, ys);\n        r = P(xt, yt);\n        comp = o;\n        land = p;\n    }\n};\n \nstruct itsect {\n    double x, y;\n    int idx;\n    bool operator<(const itsect &e) const {\n        if(x != e.x) return x < e.x;\n        return y < e.y;\n    }\n};\n\nsigned main() {\n    int T; cin >> T;\n    while(T--) {\n        int xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n        P p(xa, ya), q(xb, yb);\n        int N; cin >> N;\n        vector<Elem> es;\n        rep(i,0,N) {\n            int xs, ys, xt, yt, o, l; cin >> xs >> ys >> xt >> yt >> o >> l;\n            es.push_back(Elem(xs, ys, xt, yt, o, l));\n        }\n\n        vector<itsect> points;\n        rep(i,0,N) {\n            if(isec_ss(p, q, es[i].l, es[i].r)) {\n                P its = crossp_ll(p, q, es[i].l, es[i].r);\n                points.push_back(itsect{its.X, its.Y, i});\n            }\n        }\n        sort(points.begin(), points.end());\n\n        int prev = -1, ans = 0;\n        rep(i,0,points.size()) {\n            int num = es[points[i].idx].comp ^ es[points[i].idx].land;\n            if(prev != num) {\n                ans++;\n                prev = num;\n            }\n        }\n        cout << ans - 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-10;\n\ntypedef complex<double> Point;\n\ndouble dot(const Point& p,const Point& q){\n  return real(conj(p)*q);\n}\n\ndouble det(const Point& p,const Point& q){\n  return imag(conj(p)*q);\n}\n\nbool on_seg(const Point& p1,const Point&p2,\n\t    const Point& q){\n  return abs(det(p1-q,p2-q)) <= EPS && dot(p1-q,p2-q) < EPS;\n}\n\ndouble compute_scale(const Point& p1,const Point& p2,\n\t     const Point& q1,const Point& q2) {\n  return det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nPoint compute_intersection(const Point& p1,const Point& p2,\n\t\t\t   const Point& q1,const Point& q2) {\n  return p1 + (p2-p1) * det(q2-q1,q1-p1) / det(q2-q1,p2-p1);\n}\n\nint compute_location(int owner,int location){\n  //owner 1:me 0:other\n  //location 1:high way 0:under ground\n  if(owner == 1){\n    return location;\n  }\n  else if(owner == 0){\n    return !location;\n  }\n}\n\nint main(){\n  int total_dataset = 0;\n  while(~scanf(\"%d\",&total_dataset)){\n    for(int dataset_idx=0;dataset_idx<total_dataset;dataset_idx++){\n      int xa,ya,xb,yb;\n      scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n      Point p1(xa,ya);\n      Point p2(xb,yb);\n\n      int n;\n      scanf(\"%d\",&n);\n\t\n      vector<pair<double,int> > intersections;\n      for(int i=0;i<n;i++){\n\tint xs,ys,xt,yt,owner,location;\n\tscanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&owner,&location);\n\tPoint p3(xs,ys);\n\tPoint p4(xt,yt);\n\tPoint intersection = compute_intersection(p1,p2,p3,p4);\n\t\n\tif(!on_seg(p1,p2,intersection)) continue;\n\tdouble scale = compute_scale(p1,p2,p3,p4);\n\tint next_location = compute_location(owner,location);\n\n\tpair<double,int> tmp(scale,next_location);\n\tintersections.push_back(tmp);\n      }\n\n      sort(intersections.begin(),intersections.end());\n      int prev = -1;\n      int res = -1;\n      for(int i=0;i<intersections.size();i++){\n\tif(prev != intersections[i].second) res++;\n\tprev = intersections[i].second;\n      }\n      printf(\"%d\\n\",res);\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, double xo, double yo, double dx, double dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tdouble dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] >= 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef complex<double> P;\ndouble det(const P &a,const P &b){\n\treturn (conj(b)*a).imag();\n}\ndouble ratio(P s1,P d1,P s2,P d2){\n\treturn det(s2-s1,d2)/det(d1,d2);\n}\nint main(){\n\tint c; cin>>c;\n\twhile(c--){\n\t\tint n,xa,ya,xb,yb,o,l; cin>>xa>>ya>>xb>>yb>>n;\n\t\tP a(xa,ya),b(xb,yb);\n\t\tvector<pair<double,int> > cross;\n\t\trep(i,n){\n\t\t\tcin>>xa>>ya>>xb>>yb>>o>>l;\n\t\t\tP c(xa,ya),d(xb,yb);\n\t\t\tdouble s=ratio(a,b-a,c,d-c),t=ratio(c,d-c,a,b-a);\n\t\t\tif(0<s&&s<1&&0<t&&t<1)cross.push_back(make_pair(s,o^l^1));\n\t\t}\n\t\tsort(cross.begin(),cross.end());\n\t\tint ans=0;\n\t\trep(i,cross.size()-1)if(cross[i].second!=cross[i+1].second)ans++;\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<set>\n#include<limits>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntemplate<typename T> bool equals(T a, T b){ return (fabs(a - b)) < EPS;};\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstatic const int NOTCROSS = 4;\nstatic const int CIRCUMSCRIBED = 3; \nstatic const int INTERSECT = 2;\nstatic const int INSCRIBED = 1;\nstatic const int INCLUDE = 0;\n\nconst double PI = acos(-1);\n\nclass Point{\npublic:\n\tdouble x, y;\n\t\n\tPoint(double x = 0, double y = 0): x(x), y(y) {}\n\tPoint(const Point &p) { x = p.x; y = p.y;};\n\t\n\tPoint operator + (const Point &p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (const Point &p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (const double &a) { return Point(x * a, y * a); }\n\tPoint operator / (const double &a) { return Point(x / a, y / a); }\n\t\n\tPoint & operator = (const Point& p) {x = p.x; y = p.y; return *this;};\n\tPoint & operator += (const Point& p) {x += p.x; y += p.y; return *this;};\n\tPoint & operator -= (const Point& p) {x -= p.x; y -= p.y; return *this;};\n\tPoint & operator *= (const Point& p) {x *= p.x; y *= p.y; return *this;};\n\tPoint & operator /= (const Point& p) {x /= p.x; y /= p.y; return *this;};\n\t\n\tbool operator < (const Point &p) const {\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\t\n\tbool operator > (const Point &p) const {\n\t\treturn x != p.x ? x > p.x : y > p.y;\n\t}\n\t\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n\t}\n\t\n\tdouble abs() { return sqrt(norm()); };\n\tdouble norm() { return x * x + y * y;};\n};\n\ntypedef Point Vector;\n\n\ndouble norm(Vector a){\n\treturn a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a, Vector b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Vector a, Vector b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Segment{\n\tPoint p1, p2;\n};\n\ntypedef Segment Line;\n\nclass Circle {\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0): c(c), r(r) {}\n};\n\ntypedef vector<Point> Polygon;\n\n\n\nbool isOrthogonal(Vector a, Vector b){\n\treturn equals(dot(a,b), 0.0);\n}\n\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2){\n\treturn isOrthogonal(a1 - a2, b1 - b2);\n}\n\nbool isOrthogonal(Segment s1, Segment s2){\n\treturn equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\n\nbool isParallel(Vector a, Vector b){\n\treturn equals(cross(a, b), 0.0);\n}\n\nbool isParallel(Point a1, Point a2, Point b1, Point b2){\n\treturn isParallel(a1 - a2, b1 - b2);\n}\n\nbool isPrallel(Segment s1, Segment s2){\n\treturn equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn s.p1 + base * r;\n}\n\nPoint reflect(Segment s, Point p){\n\treturn p + (project(s, p) - p) * 2.0;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\tif(cross(a, b) < -EPS) return CLOCKWISE;\n\tif(dot(a, b) < - EPS) return ONLINE_BACK;\n\tif(a.norm() < b.norm()) return ONLINE_FRONT;\n\t\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4){\n\treturn (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 && ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2){\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nint intersect(Circle c1, Circle c2){\n\tdouble dis = abs(c1.c - c2.c);\n\t\n\tif(dis > c1.r + c2.r + EPS) return NOTCROSS;\n\tif(fabs(dis - c1.r - c2.r) < EPS) return CIRCUMSCRIBED;\n\tif(dis > fabs(c1.r - c2.r) + EPS) return INTERSECT;\n\tif(fabs(dis - fabs(c1.r - c2.r)) < EPS) return INSCRIBED;\n\treturn INCLUDE;\n}\n\ndouble getDistance(Point a, Point b){\n\treturn abs(a - b);\n}\n\ndouble getDistanceLP(Line l, Point p){\n\treturn abs(cross(l.p2 - l.p1, p - l.p1)) / abs(l.p2 - l.p1);\n}\n\ndouble getDistanceSP(Segment s, Point p){\n\tif(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn getDistanceLP(s, p);\n}\n\ndouble getDistance(Segment s1, Segment s2){\n\tif(intersect(s1, s2)) return 0.0;\n\treturn min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)), min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n\nPoint getCrosPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\nbool intersect(Circle c, Line l){\n\treturn getDistanceLP(l, c.c) < c.r + EPS;\n}\n\npair<Point, Point> getCrossPoint(Circle c, Line l){\n\tassert(intersect(c,l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.c));\n\treturn make_pair(pr + e * base, pr - e *base);\n}\n\ndouble arg(Vector p) {return atan2(p.y, p.x);}\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) * a);}\n\n\npair<Point, Point> getCrosPoint(Circle c1, Circle c2){\n\tPoint res1, res2;\n\tint ins = intersect(c1, c2);\n\tif(ins == NOTCROSS || ins == INCLUDE) {\n\t\tassert(false); // 0\n\t}\n\tif(ins == INSCRIBED && equals(c1.r, c2.r)){\n\t\tassert(false); // infinity\n\t}\n\tdouble d = abs(c1.c - c2.c);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.c - c1.c);\n\tres1 = c1.c + polar(c1.r, t + a);\n\tres2 = c1.c + polar(c1.r, t - a);\n\treturn make_pair(res1, res2);\n}\n\n\ndouble getArea(Circle c){\n\treturn c.r*c.r*PI;\n}\n\ndouble getArea(Polygon& p){\n\tdouble area = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tarea += (p[i].x * p[(i + 1) % p.size()].y - p[(i + 1) % p.size()].x * p[i].y);\n\t}\n\t\n\treturn fabs(area)/2;\n}\n\nbool isConvex(Polygon& p){\n\tint b = 0;\n\t\n\tfor(int i = 0; i < p.size(); i++){\n\t\tint j = (i + 1) % p.size(), k = (i + 2) % p.size();\n\t\tint c = ccw(p[i], p[j], p[k]);\n\t\tif(c == ON_SEGMENT || c == ONLINE_BACK || c == ONLINE_FRONT) continue;\n\t\tif(c*b < 0) return false;\n\t\tif(!b) b = c;\n\t}\n\t\n\treturn 1;\n}\n\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N;\n\t\n\tcin>>N;\n\t\n\tfor(int _ = 0; _ < N; _++) {\n\t\tint n;\n\t\tint ans = 0;\n\t\tSegment S;\n\t\tvector<pair<double,bool>> dis;\n\t\t\n\t\t// cin>>n;\n\t\tcin>>S.p1.x>>S.p1.y>>S.p2.x>>S.p2.y;\n\t\t\n\t\tcin>>n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint o, l;\n\t\t\tbool X = true;\n\t\t\tSegment T;\n\t\t\t\n\t\t\tcin>>T.p1.x>>T.p1.y>>T.p2.x>>T.p2.y;\n\t\t\t\n\t\t\tcin>>o>>l;\n\t\t\t\n\t\t\tif(o == l) X = false;\n\t\t\t\n\t\t\tif(intersect(S, T)) {\n\t\t\t\tPoint p = getCrosPoint(S, T);\n\t\t\t\t\n\t\t\t\tdis.push_back({getDistance(S.p1, p), X});\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(dis.begin(), dis.end());\n\t\t\n\t\tfor(int i = 1; i < dis.size(); i++){\n\t\t\tif(dis[i].second != dis[i-1].second)  ans++;\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <ccomplex>\n#include <cstring>\n#include <algorithm>\n#include <tuple>\n\n#define For(i,a,b) for(int i = a;i < b; i++)\n#define rep(i,n) For(i,0,n)\n#define clr(n)\tmemset(n,0,sizeof n)\n\nusing namespace std;\n\ntypedef double d;\ntypedef complex<d> P;\ntypedef pair<P, P> L;\nconst d EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n\nd dot(P a, P b){\n\treturn (conj(a) * b).X;\n}\n\nd cross(P a, P b){\n\treturn (conj(a) * b).Y;\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS)return 1;\n\tif (cross(b, c) < -EPS)return -1;\n\tif (dot(b, c) < -EPS)return 2;\n\tif (norm(b) < norm(c))return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\n\nbool isecLL(P a1, P a2, P b1,P b2){\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nbool isecLL(L l1, L l2){\n\treturn isecLL(l1.first, l1.second, l2.first, l2.second);\n}\n\nconst int INF = 1e9;\n\nP crosspointLL(P a1, P a2, P b1, P b2){\n\td d1 = cross(b2 - b1, b1 - a1);\n\td d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0))return a1;\n\tif (EQ(d2, 0) && EQ(d2, 0))return P(INF,INF);\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\nP crosspointLL(L l1, L l2){\n\treturn crosspointLL(l1.first, l1.second, l2.first, l2.second);\n}\n\ntypedef tuple<P, int, int> T;\n\nint main(){\n\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\t\tint xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tL sl(P(xa, ya), P(xb, yb));\n\t\t\n\t\tint n;\n\t\tcin >> n;\n\n\t\tvector<L> vL;\n\t\tvector<int> vo;\n\t\tvector<int> vl;\n\n\t\trep(i, n){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\n\t\t\tvL.push_back(L(P(xs, ys), P(xt, yt)));\n\t\t\tvo.push_back(o);\n\t\t\tvl.push_back(l);\n\t\t}\n\n\t\tvector<T> vp;\n\n\t\trep(i, n){\n\t\t\tif (isecLL(sl, vL[i])){\n\t\t\t\tvp.push_back(T(crosspointLL(sl, vL[i]),vo[i],vl[i]));\n\t\t\t}\n\t\t}\n\n\t\tbool f = false;\n\t\twhile (!f){\n\t\t\tf = true;\n\t\t\trep(i, n-1){\n\t\t\t\tauto p1 = get<0>(vp[i]);\n\t\t\t\tauto p2 = get<0>(vp[i+1]);\n\t\t\t\tint dist1 = (p1.X - sl.first.X)*(p1.X - sl.first.X) + (p1.Y - sl.first.Y)*(p1.Y - sl.first.Y);\n\t\t\t\tint dist2 = (p2.X - sl.first.X)*(p2.X - sl.first.X) + (p2.Y - sl.first.Y)*(p2.Y - sl.first.Y);\n\n\t\t\t\tif (dist1 > dist2){\n\t\t\t\t\tswap(vp[i], vp[i + 1]);\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, 2){\n\t\t\tint val = 0;\n\t\t\tint sf = i;\n\t\t\trep(j, vp.size()){\n\t\t\t\tif (get<1>(vp[j]) == 1){\n\t\t\t\t\tif (get<2>(vp[j]) != sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (get<2>(vp[j]) == sf){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsf = 1 - sf;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(val, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define\tmp\t\t\tmake_pair\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef\tcomplex<double>\tPoint;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a),pb(b); }\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(real(s[0]),real(s[1]))<min(real(t[0]),real(t[1]))-EPS\n\t|| max(real(t[0]),real(t[1]))<min(real(s[0]),real(s[1]))-EPS\n\t|| max(imag(s[0]),imag(s[1]))<min(imag(t[0]),imag(t[1]))-EPS\n\t|| max(imag(t[0]),imag(t[1]))<min(imag(s[0]),imag(s[1]))-EPS)\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\trep(i,3){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t*p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint n;\nPoint A,B;\nSegment AB,S[100];\nbool own[100],loc[100];\n\nint solve(){\n\tvector< pair<double,int> > pts;\n\trep(i,n){\n\t\tPoint Q;\n\t\tif(intersect(AB,S[i],&Q))\tpts.pb(mp(abs(A-Q),i));\n\t}\n\n\tsort(pts.begin(),pts.end());\n\n\tint cnt=0,id=pts[0].second;\n\tbool now=(own[id]?loc[id]:!loc[id]);\n\tfor(int i=1;i<pts.size();i++){\n\t\tid=pts[i].second;\n\t\tif(own[id]){\n\t\t\tif(now!=loc[id]){ cnt++; now=!now; }\n\t\t}\n\t\telse{\n\t\t\tif(now==loc[id]){ cnt++; now=!now; }\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint T;\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint xa,ya,xb,yb;\tscanf(\"%d%d%d%d%d\",&xa,&ya,&xb,&yb,&n);\n\t\tA=Point(xa,ya);\n\t\tB=Point(xb,yb);\n\t\tAB=Segment(A,B);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,o,l;\tscanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&o,&l);\n\t\t\tS[i]=Segment(Point(x1,y1),Point(x2,y2));\n\t\t\town[i]=o;\n\t\t\tloc[i]=l;\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int64_t a, int64_t b, int64_t c, int64_t d, int64_t e,\n                  int64_t f, int64_t g, int64_t h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int64_t a, int64_t b, int64_t c, int64_t d, int64_t e,\n                int64_t f, int64_t g, int64_t h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int64_t n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int64_t e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a;i<b;++i)\n#define rep(i,n) REP(i,0,n)\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\nstruct P {\n  complex<double> p;\n  int h;\n  P(complex<double> p,int h) : p(p),h(h) {;}\n};\n\nnamespace std {\n  bool operator<(const P &a, const P &b) {\n    return real(a.p) != real(b.p) ? real(a.p) < real(b.p) : imag(a.p) < imag(b.p);\n  }\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ndouble cross(const P &a, const P &b) {\n  return imag(conj(a.p)*b.p);\n}\n\n//inner product\ndouble dot(const P &a, const P &b) {\n  return real(conj(a.p)*b.p);\n}\n\nint ccw(P a, P b, P c) {\n  b.p -= a.p;\n  c.p -= a.p;\n  if( cross(b, c) > 0 ) return +1; // counter clockwise\n  if( cross(b, c) < 0 ) return -1; // clockwise\n  if( dot(b, c) < 0 ) return +2;   // c--a--b on line\n  if( norm(b.p) < norm(c.p) ) return -2; // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0]) * ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0]) * ccw(t[0],t[1],s[1]) <= 0;\n}\n\n// a1,a2ツづーツ端ツ点ツづつキツづゥツ静シツ閉ェツづ1,b2ツづーツ端ツ点ツづつキツづゥツ静シツ閉ェツづ個古ーツ点ツ計ツ算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = P(b2.p-b1.p,b1.h);\n  double d1 = abs(cross(b, P(a1.p-b1.p,b1.h)));\n  double d2 = abs(cross(b, P(a2.p-b1.p,b1.h)));\n  double t = d1 / (d1 + d2);\n  return P(a1.p + (a2.p-a1.p) * t,b1.h);\n}\n\nint main() {\n  int num,n,i;\n  cin>>num;\n  while(num--) {\n    vector<L> in;\n    double xa,ya,xb,yb,sx,sy,o,l;\n    cin>>sx>>sy>>xb>>yb;\n    in.push_back(L(P(complex<double>(0,0),0),P(complex<double>(xb-sx,yb-sy),0)));\n    cin>>n;\n    rep(i,n) {\n      cin>>xa>>ya>>xb>>yb>>o>>l;\n      int h = (o == 1) ? l : (l == 1) ? 0 : 1;\n      in.push_back(L(P(complex<double>(xa-sx,ya-sy),h),\n\t\t     P(complex<double>(xb-sx,yb-sy),h)));\n    }\n\n    vector<P> cr;\n    rep(i,n) {\n      if(intersectSS(in[0],in[i+1])) {\n\tcr.push_back(intersection_ls(in[0][0],in[0][1],in[i+1][0],in[i+1][1]));\n      }\n    }\n\n    sort(cr.begin(), cr.end());\n    int ans = 0;\n    for(int i=0; i<cr.size()-1; ++i) {\n      if(cr[i].h != cr[i+1].h) {\n\tans++;\n\t//cout<<real(cr[i].p)<<\",\"<<imag(cr[i].p)<<\";\"<<cr[i].h;\n\t//cout<<\"  \"<<real(cr[i+1].p)<<\",\"<<imag(cr[i+1].p)<<\";\"<<cr[i+1].h<<endl;\n      }\n    }\n\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#include<algorithm>\n#include<array>\n#include<cassert>\n#include<cmath>\n#include<vector>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\ntypedef double Real;\nconst Real EPS = 1e-8;\nint sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\n//define class ...\n\nstruct Point {\n\tReal x, y;\n\texplicit Point(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(Real s) const { return Point(x * s, y * s); }\n\tPoint operator/(Real s) const { return Point(x / s, y / s); }\n\tbool operator<(const Point &p) const {\n\t\treturn sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1);\n\t}\n\tbool operator==(const Point &p) const {\n\t\treturn sign(x - p.x) == 0 && sign(y - p.y) == 0;\n\t}\n};\n\nstruct Entrance {\n\tReal dist;\n\tint o, l;\n\texplicit Entrance(Real dist_, int o_, int l_):dist(dist_), o(o_), l(l_) {}\n\tbool operator<(const Entrance &e) const {\n\t\treturn dist < e.dist;\n\t}\n};\n\nistream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n\treturn os << '(' << p.x << \", \" << p.y << ')';\n}\n\nstruct Line : public array<Point, 2> { //??????\n\tLine(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Segment : public array<Point, 2> { //??´???\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\nstruct Circle {\n\tPoint c;\n\tReal r;\n\tCircle(const Point &c_, Real r_): c(c_), r(r_) {}\n};\n\ntypedef vector<Point> Polygon;\n\n// define function\nPoint rotate90(const Point &p) { // ???????¨???¨???\n\treturn Point(-p.y, p.x);\n}\n\nPoint rotate(const Point &p, Real theta) {\n\tconst Real s = sin(theta), c = cos(theta);\n\treturn Point(c * p.x - s * p.y, s * p.x + c * p.y);\n}\n\nReal angle(const Point &p) {\n\treturn atan2(p.y, p.x);\n}\n\nReal norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nReal abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\nReal dot(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b) { // ??????\n\treturn a.x * b.y - a.y * b.x;\n}\n\nbool is_parallel(const Line &a, const Line &b) {\n\treturn sign( cross(a[1] - a[0], b[1] - b[0]) ) == 0;\n} \n\n// define app function\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst Real crs = cross(p, q); \n\t\n\tif(sign(crs) == 1) return CCW;\n\tif(sign(crs) == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\nPoint project(const Line &l, const Point &p) {\n\tconst Point a = p - l[0];\n\tconst Point b = l[1] - l[0];\n\treturn l[0] + b * (dot(a, b) / norm(b));\n}\n\nPoint reflect(const Line &l, const Point &p) {\n\tconst Point t = project(l, p);\n\treturn t + (t - p);\n}\n\nbool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\nbool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n\treturn abs(ccw(l[0], l[1], p)) != 1;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n\treturn sign(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0])) <= 0; \n}\n\nbool intersect(const Line &a, const Line &b) {\n\treturn sign(cross(a[1] - a[0], b[1] - b[0])) != 0\n\t\t\t|| sign(cross(a[1] - a[0], b[1] - a[0])) == 0;\n}\n\nReal dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\n\nReal dist(const Line &l, const Point &p) {\n\tconst Point a = l[1] - l[0];\n\tconst Point b = p - l[0];\t\n\treturn abs(cross(a, b)) / abs(a);\n}\n\nReal dist(const Line &l, const Segment &s) {\n\tif(intersect(l, s)) return 0;\n\treturn min(dist(l, s[0]), dist(l, s[1]));\n}\n\nReal dist(const Line &a, const Line & b) {\n\tif(intersect(a, b)) return 0;\n\treturn dist(a, b[0]);\n}\n\nReal dist(const Segment &s, const Point &p) {\n\tif(sign(dot(s[1] - s[0], p - s[0])) == -1) return dist(s[0], p);\n\tif(sign(dot(s[0] - s[1], p - s[1])) == -1) return dist(s[1], p);\n\treturn dist(Line(s[0], s[1]), p);\n}\n\nReal dist(const Segment &a, const Segment &b) {\n\tif(intersect(a, b)) return 0;\n\treturn min({dist(a, b[0]), dist(a, b[1]), dist(b, a[0]), dist(b, a[1])});\t\n}\n\nbool intersect(const Circle &a, const Circle &b) {\n\treturn sign(dist(a.c, b.c) - (a.r + b.r)) <= 0\n\t\t&& sign(dist(a.c, b.c) - abs(a.r - b.r)) >= 0;\n}\n\nbool intersect(const Circle &c, const Segment &s) {\n\treturn sign(dist(s, c.c) - c.r) <= 0;\n}\n\nbool intersect(const Circle &c, const Line &l) {\n\treturn sign(dist(l, c.c) - c.r) <= 0;\n}\n\nbool contain(const Circle &c, const Point &p) {\n\treturn sign(dist(c.c, p) - c.r) <= 0;\n}\n\nint contain(const Polygon &P, const Point &p) {\n\tbool res = 0;\n\tfor(int i = 0; i < P.size(); ++i) {\n\t\tPoint v1 = P[i] - p;\n\t\tPoint v2 = P[(i + 1) % P.size()] - p;\n\t\tif(v1.y > v2.y) swap(v1, v2);\n\n\t\tif(sign(cross(v1, v2)) == 0 && sign(dot(v1, v2)) <= 0) {\n\t\t\treturn 1; //on edge\n\t\t}\n\t\tif(sign(v1.y) <= 0 && sign(v2.y) == 1 && sign(cross(v1, v2)) == 1) {\n\t\t\tres = !res;\n\t\t}\n\t}\n\treturn (res ? 2 : 0);\n}\n\nPoint crosspoint(const Line &a, const Line &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) return a[0];\t// same line\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\n// ???????????????????????¨?????°????????§???????????????intersect????????????\nPoint crosspoint(const Segment &a, const Segment &b) {\n\tassert(intersect(a, b));\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\t\n\tif(sign(crs) == 0) { //on same line\n\t\tif(intersect(a, b[0])) return b[0];\n\t\tif(intersect(a, b[1])) return b[1];\n\t\tif(intersect(b, a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\nvector<Point> crosspoint(const Circle &c, const Line &l) {\n\tconst Point p = project(l, c.c);\n\tconst Real h = dist(p, c.c);\n\n\tvector<Point> res;\n\tif(sign(h - c.r) == 1) {\n\t\t// nothing\n\t}\n\telse if(sign(h - c.r) == 0) {\n\t\tres.emplace_back(p);\n\t}\n\telse {\n\t\tconst Real b = sqrt(c.r * c.r - h * h);\n\t\tconst Point e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\t\tres.emplace_back(p + e * b);\n\t\tres.emplace_back(p - e * b);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &c, const Segment &s) {\n\tvector<Point> res;\n\tfor(const Point &p : crosspoint(c, Line(s[0], s[1]))) {\n\t\tif(intersect(s, p)) res.emplace_back(p);\n\t}\n\treturn res;\n}\n\nvector<Point> crosspoint(const Circle &a, const Circle &b) {\n\tif(!intersect(a, b)) return vector<Point>();\n\tvector<Point> res;\n\tconst Real d = dist(a.c, b.c);\n\n\tif(sign(d - (a.r - b.r)) == 0) {\n\t\tconst Point v = b.c - a.c;\n\t\tres.emplace_back(a.c + (v * (a.r / abs(v))));\n\t}\n\telse {\n\t\tconst Real theta = acos((a.r * a.r + d * d - b.r * b.r) / (2 * a.r * d));\n\t\tconst Real phi = angle(b.c - a.c);\n\t\tres.emplace_back(a.c + rotate(Point(a.r, 0), phi + theta));\n\t\tres.emplace_back(a.c + rotate(Point(a.r, 0), phi - theta));\n\t}\n\treturn res;\n}\n\nint main() {\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tint T; \n\tcin >> T;\n\trep(nth, T)\t {\n\t\tPoint a, b, s, t;\n\t\tint n, o, l;\t\n\t\tcin >> a >> b;\n\t\tcin >> n;\n\n\t\tSegment s0 = Segment(a, b);\t\n\t\tvector<Entrance> res;\t\n\t\trep(i, n) {\n\t\t\tcin >> s >> t;\n\t\t\tcin >> o >> l;\n\t\t\tSegment si = Segment(s, t);\n\t\t\tif(!intersect(s0, si)) continue;\n\t\t\tPoint c = crosspoint(s0, si);\t\n\t\t\tres.push_back(Entrance(dist(a, c), o, l));\t\t\t\n\t\t}\n\n\t\tsort(ALL(res));\n\n\t\tint ans = 0;\t\n\t\tif(res.size() != 0) {\n\t\t\tint prev = (res[0].o == 1) ? res[0].l : !res[0].l;\n\t\t\tREP(i, 1, res.size()) {\n\t\t\t\tif((res[i].o == 1 && res[i].l != prev) || (res[i].o == 0 && res[i].l == prev)) {\n\t\t\t\t\t++ans;\t\n\t\t\t\t\tprev = !prev;\n\t\t\t\t}\t\n\t\t\t}\n\t\t} \t\n\t\tcout << ans << endl;\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nbool intersectCL(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\nint main(){\n\tint z;\n\tcin>>z;\n\twhile(z--){\n\t\tL l(pin(),pin());\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<pair<P,int> >in;\n\t\twhile(n--){\n\t\t\tL t(pin(),pin());\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tif(intersectSS(l,t)){\t\t\t\t\n\t\t\t\tin.pb(pair<P,int>(crosspointSS(l,t),a^b));\n\t\t\t}\n\t\t}\n\t\tsort(all(in));\n\t\tif(in.size()<2)cout<<0<<endl;\n\t\telse{\n\t\t\tint co=0;\n\t\t\trep(i,in.size()-1)if(in[i].second!=in[i+1].second)co++;\n\t\t\tcout<<co<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\n// const ll LLINF = (1LL<<60);\n// const int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  // if (abs(A) < EPS) return ;\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int T;\n  cin >> T;\n  REP(_, T) {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n    if(ax > bx) swap(ax,bx), swap(ay,by);\n    L line(P(ax,ay), P(bx,by));\n\n    // 交点の位置とその交点が高架か地下か\n    vector<pair<P, int>> po;\n    int n;\n    cin >> n;\n    REP(i, n) {\n      int xs, ys, xt, yt, o, l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      L l2(P(xs,ys), P(xt,yt));\n      P c = crosspoint(line, l2);\n      if(ax > c.real() || c.real() > bx) continue;\n      po.PB({c, o^l});\n    }\n    sort(ALL(po));\n    // cout << po << endl;\n    int ret = 0;\n    FOR(i, 1, po.size()) {\n      if(po[i].second != po[i-1].second) ret++;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\ntypedef vector<P> G;\nG readG(int n){\n  double x,y;\n  G g;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n  }\n  return g;\n}\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\n// a < b : -1, a > b : 1, a == b : 0\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\nP crosspointSS(L &l1,L &l2) {\n  double d1 = abs(cross(l2.v, l1[0] - l2[0])); // l1.a - l2.b???\n  double d2 = abs(cross(l2.v, l1[1] - l2[0]));\n  double t = d1 / (d1 + d2);\n  return l1[0] + t * l1.v;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m,x,y,x2,y2;\n  cin >> n;\n  int o,h;\n  rep(i,n){\n    cin >> x >> y >> x2 >> y2;\n    P a(x,y),b(x2,y2);\n    L l(a,b);\n    if(b < a) l = L(b,a);\n    cin >> m;\n    vector<pair<P,pair<int,int>>> ab;//a[i](crosspoint,h)\n    rep(j,m){\n      cin >> x >> y >> x2 >> y2;\n      P a(x,y),b(x2,y2);\n      L t(a,b);\n      if(b < a) t = L(b,a);\n      cin >> o >> h;\n      if(intersectSS(l,t)){\n        P p = crosspointSS(l,t);\n        ab.push_back(mp(p,mp(o,h)));\n      }\n    }\n    sort(all(ab));\n    int s = 0;\n    if(ab[0].se.se){\n      s = ab[0].se.fi;\n    }\n    else{\n      s = !ab[0].se.fi;\n    }\n    int cnt = 0,u = 1;\n    REP(u,1,ab.size()){\n      o = ab[u].se.fi,h = ab[u].se.se;\n      if(o && s != h){\n        ++cnt;\n        s = h;\n      }\n      else if(!o && s == h){\n        ++cnt;\n        s = !h;\n      }\n    }\n    cout << cnt << endl;\n    // ???????????¨??´?????¨????????¨????????????????????????\n    // ???????§??????¨????????¨?????????????????¢???????°??????????????????????????????°????????¶?????????????????????????????????????????????\n    // ????????????????????????????????¨??¶?????????????????????h = !h???ans++\n    // ??????????????¨??¶???????????????\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint crs(double x1, double y1, double x2, double y2) {\n    double z = x1*y2-y1*x2;\n    return (0 < z ? 1 : (z < 0 ? -1 : 0));\n}\n\nbool intersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (0 <= crs(x2-x1, y2-y1, x3-x1, y3-y1) * crs(x2-x1, y2-y1, x4-x1, y4-y1)) return false;\n    if (0 <= crs(x4-x3, y4-y3, x1-x3, y1-y3) * crs(x4-x3, y4-y3, x2-x3, y2-y3)) return false;\n    return true;\n}\n\npair<double,double> intersection(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4) {\n    if (x3 == x4) {\n        swap(x1, x3); swap(y1, y3); swap(x2, x4); swap(y2, y4);\n    }\n    double x, y, a, b, c, d;\n    if (x1 == x2) {\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = x1;\n        y = c*x+d;\n    } else {\n        a = (y2-y1)/(x2-x1);\n        b = y1-a*x1;\n        c = (y4-y3)/(x4-x3);\n        d = y3-c*x3;\n        x = (d-b)/(a-c);\n        y = a*x+b;\n    }\n    return make_pair(x,y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    while (N--) {\n        double xa, ya, xb, yb;\n        int n;\n        cin >> xa >> ya >> xb >> yb >> n;\n        bool vertical = abs(xa-xb) < abs(ya-yb);\n\n        double xs, ys, xt, yt;\n        int o, l;\n        vector<pair<double,int> > levels;\n        for (int i=0; i<n; ++i) {\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            if (intersect(xa, ya, xb, yb, xs, ys, xt, yt)) {\n                if (vertical) {\n                    double y = intersection(xa, ya, xb, yb, xs, ys, xt, yt).second;\n                    levels.push_back(make_pair(y, o==1 ? l : 1-l));\n                } else {\n                    double x = intersection(xa, ya, xb, yb, xs, ys, xt, yt).first;\n                    levels.push_back(make_pair(x, o==1 ? l : 1-l));\n                }\n            }\n        }\n\n        sort(levels.begin(), levels.end());\n        int res = 0;\n        for (int i=1; i<(int)levels.size(); ++i) {\n            if (levels[i].second != levels[i-1].second) {\n                res ++;\n            }\n        }\n\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X real()\n#define Y imag()\n#define z 0.00000001\n#define INF 1e9\nusing namespace std;\ntypedef complex <double> point;\n\n\ndouble cross(point a,point b){\n  return a.X*b.Y-a.Y*b.X;\n}\n\ndouble dot(point a,point b){\n  return a.X*b.X+a.Y*b.Y;\n}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)-z>0) return 1;//\"COUNTER_CLOCKWISE\"\n  if(cross(d,e)+z<0) return -1;//\"CLOCKWISE\"\n  if(dot(d,e)<z) return 2;//\"ONLINE_BACK\"\n  if(abs(d)-abs(e)<z) return -2;//\"ONLINE_FRONT\"\n  return 0;//\"ON_SEGMENT\"\n}\n\n\npoint CrossPoint(point a,point b,point c,point d){\n  point base=d-c;\n  double d1=abs(cross(base,(a-c)));\n  double d2=abs(cross(base,(b-c)));\n  double t=d1/(d1+d2);\n  point e=(b-a)*t+a;\n  if(!ccw(a,b,e)&&!ccw(c,d,e)) return e;\n  return  point(INF,INF);\n}\n\n\nint main(){\n  /*  int a,b,c,d,e,f,g,h;\n  cin>>a>>b>>c>>d>>e>>f>>g>>h;\n  point res=CrossPoint(point(a,b),point(c,d),point(e,f),point(g,h));\n  cout <<res.X<<\" \"<<res.Y<<endl;*/\n\n  int q;\n  cin>>q;\n  while(q--){\n    int sx,sy,gx,gy,o[101],l[101];\n    cin>>sx>>sy>>gx>>gy;\n    int n;\n    cin>>n;\n    \n    point D[101];\n    for(int i=0,a,b,c,d;i<n;i++){\n      cin>>a>>b>>c>>d>>o[i]>>l[i];\n      D[i]=CrossPoint(point(sx,sy),point(gx,gy),point(a,b),point(c,d));\n      if(D[i].X==INF)i--,n--;\n    }\n\n\n    for(int i=0;i<n-1;i++)\n      for(int j=n-1;j>i;j--)\n\tif(abs(D[j]-point(sx,sy))<abs(D[j-1]-point(sx,sy))){\n\t  swap(D[j],D[j-1]);\n\t  swap(o[j],o[j-1]);\n\t  swap(l[j],l[j-1]);\n\t}\n    \n    int ans=0;\n    bool pos=l[0];\n    if(!o[0]) pos =!pos;\n    for(int i=1;i<n;i++) {\n      if(o[i]&&pos!=l[i])pos=!pos,ans++;\n      if(!o[i]&&pos==l[i])pos=!pos,ans++;\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-5;\n\nvoid foo(ll& x, ll& y, ll xo, ll yo, ll dx, ll dy) {\n\tll _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<ll> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (double)(yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 - EPS || x > r + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define CIRCLE_SAME 0x01\n#define CIRCLE_CONTAIN 0x02\n#define CIRCLE_NO_CROSS 0x04\n#define CIRCLE_ONE_CROSS 0x08\n#define CIRCLE_ONE_INSIDE_CROSS 0x10\n#define CIRCLE_TWO_CROSS 0x20\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\n// _Iy[^\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(lt(ret,0))ret+=2*pi;\n  if(gt(ret,2*pi))ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  // if( is_zv(b) || is_zv( x ) ) return ERROR;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\n// üªÌð·»è\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nelem areaOfPolygon(const vector<point> &vp){\n  elem ret = 0;\n  for(int i = 0; i < vp.size(); ++i){\n    ret += cross(vp[i],vp[(i+1)%vp.size()]);\n  }\n  return ret/2.0;\n}\n\nstruct Line{\n  seg s;\n  int o;\n  int l;\n  Line(seg s, int o, int l):s(s),o(o),l(l){}\n  Line(){}\n};\n\nstruct Exit{\n  int l;\n  int o;\n  elem distA;\n  bool operator<(const Exit &t)const{\n    return lt(distA,t.distA);\n  }\n};\n\nint minimumExits(int la, const point &A,\n\t\t  int lb, const point &B,\n\t\t  const vector<Line> &vl)\n{\n  int ret=0;\n  seg s(A,B);\n  vector<Exit> vexit;\n  for(int i = 0; i < vl.size(); ++i){\n    point tmp;\n    if(intersectionSS(s,vl[i].s,tmp)){\n      Exit exit;\n      exit.o = vl[i].o;\n      exit.l = vl[i].l;\n      exit.distA = abs(tmp-A);\n      vexit.push_back(exit);\n    }\n  }\n\n  sort(vexit.begin(),vexit.end());\n  int nowl=la;\n  for(int i = 0; i < vexit.size(); ++i){\n    if( vexit[i].l == nowl ){\n      if( vexit[i].o == 0 ){\n\t++ret;\n\tnowl = vexit[i].l?0:1;\n      }\n    }else{\n      if( vexit[i].o == 1 ){\n\t++ret;\n\tnowl = vexit[i].l;\n      }\n    }\n  }\n  if(nowl!=lb)++ret;\n  return ret;\n}\n\nint main(){\n  int T;\n  cin >> T;\n  for(int tc=1;tc<=T;++tc){\n    int res=1<<28;\n    elem xa,ya,xb,yb;\n    cin >> xa >> ya >> xb >> yb;\n    point A(xa,ya);\n    point B(xb,yb);\n    int N;\n    cin >> N;\n    vector<Line> vl;\n    for(int i = 0; i < N; ++i){\n      elem xs,ys,xg,yg;\n      int o,l;\n      cin >> xs >> ys >> xg >> yg;\n      cin >> o >> l;\n      point start(xs,ys);\n      point goal(xg,yg);\n      vl.push_back( Line(seg(start,goal),o,l) );\n    }\n    for(int la=0;la<2;++la){\n      for(int lb=0;lb<2;++lb){\n\tres= min(res,minimumExits(la,A,lb,B,vl));\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <complex>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\n\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n// ??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n\treturn abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n\n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\n\t\tdouble sy, sx, gy, gx;\n\t\tcin >> sx >> sy >> gx >> gy;\n\n\t\tL sl(pair<P,P>(P(sx,sy),P(gx,gy)));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\ttypedef pair<L, pair<int, int>> LL;\n\t\tvector<LL> l;\n\n\t\trep(i, n){\n\t\t\tcin >> sx >> sy >> gx >> gy;\n\t\t\tint o, tl;\n\t\t\tcin >> o >> tl;\n\n\t\t\tLL t;\n\n\t\t\tP tp1(sx,sy),tp2(gx,gy);\n\t\t\tt.first.first = tp1;\n\t\t\tt.first.second = tp2;\n\n\t\t\tt.second.first = o;\n\t\t\tt.second.second = tl;\n\n\t\t\tl.push_back(t);\n\t\t}\n\t\tvector<int> vo, vl;\n\t\tvector<P> point;\n\n\t\trep(i, l.size()){\n\t\t\tauto lp1 = l[i].first.first;\n\t\t\tauto lp2 = l[i].first.first;\n\t\t\tauto data = l[i].second;\n\n\t\t\tif (isecLL(sl.first, sl.second, lp1, lp2)){\n\t\t\t\tauto p = crosspointLL(sl.first, sl.second, lp1, lp2);\n\t\t\t\tpoint.push_back(p);\n\t\t\t\tvo.push_back(data.first);\n\t\t\t\tvl.push_back(data.second);\n\t\t\t}\n\t\t}\n\n\t\tbool f = true;\n\t\twhile (f){\n\t\t\tf = false;\n\t\t\trep(i, point.size() - 1){\n\t\t\t\tdouble x, y, tx, ty;\n\t\t\t\tx = point[i].imag(); y = point[i].real();\n\t\t\t\ttx = point[i+1].imag(); ty = point[i+1].real();\n\t\t\t\tdouble l1 = (x - sx) * (x - sx) + (y - sy) * (y - sy), l2 = (tx - sx) * (tx - sx) + (ty - sy) * (ty - sy);\n\n\t\t\t\tif (l1 > l2){\n\t\t\t\t\tswap(point[i], point[i + 1]);\n\t\t\t\t\tswap(vo[i], vo[i + 1]);\n\t\t\t\t\tswap(vl[i], vl[i + 1]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(j, 2){\n\t\t\tint val = 0;\n\t\t\tint sj = j;\n\t\t\trep(i, point.size()){\n\n\t\t\t\tif (vo[i] == 1){\n\t\t\t\t\tif (vl[i] != sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = vl[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vo[i] == 0){\n\t\t\t\t\tif (vl[i] == sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = (1-sj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans = min(ans, val);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nusing real = double;\nreal EPS = 1e-10;\nstruct Point {\n    real x, y;\n    Point& operator+=(const Point a) { x += a.x; y += a.y;  return *this; }\n    Point& operator-=(const Point a) { x -= a.x; y -= a.y;  return *this; }\n    Point& operator*=(const real k) { x *= k; y *= k;  return *this; }\n    Point& operator/=(const real k) { x /= k; y /= k;  return *this; }\n    Point operator+(const Point a) const {return Point(*this) += a; }\n    Point operator-(const Point a) const {return Point(*this) -= a; }\n    Point operator*(const real k) const {return Point(*this) *= k; }\n    Point operator/(const real k) const {return Point(*this) /= k; }\n    bool operator<(const Point &a) const { return (x != a.x ? x < a.x : y < a.y); }\n    explicit Point(real a = 0, real b = 0) : x(a), y(b) {};\n};\n\nistream& operator>> (istream& s, Point& P){\n    s >> P.x >> P.y;\n    return s;\n}\n\ninline real dot(Point a, Point b){ return a.x*b.x + a.y*b.y; }\ninline real cross(Point a, Point b){ return a.x*b.y - a.y*b.x; }\ninline real abs(Point a){ return sqrt(dot(a, a)); }\n\nstatic constexpr int COUNTER_CLOCKWISE = 1;\nstatic constexpr int CLOCKWISE = -1;\nstatic constexpr int ONLINE_BACK = 2;\nstatic constexpr int ONLINE_FRONT = -2;\nstatic constexpr int ON_SEGMENT = 0;\n\nint ccw(Point a, Point b, Point c){\n    b -= a; c -= a;\n    if(cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(b, c) < EPS) return CLOCKWISE;\n    if(dot(b, c) < 0) return ONLINE_BACK;\n    if(abs(b) < abs(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\nstruct Segment {\n    Point a, b;\n    Segment(Point x, Point y) : a(x), b(y) {};\n};\n\ndouble distance(Segment l, Point c){\n    if(dot(l.b-l.a, c-l.a) < EPS) return abs(c-l.a);\n    if(dot(l.a-l.b, c-l.b) < EPS) return abs(c-l.b);\n    return abs(cross(l.b-l.a, c-l.a)) / abs(l.a-l.b);\n}\n\nbool intersect(Segment l1, Segment l2){\n    return (ccw(l1.a, l1.b, l2.a)*ccw(l1.a, l1.b, l2.b) <= 0 &&\n            ccw(l2.a, l2.b, l1.a)*ccw(l2.a, l2.b, l1.b) <= 0);\n}\n\nPoint crossPoint(Segment l1, Segment l2){\n    real d1 = abs(cross(l1.b-l1.a, l2.b-l2.a));\n    real d2 = abs(cross(l1.b-l1.a, l1.b-l2.a));\n    if(d1 < EPS && d2 < EPS) return l2.a;\n    return l2.a+(l2.b-l2.a)*d2/d1;\n}\n\nint main() {\n    int q; cin >> q;\n    while(q--){\n        Point A, B; cin >> A >> B;\n        Segment X(A, B);\n        int n;\n        cin >> n;\n        vector<pair<real, int>> v;\n        for (int i = 0; i < n; ++i) {\n            Point P, Q; int o, l;\n            cin >> P >> Q >> o >> l;\n            Segment L(P, Q);\n            if(intersect(X, L)){\n                v.emplace_back(abs(crossPoint(X, L)-A), o^l^1);\n            }\n        }\n        sort(v.begin(),v.end());\n        int ans = INF<int>;\n        for (int k = 0; k <= 1; ++k) {\n            int cnt = 0, p = k;\n            for (auto & i : v) {\n                if(p != i.second) p ^= 1, cnt++;\n            }\n            ans = min(ans, cnt);\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\n/**************************************************************/\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n\n// ???\nclass Point {\npublic:\n\tdouble x, y;\n    int affi;\n    bool isGround;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n\n\tPoint operator + (Point p) {\n\t\treturn Point(x + p.x, y + p.y);\n\t}\n\tPoint operator - (Point p) {\n\t\treturn Point(x - p.x, y - p.y);\n\t}\n\tPoint operator * (double c) {\n\t\treturn Point(c * x, c * y);\n\t}\n\tPoint operator / (double c) {\n\t\treturn Point(x / c, y / c);\n\t}\n\tbool operator < (const Point &p) {\n\t\treturn (x != p.x ? x < p.x : y < p.y);\n\t}\n\tbool operator == (const Point &p) {\n\t\treturn (fabs(x - p.x) < EPS && fabs(y - p.y) < EPS);\n\t}\n\tbool operator != (const Point &p) {\n\t\treturn (fabs(x - p.x) > EPS || fabs(y - p.y) > EPS);\n\t}\n\n\t// ?????????\n\tdouble norm() {\n\t\treturn (x * x + y * y);\n\t}\n\t// ??§??????\n\tdouble abs() {\n\t\treturn sqrt(norm());\n\t}\n};\n\n// ????????????\ntypedef Point Vector;\n\n// ??????\ndouble dot(Vector a, Vector b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\n// ??????\ndouble cross(Vector a, Vector b) {\n\treturn (a.x * b.y - a.y * b.x);\n}\n\n// ?????????\ndouble norm(Vector a) {\n\treturn (a.x * a.x + a.y * a.y);\n}\n\n// ??§??????\ndouble abs(Vector a) {\n\treturn sqrt(norm(a));\n}\n\n// ??????\nclass Segment {\npublic:\n\tPoint p1, p2;\n\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\n\n// ??´???\ntypedef Segment Line;\n\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\t// ???????¨???????\n\tif (cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n\t// ????¨???????\n\tif (cross(a, b) < -EPS) return CLOCKWISE;\n\t// p1??¨p2???p0???????????§??´??????\n\tif (dot(a, b) < -EPS) return ONLINE_BACK;\n\t// p1??¨p2?????´??????????????????p0?????????????????????????????? abs(p2 - p0) > abs(p1 - p0)\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\t// ??????????§????????????? abs(p1 - p0) >= abs(p2 - p0)\n\treturn ON_SEGMENT;\n}\n\n// ??????ab??¨??????cd???????????????\nbool intersect(Point a, Point b, Point c, Point d) {\n\treturn (ccw(a, b, c) * ccw(a, b, d) <= 0 && ccw(c, d, a) * ccw(c, d, b) <= 0);\n}\n\nbool intersect(Segment s1, Segment s2) {\n\treturn intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\n// ??´???s??¨???p????????¢\ndouble distL(Line l, Point p) {\n\treturn abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n\n// ??????s??¨???p????????¢\ndouble distS(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n\treturn distL(s, p);\n}\n\n// ??????s1??¨??????s2????????¢\ndouble distSS(Segment s1, Segment s2) {\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min(min(distS(s1, s2.p1), distS(s1, s2.p2)), min(distS(s2, s1.p1), distS(s2, s1.p2)));\n}\n\n// ??????s1, s2?????????\nPoint crossPoint(Segment s1, Segment s2) {\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1 / (d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n/***********************************************************************/\n\nint d, n, sx, sy, gx, gy, o, l, c;\nvector<Point> p;\nSegment line, tmp;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> d;\n    while (d--) {\n        cin >> line.p1.x >> line.p1.y >> line.p2.x >> line.p2.y;\n        cin >> n;\n        c = 0;\n        for (int i = 0; i < n; ++i) {\n            cin >> sx >> sy >> gx >> gy >> o >> l;\n            tmp = Segment(Point(sx, sy), Point(gx, gy));\n            if (intersect(line, tmp)) {\n                p.push_back(crossPoint(line, tmp));\n                p[c].affi = o;\n                p[c].isGround = bool(l);\n                c++;\n\t\t\t\t//cout << p[c-1].x << \" \" << p[c-1].y << endl;\n            }\n        }\n\n        sort(p.begin(), p.end());\n\n        int size_ = p.size(), ans = 0, pos = -1;\n\n        for (int i = 0; i < size_; ++i) {\n            if (pos == -1) {\n                if (p[i].affi == 1) pos = p[i].isGround;\n\t\t\t\telse pos = !p[i].isGround;\n            }\n            else {\n                if (p[i].affi == 1 && p[i].isGround != pos) {\n                    pos = p[i].isGround;\n                    ans++;\n                }\n                else if (p[i].affi == 0 && p[i].isGround == pos) {\n                    pos = !p[i].isGround;\n                    ans++;\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n        ans = 0;\n        p.clear();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\tvoid make(){ cin>>x>>y;}\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n\tvoid make(){ s.make(); e.make();}\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\t\ntypedef pair<line,int> msp;\ntypedef pair<point,int> mmp;\nint solve(vector<msp> &l,line s){\n\tvector<mmp> a;\n\tfor(int i=0;i<l.size();i++){\n\t\tif(intersect(l[i].first,s) ){\n\t\t\ta.push_back( mmp( crosspoint(l[i].first,s), l[i].second)  ) ;\n\t\t}\n\t}\n\tsort(a.begin(),a.end());\n\tint s1 = 0,s2 = 1;\n\tint cnt1 = 0,cnt2 = 0;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(s1 != a[i].second){\n\t\t\ts1 = a[i].second;\n\t\t\tcnt1++;\n\t\t}\n\t\tif(s2 != a[i].second){\n\t\t\ts2 = a[i].second;\n\t\t\tcnt2++;\n\t\t}\n\t}\n\treturn min(cnt1,cnt2);\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tline s;\n\t\ts.make();\n\t\t//cout<<\"ok\"<<endl;\n\t\t//s.print();\n\t\tint m;\n\t\tcin>>m;\n\t\tvector<msp> l(m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tl[i].first.make();\n\t\t//\tcout<<i<<endl;\n\t\t//\tl[i].first.print();\n\t\t\tint o,h;\n\t\t\tcin>>o>>h;\n\t\t\tl[i].second = o^h;\n\t\t}\n\t\tcout<<solve(l,s)<<endl;\n\t\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef pair<double, int> DI;\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079 Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035 Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n点と\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t線分と点の包含判定\n\n\t説明\n\t\t線分が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\n// (A)\n// TODO\n// (B)\nbool cover(const segment<double> &S, const point<double> &p ){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t線分と線分の交点\n\n\t説明\n\t\t線分と線分の交点を求める\n\t\t(A)（線分を特徴付ける点の）座標値が整数\n\t\t(B)（線分を特徴付ける点の）座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\tS1 と S2 の交点\n\t制約\n\t\t二線分は交点を持つこと（ intersect(segment, segment ) で判定できる）\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\n// (A)\n// todo\n// (B)\npoint<double> get_intersect(const segment<double> &S1, const segment<double> &S2 ){\n\tdouble a1=cross(S1.b-S1.a,S2.b-S2.a);\n\tdouble a2=cross(S1.b-S1.a,S1.b-S2.a);\n\tif (abs(a1)<EPS){\n\t\tif(cover(S1,S2.a) ) return S2.a;\n\t\tif(cover(S1,S2.b) ) return S2.b;\n\t\tif(cover(S2,S1.a) ) return S1.a;\n\t\treturn S1.b;\n\t} // end if\n\treturn S2.a+a2/a1*(S2.b-S2.a);\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2003\", \"r\", stdin );\n\tint m;\n\tscanf (\"%d\", &m );\n\twhile (m--){\n\t\tsegment<double> l1;\n\t\tscanf (\"%lf %lf %lf %lf\", &l1.a.x, &l1.a.y, &l1.b.x, &l1.b.y ); \n\t\tint ans = 0;\n\t\tint n;\n\t\tscanf (\"%d\", &n );\n\t\tvector<DI> cr; cr.clear();\n\t\trep (i, n ){\n\t\t\tsegment<double> l2;\n\t\t\tint o, l;\n\t\t\tscanf (\"%lf %lf %lf %lf %d %d\", &l2.a.x, &l2.a.y, &l2.b.x, &l2.b.y, &o, &l );\n\t\t\tif (intersect (l1, l2 ) ){\n\t\t\t\tpoint<double> p = get_intersect (l1, l2 );\n\t\t\t\tdouble d = dist (l1.a, p );\n\t\t\t\tif (!o ){\n\t\t\t\t\tif (l == 1 ){\n\t\t\t\t\t\tl = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl = 1;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t\tcr.push_back (DI(d, l ) );\n\t\t\t} // end if \t\n\t\t} // end rep\n\t\tif (cr.size() > 0 ){\n\t\t\tsort (ALL (cr ) );\n\t\t\tint l = cr[0].second;\n\t\t\tfor (int i = 1; i < cr.size(); i++ ){\n\t\t\t\tif (l != cr[i].second ){\n\t\t\t\t\tans++;\n\t\t\t\t\tl = cr[i].second;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end if\n\t\tprintf (\"%d\\n\", ans );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)<<\" \"\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace geo{\n    const double EPS = 1e-9;\n    typedef double PT;typedef complex<PT> P;\n    typedef P vecP;typedef vector<P> Polygon;\n\n    template<typename T>bool LT(T a,T b){return a+EPS<b;}\n    template<typename T>bool GT(T a,T b){return LT(b,a);}\n    template<typename T>bool EQ(T a,T b){return !LT(a,b) && !GT(a,b);}\n\n    namespace VU{\n            static PT x(const vecP& a){return real(a);}\n            static PT y(const vecP& a){return imag(a);}\n            \n            // ベクタの長さ\n            static PT length(const vecP& a){return abs(a);}\n            // 単位ベクトル\n            static vecP unit_vector(const vecP& a){return a / abs(a);}\n            // 法線ベクトル\n            static pair<vecP,vecP> normal_vector(const vecP& a){return make_pair(a * vecP(0,1),a * vecP(0,-1));}\n            // 内積 (dot product) : a・b = |a||b|cosΘ\n            PT dot(const vecP& a,const vecP& b){return x(conj(a)*b);}\n            // 外積 (cross product) : |a×b| = |a||b|sinΘ\n            PT cross(const vecP& a,const vecP& b){return y(conj(a)*b);}\n            //点aと点bの距離\n            static PT dist(const P& a,const P& b){return abs(a-b);}\n\n            // 点の進行方向\n            int ccw(P a,P b,P c){\n                b -= a;c -= a;\n                if(LT(cross(b,c),0.0)) return +1;    // counter clockwise\n                if(GT(cross(b,c) ,0.0)) return -1;    // clockwise\n                if(EQ(dot(b,c),0.0)) return +2;      // c -- a -- b\n                if(norm(b) < norm(c)) return -2; // a -- b -- c\n                return 0;\n            }\n\n    }\n    using namespace VU;\n};\nusing namespace geo;\nnamespace std{\n    bool operator <(const P &lhs,const P &rhs){\n        if(x(lhs) == x(rhs))return y(lhs) < y(rhs);\n        return x(lhs) < x(rhs);\n    }\n}\n\nnamespace geo{\n    struct L{\n        P p1,p2;\n        L(P p1,P p2):p1(p1),p2(p2){}\n        vecP vec(){\n            return p2-p1;\n        }\n        //点との距離\n        double line_dist(const P& b){\n            return abs(cross(vec(),b-p1)) / abs(vec());\n        }\n        double linesegment_dist(const P& b){\n                if(EQ(dot(p2-p1,b-p1),0.0)) return abs(b-p1);\n                if(EQ(dot(p1-p2,b-p2) ,0.0)) return abs(b-p2);\n                return line_dist(b);\n        }\n        double linesegment_dist(L& b){\n            if(is_intersected(b))return 0;\n            return min(min( linesegment_dist(b.p1),linesegment_dist(b.p2) ),\n            min(b.linesegment_dist(p1),b.linesegment_dist(p2)));\n        }\n\n             //線分同士の交差判定\n        bool is_intersected(L& b){\n            if(LT(max(x(p1),x(p2)),min(x(b.p1),x(b.p2)))) return false;\n            if(LT(max(x(b.p1),x(b.p2)),min(x(p1),x(p2)))) return false;\n            if(LT(max(y(p1),y(p2)),min(y(b.p1),y(b.p2)))) return false;\n            if(LT(max(y(b.p1),y(b.p2)),min(y(p1),y(p2)))) return false;\n            return cross(vec(),b.p1-p1)*cross(vec(),b.p2-p1)<EPS  && cross(b.vec(),p1-b.p1)*cross(b.vec(),p2-b.p1)<EPS ;\n        }\n\n        bool is_intersected_line(L& b) {\n            return !is_parallel(b);\n        }\n\n        P intersection_point(L& b) {\n            return p1 + vec() * cross(b.vec(), b.p1-p1) / cross(b.vec(), vec());\n        }\n        // 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n        // みけんしょう\n        bool is_orthogonal(L& b) {return EQ(dot(vec(),b.vec()),0.0);}\n        // 2直線の平行判定 : a//b <=> cross(a, b) = 0\n        bool is_parallel(L& b) {return EQ(cross(vec(),b.vec()),0.0);}\n\n        // 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\n        P nearest_point_line(P b){\n            return p1 + vec() * dot(vec(),b-p1) / norm(vec());\n        }\n        // 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\n        P nearest_point_linesegment(P b){\n            if(EQ(dot(vec(),b-p1),0.0)) return p1;\n            if(EQ(dot(vec(),b-p2),0.0)) return p2;\n            return nearest_point_line(b);\n        }\n    };\n}\n\nint INF=1<<28;\nint main(){\n\tint C;cin >> C;\n\twhile(C--!=0){\n\t\tint xa,ya,xb,yb;cin >> xa >> ya >> xb >> yb;\n\t\tL base(P(xa,ya),P(xb,yb));\n\t\tint n;cin >> n;\n\t\tvector<pair<pair<P,int>,int>> inps;\n\t\tREP(i,n){\n     \t\t\tint xs,ys,xt,yt,o,l;cin >> xs >> ys >> xt >> yt >>o >> l;\n\t\t\tL line=L(P(xs,ys),P(xt,yt));\n\t\t\tif(base.is_intersected(line))inps.push_back(make_pair(make_pair(base.intersection_point(line),o),l));\n\t\t}\n\t\tsort(ALL(inps));\n                        int prev=-1;\n                        {\n                            int o=inps[0].first.second,l=inps[0].second;\n                            if(o)prev=l;else prev=!l;\n                        }\n                        int res=0;\n                        for(int i=1;i<inps.size();i++){\n                            int o=inps[i].first.second,l=inps[i].second;\n                            if(o){\n                                if(prev!=l)res++;\n                                prev=l;\n                            }else{\n                                if(prev!=!l)res++;\n                                prev=!l;\n                            }\n                        }\n                        cout <<res<<endl;\n            }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double>Point;\n\nstruct Segment{\n    Point p1,p2;\n    Segment(const Point &p1=Point(),const Point &p2=Point()):p1(p1),p2(p2){}\n};\n\nstruct Circle{\n    Point p;\n    double r;\n    Circle(const Point &p=Point(),double r=0.0):p(p),r(r){}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point>Polygon;\n\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst double INF=1e16;\nconst int COUNTER_CLOCKWISE=1;\nconst int CLOCKWISE=-1;\nconst int ONLINE_BACK=2;\nconst int ONLINE_FRONT=-2;\nconst int ON_SEGMENT=0;\n\ninline double square(double a){return a*a;}\ninline double norm(const Point &a){return square(a.real())+square(a.imag());}\ninline double dot(const Point &a,const Point &b){return (conj(a)*b).real();}\ninline double cross(const Point &a,const Point &b){return (conj(a)*b).imag();}\ninline double toDeg(double t){return t/PI*180.0;}\ninline double toRad(double t){return t/180.0*t;}\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nvoid getPoint(Point &p){\n    double x,y;\n    scanf(\"%lf%lf\",&x,&y);\n    p=Point(x,y);\n}\n\nvoid getSegment(Segment &s){\n    getPoint(s.p1);\n    getPoint(s.p2);\n}\n\nbool orthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool orthogonal(Point a1,Point a2,Point b1,Point b2){\n    return orthogonal(a1-a2,b1-b2);\n}\n\nbool orthogonal(Segment s1,Segment s2){\n    return orthogonal(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nbool parallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool parallel(Point a1,Point a2,Point b1,Point b2){\n    return parallel(a1-a2,b1-b2);\n}\n\nbool parallel(Segment s1,Segment s2){\n    return parallel(s1.p1-s1.p2,s2.p1-s2.p2);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflection(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    if(cross(a,b)>EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b)<-EPS)return CLOCKWISE;\n    if(dot(a,b)<-EPS)return ONLINE_BACK;\n    if(norm(a)<norm(b))return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&\n            ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0;\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nint N;\nSegment T;\nSegment S[100];\nint O[100],L[100];\n\nvoid solve(){\n    getSegment(T);\n    cin>>N;\n    for(int i=0;i<N;i++){\n        getSegment(S[i]);\n        cin>>O[i]>>L[i];\n    }\n    vector<pair<double,int>>vec;\n    for(int i=0;i<N;i++){\n        if(!intersect(T,S[i]))continue;\n        Point p=getCrossPoint(T,S[i]);\n        double d=abs(T.p1-p);\n        int t=O[i]^L[i];\n        vec.push_back(make_pair(d,t));\n    }\n    sort(vec.begin(),vec.end());\n    int ans=0;\n    for(int i=0;i+1<vec.size();i++)if(vec[i].second!=vec[i+1].second)ans++;\n    cout<<ans<<endl;\n}\n\nint main(){\n    int T;cin>>T;\n    while(T--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\tif(((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r)){\n\t\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++){\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\t}\n\treturn sum/2;\n}\n\nstruct edgeInfo{\n    P a;\n    P b;\n    int o;\n    int l;\n};\n\nP p1;\nP p2;\n\nstruct Point{\n    P p;\n    int l;\n    int o;\n\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<edgeInfo> edges;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            edgeInfo e;\n            e.a=P(xs,ys);\n            e.b=P(xt,yt);\n            e.l=l;\n            e.o=o;\n            edges.push_back(e);\n        }\n        vector<Point> crossPoint;\n        // ð_ðßé\n        for(int i = 0;i < n; i++){\n            if(is_intersected_ls(edges[i].a,edges[i].b,p1,p2)){\n                P res=intersection_ls(edges[i].a,edges[i].b,p1,p2);\n                Point pp;\n                pp.l=edges[i].l;\n                pp.o=edges[i].o;\n                pp.p=res;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit;\n        if(crossPoint[0].l==1){\n            if(crossPoint[0].o==1){\n                sit=1;\n            }\n            else{\n                sit=0;\n            }\n        }\n        else{\n            if(crossPoint[0].o==1){\n                sit=0;\n            }\n            else{\n                sit=1;\n            }\n        }\n        int cnt=0;\n        // ð_ðp1Éß¢ÔÉ\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].o==1){\n                if(crossPoint[i].l==0){\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n            }\n            else{\n                if(crossPoint[i].l==0){\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//XY座標\n#define X real()\n#define Y imag()\n\n// 許容する誤差ε\nconst double EPS = (1e-8);\n// 円周率\nconst double PI = 3.14159265358979;\n// infinity\nconst double INF = 1e12;\n\n// 点の表現\ntypedef complex<double> P;\n\n// complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// 2乗する\ndouble sq(double x){\n\treturn x * x;\n}\n\n// 2つのスカラーが等しいかどうか\nbool equal(double a, double b){\n\treturn ( fabs( a - b ) < EPS );\n}\n// 2つのベクトルが等しいかどうか\nbool eq_v(P a, P b){\n\treturn ( equal( a.X, b.X ) && equal( a.Y, b.Y ) );\n}\n\n// ベクトルaの単位ベクトルを求める\nP unit(P a){\n\treturn a / abs(a);\n}\n\n// ベクトルaの法線ベクトルを求める\nvector<P> normal(P a){\n\tvector<P> vp;\n\tvp.push_back( a * P(0,  1) );\n\tvp.push_back( a * P(0, -1) );\n\treturn vp;\n}\n\n// ベクトル a の単位法線ベクトルを求める\nvector<P> normal_unit(P a){\n\tvector<P> vp;\n\tvp.push_back( (a * P(0,  1)) / abs(a) );\n\tvp.push_back( (a * P(0, -1)) / abs(a) ) ;\n\treturn vp;\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross( P a, P b) {\n\treturn imag( conj(a) * b );\n}\n\n// 2 直線の直交判定 : a⊥b <=> dot(a, b) = 0\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n\treturn equal( dot(a1-a2, b1-b2), 0.0 );\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n\treturn equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// 点 c が直線 a, b 上にあるかどうか \nint is_point_on_line(P a, P b, P c) {\n\treturn equal( cross(b-a, c-a), 0.0 );\n}\n\n// 下記は (1) より (2) のほうが簡潔で良い.\n\n// 点 c が線分 a, b 上にあるかどうか (1)\nint is_point_on_line_1(P a, P b, P c) {\n  return equal( cross(b-a, c-a), 0.0 ) &&\n         (dot(b-a, c-a) > -EPS) &&\n         (dot(a-b, c-b) > -EPS);\n}\n\n// 点 c が線分 a, b 上にあるかないか(2)\nint is_point_on_line_2(P a, P b, P c) {\n\t// |a-c| + |c-b| <= |a-b| なら線分上\n\treturn (abs(a-c) + abs(c-b) < abs(a-b) + EPS);\n}\n\n// 点 a, bを通る直線と点 c との距離\ndouble distance_l_p(P a, P b, P c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// 点 a, b を端点とする線分と点 c との距離\ndouble distance_ls_p(P a, P b, P c) {\n\tif( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n\treturn ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n\t\t   ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\n// a1, a2 を端点とする線分と b1, b2 を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1 / (d1 + d2);\n\t\n\treturn a1 + (a2-a1) * t;\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n\treturn !equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// a1, a2 を通る直線と b1, b2 を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n\tP a = a2 - a1; P b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int i_=0 ; i_ < N ; i_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tP A(xa,ya), B(xb,yb);\n\t\t\n\t\t// 点Aと交点の距離と交点で地下と高架のどちらを通るべきか保持\n\t\tvector< pair<double,int> > v;\n\t\t\n\t\tcin >> n;\n\t\tfor(int j_=0 ; j_ < n ; j_++ ){\n\t\t\tint sx,sy,tx,ty,o,l;\n\t\t\tcin >> sx >> sy >> tx >> ty >> o >> l;\n\t\t\tP S(sx,sy), T(tx,ty);\n\t\t\t\n\t\t\t// 交差するかどうか\n\t\t\tif( is_intersected_ls( A , B , S , T ) ){\n\t\t\t\t// 平行かどうか\n\t\t\t\tif( is_parallel( A , B , S , T ) ){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// 交点\n\t\t\t\tP p = intersection_l( A , B , S , T );\n\t\t\t\tif( abs(A-p) < EPS || abs(B-p) < EPS ) continue;\n\t\t\t\t// 距離\n\t\t\t\tdouble dist = abs(A-p);\n\t\t\t\t\n\t\t\t\tv.push_back( pair<double,int>(dist,o^l) );\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort( v.begin() , v.end() );\n\t\tif( v.size() < 2 ){\n\t\t\tcout << 0 << endl;\n\t\t}else{\n\t\t\tint ans = 0;\n\t\t\tint d = v[0].second;\n\t\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\t\tif( d != v[i].second ){\n\t\t\t\t\tans++;\n\t\t\t\t\td = v[i].second;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\tif(((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r)){\n\t\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++){\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\t}\n\treturn sum/2;\n}\n\nstruct edgeInfo{\n    P a;\n    P b;\n    int o;\n    int l;\n};\n\nP p1;\nP p2;\n\nstruct Point{\n    P p;\n    int l;\n    int o;\n\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<edgeInfo> edges;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            edgeInfo e;\n            e.a=P(xs,ys);\n            e.b=P(xt,yt);\n            e.l=l;\n            e.o=o;\n            edges.push_back(e);\n        }\n        vector<Point> crossPoint;\n        // ð_ðßé\n        for(int i = 0;i < n; i++){\n            if(is_intersected_ls(edges[i].a,edges[i].b,p1,p2)){\n                P res=intersection_ls(edges[i].a,edges[i].b,p1,p2);\n                Point pp;\n                pp.l=edges[i].l;\n                pp.o=edges[i].o;\n                pp.p=res;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n\n        if(crossPoint.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit;\n        if(crossPoint[0].l==1){\n            if(crossPoint[0].o==1){\n                sit=1;\n            }\n            else{\n                sit=0;\n            }\n        }\n        else{\n            if(crossPoint[0].o==1){\n                sit=0;\n            }\n            else{\n                sit=1;\n            }\n        }\n        int cnt=0;\n        // ð_ðp1Éß¢ÔÉ\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].o==1){\n                if(crossPoint[i].l==0){\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n            }\n            else{\n                if(crossPoint[i].l==0){\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <complex>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\n\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\nconst D EPS = 1e-9;    // ?¨±??????????????????????????£????????????\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n\treturn (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n\treturn (conj(a)*b).Y;\n}\n// ??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a;  c -= a;\n\tif (cross(b, c) >  EPS) return +1;  // counter clockwise\n\tif (cross(b, c) < -EPS) return -1;  // clockwise\n\tif (dot(b, c)   < -EPS) return +2;  // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n\treturn 0;                          // a--c--b on line or a==c or b==c\n}\n\n// ??´?????¨???\nbool isecLP(P a1, P a2, P b) {\n\treturn abs(ccw(a1, a2, b)) != 1;  // return EQ(cross(a2-a1, b-a1), 0); ??¨??????\n}\n\n// ??´?????¨??´???\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\n\t\tdouble sy, sx, gy, gx;\n\t\tcin >> sx >> sy >> gx >> gy;\n\n\t\tL sl(pair<P,P>(P(sx,sy),P(gx,gy)));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\ttypedef pair<L, pair<int, int>> LL;\n\t\tvector<LL> l;\n\n\t\trep(i, n){\n\t\t\tcin >> sx >> sy >> gx >> gy;\n\t\t\tint o, tl;\n\t\t\tcin >> o >> tl;\n\n\t\t\tLL t;\n\n\t\t\tP tp1(sx,sy),tp2(gx,gy);\n\t\t\tt.first.first = tp1;\n\t\t\tt.first.second = tp2;\n\n\t\t\tt.second.first = o;\n\t\t\tt.second.second = tl;\n\n\t\t\tl.push_back(t);\n\t\t}\n\t\tvector<int> vo, vl;\n\t\tvector<P> point;\n\n\t\trep(i, l.size()){\n\t\t\tauto lp1 = l[i].first.first;\n\t\t\tauto lp2 = l[i].first.first;\n\t\t\tauto data = l[i].second;\n\n\t\t\tif (isecLL(sl.first, sl.second, lp1, lp2)){\n\t\t\t\tauto p = crosspointLL(sl.first, sl.second, lp1, lp2);\n\t\t\t\tpoint.push_back(p);\n\t\t\t\tvo.push_back(data.first);\n\t\t\t\tvl.push_back(data.second);\n\t\t\t}\n\t\t}\n\n\t\tbool f = true;\n\t\twhile (f){\n\t\t\tf = false;\n\t\t\trep(i, point.size() - 1){\n\t\t\t\tdouble x, y, tx, ty;\n\t\t\t\tx = point[i].imag(); y = point[i].real();\n\t\t\t\ttx = point[i+1].imag(); ty = point[i+1].real();\n\t\t\t\tdouble l1 = (x - sx) * (x - sx) + (y - sy) * (y - sy), l2 = (tx - sx) * (tx - sx) + (ty - sy) * (ty - sy);\n\n\t\t\t\tif (l1 > l2){\n\t\t\t\t\tswap(point[i], point[i + 1]);\n\t\t\t\t\tswap(vo[i], vo[i + 1]);\n\t\t\t\t\tswap(vl[i], vl[i + 1]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(j, 2){\n\t\t\tint val = 0;\n\t\t\tint sj = j;\n\t\t\trep(i, point.size()){\n\n\t\t\t\tif (vo[i] == 1){\n\t\t\t\t\tif (vl[i] != sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = vl[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vo[i] == 0){\n\t\t\t\t\tif (vl[i] == sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = (1-sj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans = min(ans, val);\n\t\t}\n\t\trep(j, 2){\n\t\t\tint val = 0;\n\t\t\tint sj = j;\n\t\t\tfor (int i = point.size() - 1; i >= 0;i--){\n\n\t\t\t\tif (vo[i] == 1){\n\t\t\t\t\tif (vl[i] != sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = vl[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vo[i] == 0){\n\t\t\t\t\tif (vl[i] == sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = (1 - sj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans = min(ans, val);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <fstream>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EPS 1e-9\n\n#define EQ(x,y) fabs((x)-(y))<(EPS)\n\ntypedef pair<pii, bool> P;\n\nbool sorter(const P p1, const P p2){\n  return p1.first<p2.first;\n}\n\nint main(){\n  int tc;\n  cin>>tc;\n  while(tc-->0){\n    vector<P> points;\n\n    double xa,ya,xb,yb;\n    scanf(\"%lf %lf %lf %lf\", &xa, &ya, &xb, &yb);\n\n    double lf=min(xa,xb), r=max(xa,xb);\n    double b=min(ya,yb), t=max(ya,yb);\n\n    int n;\n    cin>>n;\n    rep(i,n){\n      double x1,y1,x2,y2;\n      int o,l;\n      scanf(\"%lf %lf %lf %lf %d %d\", &x1, &y1, &x2, &y2, &o, &l);\n\n      // if pararell\n      if( EQ((xa-xb)*(y1-y2), (ya-yb)*(x1-x2)) ) continue;\n\n      // where is intersection?\n      double nx, ny;\n      if(EQ(xa,xb)){\n\tdouble d2 = (y1-y2)/(x1-x2);\n\tnx = xa;\n\tny = d2*(nx-x1)+y1;\n      } else if( EQ(x1,x2) ){\n\tdouble d1 = (ya-yb)/(xa-xb);\n\tnx = x1;\n\tny = d1*(nx-xa)+ya;\n      } else {\n\tdouble d1 = (ya-yb)/(xa-xb);\n\tdouble d2 = (y1-y2)/(x1-x2);\n\tnx = (y1-d2*x1-(ya-d1*xa))/(d1-d2);\n\tny = d1*(nx-xa)+ya;\n\t//assert(EQ(ny, d2*(nx-x1)+y1));\n      }\n      \n      if( nx-lf>-EPS && r-nx>-EPS && ny-b>-EPS && t-ny>-EPS ){\n      // if cross with new line, add point to vector\n\tpoints.pb(mp(mp(nx,ny), (o==l)));\n      }\n    }\n\n    sort(all(points), sorter);\n\n    int res=0;\n    repl(i,1,points.size()){\n      if(points[i-1].second != points[i].second) res++;\n    }\n\n    cout<<res<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n#include <complex>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\n\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nD dot(P a, P b){\n\treturn (conj(a)* b).real();\n}\n\nD cross(P a, P b){\n\treturn (conj(a)* b).imag();\n}\n\nint ccw(P a, P b, P c){\n\tb -= a, c -= a;\n\tif (cross(b, c) > EPS) return 1;\n\tif (cross(b, c) > -EPS) return -1;\n\tif (dot(b, c) > -EPS) return 2;\n\tif (norm(b) < norm(c)) return -2;\n\treturn 0;\n}\n\nbool isecLP(P a1, P a2, P b){\n\treturn abs(ccw(a1, a2, b)) != 1;\n}\nbool isecLL(P a1, P a2, P b1, P b2) {\n\treturn !isecLP(a2 - a1, b2 - b1, 0) || isecLP(a1, b1, b2);\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n\tD d1 = cross(b2 - b1, b1 - a1);\n\tD d2 = cross(b2 - b1, a2 - a1);\n\tif (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n\tif (EQ(d2, 0)) throw \"kouten ga nai\";   // ???????????????\n\treturn a1 + d1 / d2 * (a2 - a1);\n}\n\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\trep(_, N){\n\n\t\tdouble sy, sx, gy, gx;\n\t\tcin >> sx >> sy >> gx >> gy;\n\n\t\tL sl(pair<P,P>(P(sx,sy),P(gx,gy)));\n\n\t\tint n;\n\t\tcin >> n;\n\n\t\ttypedef pair<L, pair<int, int>> LL;\n\t\tvector<LL> l;\n\n\t\trep(i, n){\n\t\t\tcin >> sx >> sy >> gx >> gy;\n\t\t\tint o, tl;\n\t\t\tcin >> o >> tl;\n\n\t\t\tLL t;\n\n\t\t\tP tp1(sx,sy),tp2(gx,gy);\n\t\t\tt.first.first = tp1;\n\t\t\tt.first.second = tp2;\n\n\t\t\tt.second.first = o;\n\t\t\tt.second.second = tl;\n\n\t\t\tl.push_back(t);\n\t\t}\n\t\tvector<int> vo, vl;\n\t\tvector<P> point;\n\n\t\trep(i, l.size()){\n\t\t\tauto lp1 = l[i].first.first;\n\t\t\tauto lp2 = l[i].first.first;\n\t\t\tauto data = l[i].second;\n\n\t\t\tif (isecLL(sl.first, sl.second, lp1, lp2)){\n\t\t\t\tauto p = crosspointLL(sl.first, sl.second, lp1, lp2);\n\t\t\t\tpoint.push_back(p);\n\t\t\t\tvo.push_back(data.first);\n\t\t\t\tvl.push_back(data.second);\n\t\t\t}\n\t\t}\n\n\t\tbool f = true;\n\t\twhile (f){\n\t\t\tf = false;\n\t\t\trep(i, point.size() - 1){\n\t\t\t\tdouble x, y, tx, ty;\n\t\t\t\tx = point[i].imag(); y = point[i].real();\n\t\t\t\ttx = point[i+1].imag(); ty = point[i+1].real();\n\t\t\t\tdouble l1 = (x - sx) * (x - sx) + (y - sy) * (y - sy), l2 = (tx - sx) * (tx - sx) + (ty - sy) * (ty - sy);\n\n\t\t\t\tif (l1 > l2){\n\t\t\t\t\tswap(point[i], point[i + 1]);\n\t\t\t\t\tswap(vo[i], vo[i + 1]);\n\t\t\t\t\tswap(vl[i], vl[i + 1]);\n\t\t\t\t\tf = true;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(j, 2){\n\t\t\tint val = 0;\n\t\t\tint sj = j;\n\t\t\trep(i, point.size()){\n\n\t\t\t\tif (vo[i] == 1){\n\t\t\t\t\tif (vl[i] != sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = vl[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (vo[i] == 0){\n\t\t\t\t\tif (vl[i] == sj){\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\tsj = (1-sj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tans = min(ans, val);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n    return (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\n// ?????????????????? a->b->c\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\n// ??´???a??¨??????b\nbool isecLS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0;\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n    D d1 = cross(b2-b1, b1-a1);\n    D d2 = cross(b2-b1, a2-a1);\n    return a1 + d1/(d1 + d2) * (a2-a1);\n}\n\nclass CrossPoint{\npublic:\n    double x, y;\n    int o, l;\n    bool is_underground;\n    CrossPoint(double x, double y, int o, int l): x(x), y(y), o(o), l(l){\n        is_underground = o^l;\n    };\n};\n\nbool cmp(CrossPoint p1, CrossPoint p2){\n    if(EQ(p1.x, p2.x))\n        return p1.y < p2.y;\n    else\n        return p1.x < p2.x;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T; cin>>T;\n    while(T--){\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        \n        int N; cin >> N;\n        \n        vector<CrossPoint> crosspoints;\n        for(int i=0; i<N; i++){\n            int xs, ys, xt, yt, o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            \n            if(isecLS(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt))){\n                P p = crosspointLL(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt));\n                crosspoints.push_back(CrossPoint(p.X, p.Y, o, l));\n            }\n        }\n        sort(crosspoints.begin(), crosspoints.end(), cmp);\n        \n        int count = 0;\n        bool is_underground = crosspoints[0].is_underground;\n        int i = 0;\n        while(i<crosspoints.size()){\n            while(i<crosspoints.size() && crosspoints[i].is_underground == is_underground) i++;\n            if(i<crosspoints.size()){\n                is_underground = crosspoints[i].is_underground;\n                count++;\n            }\n            i++;\n        }\n        \n        cout << count << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nstruct Point{bool high;double x,y;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nPoint* Intersection(Point p1,Point p2,Point p3,Point p4){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if(d==0 || u<0 || u>1 || v<0 || v>1)return NULL;\n    Point *ret = (Point*) malloc(sizeof(Point));\n    ret->x = p1.x+u*(p2.x-p1.x);\n    ret->y = p1.y+u*(p2.y-p1.y);\n    return ret;\n}\n\nint main(void){\n    int N,n,o,l;\n    cin>>N;\n    while(N--){\n        Point a,b;\n        vector<Point> cross;\n        cin>>a.x>>a.y>>b.x>>b.y>>n;\n        rep(i,n){\n            Point s,t;\n            cin>>s.x>>s.y>>t.x>>t.y>>o>>l;\n            Point *ret = Intersection(a,b,s,t);\n            if(ret!=NULL){\n                ret->high = o==l;\n                cross.push_back(*ret);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<(int)cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n\tif(d1<r&&d2<r){\n\t\treturn false;\n\t}\n\tdouble d = distance_ls_p(a,b,c);\n\tif(EQ(d,r)||d<r){\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\tif(((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r)){\n\t\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++){\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\t}\n\treturn sum/2;\n}\n\nstruct edgeInfo{\n    P a;\n    P b;\n    int o;\n    int l;\n};\n\nP p1;\nP p2;\n\nclass Point{\npublic:\n    P p;\n    int l;\n    int o;\n\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<edgeInfo> edges;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            edgeInfo e;\n            e.a=P(xs,ys);\n            e.b=P(xt,yt);\n            e.l=l;\n            e.o=o;\n            edges.push_back(e);\n        }\n        vector<Point> crossPoint;\n        // ð_ðßé\n        for(int i = 0;i < n; i++){\n            if(is_intersected_ls(edges[i].a,edges[i].b,p1,p2)){\n                P res=intersection_ls(edges[i].a,edges[i].b,p1,p2);\n                Point pp;\n                pp.l=edges[i].l;\n                pp.o=edges[i].o;\n                pp.p=res;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n\n        if(crossPoint.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit;\n        if(crossPoint[0].l==1){\n            if(crossPoint[0].o==1){\n                sit=1;\n            }\n            else{\n                sit=0;\n            }\n        }\n        else{\n            if(crossPoint[0].o==1){\n                sit=0;\n            }\n            else{\n                sit=1;\n            }\n        }\n        int cnt=0;\n        // ð_ðp1Éß¢ÔÉ\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].o==1){\n                if(crossPoint[i].l==0){\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n            }\n            else{\n                if(crossPoint[i].l==0){\n                    if(sit!=1){\n                        sit=1;\n                        cnt++;\n                    }\n                }\n                else{\n                    if(sit!=0){\n                        sit=0;\n                        cnt++;\n                    }\n                }\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#define EPS 1e-10\nusing namespace std;\n\nint testc,n;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(fabs(a)+fabs(b)))return 0;\n\treturn a+b;\n}\n\nstruct P{\n\tdouble x,y;\n\tint flag;\n\tP(){}\n\tP(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t\tflag=-1;\n\t}\n\tP(double xx,double yy,int f){\n\t\tx=xx;\n\t\ty=yy;\n\t\tflag=f;\n\t}\n\tP operator +(P p){\n\t\treturn P(x+p.x,y+p.y);\n\t}\n\tP operator -(P p){\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tP operator *(double d){\n\t\treturn P(x*d,y*d);\n\t}\n\tP operator /(double d){\n\t\treturn P(x/d,y/d);\n\t}\n\tdouble dot(P p){\n\t\treturn add(x*p.x,y*p.y);\n\t}\n\tdouble det(P p){\n\t\treturn add(x*p.y,-y*p.x);\n\t}\n};\n\nbool on_seg(P p1,P p2,P q){\n\treturn (p1-q).det(p2-q)==0 && (p1-q).dot(p2-q)<=0;\n}\n\nbool comp(const P& p1,const P& p2){\n\tif(add(p1.x,-p2.x)==0)return p1.y<p2.y;\n\treturn p1.x<p2.x;\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n\treturn p1+(p2-p1)*((q2-q1).det(q1-p1)/(q2-q1).det(p2-p1));\n}\n\nvector<P> data[2][2][2];\nP a,b;\nvector<P> cross;\nint solve(){\n\tcross.clear();\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<data[i][j][0].size();k++){\n\t\t\t\tP p1=data[i][j][0][k],p2=data[i][j][1][k];\n\t\t\t\tif((p1-p2).det(a-b)==0)continue;\n\t\t\t\tP r=intersection(p1,p2,a,b);\n\t\t\t\tif(on_seg(p1,p2,r) && on_seg(a,b,r)){\n\t\t\t\t\tif(i==0){\n\t\t\t\t\t\tif(j==0)r.flag=0;\n\t\t\t\t\t\telse r.flag=1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(j==0)r.flag=1;\n\t\t\t\t\t\telse r.flag=0;\n\t\t\t\t\t}\n\t\t\t\t\tcross.push_back(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint now=-1,cnt=0;\n\tsort(cross.begin(),cross.end(),comp);\n\tfor(int i=0;i<cross.size();i++){\n\t\tP p=cross[i];\n\t\tif(now==-1){\n\t\t\tnow=cross[i].flag;\n\t\t}else{\n\t\t\tif(now!=cross[i].flag)cnt++;\n\t\t\tnow=cross[i].flag;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(void){\n\tscanf(\"%d\",&testc);\n\tfor(int ddd=0;ddd<testc;ddd++){\n\t\tscanf(\"%lf %lf %lf %lf\",&a.x,&a.y,&b.x,&b.y);\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int k=0;k<2;k++)data[i][j][k].clear();\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint xs,ys,xt,yt,o,l;\n\t\t\tscanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&o,&l);\n\t\t\tdata[o][l][0].push_back(P(xs,ys));\n\t\t\tdata[o][l][1].push_back(P(xt,yt));\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(int64_t a, int64_t b, int64_t c, int64_t d, int64_t e,\n                  int64_t f, int64_t g, int64_t h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(int64_t a, int64_t b, int64_t c, int64_t d, int64_t e,\n                int64_t f, int64_t g, int64_t h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int64_t n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int64_t e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    assert(-10000 <= ci.pos && ci.pos <= 10000);\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr double EPS = 1e-8;\n\nstruct point {\n    double x, y;\n    int id;\n    point (): x(0), y(0), id(0) {}\n\n    point(double a, double b): x(a), y(b), id(-1) {}\n    point(double a, double b, int c): x(a), y(b), id(c) {}\n\n    bool operator < (const point& o) const {\n        return x == o.x ? y < o.y : x < o.y;\n    }\n\n    bool operator > (const point& o) const {\n        return x == o.x ? y > o.y : x > o.y;\n    }\n};\n\ndouble put (point p, point l1, point l2) {\n    double a = l1.y - l2.y, b = l2.x - l1.x, c = l1.x*l2.y - l2.x*l1.y;\n    return a * p.x + b * p.y + c;\n}\n\npoint intersect(point k1, point k2, point l1, point l2) {\n    double ret_x = (k1.x + k2.x) / 2, ret_y = (k1.y + k2.y) / 2;\n    double sig = put(k1, l1, l2) > 0 ? 1 : -1;\n    for (int j = 0; j < 200; ++j) {\n        double val = put(point(ret_x, ret_y), l1, l2);\n        if (abs(val)  < EPS) {\n            return point(ret_x, ret_y);\n        } else if (val * sig > 0) {\n            ret_x = (ret_x + k2.x) / 2;\n            ret_y = (ret_y + k2.y) / 2;\n        } else {\n            ret_x = (ret_x + k1.x) / 2;\n            ret_y = (ret_y + k1.y) / 2;\n        }\n    }\n    return point(ret_x, ret_y);\n}\n\nbool cross(point k1, point k2, point l1, point l2) {\n    bool b1 = put(k1, l1, l2) * put(k2, l1, l2) < 0;\n    bool b2 = put(l1, k1, k2) * put(l2, k1, k2) < 0;\n    return b1 && b2;\n}\n\nint xa, ya, xb, yb, N;\npoint s[1000], t[1000];\nint   o[1000], l[1000];\n\nint solve() {\n    point start(xa, ya), goal(xb, yb);\n    vector<point> itss;\n    for (int j = 0; j < N; ++j) if (cross(start, goal, s[j], t[j])) {\n        point it = intersect(start, goal, s[j], t[j]);\n        it.id = j;\n        itss.push_back(it);\n    }\n\n    sort(begin(itss), end(itss));\n    if (start > goal) reverse(begin(itss), end(itss));\n\n    int ret = 0, height = -1;\n    for (const point& it : itss) {\n        int id = it.id;\n        int expected = o[id] == 1 ? l[id] : 1-l[id];\n        if (height == -1) {\n            height = expected;\n        } else if (height != expected) {\n            ++ret;\n            height = expected;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int datasets; cin >> datasets;\n    for (int d = 0; d < datasets; ++d) {\n        cin >> xa >> ya >> xb >> yb >> N;\n        for (int j = 0; j < N; ++j) {\n            cin >> s[j].x >> s[j].y >> t[j].x >> t[j].y >> o[j] >> l[j];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define EPS (1e-9)\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected(P a1, P a2, P b1, P b2) {\n  return ( ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n           ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS ) );\n}\n\nP s[101], t[101];\nint c[101], l[101];\n\nstruct intersection {\n  double t; // parameter t\n  int n;    // index of intersected line\n\n  bool operator<(const intersection &a) const {\n    return (t < a.t);\n  }\n};\n\nint main() {\n  int N;\n  cin >> N;\n  while (N--) {\n    P a, b;\n    cin >> a.real() >> a.imag();\n    cin >> b.real() >> b.imag();\n\n    int n;\n    cin >> n;\n    for (int i=0; i<n; i++) {\n      cin >> s[i].real() >> s[i].imag();\n      cin >> t[i].real() >> t[i].imag();\n      cin >> c[i] >> l[i];\n    }\n\n    vector<intersection> is;\n    for (int i=0; i<n; i++) {\n      if (!is_intersected(a, b, s[i], t[i])) { continue; }\n    //  if (abs(cross(b-a, t[i]-s[i])) < EPS) { continue; }\n\n      P x = t[i] - s[i];\n      double d1 = abs(cross(x, a-s[i]));\n      double d2 = abs(cross(x, b-s[i]));\n      double t = d1 / (d1 + d2);\n\n      intersection tmp = {t, i};\n      is.push_back(tmp);\n    }\n\n    sort(is.begin(), is.end());\n\n    int curr; // current status: up (=1) or down (=0)\n    if (is.size() > 0) {\n      int idx = is[0].n;\n      curr = (c[idx] == 1 ? l[idx] : !l[idx]);\n    }\n\n    int cnt = 0;\n    for (int i=1; i<is.size(); i++) {\n      int idx = is[i].n;\n      if ( (c[idx] == 1 && curr != l[idx]) ||\n           (c[idx] == 0 && curr == l[idx]) ) {\n        curr = !curr;\n        cnt++;\n      }\n    }\n\n    cout << cnt << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define mp       make_pair\n#define pb       push_back\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef complex<double> Point;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a), pb(b); }\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)  return CCW;\n\tif(rotdir<-EPS) return CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool cover(const Segment &s,const Point &p){\n\treturn dot(s[0]-p,s[1]-p)<EPS;\n}\n\nbool intersect(const Segment &s,const Segment &t,Point &p){\n\tbool flg;\n\tif(abs(cross(s[1]-s[0],t[1]-t[0]))<EPS && abs(cross(s[1]-s[0],t[0]-s[0]))<EPS){\n\t\tflg=(cover(s,t[0]) || cover(s,t[1]) || cover(t,s[0]) || cover(t,s[1]));\n\t\tif(!flg) return false;\n\t}\n\n\tif(flg || (ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t\t\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0)){\n\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\tcalc_abc(s,a1,b1,c1);\n\t\tcalc_abc(t,a2,b2,c2);\n\t\tdouble det=a1*b2-a2*b1;\n\t\tif(abs(det)<EPS){\n\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\trep(i,3){\n\t\t\t\tif(cover(s,q[i]) && cover(t,q[i])){\n\t\t\t\t\tp=q[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint n;\nPoint A,B;\nSegment AB,S[100];\nbool own[100],loc[100];\n\nint solve(){\n\tvector< pair<double,int> > pts;\n\trep(i,n){\n\t\tPoint Q;\n\t\tif(intersect(AB,S[i],Q)) pts.pb(mp(abs(A-Q),i));\n\t}\n\tif(pts.size()==0) return 0;\n\n\tsort(pts.begin(),pts.end());\n\n\tint cnt=0,id=pts[0].second;\n\tbool now=(own[id]?loc[id]:!loc[id]);\n\tfor(int i=1;i<pts.size();i++){\n\t\tid=pts[i].second;\n\t\tif(own[id]){\n\t\t\tif(now!=loc[id]){ cnt++; now=!now; }\n\t\t}\n\t\telse{\n\t\t\tif(now==loc[id]){ cnt++; now=!now; }\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint xa,ya,xb,yb; scanf(\"%d%d%d%d%d\",&xa,&ya,&xb,&yb,&n);\n\t\tA=Point(xa,ya);\n\t\tB=Point(xb,yb);\n\t\tAB=Segment(A,B);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,o,l; scanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&o,&l);\n\t\t\tS[i]=Segment(Point(x1,y1),Point(x2,y2));\n\t\t\town[i]=o;\n\t\t\tloc[i]=l;\n\t\t}\n\t\tprintf(\"%d\\n\",solve());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\n\nstruct Point{double x,y,mine,high;};\nbool comp(Point a,Point b) {return (a.x==b.x ? a.y<b.y : a.x<b.x);}\n\nbool Intersection(Point p1,Point p2,Point p3,Point p4,Point *res){\n    double d = (p2.x-p1.x)*(p4.y-p3.y)-(p2.y-p1.y)*(p4.x-p3.x);\n    double u = ((p3.x-p1.x)*(p4.y-p3.y)-(p3.y-p1.y)*(p4.x-p3.x))/d;\n    double v = ((p3.x-p1.x)*(p2.y-p1.y)-(p3.y-p1.y)*(p2.x-p1.x))/d;\n    if (d == 0 || u<0.0 || u>1.0 || v<0.0 || v>1.0)return false;\n    res->x = p1.x + u * (p2.x - p1.x);\n    res->y = p1.y + u * (p2.y - p1.y);\n    res->high = (p3.mine == p3.high);\n\n    return true;\n}\n\nint main(void){\n    int N,xa,ya,xb,yb,n,xs,ys,xt,yt,o,l;\n    cin>>N;\n    while(N--){\n        vector<Point> cross;\n        cin>>xa>>ya>>xb>>yb>>n;\n        Point a = {xa,ya,true,true};\n        Point b = {xb,yb,true,true};\n        rep(i,n){\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            Point s = {xs,ys,o,l};\n            Point t = {xt,yt,o,l};\n            Point res;\n            if(Intersection(a,b,s,t,&res)){\n                cross.push_back(res);\n            }\n        }\n\n        sort(cross.begin(),cross.end(),comp);\n        int cnt=0;\n        for(int i=0;i+1<cross.size();i++){\n            cnt+=(cross[i].high!=cross[i+1].high);\n        }\n        cout<<cnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\ndouble add(double a,double b){\n    if(abs(a+b) < eps * (abs(a) + abs(b))) return 0;\n    return a+b;\n}\n\nstruct P{\n    double x,y;\n    P(){}\n    P(double x,double y) : x(x),y(y){}\n    P operator + (P p){\n        return P(add(x,p.x),add(y,p.y));\n    }\n    P operator - (P p){\n        return P(add(x,-p.x),add(y,-p.y));\n    }\n    P operator * (double d){\n        return P(x*d,y*d);\n    }\n};\n\ndouble dot(P a,P b){\n    return add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(P a,P b){\n    return add(a.x * b.y,-a.y * b.x);\n}\n\nP intersection(P p1,P p2,P q1,P q2){\n    return p1 + (p2-p1) * (cross(q2-q1,q1-p1)/cross(q2-q1,p2-p1));\n}\n\nbool on_seg(P p1,P p2,P q){\n    return cross(p1-q,p2-q) == 0 && dot(p1-q,p2-q) <= 0;\n}\n\nvoid solve(){\n    int n;\n    P s,t;\n    cin >> s.x >> s.y >> t.x >> t.y;\n    cin >> n;\n    vector<P> p(n),q(n);\n    vector<int> o(n),l(n);\n\n    rep(i,n){\n        cin >> p[i].x >> p[i].y >> q[i].x >> q[i].y >> o[i] >> l[i];\n    }\n\n    vector<pair<P,int>> c;\n    for(int i=0;i<n;i++){\n        // ???????????´???????¨?????????????\n        if(cross(s-t,p[i]-q[i])==0) continue;\n\n        P r = intersection(s,t,p[i],q[i]);\n        if(!on_seg(p[i],q[i],r) || !on_seg(s,t,r)){     // ???????????????????????????\n            continue;\n        }\n\n        if(o[i] == 0){\n            if(l[i]==0) c.pb(make_pair(r,1));\n            if(l[i]==1) c.pb(make_pair(r,0));\n        }else{\n            if(l[i]==0) c.pb(make_pair(r,0));\n            if(l[i]==1) c.pb(make_pair(r,1));\n        }\n    }\n\n    vector<pair<double,int>> cc;\n    for(int i=0;i<sz(c);i++){\n        cc.pb(make_pair(c[i].first.x,c[i].second));\n    }\n    sort(all(cc));\n\n    int ans=0;\n    for(int i=0;i<sz(cc)-1;i++){\n        int cur = cc[i].second;\n        int nxt = cc[i+1].second;\n        if(cur!=nxt) ans++;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    int t;\n    cin >> t;\n    rep(i,t){\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<double,int>dat[1000];\n//Y*(tx-sx)=(X-sx)*(ty-sy)+sy*(tx-sx)\n//Y*(bx-ax)=(X-ax)*(by-ay)+ay*(bx-ax)\n//X=ax\n//Y*(tx-sx)=(ax-sx)*(ty-sy)+sy*(tx-sx)\n//(bx-ax)*(X*(ty-sy)+sy*tx-sx*ty)=(tx-sx)*(X*(by-ay)+ay*bx-ax*by)\n//(bx-ax)*(ty-sy)*X+(bx-ax)*(sy*tx-sx*ty)=(tx-sx)*(by-ay)*X+(tx-sx)*(ay*bx-ax*by)\n//((bx-ax)*(ty-sy)-(tx-sx)*(by-ay))*X=(tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty)\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tlong long ax,ay,bx,by;\n\t\tscanf(\"%lld%lld%lld%lld\",&ax,&ay,&bx,&by);\n\t\tint c;\n\t\tif(ax>bx){\n\t\t\tlong long cx=ax;\n\t\t\tax=bx;\n\t\t\tbx=cx;\n\t\t\tlong long cy=ay;\n\t\t\tay=by;\n\t\t\tby=cy;\n\t\t}\n\t\tscanf(\"%d\",&c);\n\t\tint now=0;\n\t\tif(ax==bx){\n\t\t\tif(ay>by){\n\t\t\t\tlong long cy=ay;\n\t\t\t\tay=by;\n\t\t\t\tby=cy;\n\t\t\t}\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tlong long sx,sy,tx,ty;\n\t\t\t\tint type,z;\n\t\t\t\tscanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n\t\t\t\ttype^=z;\n\t\t\t\tif(tx!=sx&&!(sx>ax&&tx>ax)&&!(sx<ax&&tx<ax)){\n\t\t\t\t\tdouble Y=(double)((ax-sx)*(ty-sy)+sy*(tx-sx))/(tx-sx);\n\t\t\t\t\tif((double)ay<Y&&Y<(double)by){\n\t\t\t\t\t\tdat[now++]=make_pair(Y,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tlong long sx,sy,tx,ty;\n\t\t\t\tint type,z;\n\t\t\t\tscanf(\"%lld%lld%lld%lld%d%d\",&sx,&sy,&tx,&ty,&type,&z);\n\t\t\t\ttype^=z;\n\t\t\t\tif((bx-ax)*(ty-sy)-(tx-sx)*(by-ay)!=0){\n\t\t\t\t\tdouble X=(double)((tx-sx)*(ay*bx-ax*by)-(bx-ax)*(sy*tx-sx*ty))/((bx-ax)*(ty-sy)-(tx-sx)*(by-ay));\n\t\t\t\t\tif(sx==tx){\n\t\t\t\t\t\tdouble Y=(double)((sx-ax)*(by-ay)+ay*(bx-ax))/(bx-ax);\n\t\t\t\t\t\tif((double)sy<Y&&(double)ty<Y)continue;\n\t\t\t\t\t\tif((double)sy>Y&&(double)ty>Y)continue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif((double)sx<X&&(double)tx<X)continue;\n\t\t\t\t\t\tif((double)sx>X&&(double)tx>X)continue;\n\t\t\t\t\t}\n\t\t\t\t\tif((double)ax<X&&X<(double)bx){\n\t\t\t//\t\t\tprintf(\"%f \",X);\n\t\t\t\t\t\tdat[now++]=make_pair(X,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(dat,dat+now);\n\t\tint val=dat[0].second;\n\t\tint ret=0;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tif(dat[i].second!=val){\n\t\t\t\tret++;\n\t\t\t\tval=dat[i].second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n/*\n\nTodo:\nLine??¨Segment?????????????????????\n\n*/\n\nconst double EPS = 1e-10;\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\n//0?¬?\nclass Point {\npublic:\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint operator+(Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator-(Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator*(double a) { return Point(a * x, a * y); }\n\tPoint operator/(double a) { return Point(x / a, y / a); }\n\tbool operator<(const Point &p)const {\n\t\t//return y != p.y ? y < p.y : x < p.x; // y?????? -> x??????\n\t\treturn x != p.x ? x < p.x : y < p.y; // x?????? -> y??????\n\t}\n\tbool operator==(const Point &p)const { return equals(x, p.x) && equals(y, p.y); }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << \" \" << p.y; return os; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\n\n//1?¬?\nclass Vector :public Point {\npublic:\n\tusing Point::Point;\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n};\n\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\nclass Segment :public Line {\npublic:\n\tusing Line::Line;\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\n\n//2?¬?\nclass Circle {\npublic:\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\n//????????¢??? radian ??? ??? degree\ndouble rad(double deg) { return acos(-1)*deg / 180; }\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Point a1, Point a2, Point b1, Point b2) { return is_orthogonal(a1 - a2, b1 - b2); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Point a1, Point a2, Point b1, Point b2) { return is_parallel(a1 - a2, b1 - b2); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2) { return intersect(s1.p1, s1.p2, s2.p1, s2.p2); }\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment s1, Segment s2) {\n\tassert(intersect(s1, s2));\n\tVector base = s2.p2 - s2.p1;\n\tdouble a1 = abs(cross(base, s1.p1 - s2.p1)); //area1\n\tdouble a2 = abs(cross(base, s1.p2 - s2.p1)); //area2\n\tdouble t = a1 / (a1 + a2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\n//??´?????¨??´????????????\n//Point get_cross_point(Line l1, Line l2) {}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r + d*d - c2.r*c2.r) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(Polygon g, Point p) {\n\tint n = g.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(Polygon g) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\ta += cross(g[i], g[(i + 1) % g.size()]);\n\treturn a / 2.0;\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); // ???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\nclass Road {\npublic:\n\tPoint s;\n\tbool o, l;\n\tRoad(Point s, bool o, bool l) :s(s), o(o), l(l) {}\n\tbool operator<(const Road &that) {\n\t\treturn s < that.s;\n\t}\n};\n\nsigned main() {\n\tint M; cin >> M;\n\trep(h, 0, M) {\n\t\tvector<Road> v;\n\t\tPoint a, b; cin >> a >> b;\n\t\tSegment B(a, b);\n\t\tint n; cin >> n;\n\n\t\trep(i, 0, n) {\n\t\t\tPoint s, t; cin >> s >> t;\n\t\t\tbool o, l; cin >> o >> l;\n\t\t\tSegment S(s, t);\n\t\t\tif (intersect(B, S)) {\n\t\t\t\tPoint res = get_cross_point(B, S);\n\t\t\t\tv.emplace_back(res, o, l);\n\t\t\t}\n\t\t}\n\t\tsort(all(v));\n\t\tif (v.size() == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tbool ll = v[0].o ? v[0].l : !v[0].l;\n\t\tint cnt = 0;\n\t\trep(i, 0, v.size()) {\n\t\t\tRoad r = v[i];\n\t\t\tif (r.o) {\n\t\t\t\tif (ll != r.l) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tll = r.l;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ll == r.l) {\n\t\t\t\t\tcnt++;\n\t\t\t\t\tll = !r.l;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max(0, cnt) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 1000\nusing namespace std;\n\n// library --- start\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// library --- end\n\nstruct Pox\n{\n  Segment s;\n  double dist;\n  bool o,l;\n  Pox(Segment s=Segment(),double dist=inf,bool o=false,bool l=false):s(s),dist(dist),o(o),l(l){}\n\n  bool operator < (const Pox& a)const{ return dist < a.dist; }\n\n};\n\nPoint a,b;\nint n;\nSegment seg[MAX];\nPox     pox[MAX];\n\nint compute(bool state)\n{\n  int cnt = 0;\n  rep(i,n)//0\n    {\n      if(pox[i].dist == inf)break;\n      if(pox[i].o)\n\t{//it's me\n\t  if(pox[i].l != state)\n\t    {\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n      else\n\t{//mario\n\t  if(pox[i].l == state)\n\t    {\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n    }\n  return cnt;\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> a.x >> a.y >> b.x >> b.y;\n\t  cin >> n;\n\t  rep(i,n)\n\t    {\n\t      cin >> seg[i].p1.x >> seg[i].p1.y >> seg[i].p2.x >> seg[i].p2.y >> pox[i].o >> pox[i].l;\n\t      pox[i].s = seg[i];\n\t      Point p = (intersectSS(Segment(a,b),seg[i])?crosspoint(Segment(a,b),seg[i]):Point(inf,inf));\n\t      pox[i].dist = (intersectSS(Segment(a,b),seg[i])?sqrt(norm(a-p)):inf);\n\t    }\t  \n\t  sort(pox,pox+n); \n\n\t  cout << min(compute(false),compute(true)) << endl;\n\t}\n    }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<functional>\n#include<queue>\n#include <iomanip>\n#include<map>\n#include<limits>\n#include<cmath>\n#include<algorithm>\n#include<bitset>\n#include<utility>\n#include<complex>\n#include<cstdlib>\n#include<set>\n#include<cctype>\n\n#define DBG cerr << '!' << endl;\n#define REP(i,n) for(int (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(int (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(int (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int i = 0;i < (n);i++)cerr << v[i] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n\n#define EPS 1e-5\n#define INF 1e8\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> iv;\ntypedef vector<iv> iiv;\ntypedef vector<string> sv;\n\ntypedef complex<double> point; \nlong double r;\n\nstruct straight\n{\n\tpoint p1,p2;\n\tstraight(){}\n\tstraight(point a,point b):p1(a),p2(b){}\n};\n\npoint GetCrossPoint(straight s1,straight s2)\n{\n\tlong double x1 = s1.p1.real(),y1 = s1.p1.imag(),x2 = s1.p2.real(),y2 = s1.p2.imag();\n\tlong double x3 = s2.p1.real(),y3 = s2.p1.imag(),x4 = s2.p2.real(),y4 = s2.p2.imag();\n\t\n\t\n\tif((y2-y1) * (x4-x3) == (y4-y3) * (x2-x1))\n\t{\n\t\tpoint ret(INF,INF);\n\t\treturn ret;\n\t}\n\t\n\tlong double x13 = x3 - x1;\n\tlong double y13 = y3 - y1;\n\tlong double z = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);\n\tr = ((y4-y3) * x13 - (x4-x3) * y13 ) / z;\n\t\n\t\n\tdouble x = x1 + r * (x2-x1);\n\tdouble y = y1 + r * (y2-y1);\n\tpoint ret(x,y);\n\treturn ret;\n\t\n}\n\n\nint main()\n{\n\tint N;cin >> N;\n\twhile(N--)\n\t{\n\t\t\n\t\tdouble xa,xb,ya,yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tstraight par(point(xa,ya),point(xb,yb));\n\t\tint n;cin >> n;\n\t\t\n\t\tvector<pair<double,int> > v;\n\t\t\t\t\t\t\t\t\n\t\tREP(i,n)\n\t\t{\n\t\t\tdouble sx,sy,gx,gy;\n\t\t\tint o,l;\n\t\t\tcin >> sx >> sy >> gx >> gy >> o >> l;\n\t\t\t\n\t\t\tauto cross = GetCrossPoint(par,straight(point(sx,sy),point(gx,gy)));\n\t\t\tauto tmpx = cross.real();\n\t\t\tauto tmpy = cross.imag();\n\t\t\t\n\t\t\tif(tmpx == INF)continue;\n\t\t\t\n\t\t\tif(((((tmpx - sx > -EPS) && (gx - tmpx > -EPS)) || \n\t\t\t\t((sx - tmpx > -EPS) && (tmpx - gx > -EPS))) &&\n\t\t\t\t(((tmpy - sy > -EPS) && (gy - tmpy > -EPS)) ||\n\t\t\t\t((sy - tmpy > -EPS) && (tmpy - gy > -EPS)))) &&\n\t\t\t\t((((tmpx - xa > -EPS) && (xb - tmpx > -EPS)) || \n\t\t\t\t((xa - tmpx > -EPS) && (tmpx - xb > -EPS))) &&\n\t\t\t\t(((tmpy - ya > -EPS) && (yb - tmpy > -EPS)) ||\n\t\t\t\t((ya - tmpy > -EPS) && (tmpy - yb > -EPS)))))\n\t\t\t\t{\n\t\t\t\t\tv.PB(MP(r,((o+l)%2)));\n\t\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tsort(ALL(v));\n\t\t\n\t\tif(v.size() == 0)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tint now = v[0].SE;\n\t\t\n\t\tREP(i,v.size())\n\t\t{\n\t\t\tif(v[i].SE != now)\n\t\t\t{\n\t\t\t\tnow = v[i].SE;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\n\t\tcout << ans << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nusing P=pair<double,double>;\nP operator+(P a,P b){return make_pair(a.first+b.first,a.second+b.second);}\nP operator-(P a,P b){return make_pair(a.first-b.first,a.second-b.second);}\nP operator*(P a,double t){return make_pair(a.first*t,a.first*t);}\ndouble cross(P a,P b){return a.first*b.second-a.second*b.first;}\nint ccw(P a,P b,P c){return cross(b-a,c-a)>0?1:-1;}\nbool intersect(pair<P,P>a,pair<P,P>b){\n\treturn ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second)<0\n\t\t&&ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second)<0;\n}\ndouble get(pair<P,P>a,pair<P,P>b){\n\tP base=b.second-b.first;\n\tdouble d1=abs(cross(base,a.first-b.first));\n\tdouble d2=abs(cross(base,a.second-b.first));\n\treturn d1/(d1+d2);\n}\nint n,t;\nmain()\n{\n\tcin>>t;\n\tfor(;t--;)\n\t{\n\t\tpair<P,P>a;\n\t\tcin>>a.first.first>>a.first.second>>a.second.first>>a.second.second>>n;\n\t\tvector<pair<double,bool> >Q;\n\t\tfor(;n--;)\n\t\t{\n\t\t\tpair<P,P>b;\n\t\t\tcin>>b.first.first>>b.first.second>>b.second.first>>b.second.second;\n\t\t\tint o,l;cin>>o>>l;\n\t\t\tif(intersect(a,b))\n\t\t\t{\n\t\t\t\tQ.push_back(make_pair(get(a,b),o==l));\n\t\t\t}\n\t\t}\n\t\tsort(Q.begin(),Q.end());\n\t\tint cnt=0;\n\t\tfor(int i=1;i<Q.size();i++)if(Q[i-1].second!=Q[i].second)cnt++;\n\t\tcout<<cnt<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\n#define EPS 1e-16\n\nstatic inline bool eq(const P &a, const P &b){\n  return abs(a-b) < EPS;\n}\n/* àÏ */\nstatic inline double inp(const P &a, const P &b){\n  return (conj(a)*b).real();\n}\n/* OÏ */\nstatic inline double outp(const P &a, const P &b){\n  return (conj(a)*b).imag();\n}\n\nclass Line{\npublic:\n  P p; /* position */\n  P d; /* direction */\n  Line(){}\n  Line(P pos, P dir){p=pos; d=dir/abs(dir);}\n};\n\n/* _Æûü©ç */\nLine LineDirect(P pos, P dir){\n  return Line(pos, dir);\n}\n/* 2_©ç */\nLine LinePos(P p1, P p2){\n  return Line(p1, p2-p1);\n}\n\n/* 2ÂÌ¼üÌð_ */\nP crossPoint(const Line &l1, const Line &l2){\n  double num = outp(l2.d, l2.p-l1.p);\n  double denom = outp(l2.d, l1.d);\n  return P(l1.p + l1.d * num/denom);\n}\n\n/* _Æ¼üÌ£ */\ndouble dist(const Line &l, const P &p){\n  return std::abs(outp(l.d, p-l.p) / abs(l.d));\n}\n\nint main(){\n  int d; cin>>d;\n  while(d --> 0){\n    P a, b; cin>>a.real()>>a.imag()>>b.real()>>b.imag();\n    Line l1 = LinePos(a,b);\n    int n; cin>>n;\n    vector<pair<double,int> > cp; //cross point\n    REP(i,n){\n      P c,d; int o; int l;\n      cin>>c.real()>>c.imag()>>d.real()>>d.imag()>>o>>l;\n      Line l2 = LinePos(c,d);\n      if(abs((l1.d / l2.d).imag()) < EPS) continue;\n      P p = crossPoint(l1,l2);\n      double dd = ((p-a)/(b-a)).real();\n      if(dd < 0.0 || dd > 1.0) continue;\n      cp.push_back(mp(abs(p-a),(o^l)));\n    }\n    int ans = 0;\n    if(cp.size() > 1){\n      sort(cp.begin(), cp.end());\n      for(int i=1; i<cp.size(); i++){\n        int f1 = cp[i].s;\n        int f2 = cp[i-1].s;\n        if(f1 != f2) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,pair<int,int> > CP;\n\nconst double PI = acos(-1);\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);\n  }\n}\n\n//for vector\ndouble dot(P x,P y){return real(conj(x)*y);}\n\ndouble cross(P x,P y){return imag(conj(x)*y);}\n\n//for line(segment)\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nbool is_cp(L a,L b){\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\nP seg_cp(L a,L b){\n  double d = abs(cross(b.sc-b.fs,a.fs-b.fs));\n  return a.fs + (a.sc-a.fs)*( d /(d * abs(cross(b.sc-b.fs,a.sc-b.fs))) );\n}\n\nint main(){\n  int t,n;\n  int xa,ya,xb,yb;\n  int xs[110],ys[110],xt[110],yt[110],o[110],l[110];\n\n  cin >> t;\n\n  while(t--){\n    cin >> xa >> ya >> xb >> yb;\n    cin >> n;\n    for(int i=0;i<n;i++)cin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n   \n    vector<CP> cp;\n    L nl = L(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;i++){\n      L tmpl = L(P(xs[i],ys[i]),P(xt[i],yt[i]));\n      if( is_cp(nl,tmpl) )cp.push_back(CP(seg_cp(nl,tmpl),make_pair(o[i],l[i])));\n    }\n    sort(cp.begin(),cp.end());\n    \n    int ans = 0;\n    for(int i=1;i<(int)cp.size();i++){\n      if( (cp[i-1].sc.fs==cp[i].sc.fs)^(cp[i-1].sc.sc==cp[i].sc.sc) )ans++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cmath>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1)/cross(b, a);\n}\n\nP A, B;\nint N;\nvector<P> S, T;\nvector<int> Own, Pos;\n\nint main() {\n  int Tc;\n  cin >> Tc;\n  while(Tc--) {\n    cin >> A.real() >> A.imag() >> B.real() >> B.imag();\n    cin >> N;\n    S.resize(N);\n    T.resize(N);\n    Own.resize(N);\n    Pos.resize(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i].real() >> S[i].imag() >> T[i].real() >> T[i].imag()\n\t  >> Own[i] >> Pos[i];\n    }\n\n    vector<pair<double, int> > v;\n    for(int i = 0; i < N; ++i) {\n      if(isIntersect(A,B,S[i],T[i])) {\n\tP p = getCrossP(A,B,S[i],T[i]);\n\tv.push_back(make_pair(norm(p-A), i));\n      }\n    }\n    int cnt = 0;\n    if(v.size()) {\n      sort(v.begin(), v.end());\n      int pos = (Pos[v[0].second] ^ ~Own[v[0].second]);\n      \n      for(int i = 1; i < v.size(); ++i) {\n\tint npos = Pos[v[i].second] ^ ~Own[v[i].second];\n\tif(npos != pos) ++cnt;\n\tpos = npos;\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n\nusing namespace std;\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<iomanip>\n#include<stack>\n#include<set>\n#include<functional>\n#include<map>\n#include<complex>\n#include<tuple>\ntypedef double D;\ntypedef bool B;\ntypedef complex<D> P;\ntypedef vector<P> Poly;\ntypedef pair<P, P> L;\ntypedef L LS;\n#define X real()\n#define Y imag()\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define DCl(a,b,l) P(a),(b);tie(a,b)=l;\nconst int dr[] = { 0, 1, 0, -1 };\nconst int dc[] = { 1, 0, -1, 0 };\nconst D EPS = 1e-9;\n\n#define DCl(a,b,l) P(a),(b);tie(a,b) =l;\nstruct cww{\n\tcww(){\n\t\tcin.tie();\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\nD dot(P a, P b){\n\treturn a.X*b.X + a.Y*b.Y;\n}\nD cross(P a, P b){\n\treturn a.X*b.Y - a.Y*b.X;\n}\nD ccw(P a, P b, P c){\n\treturn cross(b - a, c - a);\n}\nint sgn(P a, P b, P c){\n\tif (cross(b - a, c - a) > EPS)return 1;\n\tif (cross(b - a, c - a) < -EPS)return -1;\n\tif (dot(b - a, c - a) > -EPS)return 2;\n\tif (dot(a - b, c - b) > -EPS)return -2;\n\treturn 0;\n}\n\n\nD signed_distance_P_L(P p,L l){\n\tDCl(a, b, l);\n\treturn ccw(a, b, p) / abs(b - a);\n}\n\nB is_LS_LS(LS p,LS q){\n\tDCl(a, b, p);\n\tDCl(c, d, q);\n\treturn sgn(a, b, c)*sgn(a, b, d) <= 0\n\t&& sgn(c, d, a)*sgn(c, d, b) <= 0;\n}\nP cross_L_L(LS p,LS q){\n\tDCl(a, b, p);\n\tD d1 = signed_distance_P_L(a, q);\n\tD d2 = signed_distance_P_L(b, q);\n\treturn (a*d2 - b*d1) / (d2 - d1);\n}\n\n\nP input(){\n\tdouble x, y;\n\tcin >> x >> y;\n\treturn P(x, y);\n}\nint main(){\n\tint T; cin >> T;\n\twhile(T--){\n\t\tP A = input();\n\t\tP B = input();\n\t\tint N;\n\t\tcin >> N;\n\t\tvector<pair<LS,int>> M, O;\n\t\tREP(i, N){\n\t\t\tLS in = LS(input(), input());\n\t\t\tint type,pos; cin >> type>>pos;\n\t\t\tif (type)M.push_back({ in, pos });\n\t\t\telse O.push_back({ in, 1-pos });\n\t\t}\n\t\tmap<D, int> m;\n\t\tfor (auto ls : M)if (is_LS_LS({ A, B }, ls.first))m[abs(A-cross_L_L({ A, B }, ls.first))] = ls.second;\n\t\tfor (auto ls : O)if (is_LS_LS({ A, B }, ls.first))m[abs(A - cross_L_L({ A, B }, ls.first))] = ls.second;\n\t\tif (m.size()){\n\t\t\tint res = 0;\n\t\t\tint prv = m.begin()->second;\n\t\t\tfor (auto &it : m){\n\t\t\t\tif (prv != it.second)res++;\n\t\t\t\tprv = it.second;\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n#define INF (11111)\nstruct F{\n  double a,b;\n  bool ng;\n\n  double xs,ys,xt,yt;\n  F(int xs,int ys,int xt,int yt)\n  {\n    this->xs = (double)xs;\n    this->ys = (double)ys;\n    this->xt = (double)xt;\n    this->yt = (double)yt;\n    if(xt-xs==0){\n      ng = true;\n      a = INF;\n      b = INF;\n      return;\n    }\n    ng = false;\n    a = (this->yt-this->ys)/(this->xt-this->xs);\n    b = this->ys - a * this->xs;\n  }\n};\nint N;\nvector<PP> s;\n//vector<F> f;\ninline double abd(double a){ return a>0?a:-a; };\ninline void Fcheck(F a, F b,double& x,double& y){\n  if(a.ng){\n    if(b.ng){\n      x = INF;\n      y = INF;\n    }else{\n      x = a.xs;\n      y = b.ys+(a.xs-b.xs)*b.a;\n    }\n  }else if(b.ng){\n    if(a.ng){\n      x = INF;\n      y = INF;\n    }else{\n      x = b.xs;\n      y = a.ys+(b.xs-a.xs)*a.a;\n    }\n  }else if(b.a==a.a){\n    x = INF;\n    y= INF;\n  }else{\n    y =  (a.b*(-b.a) - b.b*(-a.a))/(-b.a - (-a.a));\n    x =  (b.b - a.b)/(-b.a - (-a.a));\n  }\n\n  if( !((double)min(a.xs,a.xt) <= x && (double)max(a.xs,a.xt) >= x &&\n\t(double)min(a.ys,a.yt) <= y && (double)max(a.ys,a.yt) >= y ) ){\n    x = INF;\n    y = INF;\n  }\n\n\t//Y=（ａ１ｃ２−ａ２ｃ１）／（ａ１ｂ２−ａ２ｂ１）\n}\nmain(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int xa,ya,xb,yb;\n    scanf(\"%d %d %d %d\",&xa,&ya,&xb,&yb);\n    F fs = F(xa,ya,xb,yb);\n    double nx = (double)min(xa,xb);\n    double ny = (double)min(ya,yb);\n    double xx = (double)max(xa,xb);\n    double xy = (double)max(ya,yb);\n    //    printf(\"y = %lfx + %lf\\n\",fs.a,fs.b);\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n      int xs,ys,xt,yt,o,l;\n      scanf(\"%d %d %d %d %d %d\",&xs,&ys,&xt,&yt,&o,&l);\n      F f = F(xs,ys,xt,yt);\n      //     printf(\"y = %lfx + %lf\\n\",f.a,f.b);\n      double X,Y;\n      Fcheck(f,fs,X,Y);\n      //              printf(\"X=%lf : Y=%lf\\n\",X,Y);\n      if(nx <= X && xx >= X && \n\t  ny <= Y && xy >= Y){\n\t//\t\tprintf(\"input : k=%lf \\n\",sqrt((X-fs.xs)*(X-fs.xs)+(Y-fs.ys)*(Y-fs.ys)));\n\ts.push_back(PP(sqrt((X-fs.xs)*(X-fs.xs)+(Y-fs.ys)*(Y-fs.ys)),P(o,l)));\n      }\n    }\n    sort(s.begin(),s.end());\n    /*  \n    for(int i=0;i<s.size();i++)\n\t  printf(\"xk=%lf, o=%d, l=%d\\n\",s[i].first,s[i].second.first,s[i].second.second);\n    */\n    int count=0;\n    int res=0;\n    int R;\n    if(!s.empty()){\n      if(!s[0].second.first){//他社\n\tif(s[0].second.second)//上\n\t  R = 0;\n\telse//地下\n\t  R = 1;\n      }\n      else{//自社\n\tif(s[0].second.second)//上\n\t  R = 1;\n\telse//下\n\t  R = 0;\n      }\n      for(int i=1;i<s.size();i++){\n\tif(s[i].second.second == R){//一致\n\t  if(!s[i].second.first){//他社\n\t    R = (R==1?0:1);\n\t    //\t    printf(\"change R = %d → %d , %d番目\\n\", (R==1?0:1),R,i);\n\t    count++;\n\t  }\n\t}else{//不一致\n\t  if(s[i].second.first){//自社\n\t    R = (R==1?0:1);\n\t    //\t    printf(\"change R = %d → %d , %d番目\\n\", (R==1?0:1),R,i);\n\t    count++;\n\t  }\n\t}\n      }\n      res = count;\n      /*   count = 0;\n\t   if(!s[s.size()-1].second.first){//他社\n\t   if(s[0].second.second)//上\n\t   R = 0;\n\t   else//下\n\t   R = 1;\n\t   }\n\t   else{//自社\n\t   if(s[s.size()-1].second.second)//上\n\t   R = 1;\n\t   else//下\n\t   R = 0;\n\t   }\n\t   for(int i=s.size()-2;i>-1;i--){\n\t   if(s[i].second.second == R){//一致\n\t   if(!s[i].second.first){//他社\n\t   R = (R==1?0:1);\n\t   count++;\n\t   }\n\t   }else{//不一致\n\t   if(s[i].second.first){//自社\n\t   R = (R==1?0:1);\n\t   count++;\n\t   }\n\t   }\n      \n\t   }*/\n    }\n    //    res = min(res,count);\n    \n    printf(\"%d\\n\",res);\n    \n    s.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(ll& x, ll& y, ll xo, ll yo, ll dx, ll dy) {\n\tll _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<ll> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (double)(yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x <= 0 || x >= r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef pair<P,bool> Q;\nD eps=1e-12;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool eq(D a,D b){return abs(a-b)<eps;}\nbool comp(const Q& xx,const Q& yy){\n\tP x=xx.fs,y=yy.fs;\n\tif(abs(x.real()-y.real())<eps){\n\t\treturn x.imag()<y.imag();\n\t}else{\n\t\treturn x.real()<y.real();\n\t}\n}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(eq(abs(a-c)+abs(c-b),abs(a-b))) return 0;\n\tif(eq(abs(a-b)+abs(b-c),abs(a-c))) return -2;\n\treturn 2;\n}\nbool iSS(L a,L b){\n\treturn ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0&&ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\tint T;\n\tcin>>T;\n\trep(tt,T){\n\t\tvector<Q> vc;\n\t\tD ax,ay,bx,by;\n\t\tint N;\n\t\tcin>>ax>>ay>>bx>>by>>N;\n\t\tL l=L(P(ax,ay),P(bx,by));\n\t\trep(i,N){\n\t\t\tD a,b,c,d;\n\t\t\tint e,f;\n\t\t\tcin>>a>>b>>c>>d>>e>>f;\n\t\t\tL s=L(P(a,b),P(c,d));\n\t\t\tif(iSS(l,s)){\n\t\t\t\tvc.pb(Q(intLL(l,s),e^f));\n\t\t\t}\n\t\t}\n\t\tif(vc.size()==0){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tsort(all(vc),comp);\n\t\tint ans=0;\n\t\tbool now=vc[0].sc;\n\t\trep(i,vc.size()){\n\t\t\tif(now^vc[i].sc){\n\t\t\t\tans++;\n\t\t\t\tnow=vc[i].sc;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <complex>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nclass L{\npublic:\n  P a, b;\n  L (P aa, P bb) { a = aa; b = bb; }\n  L (ld ax, ld ay, ld bx, ld by) { a = P(ax, ay); b = P(bx, by); }\n};\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nVP is_ll(L s, L t){\n  VP v;\n  P sv = s.b - s.a, tv = t.b - t.a;\n  if (abs(cross(sv,tv)) > 0)\n    v.push_back(s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv));\n  return v;\n}\n\nint main() {\n  int m;\n  cin >> m;\n  REP(i,m) {\n    ld xa,ya,xb,yb;\n    cin >> xa >> ya >> xb >> yb;\n    P s(xa,ya), t(xb,yb);\n    L nl(s,t);\n    int n;\n    cin >> n;\n    vector<L> vl;\n    VP crt;\n    VP crb;\n    REP(j,n){\n      double xs, ys, xt, yt;\n      int o,l;\n      cin >> xs >> ys >> xt >> yt >> o >> l;\n      P sj(xs,ys), tj(xt,yt);\n      L lj(sj,tj);\n      VP vp = is_ll(nl,lj);\n      if(!vp.empty()){\n        if(isis_sp(nl,vp[0]) && isis_sp(lj,vp[0])){\n          if(o == l)\n            crt.push_back(vp[0]);\n          else\n            crb.push_back(vp[0]);\n        }\n      }\n    }\n    sort(begin(crt),end(crt), [&](P l, P r){ return norm(l-s) < norm(r-s); });\n    sort(begin(crb),end(crb), [&](P l, P r){ return norm(l-s) < norm(r-s); });\n    int k=0;\n    int cnt = 0;\n    REP(j,crt.size()){\n      bool b = false;;\n      while(k<crb.size() && norm(crb[k]-s) < norm(crt[j]-s)) {\n        ++k;\n        b = true;\n      }\n      if(b) {\n        if (j)\n          cnt += 2;\n        else\n          cnt += 1;\n      }\n    }\n    if (k < crb.size() && !crt.empty())\n      cnt += 1;\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\ntypedef vector<P> G;\nG readG(int n){\n  double x,y;\n  G g;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n  }\n  return g;\n}\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\n// a < b : -1, a > b : 1, a == b : 0\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin >> n;\n  L l;\n  l.readL();\n  int o,h;\n  rep(i,n){\n    cin >> m;\n    vector<pair<P,pair<bool,bool>>> ab(m);//a[i](crosspoint,h)\n    rep(j,m){\n      L t;\n      t.readL();\n      cin >> o >> h;\n      P p = intersectLL(l,t);\n      ab[j] = mp(p,mp(h,o));\n    }\n    ab.push_back(mp(l[1],mp(-1,-1)));\n    sort(all(ab));\n    int s = 0;\n    if(ab[0].se.se){\n      s = ab[0].se.fi;\n    }\n    else{\n      s = !ab[0].se.fi;\n    }\n    int cnt = 0,u = 1;\n    while(u <= m){\n      h = ab[u].se.fi,o = ab[u].se.se;\n      if(h != ab[u-1].se.fi){\n        ++cnt;\n      } \n      /* if(o){        */\n      /*   if(h != s){ */\n      /*     s = h;    */\n      /*     ++cnt;    */\n      /*   }           */\n      /* }             */\n      /* else{         */\n      /*   if(h != s){ */\n      /*     s = h;    */\n      /*     ++cnt;    */\n      /*   }           */\n      /* }             */\n      ++u;\n    }\n    cout << cnt << endl;\n    // ???????????¨??´?????¨????????¨????????????????????????\n    // ???????§??????¨????????¨?????????????????¢???????°??????????????????????????????°????????¶?????????????????????????????????????????????\n    // ????????????????????????????????¨??¶?????????????????????h = !h???ans++\n    // ??????????????¨??¶???????????????\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cassert>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing namespace std;\n\nconst double eps = 1e-6;\ntypedef complex<double> point;\nstruct circle { point c; double r; };\nstruct line { point s, t; };\nstruct segment { point s, t; };\nstruct ray { point s, t; };\ndouble   dot(point p, point q) { return real(p * conj(q)); }\ndouble cross(point p, point q) { return imag(conj(p) * q); }\nint ccw(point a, point b, point c) { double z = cross(b - a, c - a); return z > eps ? 1 : z < - eps ? -1 : 0; }\nbool does_intersect(point a, line b) {\n    return ccw(0, a - b.s, b.t - b.s) == 0;\n}\nbool does_intersect(line a, point b) {\n    return does_intersect(b, a);\n}\nbool is_parallel(line a, line b) {\n    return ccw(0, a.t - a.s, b.t - b.s) == 0;\n}\nbool is_overwraped(line a, line b) {\n    return does_intersect(a.s, b)\n        and does_intersect(a.t, b);\n}\nbool does_intersect(line a, line b) {\n    return not is_parallel(a, b)\n        and not is_overwraped(a, b);\n}\npoint intersection(line a, line b) {\n    assert (does_intersect(a, b));\n    double p = cross(a.t - a.s, b.t - b.s);\n    double q = cross(a.t - a.s, a.t - b.s);\n    return (q / p) * (b.t - b.s) + b.s;\n}\nbool does_intersect(point a, segment b) {\n    return abs(cross(b.t - b.s, a - b.s)) < eps\n        and dot(b.t - b.s, a - b.s) > - eps\n        and dot(b.s - b.t, a - b.t) > - eps;\n}\nbool does_intersect(segment a, point b) {\n    return does_intersect(b, a);\n}\ntemplate <typename T, typename U>\nbool does_intersect_linelikes(T const & a, U const & b) {\n    if (not does_intersect(to_line(a), to_line(b))) return false;\n    point c = intersection(to_line(a), to_line(b));\n    return does_intersect(a, c)\n        and does_intersect(b, c);\n}\nline to_line(segment a) {\n    return { a.s, a.t };\n}\nbool does_intersect(segment a, segment b) {\n    return does_intersect_linelikes(a, b);\n}\npoint intersection(segment a, segment b) {\n    assert (does_intersect(a, b));\n    return intersection(to_line(a), to_line(b));\n}\n\nint main() {\n    int testcase; scanf(\"%d\", &testcase);\n    while (testcase --) {\n        segment a; { int ax, ay, bx, by; scanf(\"%d%d%d%d\", &ax, &ay, &bx, &by); a = { point(ax, ay), point(bx, by) }; }\n        int n; scanf(\"%d\", &n);\n        vector<pair<double, bool> > events;\n        repeat (i, n) {\n            segment b; { int ax, ay, bx, by; scanf(\"%d%d%d%d\", &ax, &ay, &bx, &by); b = { point(ax, ay), point(bx, by) }; }\n            int o, t; scanf(\"%d%d\", &o, &t);\n            if (does_intersect(a, b)) {\n                point p = intersection(to_line(a), to_line(b));\n                events.emplace_back(abs(p - a.s), o ^ t);\n            }\n        }\n        whole(sort, events);\n        int last = -1;\n        int result = 0;\n        for (auto event : events) {\n            bool type = event.second;\n            if (last != -1 and last != int(type)) {\n                result += 1;\n            }\n            last = int(type);\n        }\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\n#include <complex>\ntypedef complex<double> P;\n\n#define EQ(x,y) (abs((x)-(y))<EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real())&&EQ((a).imag(),(b).imag()))\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn a.real()!=b.real() ? a.real()<b.real() : a.imag()<b.imag();\n\t}\n}\n\ndouble cross(P a, P b) {\n\treturn a.real()*b.imag()-a.imag()*b.real();\n}\n\nint is_point_on_ls(P a, P b, P c) {\n\treturn (abs(a-c)+abs(c-b)<abs(a-b)+EPS);\n}\n\nint is_intersection_ls(P a1, P a2, P b1, P b2) {\n\tif((cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < -EPS) &&\n\t\t(cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < -EPS))\n\t\treturn true;\n\treturn is_point_on_ls(a1, a2, b1) || is_point_on_ls(a1, a2, b2) ||\n\t\tis_point_on_ls(b1, b2, a1) || is_point_on_ls(b1, b2, a2);\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n\tP b = b2-b1;\n\tdouble d1 = abs(cross(b, a1-b1));\n\tdouble d2 = abs(cross(b, a2-b1));\n\tdouble t = d1/(d1+d2);\n\n\treturn a1+(a2-a1)*t;\n}\n\ntypedef vector<P> vp;\n\nstruct crossPoint {\n\tP p;\n\tpii info;\n\tcrossPoint(P p, pii info) : p(p), info(info) {};\n};\n\nnamespace std {\n\tbool operator<(const crossPoint &a, const crossPoint &b) {\n\t\treturn a.p.real()!=b.p.real() ? a.p.real()<b.p.real() : a.p.imag()<b.p.imag();\n\t}\n}\n\nint getUpDown(int f, vector<crossPoint> cp) {\n\tint res = 0;\n\tint size = cp.size();\n\tREP(i, size) {\n\t\tif(cp[i].info.first == 0) {\n\t\t\tif(f != cp[i].info.second) {\n\t\t\t\tf = 1-f;\n\t\t\t\tres++;\n\t\t\t}\n\t\t} else {\n\t\t\tif(f == cp[i].info.second) {\n\t\t\t\tf = 1-f;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tint m;\n\tcin >> m;\n\tREP(szg, m) {\n\t\tdouble xa, ya, xb, yb;\n\t\tint n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\t\tP a = P(xa, ya), b = P(xb, yb); \n\t\t\n\t\tdouble xs, ys, xt, yt;\n\t\tvi o(n), l(n);\n\t\tvector<vp> lines(n, vp(2));\n\t\tREP(i, n) {\n\t\t\tcin >> xs >> ys >> xt >> yt >> o[i] >> l[i];\n\t\t\tlines[i][0] = P(xs, ys);\n\t\t\tlines[i][1] = P(xt, yt);\n\t\t}\n\n\t\tvi isCross(n, 0);\n\t\tvector<crossPoint> cp;\n\t\tREP(i, n) {\n\t\t\tif(is_intersection_ls(a, b, lines[i][0], lines[i][1])) {\n\t\t\t\tP p = intersection_ls(a, b, lines[i][0], lines[i][1]);\n\t\t\t\tcp.push_back(crossPoint(p, pii(o[i], l[i])));\n\t\t\t}\n\t\t}\n\n\t\tsort(ALL(cp));\n\t\tint size = cp.size();\n\t\tint ans = min(size, min(getUpDown(0, cp), getUpDown(1, cp)));\n\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n#define EPS (1.0e-9)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = fabs(cross(s1.p1 - s2.p1, base));\n  double d2 = fabs(cross(s1.p2 - s2.p1, base));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\ndouble getTofCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = fabs(cross(s1.p1 - s2.p1, base));\n  double d2 = fabs(cross(s1.p2 - s2.p1, base));\n  return d1/(d1+d2);\n}\n\nSegment S;\nint N;\nSegment Q[100];\nint O[100], H[100];\n\nclass CrossPoint {\npublic:\n  int o, l;\n  double t;\n  CrossPoint(int o, int l, double t) : o(o), l(l), t(t) {}\n  bool operator < (const CrossPoint &cp) const {\n    return t < cp.t;\n  }\n};\n\nvoid solve() {\n  vector<CrossPoint> cp;\n\n  for(int i = 0; i < N; ++i) {\n    if(!isIntersect(S, Q[i])) continue;\n    cp.push_back(CrossPoint(O[i], H[i], getTofCrossPoint(S, Q[i])));\n  }\n  if(cp.size() == 0) {\n    cout << 0 << endl;\n    return;\n  }\n  sort(cp.begin(), cp.end());\n\n  int ans = 0;\n  int nl;\n\n  if(cp[0].o == 1) nl = cp[0].l;\n  else             nl = 1 - cp[0].l;\n  for(int i = 1; i < cp.size(); ++i) {\n    if(cp[i].o == 1 && cp[i].l != nl ||\n       cp[i].o == 0 && cp[i].l == nl ) {\n      nl = 1 - nl;\n      ++ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nmain() {\n  int T;\n  cin >> T;\n  for(int t = 0; t < T; ++t) {\n    cin >> S.p1.x >> S.p1.y >> S.p2.x >> S.p2.y;\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n      cin >> Q[i].p1.x >> Q[i].p1.y >> Q[i].p2.x >> Q[i].p2.y\n\t  >> O[i] >> H[i];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\nSeg side_G(const G& g, int i)\n{\n    return Seg(g[i], g[(i + 1) % g.size()]);\n}\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n/////////////////// \n\n\nint main()\n{\n    fast_io();\n\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        Seg s;\n        cin >> s.first >> s.second;\n        // Point rota(1, -arg(s.second - s.first));\n        // s.first *= rota, s.second *= rota;\n        \n        \n        vector<pair<Point, bool> > c;\n        int n;\n        cin >> n;\n        rep(i, n)\n        {\n            Seg t;\n            int o, l;\n            cin >> t.first >> t.second >> o >> l;\n            // t.first *= rota, t.second *= rota;\n            if (intersect_SS(s, t))\n                c.pb(mp(ip_SS(s, t), (o ^ l)));\n        }\n        sort(all(c));\n\n        int res = 0;\n        rep(i, (int)c.size() - 1)\n            if (c[i].second != c[i + 1].second)\n                ++res;\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dp[11][100001];\nint n, d, x;\nint p[10][10];\n\nint main(){\n\tcin >> n >> d >> x;\n\trep(i,d) rep(j,n) cin >> p[i][j];\n\trep(i,d) rep(j,100001) dp[i][j] = j;\n\tfor(int i = d-2; i >= 0; i--){\n\t\tfor(int j = 1; j <= 100000; j++){\n\t\t\tdp[i][j] = max(dp[i][j],dp[i+1][j]);\n\t\t\tdp[i][j] = max(dp[i][j],dp[i][j-1]+1);\n\t\t\trep(k,n){\n\t\t\t\tif(p[i][k] > j) continue;\n\t\t\t\tfor(int l = i+1; l < d; l++){\n\t\t\t\t\tif(p[i][k] >= p[l][k]) continue;\n\t\t\t\t\tcout << p[l][k] + dp[i][j-p[i][k]] << endl;\n\t\t\t\t\tdp[i][j] = max(dp[i][j],dp[l][p[l][k]+dp[i][j-p[i][k]]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[0][x] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int i,j;\n    int t;\n    cin >> t;\n    while(t--){\n        L l = inL();//a:l[0],b:l[1]\n        int n;\n        cin >> n;\n\n        vector<pair<double,int> > v;\n\n        rep(i,n){\n            L seg = inL();\n            int a,b;\n            cin >> a >> b;//会社、地上地下\n            if(!intersectSS(l,seg))continue;\n            P p = crosspointSS(l,seg);\n            double dist = distancePP(p, l[0]);\n            v.push_back(make_pair(dist,a^b));\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n\n        rep(i,v.size()-1){\n            if(v[i].second != v[i+1].second) ans++;\n        }\n\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define y1 y114514\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<double,int> Pair;\n\nint u, n;\ndouble xa, ya, xb, yb;\ndouble x1, y1, x2, y2;\nint o, l;\nvector<Pair> v;\n\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n  return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n         ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nint main(){\n\tP a, b;\n\tscanf(\"%d\",&u);\n\trep(i,u){\n\t\tscanf(\"%lf%lf%lf%lf\",&xa,&ya,&xb,&yb);\n\t\ta = (xa,ya); b = (xb, yb);\n\t\tcin >> n;\n\t\trep(j,n){\n\t\t\tcin >> x1 >> y1 >> x2 >> y2 >> o >> l;\n\t\t\tif(l == 0) o = o^1;\n\t\t\tP c = (x1,y1), d = (x2,y2);\n\t\t\tif(is_intersected_ls(a,b,c,d) == 0) continue;\n\t\t\tP e = intersection_ls(a,b,c,d);\n\t\t\tv.push_back(Pair(sqrt(pow(e.real()-a.real(),2)+pow(e.imag()-a.imag(),2)),o));\n\t\t}\n\t\tint ans = 0;\n\t\tint st = 0;\n\t\tint cnt = 0;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = cnt;\n\t\tcnt = 0;\n\t\tst = 1;\n\t\trep(j,v.size()){\n\t\t\tif(st != v[j].second){\n\t\t\t\tst = st^1;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans,cnt);\n\t\tcout << ans << endl;\n\t\tv.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\ndouble xmax, xmin, ymax, ymin;\nstruct vec{\n  double x, y;\n  vec operator+(const vec& a) const { return (vec){x + a.x, y + a.y}; }\n  vec operator-(const vec& a) const { return (vec){x - a.x, y - a.y}; }\n  vec sca(double t){ return (vec){t * x, t * y}; }\n  double dot(vec a){ return x * a.x + y * a.y; }\n  double cross(vec a){ return x * a.y - y * a.x; }\n  double norm(){ return sqrt(x * x + y * y); }\n  double norm2(){ return x * x + y * y; }\n};\nstruct line{\n  vec a, b;\n  void nextline(){ cin >> a.x >> a.y >> b.x >> b.y; return; }\n  vec getvec(){ return b - a; }\n  double size(){ return getvec().norm(); }\n  vec proj(vec p){ return a + (b - a).sca((p - a).dot(b - a) / (b - a).dot(b - a)); }\n  vec vref(vec p){ return proj(p).sca(2.0) - p; }\n  int ccw(vec p){\n    vec q = p - a, ba = b - a;\n    if(ba.cross(q) > 0)return 1; //ccw\n    if(ba.cross(q) < 0)return -1; //cw\n    if(ba.dot(q) < 0)return -2; //back\n    if(ba.dot(ba) < q.dot(q))return 2; //front\n    return 0; //on\n  }\n  bool paral(line l){ return abs(l.getvec().cross(getvec())) < eps; }\n  bool orth(line l){ return abs(l.getvec().dot(getvec())) < eps; }\n  bool intersec(line l){\n    bool res0 = (ccw(l.a) * ccw(l.b) == 4); //syukutai\n    bool res1 = (getvec().cross(l.a - a) * getvec().cross(l.b - a)) <= eps;\n    bool res2 = (l.getvec().cross(a - l.a) * l.getvec().cross(b - l.a)) <= eps;\n    return !res0 && res1 && res2;\n  }\n  vec crosspoint(line l){\n    return a + getvec().sca((l.a - a).cross(l.getvec()) / getvec().cross(l.getvec()));\n  }\n  double pldist(vec p){\n    double res = min((a - p).norm2(), (b - p).norm2());\n    vec h = proj(p);\n    if((a - h).dot(b - h) < 0)res = min(res, (h - p).norm2());\n    return sqrt(res);\n  }\n  double lldist(line l){\n    if(intersec(l))return 0.0;\n    return min(min(pldist(l.a), pldist(l.b)), min(l.pldist(a), l.pldist(b)));\n  }\n};\n\nstruct crossp{\n  double d;\n  int ol;\n};\nbool comp(crossp a, crossp b){ return a.d < b.d; }\n\nvector<crossp> ans;\n\nsigned main(void){\n  int i, j, k;\n  int(times);\n  for(;times--;){\n    line l; l.nextline();\n\n    int(n);\n    rep(i, n){\n      line m; m.nextline();\n      int2(tmp, tnp);\n      if(tmp == 0)tmp = -1;\n      if(tnp == 0)tnp = -1;\n      if(l.intersec(m)){\n        vec p = l.crosspoint(m);\n        ans.pb((crossp){(p - l.a).norm2(), tmp * tnp });\n      }\n    }\n    sort(ans.begin(), ans.end(), comp);\n    int res = 0;\n    rep1(i, ans.size()){\n      if(ans[i].ol * ans[i - 1].ol == -1)res++;\n    }\n    pri(res);\n\n    ans.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)<<\" \"\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nint INF=1<<28;\n\nnamespace geo{\n    const double EPS = 1e-9;\n    typedef double PT;typedef complex<PT> P;\n    typedef P vecP;typedef vector<P> Polygon;\n\n    template<typename T>bool LT(T a,T b){return a+EPS<b;}\n    template<typename T>bool GT(T a,T b){return LT(b,a);}\n    template<typename T>bool EQ(T a,T b){return !LT(a,b) && !GT(a,b);}\n\n    namespace VU{\n            static PT x(const vecP& a){return real(a);}\n            static PT y(const vecP& a){return imag(a);}\n            \n            // ベクタの長さ\n            static PT length(const vecP& a){return abs(a);}\n            // 単位ベクトル\n            static vecP unit_vector(const vecP& a){return a / abs(a);}\n            // 法線ベクトル\n            static pair<vecP,vecP> normal_vector(const vecP& a){return make_pair(a * vecP(0,1),a * vecP(0,-1));}\n            // 内積 (dot product) : a・b = |a||b|cosΘ\n            PT dot(const vecP& a,const vecP& b){return x(conj(a)*b);}\n            // 外積 (cross product) : |a×b| = |a||b|sinΘ\n            PT cross(const vecP& a,const vecP& b){return y(conj(a)*b);}\n            //点aと点bの距離\n            static PT dist(const P& a,const P& b){return abs(a-b);}\n\n            // 点の進行方向\n            int ccw(P a,P b,P c){\n                b -= a;c -= a;\n                if(LT(cross(b,c),0.0)) return +1;    // counter clockwise\n                if(GT(cross(b,c) ,0.0)) return -1;    // clockwise\n                if(EQ(dot(b,c),0.0)) return +2;      // c -- a -- b\n                if(norm(b) < norm(c)) return -2; // a -- b -- c\n                return 0;\n            }\n\n    }\n    using namespace VU;\n};\nusing namespace geo;\nnamespace std{\n    bool operator <(const P &lhs,const P &rhs){\n        if(x(lhs) == x(rhs))return y(lhs) < y(rhs);\n        return x(lhs) < x(rhs);\n    }\n}\n\nnamespace geo{\n    struct L{\n        P p1,p2;\n        L(P p1,P p2):p1(p1),p2(p2){}\n        vecP vec(){\n            return p2-p1;\n        }\n        //点との距離\n        double line_dist(const P& b){\n            return abs(cross(vec(),b-p1)) / abs(vec());\n        }\n        double linesegment_dist(const P& b){\n                if(EQ(dot(p2-p1,b-p1),0.0)) return abs(b-p1);\n                if(EQ(dot(p1-p2,b-p2) ,0.0)) return abs(b-p2);\n                return line_dist(b);\n        }\n        double linesegment_dist(L& b){\n            if(is_intersected(b))return 0;\n            return min(min( linesegment_dist(b.p1),linesegment_dist(b.p2) ),\n            min(b.linesegment_dist(p1),b.linesegment_dist(p2)));\n        }\n\n             //線分同士の交差判定\n        bool is_intersected(L& b){\n            if(LT(max(x(p1),x(p2)),min(x(b.p1),x(b.p2)))) return false;\n            if(LT(max(x(b.p1),x(b.p2)),min(x(p1),x(p2)))) return false;\n            if(LT(max(y(p1),y(p2)),min(y(b.p1),y(b.p2)))) return false;\n            if(LT(max(y(b.p1),y(b.p2)),min(y(p1),y(p2)))) return false;\n            return cross(vec(),b.p1-p1)*cross(vec(),b.p2-p1)<EPS  && cross(b.vec(),p1-b.p1)*cross(b.vec(),p2-b.p1)<EPS ;\n        }\n\n        bool is_intersected_line(L& b) {\n            return !is_parallel(b);\n        }\n\n        P intersection_point(L& b) {\n            if(EQ(p1,b.p1) || EQ(p1,b.p2)) return p1;if(EQ(p2,b.p1) || EQ(p2,b.p2)) return p2;\n            return p1 + vec() * cross(b.vec(), b.p1-p1) / cross(b.vec(), vec());\n        }\n        P intersection_ls(L& b) {\n          double d1 = abs(cross(b.vec(), p1-b.p1));\n          double d2 = abs(cross(b.vec(), p2-b.p1));\n          if(d1 + d2 == 0) return P(INF,INF);\n          double t = d1 / (d1 + d2);\n          return p1 + (p2-p1) * t;\n        }\n        // 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n        // みけんしょう\n        bool is_orthogonal(L& b) {return EQ(dot(vec(),b.vec()),0.0);}\n        // 2直線の平行判定 : a//b <=> cross(a, b) = 0\n        bool is_parallel(L& b) {return EQ(cross(vec(),b.vec()),0.0);}\n\n        // 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\n        P nearest_point_line(P b){\n            return p1 + vec() * dot(vec(),b-p1) / norm(vec());\n        }\n        // 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\n        P nearest_point_linesegment(P b){\n            if(EQ(dot(vec(),b-p1),0.0)) return p1;\n            if(EQ(dot(vec(),b-p2),0.0)) return p2;\n            return nearest_point_line(b);\n        }\n    };\n}\n\nint main(){\n\tint C;cin >> C;\n\twhile(C--!=0){\n\t\tint xa,ya,xb,yb;cin >> xa >> ya >> xb >> yb;\n\t\tL base(P(xa,ya),P(xb,yb));\n\t\tint n;cin >> n;\n\t\tvector<pair<pair<P,int>,int>> inps;\n\t\tREP(i,n){\n     \t\t\tint xs,ys,xt,yt,o,l;cin >> xs >> ys >> xt >> yt >>o >> l;\n\t\t\tL line=L(P(xs,ys),P(xt,yt));\n\t\t\tif(base.is_intersected(line))inps.push_back(make_pair(make_pair(base.intersection_ls(line),o),l));\n\t\t}\n\t\tsort(ALL(inps));\n                        int prev=-1;\n                        {\n                            int o=inps[0].first.second,l=inps[0].second;\n                            if(o)prev=l;else prev=!l;\n                        }\n                        int res=0;\n                        for(int i=1;i<inps.size();i++){\n                            int o=inps[i].first.second,l=inps[i].second;\n                            if(o){\n                                if(prev!=l)res++;\n                                prev=l;\n                            }else{\n                                if(prev!=!l)res++;\n                                prev=!l;\n                            }\n                        }\n                        cout <<res<<endl;\n            }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define shosu(x) fixed<<setprecision(x)\n#define diff(P,i) (P[(i+1)%P.size()] - P[i])\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L(){;}\n};\nstruct C {\n  P c;double r;\n  C(const P &c,double r):c(c),r(r){}\n};\n\nnamespace std{//演算子の定義\n  bool operator < (const P& a,const P& b) {\n    return real(a)!= real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    //return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b)\n  }\n  bool operator == (const P& a,const P& b) {\n    return a.real()==b.real() && a.imag()==b.imag();\n  }\n}\n\n\nvoid printP(const P &p){\n  cout << shosu(10) << p.real() << \" \" << p.imag() << endl;\n}\n\nvoid printL(const L &l) {\n  \tcout << shosu(10) << l[0].real() << \" \" << l[0].imag() << \" \" << l[1].real() << \" \" << l[1].imag() << endl;\n}\n\nvoid printG(const G &g) {\n  for(int i = 0; i < g.size(); i++){\n    cout << shosu(10) << g[i].real() << \" \" << g[i].imag() << endl;\n  }\n}\n\n\n\ndouble dot(P a,P b) {\n  return real(conj(a)*b);\n}\n\ndouble cross(P a,P b) {\n  return imag(conj(a)*b);\n}\n\nP orth(const P &a, const P &b) { //点aを(点bを基準として)90度回転した点\n  P p = a-b;\n  P q(-p.imag(), p.real());\n  return q + b;\n}\n\nint ccw(P a, P b, P c) { //3点の関係性\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\n\nP projection(const L &l, const P &p) { //pの直線l上の射影の点\n  double t=dot(p-l[0],l[0]-l[1])/norm(l[0]-l[1]);\n  return l[0]+t*(l[0]-l[1]);\n}\n\nP reflection(const L &l, const P &p) { //点pの直線lに関して対称な点\n  return p+2.0*(projection(l,p)-p);\n}\n\nbool isorthogonal(const L &l, const L &m) { //2直線の直交判定\n  return fabs(dot(l[1]-l[0], m[1]-m[0])) < EPS;\n}\n\nbool isparallel(const L &l, const L &m) { //2直線の平行判定\n  return fabs(cross(l[1]-l[0],m[1]-m[0])) < EPS;\n}\n\nbool intersectLL(const L &l, const L &m) { //2直線の交差判定\n  return !isparallel(l,m);\n}\n\nbool intersectSS(const L &s, const L &t) { //2線分の交差判定(完全に交差してないとだめ)\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectSP(const L &s, const P &p) { //直線と点の交差判定\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // 三角不等式\n}\n\n\nP crosspointSS(const L &a, const L &b) { //2線分の交点\ndouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\ndouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\nreturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\n\nP crosspointLL(const L &l, const L &m) { //2直線の交点\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nL crosspointCL(C c,L l){ //円と直線の交点\n\tP pr = projection(l,c.c);\n\tP e = (l[1] - l[0]) / abs(l[1] - l[0]);\n\tdouble tmp = c.r * c.r - norm(pr - c.c);\n\tif(abs(tmp) < EPS) tmp = 0;\n\tdouble t = sqrt(tmp);\n\tP a = pr + t * e;\n\tP b = pr - t * e;\n\tif(b < a) swap(a,b);\n\treturn L(a,b);\n}\n\nL crosspointCC(C a,C b){ //2円の交点\n\tP tmp = b.c - a.c;\n\tdouble d = abs(tmp);\n\tdouble q = acos((a.r * a.r + d * d - b.r * b.r)/(2 * a.r * d));\n\tdouble t = arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1 = a.c + polar(a.r, t + q);\n\tP p2 = a.c + polar(a.r, t - q);\n\tif(p2 < p1) swap(p1,p2);\n\treturn L(p1, p2);\n}\n\n\ndouble distancePP(const P &p, const P &q){ //2点間の距離\n  return hypot(p.real()-q.real(), p.imag()-q.imag());\n}\n\ndouble distanceSP(const L &s, const P &p) {//直線と点との距離\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\ndouble distanceSS(const L &s, const L &t) {//2線分の距離\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n\n\n\nP turn(P p,double t){ // 回転\n    return p*exp(P(.0,t*PI/180.0));\n}\n\n\nvector<L> tangentCC(C a,C b){ //2円の接線\n\tif(a.r < b.r) swap(a,b);\n\tdouble d = abs(a.c - b.c);\n\tvector<L> l;\n\tif(d < EPS) return l;\n\tif(a.r + b.r < d - EPS){ //離れている\n\t\tdouble t = acos((a.r + b.r)/d);\n\t\tt = t * 180 / PI;\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), t), b.c + turn(b.r / d * (a.c-b.c), t)));\n\t\tl.push_back(L(a.c + turn(a.r/d*(b.c-a.c), -t), b.c + turn(b.r / d * (a.c-b.c), -t)));\n\t}else if(a.r + b.r < d + EPS){ //外接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\tif(abs(a.r - b.r) < d - EPS){ //交わっている\n\t\tdouble t1 = acos((a.r - b.r) / d);\n\t\tt1 = t1 * 180 / PI;\n\t\tdouble t2 = 180 - t1;\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c-a.c), t1), b.c + turn(b.r / d * (a.c - b.c), -t2)));\n\t\tl.push_back(L(a.c + turn(a.r / d * (b.c - a.c), -t1),b.c + turn(b.r / d * (a.c - b.c), t2)));\n\t}else if(abs(a.r - b.r) < d + EPS){ //内接\n\t\tP p = a.c + a.r / d * (b.c - a.c);\n\t\tl.push_back(L(p, p + turn(b.c - a.c, 90)));\n\t}\n\treturn l;\n}\n\nL tangentCP(const C &c, const P &p) { //円cの外部にある点pを通るcの接線の接点\n  double d = distancePP(c.c,p);\n  double r = sqrt(d*d - c.r * c.r);\n  C cc(p,r);\n  return crosspointCC(c,cc);\n}\n\n\ndouble area(const G &g) { //多角形の面積\n    double S =0;\n    for(int i = 0; i < g.size(); i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\n\nbool isconvex(const G &g) { //凸かどうか(全ての内角の大きさが180度以下)\n\tint n = g.size();\n  for(int i = 0; i < n; i++)\n    if(ccw(g[(i+n-1)%n], g[i%n], g[(i+1)%n])==-1) return false;\n\treturn true;\n}\n\nint inconvex(const G& g, const P& p) { //多角形と点の関係\n\tbool in = false;\n\tint n = g.size();\n\tfor(int i = 0; i < n; i++){\n\t\tP a = g[i%n] - p;\n\t\tP b = g[(i+1)%n] - p;\n\t\tif(imag(a) > imag(b)) swap(a, b);\n\t\tif(imag(a) < EPS && 0 < imag(b))if(cross(a,b) < 0)in = !in;\n\t\tif(abs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;//ON\n\t}\n\treturn in ? 2 : 0;//IN : OUT;\n}\n\nG convex_hull(G &ps) { // 凸包(点集合 P の全ての点を含む最小の凸多角形)\n  int n = ps.size(), k = 0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i = 0; i < n; ch[k++] = ps[i++])//lower-hull\n\t\twhile(k >= 2 && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//<=0  ->  ==-1\n\tfor(int i = n-2,t = k+1; i >= 0; ch[k++] = ps[i--])//upper-hull\n\t\twhile(k >= t && ccw(ch[k-2],ch[k-1],ps[i]) == -1) --k;//\n\tch.resize(k-1);\n\treturn ch;\n}\n\ndouble convex_diameter(const G &pt) { //凸多角形の直径(最遠頂点対間距離)\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is] - pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i] - pt[j]) > maxd) {\n      maxd = norm(pt[i] - pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\n\n\nG convex_cut(const G& g, const L& l) { //凸多角形の切断\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a = g[i], b = g[(i+1)%g.size()];\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\n\n\nL PerpendicularBisector(const L &l) { //線分の垂直二等分線\n  P p = l[0];\n  P q((l[0].real() + l[1].real())/2.0, (l[0].imag() + l[1].imag())/2.0);\n  L t(q, orth(p,q));\n  return t;\n}\n\nP CircumscribedCircle(const G &g) { //三角形の外接円の半径\n  L l1(g[0],g[1]);\n  L l2(g[1],g[2]);\n  L m1 = PerpendicularBisector(l1);\n  L m2 = PerpendicularBisector(l2);\n  return crosspointLL(m1, m2);\n}\n\n\nP inP(){\n  double x,y;\n//  scanf(\"%lf,%lf\", &x, &y);\n  cin >> x >> y;\n  P p(x,y);\n  return p;\n}\n\n\nL inL(){\n  P p1 = inP();\n  P p2 = inP();\n  L l(p1,p2);\n  return l;\n}\n\nC inC(){\n  P p = inP();\n  double r;\n  cin >> r;\n  C c(p,r);\n  return c;\n}\n\n\nG inG(int n){\n  G g(n);\n  for(int i = 0; i < n; i++){\n    g[i] = inP();\n  }\n  return g;\n}\n\n\n\nint main(void) {\n    int i,j;\n    int t;\n    cin >> t;\n    while(t--){\n        L l = inL();//a:l[0],b:l[1]\n        int n;\n        cin >> n;\n\n        vector<pair<double,int> > v;\n\n        rep(i,n){\n            L seg = inL();\n            int a,b;\n            cin >> a >> b;//会社、地上地下\n            if(!intersectSS(l,seg))continue;\n            P p = crosspointSS(l,seg);\n            double dist = distancePP(p, l[0]);\n            v.push_back(make_pair(dist,(int)a!=b));\n        }\n\n        sort(all(v));\n\n        int ans = 0;\n\n        rep(i,v.size()-1){\n            if(v[i].second != v[i+1].second) ans++;\n        }\n\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nstruct edgeInfo{\n    P a;\n    P b;\n    int o;\n    int l;\n};\n\nP p1,p2;\n\nclass Point{\npublic:\n    P p;\n    int l;\n    int o;\n    int t;\n\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<edgeInfo> edges;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            edgeInfo e;\n            e.a=P(xs,ys);\n            e.b=P(xt,yt);\n            e.l=l;\n            e.o=o;\n            edges.push_back(e);\n        }\n        vector<Point> crossPoint;\n        // ð_ðßé\n        for(int i = 0;i < n; i++){\n            if(is_intersected_ls(edges[i].a,edges[i].b,p1,p2)){\n                P res=intersection_ls(edges[i].a,edges[i].b,p1,p2);\n                Point pp;\n                pp.l=edges[i].l;\n                pp.o=edges[i].o;\n                pp.p=res;\n                pp.t=pp.l^pp.o;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n\n        if(crossPoint.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit=0;\n        sit=crossPoint[0].t;\n        // ð_ðp1Éß¢ÔÉ\n        int cnt=0;\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].t!=sit){\n                sit=crossPoint[i].t;\n                cnt++;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ndouble EPS = 1e-9;\nint sign(double x){\n  if (x > EPS){\n    return 1;\n  } else if (x < - EPS){\n    return -1;\n  } else {\n    return 0;\n  }\n}\nstruct point{\n  double x, y;\n  point(){\n  }\n  point(double x, double y): x(x), y(y){\n  }\n  point operator +(point P){\n    return point(x + P.x, y + P.y);\n  }\n  point operator -(point P){\n    return point(x - P.x, y - P.y);\n  }\n  point operator *(double k){\n    return point(x * k, y * k);\n  }\n  point operator /(double k){\n    return point(x / k, y / k);\n  }\n};\ndouble abs(point P){\n  return sqrt(pow(P.x, 2) + pow(P.y, 2));\n}\ndouble dot(point P, point Q){\n  return P.x * Q.x + P.y * Q.y;\n}\ndouble cross(point P, point Q){\n  return P.x * Q.y - P.y * Q.x;\n}\nstruct line{\n  point A, B;\n  line(){\n  }\n  line(point A, point B): A(A), B(B){\n  }\n};\npoint vec(line L){\n  return L.B - L.A;\n}\nbool is_parallel(line L1, line L2){\n  return sign(cross(vec(L1), vec(L2))) == 0;\n}\npoint line_intersection(line L1, line L2){\n  return L1.A + vec(L1) * cross(L2.A - L1.A, vec(L2)) / cross(vec(L1), vec(L2));\n}\nbool on_segment(point P, line L){\n  return sign(dot(P - L.A, vec(L))) == 1 && sign(dot(P - L.B, vec(L))) == -1;\n}\nint main(){\n  int T;\n  cin >> T;\n  for (int i = 0; i < T; i++){\n    int xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    line L1 = line(point(xa, ya), point(xb, yb));\n    int n;\n    cin >> n;\n    vector<line> L2(n);\n    vector<int> o(n), l(n);\n    for (int j = 0; j < n; j++){\n      int xs, ys, xt, yt;\n      cin >> xs >> ys >> xt >> yt >> o[j] >> l[j];\n      L2[j] = line(point(xs, ys), point(xt, yt));\n    }\n    vector<pair<double, int>> I;\n    for (int j = 0; j < n; j++){\n      if (!is_parallel(L1, L2[j])){\n        point P = line_intersection(L1, L2[j]);\n        if (on_segment(P, L1) && on_segment(P, L2[j])){\n          double t = abs(P - L1.A) / abs(vec(L1));\n          I.push_back(make_pair(t, (o[j] + l[j]) % 2));\n        }\n      }\n    }\n    sort(I.begin(), I.end());\n    int sz = I.size();\n    int ans = 0;\n    for (int j = 0; j < sz - 1; j++){\n      if (I[j].second != I[j + 1].second){\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nvoid foo(ll& x, ll& y, ll xo, ll yo, ll dx, ll dy) {\n\tll _x = x - xo, _y = y - yo;\n\tx = dx * _x + dy * _y;\n\ty = dx * _y - dy * _x;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tll xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<ll> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tll dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] > 0) continue;\n\t\t\tdouble x = (double)(yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < 0 || x * (1 - EPS) > r) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n\nusing ll = long long;\nusing ull = unsigned long long;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline void chmax(T &x, U y){ x = std::max<T>(x, y); }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ x = std::min<T>(x, y); }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(std::begin(c), std::end(c))); }\n\n// }}}\n// geometry {{{\nusing Real = long double;\n\nstruct Point {\n\tReal x, y;\n\tPoint(){}\n\tPoint(Real x, Real y): x(x), y(y){}\n\t\n\tconst Point operator + (const Point &r) const {\n\t\treturn Point(x + r.x, y + r.y);\n\t}\n\t\n\tconst Point operator - (const Point &r) const {\n\t\treturn Point(x - r.x, y - r.y);\n\t}\n\t\n\tconst Point operator * (Real r) const {\n\t\treturn Point(x * r, y * r);\n\t}\n\n\tconst Point operator * (const Point &r) const {\n\t\treturn Point(x * r.x - y * r.y, x * r.y + y * r.x);\n\t}\n\t\n\tconst Point operator / (Real r) const {\n\t\treturn Point(x / r, y / r);\n\t}\n\t\n\tPoint& operator += (const Point &r){\n\t\tx += r.x;\n\t\ty += r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator -= (const Point &r){\n\t\tx -= r.x;\n\t\ty -= r.y;\n\t\treturn *this;\n\t}\n\t\n\tPoint& operator *= (Real r){\n\t\tx *= r;\n\t\ty *= r;\n\t\treturn *this;\n\t}\n\n\tPoint& operator *= (const Point &r){\n\t\treturn *this = *this * r;\n\t}\n\t\n\tPoint& operator /= (Real r){\n\t\tx /= r;\n\t\ty /= r;\n\t\treturn *this;\n\t}\n\n\tbool operator < (const Point &r) const {\n\t\tif (x != r.x) return x < r.x;\n\t\treturn y < r.y;\n\t}\n};\n\nusing LS = array<Point, 2>;\n\nstruct Line : LS {\n\tLine(){}\n\tLine(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tLine(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Segment : LS {\n\tSegment(){}\n\tSegment(const Point &p1, const Point &p2){\n\t\t(*this)[0] = p1;\n\t\t(*this)[1] = p2;\n\t}\n\tSegment(const LS &r){\n\t\t*this = r;\n\t}\n};\n\nstruct Circle {\n\tCircle(){}\n\tCircle(const Point &p, Real r): p(p), r(r){}\n\tPoint p;\n\tReal r;\n};\n\nusing Polygon = vector<Point>;\n\nconst Real PI = acos(Real(-1));\nconst Real EPS = 1e-12;\n\nint sgn(Real a){\n\tif (abs(a) < EPS) return 0;\n\tif (a < 0.0) return -1;\n\treturn 1;\n}\n\nbool eq(Real a, Real b){\n\treturn sgn(a - b) == 0;\n}\n\nbool neq(Real a, Real b){\n\treturn sgn(a - b) != 0;\n}\n\nbool lt(Real a, Real b){\n\treturn sgn(a - b) < 0;\n}\n\nbool leq(Real a, Real b){\n\treturn sgn(a - b) <= 0;\n}\n\nbool gt(Real a, Real b){\n\treturn sgn(a - b) > 0;\n}\n\nbool geq(Real a, Real b){\n\treturn sgn(a - b) >= 0;\n}\n\nReal toRad(Real t){\n\treturn t / 180 * PI;\n}\n\nReal toDeg(Real t){\n\treturn t * 180 / PI;\n}\n\nReal norm(const Point &a){\n\treturn sq(a.x) + sq(a.y);\n}\n\nReal abs(const Point &a){\n\treturn sqrt(norm(a));\n}\n\nReal arg(const Point &a){\n\treturn atan2(a.y, a.x);\n}\n\nPoint polar(Real r, Real t){\n\treturn Point(cos(t) * r, sin(t) * r);\n}\n\nReal dot(const Point &a, const Point &b){\n\treturn a.x * b.x + a.y * b.y;\n}\n\nReal cross(const Point &a, const Point &b){\n\treturn a.x * b.y - a.y * b.x;\n}\n\nint ccw(const Point &p1, const Point &p2, const Point &p3){\n\tPoint a = p2 - p1, b = p3 - p1;\n\tif (gt(cross(a, b), 0)) return 1;\n\tif (lt(cross(a, b), 0)) return -1;\n\tif (lt(dot(a, b), 0)) return 2;\n\tif (lt(norm(a), norm(b))) return -2;\n\treturn 0;\n}\n\nbool orthogonal(const LS &l1, const LS &l2){\n\treturn eq(dot(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nbool parallel(const LS &l1, const LS &l2){\n\treturn eq(cross(l1[1] - l1[0], l2[1] - l2[0]), 0);\n}\n\nPoint project(const LS &l, const Point &p){\n\tReal r = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n\treturn l[0] + (l[1] - l[0]) * r;\n}\n\nPoint reflect(const LS &l, const Point &p){\n\treturn p + (project(l, p) - p) * 2;\n}\n\nbool intersect(const Line &l1, const Line &l2){\n\tif (!parallel(l1, l2)) return true;\n\treturn eq(cross(l1[1] - l1[0], l2[0] - l1[0]), 0);\n}\n\nbool intersect(const Line &l, const Segment &s){\n\treturn leq(cross(l[1] - l[0], s[0] - l[0]) * cross(l[1] - l[0], s[1] - l[0]), 0);\n}\n\nbool intersect(const Line &l, const Point &p){\n\treturn eq(cross(l[1] - p, l[0] - p), 0);\n}\n\nbool intersect(const Segment &s1, const Segment &s2){\n\treturn ccw(s1[0], s1[1], s2[0]) * ccw(s1[0], s1[1], s2[1]) <= 0 &&\n\t       ccw(s2[0], s2[1], s1[0]) * ccw(s2[0], s2[1], s1[1]) <= 0;\n}\n\nbool intersect(const Segment &s, const Point &p){\n\treturn ccw(s[0], s[1], p) == 0;\n}\n\nReal distance(const Line &l, const Point &p){\n\treturn abs(cross(l[1] - l[0], p - l[0]) / abs(l[1] - l[0]));\n}\n\nReal distance(const Segment &s, const Point &p){\n\tif (dot(s[1] - s[0], p - s[0]) < 0.0) return abs(p - s[0]);\n\tif (dot(s[0] - s[1], p - s[1]) < 0.0) return abs(p - s[1]);\n\treturn distance(Line(s), p);\n}\n\nReal distance(const Segment &s1, const Segment &s2){\n\tif (intersect(s1, s2)) return 0.0;\n\treturn min({\n\t\tdistance(s1, s2[0]), distance(s1, s2[1]),\n\t\tdistance(s2, s1[0]), distance(s2, s1[1])\n\t});\n}\n\nPoint crossPoint(const LS &s1, const LS &s2){\n\tReal d1 = abs(cross(s2[1] - s2[0], s1[0] - s2[0]));\n\tReal d2 = abs(cross(s2[1] - s2[0], s1[1] - s2[0]));\n\tReal t = d1 / (d1 + d2);\n\treturn s1[0] + (s1[1] - s1[0]) * t;\n}\n// }}}\n\nSegment s;\nint n;\nSegment t[100];\nint o[100], l[100];\n\nint main()\n{\n\tint ca;\n\tcin >> ca;\n\twhile (ca--){\n\t\tcin >> s[0].x >> s[0].y >> s[1].x >> s[1].y;\n\t\tcin >> n;\n\t\trep(i, n){\n\t\t\tcin >> t[i][0].x >> t[i][0].y >> t[i][1].x >> t[i][1].y;\n\t\t\tcin >> o[i] >> l[i];\n\t\t}\n\n\t\tvector<pair<Point, int>> v;\n\t\trep(i, n){\n\t\t\tif (intersect(t[i], s)){\n\t\t\t\tv.eb(crossPoint(t[i], s), o[i] ^ l[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsort(v);\n\n\t\tint res = 0;\n\t\tif (!v.empty()){\n\t\t\tint c = v[0].se;\n\t\t\tloop(i, 1, v.size()){\n\t\t\t\tres += c ^ v[i].se;\n\t\t\t\tc = v[i].se;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#include <iterator>\n#include <limits>\n\nusing namespace std;\n\ntypedef pair<double, double> point;\ntypedef pair<double, double> line;\n\ntypedef struct {\n    double x, y;\n} pt;\n\ntypedef pair<pt, pt> seg;\n\nseg mkseg(double ax, double ay, double bx, double by) {\n    pt a = {ax, ay};\n    pt b = {bx, by};\n    return seg(a, b);\n}\n\ndouble inf = numeric_limits<double>::infinity();\n\npt seg_cross(seg a, seg b) {\n    double A = (a.second.x - a.first.x) / (a.second.y - a.first.y);\n    double B = (b.second.x - b.first.x) / (b.second.y - b.first.y);\n\n    if (A == inf) {\n        double y = a.second.y;\n        double x = B * (y - b.first.y) + b.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    if (B == inf) {\n        double y = b.second.y;\n        double x = A * (y - a.first.y) + a.first.x;\n        pt p = {x, y};\n        return p;\n    }\n\n    double y = (A * a.first.y - B * b.first.y + b.first.x - a.first.x) / (A - B);\n    double x = A * (y - a.first.y) + a.first.x;\n    pt p = {x, y};\n    return p;\n}\n\ntypedef struct {\n    line line;\n    int minx, maxx;\n    bool flag;\n} route;\n\npoint cross_point(line a, line b) {\n    double x = - (b.second - a.second) / (b.first - a.first);\n    double y = x * a.first + a.second;\n    return point(x, y);\n}\n\nline line_from_point(int ax, int ay, int bx, int by) {\n    double a = (ay - by) / (ax - bx);\n    return line(a, ay - a * ax);\n}\n\nvoid solve() {\n    int ax, ay, bx, by;\n    cin >> ax >> ay >> bx >> by;\n\n    seg new_seg = mkseg(ax, ay, bx, by);\n\n    int n;\n    cin >> n;\n\n    vector< pair<pt, bool> > pts;\n\n    while (n--) {\n        int ax_, ay_, bx_, by_;\n        int pos, owner;\n        cin >> ax_ >> ay_ >> bx_ >> by_ >> pos >> owner;\n\n        seg s = mkseg(ax_, ay_, bx_, by_);\n\n        double minx = min(ax_, bx_);\n        double maxx = max(ax_, bx_);\n\n        pt c = seg_cross(new_seg, s);\n        cerr << \"CROSS AT \" << c.x << \",\" << c.y << endl;\n\n        bool flag = (pos == 1) ^ (owner == 1);\n        if (minx <= c.x && c.x <= maxx && min(ax, bx) <= c.x && c.x <= max(ax, bx)) {\n            cerr << \"PUSH \" << c.x << \",\" << c.y << endl;\n            pts.push_back(make_pair(c, flag));\n        }\n\n        // route r;\n        // line l = line_from_point(ax_, ay_, bx_, by_);\n        // r.minx = min(ax_, bx_);\n        // r.maxx = max(ax_, bx_);\n        // r.flag = (pos == 1) ^ (owner == 1);\n\n        // point cp = cross_point(new_line, l);\n        // double cpx = cp.first;\n        // if (r.minx <= cpx && cpx <= r.maxx && ax <= cpx && cpx <= bx) {\n        //     cross_points.push_back(make_pair(cp, r.flag));\n        // }\n    }\n\n    struct {\n        bool operator()(pair<pt, bool> a, pair<pt, bool> b) {\n            return a.first.x < b.first.x;\n        }\n    } by_x;\n\n    sort(pts.begin(), pts.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<pt, bool> >::iterator it = pts.begin(); it != pts.end(); it++) {\n        pair<pt, bool> p = *it;\n        cerr << \"FOUND \" << p.first.x << \" \" << p.first.y << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n\n    /*\n    struct {\n        bool operator()(pair<point, bool> a, pair<point, bool> b) {\n            return a.first.first < b.first.first;\n        }\n    } by_x;\n\n    sort(cross_points.begin(), cross_points.end(), by_x);\n\n    int curr_pos = -1;\n    int cnt = 0;\n    for (vector< pair<point, bool> >::iterator it = cross_points.begin(); it != cross_points.end(); it++) {\n        pair<point, bool> p = *it;\n        // cout << p.first.first << \" \" << p.first.second << \" \" << p.second << endl;\n        if (curr_pos != -1) {\n            if (curr_pos != p.second) {\n                cnt++;\n            }\n        }\n        curr_pos = p.second;\n    }\n    cout << cnt << endl;\n    */\n}\n\nint main() {\n    int N;\n    cin >> N;\n    while (N--) {\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-9;\n\nvoid foo(double& x, double& y, double xo, double yo, double dx, double dy) {\n\tdouble _x = x - xo, _y = y - yo;\n\tdouble r = sqrt((double)dx * dx + dy * dy);\n\tx = _x * dx / r + _y * dy / r;\n\ty = _y * dx / r - _x * dy / r;\n}\n\nint main() {\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tdouble xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tint N; cin >> N;\n\t\tvector<double> xs(N), ys(N), xt(N), yt(N);\n\t\tvector<int> o(N), l(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tcin >> xs[i] >> ys[i] >> xt[i] >> yt[i] >> o[i] >> l[i];\n\t\tdouble dx = xb - xa, dy = yb - ya, r = dx * dx + dy * dy;\n\t\tif (r == 0) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<d_i> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfoo(xs[i], ys[i], xa, ya, dx, dy);\n\t\t\tfoo(xt[i], yt[i], xa, ya, dx, dy);\n\t\t\tif (ys[i] * yt[i] >= 0) continue;\n\t\t\tdouble x = (yt[i] * xs[i] - ys[i] * xt[i]) / (yt[i] - ys[i]);\n\t\t\tif (x < -EPS || x > sqrt((double)dx * dx + dy * dy) + EPS) continue;\n\t\t\tv.push_back(d_i(x, o[i] ^ l[i]));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j + 1 < v.size(); j++)\n\t\t\tif (v[j].second ^ v[j + 1].second)\n\t\t\t\tcnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <complex>\n#include <vector>\n#include <assert.h>\n#include <queue>\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(){}\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nstruct C {\n  P p; double r;\n  C(){ }\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\n//直線x直線交差判定\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\n//直線x線分交差判定\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\n//直線x点交差判定\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\n//線分x線分交差判定\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\n//線分x点交差判定\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n//点の直線への射影\nP projection(const L &l, const P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\n\n//直線と点の距離\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\n\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n\n//線分と点の距離\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\n//直線と直線の交点\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint n, xa, xb, ya, yb, N;\nL newline;\n\nclass Line{\npublic:\n\tdouble distance;\n\tL vec;\n\tint owner;\n\tint pos;\n\tbool operator< (const Line &opp) const {\n\t\treturn distance>opp.distance;\n\t}\n};\n\n\n\nmain(){\n\t\n\tcin >> n;\n\twhile(n--){\n\t\tLine t;\n\t\tpriority_queue<Line> oldline;\n\t\tcin >> xa >> ya >> xb >> yb >> N;\n\t\tnewline = L(P(xa,ya), P(xb,yb));\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin >> xa >> ya >> xb >> yb >> t.owner >> t.pos;\n\t\t\tt.vec = L(P(xa,ya), P(xb,yb));\n\t\t\tif(intersectSS(newline, t.vec)){\n\t\t\t\tt.distance = norm(crosspoint(newline, t.vec) - newline[0]);\n\t\t\t\toldline.push(t);\n\t\t\t}\n\t\t}\n\t\tint ans;\n\t\tint now=5;\n\t\tfor(ans=0;!oldline.empty();){\n\t\t\tt = oldline.top();\n\t\t\toldline.pop();\n//\t\t\tprintf(\"%d %d %d\\n\", now, t.owner, t.pos);\n\t\t\tif(!t.owner) t.pos = !t.pos;\n\t\t\tif(now == 5){\n\t\t\t\tnow = t.pos;\n\t\t\t}else{\n\t\t\t\tif(now != t.pos){\n\t\t\t\t\tnow = !now;\n\t\t\t\t\tans ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nvoid solve(){\n\tcomplex<long double> A, B;\n\tlong double a, b;\n\tcin >> a >> b;\n\tA = complex<long double>{ a,b };\n\tcin >> a >> b;\n\tB = complex<long double>{ a,b };\n\tint n;\n\tcin >> n;\n\tvector<pair<long double, int>> inputs;\n\t\n\tREP(i, n) {\n\t\tlong double a, b;\n\t\tcin >> a >> b;\n\t\tcomplex<long double> C{ a,b };\n\t\tcin >> a >> b;\n\t\tcomplex<long double> D{ a,b };\n\t\tint e, f;\n\t\tcin >> e >> f;\n\t\tlong double r = 0.0;\n\t\tlong double bunbo = (B.real() - A.real()) * (D.imag() - C.imag()) - (B.imag() - A.imag()) * (D.real() - C.real());\n\t\tif (abs(bunbo) < eps) continue;\n\t\tr = ((D.imag() - C.imag()) * (C.real() - A.real()) - (D.real() - C.real()) * (C.imag() - A.imag()));\n\t\tr /= bunbo;\n\t\tlong double s = ((B.imag() - A.imag()) * (C.real() - A.real()) - (B.real() - A.real()) * (C.imag() - A.imag())) / bunbo;\n\t\te += f;\n\t\te %= 2;\n\t\tif (r > 0.00000000L+eps && r < 1.00000000L - eps&&s > 0.00000000L + eps&&s < 1.00000000L - eps) {\n\t\t\tinputs.push_back(mp(r, e));\n\t\t}\n\t}\n\tsort(ALL(inputs));\n\tint ans = 0;\n\tfor (int i = 1; i < inputs.size(); ++i) {\n\t\tif (inputs[i].second != inputs[i - 1].second) ans++;\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tint t;\n\tcin >> t;\n\tREP(tea,t)\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\nbool in_seg(int n, int l, int r) { return l <= n && n < r; } // n in [l, r)?\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\n/////////////////////////////////////////////\ntypedef double gtype;\nconst gtype EPS_FOR_LIB = 1e-9;\ntypedef complex<gtype> Point;\ngtype to_rad(gtype deg)\n{\n    return deg * PI / 180;\n}\ngtype to_deg(gtype rad)\n{\n    return rad * 180 / PI;\n}\n\nnamespace std\n{\n\tbool operator<(const Point& a, const Point& b)\n\t{\n\t\treturn a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n\t}\n\tstd::istream& operator>>(std::istream& is, Point& p)\n\t{\n\t\tgtype a, b;\n        is >> a >> b;\n\t\tp = Point(a, b);\n\t\treturn is;\n\t}\n\tstd::ostream& operator<<(std::ostream& os, const Point& p)\n\t{\n\t\treturn os << \"(\" << p.real() << \", \" << p.imag() << \")\";\n\t}\n};\nstruct Line\n{\n\tPoint first, second;\n\tLine() {}\n    Line(const Point& first, const Point& second)\n        : first(first), second(second)\n    {\n        // 距離で割るときにNaNになるのを防ぐ\n        if (first == second)\n            this->first.real() += 1e-12;\n    }\n};\ntypedef Line Seg;\nostream& operator<<(ostream& os, const Line& line)\n{\n    return os << \"(\" << line.first << \", \" << line.second << \")\";\n}\n\nstruct Circle\n{\n    Point p;\n    gtype r;\n    Circle() {}\n    Circle(const Point& p, gtype r)\n        : p(p), r(r)\n    {\n    }\n};\nostream& operator<<(ostream& os, const Circle& c)\n{\n    return os << \"(\" << c.p << \", \" << c.r << \")\";\n}\ntypedef vector<Point> G;\ntypedef G Convex;\nSeg side_G(const G& g, int i)\n{\n    return Seg(g[i], g[(i + 1) % g.size()]);\n}\n\n\ngtype dot(const Point& a, const Point& b)\n{\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ngtype cross(const Point& a, const Point& b)\n{\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\nenum res_ccw\n{\n\tcounter_clockwise = +1,\n\tclockwise = -1,\n\ton = 0,\n};\nres_ccw ccw(const Point& a, const Point& b, const Point& c)\n{\n    const gtype feps = 1e-10;\n\tPoint p = b - a, q = c - a;\n\tif (cross(p, q) > feps) return counter_clockwise;\n\telse if (cross(p, q) < -feps) return clockwise;\n\treturn on;\n}\n\n\n//// 交差判定\n\n// 直交判定\n// AOJ0058\nbool is_orthogonal(const Line& line1, const Line& line2)\n{\n\treturn abs(dot(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n// AOJ0021, AOJ0187\nbool is_parallel(const Line& line1, const Line& line2)\n{\n\treturn abs(cross(line1.second - line1.first, line2.second - line2.first)) < 1e-9;\n}\n\nbool intersect_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.second - line.first, p - line.first)) < 1e-20;\n}\nbool intersect_SP(const Line& seg, const Point& p)\n{\n\treturn abs(seg.first - p) + abs(p - seg.second) < abs(seg.first - seg.second) + EPS_FOR_LIB;\n}\n\n\nbool intersect_LL(const Line& line1, const Line& line2)\n{\n\treturn !is_parallel(line1, line2);\n}\n// AOJ1183\nbool intersect_LS(const Line& line, const Line& seg)\n{\n\treturn cross(line.second - line.first, seg.first - line.first)\n\t\t* cross(line.second - line.first, seg.second - line.first) < EPS_FOR_LIB;\n}\nbool intersect_SL(const Line& seg, const Line& line)\n{\n    return intersect_LS(line, seg);\n}\n// AOJ0187, AOJ1183\nbool intersect_SS(const Line& seg1, const Line& seg2)\n{\n    const gtype feps = 1e-9;\n\treturn (cross(seg1.second - seg1.first, seg2.first - seg1.first) * cross(seg1.second - seg1.first, seg2.second - seg1.first) < -feps\n            && cross(seg2.second - seg2.first, seg1.first - seg2.first) * cross(seg2.second - seg2.first, seg1.second - seg2.first) < -feps)\n\t\t|| intersect_SP(seg1, seg2.first)\n\t\t|| intersect_SP(seg1, seg2.second)\n\t\t|| intersect_SP(seg2, seg1.first)\n\t\t|| intersect_SP(seg2, seg1.second);\n}\n\n\n//// 距離\ngtype dist_LP(const Line& line, const Point& p)\n{\n\treturn abs(cross(line.first - line.second, p - line.second) / abs(line.first - line.second));\n}\ngtype dist_PL(const Point& p, const Line& line)\n{\n    return dist_LP(line, p);\n}\ngtype dist_LL(const Line& line1, const Line& line2)\n{\n\treturn is_parallel(line1, line2) ? dist_LP(line1, line2.first) : 0;\n}\ngtype dist_LS(const Line& line, const Line& seg)\n{\n\tif (intersect_LS(line, seg))\n\t\treturn 0;\n\telse\n\t\treturn min(dist_LP(line, seg.first), dist_LP(line, seg.second));\n}\ngtype dist_SL(const Line& seg, const Line& line)\n{\n    return dist_LS(line, seg); // 写すとき注意！！！\n}\ngtype dist_SP(const Line& seg, const Point& p)\n{\n\tif (dot(seg.second - seg.first, p - seg.first) < 0)\n\t\treturn abs(seg.first - p);\n\telse if (dot(seg.first - seg.second, p - seg.second) < 0)\n\t\treturn abs(seg.second - p);\n\telse\n\t\treturn dist_LP(seg, p);\n}\ngtype dist_PS(const Point& p, const Line& seg)\n{\n    return dist_SP(seg, p);\n}\n// AOJ1157\ngtype dist_SS(const Line& seg1, const Line& seg2)\n{\n\tif (intersect_SS(seg1, seg2))\n\t\treturn 0;\n\telse\n\t\treturn min(min(dist_SP(seg1, seg2.first), dist_SP(seg1, seg2.second))\n\t\t\t, min(dist_SP(seg2, seg1.first), dist_SP(seg2, seg1.second)));\n}\n\nPoint ip_SS(const Line& seg1, const Line& seg2)\n{\n\tif (!intersect_SS(seg1, seg2))\n\t{\n\t\tcerr << \"ip_SS: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tgtype a = abs(cross(seg1.second - seg1.first, seg2.first - seg1.first));\n\tgtype b = abs(cross(seg1.second - seg1.first, seg2.second - seg1.first));\n    if (a < 1e-9 && b < 1e-9)\n    {\n        cerr << \"same line\" << endl;\n        exit(1);\n    }\n\n\tgtype t = a / (a + b);\n\treturn seg2.first + t * (seg2.second - seg2.first);\n}\nPoint ip_LL(const Line& line1, const Line& line2)\n{\n\tif (is_parallel(line1, line2))\n\t{\n\t\tcerr << \"ip_LL: 前提条件満たしてない\" << endl;\n\t\texit(1);\n\t}\n\n\tPoint a = line1.second - line1.first, b = line2.second - line2.first;\n\tgtype p = cross(b, line2.first - line1.first);\n\tgtype q = cross(b, a);\n\treturn line1.first + p / q * a;\n}\n\n\n\n\n/////////////////// \n\n\nint main()\n{\n    fast_io();\n\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        Seg s;\n        cin >> s.first >> s.second;\n        Point rota(1, -arg(s.second - s.first));\n        s.first *= rota, s.second *= rota;\n        \n        \n        vector<pair<Point, bool> > c;\n        int n;\n        cin >> n;\n        rep(i, n)\n        {\n            Seg t;\n            int o, l;\n            cin >> t.first >> t.second >> o >> l;\n            t.first *= rota, t.second *= rota;\n            if (intersect_SS(s, t))\n                c.pb(mp(ip_SS(s, t), (o ^ l)));\n        }\n        sort(all(c));\n\n        int res = 0;\n        if (!c.empty())\n        {\n            bool f = c[0].second;\n            for (int i = 1; i < c.size(); ++i)\n            {\n                if (f != c[i].second)\n                {\n                    ++res;\n                    f ^= 1;\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n\n#define\tmp\t\t\tmake_pair\n#define\tpb\t\t\tpush_back\n#define\trep(i,n)\tfor(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef\tcomplex<double>\tPoint;\n\nconst double EPS=1e-9;\n\nclass Line:public vector<Point>{\npublic:\n\tLine(){}\n\tLine(const Point &a,const Point &b){ pb(a),pb(b); }\n};\n\nclass Segment:public Line{\npublic:\n\tSegment(){}\n\tSegment(const Point &a,const Point &b):Line(a,b){}\n};\n\ndouble dot(const Point &a,const Point &b){\n\treturn real(a)*real(b)+imag(a)*imag(b);\n}\n\ndouble cross(const Point &a,const Point &b){\n\treturn real(a)*imag(b)-imag(a)*real(b);\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const Point &a,Point b,Point c){\n\tb-=a,c-=a;\n\tdouble rotdir=cross(b,c);\n\tif(rotdir>EPS)\t\treturn CCW;\n\tif(rotdir<-EPS)\t\treturn CW;\n\treturn ON;\n}\n\ninline void calc_abc(const Line &l,double &a,double &b,double &c){\t// l : ax+by+c=0\n\ta=imag(l[0])-imag(l[1]);\n\tb=real(l[1])-real(l[0]);\n\tc=cross(l[0],l[1]);\n}\n\nbool intersect(const Segment &s,const Segment &t,Point *p=NULL){\n\tif(max(real(s[0]),real(s[1]))<min(real(t[0]),real(t[1]))-EPS\n\t|| max(real(t[0]),real(t[1]))<min(real(s[0]),real(s[1]))-EPS\n\t|| max(imag(s[0]),imag(s[1]))<min(imag(t[0]),imag(t[1]))-EPS\n\t|| max(imag(t[0]),imag(t[1]))<min(imag(s[0]),imag(s[1]))-EPS)\treturn false;\n\n\tif(ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1])<=0\n\t&& ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1])<=0){\n\t\tif(p){\n\t\t\tdouble a1,b1,c1,a2,b2,c2;\n\t\t\tcalc_abc(s,a1,b1,c1);\n\t\t\tcalc_abc(t,a2,b2,c2);\n\t\t\tdouble det=a1*b2-a2*b1;\n\t\t\tif(abs(det)<EPS){\t// s is parallel to t\n\t\t\t\tPoint q[3]={s[0],s[1],t[0]};\n\t\t\t\trep(i,3){\n\t\t\t\t\tif(dot(q[i]-s[0],q[i]-s[1])<EPS && dot(q[i]-t[0],q[i]-t[1])<EPS){\n\t\t\t\t\t\t*p=q[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\t*p=Point(b1*c2-b2*c1,a2*c1-a1*c2)/det;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint n;\nPoint A,B;\nSegment AB,S[100];\nbool own[100],loc[100];\n\nint solve(bool loca){\n\tvector< pair<double,int> > pts;\n\trep(i,n){\n\t\tPoint Q;\n\t\tif(intersect(AB,S[i],&Q))\tpts.pb(mp(abs(A-Q),i));\n\t}\n\n\tsort(pts.begin(),pts.end());\n\n\tint cnt=0;\n\tbool now=loca;\n\trep(i,pts.size()){\n\t\tint id=pts[i].second;\n\t\tif(own[id]){\n\t\t\tif(now!=loc[id]){ cnt++; now=!now; }\n\t\t}\n\t\telse{\n\t\t\tif(now==loc[id]){ cnt++; now=!now; }\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint main(){\n\tint T;\tscanf(\"%d\",&T);\n\twhile(T--){\n\t\tint xa,ya,xb,yb;\tscanf(\"%d%d%d%d%d\",&xa,&ya,&xb,&yb,&n);\n\t\tA=Point(xa,ya);\n\t\tB=Point(xb,yb);\n\t\tAB=Segment(A,B);\n\t\trep(i,n){\n\t\t\tint x1,y1,x2,y2,o,l;\tscanf(\"%d%d%d%d%d%d\",&x1,&y1,&x2,&y2,&o,&l);\n\t\t\tS[i]=Segment(Point(x1,y1),Point(x2,y2));\n\t\t\town[i]=o;\n\t\t\tloc[i]=l;\n\t\t}\n\t\tprintf(\"%d\\n\",min(solve(0),solve(1)));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> Point;\ntypedef pair<double, int> P;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n\tif (lhs.real() < rhs.real() - eps)\n\t\treturn true;\n\tif (lhs.real() > rhs.real() + eps)\n\t\treturn false;\n\treturn lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n\treturn (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a) * b);\n}\n\nclass Line\n{\n  public:\n\tPoint a, b;\n\tint own; //a�ЂȂ�1 b�ЂȂ�0\n\tint pos; //���˂Ȃ�1 �n���Ȃ�0\n\tLine() : a(Point(0, 0)), b(Point(0, 0)), own(-1), pos(-1) {}\n\tLine(Point a, Point b, int own, int pos) : a(a), b(b), own(own), pos(pos) {}\n};\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a;\n\tc -= a;\n\tif (cross(b, c) > eps)\n\t\treturn 1; //a,b,c�������v���\n\tif (cross(b, c) < -eps)\n\t\treturn -1; //a,b,c�����v���\n\tif (dot(b, c) < 0)\n\t\treturn 2; //c,a,b�̏��Œ�����\n\tif (norm(b) < norm(c))\n\t\treturn -2; //a,b,c�̏��Œ�����\n\treturn 0;\t  //a,c,b�Œ�����\n}\n\nbool isis_ss(Line s, Line t)\n{ //�����Ɛ����̌����\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\t   ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_sp(Line s, Point p)\n{ //�_�̐����㔻��\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint is_ll(Line s, Line t)\n{ //�����ƒ����̌�_\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint num;\n\tcin >> num;\n\twhile (num--)\n\t{\n\t\tld xa, ya, xb, yb;\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tPoint a(xa, ya), b(xb, yb);\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<Line> rosen; //�H���S��\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tld xs, ys, xt, yt;\n\t\t\tint o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tPoint s(xs, ys), t(xt, yt);\n\t\t\tLine li(s, t, o, l);\n\t\t\trosen.push_back(li);\n\t\t}\n\t\tLine route(a, b, 1, -1); //�n�_�I�_\n\t\tvector<P> lines;\t\t //P(�����Aindex) �����H�����X�g\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (cross(route.b - route.a, rosen[i].b - rosen[i].a) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (isis_ss(route, rosen[i]))\n\t\t\t{\n\t\t\t\tPoint kouten = is_ll(route, rosen[i]);\n\t\t\t\tdouble dis = norm(route.a - kouten);\n\t\t\t\tlines.push_back(P(dis, i));\n\t\t\t}\n\t\t}\n\t\tsort(lines.begin(), lines.end());\n\t\tint res = 0, pos;\n\t\tif (lines.size() == 0)\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint idx = lines[0].second;\n\t\tif (rosen[idx].own == 1)\n\t\t{\n\t\t\tpos = rosen[idx].pos;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos = 1 - rosen[idx].pos;\n\t\t}\n\t\tfor (int i = 0; i < (int)lines.size(); i++)\n\t\t{\n\t\t\tint idx = lines[i].second;\n\t\t\t//cout << idx<<\" \"<<pos << \" \" << rosen[idx].own << \" \" << rosen[idx].pos << endl;\n\t\t\tif (rosen[idx].own == 1)\n\t\t\t{\n\t\t\t\tif (rosen[idx].pos == pos)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpos = 1 - pos;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (rosen[idx].pos != pos)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpos = 1 - pos;\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << i<<\" \"<<pos << endl;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n#define EPS (1.0e-9)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nclass Point {\npublic:\n  double x, y;\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x*a, y*a); }\n};\n\ntypedef Point Vector;\n\nclass Segment {\npublic:\n  Point p1, p2;\n};\ntypedef Segment Line;\n\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\ndouble norm(Vector a) { return a.x*a.x + a.y*a.y; }\n\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4) {\n  return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t   ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2) {\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = fabs(cross(s1.p1 - s2.p1, base));\n  double d2 = fabs(cross(s1.p2 - s2.p1, base));\n  double t = d1/(d1+d2);\n  return s1.p1 + (s1.p2 - s1.p1)*t;\n}\ndouble getTofCrossPoint(Segment s1, Segment s2) {\n  Vector base = s2.p2 - s2.p1;\n  double d1 = fabs(cross(s1.p1 - s2.p1, base));\n  double d2 = fabs(cross(s1.p2 - s2.p1, base));\n  return d1/(d1+d2);\n}\n\nSegment S;\nint N;\nSegment Q[100];\nint O[100], H[100];\n\nclass CrossPoint {\npublic:\n  int o, l;\n  double t;\n  CrossPoint(int o, int l, double t) : o(o), l(l), t(t) {}\n  bool operator < (const CrossPoint &cp) const {\n    return t < cp.t;\n  }\n};\n\nvoid solve() {\n  vector<CrossPoint> cp;\n\n  for(int i = 0; i < N; ++i) {\n    if(!isIntersect(S, Q[i])) continue;\n    cp.push_back(CrossPoint(O[i], H[i], getTofCrossPoint(S, Q[i])));\n  }\n  sort(cp.begin(), cp.end());\n\n  int ans = 0;\n  int nl;\n  if(cp[0].o == 1) nl = cp[0].l;\n  else             nl = 1 - cp[0].l;\n  for(int i = 1; i < cp.size(); ++i) {\n    if(cp[i].o == 1 && cp[i].l != nl ||\n       cp[i].o == 0 && cp[i].l == nl ) {\n      nl = 1 - nl;\n      ++ans;\n    }\n  }\n  cout << ans << endl;\n}\n\nmain() {\n  int T;\n  cin >> T;\n  for(int t = 0; t < T; ++t) {\n    cin >> S.p1.x >> S.p1.y >> S.p2.x >> S.p2.y;\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n      cin >> Q[i].p1.x >> Q[i].p1.y >> Q[i].p2.x >> Q[i].p2.y\n\t  >> O[i] >> H[i];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// ?????????dot(a,b) = |a||b|cos??\nD dot(P a, P b) {\n    return (conj(a)*b).X;\n}\n// ?????????cross(a,b) = |a||b|sin??\nD cross(P a, P b) {\n    return (conj(a)*b).Y;\n}\n// ?????????????????? a->b->c\nint ccw(P a, P b, P c) {\n    b -= a;\tc -= a;\n    //3???????????´???????????????\n    if (cross(b,c) > EPS) return +1;\t// counter clockwise\n    if (cross(b,c) < -EPS) return -1;\t// clockwise\n    //3???????????´???????????????\n    if (dot(b,c) < -EPS) return +2;\t\t// c--a--b on line\n    if (norm(b) < norm(c)) return -2;\t// a--b--c on line or a==b\n    return 0;\t\t\t\t\t\t\t// a--c--b on line or a==c or b==c\n}\n// ????????¨??????\nbool isecSS(P a1, P a2, P b1, P b2) {\n    return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n    ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\nP crosspointLL(P a1, P a2, P b1, P b2) {\n    D d1 = cross(b2-b1, b1-a1);\n    D d2 = cross(b2-b1, a2-a1);\n    return a1 + d1/d2 * (a2-a1);\n}\n\nclass CrossPoint{\npublic:\n    double x, y;\n    int o, l;\n    bool is_underground;\n    CrossPoint(double x, double y, int o, int l): x(x), y(y), o(o), l(l){\n        is_underground = o^l;\n    };\n};\n\nbool cmp(CrossPoint p1, CrossPoint p2){\n    if(EQ(p1.x, p2.x))\n        return p1.y < p2.y;\n    else\n        return p1.x < p2.x;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int T; cin>>T;\n    while(T--){\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n        \n        int N; cin >> N;\n        \n        vector<CrossPoint> crosspoints;\n        for(int i=0; i<N; i++){\n            int xs, ys, xt, yt, o, l;\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n            \n            if(isecSS(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt))){\n                P p = crosspointLL(P(xa, ya), P(xb, yb), P(xs, ys), P(xt, yt));\n                crosspoints.push_back(CrossPoint(p.X, p.Y, o, l));\n            }\n        }\n        \n        if(crosspoints.size()){\n            sort(crosspoints.begin(), crosspoints.end(), cmp);\n            \n            int count = 0;\n            for(int i=1; i<crosspoints.size(); i++)\n                count += crosspoints[i-1].is_underground != crosspoints[i].is_underground;\n            cout << count << endl;\n        }else{\n            cout << 0 << endl;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline double add(double a, double b){\n    return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n}\n\nstruct vec{\n    long double x,y;\n    vec operator-(vec b){\n        return (vec){add(x,-b.x),add(y,-b.y)};\n    }\n    vec operator+(vec b){\n        return (vec){add(x,b.x),add(y,b.y)};\n    }\n    vec operator*(long double d){\n        return (vec){x*d,y*d};\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){\n        return sqrt(x*x+y*y);\n    }\n};\n\n\nconst double eps = 0.0000001;\n\nint ccw(vec& a, vec& b, vec& c){\n    vec ab = b-a, ac = c-a;\n    long double o = ab.cross(ac);\n    if(o>0) return 1; //CCW\n    if(o<0) return -1; //CW\n    if(ab.dot(ac)<0){\n        return 2; //C-A-B\n    }else{\n        if(ab.dot(ab)<ac.dot(ac)){\n            return -2; //A-B-C\n        }else{\n            return 0; //A-C-B\n        }\n    }\n}\n\nvec interSection(vec& p0,vec& p1,vec& p2,vec& p3){\n    vec p23=p3-p2,p02=p2-p0,p01=p1-p0;\n    double k = p23.cross(p02)/p23.cross(p01);\n    return p0+p01*k;\n}\n\nint isInterSection(vec& p0,vec& p1,vec& p2,vec& p3){//??????p[0]p[1]??¨p[2]p[3]\n    switch(ccw(p0,p1,p2)*ccw(p0,p1,p3)){\n        case -1:\n        case -4:\n            break;\n        case 0:\n            return ~(ccw(p0,p1,p2)|ccw(p0,p1,p3))?2:-1;//?§???§??\\??????????????´???\n        default:\n            return 0;\n    }\n    switch(ccw(p2,p3,p0)*ccw(p2,p3,p1)){\n        case -1:\n        case -4:\n        case 0:\n            break;\n        default:\n            return 0;\n    }\n    return 1;\n}\n\ntypedef pair<vec,int> P;\n\nstruct Section{\n    vec v1,v2;//?§??????¨??????\n    vector<P> cp;//??????(????????????????????¨?????????)\n};\n\nint main(void){\n    int N;\n    vector<Section> S;\n    cin>>N;\n    while(N--){\n        S.clear();\n        Section line;\n        cin >> line.v1.x >> line.v1.y >> line.v2.x >> line.v2.y;\n        int n; cin >> n;\n        for(int i=0;i<n;i++){\n            vec v1,v2;\n            int o,l;\n            cin >> v1.x >> v1.y >> v2.x >> v2.y >> o >> l;\n            if(isInterSection(v1,v2,line.v1,line.v2)){\n                line.cp.push_back(P(interSection(v1,v2,line.v1,line.v2),o?l:l^1));\n            }\n        }\n        sort(line.cp.begin(),line.cp.end());\n        int c=0,h=line.cp[0].second;\n        for(int i=1;i<line.cp.size();i++){\n            if(h!=line.cp[i].second){\n                c++;\n                h=line.cp[i].second;\n            }\n        }\n        cout << c << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <sstream>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> point;\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n#define all(x) x.begin(), x.end()\n#define mp make_pair\n#define pb push_back\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin(); itr!=(c).end(); itr++)\n\ndouble cross(point a, point b){\n  return ( a.real()*b.imag() - a.imag()*b.real() );\n}\nbool is_intersection_ls(point a1, point a2, point b1, point b2){\n  return ( cross(a2-a1,b1-a1)*cross(a2-a1,b2-a1)<EPS &&\n           cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<EPS );\n}\npoint intersection_ls(point a1, point a2, point b1, point b2){\n  point b = b2 - b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1+d2);\n  return a1 + (a2-a1)*t;\n}\n\nclass sen{\npublic:\n  point p;\n  int o,l;\n  sen(point _p, int _o, int _l){\n    p = _p;\n    o = _o;\n    l = _l;\n  }\n  bool operator<(const sen& a)const{\n    if( p.real() == a.p.real() ) return p.imag() < a.p.imag();\n    return p.real() < a.p.real();\n  }\n};\n\npoint s,e;\npoint ds[110], de[110];\nint O[110], L[110];\nint n;\n\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    cin >> s.real() >> s.imag() >> e.real() >> e.imag();\n    cin>>n;\n    rep(i,n){\n      cin >> ds[i].real() >> ds[i].imag();\n      cin >> de[i].real() >> de[i].imag();\n      cin >> O[i] >> L[i];\n    }\n#if DEB\n    rep(i,n){\n      cout << ds[i] << \" : \" << de[i] << \" ,\" << O[i] << \" \" << L[i] << endl;\n    }\n#endif\n\n    vector<sen> v;\n    rep(i,n){\n      if( is_intersection_ls(s,e,ds[i],de[i]) ){\n        point p = intersection_ls(s,e,ds[i],de[i]);\n        v.push_back(sen(p,O[i],L[i]));\n      }\n    }\n\n    // o ª1Èç©Ð\n    // l ª\n    int nl;\n    int cnt = 0;\n    sort(all(v));\n    rep(i,v.size()){\n#if DEB\n      cout << v[i].p << \" \" << v[i].o << \" \" << v[i].l << endl;\n#endif\n\n      if( i==0 ){\n        if( v[i].o==1 ){\n          nl = v[i].l;\n        }else{\n          nl = (v[i].l == 1 ? 0 : 1);\n        }\n      }else{\n        if( v[i].o==1 ){\n          if( v[i].l!=nl ){\n            nl = v[i].l;\n            cnt++;\n          }\n        }else{\n          if( v[i].l==nl ){\n            nl = (v[i].l==1 ? 0 : 1);\n            cnt++;\n          }\n        }\n      }\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;//????´???°????????¢?????????????????¨?§£???\nnamespace std {\n  bool operator < (const P& a, const P& b) {//x????????????\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n  bool sorty(const P& a, const P& b) {//y????????????\n    return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);\n  }\n  bool same(const P& a, const P& b) {\n    P p = a - b;\n    if(abs(real(p)) < EPS && abs(imag(p)) < EPS){\n      return true;\n    }\n    return false;\n  }\n}\ndouble cross(const P& a, const P& b) {//??????\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {//??????\n  return real(conj(a)*b);\n}\n\nclass L{// line\n  public:\n    vector<P> l;\n    P v;\n    L(){};\n    L(const P &a, const P &b) {\n      l.push_back(a); l.push_back(b);\n      v = (b-a);\n    }\n    L(double a,double b,double c,double d){\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n    P& operator[](const int i){\n      return l[i];\n    }\n    void readL() {\n      double a, b,c,d;\n      cin >> a >> b >> c >> d;\n      l.clear();\n      l.push_back(P(a,b)),l.push_back(P(c,d));\n    }\n};\n\ntypedef vector<P> G;\nG readG(int n){\n  double x,y;\n  G g;\n  rep(i,n){\n    cin >> x >> y;\n    g.push_back(P(x,y));\n  }\n  return g;\n}\n\nstruct C {//???\n  P p; double r;\n  C(){};\n  C(const P &p, double r) : p(p), r(r) { }\n};\nint ccw(P a, P b, P c) {//3????????????????????§????????§??????????????????\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0; // a--c--b on line\n}\nint linejudge(L &ab,L &cd){ //2??´???????????¢???\n  P a = ab[1] - ab[0],b = cd[1] - cd[0];\n  if(abs(cross(a,b)) < EPS){ // Parallel\n    return 2;\n  }\n  else if(abs(dot(a,b)) < EPS){ //Orthogonal\n    return 1;\n  }\n  return 0;\n}\n// L:line,S:segment,P:point\nbool intersectLL( L &l,  L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n    abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS( L &l,  L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n    cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP( L &l,  P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS( L &s,  L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n    ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP( L &s,  P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n// L & P intersection\nP projection( L &l,  P &p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n// L????????????P???????°????\nP reflection( L &l,  P &p) {\n  return p + 2.0 * (projection(l, p) - p);\n}\ndouble distanceLP( L &l,  P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL( L &l,  L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS( L &l,  L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP( L &s,  P &p) {\n  P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS( L &s,  L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])), min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\ndouble distancePP( P &p, P &q){\n  return abs(p - q) ;\n}\nP crosspoint(L &l,L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nP verticalvector( P &a, P &b){//2???????????????????????????????????????\n  if(a.real() == b.real()){\n    return {1.0,0};\n  }\n  if(a.imag() == b.imag()){\n    return {0,1.0};\n  }\n  P p = a - b;\n  P res = {-p.imag(),p.real()};\n  return res / abs(p);\n}\n// a < b : -1, a > b : 1, a == b : 0\ninline int sgn(double a, double b = 0) { return a < b - EPS ? -1 : a > b + EPS ? 1 : 0; }\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  cin >> n;\n  L l;\n  l.readL();\n  int o,h;\n  rep(i,n){\n    cin >> m;\n    vector<pair<P,pair<bool,bool>>> ab(m);//a[i](crosspoint,h)\n    rep(j,m){\n      L t;\n      t.readL();\n      cin >> o >> h;\n      P p = intersectLL(l,t);\n      ab[j] = mp(p,mp(h,o));\n    }\n    ab.push_back(mp(l[1],mp(-1,-1)));\n    sort(all(ab));\n    int s = 0;\n    if(ab[0].se.se){\n      s = ab[0].se.fi;\n    }\n    else{\n      s = !ab[0].se.fi;\n    }\n    int cnt = 0,u = 1;\n    while(1){\n      if(ab[u].fi == l[1]){\n        break;\n      }\n      h = ab[u].se.fi,o = ab[u].se.se;\n      if(h != ab[u-1].se.fi){\n        ++cnt;\n      } \n      /* if(o){        */\n      /*   if(h != s){ */\n      /*     s = h;    */\n      /*     ++cnt;    */\n      /*   }           */\n      /* }             */\n      /* else{         */\n      /*   if(h != s){ */\n      /*     s = h;    */\n      /*     ++cnt;    */\n      /*   }           */\n      /* }             */\n      ++u;\n    }\n    cout << cnt << endl;\n    // ???????????¨??´?????¨????????¨????????????????????????\n    // ???????§??????¨????????¨?????????????????¢???????°??????????????????????????????°????????¶?????????????????????????????????????????????\n    // ????????????????????????????????¨??¶?????????????????????h = !h???ans++\n    // ??????????????¨??¶???????????????\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)<<\" \"\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\nstringstream ss;\nREP(i,x.size()){\n  if(i!=0)ss<<\" \";\n  ss<< x[i];\n}\nreturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\nstringstream ss;\nREP(i,map.size()){\n  if(i!=0)ss<<BR;\n  ss<< toString(map[i]);\n}\nreturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\nstring res;stringstream ss;\nfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\nreturn (v%MOD+MOD)%MOD;\n}\n\nint INF=1<<28;\n\nnamespace geo{\n    const double EPS = 1e-9;\n    typedef double PT;typedef complex<PT> P;\n    typedef P vecP;typedef vector<P> Polygon;\n\n    template<typename T>bool LT(T a,T b){return a+EPS<b;}\n    template<typename T>bool GT(T a,T b){return LT(b,a);}\n    template<typename T>bool EQ(T a,T b){return !LT(a,b) && !GT(a,b);}\n\n    namespace VU{\n        static PT x(const vecP& a){return real(a);}\n        static PT y(const vecP& a){return imag(a);}\n        \n            // ベクタの長さ\n        static PT length(const vecP& a){return abs(a);}\n            // 単位ベクトル\n        static vecP unit_vector(const vecP& a){return a / abs(a);}\n            // 法線ベクトル\n        static pair<vecP,vecP> normal_vector(const vecP& a){return make_pair(a * vecP(0,1),a * vecP(0,-1));}\n            // 内積 (dot product) : a・b = |a||b|cosΘ\n        PT dot(const vecP& a,const vecP& b){return x(conj(a)*b);}\n            // 外積 (cross product) : |a×b| = |a||b|sinΘ\n        PT cross(const vecP& a,const vecP& b){return y(conj(a)*b);}\n            //点aと点bの距離\n        static PT dist(const P& a,const P& b){return abs(a-b);}\n\n            // 点の進行方向\n        int ccw(P a,P b,P c){\n            b -= a;c -= a;\n                if(LT(cross(b,c),0.0)) return +1;    // counter clockwise\n                if(GT(cross(b,c) ,0.0)) return -1;    // clockwise\n                if(EQ(dot(b,c),0.0)) return +2;      // c -- a -- b\n                if(norm(b) < norm(c)) return -2; // a -- b -- c\n                return 0;\n            }\n\n        }\n        using namespace VU;\n    };\n    using namespace geo;\n    namespace std{\n        bool operator <(const P &lhs,const P &rhs){\n            if(x(lhs) == x(rhs))return y(lhs) < y(rhs);\n            return x(lhs) < x(rhs);\n        }\n    }\n\n    namespace geo{\n        struct L{\n            P p1,p2;\n            L(P p1,P p2):p1(p1),p2(p2){}\n            vecP vec(){\n                return p2-p1;\n            }\n        //点との距離\n            double line_dist(const P& b){\n                return abs(cross(vec(),b-p1)) / abs(vec());\n            }\n            double linesegment_dist(const P& b){\n                if(EQ(dot(p2-p1,b-p1),0.0)) return abs(b-p1);\n                if(EQ(dot(p1-p2,b-p2) ,0.0)) return abs(b-p2);\n                return line_dist(b);\n            }\n            double linesegment_dist(L& b){\n                if(is_intersected(b))return 0;\n                return min(min( linesegment_dist(b.p1),linesegment_dist(b.p2) ),\n                    min(b.linesegment_dist(p1),b.linesegment_dist(p2)));\n            }\n\n             //線分同士の交差判定\n            bool is_intersected(L& b){\n                if(LT(max(x(p1),x(p2)),min(x(b.p1),x(b.p2)))) return false;\n                if(LT(max(x(b.p1),x(b.p2)),min(x(p1),x(p2)))) return false;\n                if(LT(max(y(p1),y(p2)),min(y(b.p1),y(b.p2)))) return false;\n                if(LT(max(y(b.p1),y(b.p2)),min(y(p1),y(p2)))) return false;\n                return cross(vec(),b.p1-p1)*cross(vec(),b.p2-p1)<EPS  && cross(b.vec(),p1-b.p1)*cross(b.vec(),p2-b.p1)<EPS ;\n            }\n\n            bool is_intersected_line(L& b) {\n                return !is_parallel(b);\n            }\n\n            P intersection_point(L& b) {\n                if(EQ(p1,b.p1) || EQ(p1,b.p2)) return p1;if(EQ(p2,b.p1) || EQ(p2,b.p2)) return p2;\n                return p1 + vec() * cross(b.vec(), b.p1-p1) / cross(b.vec(), vec());\n            }\n            P intersection_ls(L& b) {\n              double d1 = abs(cross(b.vec(), p1-b.p1));\n              double d2 = abs(cross(b.vec(), p2-b.p1));\n              if(d1 + d2 == 0) return P(INF,INF);\n              double t = d1 / (d1 + d2);\n              return p1 + (p2-p1) * t;\n          }\n        // 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\n        // みけんしょう\n          bool is_orthogonal(L& b) {return EQ(dot(vec(),b.vec()),0.0);}\n        // 2直線の平行判定 : a//b <=> cross(a, b) = 0\n          bool is_parallel(L& b) {return EQ(cross(vec(),b.vec()),0.0);}\n\n        // 直線と点の最短距離を実現する直線の点(すいせんの足)(みけんしょう)\n          P nearest_point_line(P b){\n            return p1 + vec() * dot(vec(),b-p1) / norm(vec());\n        }\n        // 線分と点の最短距離を実現する線分嬢の点(みけんしょう)\n        P nearest_point_linesegment(P b){\n            if(EQ(dot(vec(),b-p1),0.0)) return p1;\n            if(EQ(dot(vec(),b-p2),0.0)) return p2;\n            return nearest_point_line(b);\n        }\n    };\n}\n\nint main(){\n\tint C;cin >> C;\n\twhile(C--!=0){\n\t\tint xa,ya,xb,yb;cin >> xa >> ya >> xb >> yb;\n\t\tL base(P(xa,ya),P(xb,yb));\n\t\tint n;cin >> n;\n\t\tvector<pair<pair<P,int>,int>> inps;\n\t\tREP(i,n){\n            int xs,ys,xt,yt,o,l;cin >> xs >> ys >> xt >> yt >>o >> l;\n            L line=L(P(xs,ys),P(xt,yt));\n            if(base.is_intersected(line))inps.push_back(make_pair(make_pair(base.intersection_ls(line),o),l));\n        }\n        sort(ALL(inps));\n        \n        int res=0;  \n        if(inps.size()>0){\n            int prev=-1;\n            {\n                int o=inps[0].first.second,l=inps[0].second;\n                if(o)prev=l;else prev=!l;\n            }\n            for(int i=1;i<inps.size();i++){\n                int o=inps[i].first.second,l=inps[i].second;\n                if(o){\n                    if(prev!=l)res++;\n                    prev=l;\n                }else{\n                    if(prev!=!l)res++;\n                    prev=!l;\n                }\n            }\n        }\n        cout <<res<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\n\nint main() {\n\tint a; cin >> a;\n\tfor (int i = 0; i < a; ++i) {\n\t\tint xa, ya, xb, yb; cin >> xa >> ya >> xb >> yb;\n\t\tPoint a(xa, ya);\n\t\tPoint b(xb, yb);\n\t\tLine nl(a, b);\n\t\tint n; cin >> n;\n\t\tvector<pair<Line, bool>>ls;\n\t\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint xs, ys, xt, yt, o, l; cin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tPoint s(xs, ys);\n\t\t\tPoint t(xt, yt);\n\t\t\tls.push_back(make_pair(Line(s, t), bool(o^l)));\n\t\t}\n\t\tvector<pair<Point, int >>touchps;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (isis_ss(nl,ls[i].first)) {\n\t\t\t\tPoint p(is_ll(nl, ls[i].first));\n\t\t\t\ttouchps.push_back(make_pair(p, ls[i].second));\n\t\t\t}\n\t\t}\n\t\tsort(touchps.begin(), touchps.end());\n\t\tint now = -1;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < touchps.size(); ++i) {\n\t\t\tif (now==-1||now == touchps[i].second) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tnow = touchps[i].second;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// * XY座標\n#define X real()\n#define Y imag()\n\n// * 点の表現\ntypedef complex<double> P;\n\n// * 許容する誤差ε\nconst double EPS = 1e-9;\n// * Infinity\nconst double INF = 1e12;\n// * 円周率\nconst double PI = acos(-1.0);\n// * Infinity 2\nconst P INF_P(INF,INF);\n\n// * complex<double> の順序を定義する\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn (real(a) != real(b))? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\n// * 2つのスカラーが等しいかどうか\nbool equal(double a, double b) {\n\treturn ( fabs( a - b ) < EPS );\n}\n\n// * 2点間の距離\ndouble dist(P p1, P p2) {\n\treturn abs(p1 - p2);\n}\n\n// * 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(P a, P b) {\n\treturn real( conj(a) * b );\n}\n\n// * 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(P a, P b) {\n\treturn imag( conj(a) * b ) ;\n}\n\n// 2 直線の平行判定 : a//b <=> cross(a, b) = 0\nint is_parallel(P a1, P a2, P b1, P b2) {\n    return equal( cross(a1-a2, b1-b2), 0.0 );\n}\n\n// CCW : 反時計回り (Counter Clock Wise)\n// CW : 時計回り (Clock Wise)\nenum {CCW=1, CW=-1, ON=0};\n// * 3点がどちら回りであるか返す, 3点が1直線に乗っているときは ON を返す\nint ccw(const P &a, P b, P c) {\n\tb-=a, c-=a;\n\tdouble rotdir = cross(b,c);\n\tif( rotdir >  EPS ) return CCW;\n\tif( rotdir < -EPS ) return CW;\n\treturn ON;\n}\n\n// 線分の表現\nstruct Segment{\n\t// 点 a, b を端点とする線分\n\tP a, b;\n\t// コンストラクタで初期化\n\tSegment(P a_, P b_) {\n\t\t// x 座標の小さいほうの点を 点 a とする. (不要なときはこの1行を削除すること!!!)\n\t\tif( b_ < a_ ) swap(a_,b_);\n\t\ta = a_; b = b_;\n\t}\n\t// 線分の長さを返す\n\tdouble length() { return abs(a-b); }\n\t// 中点を返す\n\tP mid() { return P( (a.X+b.X)/2.0 , (a.Y+b.Y)/2.0 ); }\n\t// 点 p が線分上にあるかどうか\n\tbool contain(P p) { return (abs(a-p) + abs(p-b) < abs(a-b) + EPS); }\n\t// 線分と点 p の距離\n\tdouble distance(P p) {\n\t\tif( dot(b-a, p-a) < EPS ) return abs(p-a);\n\t\tif( dot(a-b, p-b) < EPS ) return abs(p-b);\n\t\treturn abs(cross(b-a, p-a)) / abs(b-a);\n\t}\n\t// 線分 s と交差しているかどうかを返す.\n\tbool is_intersection(const Segment& s){\n\t\treturn ( ccw(a, b, s.a)   * ccw(a, b, s.b) <= 0 && \n\t\t         ccw(s.a, s.b, a) * ccw(s.a, s.b, b) <= 0 );\n\t}\n\t// 線分の交差判定と交点計算\n\tbool intersection(Segment s, P& p) {\n\t\tbool result = is_intersection( s );\n\t\tif( result ) {\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\t\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ) { // 2つの線分が同じ直線上にあるとき\n\t\t\t\tif( this->contain(s.a) ) {\n\t\t\t\t\tp = s.a;\n\t\t\t\t}else if( this->contain(s.b) ) {\n\t\t\t\t\tp = s.b;\n\t\t\t\t}else if( s.contain( a ) ) {\n\t\t\t\t\tp = a;\n\t\t\t\t}else if( s.contain( b ) ) {\n\t\t\t\t\tp = b;\n\t\t\t\t}else {\n\t\t\t\t\tp = INF_P;\n\t\t\t\t}\n\t\t\t}else if( abs(d1) < EPS ) {\n\t\t\t\tp = INF_P;\n\t\t\t}else {\n\t\t\t\tdouble t = d1 / (d1 + d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t}\n\t\t}else{\n\t\t\tp = INF_P;\n\t\t}\n\t\treturn result;\n\t}\n\t// 線分と線分の距離\n\tdouble distance(Segment s) {\n\t\tif( is_intersection(s) ) return 0.0;\n\t\treturn min( min(distance(s.a), distance(s.b)), min(s.distance(a), s.distance(b)) );\n\t}\n\t// デバッグ出力\n\tvoid print() { printf(\"line(%f,%f,%f,%f); \\n\", a.X, a.Y, b.X, b.Y ); }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    for(int i_=0 ; i_ < N ; i_++ ){\n        int xa, ya, xb, yb, n;\n        cin >> xa >> ya >> xb >> yb;\n        // 駅A と 駅B を結ぶ 線分AB\n        P A(xa,ya), B(xb,yb);\n        Segment AB( A, B );\n         \n        // 点Aと交点の距離と交点で地下と高架のどちらを通るべきか保持\n        // v[i] := (点Aからの距離, 0 or 1 )\n        vector< pair<double,int> > v;\n         \n        cin >> n;\n        for(int j_=0 ; j_ < n ; j_++ ){\n            int sx,sy,tx,ty,o,l;\n            cin >> sx >> sy >> tx >> ty >> o >> l;\n            P S(sx,sy), T(tx,ty);\n            Segment ST( S, T );\n             \n            // 交差するかどうか\n            if( AB.is_intersection(ST) ){\n            \tP p;\n            \tAB.intersection(ST, p);\n                // 平行かどうか\n                if( is_parallel( A , B , S , T ) ){\n                    continue;\n                }\n                // 距離\n                double d = dist( A , p );\n                v.push_back( pair<double,int>(d, o^l) );\n            }\n        }\n         \n        sort( v.begin() , v.end() );\n        int ans=0;\n        for(int i=1 ; i < v.size() ; i++ ){\n            if( v[i-1].second != v[i].second ){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\n#define N 100\n#define INFF 100.0\n\ndouble f(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) {\n\tif( (Y1-Y2)*(x1-x2)==(X1-X2)*(y1-y2) ) return INFF;\n\treturn (double)( (X1-X2)*(y2-Y2)-(Y1-Y2)*(x2-X2) )/(double)( (Y1-Y2)*(x1-x2)-(X1-X2)*(y1-y2) );\n}\n\nint main() {\n\tint nn, n, xa, ya, xb, yb, p, ans;\n\tint xs, ys, xt, yt, o, l;\n\tmap<double, int> tl; double t1, t2;\n\tmap<double, int>::iterator it;\n\tcin >> nn;\n\tfor(int q=0; q<nn; ++q) {\n\t\tcin >> xa >> ya >> xb >> yb;\n\t\tcin >> n;\n\t\ttl.clear();\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tt1 = f(xa, ya, xb, yb, xs, ys, xt, yt);\n\t\t\tt2 = f(xs, ys, xt, yt, xa, ya, xb, yb);\n\t\t\tif(0.000000<=t1&&t1<=1.000000&&0.000000<=t2&&t2<=1.000000) {\n\t\t\t\ttl[t1] = (o==1?l:1-l);\n\t\t\t}\n\t\t}\n\t\tit = tl.begin(); p = (*it).second; ans = 0;\n\t\tfor(++it; it!=tl.end(); ++it) {\n\t\t\tif((*it).second!=p) {\n\t\t\t\tans++; p = (*it).second;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\n#define equals(a,b) (fabs( (a) - (b) )< EPS )\n// c++ 11,14\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\ntypedef struct point{\n\tdouble x,y;\n\tpoint(){};\n\tpoint(double x ,double y):x(x),y(y){};\n\tpoint operator + (point &p){ return point(x+p.x,y+p.y);\t}\n\tpoint operator - (point &p){ return point(x-p.x,y-p.y);\t}\n\tpoint operator * (point &p){ return point(x*p.x-y*p.y,x*p.y+y*p.x) ;}\n\tpoint operator * (double a){ return point(x*a,y*a);\t}\n\tpoint operator / (double a){ return point(x/a,y/a);\t}\n\t\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x+y*y; }\n\tvoid make(){ cin>>x>>y;}\n\tbool operator < (const point &p) const { return x!=p.x ? x<p.x : y<p.y; }\n\tbool operator == (const point &p) const { return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS; }\n}point;\ndouble abs(point a){return a.abs();}\ndouble norm(point a){return a.norm();}\n\ntypedef complex<double> C;\ntypedef struct { \n\tpoint s,e;\n\tvoid make(){ s.make(); e.make();}\n} line;\n\nC convert(point a){ return C(a.x,a.y); }\npoint convert( C a){ return point(a.real(),a.imag() );}\ndouble dot(point a,point b){ return a.x*b.x+a.y*b.y ; } //内積　a・b\ndouble cross(point a,point b){ return a.x*b.y - a.y*b.x ; }//外積(z成分)　a×b\npoint vec(line l){return l.e-l.s;}\nline make(point s,point e){\n\tline res; res.s=s; res.e=e;\n\treturn res;\n}\npoint make(){ \n\tdouble x,y; cin>>x>>y;\n       \treturn point(x,y);\n}\nline lmake(){\n\tpoint p0=make();\n\tpoint p1=make();\n\treturn make(p0,p1);\n}\n//直交\nbool isorthogonal(point a,point b){ return equals(dot(a,b), 0.0); }\nbool isorthogonal(line l1,line l2){ return isorthogonal(vec(l1),vec(l2)); }\n//平行\nbool isparallel(point a,point b){ return equals(cross(a,b),0.0); }\nbool isparallel(line l1,line l2){ return isparallel(vec(l1),vec(l2)); }\n//射影\npoint project(line s,point p){\n\tpoint base = vec(s);\n\tdouble r=dot(p-s.s,base)/base.norm();\n\tbase = base*r;\n\treturn s.s+base;\n}\n//反射\npoint reflect(line l,point p){\n\tpoint tmp=project(l,p)-p;\n\ttmp= tmp*2.0;\n\treturn p+tmp;\n\n}\n//交差判定\n\nint ccw(point p0,point p1,point p2){\n\tpoint a = p1-p0;\n\tpoint b = p2-p0;\nif(cross(a,b)>EPS) return 1;//counter_clockwise\nif(cross(a,b)<-EPS) return -1;//clockwise\nif(dot(a,b)<-EPS)return 2;//online_back\nif(a.norm()<b.norm() ) return -2;//online_front\nreturn 0;//on_segment\n}\n// line p1-p2 line p3-p4\nbool intersect(point p1,point p2,point p3,point p4){\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0 ); \n}\n// line l1,l2\nbool intersect(line l1,line l2){ return intersect(l1.s,l1.e,l2.s,l2.e); }\n\n\n//距離\n//point-point\ndouble distance(point a,point b){ return abs(a-b); }\n//point-line(直線）\ndouble distance2(line l,point p){\n\treturn abs(cross(vec(l),p-l.s)/abs(l.e-l.s));\n}\n//point-line(線分)\ndouble distance(line l,point p){\n\tif( dot(vec(l),p-l.s) <0.0 ) return abs(p-l.s);\n\tif( dot(l.s-l.e,p-l.e) <0.0 ) return abs(p-l.e);\n\treturn distance2(l,p);\n}\n//line-line\ndouble distance(line l1,line l2){\n\tif(intersect(l1,l2))\treturn 0.0;\n\treturn min(min(distance(l1,l2.s),distance(l1,l2.e) ), min(distance(l2,l1.s),distance(l2,l1.e) ) );\n}\n\n//交点\npoint crosspoint(line l1,line l2){\n\tpoint base = vec(l2);\n\tdouble d1 = abs(cross(base,l1.s-l2.s) );\n\tdouble d2 = abs(cross(base,l1.e-l2.s) );\n\tdouble t = d1/(d1+d2);\n\tpoint tmp = vec(l1)*t;\n\treturn l1.s+tmp;\n}\n//面積\ndouble area(vector<point> &p,int n){\n\tdouble ans=0.0;\n\tfor(int i=0;i<n-2;i++){\n\tans+=cross(p[i+2]-p[0],p[i+1]-p[0]);\n\t}\n\treturn abs(ans)/2;\n}\ndouble area(vector<point> p){\n\treturn area(p,p.size());\n}\n//内包\nint contains(vector<point> &g,point p){\nint n=g.size();\nbool flag=false;\n\tfor(int i=0;i<n;i++){\n\t\tpoint a=g[i]-p, b=g[(i+1)%n]-p;\n\t\tif(abs(cross(a,b) )<EPS && dot(a,b) <EPS)return 1;\n\t\tif(a.y>b.y) swap(a,b);\n\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS) flag=!flag;\n\t}\n\treturn (flag? 2:0);\n}\n//凸包\nvector<point> andrewscan(vector<point> &s){\n\tvector<point> u,l;\n\tif(s.size() <3) return s;\n\tsort(s.begin(),s.end());\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size()-1]);\n\tl.push_back(s[s.size()-2]);\n\n\tfor(int i=2;i<s.size();i++){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\n\tfor(int i=s.size()-3;i>=0;i--){\n\t\t\t//凸包の辺上を含めない場合\n\t\tfor(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n\t\t\t//凸包の辺上を含める場合\n\t\t//for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])==COUNTER_CLOCKWISE;n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\n\treverse(l.begin(),l.end());\n\tfor(int i=u.size()-2;i>=1;i--)l.push_back(u[i]);\n\treturn l;\n}\n//直径\ndouble convex_diameter(vector<point> &g){\n\tint n=g.size();\n\tint is=0,js=0;\n\tfor(int i=1;i<n;i++){\n\t\tif(g[is].y < g[i].y)is =i;\n\t\tif(g[i].y < g[js].y)js=i;\n\t}\n\tdouble maxd = abs((g[is]-g[js]));\n\tint i,mi,j,mj;\n\ti=mi=is;\n\tj=mj=js;\n\tdo{\n\t\tif(cross(g[(i+1)%n]-g[i],g[(j+1)%n]-g[j])>=0)j=(j+1)%n;\n\t\telse i=(i+1)%n;\n\t\tif(abs(g[i]-g[j])>maxd){\n\t\t\t//cerr<<i<<' '<<j<<' '<<norm(g[i]-g[j])<<endl;\n\t\t\tmaxd =abs(g[i]-g[j]);\n\t\t\tmi=i;mj=j;\n\t\t}\n\t}while(i!=is||j!=js);\n\treturn maxd;\n}\n\t\ntypedef pair<line,int> msp;\ntypedef pair<point,int> mmp;\nint solve(vector<msp> &l,line s){\n\tvector<mmp> a;\n\tfor(int i=0;i<l.size();i++){\n\t\tif(intersect(l[i].first,s) ){\n\t\t\ta.push_back( mmp( crosspoint(l[i].first,s), l[i].second)  ) ;\n\t\t}\n\t}\n\tsort(a.begin(),a.end());\n\tint s1 = 0,s2 = 1;\n\tint cnt1 = 0,cnt2 = 0;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(s1 != a[i].second){\n\t\t\ts1 = a[i].second;\n\t\t\tcnt1++;\n\t\t}\n\t\tif(s2 != a[i].second){\n\t\t\ts2 = a[i].second;\n\t\t\tcnt2++;\n\t\t}\n\t}\n\treturn min(cnt1,cnt2);\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tline s;\n\t\ts.make();\n\t\t//cout<<\"ok\"<<endl;\n\t\t//s.print();\n\t\tint m;\n\t\tcin>>m;\n\t\tvector<msp> l(m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tl[i].first.make();\n\t\t//\tcout<<i<<endl;\n\t\t//\tl[i].first.print();\n\t\t\tint o,h;\n\t\t\tcin>>o>>h;\n\t\t\tl[i].second = o^h;\n\t\t}\n\t\tcout<<solve(l,s)<<endl;\n\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 1000\nusing namespace std;\n\n// library --- start\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:y<p.y; }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nbool pequals(Point a,Point b){ return equals(a.x,b.x) && equals(a.y,b.y); }\n\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// library --- end\n\nstruct Pox\n{\n  Segment s;\n  double dist;\n  bool o,l;\n  Pox(Segment s=Segment(),double dist=inf,bool o=false,bool l=false):s(s),dist(dist),o(o),l(l){}\n\n  bool operator < (const Pox& a)const{ return dist < a.dist; }\n\n};\n\nPoint a,b;\nint n;\nSegment seg[MAX];\nPox     pox[MAX];\n\nint compute(bool state)\n{\n  //cout << \"first state : \" << (state?\"kouka\":\"tika\") << endl;\n  int cnt = 0;\n  rep(i,n)//0\n    {\n      if(pox[i].dist == inf)break;\n      //cout << i << \"-th \" << (state?\"kouka\":\"tika\") << endl;\n      if(pox[i].o)\n\t{//it's me\n\t  if(pox[i].l == state)\n\t    {\n\t\t      \n\t    }\n\t  else\n\t    {//cout << \"add!\" << endl;\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t}\n      else\n\t{//mario\n\t  if(pox[i].l == state)\n\t    {//cout << \"add!\" << endl;\n\t      cnt++;\n\t      state = !state;\n\t    }\n\t  else\n\t    {\n\n\t    }\n\t}\n    }\n  //cout << \"cnt = \" << cnt << endl;\n  return cnt;\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> a.x >> a.y >> b.x >> b.y;\n\t  cin >> n;\n\t  rep(i,n)\n\t    {\n\t      cin >> seg[i].p1.x >> seg[i].p1.y >> seg[i].p2.x >> seg[i].p2.y >> pox[i].o >> pox[i].l;\n\t      pox[i].s = seg[i];\n\t      Point p = (intersectSS(Segment(a,b),seg[i])?crosspoint(Segment(a,b),seg[i]):Point(inf,inf));\n\t      pox[i].dist = (intersectSS(Segment(a,b),seg[i])?sqrt(norm(a-p)):inf);\n\t    }\t  \n\t  sort(pox,pox+n); \n\t  /*\n\t  cout << \"------------\" << endl;\n\t  rep(i,n)\n\t    {\n\t      if(pox[i].dist == inf)break;\n\t      cout << \"( (\" << pox[i].s.p1.x << \",\" << pox[i].s.p1.y << \") (\" << pox[i].s.p2.x << \",\" << pox[i].s.p2.y << \") )\" << endl;\n\t      cout << \"dist = \" << pox[i].dist << endl;\n\t      cout << (pox[i].o?\"you\":\"he\") << \" \" << (pox[i].l?\"kouka\":\"tika\") << endl;\n\t      cout << endl;\n\t    }\n\t  cout << endl;\n\t  */\n\t  cout << min(compute(false),compute(true)) << endl;\n\t}\n    }\n  return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ndouble crosspoint(double a, double b, double c, double d, double e, double f,\n                  double g, double h) {\n  if (a == c) {\n    return a;\n  } else if (e == g) {\n    return e;\n  }\n  double numerator   = (h * e - f * g) * (a - c) + (b * c - d * a) * (e - g);\n  double denominator = (b - d) * (e - g) + (h - f) * (a - c);\n  // cerr << \"\\033[93m\"\n  //      << \"crosspoint:\" << numerator / denominator << \"\\033[m\" << endl;\n  return numerator / denominator;\n}\n\n// a<=c,e<=gになるように入れること\nbool iscrossing(double a, double b, double c, double d, double e, double f,\n                double g, double h) {\n  double cross_x = crosspoint(a, b, c, d, e, f, g, h);\n  // cross_yも入れる必要あり？\n  double cross_y;\n  if (a - c != 0) {\n    cross_y = (b - d) * cross_x / (a - c) + (d * a - b * c) / (double)(a - c);\n  } else if (e - g != 0) {\n    cross_y = (f - h) * cross_x / (e - g) + (h * e - f * g) / (double)(e - g);\n  } else {\n    return false;\n  }\n\n  if (a <= cross_x && cross_x <= c && e <= cross_x && cross_x <= g) {\n    // xはチェック済み\n    if (b < d) {\n      if (!(b <= cross_y && cross_y <= d)) return false;\n    } else {\n      if (!(d <= cross_y && cross_y <= b)) return false;\n    }\n    if (f < h) {\n      if (!(f <= cross_y && cross_y <= h)) return false;\n    } else {\n      if (!(h <= cross_y && cross_y <= f)) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstruct CrossInfo {\n  double pos;\n  bool ismine;\n  bool ishigh;\n  CrossInfo(double p, bool mine, bool high) {\n    pos    = p;\n    ismine = mine;\n    ishigh = high;\n  }\n  bool operator<(const CrossInfo& a) const {\n    return pos < a.pos;\n  }\n};\n\nbool shouldhigh(bool ismine, bool ishigh) {\n  if (ishigh) {\n    if (ismine) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    if (ismine) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nint Solve() {\n  int64_t n, a, b, c, d;\n  cin >> a >> b >> c >> d >> n;\n  std::vector<CrossInfo> crossinfo;\n  if (a > c) {\n    std::swap(a, c);\n    std::swap(b, d);\n  }\n  for (int i = 0; i < n; i++) {\n    int64_t e, f, g, h;\n    bool ismine, ishigh;\n    cin >> e >> f >> g >> h >> ismine >> ishigh;\n    if (e > g) {\n      std::swap(e, g);\n      std::swap(f, h);\n    }\n    if (iscrossing(a, b, c, d, e, f, g, h)) {\n      crossinfo.push_back(\n          CrossInfo(crosspoint(a, b, c, d, e, f, g, h), ismine, ishigh));\n    }\n  }\n\n  if (crossinfo.size() == 0) {\n    return 0;\n  }\n  int result = 0;\n  std::sort(crossinfo.begin(), crossinfo.end());\n  // cerr << \"\\033[93m\" << crossinfo.size() << \"\\033[m\" << endl;\n  bool nowhigh = shouldhigh(crossinfo.front().ismine, crossinfo.front().ishigh);\n  for (auto ci : crossinfo) {\n    // cerr << \"\\033[93m\" << ci.pos << \" \" << ci.ishigh << \" \" << ci.ismine\n    //      << \"\\033[m\" << endl;\n    assert(-10000 <= ci.pos && ci.pos <= 10000);\n    if (nowhigh) {\n      if (!shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = false;\n      }\n    } else {\n      if (shouldhigh(ci.ismine, ci.ishigh)) {\n        result++;\n        nowhigh = true;\n      }\n    }\n  }\n  return result;\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cout << Solve() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef complex<double> P;\n#define PI acos(-1)\n#define EPS 1e-10\n#define INF 1e9\n\nP A, B;\nint N;\nP S[100], T[100];\nint O[100], L[100];\n\ndouble cross(P a, P b) { return imag(conj(a) * b); }\n\nbool is_crossing(P a1, P a2, P b1, P b2)\n{\n\tbool l = cross(a2 - a1, b1 - a1) * cross(a2 - a1, b2 - a1) < EPS;\n\tbool r = cross(b2 - b1, a1 - b1) * cross(b2 - b1, a2 - b1) < EPS;\n\treturn l && r;\n}\n\nP intersection_is(P a1, P a2, P b1, P b2)\n{\n\tP b = b2 - b1;\n\tdouble d1 = abs(cross(b, a1 - b1));\n\tdouble d2 = abs(cross(b, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\treturn a1 + (a2 - a1) * t;\n}\n\nint solve()\n{\n\tvector<pair<double, int> > vp;\n\n\trep(i, 0, N) if (is_crossing(A, B, S[i], T[i]))\n\t{\n\t\tP c = intersection_is(A, B, S[i], T[i]);\n\n\t\tdouble d = abs(c - A);\n\n\t\tint place;\n\n\t\tif (O[i] == 1)\n\t\t\tplace = L[i];\n\t\telse\n\t\t\tplace = 1 - L[i];\n\n\t\tvp.push_back(make_pair(d, place));\n\t}\n\n\tsort(vp.begin(), vp.end());\n\n\tint ans = 0;\n\trep(i, 1, vp.size())\n\t{\n\t\t//assert(EPS < abs(vp[i].first - vp[i - 1].first));\n\t\tif (abs(vp[i].first - vp[i - 1].first) < EPS)\n\t\t{\n\t\t\tans++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (vp[i].second != vp[i - 1].second) ans++;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint dn; cin >> dn;\n\trep(i, 0, dn)\n\t{\n\t\tdouble x, y;\n\n\t\tcin >> x >> y; A = P(x, y);\n\t\tcin >> x >> y; B = P(x, y);\n\t\tcin >> N;\n\t\trep(j, 0, N)\n\t\t{\n\t\t\tcin >> x >> y; S[j] = P(x, y);\n\t\t\tcin >> x >> y; T[j] = P(x, y);\n\t\t\tcin >> O[j] >> L[j];\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\ntypedef complex<double> P;\n\ndouble dot(P a, P b){ return real( conj(a) * b ); }\n\ndouble cross(P a, P b){ return imag( conj(a) * b ); }\n\nstruct Segment{\n\tP a, b;\n\tSegment(P a_, P b_){ a = a_; b = b_; }\n\tSegment(){}\n\tbool is_intersection(const Segment& s){\n\t\treturn ( cross(b-a, s.a-a) * cross(b-a, s.b-a) < EPS ) && (cross(s.b-s.a, a-s.a) * cross(s.b-s.a, b-s.a) ) ;\n\t}\n\tbool intersection(Segment s, P& p){\n\t\tbool result = is_intersection( s );\n\t\tif( result ){\n\t\t\tdouble d1 = abs( cross(s.b-s.a, a-s.a) );\n\t\t\tdouble d2 = abs( cross(s.b-s.a, b-s.a) );\n\t\t\tif( abs(d1) < EPS && abs(d2) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else if( abs(d1) < EPS ){\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\tdouble t = d1 / (d1+d2);\n\t\t\t\tp = a + (b-a) * t;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nint main(){\n\tint T;\n\tcin >> T;\n\tfor(int t_=0 ; t_ < T ; t_++ ){\n\t\tint xa, ya, xb, yb, n;\n\t\tcin >> xa >> ya >> xb >> yb >> n;\n\n\t\tP start(xa,ya), goal(xb,yb);\n\t\tSegment S( start , goal );\n\n\t\tvector< pair<int,int> > v;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint xs, ys, xt, yt, o, l;\n\t\t\tcin >> xs >> ys >> xt >> yt >> o >> l;\n\t\t\tSegment s( P(xs,ys) , P(xt,yt) );\n\n\t\t\tP p(0,0);\n\t\t\tif( S.intersection( s , p ) ){\n\t\t\t\tint d = (start.X - p.X)*(start.X - p.X) + (start.Y - p.Y)*(start.Y - p.Y);\n\t\t\t\tv.push_back( pair<int,int> ( d , o^l ) );\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tsort( v.begin() , v.end() );\n\t\tif( v.size() >= 2 ){\n\t\t\tint pos = v[0].second;\n\t\t\tfor(int i=1 ; i < v.size() ; i++ ){\n\t\t\t\tif( pos != v[i].second ){\n\t\t\t\t\tpos = v[i].second;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << cnt << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <utility>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n \ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X, b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\nint main(){\n    int rep;\n    cin >> rep;\n    for(int r=0; r<rep; r++){\n        int sx,sy, gx,gy;\n        cin >> sx >> sy >> gx >> gy;\n        L rail(P(sx,sy), P(gx,gy));\n        int n;\n        cin >> n;\n        vector<pair<P, int> > cp;\n        for(int i=0; i<n; i++){\n            int l, o, tag;\n            cin >> sx >> sy >> gx >> gy >> l >> o;\n            L r = L(P(sx,sy), P(gx,gy));\n            tag = l^o;\n            if(!isParallel(rail, r) && intersectSS(rail, r)){\n                cp.push_back(make_pair(crosspointLL(rail, r), tag));\n            }\n        }\n        sort(cp.begin(), cp.end());\n        int ans = 0;\n        for(int i=0; i<(int)cp.size()-1; i++){\n            if(cp[i].second != cp[i+1].second) ans++;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nclass Road\n{\npublic:\n    Road(int _xs, int _ys, int _xt, int _yt, bool _l)\n    {\n        xs = _xs;\n        ys = _ys;\n        xt = _xt;\n        yt = _yt;\n        l = _l;\n    }\n\n    int xs, ys, xt, yt;\n\n    //l : true??§?????¶\n    bool l;\n\n};\n\n//https://qiita.com/ykob/items/ab7f30c43a0ed52d16f2\nbool crossed(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) \n{\n  int ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  int tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  int tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  int td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n  return tc * td < 0 && ta * tb < 0;\n  // return tc * td <= 0 && ta * tb <= 0; // ?????????????????´???\n};\nint main()\n{\n    auto data_num = 0;\n    cin >> data_num;\n    for(auto i = 0; i < data_num; i++)\n    {\n        int xa, ya, xb, yb;\n        cin >> xa >> ya >> xb >> yb;\n\n        int n;\n        cin >> n;\n        vector<Road> roads;\n        roads.reserve(n);\n\n        vector< pair<float, bool> > crossPoints{};\n\n        for(int j = 0; j < n; j++)\n        {\n\n            int xs, ys, xt, yt;\n            bool o, l;\n\n            cin >> xs >> ys >> xt >> yt >> o >> l;\n\n            //???????????¢?????????\n            roads.push_back( Road(xs, ys, xt, yt, !(o ^ l) ) );\n        }\n\n        for(const auto& r : roads)\n        {\n            if(crossed(xa, ya, xb, yb, r.xs, r.ys, r.xt, r.yt))\n            {\n                float cross_x = ((r.ys * r.xt - r.xs * r.yt) * (xb - xa) - (ya * xb - xa * yb) * (r.xt - r.xs)) / (float)((yb - ya) * (r.xt - r.xs) - (xb - xa) * (r.yt - r.ys)); \n                float cross_y = ((r.ys * r.xt - r.xs * r.yt) * (yb - ya) - (ya * xb - xa * yb) * (r.yt - r.ys)) / (float)((yb - ya) * (r.xt - r.xs) - (xb - xa) * (r.yt - r.ys)); \n                float differ_x = xa - cross_x;\n                float differ_y = ya - cross_y;\n                float dist = differ_x * differ_x + differ_y * differ_y;\n\n                crossPoints.push_back( make_pair(dist, r.l) );\n            }\n        }\n        sort(crossPoints.begin(), crossPoints.end());\n\n\n\n        auto ans = 0;\n        bool nowHeight = crossPoints[0].second;\n        for(const auto& cp : crossPoints)\n        {\n            if(nowHeight != cp.second)\n            {\n                nowHeight = cp.second;\n                ans++;\n            }\n        }\n\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\ntypedef pair<double, int> pdi;\n\nstruct point { double x, y; };\nstruct line { point p, q; };\n\nint T, N, O[110], L[110];\nline A, S[110];\n\nbool intersect(line l1, line l2) {\n  double ax = l1.p.x, ay = l1.p.y;\n  double bx = l1.q.x, by = l1.q.y;\n  double cx = l2.p.x, cy = l2.p.y;\n  double dx = l2.q.x, dy = l2.q.y;\n  double ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n  double tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n  double tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n  double td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n  return tc * td < 0 && ta * tb < 0;\n}\n\ndouble distance(line l, point p) {\n  double ux = l.q.x - l.p.x;\n  double uy = l.q.y - l.p.y;\n  double vx = p.x - l.p.x;\n  double vy = p.y - l.p.y;\n  double cross = abs(ux * vy - uy * vx);\n  double ul = sqrt(ux * ux + uy * uy);\n  return cross / ul;\n}\n\nint main(void) {\n  cin >> T;\n  while(T--) {\n    cin >> A.p.x >> A.p.y >> A.q.x >> A.q.y;\n    cin >> N;\n    REP(i, 0, N) cin >> S[i].p.x >> S[i].p.y >> S[i].q.x >> S[i].q.y >> O[i] >> L[i];\n\n    double d = sqrt((A.p.x - A.q.x) * (A.p.x - A.q.x) + (A.p.y - A.q.y) * (A.p.y - A.q.y));\n\n    vector<pdi> E;\n    REP(i, 0, N) if(intersect(A, S[i])) {\n      double da = distance(S[i], A.p);\n      double db = distance(S[i], A.q);\n      double dx = d * da / (da + db);\n      E.push_back(pdi(dx, i));\n    }\n\n    sort(E.begin(), E.end());\n\n    vector<int> g;\n    REP(i, 0, E.size()) {\n      int k = E[i].second;\n      g.push_back(O[k] == 1 ? L[k] : (L[k] ^ 1));\n    }\n\n    int ans = 0;\n    REP(i, 0, g.size() - 1) if(g[i] != g[i + 1]) ans++;\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢È¢±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n\nP p1,p2;\n\nclass Point{\npublic:\n    P p;\n    int t;\n    bool operator<(const Point &pp)const{\n        double dist1=abs(p1-pp.p);\n        double dist2=abs(p1-this->p);\n        return dist2<dist1;\n    }\n};\n\nint main(){\n    int data;\n    cin>>data;\n    while(data--){\n        int x,y;\n        cin>>x>>y;\n        p1=P(x,y);\n        cin>>x>>y;\n        p2=P(x,y);\n        int n;\n        cin>>n;\n        vector<Point> crossPoint;\n        for(int i = 0; i < n; i++){\n            int xs,ys,xt,yt,o,l;\n            cin>>xs>>ys>>xt>>yt>>o>>l;\n            P a=P(xs,ys);P b=P(xt,yt);\n            if(is_intersected_ls(a,b,p1,p2)){\n                P res=intersection_ls(a,b,p1,p2);\n                Point pp;\n                pp.p=res;\n                pp.t=l^o;\n                crossPoint.push_back(pp);\n            }\n        }\n        // ð_ðp1Éß¢ÔÉ\\[g\n        sort(crossPoint.begin(),crossPoint.end());\n        if(crossPoint.size()==0){\n            cout<<0<<endl;\n            continue;\n        }\n        // »ÝÌ©ªÌHüîñ(1:nã,0:nº)\n        int sit=0;\n        sit=crossPoint[0].t;\n        // ð_ðp1Éß¢ÔÉ\n        int cnt=0;\n        for(int i = 1; i < crossPoint.size(); i++){\n            if(crossPoint[i].t!=sit){\n                sit=crossPoint[i].t;\n                cnt++;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct L:public vector<P> {\n  L(const P& a,const P& b){push_back(a);push_back(b);}\n};\n\ndouble dot(P a, P b) {\n  return a.real()*b.real()+a.imag()*b.imag();\n}\n\ndouble cross(P a, P b) {\n  return dot(P(-a.imag(),a.real()),b);\n}\n\nint ccw(P a, P b, P c) {\n  b-=a; c-=a;\n  if(cross(b,c)>0)return +1;\n  if(cross(b,c)<0)return -1;\n  if(dot(b,c)<0)return +2;\n  if(norm(b)<norm(c))return -2;\n  return 0;\n}\n\nbool hit(const L& s, const L& t) {\n  return ccw(s[0],t[0],s[1])*ccw(s[0],t[1],s[1])<=0;\n}\n\ndouble crosslen(const L& s, const L& t) {\n  P ab=s[1]-s[0], ac=t[0]-s[0], ad=t[1]-s[0];\n  ab/=norm(ab);\n  double lac=dot(ab,ac), lad=dot(ab,ad);\n  double dac=abs(ac-ab*lac), dad=abs(ad-ab*lad);\n  return (lac*dad+lad*dac)/(dad+dac);\n}\n\nstruct LINE {\n  L line;\n  int o,l;\n};\n\nstruct POINT {\n  LINE line;\n  double len;\n};\n\nbool comp (POINT a, POINT b) {\n  return a.len < b.len;\n}\n\nint main () {\n  int m;cin>>m;\n  while(m--){\n    vector<POINT> points;\n    vector<LINE> lines;\n    double xa,ya,xb,yb;cin>>xa>>ya>>xb>>yb;\n    int n;cin>>n;\n    L self(P(xa,ya),P(xb,yb));\n    for(int i=0;i<n;++i){\n      double a,b,c,d;int e,f;cin>>a>>b>>c>>d>>e>>f;\n      lines.push_back((LINE){L(P(a,b),P(c,d)),e,f});\n    }\n    for(int i=0;i<n;++i)\n      if(hit(self,lines[i].line))\n\tpoints.push_back((POINT){lines[i],crosslen(self,lines[i].line)});\n    sort(points.begin(),points.end(),comp);\n    int len=points.size();\n    if(len==0){cout<<0<<endl;continue;}\n    LINE line=points[0].line;\n    int precur,cur=0,result=0;\n    if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n    for(int i=1;i<len;++i){\n      line=points[i].line;\n      precur=cur; if(line.o==1){cur=line.l;}else{cur=1-line.l;}\n      if(precur!=cur){++result;}\n    }\n    cout<<result<<endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\nconst double EPS=1e-10;\ntypedef struct P{double x,y;int o,l;}P;\nint C,N,XS,YS,XT,YT,O,L,XA,YA,XB,YB,i,b,tx,ty,c,T,R;\ndouble r,s;\nP ST[105];\nint cmp(const void* a,const void* b)\n{\n\tP* A=(P*)a;\n\tP* B=(P*)b;\n\tif(abs(A->x-B->x)<0)\n\t{\n\t\tif(A->y-B->y<0)return -1;\n\t\tif(B->y>A->y<0)return 1;\n\t}\n\tif(A->x-B->x<0)return -1;\n\tif(B->x-A->x<0)return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tfor(scanf(\"%d\",&C);C--;)\n\t{\n\t\tmemset(ST,0,sizeof(ST));\n\t\tscanf(\"%d%d%d%d%d\",&XA,&YA,&XB,&YB,&N);\n\t\tfor(i=c=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d%d%d\",&XS,&YS,&XT,&YT,&O,&L);\n\t\t\ttx=XS-XA;\n\t\t\tty=YS-YA;\n\t\t\tb=(XB-XA)*(YT-YS)-(YB-YA)*(XT-XS);\n\t\t\tif(b==0)continue;\n\t\t\tr=(double)((YT-YS)*tx-(XT-XS)*ty)/b;\n\t\t\ts=(double)((YB-YA)*tx-(XB-XA)*ty)/b;\n\t\t\tif(r<EPS||s<EPS||1.0-r<EPS||1.0-s<EPS)continue;\n\t\t\tif(r>EPS&&1.0-r>EPS){P ins={XA+r*(XB-XA),YA+r*(YB-YA),O,L};ST[c++]=ins;}\n\t\t\telse{P ins={XS+s*(XT-XS),YS+s*(YT-YS),O,L};ST[c++]=ins;}\n\t\t}\n\t\tqsort(ST,c,sizeof(P),cmp);\n\t\tR=999;\n\t\tfor(L=0;L<2;L++)\n\t\t{\n\t\t\tfor(T=L,i=b=0;i<c;i++)\n\t\t\t{\n\t\t\t\tif(ST[i].o==1&&ST[i].l!=T){b++;T^=1;}\n\t\t\t\tif(ST[i].o!=1&&ST[i].l==T){b++;T^=1;}\n\t\t\t}\n\t\t\tR=R<b?R:b;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\nconst double EPS=1e-10;\ntypedef struct P{double x,y;int o,l;}P;\nint C,N,XS,YS,XT,YT,O,L,XA,YA,XB,YB,i,b,tx,ty,c,T,R;\ndouble r,s;\nP ST[105];\nint cmp(const void* a,const void* b)\n{\n\tP* A=(P*)a;\n\tP* B=(P*)b;\n\tif(abs(A->x-B->x)<EPS)\n\t{\n\t\tif(A->y<B->y)return -1;\n\t\tif(A->y>B->y)return 1;\n\t}\n\tif(A->x<B->x)return -1;\n\tif(A->x>B->x)return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tfor(scanf(\"%d\",&C);C--;)\n\t{\n\t\tmemset(ST,0,sizeof(ST));\n\t\tscanf(\"%d%d%d%d%d\",&XA,&YA,&XB,&YB,&N);\n\t\tfor(i=c=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d%d%d\",&XS,&YS,&XT,&YT,&O,&L);\n\t\t\ttx=XS-XA;\n\t\t\tty=YS-YA;\n\t\t\tb=(XB-XA)*(YT-YS)-(YB-YA)*(XT-XS);\n\t\t\tif(b==0)continue;\n\t\t\tr=(double)((YT-YS)*tx-(XT-XS)*ty)/b;\n\t\t\ts=(double)((YB-YA)*tx-(XB-XA)*ty)/b;\n\t\t\tif(r<EPS||s<EPS||1.0-r<EPS||1.0-s<EPS)continue;\n\t\t\tif(r>EPS&&1.0-r>EPS){P ins={XA+r*(XB-XA),YA+r*(YB-YA),O,L};ST[c++]=ins;}\n\t\t\telse{P ins={XS+s*(XT-XS),YS+s*(YT-YS),O,L};ST[c++]=ins;}\n\t\t}\n\t\tqsort(ST,c,sizeof(P),cmp);\n\t\tR=999;\n\t\tfor(L=0;L<2;L++)\n\t\t{\n\t\t\tfor(i=b=0;i<c;i++)\n\t\t\t{\n\t\t\t\tif(ST[i].o==1&&ST[i].l!=L){b++;L^=1;}\n\t\t\t\tif(ST[i].o!=1&&ST[i].l==L){b++;L^=1;}\n\t\t\t}\n\t\t\tR=R<b?R:b;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n\tdouble x,y;\n} xy_t;\n\ndouble eq(double a, double b) {\n\treturn fabs(a-b)<EPS;\n}\n\ndouble lt(double a, double b) {\n\treturn a+EPS<b;\n}\n\ndouble leq(double a, double b) {\n\treturn a<b+EPS;\n}\n\ndouble gt(double a, double b) {\n\treturn a>b+EPS;\n}\n\ndouble geq(double a, double b) {\n\treturn a+EPS>b;\n}\n\nint inrange(double r1, double r2, double c) {\n\tif(lt(r1,r2)) {\n\t\treturn leq(r1,c) && leq(c,r2);\n\t} else if(gt(r1,r2)) {\n\t\treturn leq(r2,c) && leq(c,r1);\n\t} else {\n\t\treturn eq(r1,c) && eq(r2,c);\n\t}\n}\n\nxy_t kouten(int *e, xy_t s1, xy_t t1, xy_t s2, xy_t t2) {\n\t/* (x,y) = (x1,y1)+t(x2-x1,y2-y1)\n\t * t = (x-x1)/(x2-x1) = (y-y1)/(y2-y1)\n\t * (x-x1)*(y2-y1) = (y-y1)*(x2-x1)\n\t * (y2-y1)*x + (x1-x2)*y = x1*y2 - x2*y1\n\t */\n\txy_t ret={0,0};\n\tdouble a = t1.y-s1.y;\n\tdouble b = s1.x-t1.x;\n\tdouble c = t2.y-s2.y;\n\tdouble d = s2.x-t2.x;\n\tdouble v1 = s1.x*t1.y - t1.x*s1.y;\n\tdouble v2 = s2.x*t2.y - t2.x*s2.y;\n\tdouble delta = a*d-b*c;\n\tif(eq(delta,0)) {\n\t\tif(e!=NULL)*e=0;\n\t\treturn ret;\n\t}\n\tret.x=(d*v1-b*v2)/delta;\n\tret.y=(-c*v1+a*v2)/delta;\n\tif(e!=NULL) {\n\t\t*e=inrange(s1.x,t1.x,ret.x) && inrange(s1.y,t1.y,ret.y) &&\n\t\t\tinrange(s2.x,t2.x,ret.x) && inrange(s2.y,t2.y,ret.y);\n\t}\n\treturn ret;\n}\n\ntypedef struct {\n\txy_t zahyo;\n\tint is_kouka;\n} kouten_t;\n\nint cmp_x(const void *x, const void *y) {\n\tdouble a = ((const kouten_t*)x)->zahyo.x;\n\tdouble b = ((const kouten_t*)y)->zahyo.x;\n\tif(gt(a,b))return 1;\n\tif(lt(a,b))return -1;\n\treturn 0;\n}\n\nint cmp_y(const void *x, const void *y) {\n\tdouble a = ((const kouten_t*)x)->zahyo.y;\n\tdouble b = ((const kouten_t*)y)->zahyo.y;\n\tif(gt(a,b))return 1;\n\tif(lt(a,b))return -1;\n\treturn 0;\n}\n\nint solve(void) {\n\txy_t a,b;\n\tint n;\n\tint i;\n\tkouten_t kouten_list[110];\n\tint kouten_num=0;\n\tint ans;\n\tif(scanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y)!=4)return 0;\n\tif(scanf(\"%d\",&n)!=1)return 0;\n\tfor(i=0;i<n;i++) {\n\t\txy_t s,t;\n\t\tint o,l;\n\t\txy_t k;\n\t\tint e=0;\n\t\tif(scanf(\"%lf%lf%lf%lf%d%d\",&s.x,&s.y,&t.x,&t.y,&o,&l)!=6)return 0;\n\t\tk=kouten(&e,a,b,s,t);\n\t\tif(e) {\n\t\t\tkouten_list[kouten_num].zahyo=k;\n\t\t\tkouten_list[kouten_num].is_kouka = (1-o)^l;\n\t\t\tkouten_num++;\n\t\t}\n\t}\n\tqsort(kouten_list,kouten_num,sizeof(kouten_list[0]),\n\t\t  eq(kouten_list[0].zahyo.x,kouten_list[kouten_num-1].zahyo.x)?cmp_y:cmp_x);\n\tans=0;\n\tfor(i=1;i<kouten_num;i++) {\n\t\tif(kouten_list[i].is_kouka!=kouten_list[i-1].is_kouka)ans++;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 1;\n}\n\nint main(void) {\n\tint n,i;\n\tif(scanf(\"%d\",&n)!=1)return 1;\n\tfor(i=0;i<n;i++) {\n\t\tif(!solve())return 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2003: Railroad Conflict\n// 2017.12.11 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double d; int x1, y1, x2, y2; char flg, cross; } T;\nT tbl[101];\nint xa, ya, xb, yb;\nchar buf[40], *p;\n\nint getint()\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = 10*n + (*p++ & 0xf);\n\t\tp++; return -n;\n\t}\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++; return n;\n}\n\nint segCross(double *xx, double *yy, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)\n{\n\tlong long t1, t2, t3, t4;\n\tdouble bo, ua;\n\n\tt1 = (long long)(y1-y3)*(x3-x4)-(long long)(x1-x3)*(y3-y4);\n\tt2 = (long long)(y2-y3)*(x3-x4)-(long long)(x2-x3)*(y3-y4);\n\tt3 = (long long)(y3-y1)*(x1-x2)-(long long)(x3-x1)*(y1-y2);\n\tt4 = (long long)(y4-y1)*(x1-x2)-(long long)(x4-x1)*(y1-y2);\n\tif ((t1 < 0 && t2 > 0 || t1 > 0 && t2 < 0) && (t3 < 0 && t4 > 0 || t3 > 0 && t4 < 0)) {\n\t\tbo = (double)((long long)(y4-y3)*(x2-x1)-(long long)(x4-x3)*(y2-y1));\n\t\tua = (double)((long long)(x4-x3)*(y1-y3)-(long long)(y4-y3)*(x1-x3));\n\t\t*xx = x1 + ua/bo * (x2-x1);\n\t\t*yy = y1 + ua/bo * (y2-y1);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint cmp(T *a, T *b)\n{\n\tif (a->cross - b->cross) return b->cross - a->cross;\n\tif (a->d < b->d) return -1;\n\treturn 1;\n}\n\nint main()\n{\n\tint cno, n, i, now, ans;\n\tT *tp;\n\tdouble x, y;\n\n\tfgets(p=buf, 10, stdin), cno = getint();\n\twhile (cno--) {\n\t\tfgets(p=buf, 40, stdin);\n\t\txa = getint(), ya = getint();\n\t\txb = getint(), yb = getint();\n\t\tfgets(p=buf, 10, stdin), n = getint();\n\t\ti = n; for (tp = tbl; i--; tp++) {\n\t\t\tfgets(p=buf, 40, stdin);\n\t\t\ttp->x1 = getint(), tp->y1 = getint();\n\t\t\ttp->x2 = getint(), tp->y2 = getint();\n\t\t\ttp->flg = (*p & 1) ^ (*(p+2) & 1);\n\t\t}\n\n\t\ti = n; for (tp = tbl; i--; tp++) {\n\t\t\tif (segCross(&x, &y, xa, ya, xb, yb, tp->x1, tp->y1, tp->x2, tp->y2)) {\n\t\t\t\ttp->d = hypot(x-xa, y-ya), tp->cross = 1;\n\t\t\t} else tp->cross = 0;\n\t\t}\n\t\tqsort(tbl, n, sizeof(T), cmp);\n\t\tans = 0, now = tbl[0].flg;\n\t\tfor (tp = tbl; tp->cross && n--; tp++) {\n\t\t\tif (tp->flg != now) ans++, now = !now;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\nconst double EPS=1e-10;\ntypedef struct P{double x,y;int o,l;}P;\nint C,N,XS,YS,XT,YT,O,L,XA,YA,XB,YB,i,b,tx,ty,c,T,R;\ndouble r,s;\nP ST[105];\nint cmp(const void* a,const void* b)\n{\n\tP* A=(P*)a;\n\tP* B=(P*)b;\n\tif(abs(A->x-B->x)<EPS)\n\t{\n\t\tif(A->y<B->y)return -1;\n\t\tif(A->y>B->y)return 1;\n\t}\n\tif(A->x<B->x)return -1;\n\tif(A->x>B->x)return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tfor(scanf(\"%d\",&C);C--;)\n\t{\n\t\tmemset(ST,0,sizeof(ST));\n\t\tscanf(\"%d%d%d%d%d\",&XA,&YA,&XB,&YB,&N);\n\t\tfor(i=c=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d%d%d\",&XS,&YS,&XT,&YT,&O,&L);\n\t\t\ttx=XS-XA;\n\t\t\tty=YS-YA;\n\t\t\tb=(XB-XA)*(YT-YS)-(YB-YA)*(XT-XS);\n\t\t\tif(b==0)continue;\n\t\t\tr=(double)((YT-YS)*tx-(XT-XS)*ty)/b;\n\t\t\ts=(double)((YB-YA)*tx-(XB-XA)*ty)/b;\n\t\t\tif(r<EPS||s<EPS||1.0-r<EPS||1.0-s<EPS)continue;\n\t\t\tif(r>EPS&&1.0-r>EPS){P ins={XA+r*(XB-XA),YA+r*(YB-YA),O,L};ST[c++]=ins;}\n\t\t\telse{P ins={XS+s*(XT-XS),YS+s*(YT-YS),O,L};ST[c++]=ins;}\n\t\t}\n\t\tqsort(ST,c,sizeof(P),cmp);\n\t\tR=999;\n\t\tfor(L=0;L<2;L++)\n\t\t{\n\t\t\tfor(T=L,i=b=0;i<c;i++)\n\t\t\t{\n\t\t\t\tif(ST[i].o==1&&ST[i].l!=T){b++;T^=1;}\n\t\t\t\tif(ST[i].o!=1&&ST[i].l==T){b++;T^=1;}\n\t\t\t}\n\t\t\tR=R<b?R:b;\n\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define eps 1e-10\n\ntypedef struct line{\n\tll x1,y1;\n\tll x2,y2;\n}L;\n\nint sgn(ll x){return x<0?-1:x>0;}\n\nint iscloss(L s,L t){\n\t//点(p,q)が直線f(x,y)=ax+by+c=0のどっち側にあるかはf(p,q)を見ればよい\n\t//点(x1,y1),(x2,y2)を結ぶ直線の式は(y2-y1)*(x-x1)+(x2-x1)*(y1-y)=0\n\tll t1=(s.y2-s.y1)*(t.x1-s.x1)+(s.x2-s.x1)*(s.y1-t.y1);\n\tll t2=(s.y2-s.y1)*(t.x2-s.x1)+(s.x2-s.x1)*(s.y1-t.y2);\n\tll t3=(t.y2-t.y1)*(s.x1-t.x1)+(t.x2-t.x1)*(t.y1-s.y1);\n\tll t4=(t.y2-t.y1)*(s.x2-t.x1)+(t.x2-t.x1)*(t.y1-s.y2);\n\t//2線分が同一直線上になく、かつ、共有点があればtrue\n\t//（同一直線上にある2線分が共有点を持ってもfalseが返るので注意）\n\treturn sgn(t1)!=sgn(t2) && sgn(t3)!=sgn(t4);\n}\n\ndouble calcx,calcy;\nvoid calc(L s,L t){\n\t//交点は、線分tを|t1|:|t2|に内分する点\n\tll t1=(s.y2-s.y1)*(t.x1-s.x1)+(s.x2-s.x1)*(s.y1-t.y1);\n\tll t2=(s.y2-s.y1)*(t.x2-s.x1)+(s.x2-s.x1)*(s.y1-t.y2);\n\tt1=llabs(t1);\n\tt2=llabs(t2);\n\tcalcx=t.x1+(double)(t.x2-t.x1)*t1/(t1+t2);\n\tcalcy=t.y1+(double)(t.y2-t.y1)*t1/(t1+t2);\n}\n\nL s,t;\ndouble x[200],y[200];\nint st[200];\nint idx[200];\n\nint main(){\n\tint q;\n\tscanf(\"%d\",&q);\n\t\n\twhile(q--){\n\t\tscanf(\"%lld%lld%lld%lld\",&s.x1,&s.y1,&s.x2,&s.y2);\n\t\tint cnt=0;\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\trep(i,1,n+1){\n\t\t\tint a,b;\n\t\t\tscanf(\"%lld%lld%lld%lld%lld%lld\",&t.x1,&t.y1,&t.x2,&t.y2,&a,&b);\n\t\t\tif(iscloss(s,t)){\n\t\t\t\tcalc(s,t);\n\t\t\t\tx[cnt]=calcx;\n\t\t\t\ty[cnt]=calcy;\n\t\t\t\tst[cnt]=a^b;\n\t\t\t\tidx[cnt]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//ソート\n\t\trep(i,0,cnt)rep(j,0,cnt-1){\n\t\t\tif(x[idx[j]]>x[idx[j+1]]+eps || (fabs(x[idx[j]]-x[idx[j+1]])<eps&&y[idx[j]]>y[idx[j+1]]+eps)){\n\t\t\t\tint temp=idx[j];\n\t\t\t\tidx[j]=idx[j+1];\n\t\t\t\tidx[j+1]=temp;\n\t\t\t}\n\t\t}\n\t\tint ans=0,crr=st[idx[0]];\n\t\trep(i,1,cnt)if(st[idx[i-1]]!=st[idx[i]])ans++;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.lang.Math.*\n\nfun main(args:Array<String>):Unit{\n    println(args)\n    repeat(readLine()!!.toInt()){\n        val (xa, ya, xb, yb) = readLine()!!.split(' ').map(String::toInt)\n        val newLine = Line(Point(xa, ya), Point(xb, yb))\n        val oldLine = Array(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ').map(String::toInt)\n            val (xs, ys, xt, yt) = arg.take(4)\n            val (o, l) = arg.takeLast(2)\n            RailWay(Line(Point(xs, ys), Point(xt, yt)),  o, l)\n        }.mapNotNull{\n            val p = it.line.crossPoint(newLine)\n            when(p){\n                null -> null\n                else -> Pair(choiceLineCondition(it.owner, it.condition), p)\n            }\n        }.distinctBy { it.second }.sortedBy { it.second }.toTypedArray()\n        println((1 until oldLine.size).count{oldLine[it].first != oldLine[it - 1].first})\n    }\n}\nfun choiceLineCondition(owner:Owner, condition: LineCondition):LineCondition {\n    return when(owner){\n        Owner.Ours -> condition\n        else -> when(condition){\n            LineCondition.Subway -> LineCondition.Highway\n            LineCondition.Highway -> LineCondition.Subway\n        }\n    }\n}\nclass RailWay(val line:Line, val owner: Owner, val condition:LineCondition){\n    constructor(line:Line, owner:Int, condition:Int):this(line, when(owner){\n        1 -> Owner.Ours\n        else -> Owner.Competitor\n    }, when(condition){\n        1 -> LineCondition.Highway\n        else -> LineCondition.Subway\n    })\n}\nenum class LineCondition{\n    Subway, Highway\n}\nenum class Owner{\n    Ours, Competitor\n}\ndata class Point(val x:Rational, val y:Rational):Comparable<Point> {\n    constructor(x:Int, y:Int):this(Rational(x), Rational(y))\n    override fun compareTo(other: Point): Int {\n        return if (x == other.x) y.compareTo(other.y) else x.compareTo(other.x)\n    }\n    fun equals(other: Point): Boolean {\n        return x == other.x && y == other.y\n    }\n}\nclass Rational private constructor(private val numerator:Long, private val denominator:Long):Comparable<Rational>{\n    override fun compareTo(other: Rational): Int {\n        return (numerator * other.denominator).compareTo(other.numerator * denominator)\n    }\n    fun equals(other: Rational): Boolean {\n        return numerator == other.numerator && denominator == other.denominator\n    }\n    fun equals(other:Int):Boolean {\n        return numerator == other.toLong() && denominator == 1L\n    }\n    companion object {\n        fun Rational.compareTo(other:Int):Int {\n            return numerator.compareTo(other * denominator)\n        }\n        fun Int.compareTo(other:Rational):Int {\n            return (this * other.denominator).compareTo(other.denominator)\n        }\n        operator fun invoke(integer:Int):Rational{\n            return Rational(integer.toLong(), 1)\n        }\n        operator fun invoke(numerator:Long, denominator:Long):Rational{\n            val n = abs(numerator)\n            val d = abs(denominator)\n            val g = gcd(n, d)\n            return Rational(sign(numerator) * sign(denominator) * n / g, d / g)\n        }\n        private tailrec fun gcd(a:Long, b:Long):Long {\n            return when(b){\n                0L -> a\n                else -> gcd(b, a % b)\n            }\n        }\n        private fun sign(value:Long):Int = value.compareTo(0)\n    }\n    operator fun plus(other:Rational):Rational = Rational.invoke(numerator * other.denominator + other.numerator * denominator, denominator * other.denominator)\n    operator fun minus(other:Rational):Rational = Rational.invoke(numerator * other.denominator - other.numerator * denominator, denominator * other.denominator)\n    operator fun times(other:Rational):Rational = Rational.invoke(numerator * other.numerator, denominator * other.denominator)\n    operator fun div(other:Rational):Rational = Rational.invoke(numerator * other.denominator, other.numerator * denominator)\n}\nclass Line private constructor(private val from:Point, private val to:Point) {//ay = bx + c\n    companion object {\n        operator fun invoke(from:Point, to:Point):Line {\n            return if (from < to){\n                Line(from, to)\n            }else{\n                Line(to, from)\n            }\n        }\n    }\n    private val a = from.x - to.x\n    private val b = from.y - to.y\n    private val c = (from.x - to.x) * to.y - (from.y - to.y) * to.x\n    fun crossPoint(other: Line): Point? {\n        if (isParallel(other)) return null\n        val x = (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        val y = (b * other.c - other.b * c) / (other.a * b - a * other.b)\n        val point = Point(x, y)\n        return if (isOnLine(point) && other.isOnLine(point)) point else null\n    }\n    private fun isParallel(other:Line):Boolean {\n        return a * other.b == b * other.a\n    }\n    private fun isOnLine(point:Point):Boolean {\n        val (minx, maxx) = listOf(from.x, to.x).sorted()\n        val (miny, maxy) = listOf(from.y, to.y).sorted()\n        return point.x in minx .. maxx && point.y in miny .. maxy\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    repeat(readLine()!!.toInt()){\n        val (xa, ya, xb, yb) = readLine()!!.split(' ').map(String::toInt)\n        val newLine = Line(Point(xa, ya), Point(xb, yb))\n        val oldLine = Array(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ').map(String::toInt)\n            val (xs, ys, xt, yt) = arg.take(4)\n            val (o, l) = arg.takeLast(2)\n            RailWay(Line(Point(xs, ys), Point(xt, yt)),  when(l){\n                1 -> LineCondition.Highway\n                else -> LineCondition.Subway\n            }, when(o){\n                1 -> Owner.Ours\n                else -> Owner.Competitor\n            })\n        }.map{\n            val point = it.line.crossPoint(newLine)\n            when(point) {\n                null -> null\n                else -> when (it.owner) {\n                    Owner.Ours -> when (it.condtion) {\n                        LineCondition.Subway -> Pair(LineCondition.Subway, point)\n                        else -> Pair(LineCondition.Highway, point)\n                    }\n                    else -> when (it.condtion) {\n                        LineCondition.Highway -> Pair(LineCondition.Subway, point)\n                        else -> Pair(LineCondition.Highway, point)\n                    }\n                }\n            }\n        }.filterNotNull().sortedBy{it.second}\n        var current = oldLine.first().first\n        var count = 0\n        oldLine.forEach {\n            if (it.first != current){\n                current = it.first\n                ++count\n            }\n        }\n        println(count)\n    }\n\n}\nclass RailWay(val line:Line, val condtion:LineCondition, val owner: Owner)\nenum class LineCondition{\n    Subway, Highway\n}\nenum class Owner{\n    Ours, Competitor\n}\ndata class Point(val x:Int, val y:Int):Comparable<Point> {\n    override fun compareTo(other: Point): Int {\n        return if (x == other.x) y.compareTo(other.y) else x.compareTo(other.x)\n    }\n}\n\nclass Line(private val from:Point, private val to:Point) {//ay = bx + c\n    private val a:Int = from.x - to.x\n    private val b:Int = from.y - to.y\n    private val c:Int = (from.x - to.x) * to.y - (from.y - to.y) * to.x\n    fun crossPoint(other: Line): Point? {\n        if (isParallel(other)) return null\n        // b * other.b x = other.b * a y - c * other.b = b * other.a y - other.c * b\n        // (a * other.b - b * other.a) y = (c * other.b - b * other.c)\n        // a * other.a y = other.a * b x + other.a * c = a * other.b x + a * other.c\n        // (b * other.a - a * other.b) x = (a * other.c - c * other.a)\n        // (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        // (other.c * b - c * other.b) / (other.a * b - a * other.b)\n        val x = (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        val y = (b * other.c - other.b * c) / (other.a * b - a * other.b)\n        return if (x in (from.x .. to.x) || x in (to.x .. from.x)) Point(x, y) else null\n    }\n    private fun isParallel(other:Line):Boolean {\n        return a * other.b == b * other.a\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "\nfun main(args:Array<String>):Unit{\n    repeat(readLine()!!.toInt()){\n        val (xa, ya, xb, yb) = readLine()!!.split(' ').map(String::toDouble)\n        val newLine = Line(Point(xa, ya), Point(xb, yb))\n        val oldLine = Array(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ')\n            val (xs, ys, xt, yt) = arg.take(4).map(String::toDouble)\n            val (o, l) = arg.takeLast(2).map(String::toInt)\n            RailWay(Line(Point(xs, ys), Point(xt, yt)),  when(l){\n                1 -> LineCondition.Highway\n                else -> LineCondition.Subway\n            }, when(o){\n                1 -> Owner.Ours\n                else -> Owner.Competitor\n            })\n        }.mapNotNull{\n            val point = it.line.crossPoint(newLine)\n            when(point) {\n                null -> null\n                else -> when (it.owner) {\n                    Owner.Ours -> when (it.condition) {\n                        LineCondition.Subway -> Pair(LineCondition.Subway, point)\n                        else -> Pair(LineCondition.Highway, point)\n                    }\n                    else -> when (it.condition) {\n                        LineCondition.Highway -> Pair(LineCondition.Subway, point)\n                        else -> Pair(LineCondition.Highway, point)\n                    }\n                }\n            }\n        }.sortedBy{it.second}\n        var current = oldLine.firstOrNull()?.first\n        var count = 0\n        oldLine.forEach {\n            if (it.first != current){\n                current = it.first\n                ++count\n            }\n        }\n        println(count)\n    }\n\n}\nclass RailWay(val line:Line, val condition:LineCondition, val owner: Owner)\nenum class LineCondition{\n    Subway, Highway\n}\nenum class Owner{\n    Ours, Competitor\n}\ndata class Point(val x:Double, val y:Double):Comparable<Point> {\n    override fun compareTo(other: Point): Int {\n        return if (x == other.x) y.compareTo(other.y) else x.compareTo(other.x)\n    }\n}\n\nclass Line private constructor(private val from:Point, private val to:Point) {//ay = bx + c\n    companion object {\n        operator fun invoke(from:Point, to:Point):Line {\n            return if (from < to){\n                Line(from, to)\n            }else{\n                Line(to, from)\n            }\n        }\n    }\n    private val a = from.x - to.x\n    private val b = from.y - to.y\n    private val c = (from.x - to.x) * to.y - (from.y - to.y) * to.x\n    fun crossPoint(other: Line): Point? {\n        if (isParallel(other)) return null\n        // b * other.b x = other.b * a y - c * other.b = b * other.a y - other.c * b\n        // (a * other.b - b * other.a) y = (c * other.b - b * other.c)\n        // a * other.a y = other.a * b x + other.a * c = a * other.b x + a * other.c\n        // (b * other.a - a * other.b) x = (a * other.c - c * other.a)\n        // (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        // (other.c * b - c * other.b) / (other.a * b - a * other.b)\n        val x = (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        val y = (b * other.c - other.b * c) / (other.a * b - a * other.b)\n        val point = Point(x, y)\n        return if (isOnLine(point) && other.isOnLine(point)) point else null\n    }\n    private fun isParallel(other:Line):Boolean {\n        return a * other.b == b * other.a\n    }\n    private fun isOnLine(point:Point):Boolean {\n        val (minx, maxx) = listOf(from.x, to.x).sorted()\n        val (miny, maxy) = listOf(from.y, to.y).sorted()\n        return point.x in minx .. maxx && point.y in miny .. maxy\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>):Unit {\n    repeat(readLine()!!.toInt()){\n        val (xa, ya, xb, yb) = readLine()!!.split(' ').map(String::toInt)\n        val newLine = Line(Point(xa, ya), Point(xb, yb))\n        val oldLine = Array(readLine()!!.toInt()){\n            val arg = readLine()!!.split(' ').map(String::toInt)\n            val (xs, ys, xt, yt) = arg.take(4)\n            val (o, l) = arg.takeLast(2)\n            RailWay(Line(Point(xs, ys), Point(xt, yt)),  when(l){\n                1 -> LineCondition.Highway\n                else -> LineCondition.Subway\n            }, when(o){\n                1 -> Owner.Ours\n                else -> Owner.Competitor\n            })\n        }.mapNotNull{\n            val point = it.line.crossPoint(newLine)\n            when(point) {\n                null -> null\n                else -> when (it.owner) {\n                    Owner.Ours -> when (it.condtion) {\n                        LineCondition.Subway -> Pair(LineCondition.Subway, point)\n                        else -> Pair(LineCondition.Highway, point)\n                    }\n                    else -> when (it.condtion) {\n                        LineCondition.Highway -> Pair(LineCondition.Subway, point)\n                        else -> Pair(LineCondition.Highway, point)\n                    }\n                }\n            }\n        }.sortedBy{it.second}\n        var current = oldLine.firstOrNull()?.first\n        var count = 0\n        oldLine.forEach {\n            if (it.first != current){\n                current = it.first\n                ++count\n            }\n        }\n        println(count)\n    }\n\n}\nclass RailWay(val line:Line, val condtion:LineCondition, val owner: Owner)\nenum class LineCondition{\n    Subway, Highway\n}\nenum class Owner{\n    Ours, Competitor\n}\ndata class Point(val x:Int, val y:Int):Comparable<Point> {\n    override fun compareTo(other: Point): Int {\n        return if (x == other.x) y.compareTo(other.y) else x.compareTo(other.x)\n    }\n}\n\nclass Line(private val from:Point, private val to:Point) {//ay = bx + c\n    private val a:Int = from.x - to.x\n    private val b:Int = from.y - to.y\n    private val c:Int = (from.x - to.x) * to.y - (from.y - to.y) * to.x\n    fun crossPoint(other: Line): Point? {\n        if (isParallel(other)) return null\n        // b * other.b x = other.b * a y - c * other.b = b * other.a y - other.c * b\n        // (a * other.b - b * other.a) y = (c * other.b - b * other.c)\n        // a * other.a y = other.a * b x + other.a * c = a * other.b x + a * other.c\n        // (b * other.a - a * other.b) x = (a * other.c - c * other.a)\n        // (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        // (other.c * b - c * other.b) / (other.a * b - a * other.b)\n        val x = (a * other.c - other.a * c) / (other.a * b - a * other.b)\n        val y = (b * other.c - other.b * c) / (other.a * b - a * other.b)\n        return if (x in (from.x .. to.x) || x in (to.x .. from.x)) Point(x, y) else null\n    }\n    private fun isParallel(other:Line):Boolean {\n        return a * other.b == b * other.a\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    int T = ni();\n    for (int t = 0; t < T; ++t) {\n      int xa = ni();\n      int ya = ni();\n      int xb = ni();\n      int yb = ni();\n      int n = ni();\n      ArrayList<Data> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        int xs = ni();\n        int ys = ni();\n        int xt = ni();\n        int yt = ni();\n        int o = ni();\n        int l = ni();\n        list.add(new Data(xs, ys, xt, yt, o, l));\n      }\n      LineSegment atom = new LineSegment(xa, ya, xb, yb);\n      ArrayList<Data> target = new ArrayList<>();\n      for (Data d : list) {\n        if (d.cal(atom, xa, ya)) {\n          target.add(d);\n        }\n      }\n      target.sort(Comparator.comparingDouble((a) -> a.dist));\n      if (target.size() == 0) {\n        System.out.println(0);\n      } else {\n        Data start = target.get(0);\n        boolean now;\n        if (start.o == 1) {\n          now = start.l == 1;\n        } else {\n          now = start.l == 0;\n        }\n        int cnt = 0;\n        for (Data d : target) {\n          boolean next;\n          if (d.o == 1) {\n            next = d.l == 1;\n          } else {\n            next = d.l == 0;\n          }\n          if (now != next) {\n            ++cnt;\n          }\n          now = next;\n        }\n        System.out.println(cnt);\n      }\n    }\n  }\n\n  class Data {\n    LineSegment s;\n    int o;\n    int l;\n    Point2D point;\n    double dist;\n\n    Data(int xs, int ys, int xt, int yt, int o, int l) {\n      this.s = new LineSegment(xs, ys, xt, yt);\n      this.o = o;\n      this.l = l;\n    }\n\n    boolean cal(LineSegment r, int xa, int ya) {\n      point = s.getIntersectionPoint(r);\n      if (point == null) {\n        return false;\n      }\n      Point2D q = new Point2D.Double(xa, ya);\n      dist = point.distance(q);\n      return true;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tdouble EPS = 1e-9;\n\t\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\t\tboolean me, up;\n\t\tpublic P(double x, double y, boolean me, boolean up) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.me = me;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int) Math.signum(x-o.x);\n\t\t\telse return (int) Math.signum(y-o.y);\n\t\t}\n\t}\n\t\n\tboolean cross(P a, P b, P s, P t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(t, s, a)*ex(t, s, b)>0)return false;\n\t\treturn ex(s, t, a)*ex(s, t, b)<EPS;\n\t}\n\tdouble ex(P s, P t, P r){\n\t\tdouble x1 = t.x-s.x, y1 = t.y-s.y, x2 = r.x-s.x, y2 = r.y-s.y;\n\t\treturn x1*y2-x2*y1;\n\t}\n\tdouble dist(P a, P b, P p){\n\t\tdouble x1 = b.x-a.x, y1 = b.y-a.y, x2 = p.x-a.x, y2 = p.y-a.y;\n\t\tif(x1*x2+y1*y2<EPS)return Math.hypot(x2, y2);\n\t\tx1 = a.x-b.x; y1 = a.y-b.y; x2 = p.x-b.x; y2 = p.y-b.y;\n\t\tif(x1*x2+y1*y2<EPS)return Math.hypot(x2, y2);\n\t\treturn Math.abs((x1*y2-x2*y1))/Math.hypot(x1, y1);\n\t}\n\tP cp(P a, P b, P s, P t, boolean m, boolean u){\n\t\tdouble ds = dist(a, b, s), dt = dist(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble dx = t.x-s.x, dy = t.y-s.y;\n\t\treturn new P(s.x+k*dx, s.y+k*dy, m, u);\n\t}\n\tboolean on(P a, P b, P p){\n\t\tif(Math.abs(a.x-b.x)<EPS)return Math.min(a.y, b.y)<=p.y&&p.y<=Math.max(a.y, b.y);\n\t\tdouble alpha = (b.y-a.y)/(b.x-a.x);\n\t\tdouble beta = a.y-alpha*a.x;\n\t\tif(Math.abs(p.y-(alpha*p.x+beta))>EPS)return false;\n\t\treturn Math.min(a.x, b.x)<=p.x&&p.x<=Math.max(a.x, b.x);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tP A = new P(sc.nextDouble(), sc.nextDouble(), true, true), B = new P(sc.nextDouble(), sc.nextDouble(), true, true);\n\t\t\tint n = sc.nextInt();\n\t\t\tP[][] line = new P[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\tboolean m = sc.nextInt()==1, u = sc.nextInt()==1;\n\t\t\t\tline[i][0] = new P(x1, y1, m, u);\n\t\t\t\tline[i][1] = new P(x2, y2, m, u);\n\t\t\t}\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tP s = line[i][0], t = line[i][1];\n\t\t\t\tdouble x1 = B.x-A.x, y1 = B.y-A.y, x2 = t.x-s.x, y2 = t.y-s.y;\n\t\t\t\tif(Math.abs(x1*y2-x2*y1)<EPS){\n\t\t\t\t\tif(on(A, B, s))l.add(s);\n\t\t\t\t\tif(on(A, B, t))l.add(t);\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\tif(cross(A, B, s, t))l.add(cp(A, B, s, t, s.me, s.up));\n\t\t\t}\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tif(l.size()>0){\n\t\t\t\tP h = l.get(0);\n//\t\t\t\tSystem.out.println(h.x+\" \"+h.y);\n\t\t\t\tboolean u = h.me?h.up:!h.up;\n\t\t\t\tfor(int i=1;i<l.size();i++){\n\t\t\t\t\th = l.get(i);\n//\t\t\t\t\tSystem.out.println(h.x+\" \"+h.y);\n\t\t\t\t\tif(h.me){\n\t\t\t\t\t\tif(h.up!=u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(h.up==u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\nclass Main{\n    int n;\n    int xa,ya,xb,yb;\n    int xs,ys,xt,yt,o,l;\n    Line2D a,b;\n    Intersection[] inter;\n\n    class Intersection{\n\tdouble dist;\n\tint owner,height;\n\tpublic Intersection(double dist,int owner,int height){\n\t    this.dist = dist;\n\t    this.owner = owner;\n\t    this.height = height;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tint T = sc.nextInt();\n\twhile(T--!=0){\n\t    xa = sc.nextInt(); ya = sc.nextInt();\n\t    xb = sc.nextInt(); yb = sc.nextInt();\n\t    n = sc.nextInt();\n\n\t    inter = new Intersection[n];\n\t    for(int i=0; i<n; i++){\n\t\txs = sc.nextInt(); ys = sc.nextInt();\n\t\txt = sc.nextInt(); yt = sc.nextInt();\n\t\to = sc.nextInt(); l = sc.nextInt();\n\t\ta = new Line2D.Double(xa,ya,xb,yb);\n\t\tb = new Line2D.Double(xs,ys,xt,yt);\n\t\tif(a.intersectsLine(b)){\n\t\t    double d = calcDist(xa,ya,xb,yb,xs,ys,xt,yt);\n\t\t    inter[i] = new Intersection(d,o,l);\n\t\t}else{\n\t\t    inter[i] = new Intersection(-1,-1,-1);\n\t\t}\n\t    }\n\n\t    for(int i=0; i<n; i++){\n\t\tdouble minD = inter[i].dist;\n\t\tint minIndex = i;\n\t\tfor(int j=i; j<n; j++){\n\t\t    if(inter[j].dist<minD){\n\t\t\tminD = inter[j].dist;\n\t\t\tminIndex = j;\n\t\t    }\n\t\t}\n\t\tIntersection tmp = inter[minIndex];\n\t\tinter[minIndex] = inter[i];\n\t\tinter[i] = tmp;\n\t    }\n\n\t    int ans = Math.min(countGate(0),countGate(1));\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    double calcDist(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tdouble bx = x4-x3;\n\tdouble by = y4-y3;\n\tdouble d1 = Math.abs(bx*(y1-y3)-by*(x1-x3));\n\tdouble d2 = Math.abs(bx*(y2-y3)-by*(x2-x3));\n\tdouble t = d1/(d1+d2);\t\n\tdouble x = x1+(x2-x1)*t;\n\tdouble y = y1+(y2-y1)*t;\n\n\treturn (xa-x)*(xa-x)+(ya-y)*(ya-y);\n    }\n\n    int countGate(int nowHeight){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t    if(inter[i].dist==-1)continue;\n\t    if(inter[i].owner==0){\n\t\tif(inter[i].height==nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }else{\n\t\tif(inter[i].height!=nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\treturn count;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tdouble EPS = 1e-9;\n\t\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\t\tboolean me, up;\n\t\tpublic P(double x, double y, boolean me, boolean up) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.me = me;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int) Math.signum(x-o.x);\n\t\t\telse return (int) Math.signum(y-o.y);\n\t\t}\n\t}\n\t\n\tboolean cross(P a, P b, P s, P t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(t, s, a)*ex(t, s, b)>0)return false;\n\t\treturn ex(s, t, a)*ex(s, t, b)<EPS;\n\t}\n\tdouble ex(P s, P t, P r){\n\t\tdouble x1 = t.x-s.x, y1 = t.y-s.y, x2 = r.x-s.x, y2 = r.y-s.y;\n\t\treturn x1*y2-x2*y1;\n\t}\n\tdouble dist(P a, P b, P p){\n\t\tdouble x1 = b.x-a.x, y1 = b.y-a.y, x2 = p.x-a.x, y2 = p.y-a.y;\n\t\treturn Math.abs((x1*y2-x2*y1))/Math.hypot(x1, y1);\n\t}\n\tP cp(P a, P b, P s, P t, boolean m, boolean u){\n\t\tdouble ds = dist(a, b, s), dt = dist(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble dx = t.x-s.x, dy = t.y-s.y;\n\t\treturn new P(s.x+k*dx, s.y+k*dy, m, u);\n\t}\n\tboolean on(P a, P b, P p){\n\t\tif(Math.abs(a.x-b.x)<EPS)return Math.min(a.y, b.y)<=p.y&&p.y<=Math.max(a.y, b.y);\n\t\tdouble alpha = (b.y-a.y)/(b.x-a.x);\n\t\tdouble beta = a.y-alpha*a.x;\n\t\tif(Math.abs(p.y-(alpha*p.x+beta))>EPS)return false;\n\t\treturn Math.min(a.x, b.x)<=p.x&&p.x<=Math.max(a.x, b.x);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tP A = new P(sc.nextDouble(), sc.nextDouble(), true, true), B = new P(sc.nextDouble(), sc.nextDouble(), true, true);\n\t\t\tint n = sc.nextInt();\n\t\t\tP[][] line = new P[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\tboolean m = sc.nextInt()==1, u = sc.nextInt()==1;\n\t\t\t\tline[i][0] = new P(x1, y1, m, u);\n\t\t\t\tline[i][1] = new P(x2, y2, m, u);\n\t\t\t}\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tP s = line[i][0], t = line[i][1];\n\t\t\t\tdouble x1 = B.x-A.x, y1 = B.y-A.y, x2 = t.x-s.x, y2 = t.y-s.y;\n\t\t\t\tif(Math.abs(x1*y2-x2*y1)<EPS){\n\t\t\t\t\tif(on(A, B, s))l.add(s);\n\t\t\t\t\tif(on(A, B, t))l.add(t);\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\tif(cross(A, B, s, t))l.add(cp(A, B, s, t, s.me, s.up));\n\t\t\t}\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tif(l.size()>0){\n\t\t\t\tP h = l.get(0);\n\t\t\t\tboolean u = h.me?h.up:!h.up;\n\t\t\t\tfor(int i=1;i<l.size();i++){\n\t\t\t\t\th = l.get(i);\n\t\t\t\t\tif(h.me){\n\t\t\t\t\t\tif(h.up!=u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(h.up==u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\tdouble EPS = 1e-12;\n\n\tclass Point implements Comparable<Point> {\n\t\tdouble x, y;\n\t\tint f;\n\n\t\tPoint(double x, double y, int f) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.f = f;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\tif (this.x != o.x) {\n\t\t\t\tdouble diff = this.x - o.x;\n\t\t\t\treturn diff > 0 ? 1 : diff < 0 ? -1 : 0;\n\t\t\t}\n\t\t\tif (this.y != o.y) {\n\t\t\t\tdouble diff = this.y - o.y;\n\t\t\t\treturn diff > 0 ? 1 : diff < 0 ? -1 : 0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdouble norm(double[] a) {\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\n\tdouble[] sub(double[] a, double[] b) {\n\t\treturn new double[] { a[0] - b[0], a[1] - b[1] };\n\t}\n\n\tdouble dot(double[] a, double[] b) {\n\t\treturn a[0] * b[0] + a[1] * b[1];\n\t}\n\n\tdouble cross(double[] a, double[] b) {\n\t\treturn a[0] * b[1] - a[1] * b[0];\n\t}\n\n\tint ccw(double[] a, double[] b, double[] c) {\n\t\tdouble[] d = sub(b, a), e = sub(c, a);\n\t\tif (cross(d, e) > 0)\n\t\t\treturn +1;\n\t\tif (cross(d, e) < 0)\n\t\t\treturn -1;\n\t\tif (dot(d, e) < 0)\n\t\t\treturn +2;\n\t\tif (norm(d) < norm(e))\n\t\t\treturn -2;\n\t\treturn 0;\n\t}\n\n\tboolean isIntersectSS(double[] a1, double[] a2, double[] b1, double[] b2) {\n\t\treturn ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 && ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n\t}\n\n\tboolean isIntersectLL(double[] a1, double[] a2, double[] b1, double[] b2) {\n\t\treturn !isParallel(a1, a2, b1, b2) || isSameLine(a1, a2, b1, b2);\n\t}\n\n\tboolean isSameLine(double[] a1, double[] a2, double[] b1, double[] b2) {\n\t\treturn abs(cross(sub(a1, a2), sub(a1, b1))) < EPS && abs(cross(sub(a1, a2), sub(a1, b2))) < EPS;\n\t}\n\n\tdouble abs(double a) {\n\t\treturn 0 < a ? a : -a;\n\t}\n\n\tboolean isParallel(double[] a1, double[] a2, double[] b1, double[] b2) {\n\t\treturn abs(cross(sub(a2, a1), sub(b2, b1))) < EPS;\n\t}\n\n\tdouble[] crosspoint(double[] a1, double[] a2, double[] b1, double[] b2) {\n\t\tif (!isIntersectLL(a1, a2, b1, b2))\n\t\t\treturn null;\n\t\tif (isSameLine(a1, a2, b1, b2))\n\t\t\treturn b1;\n\t\tdouble A = cross(sub(a2, a1), sub(b2, b1));\n\t\tdouble B = cross(sub(a2, a1), sub(a2, b1));\n\t\treturn new double[] { b1[0] + B / A * (b2[0] - b1[0]), b1[1] + B / A * (b2[1] - b1[1]) };\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\tint T = sc.nextInt();\n\t\twhile (T-- > 0) {\n\t\t\tdouble[][] l = new double[2][2];\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tl[i][j] = sc.nextDouble();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint n = sc.nextInt();\n\t\t\tdouble[][] s = new double[n][2];\n\t\t\tdouble[][] t = new double[n][2];\n\t\t\tint[] o = new int[n];\n\t\t\tint[] p = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\ts[i][j] = sc.nextDouble();\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tt[i][j] = sc.nextDouble();\n\t\t\t\t}\n\t\t\t\to[i] = sc.nextInt();\n\t\t\t\tp[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tList<Point> list = new LinkedList<Point>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tboolean f = isIntersectSS(l[0], l[1], s[i], t[i]);\n\t\t\t\tif (f) {\n\t\t\t\t\tdouble[] x = crosspoint(l[0], l[1], s[i], t[i]);\n\t\t\t\t\tlist.add(new Point(x[0], x[1], (o[i] + p[i]) % 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(list);\n\t\t\tPoint[] ans = list.toArray(new Point[0]);\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 1; i < ans.length; i++) {\n\t\t\t\tif (ans[i - 1].f != ans[i].f) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Point2D.Double a, b;\n\tstatic int n;\n\t\n\tstatic ArrayList<Point2D.Double> s, t;\n\tstatic int[] o, h;\n\t\n\tprivate static double cross(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn (a.x * b.y - a.y * b.x);\n\t}\n\t\n\tprivate static Point2D.Double add(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x + b.x, a.y + b.y);\n\t}\n\t\n\tprivate static Point2D.Double sub(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x - b.x, a.y - b.y);\n\t}\n\t\n\tprivate static Point2D.Double mul(Point2D.Double a, double t)\n\t{\n\t\treturn new Point2D.Double(a.x * t, a.y * t);\n\t}\n\t\n\tprivate static Boolean isCrossing(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\treturn (cross(sub(a2, a1), sub(b1, a1)) * cross(sub(a2, a1), sub(b2, a1)) < 1e-10) &&\n\t\t\t   (cross(sub(b2, b1), sub(a1, b1)) * cross(sub(b2, b1), sub(a2, b1)) < 1e-10);\n\t}\n\t\n\tprivate static Point2D.Double crosspoint(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\tPoint2D.Double b = sub(b2, b1);\n\t\tdouble d1 = Math.abs( cross(b, sub(a1, b1)) );\n\t\tdouble d2 = Math.abs( cross(b, sub(a2, b1)) );\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn add(a1, mul(sub(a2, a1), t));\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\tint allnum = sca.nextInt();\n\t\t\n\t\tfor(;allnum > 0;allnum--)\n\t\t\t{\n\t\t\t\n\t\t\ta = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\tb = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\n\t\t\tn = sca.nextInt();\n\t\t\t\n\t\t\tint i, j, k;\n\t\t\tArrayList<Point2D.Double> crossp = new ArrayList<Point2D.Double>();\n\t\t\tdouble[] dis;\n\t\t\t\n\t\t\ts = new ArrayList<Point2D.Double>();\n\t\t\tt = new ArrayList<Point2D.Double>();\n\t\t\to = new int[n];\n\t\t\th = new int[n];\n\t\t\tcrossp = new ArrayList<Point2D.Double>();\n\t\t\tdis = new double[n];\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tPoint2D.Double ss = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tPoint2D.Double tt = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tint oo = sca.nextInt();\n\t\t\t\tint hh = sca.nextInt();\n\t\t\t\t\n\t\t\t\tif(isCrossing(a, b, ss, tt))\n\t\t\t\t{\n\t\t\t\t\ts.add(ss);\n\t\t\t\t\tt.add(tt);\n\t\t\t\t\to[i] = oo;\n\t\t\t\t\th[i] = hh;\n\t\t\t\t\t\n\t\t\t\t\tPoint2D.Double cp = crosspoint(a, b, ss, tt);\n\t\t\t\t\tcrossp.add(cp);\n\t\t\t\t\t\n\t\t\t\t\tdouble dx = a.x - cp.x;\n\t\t\t\t\tdouble dy = a.y - cp.y;\n\t\t\t\t\tdis[i] = Math.sqrt(dx*dx + dy*dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti--;\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = n;i > 0;i--)\n\t\t\t{\n\t\t\t\tfor(j = 0;j < (i - 1);j++)\n\t\t\t\t{\n\t\t\t\t\tif(dis[j] > dis[j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble tmp;\n\t\t\t\t\t\ttmp = dis[j];    dis[j] = dis[j+1];    dis[j+1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint tmpi;\n\t\t\t\t\t\ttmpi = o[j];     o[j] = o[j+1];    o[j+1] = tmpi;\n\t\t\t\t\t\ttmpi = h[j];     h[j] = h[j+1];    h[j+1] = tmpi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint point = -1;\n\t\t\tint num = 0;\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tif(o[i] == 1)\n\t\t\t\t{\n\t\t\t\t\tif(h[i] == point) continue;\n\t\t\t\t\tnum++;\n\t\t\t\t\tpoint = h[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(h[i] != point) continue;\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tif(h[i] == 0)\n\t\t\t\t\t\tpoint = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpoint = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(num - 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Railroad Conflict\npublic class Main{\n\n\tfinal double EPS = 1e-10;\n\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tboolean intersectSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\treturn cross(sub(a2, a1), sub(b1, a1))*cross(sub(a2, a1), sub(b2, a1)) < EPS &&\n\t\tcross(sub(b2, b1), sub(a1, b1))*cross(sub(b2, b1), sub(a2, b1)) < EPS;\n\t}\n\tdouble[] crossPointSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\tif(!intersectSS(a1, a2, b1, b2))return null;\n\t\tdouble[] b = sub(b2, b1);\n\t\tdouble d1 = Math.abs(cross(b, sub(a1, b1)));\n\t\tdouble d2 = Math.abs(cross(b, sub(a2, b1)));\n\t\tdouble t = d1/(d1+d2);\n\t\tdouble[] a = sub(a2, a1);\n\t\treturn new double[]{a1[0]+a[0]*t, a1[1]+a[1]*t};\n\t}\n\n\tdouble[] A, B;\n\n\tclass P implements Comparable<P>{\n\t\tdouble[] p;\n\t\tboolean mine;\n\t\tboolean up;\n\t\tpublic P(double[] p, boolean mine, boolean up) {\n\t\t\tthis.p = p;\n\t\t\tthis.mine = mine;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tdouble[] s1 = sub(p, A);\n\t\t\tdouble[] s2 = sub(o.p, A);\n\t\t\tdouble d1 = s1[0]*s1[0]+s1[1]*s1[1];\n\t\t\tdouble d2 = s2[0]*s2[0]+s2[1]*s2[1];\n\t\t\treturn d1<d2?-1:d2<d1?1:0;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tA = new double[2];\n\t\t\tB = new double[2];\n\t\t\tA[0] = sc.nextDouble();\n\t\t\tA[1] = sc.nextDouble();\n\t\t\tB[0] = sc.nextDouble();\n\t\t\tB[1] = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\twhile(n--!=0){\n\t\t\t\tdouble[] s = new double[2];\n\t\t\t\tdouble[] t = new double[2];\n\t\t\t\ts[0] = sc.nextDouble();\n\t\t\t\ts[1] = sc.nextDouble();\n\t\t\t\tt[0] = sc.nextDouble();\n\t\t\t\tt[1] = sc.nextDouble();\n\t\t\t\tint o = sc.nextInt();\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tdouble[] r = crossPointSS(s, t, A, B);\n\t\t\t\tif(r==null)continue;\n\t\t\t\tl.add(new P(r, o==1, u==1));\n\t\t\t}\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tboolean f = true;\n\t\t\tboolean up = true;\n\t\t\tfor(P p:l){\n//\t\t\t\tSystem.out.println(\"P:\" + p.p[0]+\",\"+p.p[1]+\" MINE?\" + p.mine + \" UP?\"+p.up);\n\t\t\t\tif(f){\n\t\t\t\t\tf = false;\n\t\t\t\t\tif(p.mine)up = p.up;\n\t\t\t\t\telse up = !p.up;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(p.mine && p.up!=up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!p.mine && p.up==up){\n\t\t\t\t\t\tup = !p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Point2D.Double a, b;\n\tstatic int n;\n\t\n\tstatic ArrayList<Point2D.Double> s, t;\n\tstatic int[] o, h;\n\t\n\tprivate static double cross(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn (a.x * b.y - a.y * b.x);\n\t}\n\t\n\tprivate static Point2D.Double add(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x + b.x, a.y + b.y);\n\t}\n\t\n\tprivate static Point2D.Double sub(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x - b.x, a.y - b.y);\n\t}\n\t\n\tprivate static Point2D.Double mul(Point2D.Double a, double t)\n\t{\n\t\treturn new Point2D.Double(a.x * t, a.y * t);\n\t}\n\t\n\tprivate static Boolean isCrossing(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\treturn (cross(sub(a2, a1), sub(b1, a1)) * cross(sub(a2, a1), sub(b2, a1)) < 1e-10) &&\n\t\t\t   (cross(sub(b2, b1), sub(a1, b1)) * cross(sub(b2, b1), sub(a2, b1)) < 1e-10);\n\t}\n\t\n\tprivate static Point2D.Double crosspoint(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\tPoint2D.Double b = sub(b2, b1);\n\t\tdouble d1 = Math.abs( cross(b, sub(a1, b1)) );\n\t\tdouble d2 = Math.abs( cross(b, sub(a2, b1)) );\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn add(a1, mul(sub(a2, a1), t));\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\tint allnum = sca.nextInt();\n\t\t\n\t\tfor(;allnum > 0;allnum--)\n\t\t\t{\n\t\t\t\n\t\t\ta = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\tb = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\n\t\t\tn = sca.nextInt();\n\t\t\t\n\t\t\tint i, j, k;\n\t\t\tArrayList<Point2D.Double> crossp = new ArrayList<Point2D.Double>();\n\t\t\tdouble[] dis;\n\t\t\t\n\t\t\ts = new ArrayList<Point2D.Double>();\n\t\t\tt = new ArrayList<Point2D.Double>();\n\t\t\to = new int[n];\n\t\t\th = new int[n];\n\t\t\tcrossp = new ArrayList<Point2D.Double>();\n\t\t\tdis = new double[n];\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tPoint2D.Double ss = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tPoint2D.Double tt = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tint oo = sca.nextInt();\n\t\t\t\tint hh = sca.nextInt();\n\t\t\t\t\n\t\t\t\tif(isCrossing(a, b, ss, tt))\n\t\t\t\t{\n\t\t\t\t\ts.add(ss);\n\t\t\t\t\tt.add(tt);\n\t\t\t\t\to[i] = oo;\n\t\t\t\t\th[i] = hh;\n\t\t\t\t\t\n\t\t\t\t\tPoint2D.Double cp = crosspoint(a, b, ss, tt);\n\t\t\t\t\tcrossp.add(cp);\n\t\t\t\t\t\n\t\t\t\t\tdouble dx = a.x - cp.x;\n\t\t\t\t\tdouble dy = a.y - cp.y;\n\t\t\t\t\tdis[i] = Math.sqrt(dx*dx + dy*dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti--;\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = n;i > 0;i--)\n\t\t\t{\n\t\t\t\tfor(j = 0;j < (i - 1);j++)\n\t\t\t\t{\n\t\t\t\t\tif(dis[j] > dis[j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble tmp;\n\t\t\t\t\t\ttmp = dis[j];    dis[j] = dis[j+1];    dis[j+1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint tmpi;\n\t\t\t\t\t\ttmpi = o[j];     o[j] = o[j+1];    o[j+1] = tmpi;\n\t\t\t\t\t\ttmpi = h[j];     h[j] = h[j+1];    h[j+1] = tmpi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint point = -1;\n\t\t\tint num = 0;\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tif(o[i] == 1)\n\t\t\t\t{\n\t\t\t\t\tif(h[i] == point) continue;\n\t\t\t\t\tnum++;\n\t\t\t\t\tpoint = h[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(h[i] != point) continue;\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tif(point == 0)\n\t\t\t\t\t\tpoint = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpoint = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(num - 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\tclass C implements Comparable<C>{\n\t\tdouble distance;\n\t\tint pos;\n\t\tpublic C(double distance, int pos) {\n\t\t\tthis.distance = distance;\n\t\t\tthis.pos = pos;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.distance < o.distance) return -1;\n\t\t\tif(this.distance > o.distance) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tint xa = sc.nextInt();\n\t\t\tint ya = sc.nextInt();\n\t\t\tint xb = sc.nextInt();\n\t\t\tint yb = sc.nextInt();\n\t\t\tLine2D newline = new Line2D.Double(new Point2D.Double(xa, ya), new Point2D.Double(xb, yb));\n\t\t\tint n = sc.nextInt();\n\t\t\tLine2D [] llist = new Line2D[n];\n\t\t\tint [] posdata = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint xs = sc.nextInt();\n\t\t\t\tint ys = sc.nextInt();\n\t\t\t\tint xt = sc.nextInt();\n\t\t\t\tint yt = sc.nextInt();\n\t\t\t\tllist[i] = new Line2D.Double(new Point2D.Double(xs, ys), new Point2D.Double(xt, yt));\n\t\t\t\tint o = sc.nextInt();\n\t\t\t\tint pos = sc.nextInt();\n\t\t\t\tposdata[i] = (o == 0 ? pos ^ 1 : pos);\n\t\t\t}\n\t\t\tArrayList<C> intersect = new ArrayList<Main.C>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(newline.intersectsLine(llist[i])){\n\t\t\t\t\tPoint2D intersectP = intersectPtSS(newline, llist[i]);\n\t\t\t\t\tdouble dis = intersectP.distance(newline.getP1());\n\t\t\t\t\tintersect.add(new C(dis, posdata[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(intersect.size() == 0){\n\t\t\t\tSystem.out.println(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tCollections.sort(intersect);\n\t\t\tint prev = intersect.get(0).pos;\n\t\t\tint count = 0;\n\t\t\tfor(int i = 1; i < intersect.size(); i++){\n\t\t\t\tif(prev != intersect.get(i).pos){\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev = intersect.get(i).pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tprivate Point2D intersectPtSS(Line2D l, Line2D m){\n\t\tPoint2D lVec = sub(l.getP2(), l.getP1());\n\t\tPoint2D mVec = sub(m.getP2(), m.getP1());\n\t\tPoint2D m1l1Vec = sub(m.getP1(), l.getP1());\n\t\tdouble a = cross(m1l1Vec, lVec);\n\t\tdouble b = cross(lVec, mVec);\n\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\treturn null;\n\t\t}\n\t\tdouble t = a / b;\n\t\tdouble resx = m.getX1() + t * mVec.getX();\n\t\tdouble resy = m.getY1() + t * mVec.getY();\n\t\treturn new Point2D.Double(resx, resy);\n\t}\n\n\tprivate double cross(Point2D p1, Point2D p2) {\n\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\treturn res;\n\t}\n\n\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\treturn new Point2D.Double(p2.getX() - p1.getX(), p2.getY() - p1.getY());\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int x1, y1, x2, y2,N;\n\tstatic final double EPS = 1e-8;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(int Test=cin.nextInt();Test--!=0;){\n\t\t\tx1=cin.nextInt();\n\t\t\ty1=cin.nextInt();\n\t\t\tx2=cin.nextInt();\n\t\t\ty2=cin.nextInt();\n\t\t\tN=cin.nextInt();\n\t\t\tLine[] line=new Line[N];\n\t\t\tdouble[][] p = new double[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tline[i]=new Line(cin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt());\n\t\t\t\tline[i].p=p[i];\n\t\t\t}\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(!Line2D.linesIntersect(x1,y1,x2,y2, line[i].x1,line[i].y1,line[i].x2,line[i].y2\n\t\t\t\t)){\n\t\t\t\t\tp[i][0]=1<<30;\n\t\t\t\t\tline[i].isCross=false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tp[i]=crossPointSS(\n\t\t\t\t\t\tnew double[]{x1,y1},\n\t\t\t\t\t\tnew double[]{x2,y2},\n\t\t\t\t\t\tnew double[]{line[i].x1,line[i].y1},\n\t\t\t\t\t\tnew double[]{line[i].x2,line[i].y2}\n\n\t\t\t\t);\n\t\t\t\tline[i].p=p[i];\n\t\t\t\t//\t\t\t\tSystem.out.println(p[i][0]+\" \"+p[i][1]);\n\t\t\t}/*\n\t\t\tArrays.sort(p,new Comparator<double[]>(){\n\t\t\t\tpublic int compare(double[] a,double[] b){\n\t\t\t\t\tif(a[0]-b[0]<EPS)return 0;\n\t\t\t\t\tif(a[0]+EPS>b[0])return 1;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t});*/\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t//\t\t\t\tSystem.out.println(line[i]+\" \"+line[i].p[0]+\" \"+line[i].x2);\n\t\t\t}\n\t\t\tArrays.sort(line);\n//\t\t\tSystem.out.println();\n\t\t\tfor(int i=0;i<N;i++){\n//\t\t\t\tSystem.out.println(line[i].isMine+\" \"+line[i].isHigh);\n\t\t\t}\n\t\t\t//\t\t\tSystem.out.println();\n\t\t\tboolean isHigh=false;\n\t\t\tint c=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(!line[i].isCross)continue;\n\n\t\t\t\tif(line[i].isMine){\n\t\t\t\t\tisHigh=line[i].isHigh;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tisHigh=!line[i].isHigh;\n\t\t\t\t}\n\t\t\t\tc=i;\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(isHigh);\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(!line[i].isCross)continue;\n\t\t\t\tif(c==i)continue;\n\t\t\t\tif(line[i].isMine){\n\t\t\t\t\tif(line[i].isHigh==isHigh){\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tisHigh=line[i].isHigh;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(line[i].isMine==isHigh){\n\t\t\t\t\t\tisHigh=!line[i].isHigh;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(isHigh);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class Line implements Comparable<Line>{\n\t\tint x1, y1, x2, y2;\n\t\tboolean isMine, isHigh,isCross;\n\t\tdouble[] p;\n\t\tLine(int a,int b,int c,int d,int e,int f){\n\t\t\tx1=a;\n\t\t\ty1=b;\n\t\t\tx2=c;\n\t\t\ty2=d;\n\t\t\tisMine=e==1;\n\t\t\tisHigh=f==1;\n\t\t\tisCross=true;\n\t\t}\n\t\tpublic int compareTo(Line line){\n\t\t\tif(p[0]-line.p[0]<EPS)return 0;\n\t\t\tif(p[0]+EPS>line.p[0])return 1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstatic double[] crossPointSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\tif(!intersectSS(a1, a2, b1, b2))return null;\n\t\tdouble[] b = sub(b2, b1);\n\t\tdouble d1 = Math.abs(cross(b, sub(a1, b1)));\n\t\tdouble d2 = Math.abs(cross(b, sub(a2, b1)));\n\t\tdouble t = d1/(d1+d2);\n\t\tdouble[] a = sub(a2, a1);\n\t\treturn new double[]{a1[0]+a[0]*t, a1[1]+a[1]*t};\n\t}\n\tstatic boolean intersectSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\treturn cross(sub(a2, a1), sub(b1, a1))*cross(sub(a2, a1), sub(b2, a1)) < EPS &&\n\t\tcross(sub(b2, b1), sub(a1, b1))*cross(sub(b2, b1), sub(a2, b1)) < EPS;\n\t}\n\tstatic double norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tstatic double[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tstatic double dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tstatic double cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.*;\n\n\n\n\n\n\n\nclass Main {\n\n\tpublic static void main(String[] args) {\t\n\t\t//FastScanner sc = new FastScanner();\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dataset = sc.nextInt();\n\t\tfor(int datasetCount = 0; datasetCount < dataset; datasetCount++) {\n\t\t\tint xa = sc.nextInt();\n\t\t\tint ya = sc.nextInt();\n\t\t\tint xb = sc.nextInt();\n\t\t\tint yb = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tPoint pa = new Point(xa,ya);\n\t\t\tPoint pb = new Point(xb,yb);\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tPoint s = new Point(sc.nextInt(),sc.nextInt());\n\t\t\t\tPoint t = new Point(sc.nextInt(),sc.nextInt());\n\t\t\t\tdata[i] = new Data(s,t,(sc.nextInt()==1?true:false),(sc.nextInt()==1?true:false));\n\t\t\t}\n\t\t\tPriorityQueue<Data> intersectA = new PriorityQueue<Data>();\n\t\t\tPriorityQueue<Data> intersectB = new PriorityQueue<Data>();\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(intersectsSS(pa,pb,data[i].s,data[i].t)) {\n\t\t\t\t\tPoint pp = crosspointLL(data[i].s,data[i].t,pa,pb);\n\t\t\t\t\tdouble dist = pa.distance(pp);\n\t\t\t\t\tdata[i].dist = dist;\n\t\t\t\t\tintersectA.add(data[i]);\n\t\t\t\t\tintersectB.add(data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tboolean nowg = true;\n\t\t\twhile(!intersectA.isEmpty()) {\n\t\t\t\tData p = intersectA.poll();\n\t\t\t\tif(p.o) {\n\t\t\t\t\tif(p.l != nowg) {\n\t\t\t\t\t\tmax++;\n\t\t\t\t\t\tnowg = !nowg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(p.l == nowg) {\n\t\t\t\t\t\tmax++;\n\t\t\t\t\t\tnowg = !nowg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tnowg = false;\n\t\t\twhile(!intersectB.isEmpty()) {\n\t\t\t\tData p = intersectB.poll();\n\t\t\t\tif(p.o) {\n\t\t\t\t\tif(p.l != nowg) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tnowg = !nowg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(p.l == nowg) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tnowg = !nowg;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.min(max, count);\n\t\t\tSystem.out.println(max);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\tstatic Point crosspointLL(Point a1, Point a2, Point b1, Point b2) {\n        // ????????????a????????????d1/d2???????????¨??´???b?????\\???????????????d1,d2????¨????\n        Point a = a2.subtract(a1);\n        Point b = b2.subtract(b1);\n        double d1 = b.cross(b1.subtract(a1));\n        double d2 = b.cross(a);\n        if (Math.abs(d1) < EPS && Math.abs(d2) < EPS) return a1;  // same line\n        // ????????´?????????????????????????????????????????? return intersectsSP(b1,b2,a1) ? a1 : a2; ??¨??????????????????\n        if (Math.abs(d2) < EPS) throw new IllegalArgumentException(\n                \"PRECONDITION NOT SATISFIED\");\n        return a1.add(a.multiply(d1 / d2));\n    }\n\tstatic class Data implements Comparable<Data> {\n\t\tstatic Point pp;\n\t\tPoint s;\n\t\tPoint t;\n\t\tboolean o;\n\t\tboolean l;\n\t\tdouble dist;\n\t\tData(Point s, Point t, boolean o, boolean l) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.o = o;\n\t\t\tthis.l = l;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\tif(this.dist < o.dist) return -1;\n\t\t\tif(this.dist > o.dist) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tstatic double distanceSP(Point a1, Point a2, Point b) {\n        Point r = projection(a1, a2, b);\n        // ?????±??????????????????????????????????????????p??????????????????????????¢???????????°??????\n        if (intersectsSP(a1, a2, r)) return r.distance(b);\n        return Math.min(b.distance(a1), b.distance(a2));\n    }\n\tstatic boolean intersectsSP(Point a1, Point a2, Point b) {\n        return ccw(a1, a2, b) == 0;\n    }\n\tstatic Point projection(Point a1, Point a2, Point p) {\n        Point a = a2.subtract(a1);\n        p = p.subtract(a1);\n        double t = a.dot(p) / a.distanceSqr();\n        // |a||p|cos??=t|a|^2, a,t???????????§?????????????¨?????????p??????????????´???\n        return a1.add(a.multiply(t));\n    }\n\tstatic class Point extends Point2D.Double implements Comparable<Point> {\n\n        public Point() {\n        }\n\n        public Point(double x, double y) {\n            super(x, y);\n            // x??¨y???final??§??????????????????????????????????????¢??°????????¨????????´?????????????????¨???????????¨?????????????????§??¨??????\n        }\n\n        /** ?????????dot(v1,v2)=|v1||v2|cos?? */\n        double dot(Point p) {\n            return x * p.x + y * p.y;\n        }\n\n        /** ?????????cross(v1,v2)=|v1||v2|sin?? */\n        double cross(Point p) {\n            return x * p.y - y * p.x;\n        }\n\n        double distanceSqr() {\n            return x * x + y * y;\n        }\n\n        double distance() {\n            return Math.hypot(x, y);\n        }\n\n        Point add(Point p) {\n            return new Point(x + p.x, y + p.y);\n        }\n\n        Point multiply(double k) {\n            return new Point(k * x, k * y);\n        }\n\n        Point multiply(Point p) {  // complex mul: (x+yi)*(p.x+p.yi)\n            return new Point(x * p.x - y * p.y, x * p.y + p.x * y);\n        }\n\n        Point subtract(Point p) {\n            return new Point(x - p.x, y - p.y);\n        }\n\n        @Override\n        public boolean equals(Object obj) {  // ????????¢??°???Eclipse??§??????????????§?¨?????????????????????????????????°??????\n            if (this == obj) return true;\n            if (obj == null) return false;\n            if (getClass() != obj.getClass()) return false;\n            Point other = (Point) obj;\n            if (!approxEquals(x, other.x)) return false;\n            if (!approxEquals(y, other.y)) return false;\n            return true;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            if (!approxEquals(x, o.x)) return (int) Math.signum(x - o.x);\n            if (!approxEquals(y, o.y)) return (int) Math.signum(y - o.y);\n            return 0;\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + x + \",\" + y + \")\";\n        }\n\n    }\n\t\n\tstatic boolean approxEquals(double a, double b) {\n        return Math.abs(a - b) < EPS;\n    }\n\t\n\tstatic final double EPS = 1e-12;\n\tstatic boolean intersectsSS(Point a1, Point a2, Point b1, Point b2) {\n\t       // ????????????????????????????????????????????????????????????true\n\t       return ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0\n\t               && ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0;\n\t}\n\t \n\t static int ccw(Point a, Point b, Point c) {\n\t        b = b.subtract(a);\n\t        c = c.subtract(a);\n\t        if (b.cross(c) > EPS) return +1;                  // counter clockwise\n\t        if (b.cross(c) + EPS < 0) return -1;              // clockwise\n\t        if (b.dot(c) + EPS < 0) return +2;                // c--a--b on line and a!=c\n\t        if (b.distanceSqr() < c.distanceSqr()) return -2; // a--b--c on line or a==b???????????¬??????a==b??¨??????????????§?????????\n\t        return 0;                                         // a--c--b on line or b==c\n\t    }\n\n\n\t\n\tstatic class FastScanner {\n\t    private final InputStream in = System.in;\n\t    private final byte[] buffer = new byte[1024];\n\t    private int ptr = 0;\n\t    private int buflen = 0;\n\t    private boolean hasNextByte() {\n\t        if (ptr < buflen) {\n\t            return true;\n\t        }else{\n\t            ptr = 0;\n\t            try {\n\t                buflen = in.read(buffer);\n\t            } catch (IOException e) {\n\t                e.printStackTrace();\n\t            }\n\t            if (buflen <= 0) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\t    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\t    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t    public String next() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        StringBuilder sb = new StringBuilder();\n\t        int b = readByte();\n\t        while(isPrintableChar(b)) {\n\t            sb.appendCodePoint(b);\n\t            b = readByte();\n\t        }\n\t        return sb.toString();\n\t    }\n\t    public long nextLong() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        long n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t    public int nextInt() {\n\t        if (!hasNext()) throw new NoSuchElementException();\n\t        int n = 0;\n\t        boolean minus = false;\n\t        int b = readByte();\n\t        if (b == '-') {\n\t            minus = true;\n\t            b = readByte();\n\t        }\n\t        if (b < '0' || '9' < b) {\n\t            throw new NumberFormatException();\n\t        }\n\t        while(true){\n\t            if ('0' <= b && b <= '9') {\n\t                n *= 10;\n\t                n += b - '0';\n\t            }else if(b == -1 || !isPrintableChar(b)){\n\t                return minus ? -n : n;\n\t            }else{\n\t                throw new NumberFormatException();\n\t            }\n\t            b = readByte();\n\t        }\n\t    }\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\nclass Main{\n    int n;\n    int xa,ya,xb,yb;\n    int[] xs,ys,xt,yt,o,l;\n    Line2D a,b;\n    Intersection[] inter;\n\n    class Intersection{\n\tdouble dist;\n\tint owner,height;\n\tpublic Intersection(double dist,int owner,int height){\n\t    this.dist = dist;\n\t    this.owner = owner;\n\t    this.height = height;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tint T = sc.nextInt();\n\twhile(T--!=0){\n\t    xa = sc.nextInt(); ya = sc.nextInt();\n\t    xb = sc.nextInt(); yb = sc.nextInt();\n\t    n = sc.nextInt();\n\t    xs = new int[n]; ys = new int[n];\n\t    xt = new int[n]; yt = new int[n];\n\t    o = new int[n];\n\t    l = new int[n];\n\t    for(int i=0; i<n; i++){\n\t\txs[i] = sc.nextInt(); ys[i] = sc.nextInt();\n\t\txt[i] = sc.nextInt(); yt[i] = sc.nextInt();\n\t\to[i] = sc.nextInt();\n\t\tl[i] = sc.nextInt();\n\t    }\n\n\t    inter = new Intersection[n];\n\t    for(int i=0; i<n; i++){\n\t\ta = new Line2D.Double(xa,ya,xb,yb);\n\t\tb = new Line2D.Double(xs[i],ys[i],xt[i],yt[i]);\n\t\tif(!a.intersectsLine(b)){\n\t\t    inter[i] = new Intersection(-1,-1,-1);\n\t\t    continue;\n\t\t}\n\t\tdouble d = calcDist(xa,ya,xb,yb,xs[i],ys[i],xt[i],yt[i]);\n\t\tinter[i] = new Intersection(d,o[i],l[i]);\n\t    }\n\n\t    for(int i=0; i<n; i++){\n\t\tdouble minD = inter[i].dist;\n\t\tint minIndex = i;\n\t\tfor(int j=i; j<n; j++){\n\t\t    if(inter[j].dist<minD){\n\t\t\tminD = inter[j].dist;\n\t\t\tminIndex = j;\n\t\t    }\n\t\t}\n\t\tIntersection tmp = inter[minIndex];\n\t\tinter[minIndex] = inter[i];\n\t\tinter[i] = tmp;\n\t    }\n\n\t    int ans = Math.min(countGate(0),countGate(1));\n\n\t    System.out.println(ans);\n\t}\n    }\n\n    double calcDist(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tdouble bx = x4-x3;\n\tdouble by = y4-y3;\n\tdouble d1 = Math.abs(bx*(y1-y3)-by*(x1-x3));\n\tdouble d2 = Math.abs(bx*(y2-y3)-by*(x2-x3));\n\tdouble t = d1/(d1+d2);\t\n\tdouble x = x1+(x2-x1)*t;\n\tdouble y = y1+(y2-y1)*t;\n\n\treturn (xa-x)*(xa-x)+(ya-y)*(ya-y);\n    }\n\n    int countGate(int nowHeight){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t    if(inter[i].dist==-1)continue;\n\t    if(inter[i].owner==0){\n\t\tif(inter[i].height==nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }else{\n\t\tif(inter[i].height!=nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\treturn count;\n    }\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\npublic class Main{\n    int n;\n    int xa,ya,xb,yb;\n    int xs,ys,xt,yt,o,l;\n    Line2D a,b;\n    Intersection[] inter;\n\n    class Intersection{\n\tdouble dist;\n\tint owner,height;\n\tpublic Intersection(double dist,int owner,int height){\n\t    this.dist = dist;\n\t    this.owner = owner;\n\t    this.height = height;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tint T = sc.nextInt();\n\twhile(T--!=0){\n\t    xa = sc.nextInt(); ya = sc.nextInt();\n\t    xb = sc.nextInt(); yb = sc.nextInt();\n\t    n = sc.nextInt();\n\n\t    inter = new Intersection[n];\n\t    a = new Line2D.Double(xa,ya,xb,yb);\n\t    for(int i=0; i<n; i++){\n\t\txs = sc.nextInt(); ys = sc.nextInt();\n\t\txt = sc.nextInt(); yt = sc.nextInt();\n\t\to = sc.nextInt(); l = sc.nextInt();\n\t\tb = new Line2D.Double(xs,ys,xt,yt);\n\t\tif(a.intersectsLine(b)){\n\t\t    double d = calcDist(xa,ya,xb,yb,xs,ys,xt,yt);\n\t\t    inter[i] = new Intersection(d,o,l);\n\t\t}else{\n\t\t    inter[i] = new Intersection(-1,-1,-1);\n\t\t}\n\t    }\n\n\t    Comparator<Intersection> cmp = new Comparator<Intersection>(){\n\t\tpublic int compare(Intersection i1, Intersection i2){\n\t\t    if(i1.dist<i2.dist) return -1;\n\t\t    if(i1.dist>i2.dist) return 1;\n\t\t    return 0;\n\t\t}\n\t    };\n\t    Arrays.sort(inter, cmp);\n\n\t    int ans = Math.min(countGate(0),countGate(1));\n\t    \n\t    System.out.println(ans);\n\t}\n    }\n    \n    double calcDist(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tdouble bx = x4-x3;\n\tdouble by = y4-y3;\n\tdouble d1 = Math.abs(bx*(y1-y3)-by*(x1-x3));\n\tdouble d2 = Math.abs(bx*(y2-y3)-by*(x2-x3));\n\tdouble t = d1/(d1+d2);\t\n\tdouble x = x1+(x2-x1)*t;\n\tdouble y = y1+(y2-y1)*t;\n\t\n\treturn (xa-x)*(xa-x)+(ya-y)*(ya-y);\n    }\n    \n    int countGate(int nowHeight){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t    if(inter[i].dist==-1)continue;\n\t    if(inter[i].owner==0){\n\t\tif(inter[i].height==nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }else{\n\t\tif(inter[i].height!=nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\treturn count;\n    }\n    \n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tdouble EPS = 1e-10;\n\t\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\t\tboolean me, up;\n\t\tpublic P(double x, double y, boolean me, boolean up) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.me = me;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(x!=o.x)return (int) Math.signum(x-o.x);\n\t\t\telse return (int) Math.signum(y-o.y);\n\t\t}\n\t}\n\t\n\tboolean cross(P a, P b, P s, P t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\treturn ex(s, t, a)*ex(s, t, b)<EPS;\n\t}\n\tdouble ex(P s, P t, P r){\n\t\tdouble x1 = t.x-s.x, y1 = t.y-s.y, x2 = r.x-s.x, y2 = r.y-s.y;\n\t\treturn x1*y2-x2*y1;\n\t}\n\tP cp(P a, P b, P s, P t, boolean m, boolean u){\n\t\tdouble dx = b.x-a.x, dy = b.y-a.y;\n\t\tdouble norm = Math.hypot(dx, dy);\n\t\tdx/=norm; dy/=norm;\n\t\tdouble tx = s.x-a.x, ty = s.y-a.y;\n\t\tdouble thita = Math.atan2(dx*ty-dy*tx, dx*tx+dy*ty);\n\t\tdouble k = Math.cos(thita)*Math.hypot(tx, ty);\n\t\treturn new P(a.x+k*dx, a.y+k*dy, m, u);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tP A = new P(sc.nextDouble(), sc.nextDouble(), true, true), B = new P(sc.nextDouble(), sc.nextDouble(), true, true);\n\t\t\tint n = sc.nextInt();\n\t\t\tP[][] line = new P[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\tboolean m = sc.nextInt()==1, u = sc.nextInt()==1;\n\t\t\t\tline[i][0] = new P(x1, y1, m, u);\n\t\t\t\tline[i][1] = new P(x2, y2, m, u);\n\t\t\t}\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\tfor(int i=0;i<n;i++)if(cross(A, B, line[i][0], line[i][1]))l.add(cp(A, B, line[i][0], line[i][1], line[i][0].me, line[i][0].up));\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tif(l.size()>0){\n\t\t\t\tP h = l.get(0);\n\t\t\t\tboolean u = h.me?h.up:!h.up;\n\t\t\t\tfor(int i=1;i<l.size();i++){\n\t\t\t\t\th = l.get(i);\n\t\t\t\t\tif(h.me){\n\t\t\t\t\t\tif(h.up!=u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(h.up==u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint N = nextInt();\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tP A = new P(nextInt(), nextInt());\n\t\t\tP B = new P(nextInt(), nextInt());\n\n\t\t\tint n = nextInt();\n\n\t\t\tGeo2D geo2d = new Geo2D();\n\n\t\t\tArrayList<CrossPoint> list = new ArrayList<CrossPoint>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tP S = new P(nextInt(), nextInt());\n\t\t\t\tP T = new P(nextInt(), nextInt());\n\n\t\t\t\tint o = nextInt();// 1ならば自社\n\t\t\t\tint l = nextInt();// 0ならば地下\n\n\t\t\t\tif (o == 0) {\n\t\t\t\t\t// 他社なら反転\n\t\t\t\t\tl = (l + 1) % 2;\n\t\t\t\t}\n\n\t\t\t\tif (geo2d.cross(A, B, S, T)) {\n\t\t\t\t\tP crossP = geo2d.intersection_ls(A, B, S, T);\n\t\t\t\t\tlist.add(new CrossPoint(crossP.x, crossP.y, l == 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(list);\n\n\t\t\tboolean now = true;\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tif (i != 0 && now != list.get(i).under) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tnow = list.get(i).under;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass CrossPoint implements Comparable<CrossPoint> {\n\tdouble x, y;\n\tboolean under;// 地下ならtrue\n\tdouble EPS = 1e-9;\n\n\tpublic CrossPoint(double x, double y, boolean under) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.under = under;\n\t}\n\n\tpublic int compareTo(CrossPoint o) {\n\t\t// 基本x座標で昇順にソートしつつ、同じならy座標でソートする\n\t\tif (Math.abs(x - o.x) > EPS)\n\t\t\treturn (int) Math.signum(x - o.x);\n\t\telse\n\t\t\treturn (int) Math.signum(y - o.y);\n\t}\n}\n\nclass P implements Comparable<P> {\n\tdouble x, y;\n\tdouble EPS = 1e-9;\n\n\tpublic P(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int compareTo(P o) {\n\t\tif (Math.abs(x - o.x) > EPS)\n\t\t\treturn (int) Math.signum(x - o.x);\n\t\telse\n\t\t\treturn (int) Math.signum(y - o.y);\n\t}\n}\n\n// 平面幾何系ライブラリもどき\nclass Geo2D {\n\n\tdouble EPS = 1e-9;\n\n\t/* 線分abと線分stは交差するか */\n\tboolean cross(P a, P b, P s, P t) {\n\t\tif (ex(a, b, s) * ex(a, b, t) > 0)\n\t\t\treturn false;\n\t\tif (ex(b, a, s) * ex(b, a, t) > 0)\n\t\t\treturn false;\n\t\tif (ex(t, s, a) * ex(t, s, b) > 0)\n\t\t\treturn false;\n\t\treturn ex(s, t, a) * ex(s, t, b) < EPS;\n\t}\n\n\t/* ベクトルstとsrの外積 */\n\tdouble ex(P s, P t, P r) {\n\t\tdouble x1 = t.x - s.x;\n\t\tdouble y1 = t.y - s.y;\n\t\tdouble x2 = r.x - s.x;\n\t\tdouble y2 = r.y - s.y;\n\t\treturn x1 * y2 - x2 * y1;\n\t}\n\n\t// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\n\tP intersection_ls(P a1, P a2, P b1, P b2) {\n\t\tdouble d1 = Math.abs(ex(b1, a1, b2));\n\t\tdouble d2 = Math.abs(ex(b1, a2, b2));\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn new P(a1.x + (a2.x - a1.x) * t, a1.y + (a2.y - a1.y) * t);\n\t}\n\n\t/* 線分abと点Pの距離 */\n\tdouble dist(P a, P b, P p) {\n\t\tdouble x1 = b.x - a.x;\n\t\tdouble y1 = b.y - a.y;\n\t\tdouble x2 = p.x - a.x;\n\t\tdouble y2 = p.y - a.y;\n\t\treturn Math.abs((x1 * y2 - x2 * y1)) / Math.hypot(x1, y1);\n\t}\n\n\t/* 点pは線分ab上にあるかどうか */\n\tboolean on(P a, P b, P p) {\n\t\tif (Math.abs(a.x - b.x) < EPS)\n\t\t\treturn Math.min(a.y, b.y) <= p.y && p.y <= Math.max(a.y, b.y);\n\t\tdouble alpha = (b.y - a.y) / (b.x - a.x);\n\t\tdouble beta = a.y - alpha * a.x;\n\t\tif (Math.abs(p.y - (alpha * p.x + beta)) > EPS)\n\t\t\treturn false;\n\t\treturn Math.min(a.x, b.x) <= p.x && p.x <= Math.max(a.x, b.x);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tdouble EPS = 1e-10;\n\t\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\t\tboolean me, up;\n\t\tpublic P(double x, double y, boolean me, boolean up) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.me = me;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int) Math.signum(x-o.x);\n\t\t\telse return (int) Math.signum(y-o.y);\n\t\t}\n\t}\n\t\n\tboolean cross(P a, P b, P s, P t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\treturn ex(s, t, a)*ex(s, t, b)<EPS;\n\t}\n\tdouble ex(P s, P t, P r){\n\t\tdouble x1 = t.x-s.x, y1 = t.y-s.y, x2 = r.x-s.x, y2 = r.y-s.y;\n\t\treturn x1*y2-x2*y1;\n\t}\n\tP cp(P a, P b, P s, P t, boolean m, boolean u){\n\t\tdouble dx = b.x-a.x, dy = b.y-a.y;\n\t\tdouble norm = Math.hypot(dx, dy);\n\t\tdx/=norm; dy/=norm;\n\t\tdouble tx = s.x-a.x, ty = s.y-a.y;\n\t\tdouble thita = Math.atan2(dx*ty-dy*tx, dx*tx+dy*ty);\n\t\tdouble k = Math.cos(thita)*Math.hypot(tx, ty);\n\t\treturn new P(a.x+k*dx, a.y+k*dy, m, u);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tP A = new P(sc.nextDouble(), sc.nextDouble(), true, true), B = new P(sc.nextDouble(), sc.nextDouble(), true, true);\n\t\t\tif(B.compareTo(A)<0){\n\t\t\t\tP t = A;\n\t\t\t\tA = B;\n\t\t\t\tB = t;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tP[][] line = new P[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\tboolean m = sc.nextInt()==1, u = sc.nextInt()==1;\n\t\t\t\tline[i][0] = new P(x1, y1, m, u);\n\t\t\t\tline[i][1] = new P(x2, y2, m, u);\n\t\t\t}\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\tfor(int i=0;i<n;i++)if(cross(A, B, line[i][0], line[i][1]))l.add(cp(A, B, line[i][0], line[i][1], line[i][0].me, line[i][0].up));\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tif(l.size()>0){\n\t\t\t\tP h = l.get(0);\n\t\t\t\tboolean u = h.me?h.up:!h.up;\n\t\t\t\tfor(int i=1;i<l.size();i++){\n\t\t\t\t\th = l.get(i);\n\t\t\t\t\tif(h.me){\n\t\t\t\t\t\tif(h.up!=u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(h.up==u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\npublic class Main{\n    int n;\n    int xa,ya,xb,yb;\n    int xs,ys,xt,yt,o,l;\n    Line2D a,b;\n    Intersection[] inter;\n\n    class Intersection{\n\tdouble dist;\n\tint owner,height;\n\tpublic Intersection(double dist,int owner,int height){\n\t    this.dist = dist;\n\t    this.owner = owner;\n\t    this.height = height;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tint T = sc.nextInt();\n\twhile(T--!=0){\n\t    xa = sc.nextInt(); ya = sc.nextInt();\n\t    xb = sc.nextInt(); yb = sc.nextInt();\n\t    n = sc.nextInt();\n\n\t    inter = new Intersection[n];\n\t    for(int i=0; i<n; i++){\n\t\txs = sc.nextInt(); ys = sc.nextInt();\n\t\txt = sc.nextInt(); yt = sc.nextInt();\n\t\to = sc.nextInt(); l = sc.nextInt();\n\t\ta = new Line2D.Double(xa,ya,xb,yb);\n\t\tb = new Line2D.Double(xs,ys,xt,yt);\n\t\tif(a.intersectsLine(b)){\n\t\t    double d = calcDist(xa,ya,xb,yb,xs,ys,xt,yt);\n\t\t    inter[i] = new Intersection(d,o,l);\n\t\t}else{\n\t\t    inter[i] = new Intersection(-1,-1,-1);\n\t\t}\n\t    }\n\n\t    Comparator<Intersection> cmp = new Comparator<Intersection>(){\n\t\tpublic int compare(Intersection i1, Intersection i2){\n\t\t    if(i1.dist<i2.dist) return -1;\n\t\t    if(i1.dist>i2.dist) return 1;\n\t\t    return 0;\n\t\t}\n\t    };\n\t    Arrays.sort(inter, cmp);\n\t    \n\t    int ans = Math.min(countGate(0),countGate(1));\n\t    \n\t    System.out.println(ans);\n\t}\n    }\n    \n    double calcDist(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tdouble bx = x4-x3;\n\tdouble by = y4-y3;\n\tdouble d1 = Math.abs(bx*(y1-y3)-by*(x1-x3));\n\tdouble d2 = Math.abs(bx*(y2-y3)-by*(x2-x3));\n\tdouble t = d1/(d1+d2);\t\n\tdouble x = x1+(x2-x1)*t;\n\tdouble y = y1+(y2-y1)*t;\n\t\n\treturn (xa-x)*(xa-x)+(ya-y)*(ya-y);\n    }\n    \n    int countGate(int nowHeight){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t    if(inter[i].dist==-1)continue;\n\t    if(inter[i].owner==0){\n\t\tif(inter[i].height==nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }else{\n\t\tif(inter[i].height!=nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\treturn count;\n    }\n    \n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass State implements Comparable<State> {\n\t\tdouble dist;\n\t\tint type;\n\n\t\tState(double dist, int type) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn Double.compare(dist, s.dist);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + dist + \" \" + type;\n\t\t}\n\t}\n\t\n\tint calcType(int o, int l) {\n\t\treturn o ^ l;\n\t}\n\t\n\tdouble calcDist(double x1, double y1, double x2, double y2) {\n\t\tdouble dx = x1 - x2, dy = y1 - y2;\n\t\treturn dx * dx + dy * dy;\n\t}\n\t\n\tpublic void run() {\n\t\tint T = in.nextInt();\n\t\twhile (T-- > 0) {\n\t\t\tdouble xa = in.nextInt(), ya = in.nextInt(), xb = in.nextInt(), yb = in.nextInt();\n\t\t\tLine2D.Double base = new Line2D.Double(xa, ya, xb, yb);\n\t\t\tint n = in.nextInt();\n\t\t\tdouble a = (yb - ya) / (xb - xa), b = (ya * xb - yb * xa) / (xb - xa);\n\t\t\tArrayList<State> list = new ArrayList<State>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint nxa = in.nextInt(), nya = in.nextInt(), nxb = in.nextInt(), nyb = in.nextInt();\n\t\t\t\tint o = in.nextInt(), l = in.nextInt();\n\n\t\t\t\tLine2D.Double next = new Line2D.Double(nxa, nya, nxb, nyb);\n\t\t\t\t\n\t\t\t\tif (base.intersectsLine(next)) {\n\t\t\t\t\tif (nxb != nxa) {\n\t\t\t\t\t\tdouble c = (nyb - nya) / (nxb - nxa), d = (nya * nxb - nyb * nxa) / (nxb - nxa);\n\t\t\t\t\t\tdouble x = (d - b) / (a - c), y = (a * d - b * c) / (a - c);\n\t\t\t\t\t\t\n//\t\t\t\t\t\tSystem.out.println(i + \" \" + x + \" \" + y);\n\t\t\t\t\t\tlist.add(new State(calcDist(xa, ya, x, y), calcType(o, l)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble x = nxa;\n\t\t\t\t\t\tdouble y = x * a + b;\n\n\t\t\t\t\t\tlist.add(new State(calcDist(xa, ya, x, y), calcType(o, l)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int type = 0; type <= 1; type++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tint nowType = type;\n\t\t\t\tfor (State st : list) {\n\t\t\t\t\tif (st.type != nowType) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tnowType ^= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tdouble EPS = 1.0e-08;\n\tclass C implements Comparable<C>{\n\t\tdouble distance;\n\t\tint pos;\n\t\tpublic C(double distance, int pos) {\n\t\t\tthis.distance = distance;\n\t\t\tthis.pos = pos;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\tif(this.distance < o.distance) return -1;\n\t\t\tif(this.distance > o.distance) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tint xa = sc.nextInt();\n\t\t\tint ya = sc.nextInt();\n\t\t\tint xb = sc.nextInt();\n\t\t\tint yb = sc.nextInt();\n\t\t\tLine2D newline = new Line2D.Double(new Point2D.Double(xa, ya), new Point2D.Double(xb, yb));\n\t\t\tint n = sc.nextInt();\n\t\t\tLine2D [] llist = new Line2D[n];\n\t\t\tint [] posdata = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint xs = sc.nextInt();\n\t\t\t\tint ys = sc.nextInt();\n\t\t\t\tint xt = sc.nextInt();\n\t\t\t\tint yt = sc.nextInt();\n\t\t\t\tllist[i] = new Line2D.Double(new Point2D.Double(xs, ys), new Point2D.Double(xt, yt));\n\t\t\t\tint o = sc.nextInt();\n\t\t\t\tint pos = sc.nextInt();\n\t\t\t\tposdata[i] = (o == 0 ? pos ^ 1 : pos);\n\t\t\t}\n\t\t\tArrayList<C> intersect = new ArrayList<Main.C>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(newline.intersectsLine(llist[i])){\n\t\t\t\t\tPoint2D intersectP = intersectPtSS(newline, llist[i]);\n\t\t\t\t\tdouble dis = intersectP.distance(newline.getP1());\n\t\t\t\t\tintersect.add(new C(dis, posdata[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(intersect);\n\t\t\tint prev = intersect.get(0).pos;\n\t\t\tint count = 0;\n\t\t\tfor(int i = 1; i < intersect.size(); i++){\n\t\t\t\tif(prev != intersect.get(i).pos){\n\t\t\t\t\tcount++;\n\t\t\t\t\tprev = intersect.get(i).pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tprivate Point2D intersectPtSS(Line2D l, Line2D m){\n\t\tPoint2D lVec = sub(l.getP2(), l.getP1());\n\t\tPoint2D mVec = sub(m.getP2(), m.getP1());\n\t\tPoint2D m1l1Vec = sub(m.getP1(), l.getP1());\n\t\tdouble a = cross(m1l1Vec, lVec);\n\t\tdouble b = cross(lVec, mVec);\n\t\tif(Math.abs(a) < EPS && Math.abs(b) < EPS){\n\t\t\treturn null;\n\t\t}\n\t\tdouble t = a / b;\n\t\tdouble resx = m.getX1() + t * mVec.getX();\n\t\tdouble resy = m.getY1() + t * mVec.getY();\n\t\treturn new Point2D.Double(resx, resy);\n\t}\n\n\tprivate double cross(Point2D p1, Point2D p2) {\n\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\treturn res;\n\t}\n\n\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\treturn new Point2D.Double(p2.getX() - p1.getX(), p2.getY() - p1.getY());\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\npublic class Main{\n    int n;\n    int xa,ya,xb,yb;\n    int xs,ys,xt,yt,o,l;\n    Line2D a,b;\n    Intersection[] inter;\n\n    class Intersection{\n\tdouble dist;\n\tint owner,height;\n\tpublic Intersection(double dist,int owner,int height){\n\t    this.dist = dist;\n\t    this.owner = owner;\n\t    this.height = height;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tint T = sc.nextInt();\n\twhile(T--!=0){\n\t    xa = sc.nextInt(); ya = sc.nextInt();\n\t    xb = sc.nextInt(); yb = sc.nextInt();\n\t    n = sc.nextInt();\n\n\t    inter = new Intersection[n];\n\t    a = new Line2D.Double(xa,ya,xb,yb);\n\t    for(int i=0; i<n; i++){\n\t\txs = sc.nextInt(); ys = sc.nextInt();\n\t\txt = sc.nextInt(); yt = sc.nextInt();\n\t\to = sc.nextInt(); l = sc.nextInt();\n\t\tb = new Line2D.Double(xs,ys,xt,yt);\n\t\tif(a.intersectsLine(b)){\n\t\t    double d = calcDist(xa,ya,xb,yb,xs,ys,xt,yt);\n\t\t    inter[i] = new Intersection(d,o,l);\n\t\t}else{\n\t\t    inter[i] = new Intersection(-1,-1,-1);\n\t\t}\n\t    }\n\n\t    Comparator<Intersection> cmp = new Comparator<Intersection>(){\n\t\tpublic int compare(Intersection i1, Intersection i2){\n\t\t    if(i1.dist<i2.dist) return -1;\n\t\t    if(i1.dist>i2.dist) return 1;\n\t\t    return 0;\n\t\t}\n\t    };\n\t    Arrays.sort(inter, cmp);\n\t    \n\t    System.out.println(Math.min(countGate(0),countGate(1)));\n\t}\n    }\n    \n    double calcDist(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tdouble bx = x4-x3;\n\tdouble by = y4-y3;\n\tdouble d1 = Math.abs(bx*(y1-y3)-by*(x1-x3));\n\tdouble d2 = Math.abs(bx*(y2-y3)-by*(x2-x3));\n\tdouble t = d1/(d1+d2);\t\n\tdouble x = x1+(x2-x1)*t;\n\tdouble y = y1+(y2-y1)*t;\n\t\n\treturn (xa-x)*(xa-x)+(ya-y)*(ya-y);\n    }\n    \n    int countGate(int nowHeight){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t    if(inter[i].dist==-1)continue;\n\t    if(inter[i].owner==0){\n\t\tif(inter[i].height==nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }else{\n\t\tif(inter[i].height!=nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\treturn count;\n    }\n    \n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass State implements Comparable<State> {\n\t\tdouble dist;\n\t\tint type;\n\n\t\tState(double dist, int type) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.type = type;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn Double.compare(dist, s.dist);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + dist + \" \" + type;\n\t\t}\n\t}\n\t\n\tint calcType(int o, int l) {\n\t\treturn o ^ l;\n\t}\n\t\n\tdouble calcDist(double x1, double y1, double x2, double y2) {\n\t\tdouble dx = x1 - x2, dy = y1 - y2;\n\t\treturn dx * dx + dy * dy;\n\t}\n\t\n\tpublic void run() {\n\t\tint T = in.nextInt();\n\t\twhile (T-- > 0) {\n\t\t\tdouble xa = in.nextInt(), ya = in.nextInt(), xb = in.nextInt(), yb = in.nextInt();\n\t\t\tLine2D.Double base = new Line2D.Double(xa, ya, xb, yb);\n\t\t\tint n = in.nextInt();\n\t\t\tdouble a = (yb - ya) / (xb - xa), b = (ya * xb - yb * xa) / (xb - xa);\n\t\t\tArrayList<State> list = new ArrayList<State>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdouble nxa = in.nextInt(), nya = in.nextInt(), nxb = in.nextInt(), nyb = in.nextInt();\n\t\t\t\tint o = in.nextInt(), l = in.nextInt();\n\n\t\t\t\tLine2D.Double next = new Line2D.Double(nxa, nya, nxb, nyb);\n\t\t\t\t\n\t\t\t\tif (base.intersectsLine(next)) {\n\t\t\t\t\tif (nxb != nxa) {\n\t\t\t\t\t\tdouble c = (nyb - nya) / (nxb - nxa), d = (nya * nxb - nyb * nxa) / (nxb - nxa);\n\t\t\t\t\t\tdouble x = (d - b) / (a - c), y = (a * d - b * c) / (a - c);\n\t\t\t\t\t\t\n//\t\t\t\t\t\tSystem.out.println(i + \" \" + x + \" \" + y);\n\t\t\t\t\t\tlist.add(new State(calcDist(xa, ya, x, y), calcType(o, l)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdouble x = nxa;\n\t\t\t\t\t\tdouble y = x * a + b;\n\n\t\t\t\t\t\tlist.add(new State(calcDist(xa, ya, x, y), calcType(o, l)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(list);\n\t\t\t\n\t\t\tint res = Integer.MAX_VALUE;\n\t\t\tfor (int type = 0; type <= 1; type++) {\n\t\t\t\tint sum = 0;\n\t\t\t\tint nowType = type;\n\t\t\t\tfor (State st : list) {\n\t\t\t\t\tif (st.type != nowType) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tnowType ^= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres = Math.min(res, sum);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Point2D.Double a, b;\n\tstatic int n;\n\t\n\tstatic ArrayList<Point2D.Double> s, t;\n\tstatic int[] o, h;\n\t\n\tprivate static double cross(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn (a.x * b.y - a.y * b.x);\n\t}\n\t\n\tprivate static Point2D.Double add(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x + b.x, a.y + b.y);\n\t}\n\t\n\tprivate static Point2D.Double sub(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x - b.x, a.y - b.y);\n\t}\n\t\n\tprivate static Point2D.Double mul(Point2D.Double a, double t)\n\t{\n\t\treturn new Point2D.Double(a.x * t, a.y * t);\n\t}\n\t\n\tprivate static Boolean isCrossing(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\treturn (cross(sub(a2, a1), sub(b1, a1)) * cross(sub(a2, a1), sub(b2, a1)) < 1e-10) &&\n\t\t\t   (cross(sub(b2, b1), sub(a1, b1)) * cross(sub(b2, b1), sub(a2, b1)) < 1e-10);\n\t}\n\t\n\tprivate static Point2D.Double crosspoint(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\tPoint2D.Double b = sub(b2, b1);\n\t\tdouble d1 = Math.abs( cross(b, sub(a1, b1)) );\n\t\tdouble d2 = Math.abs( cross(b, sub(a2, b1)) );\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn add(a1, mul(sub(a2, a1), t));\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\tint allnum = sca.nextInt();\n\t\t\n\t\tfor(;allnum > 0;allnum--)\n\t\t\t{\n\t\t\t\n\t\t\ta = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\tb = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\n\t\t\tn = sca.nextInt();\n\t\t\t\n\t\t\tint i, j, k;\n\t\t\tArrayList<Point2D.Double> crossp = new ArrayList<Point2D.Double>();\n\t\t\tdouble[] dis;\n\t\t\t\n\t\t\ts = new ArrayList<Point2D.Double>();\n\t\t\tt = new ArrayList<Point2D.Double>();\n\t\t\to = new int[n];\n\t\t\th = new int[n];\n\t\t\tcrossp = new ArrayList<Point2D.Double>();\n\t\t\tdis = new double[n];\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tPoint2D.Double ss = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tPoint2D.Double tt = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tint oo = sca.nextInt();\n\t\t\t\tint hh = sca.nextInt();\n\t\t\t\t\n\t\t\t\tif(isCrossing(a, b, ss, tt))\n\t\t\t\t{\n\t\t\t\t\ts.add(ss);\n\t\t\t\t\tt.add(tt);\n\t\t\t\t\to[i] = oo;\n\t\t\t\t\th[i] = hh;\n\t\t\t\t\t\n\t\t\t\t\tPoint2D.Double cp = crosspoint(a, b, ss, tt);\n\t\t\t\t\tcrossp.add(cp);\n\t\t\t\t\t\n\t\t\t\t\tdouble dx = a.x - cp.x;\n\t\t\t\t\tdouble dy = a.y - cp.y;\n\t\t\t\t\tdis[i] = Math.sqrt(dx*dx + dy*dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti--;\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = n;i > 0;i--)\n\t\t\t{\n\t\t\t\tfor(j = 0;j < (i - 1);j++)\n\t\t\t\t{\n\t\t\t\t\tif(dis[j] > dis[j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble tmp;\n\t\t\t\t\t\ttmp = dis[j];    dis[j] = dis[j+1];    dis[j+1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint tmpi;\n\t\t\t\t\t\ttmpi = o[j];     o[j] = o[j+1];    o[j+1] = tmpi;\n\t\t\t\t\t\ttmpi = h[j];     h[j] = h[j+1];    h[j+1] = tmpi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint point = 0;\n\t\t\tint num = 0;\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tif(o[i] == 1 && h[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tif(point != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tpoint = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(o[i] == 1 && h[i] == 1)\n\t\t\t\t{\n\t\t\t\t\tif(point != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tpoint = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(o[i] == 0 && h[i] == 0)\n\t\t\t\t{\n\t\t\t\t\tif(point != 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tpoint = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(point != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tpoint = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif((o[0] == 1 && h[0] == 1) || (o[0] == 0 && h[0] == 0)) num--;\n\t\t\t\n\t\t\tSystem.out.println(num);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int x1, y1, x2, y2,N;\n\tstatic final double EPS = 1e-8;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(int Test=cin.nextInt();Test--!=0;){\n\t\t\tx1=cin.nextInt();\n\t\t\ty1=cin.nextInt();\n\t\t\tx2=cin.nextInt();\n\t\t\ty2=cin.nextInt();\n\t\t\tN=cin.nextInt();\n\t\t\tLine[] line=new Line[N];\n\t\t\tdouble[][] p = new double[N][2];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tline[i]=new Line(cin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt(),\n\t\t\t\t\t\tcin.nextInt());\n\t\t\t\tline[i].p=p[i];\n\t\t\t}\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(!Line2D.linesIntersect(x1,y1,x2,y2, line[i].x1,line[i].y1,line[i].x2,line[i].y2\n\t\t\t\t)){\n\t\t\t\t\tp[i][0]=1<<30;\n\t\t\t\t\tline[i].isCross=false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tp[i]=crossPointSS(\n\t\t\t\t\t\tnew double[]{x1,y1},\n\t\t\t\t\t\tnew double[]{x2,y2},\n\t\t\t\t\t\tnew double[]{line[i].x1,line[i].y1},\n\t\t\t\t\t\tnew double[]{line[i].x2,line[i].y2}\n\n\t\t\t\t);\n\t\t\t\tline[i].p=p[i];\n\t\t\t\t//\t\t\t\tSystem.out.println(p[i][0]+\" \"+p[i][1]);\n\t\t\t}/*\n\t\t\tArrays.sort(p,new Comparator<double[]>(){\n\t\t\t\tpublic int compare(double[] a,double[] b){\n\t\t\t\t\tif(a[0]-b[0]<EPS)return 0;\n\t\t\t\t\tif(a[0]+EPS>b[0])return 1;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t});*/\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t//\t\t\t\tSystem.out.println(line[i]+\" \"+line[i].p[0]+\" \"+line[i].x2);\n\t\t\t}\n\t\t\tArrays.sort(line);\n//\t\t\tSystem.out.println();\n\t\t\tfor(int i=0;i<N;i++){\n//\t\t\t\tSystem.out.println(line[i].isMine+\" \"+line[i].isHigh);\n\t\t\t}\n\t\t\t//\t\t\tSystem.out.println();\n\t\t\tboolean isHigh=false;\n\t\t\tint c=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(!line[i].isCross)continue;\n\n\t\t\t\tif(line[i].isMine){\n\t\t\t\t\tisHigh=line[i].isHigh;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tisHigh=!line[i].isHigh;\n\t\t\t\t}\n\t\t\t\tc=i;\n\t\t\t\tbreak;\n\t\t\t}\n//\t\t\tSystem.out.println(isHigh);\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(!line[i].isCross)continue;\n\t\t\t\tif(c==i)continue;\n\t\t\t\tif(line[i].isMine){\n\t\t\t\t\tif(line[i].isHigh==isHigh){\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tisHigh=line[i].isHigh;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(line[i].isHigh==isHigh){\n\t\t\t\t\t\tisHigh=!line[i].isHigh;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(isHigh);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\t}\n\n\tstatic class Line implements Comparable<Line>{\n\t\tint x1, y1, x2, y2;\n\t\tboolean isMine, isHigh,isCross;\n\t\tdouble[] p;\n\t\tLine(int a,int b,int c,int d,int e,int f){\n\t\t\tx1=a;\n\t\t\ty1=b;\n\t\t\tx2=c;\n\t\t\ty2=d;\n\t\t\tisMine=e==1;\n\t\t\tisHigh=f==1;\n\t\t\tisCross=true;\n\t\t}\n\t\tpublic int compareTo(Line line){\n\t\t\tif(p[0]-line.p[0]<EPS)return 0;\n\t\t\tif(p[0]+EPS>line.p[0])return 1;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tstatic double[] crossPointSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\tif(!intersectSS(a1, a2, b1, b2))return null;\n\t\tdouble[] b = sub(b2, b1);\n\t\tdouble d1 = Math.abs(cross(b, sub(a1, b1)));\n\t\tdouble d2 = Math.abs(cross(b, sub(a2, b1)));\n\t\tdouble t = d1/(d1+d2);\n\t\tdouble[] a = sub(a2, a1);\n\t\treturn new double[]{a1[0]+a[0]*t, a1[1]+a[1]*t};\n\t}\n\tstatic boolean intersectSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\treturn cross(sub(a2, a1), sub(b1, a1))*cross(sub(a2, a1), sub(b2, a1)) < EPS &&\n\t\tcross(sub(b2, b1), sub(a1, b1))*cross(sub(b2, b1), sub(a2, b1)) < EPS;\n\t}\n\tstatic double norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tstatic double[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tstatic double dot(double[] a, double[] b){\n\t\treturn a[0]*b[0]+a[1]*b[1];\n\t}\n\tstatic double cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\npublic class Main{\n    int n;\n    int xa,ya,xb,yb;\n    int xs,ys,xt,yt,o,l;\n    Line2D a,b;\n    Intersection[] inter;\n\n    class Intersection{\n\tdouble dist;\n\tint owner,height;\n\tpublic Intersection(double dist,int owner,int height){\n\t    this.dist = dist;\n\t    this.owner = owner;\n\t    this.height = height;\n\t}\n    }\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tint T = sc.nextInt();\n\twhile(T--!=0){\n\t    xa = sc.nextInt(); ya = sc.nextInt();\n\t    xb = sc.nextInt(); yb = sc.nextInt();\n\t    n = sc.nextInt();\n\n\t    inter = new Intersection[n];\n\t    a = new Line2D.Double(xa,ya,xb,yb);\n\t    for(int i=0; i<n; i++){\n\t\txs = sc.nextInt(); ys = sc.nextInt();\n\t\txt = sc.nextInt(); yt = sc.nextInt();\n\t\to = sc.nextInt(); l = sc.nextInt();\n\t\tb = new Line2D.Double(xs,ys,xt,yt);\n\t\tif(a.intersectsLine(b)){\n\t\t    double d = calcDist(xa,ya,xb,yb,xs,ys,xt,yt);\n\t\t    inter[i] = new Intersection(d,o,l);\n\t\t}else{\n\t\t    inter[i] = new Intersection(-1,-1,-1);\n\t\t}\n\t    }\n\n\t    Comparator<Intersection> cmp = new Comparator<Intersection>(){\n\t\tpublic int compare(Intersection i1, Intersection i2){\n\t\t    if(i1.dist<i2.dist) return -1;\n\t\t    if(i1.dist>i2.dist) return 1;\n\t\t    return 0;\n\t\t}\n\t    };\n\t    Arrays.sort(inter, cmp);\n\n\t    int ans = Math.min(countGate(0),countGate(1))\n\t    \n\t    System.out.println(ans);\n\t}\n    }\n    \n    double calcDist(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4){\n\tdouble bx = x4-x3;\n\tdouble by = y4-y3;\n\tdouble d1 = Math.abs(bx*(y1-y3)-by*(x1-x3));\n\tdouble d2 = Math.abs(bx*(y2-y3)-by*(x2-x3));\n\tdouble t = d1/(d1+d2);\t\n\tdouble x = x1+(x2-x1)*t;\n\tdouble y = y1+(y2-y1)*t;\n\t\n\treturn (xa-x)*(xa-x)+(ya-y)*(ya-y);\n    }\n    \n    int countGate(int nowHeight){\n\tint count = 0;\n\tfor(int i=0; i<n; i++){\n\t    if(inter[i].dist==-1)continue;\n\t    if(inter[i].owner==0){\n\t\tif(inter[i].height==nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }else{\n\t\tif(inter[i].height!=nowHeight){\n\t\t    nowHeight = 1 - nowHeight;\n\t\t    count++;\n\t\t}\n\t    }\n\t}\n\treturn count;\n    }\n    \n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Railroad Conflict\npublic class Main{\n\n\tfinal double EPS = 1e-10;\n\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tboolean intersectSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\treturn cross(sub(a2, a1), sub(b1, a1))*cross(sub(a2, a1), sub(b2, a1)) < EPS &&\n\t\tcross(sub(b2, b1), sub(a1, b1))*cross(sub(b2, b1), sub(a2, b1)) < EPS;\n\t}\n\tdouble[] crossPointSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\tif(!intersectSS(a1, a2, b1, b2))return null;\n\t\tdouble[] b = sub(b2, b1);\n\t\tdouble d1 = Math.abs(cross(b, sub(a1, b1)));\n\t\tdouble d2 = Math.abs(cross(b, sub(a2, b1)));\n\t\tdouble t = d1/(d1+d2);\n\t\tdouble[] a = sub(a2, a1);\n\t\treturn new double[]{a1[0]+a[0]*t, a1[1]+a[1]*t};\n\t}\n\n\tdouble[] A, B;\n\n\tclass P implements Comparable<P>{\n\t\tdouble[] p;\n\t\tboolean mine;\n\t\tboolean up;\n\t\tpublic P(double[] p, boolean mine, boolean up) {\n\t\t\tthis.p = p;\n\t\t\tthis.mine = mine;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tdouble[] s1 = sub(p, A);\n\t\t\tdouble[] s2 = sub(o.p, A);\n\t\t\tdouble d1 = s1[0]*s1[0]+s1[1]*s1[1];\n\t\t\tdouble d2 = s2[0]*s2[0]+s2[1]*s2[1];\n\t\t\treturn d1<d2?-1:d2<d1?1:0;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tA = new double[2];\n\t\t\tB = new double[2];\n\t\t\tA[0] = sc.nextDouble();\n\t\t\tA[1] = sc.nextDouble();\n\t\t\tB[0] = sc.nextDouble();\n\t\t\tB[1] = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\twhile(n--!=0){\n\t\t\t\tdouble[] s = new double[2];\n\t\t\t\tdouble[] t = new double[2];\n\t\t\t\ts[0] = sc.nextDouble();\n\t\t\t\ts[1] = sc.nextDouble();\n\t\t\t\tt[0] = sc.nextDouble();\n\t\t\t\tt[1] = sc.nextDouble();\n\t\t\t\tint o = sc.nextInt();\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tdouble[] r = crossPointSS(s, t, A, B);\n\t\t\t\tif(r==null)continue;\n\t\t\t\tl.add(new P(r, o==1, u==1));\n\t\t\t}\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tboolean f = true;\n\t\t\tboolean up = true;\n\t\t\tfor(P p:l){\n//\t\t\t\tSystem.out.println(\"P:\" + p.p[0]+\",\"+p.p[1]+\" MINE?\" + p.mine + \" UP?\"+p.up);\n\t\t\t\tif(f){\n\t\t\t\t\tf = false;\n\t\t\t\t\tif(p.mine)up = p.up;\n\t\t\t\t\telse up = !p.up;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(p.mine && p.up!=up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!p.mine && p.up==up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tdouble EPS = 1e-10;\n\t\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\t\tboolean me, up;\n\t\tpublic P(double x, double y, boolean me, boolean up) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.me = me;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int) Math.signum(x-o.x);\n\t\t\telse return (int) Math.signum(y-o.y);\n\t\t}\n\t}\n\t\n\tboolean cross(P a, P b, P s, P t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(t, s, a)*ex(t, s, b)>0)return false;\n\t\treturn ex(s, t, a)*ex(s, t, b)<EPS;\n\t}\n\tdouble ex(P s, P t, P r){\n\t\tdouble x1 = t.x-s.x, y1 = t.y-s.y, x2 = r.x-s.x, y2 = r.y-s.y;\n\t\treturn x1*y2-x2*y1;\n\t}\n\tP cp(P a, P b, P s, P t, boolean m, boolean u){\n\t\tdouble dx = b.x-a.x, dy = b.y-a.y;\n\t\tdouble norm = Math.hypot(dx, dy);\n\t\tdx/=norm; dy/=norm;\n\t\tdouble tx = s.x-a.x, ty = s.y-a.y;\n\t\tdouble thita = Math.atan2(dx*ty-dy*tx, dx*tx+dy*ty);\n\t\tdouble k = Math.cos(thita)*Math.hypot(tx, ty);\n\t\treturn new P(a.x+k*dx, a.y+k*dy, m, u);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tP A = new P(sc.nextDouble(), sc.nextDouble(), true, true), B = new P(sc.nextDouble(), sc.nextDouble(), true, true);\n\t\t\tif(B.compareTo(A)<0){\n\t\t\t\tP t = A;\n\t\t\t\tA = B;\n\t\t\t\tB = t;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tP[][] line = new P[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\tboolean m = sc.nextInt()==1, u = sc.nextInt()==1;\n\t\t\t\tline[i][0] = new P(x1, y1, m, u);\n\t\t\t\tline[i][1] = new P(x2, y2, m, u);\n\t\t\t}\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\tfor(int i=0;i<n;i++)if(cross(A, B, line[i][0], line[i][1]))l.add(cp(A, B, line[i][0], line[i][1], line[i][0].me, line[i][0].up));\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tif(l.size()>0){\n\t\t\t\tP h = l.get(0);\n\t\t\t\tboolean u = h.me?h.up:!h.up;\n\t\t\t\tfor(int i=1;i<l.size();i++){\n\t\t\t\t\th = l.get(i);\n\t\t\t\t\tif(h.me){\n\t\t\t\t\t\tif(h.up!=u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(h.up==u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main{\n\n\tdouble EPS = 1e-10;\n\t\n\tclass P implements Comparable<P>{\n\t\tdouble x, y;\n\t\tboolean me, up;\n\t\tpublic P(double x, double y, boolean me, boolean up) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.me = me;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int) Math.signum(x-o.x);\n\t\t\telse return (int) Math.signum(y-o.y);\n\t\t}\n\t}\n\t\n\tboolean cross(P a, P b, P s, P t){\n\t\tif(ex(a, b, s)*ex(a, b, t)>0)return false;\n\t\tif(ex(b, a, s)*ex(b, a, t)>0)return false;\n\t\tif(ex(t, s, a)*ex(t, s, b)>0)return false;\n\t\treturn ex(s, t, a)*ex(s, t, b)<EPS;\n\t}\n\tdouble ex(P s, P t, P r){\n\t\tdouble x1 = t.x-s.x, y1 = t.y-s.y, x2 = r.x-s.x, y2 = r.y-s.y;\n\t\treturn x1*y2-x2*y1;\n\t}\n\tdouble dist(P a, P b, P p){\n\t\tdouble x1 = b.x-a.x, y1 = b.y-a.y, x2 = p.x-a.x, y2 = p.y-a.y;\n\t\tif(x1*x2+y1*y2<EPS)return Math.hypot(x2, y2);\n\t\tx1 = a.x-b.x; y1 = a.y-b.y; x2 = p.x-b.x; y2 = p.y-b.y;\n\t\tif(x1*x2+y1*y2<EPS)return Math.hypot(x2, y2);\n\t\treturn Math.abs((x1*y2-x2*y1))/Math.hypot(x1, y1);\n\t}\n\tP cp(P a, P b, P s, P t, boolean m, boolean u){\n\t\tdouble ds = dist(a, b, s), dt = dist(a, b, t);\n\t\tdouble k = ds/(ds+dt);\n\t\tdouble dx = t.x-s.x, dy = t.y-s.y;\n\t\treturn new P(s.x+k*dx, s.y+k*dy, m, u);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tP A = new P(sc.nextDouble(), sc.nextDouble(), true, true), B = new P(sc.nextDouble(), sc.nextDouble(), true, true);\n\t\t\tif(B.compareTo(A)<0){\n\t\t\t\tP t = A;\n\t\t\t\tA = B;\n\t\t\t\tB = t;\n\t\t\t}\n\t\t\tint n = sc.nextInt();\n\t\t\tP[][] line = new P[n][2];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble x1 = sc.nextDouble(), y1 = sc.nextDouble(), x2 = sc.nextDouble(), y2 = sc.nextDouble();\n\t\t\t\tboolean m = sc.nextInt()==1, u = sc.nextInt()==1;\n\t\t\t\tline[i][0] = new P(x1, y1, m, u);\n\t\t\t\tline[i][1] = new P(x2, y2, m, u);\n\t\t\t}\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\tfor(int i=0;i<n;i++)if(cross(A, B, line[i][0], line[i][1]))l.add(cp(A, B, line[i][0], line[i][1], line[i][0].me, line[i][0].up));\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tif(l.size()>0){\n\t\t\t\tP h = l.get(0);\n//\t\t\t\tSystem.out.println(h.x+\" \"+h.y);\n\t\t\t\tboolean u = h.me?h.up:!h.up;\n\t\t\t\tfor(int i=1;i<l.size();i++){\n\t\t\t\t\th = l.get(i);\n//\t\t\t\t\tSystem.out.println(h.x+\" \"+h.y);\n\t\t\t\t\tif(h.me){\n\t\t\t\t\t\tif(h.up!=u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(h.up==u){\n\t\t\t\t\t\t\tres++; u=!u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic Point2D.Double a, b;\n\tstatic int n;\n\t\n\tstatic ArrayList<Point2D.Double> s, t;\n\tstatic int[] o, h;\n\t\n\tprivate static double cross(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn (a.x * b.y - a.y * b.x);\n\t}\n\t\n\tprivate static Point2D.Double add(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x + b.x, a.y + b.y);\n\t}\n\t\n\tprivate static Point2D.Double sub(Point2D.Double a, Point2D.Double b)\n\t{\n\t\treturn new Point2D.Double(a.x - b.x, a.y - b.y);\n\t}\n\t\n\tprivate static Point2D.Double mul(Point2D.Double a, double t)\n\t{\n\t\treturn new Point2D.Double(a.x * t, a.y * t);\n\t}\n\t\n\tprivate static Boolean isCrossing(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\treturn (cross(sub(a2, a1), sub(b1, a1)) * cross(sub(a2, a1), sub(b2, a1)) < 1e-10) &&\n\t\t\t   (cross(sub(b2, b1), sub(a1, b1)) * cross(sub(b2, b1), sub(a2, b1)) < 1e-10);\n\t}\n\t\n\tprivate static Point2D.Double crosspoint(Point2D.Double a1, Point2D.Double a2, Point2D.Double b1, Point2D.Double b2)\n\t{\n\t\tPoint2D.Double b = sub(b2, b1);\n\t\tdouble d1 = Math.abs( cross(b, sub(a1, b1)) );\n\t\tdouble d2 = Math.abs( cross(b, sub(a2, b1)) );\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn add(a1, mul(sub(a2, a1), t));\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\tint allnum = sca.nextInt();\n\t\t\n\t\tfor(;allnum > 0;allnum--)\n\t\t\t{\n\t\t\t\n\t\t\ta = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\tb = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\n\t\t\tn = sca.nextInt();\n\t\t\t\n\t\t\tint i, j, k;\n\t\t\tArrayList<Point2D.Double> crossp = new ArrayList<Point2D.Double>();\n\t\t\tdouble[] dis;\n\t\t\t\n\t\t\ts = new ArrayList<Point2D.Double>();\n\t\t\tt = new ArrayList<Point2D.Double>();\n\t\t\to = new int[n];\n\t\t\th = new int[n];\n\t\t\tcrossp = new ArrayList<Point2D.Double>();\n\t\t\tdis = new double[n];\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tPoint2D.Double ss = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tPoint2D.Double tt = new Point2D.Double(sca.nextDouble(), sca.nextDouble());\n\t\t\t\tint oo = sca.nextInt();\n\t\t\t\tint hh = sca.nextInt();\n\t\t\t\t\n\t\t\t\tif(isCrossing(a, b, ss, tt))\n\t\t\t\t{\n\t\t\t\t\ts.add(ss);\n\t\t\t\t\tt.add(tt);\n\t\t\t\t\to[i] = oo;\n\t\t\t\t\th[i] = hh;\n\t\t\t\t\t\n\t\t\t\t\tPoint2D.Double cp = crosspoint(a, b, ss, tt);\n\t\t\t\t\tcrossp.add(cp);\n\t\t\t\t\t\n\t\t\t\t\tdouble dx = a.x - cp.x;\n\t\t\t\t\tdouble dy = a.y - cp.y;\n\t\t\t\t\tdis[i] = Math.sqrt(dx*dx + dy*dy);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti--;\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(i = n;i > 0;i--)\n\t\t\t{\n\t\t\t\tfor(j = 0;j < (i - 1);j++)\n\t\t\t\t{\n\t\t\t\t\tif(dis[j] > dis[j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tdouble tmp;\n\t\t\t\t\t\ttmp = dis[j];    dis[j] = dis[j+1];    dis[j+1] = tmp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint tmpi;\n\t\t\t\t\t\ttmpi = o[j];     o[j] = o[j+1];    o[j+1] = tmpi;\n\t\t\t\t\t\ttmpi = h[j];     h[j] = h[j+1];    h[j+1] = tmpi;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint point = -1;\n\t\t\tint num = 0;\n\t\t\t\n\t\t\tfor(i = 0;i < n;i++)\n\t\t\t{\n\t\t\t\tif(i > 0)\n\t\t\t\t{\n\t\t\t\t\tif(Math.abs(dis[i] - dis[i-1]) < 1e-10) continue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(o[i] == 1)\n\t\t\t\t{\n\t\t\t\t\tif(h[i] == point) continue;\n\t\t\t\t\tnum++;\n\t\t\t\t\tpoint = h[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(h[i] != point) continue;\n\t\t\t\t\tnum++;\n\t\t\t\t\t\n\t\t\t\t\tif(h[i] == 0)\n\t\t\t\t\t\tpoint = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tpoint = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(num - 1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint N = nextInt();\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tP A = new P(nextInt(), nextInt());\n\t\t\tP B = new P(nextInt(), nextInt());\n\n\t\t\tint n = nextInt();\n\n\t\t\tGeo2D geo2d = new Geo2D();\n\n\t\t\tArrayList<CrossPoint> list = new ArrayList<CrossPoint>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tP S = new P(nextInt(), nextInt());\n\t\t\t\tP T = new P(nextInt(), nextInt());\n\n\t\t\t\tint o = nextInt();// 1ならば自社\n\t\t\t\tint l = nextInt();// 0ならば地下\n\n\t\t\t\tif (o == 0) {\n\t\t\t\t\t// 他社なら反転\n\t\t\t\t\tl = (l + 1) % 2;\n\t\t\t\t}\n\n\t\t\t\tif (geo2d.cross(A, B, S, T)) {\n\t\t\t\t\tP crossP = geo2d.intersection_ls(A, B, S, T);\n\t\t\t\t\tlist.add(new CrossPoint(crossP.x, crossP.y, l == 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(list);\n\n\t\t\tboolean now = true;\n\t\t\tP nowP = new P(-100000, -100000);\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tif (i != 0 && now != list.get(i).under) {\n\t\t\t\t\tdouble x = nowP.x - list.get(i).x;\n\t\t\t\t\tdouble y = nowP.y - list.get(i).y;\n\t\t\t\t\tdouble dist = Math.sqrt(x * x + y * y);\n\t\t\t\t\tif (dist > 1e-9) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnow = list.get(i).under;\n\t\t\t\tnowP.x = list.get(i).x;\n\t\t\t\tnowP.y = list.get(i).y;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass CrossPoint implements Comparable<CrossPoint> {\n\tdouble x, y;\n\tboolean under;// 地下ならtrue\n\tdouble EPS = 1e-9;\n\n\tpublic CrossPoint(double x, double y, boolean under) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.under = under;\n\t}\n\n\tpublic int compareTo(CrossPoint o) {\n\t\t// 基本x座標で昇順にソートしつつ、同じならy座標でソートする\n\t\tif (Math.abs(x - o.x) > EPS)\n\t\t\treturn (int) Math.signum(x - o.x);\n\t\telse\n\t\t\treturn (int) Math.signum(y - o.y);\n\t}\n}\n\nclass P implements Comparable<P> {\n\tdouble x, y;\n\tdouble EPS = 1e-9;\n\n\tpublic P(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int compareTo(P o) {\n\t\tif (Math.abs(x - o.x) > EPS)\n\t\t\treturn (int) Math.signum(x - o.x);\n\t\telse\n\t\t\treturn (int) Math.signum(y - o.y);\n\t}\n}\n\n// 平面幾何系ライブラリもどき\nclass Geo2D {\n\n\tdouble EPS = 1e-9;\n\n\t/* 線分abと線分stは交差するか */\n\tboolean cross(P a, P b, P s, P t) {\n\t\tif (ex(a, b, s) * ex(a, b, t) > 0)\n\t\t\treturn false;\n\t\tif (ex(b, a, s) * ex(b, a, t) > 0)\n\t\t\treturn false;\n\t\tif (ex(t, s, a) * ex(t, s, b) > 0)\n\t\t\treturn false;\n\t\treturn ex(s, t, a) * ex(s, t, b) < EPS;\n\t}\n\n\t/* ベクトルstとsrの外積 */\n\tdouble ex(P s, P t, P r) {\n\t\tdouble x1 = t.x - s.x;\n\t\tdouble y1 = t.y - s.y;\n\t\tdouble x2 = r.x - s.x;\n\t\tdouble y2 = r.y - s.y;\n\t\treturn x1 * y2 - x2 * y1;\n\t}\n\n\t// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\n\tP intersection_ls(P a1, P a2, P b1, P b2) {\n\t\tdouble d1 = Math.abs(ex(b1, a1, b2));\n\t\tdouble d2 = Math.abs(ex(b1, a2, b2));\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn new P(a1.x + (a2.x - a1.x) * t, a1.y + (a2.y - a1.y) * t);\n\t}\n\n\t/* 線分abと点Pの距離 */\n\tdouble dist(P a, P b, P p) {\n\t\tdouble x1 = b.x - a.x;\n\t\tdouble y1 = b.y - a.y;\n\t\tdouble x2 = p.x - a.x;\n\t\tdouble y2 = p.y - a.y;\n\t\treturn Math.abs((x1 * y2 - x2 * y1)) / Math.hypot(x1, y1);\n\t}\n\n\t/* 点pは線分ab上にあるかどうか */\n\tboolean on(P a, P b, P p) {\n\t\tif (Math.abs(a.x - b.x) < EPS)\n\t\t\treturn Math.min(a.y, b.y) <= p.y && p.y <= Math.max(a.y, b.y);\n\t\tdouble alpha = (b.y - a.y) / (b.x - a.x);\n\t\tdouble beta = a.y - alpha * a.x;\n\t\tif (Math.abs(p.y - (alpha * p.x + beta)) > EPS)\n\t\t\treturn false;\n\t\treturn Math.min(a.x, b.x) <= p.x && p.x <= Math.max(a.x, b.x);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Railroad Conflict\npublic class Main{\n\n\tfinal double EPS = 1e-8;\n\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tboolean intersectSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\treturn cross(sub(a2, a1), sub(b1, a1))*cross(sub(a2, a1), sub(b2, a1)) < EPS &&\n\t\tcross(sub(b2, b1), sub(a1, b1))*cross(sub(b2, b1), sub(a2, b1)) < EPS;\n\t}\n\tdouble[] crossPointSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\tif(!intersectSS(a1, a2, b1, b2))return null;\n\t\tdouble[] b = sub(b2, b1);\n\t\tdouble d1 = Math.abs(cross(b, sub(a1, b1)));\n\t\tdouble d2 = Math.abs(cross(b, sub(a2, b1)));\n\t\tdouble t = d1/(d1+d2);\n\t\tdouble[] a = sub(a2, a1);\n\t\treturn new double[]{a1[0]+a[0]*t, a1[1]+a[1]*t};\n\t}\n\n\tdouble[] A, B;\n\n\tclass P implements Comparable<P>{\n\t\tdouble[] p;\n\t\tboolean mine;\n\t\tboolean up;\n\t\tpublic P(double[] p, boolean mine, boolean up) {\n\t\t\tthis.p = p;\n\t\t\tthis.mine = mine;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tdouble d1 = norm(sub(p, A));\n\t\t\tdouble d2 = norm(sub(o.p, A));\n\t\t\treturn d1<d2?-1:d2<d1?1:0;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tA = new double[2];\n\t\t\tB = new double[2];\n\t\t\tA[0] = sc.nextDouble();\n\t\t\tA[1] = sc.nextDouble();\n\t\t\tB[0] = sc.nextDouble();\n\t\t\tB[1] = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\twhile(n--!=0){\n\t\t\t\tdouble[] s = new double[2];\n\t\t\t\tdouble[] t = new double[2];\n\t\t\t\ts[0] = sc.nextDouble();\n\t\t\t\ts[1] = sc.nextDouble();\n\t\t\t\tt[0] = sc.nextDouble();\n\t\t\t\tt[1] = sc.nextDouble();\n\t\t\t\tint o = sc.nextInt();\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tdouble[] r = crossPointSS(s, t, A, B);\n\t\t\t\tif(r==null)continue;\n\t\t\t\tl.add(new P(r, o==1, u==1));\n\t\t\t}\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tboolean f = true;\n\t\t\tboolean up = true;\n\t\t\tfor(P p:l){\n\t\t\t\tif(f){\n\t\t\t\t\tf = false;\n\t\t\t\t\tif(p.mine)up = p.up;\n\t\t\t\t\telse up = !p.up;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(p.mine && p.up!=up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!p.mine && p.up==up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Dist implements Comparable<Dist>{\n\t\tdouble dist;\n\t\tboolean must;\n\t\t\n\t\tpublic Dist(double dist, boolean must) {\n\t\t\tsuper();\n\t\t\tthis.dist = dist;\n\t\t\tthis.must = must;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Dist arg0) {\n\t\t\treturn Double.compare(this.dist, arg0.dist);\n\t\t}\n\t}\n\t\n\tfinal static int MAX = 24 * 60 * 60;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int t = sc.nextInt();\n\t\t\n\t\tfor(int tt = 0; tt < t; tt++){\n\t\t\tfinal int xa = sc.nextInt();\n\t\t\tfinal int ya = sc.nextInt();\n\t\t\tfinal int xb = sc.nextInt();\n\t\t\tfinal int yb = sc.nextInt();\n\t\t\t\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tPoint2D[] p_l = new Point2D[2];\n\t\t\tp_l[0] = new Point2D(xa, ya);\n\t\t\tp_l[1] = new Point2D(xb, yb);\n\t\t\t\n\t\t\tPoint2D[][] lines = new Point2D[N][2];\n\t\t\tboolean[] must = new boolean[N];\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfinal int xs = sc.nextInt();\n\t\t\t\tfinal int ys = sc.nextInt();\n\t\t\t\tfinal int xt = sc.nextInt();\n\t\t\t\tfinal int yt = sc.nextInt();\n\t\t\t\tfinal int o = sc.nextInt();\n\t\t\t\tfinal int l = sc.nextInt();\n\t\t\t\t\n\t\t\t\tlines[i][0] = new Point2D(xs, ys);\n\t\t\t\tlines[i][1] = new Point2D(xt, yt);\n\t\t\t\tmust[i] = o == 1 ? l == 1 : l == 0;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Dist> queue = new PriorityQueue<Dist>(); \n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tif(Point2D.intersect_s(p_l[0], p_l[1], lines[i][0], lines[i][1])){\n\t\t\t\t\tfinal double dist = Point2D.interpoint_s(p_l[0], p_l[1], lines[i][0], lines[i][1]).dist(p_l[0]);\n\t\t\t\t\t\n\t\t\t\t\tqueue.add(new Dist(dist, must[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean prev = false;\n\t\t\tboolean p_must = true;\n\t\t\tint changes = 0;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tDist dist = queue.poll();\n\t\t\t\t\n\t\t\t\tif(!prev){\n\t\t\t\t\tprev = true;\n\t\t\t\t}else if(p_must != dist.must){\n\t\t\t\t\tchanges++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp_must = dist.must;\n\t\t\t}\n\n\t\t\tSystem.out.println(changes);\n\t\t}\n\n\t}\n\n}\n\nclass Point2D{\n\tpublic double x;\n\tpublic double y;\n\n\tpublic static final double EPS = 1e-9;\n\n\tpublic Point2D(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\t\n\t//オマケ\n\tpublic Point2D(Point2D point) {\n\t\tthis.x = point.x;\n\t\tthis.y = point.y;\n\t}\n\n\t//オマケ\n\tpublic String toString() {\n\t\treturn x + \",\" + y;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (o instanceof Point2D) {\n\t\t\tPoint2D another = (Point2D) o;\n\t\t\t\n\t\t\tif(Point2D.eq(this.x, another.x) && Point2D.eq(this.y, another.y)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic Point2D add(Point2D another) {\n\t\tPoint2D ret = new Point2D(this);\n\t\tret.x += another.x;\n\t\tret.y += another.y;\n\t\treturn ret;\n\t}\n\t\n\tpublic Point2D minus(){\n\t\tPoint2D ret = new Point2D(this);\n\t\tret.x = -ret.x;\n\t\tret.y = -ret.y;\n\t\treturn ret;\n\t}\n\t\n\tpublic Point2D sub(Point2D another) {\n\t\treturn this.add(another.minus());\n\t}\n\n\tpublic Point2D mul(double d) {\n\t\tPoint2D ret = new Point2D(this);\n\t\tret.x *= d;\n\t\tret.y *= d;\n\t\treturn ret;\n\t}\n\n\tpublic Point2D div(double d) {\n\t\tPoint2D ret = new Point2D(this);\n\t\tret.x /= d;\n\t\tret.y /= d;\n\t\treturn ret;\n\t}\n\t\n\tpublic double dot(Point2D another) {\n\t\treturn this.x * another.x + this.y * another.y;\n\t}\n\n\tpublic double cross(double x, double y) {\n\t\treturn this.x * y - this.y * x;\n\t}\n\n\tpublic double cross(Point2D another) {\n\t\treturn this.x * another.y - this.y * another.x;\n\t}\n\t\n\tpublic double dist(Point2D another){\n\t\treturn Math.sqrt((this.x - another.x) * (this.x - another.x) +\n\t\t\t\t \t\t (this.y - another.y) * (this.y - another.y));\n\t}\n\n\tpublic double dist_o() {\n\t\tfinal Point2D ZERO = new Point2D(0, 0);\n\t\treturn this.dist(ZERO);\n\t}\n\n\tpublic Point2D unit() {\n\t\treturn this.div(this.dist_o());\n\t}\n\n\tpublic boolean pol(Point2D start, Point2D end) {\n\t\treturn end.sub(start).cross(this.sub(start)) < EPS;\n\t}\n\n\tpublic boolean pos(Point2D start, Point2D end) {\n\t\treturn (start.dist(this) + this.dist(end) < start.dist(end) + EPS);\n\t}\n\n\tpublic double pld(Point2D start, Point2D end) {\n\t\treturn Math.abs((end.sub(start).cross(this.sub(start)))\n\t\t\t\t/ end.sub(start).dist_o());\n\t}\n\n\tpublic double psd(Point2D start, Point2D end) {\n\t\tif (end.sub(start).dot(this.sub(start)) < EPS) {\n\t\t\treturn this.dist(start);\n\t\t} else if (start.sub(end).dot(this.sub(end)) < EPS) {\n\t\t\treturn this.dist(end);\n\t\t} else {\n\t\t\treturn Math.abs(end.sub(start).cross(this.sub(start)) / end.dist(start));\n\t\t}\n\t}\n\t\n\tpublic static int signum(double x){\n\t\treturn Math.abs(x) < EPS ? 0 : x > 0 ? 1 : -1;\n\t}\n\t\n\tpublic static boolean eq(double x, double y){\n\t\treturn signum(x - y) == 0;\n\t}\n\t\n\tpublic static int ccw(Point2D p, Point2D r, Point2D s){\n\t\tPoint2D a = r.sub(p);\n\t\tPoint2D b = s.sub(p);\n\t\t\n\t\tfinal int sgn = Point2D.signum(a.cross(b));\n\t\tif(sgn != 0){\n\t\t\treturn sgn;\n\t\t}else if(a.x * b.x < -EPS && a.y * b.y < -EPS){\n\t\t\treturn -1;\n\t\t}else if(a.dist_o() < b.dist_o() - EPS){\n\t\t\treturn 1;\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tpublic static boolean intersect_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn (Point2D.ccw(a1, a2, b1) * Point2D.ccw(a1, a2, b2) <= 0)\n\t\t\t\t&& (Point2D.ccw(b1, b2, a1) * Point2D.ccw(b1, b2, a2) <= 0);\n\t}\n\n\tpublic static boolean insersect_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\treturn a1.sub(a2).cross(b1.sub(b2)) < EPS;\n\t}\n\n\tpublic static Point2D interpoint_s(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble d1 = Math.abs(b.cross(a1.sub(b1)));\n\t\tdouble d2 = Math.abs(b.cross(a2.sub(b1)));\n\t\tdouble t = d1 / (d1 + d2);\n\t\tPoint2D a = a2.sub(a1), v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D interpoint_l(Point2D a1, Point2D a2, Point2D b1,\n\t\t\tPoint2D b2) {\n\t\tPoint2D a = a2.sub(a1);\n\t\tPoint2D b = b2.sub(b1);\n\t\tdouble t = b.cross(b1.sub(a1)) / b.cross(a);\n\t\tPoint2D v = a.mul(t);\n\t\treturn a1.add(v);\n\t}\n\n\tpublic static Point2D[] cross_ss(Point2D p1, double r1, Point2D p2,\n\t\t\tdouble r2) {\n\t\tdouble dis = p1.dist(p2);\n\n\t\tif (r1 + EPS > r2 && r1 - EPS < r2 && dis < EPS) {\n\t\t\treturn new Point2D[0]; // same\n\t\t}\n\n\t\tif (dis - EPS < r1 + r2 && dis + EPS > r1 + r2) {\n\t\t\tPoint2D tmp = p2.sub(p1);\n\t\t\ttmp = tmp.mul(r1 / tmp.dist_o());\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis + EPS > r1 + r2) {\n\t\t\treturn new Point2D[0]; // out\n\t\t}\n\n\t\tdouble dis_m = Math.abs(r1 - r2);\n\n\t\tif (dis_m + EPS > dis && dis_m - EPS < dis) {\n\t\t\tPoint2D tmp = null;\n\t\t\tif (r1 > r2) {\n\t\t\t\ttmp = p2.sub(p1);\n\t\t\t} else {\n\t\t\t\ttmp = p1.sub(p2);\n\t\t\t}\n\n\t\t\tdouble min = Math.min(r1, r2);\n\n\t\t\ttmp = tmp.mul((min + tmp.dist_o()) / tmp.dist_o());\n\n\t\t\tPoint2D ret[] = new Point2D[1];\n\t\t\tret[0] = p1.add(tmp);\n\t\t\treturn ret;\n\t\t} else if (dis_m + EPS > dis) {\n\t\t\treturn new Point2D[0]; // inner\n\t\t} else {\n\t\t\tPoint2D ret[] = new Point2D[2];\n\n\t\t\tdouble theta = Math.acos((dis * dis + r1 * r1 - r2 * r2)\n\t\t\t\t\t/ (2 * dis * r1));\n\t\t\tdouble a = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n\n\t\t\tret[0] = new Point2D(r1 * Math.cos(a + theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a + theta) + p1.y);\n\t\t\tret[1] = new Point2D(r1 * Math.cos(a - theta) + p1.x, r1\n\t\t\t\t\t* Math.sin(a - theta) + p1.y);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t\n\tpublic static double ss_dist(Point2D start1, Point2D end1, Point2D start2, Point2D end2){\n\t\tif(Point2D.intersect_s(start1, end1, start2, end2)){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\treturn Math.min(Math.min(Math.min(start1.psd(start2, end2), end1.psd(start2, end2)), start2.psd(start1, end1)), end2.psd(start1, end1));\n\t\t}\n\t}\n\t\n\tpublic void interpoint_lc(Point2D start, Point2D end, Point2D c, double r,\n\t\t\tPoint2D ans[]) {\n\t\tif (c.pld(start, end) > r + EPS)\n\t\t\treturn;\n\t\tPoint2D v = end.sub(start).unit();\n\t\tdouble delta = v.dot(start.sub(c)) * v.dot(start.sub(c))\n\t\t\t\t- start.dist(c) * start.dist(c) + r * r;\n\t\tdouble t = -v.dot(start.sub(c));\n\t\tdouble s = Math.sqrt(delta);\n\t\tans[0] = start.add(v.mul(t + s));\n\t\tans[1] = start.add(v.mul(t + s));\n\t}\n\n\tpublic Point2D normal_vector(Point2D p, Point2D a, Point2D b) {\n\t\tPoint2D v = b.sub(a).unit();\n\t\tv = v.cross(p.sub(a)) > 0 ? new Point2D(v.y, (-1) * v.x) : new Point2D(\n\t\t\t\t(-1) * v.y, v.x);\n\t\treturn v.mul(p.pld(a, b));\n\t}\n\n\tpublic double area(Point2D a, Point2D b, Point2D c) {\n\t\treturn Math.abs((c.sub(a).cross(b.sub(a))) * 0.5);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint N = nextInt();\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tP A = new P(nextInt(), nextInt());\n\t\t\tP B = new P(nextInt(), nextInt());\n\n\t\t\tint n = nextInt();\n\n\t\t\tGeo2D geo2d = new Geo2D();\n\n\t\t\tArrayList<CrossPoint> list = new ArrayList<CrossPoint>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tP S = new P(nextInt(), nextInt());\n\t\t\t\tP T = new P(nextInt(), nextInt());\n\n\t\t\t\tint o = nextInt();// 1ならば自社\n\t\t\t\tint l = nextInt();// 0ならば地下\n\n\t\t\t\tif (o == 0) {\n\t\t\t\t\t// 他社なら反転\n\t\t\t\t\tl = (l + 1) % 2;\n\t\t\t\t}\n\n\t\t\t\tif (geo2d.cross(A, B, S, T)) {\n\t\t\t\t\tP crossP = geo2d.intersection_ls(A, B, S, T);\n\t\t\t\t\tlist.add(new CrossPoint(crossP.x, l == 0));\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(list);\n\n\t\t\tboolean now = true;\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tif (i != 0 && now != list.get(i).under) {\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t\tnow = list.get(i).under;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\n\t\t}\n\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass CrossPoint implements Comparable<CrossPoint> {\n\tdouble x;\n\tboolean under;// 地下ならtrue\n\n\tpublic CrossPoint(double x, boolean under) {\n\t\tthis.x = x;\n\t\tthis.under = under;\n\t}\n\n\tpublic int compareTo(CrossPoint o) {\n\t\treturn (int) Math.signum(x - o.x);\n\t}\n}\n\nclass P implements Comparable<P> {\n\tdouble x, y;\n\tdouble EPS = 1e-9;\n\n\tpublic P(double x, double y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int compareTo(P o) {\n\t\tif (Math.abs(x - o.x) > EPS)\n\t\t\treturn (int) Math.signum(x - o.x);\n\t\telse\n\t\t\treturn (int) Math.signum(y - o.y);\n\t}\n}\n\n// 平面幾何系ライブラリもどき\nclass Geo2D {\n\n\tdouble EPS = 1e-9;\n\n\t/* 線分abと線分stは交差するか */\n\tboolean cross(P a, P b, P s, P t) {\n\t\tif (ex(a, b, s) * ex(a, b, t) > 0)\n\t\t\treturn false;\n\t\tif (ex(b, a, s) * ex(b, a, t) > 0)\n\t\t\treturn false;\n\t\tif (ex(t, s, a) * ex(t, s, b) > 0)\n\t\t\treturn false;\n\t\treturn ex(s, t, a) * ex(s, t, b) < EPS;\n\t}\n\n\t/* ベクトルstとsrの外積 */\n\tdouble ex(P s, P t, P r) {\n\t\tdouble x1 = t.x - s.x;\n\t\tdouble y1 = t.y - s.y;\n\t\tdouble x2 = r.x - s.x;\n\t\tdouble y2 = r.y - s.y;\n\t\treturn x1 * y2 - x2 * y1;\n\t}\n\n\t// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\n\tP intersection_ls(P a1, P a2, P b1, P b2) {\n\t\tdouble d1 = Math.abs(ex(b1, a1, b2));\n\t\tdouble d2 = Math.abs(ex(b1, a2, b2));\n\t\tdouble t = d1 / (d1 + d2);\n\t\treturn new P(a1.x + (a2.x - a1.x) * t, a1.y + (a2.y - a1.y) * t);\n\t}\n\n\t/* 線分abと点Pの距離 */\n\tdouble dist(P a, P b, P p) {\n\t\tdouble x1 = b.x - a.x;\n\t\tdouble y1 = b.y - a.y;\n\t\tdouble x2 = p.x - a.x;\n\t\tdouble y2 = p.y - a.y;\n\t\treturn Math.abs((x1 * y2 - x2 * y1)) / Math.hypot(x1, y1);\n\t}\n\n\t/* 点pは線分ab上にあるかどうか */\n\tboolean on(P a, P b, P p) {\n\t\tif (Math.abs(a.x - b.x) < EPS)\n\t\t\treturn Math.min(a.y, b.y) <= p.y && p.y <= Math.max(a.y, b.y);\n\t\tdouble alpha = (b.y - a.y) / (b.x - a.x);\n\t\tdouble beta = a.y - alpha * a.x;\n\t\tif (Math.abs(p.y - (alpha * p.x + beta)) > EPS)\n\t\t\treturn false;\n\t\treturn Math.min(a.x, b.x) <= p.x && p.x <= Math.max(a.x, b.x);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Railroad Conflict\npublic class Main{\n\n\tfinal double EPS = 1e-10;\n\n\tdouble norm(double[] a){\n\t\treturn Math.hypot(a[0], a[1]);\n\t}\n\tdouble[] sub(double[] a, double[] b){\n\t\treturn new double[]{a[0]-b[0], a[1]-b[1]};\n\t}\n\tdouble cross(double[] a, double[] b){\n\t\treturn a[0]*b[1]-a[1]*b[0];\n\t}\n\tboolean intersectSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\treturn cross(sub(a2, a1), sub(b1, a1))*cross(sub(a2, a1), sub(b2, a1)) < EPS &&\n\t\tcross(sub(b2, b1), sub(a1, b1))*cross(sub(b2, b1), sub(a2, b1)) < EPS;\n\t}\n\tdouble[] crossPointSS(double[] a1, double[] a2, double[] b1, double[] b2){\n\t\tif(!intersectSS(a1, a2, b1, b2))return null;\n\t\tdouble[] b = sub(b2, b1);\n\t\tdouble d1 = Math.abs(cross(b, sub(a1, b1)));\n\t\tdouble d2 = Math.abs(cross(b, sub(a2, b1)));\n\t\tdouble t = d1/(d1+d2);\n\t\tdouble[] a = sub(a2, a1);\n\t\treturn new double[]{a1[0]+a[0]*t, a1[1]+a[1]*t};\n\t}\n\n\tdouble[] A, B;\n\n\tclass P implements Comparable<P>{\n\t\tdouble[] p;\n\t\tboolean mine;\n\t\tboolean up;\n\t\tpublic P(double[] p, boolean mine, boolean up) {\n\t\t\tthis.p = p;\n\t\t\tthis.mine = mine;\n\t\t\tthis.up = up;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tdouble d1 = norm(sub(p, A));\n\t\t\tdouble d2 = norm(sub(o.p, A));\n\t\t\treturn d1<d2+EPS?-1:d2<d1+EPS?1:0;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tA = new double[2];\n\t\t\tB = new double[2];\n\t\t\tA[0] = sc.nextDouble();\n\t\t\tA[1] = sc.nextDouble();\n\t\t\tB[0] = sc.nextDouble();\n\t\t\tB[1] = sc.nextDouble();\n\t\t\tint n = sc.nextInt();\n\t\t\tList<P> l = new ArrayList<P>();\n\t\t\twhile(n--!=0){\n\t\t\t\tdouble[] s = new double[2];\n\t\t\t\tdouble[] t = new double[2];\n\t\t\t\ts[0] = sc.nextDouble();\n\t\t\t\ts[1] = sc.nextDouble();\n\t\t\t\tt[0] = sc.nextDouble();\n\t\t\t\tt[1] = sc.nextDouble();\n\t\t\t\tint o = sc.nextInt();\n\t\t\t\tint u = sc.nextInt();\n\t\t\t\tdouble[] r = crossPointSS(s, t, A, B);\n\t\t\t\tif(r==null)continue;\n\t\t\t\tl.add(new P(r, o==1, u==1));\n\t\t\t}\n\t\t\tCollections.sort(l);\n\t\t\tint res = 0;\n\t\t\tboolean f = true;\n\t\t\tboolean up = true;\n\t\t\tfor(P p:l){\n\t\t\t\tif(f){\n\t\t\t\t\tf = false;\n\t\t\t\t\tif(p.mine)up = p.up;\n\t\t\t\t\telse up = !p.up;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(p.mine && p.up!=up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(!p.mine && p.up==up){\n\t\t\t\t\t\tup = p.up;\n\t\t\t\t\t\tres++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Xml.Xsl;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n\tclass Program {\n\t\tstatic void Main(string[] args) {\n\t\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush=\n#if DEBUG\n\t\t\ttrue\n#else\n\t\t\tfalse\n#endif\n\t\t\t};\n\t\t\tConsole.SetOut(sw);\n\t\t\tnew Program().Solve(new ConsoleInput(\n#if DEBUG\n\t\t\tnew StreamReader(\"../../../inputData.txt\")\n#else\n\t\t\tConsole.In\n#endif\n\t\t\t, ' '));\n\t\t\tConsole.Out.Flush();\n\t\t}\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\tvar dataSetCount = cin.ReadInt;\n\t\t\tfor(int dataSet = 0; dataSet<dataSetCount; dataSet++) {\n\t\t\t\tvar dat = cin.ReadLine.Split(' ').Take(4).Select(int.Parse).ToArray();\n\t\t\t\tvar A = new Point(dat[0], dat[1]);\n\t\t\t\tvar B = new Point(dat[2], dat[3]);\n\t\t\t\tvar newRoad = new Railway(A, B, false, false);\n\t\t\t\tvar N = cin.ReadInt;\n\t\t\t\tvar oldRails = new Railway[N];\n\t\t\t\tvar doesCross = new bool[N];\n\t\t\t\tvar dist = new decimal[N];\n\t\t\t\tfor(int i = 0; i<N; i++) {\n\t\t\t\t\tvar datum = cin.ReadIntArray(6);\n\t\t\t\t\tvar start = new Point(datum[0], datum[1]);\n\t\t\t\t\tvar end = new Point(datum[2], datum[3]);\n\t\t\t\t\tvar own = datum[4]==1;\n\t\t\t\t\tvar inf = datum[5]==0;\n\t\t\t\t\toldRails[i]=new Railway(start, end, own, inf);\n\t\t\t\t\tdoesCross[i]=Railway.isIntersect(newRoad, oldRails[i]);\n\t\t\t\t\tdist[i]=!doesCross[i] ? -1 : Point.outer(start-A, end-A)/Point.outer(B-A, end-start);\n\t\t\t\t}\n\t\t\t\tvar Order = doesCross.Indices().Where(i => doesCross[i]).OrderBy(i => dist[i]);\n\t\t\t\tif(!Order.Any()) {\n\t\t\t\t\tConsole.WriteLine(0);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvar turn = 0;\n\t\t\t\tvar firstOpponent = oldRails[Order.First()];\n\t\t\t\tvar nowInfra = firstOpponent.infra==firstOpponent.friend;\n\t\t\t\tforeach(var j in Order.Skip(1)) {\n\t\t\t\t\tvar rail = oldRails[j];\n\t\t\t\t\tif((nowInfra==rail.infra)^rail.friend) {\n\t\t\t\t\t\tnowInfra^=true;\n\t\t\t\t\t\tturn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(turn);\n\t\t\t}\n\t\t}\n\t\tstruct Railway {\n\t\t\tpublic Point start { get; set; }\n\t\t\tpublic Point end { get; set; }\n\t\t\tpublic bool friend { get; set; }\n\t\t\tpublic bool infra { get; set; }\n\t\t\tpublic Railway(Point ss, Point ee, bool ff, bool ii) {\n\t\t\t\tstart=ss; end=ee; friend=ff; infra=ii;\n\t\t\t}\n\t\t\tpublic static bool isIntersect(Railway A, Railway B) {\n\t\t\t\tPoint a1 = A.start, a2 = A.end, b1 = B.start, b2 = B.end;\n\t\t\t\tvar parallel = Point.outer(a2-a1, b2-b1)==0m;\n\t\t\t\tif(parallel) {\n\t\t\t\t\tvar willIntersect = Point.outer(a2-a1, b1-a1)==0m;\n\t\t\t\t\tif(!willIntersect) return false;\n\t\t\t\t\tvar k1 = Point.inner(b1-a1, b1-a2);\n\t\t\t\t\tvar k2 = Point.inner(b2-a1, b2-a2);\n\t\t\t\t\tif(k1<=0||k2<=0) return true;\n\t\t\t\t\tvar l1 = Point.inner(a1-b1, a1-b2);\n\t\t\t\t\tvar l2 = Point.inner(a2-b1, a2-b2);\n\t\t\t\t\treturn l1<=0||l2<=0;\n\t\t\t\t} else {\n\t\t\t\t\treturn Point.outer(b1-a1, a2-a1)*Point.outer(b2-a2, a1-a2)>=0\n\t\t\t\t\t&&Point.outer(a1-b1, b2-b1)*Point.outer(a2-b2, b1-b2)>=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static void Swap<T>(this T[] A, int x, int y) {\n\t\t\tvar tmp = A[x];\n\t\t\tA[x]=A[y];\n\t\t\tA[y]=tmp;\n\t\t}\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t\tpublic static IEnumerable<int> Indices<T>(this T[] X) => Enumerable.Range(0, X.Length);\n\t\tpublic static IEnumerable<int> Indices<T>(this T[,] X, int dim)\n\t\t\t=> Enumerable.Range(0, X.GetLength(dim));\n\t\tpublic static string Join<T>(this T[,] X, string separatorD2 = \",\", string separatorD1 = \"\\n\")\n\t\t\t=> X.Indices(0).Select(\n\t\t\t\ti => X.Indices(1).Select(j => X[i, j]).Join(separatorD2)\n\t\t\t).Join(separatorD1);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator=separator;\n\t\t\tthis._stream=stream;\n\t\t\tinputStream=new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count!=0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i<tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i<N; ++i)\n\t\t\t\tret[i]=Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i<N; ++i) ret[i]=ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i<N; ++i) ret[i]=ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i<N; ++i) ret[i]=ReadDouble; return ret; }\n\t\tpublic bool isEOF {\n\t\t\tget { return _stream.Peek()==-1; }\n\t\t}\n\t}\n\tpublic struct Point {\n\t\tpublic decimal x { get; set; }\n\t\tpublic decimal y { get; set; }\n\t\tpublic Point(decimal xx, decimal yy) { x=xx; y=yy; }\n\t\tpublic static Point operator -(Point a, Point b) => new Point(a.x-b.x, a.y-b.y);\n\t\tpublic static decimal outer(Point a, Point b) => a.x*b.y-b.x*a.y;\n\t\tpublic static decimal inner(Point a, Point b) => a.x*b.x+a.y*b.y;\n\t\tpublic decimal Abs2() => x*x+y*y;\n\t\tpublic override string ToString() => $\"({x}, {y})\";\n\t}\n}\n"
  },
  {
    "language": "Ruby",
    "code": "### classes\n\nclass Pt\n  attr_accessor :x, :y\n\n  def initialize() end\n  def initialize(x, y) @x = x; @y = y end\n\n  def ==(pt) @x == pt.x && @y == pt.y end\n  def +(pt) Pt.new(@x + pt.x, @y + pt.y) end\n  def -(pt) Pt.new(@x - pt.x, @y - pt.y) end\n  def -@() Pt.new(-@x, -@y) end\n  def *(t) Pt.new(@x * t, @y * t) end\n  def /(t) Pt.new(@x / t, @y / t) end\n  def dot(v) @x * v.x + @y * v.y end\n  def cross(v) @x * v.y - @y * v.x end\n  def d2() @x * @x + @y * @y end\n  def d() Math.sqrt(d2()) end\n  def to_s() \"(#{@x},#{@y})\" end\nend\n\n### subroutines\n\ndef cross_segs(a0, a1, b0, b1)\n  av = a1 - a0\n  bv = b1 - b0\n  cr01 = av.cross(bv)\n  return nil if cr01 == 0.0\n\n  ab = b0 - a0\n  cr0 = ab.cross(av)\n  cr1 = ab.cross(bv)\n\n  t0 = cr1 / cr01\n  t1 = cr0 / cr01\n\n  cl = av * t0 + a0\n  #p [ap.to_s, av.to_s, bp.to_s, bv.to_s, cl.to_s]\n  return nil if t0 < 0.0 || t0 > 1.0 || t1 < 0.0 || t1 > 1.0\n  [cl, t0]\nend\n\n### main\n\ngets.to_i.times do\n  xa, ya, xb, yb = gets.split.map(&:to_f)\n  pta = Pt.new(xa, ya)\n  ptb = Pt.new(xb, yb)\n  \n  n = gets.to_i\n\n  lns = []\n  for i in (0...n)\n    x0, y0, x1, y1, oi, li = gets.split.map(&:to_i)\n    lns << [Pt.new(x0.to_f, y0.to_f), Pt.new(x1.to_f, y1.to_f), oi, li]\n  end\n  #p lns\n  \n  cts = []\n\n  for i in (0...n)\n    pt0, pt1, oi, li = lns[i]\n    csg = cross_segs(pta, ptb, pt0, pt1)\n    if csg\n      cts << [csg[1], (oi ^ 1) ^ li]\n    end\n  end\n  cts.sort!\n  #p cts\n\n  count = 0\n  if cts.length > 1\n    prvl = cts[0][1]\n    for i in (1...cts.length)\n      count += 1 if prvl != cts[i][1]\n      prvl = cts[i][1]\n    end\n  end\n\n  puts count\nend"
  },
  {
    "language": "Ruby",
    "code": "class Line\n\trequire 'matrix'\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\treturn (m.inv * v).to_a\n\tend\n\n\tdef cross?(l)\n\t\t(@a * l.x1 + @b * l.y1 - @c) * (@a * l.x2 + @b * l.y2 - @c) < 0 &&\n\t\t(l.a * @x1 + l.b * @y1 - l.c) * (l.a * @x2 + l.b * @y2 - l.c) < 0\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\nt = gets.to_i\nt.times do\n\tnl = Line.through_two_points(*gets.split.map(&:to_i))\n\tn = gets.to_i\n\tarr = []\n\t(1..n).each do\n\t\tx1, y1, x2, y2, a, b = gets.split.map(&:to_i)\n\t\tl = Line.through_two_points(x1, y1, x2, y2)\n\t\tnext if !nl.cross?(l)\n\t\tarr << [*nl.cross_point(l), a ^ b]\n\tend\n\tif arr.size < 2\n\t\tp 0\n\telse\n\t\tp arr.sort.map(&:last).each_cons(2).map{|x, y| x ^ y}.inject(:+)\n\tend\nend"
  },
  {
    "language": "Ruby",
    "code": "ERROR = 1e-5\n\ninclude Math\nclass Line\n\trequire 'matrix'\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef cross_point(l)\n\t\tm = Matrix[\n\t\t\t[@a, @b],\n\t\t\t[l.a, l.b],\n\t\t];\n\t\tv = Vector[@c, l.c]\n\t\t(m.inv * v).to_a\n\tend\n\n\tdef include?(x, y)\n\t\t(@a * x + @b * y - c).abs < ERROR && \n\t\t(x - @x1) * (x - @x2) <= ERROR &&\n\t\t(y - @y1) * (y - @y2) <= ERROR\n\tend\n\n\tdef parallel?(l)\n\t\t(@a * l.b - @b * l.a).abs < ERROR\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c\nend\n\nt = gets.to_i\nt.times do\n\tnl = Line.through_two_points(*gets.split.map(&:to_i))\n\tn = gets.to_i\n\tarr = []\n\t(1..n).each do\n\t\tx1, y1, x2, y2, a, b = gets.split.map(&:to_i)\n\t\tl = Line.through_two_points(x1, y1, x2, y2)\n\t\tnext if nl.parallel?(l)\n\t\tcx, cy = nl.cross_point(l)\n\t\tarr << [cx, cy, a ^ b] if nl.include?(cx, cy)\t\t\n\tend\n\tp arr.sort.map(&:last).each_cons(2).map{|x, y| x ^ y}.inject(:+)\nend"
  },
  {
    "language": "Ruby",
    "code": "def contact(a,b)\n\tax,ay,bx,by = a\n\tcx,cy,dx,dy = b\n\td = (bx-ax)*(dy-cy)-(by-ay)*(dx-cx)\n\tacx = cx-ax\n\tacy = cy-ay\n\tif d == 0\n\t\tnil\n\telse\n\t\tr = ((dy-cy)*acx-(dx-cx)*acy)/d\n\t\ts = ((by-ay)*acx-(bx-ax)*acy)/d\n\t\tif (0.0..1.0).include? r and (0.0..1.0).include? s\n\t\t\t[ax+(bx-ax)*r,ay+(by-ay)*r]\n\t\telse\n\t\t\tnil\n\t\tend\n\tend\nend\n\ngets.to_i.times {\n\tline = gets.split(\" \").map(&:to_f)\n\tp Enumerator.new {|y|\n\t\tsx,sy = line\n\t\tgets.to_i.times {\n\t\t\trail = gets.split(\" \").map(&:to_f)\n\t\t\tif !(p = contact(rail,line)).nil?\n\t\t\t\tdx , dy = p\n\t\t\t\t_,_,_,_,o,l = rail\n\t\t\t\tarr = [[1,0],[0,1]]\n\t\t\t\ty << [(sx-dx)**2 + (sy-dy)**2,arr[o][l]]\n\t\t\tend\n\t\t}\n\t}.sort {|a,b|\n\t\ta[0] <=> b[0]\n\t}.each_cons(2).count {|a,b|\n\t\ta[1]!=b[1]\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\n\ndef cross(p)\n  x0 = (p[2] - p[0]).to_f\n  y0 = (p[3] - p[1]).to_f\n  x1 = (p[6] - p[4]).to_f\n  y1 = (p[7] - p[5]).to_f\n  x2 = (p[4] - p[0]).to_f\n  y2 = (p[5] - p[1]).to_f\n  r = (y1 * x2 - x1 * y2) / (x0 * y1 - x1 * y0)\n  s = (y0 * x2 - x0 * y2) / (x0 * y1 - x1 * y0)\n  p[0] + r * (p[2] - p[0]) if r > -EPS && r < 1.0 + EPS && s > -EPS && s < 1.0 + EPS\nend\n\ngets.to_i.times do\n  xa, ya ,xb, yb = gets.split.map(&:to_i)\n  arr = []\n  gets.to_i.times do\n    xc, yc, xd, yd, o, l = gets.split.map(&:to_i)\n    px = cross([xa, ya, xb, yb, xc, yc, xd, yd])\n    arr << [px, o, l] unless px.nil?\n  end\n  arr.sort!\n  _, so, sl = arr.shift\n  cl = (so == 1 ? sl : 1 - sl)\n  p arr.reduce(0){ |cnt, (_, o, l)|\n    if o != 1 && cl == l\n      cl = 1 - cl; cnt + 1\n    elsif o == 1 && cl != l\n      cl = l; cnt + 1\n    else cnt\n    end\n  }\nend"
  },
  {
    "language": "Ruby",
    "code": "def contact(a,b)\n\tax,ay,bx,by = a\n\tcx,cy,dx,dy = b\n\td = (bx-ax)*(dy-cy)-(by-ay)*(dx-cx)\n\tacx = cx-ax\n\tacy = cy-ay\n\tif d == 0\n\t\tnil\n\telse\n\t\tr = ((dy-cy)*acx-(dx-cx)*acy)/d\n\t\ts = ((by-ay)*acx-(bx-ax)*acy)/d\n\t\tif (0..1).include? r and (0..1).include? s\n\t\t\t[ax+(bx-ax)*r,ay+(by-ay)*r]\n\t\telse\n\t\t\tnil\n\t\tend\n\tend\nend\n\ngets.to_i.times {\n\tline = gets.split(\" \").map(&:to_f)\n\tp Enumerator.new {|y|\n\t\tsx,sy = line\n\t\tgets.to_i.times {\n\t\t\trail = gets.split(\" \").map(&:to_f)\n\t\t\tif !(p = contact(rail,line)).nil?\n\t\t\t\tdx , dy = p\n\t\t\t\t_,_,_,_,o,l = rail\n\t\t\t\tarr = [[1,0],[0,1]]\n\t\t\t\ty << [(sx-dx)**2 + (sy-dx)**2,arr[o][l]]\n\t\t\tend\n\t\t}\n\t}.sort {|a,b|\n\t\ta[0] <=> b[0]\n\t}.each_cons(2).count {|a,b|\n\t\ta[1]!=b[1]\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "EPS = 1e-9\n\ndef cross(p)\n  x0 = (p[2] - p[0]).to_f\n  y0 = (p[3] - p[1]).to_f\n  x1 = (p[6] - p[4]).to_f\n  y1 = (p[7] - p[5]).to_f\n  x2 = (p[4] - p[0]).to_f\n  y2 = (p[5] - p[1]).to_f\n  r = (y1 * x2 - x1 * y2) / (x0 * y1 - x1 * y0)\n  s = (y0 * x2 - x0 * y2) / (x0 * y1 - x1 * y0)\n  p[0] + r * (p[2] - p[0]) if r > -EPS && r < 1.0 + EPS && s > -EPS && s < 1.0 + EPS\nend\n\ngets.to_i.times do\n  xa, ya ,xb, yb = gets.split.map(&:to_i)\n  arr = []\n  gets.to_i.times do\n    xc, yc, xd, yd, o, l = gets.split.map(&:to_i)\n    px = cross([xa, ya, xb, yb, xc, yc, xd, yd])\n    arr << [px, o, l] unless px.nil?\n  end\n  unless arr.empty?\n    arr.sort!\n    _, so, sl = arr.shift\n    cl = (so == 1 ? sl : 1 - sl)\n  end\n  p arr.reduce(0){ |cnt, (_, o, l)|\n    if o != 1 && cl == l\n      cl = 1 - cl; cnt + 1\n    elsif o == 1 && cl != l\n      cl = l; cnt + 1\n    else cnt\n    end\n  }\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\nimport std.string;\nimport std.range;\nimport std.array;\nimport std.conv;\nimport std.complex;\nimport std.math;\nimport std.ascii;\nimport std.bigint;\nimport std.container;\nimport std.typecons;\n\nint cross(int[] a, int[] b) {\n\treturn a[0]*b[1]-a[1]*b[0];\n}\nint dot(int[] a, int[] b){\n\treturn a[0]*b[0]+a[1]*b[1];\n}\n\ndouble[] crosspoint(int[] a, int[] b, int[] c, int[] d) {\n\tauto n = [a[1]-b[1], b[0]-a[0]];\n\tint[2] bd = b[]-d[];\n\tint[2] cb = c[]-b[];\n\tint[2] cd = c[]-d[];\n\tint tmp[2] = dot(n, bd)*c.dup[]+dot(n, cb)*d.dup[];\n\tdouble div = dot(n, cd);\n\treturn [tmp[0]/div, tmp[1]/div];\n}\nbool isCross(int[]a, int[] b, int[] c, int[] d){\n\tint[2][4] v;\n\tv[0] = a.dup[]-c[];\n\tv[1] = c.dup[]-b[];\n\tv[2] = b.dup[]-d[];\n\tv[3] = d.dup[]-a[];\n\tint s1, s2;\n\tforeach(i; 0..4) {\n\t\ts1 += cross(v[i], v[(i+1)%4]);\n\t\ts2 += abs(cross(v[i], v[(i+1)%4]));\n\t}\n\treturn abs(s1) == s2;\n}\n\nalias Tuple!(double[], \"p\", int, \"o\", int, \"l\") T;\n\nvoid main() {\n\tint m = to!int(readln().strip());\n\tforeach(_1 ; 0..m) {\n\t\tauto s = map!(to!int)(readln().strip().split());\n\t\tint[] a = [s[0], s[1]];\n\t\tint[] b = [s[2], s[3]];\n\t\tint n = to!int(readln().strip());\n\n\t\tT[] t;\n\t\tforeach(_2; 0..n) {\n\t\t\tauto si = map!(to!int)(readln().strip().split());\n\t\t\tauto c = array(si[0..2]);\n\t\t\tauto d = array(si[2..4]);\n\t\t\tif(isCross(a, b, c,d)){\n\t\t\t\tt ~= T(crosspoint(a,b,c,d), si[4], si[5]);\n\t\t\t}\n\t\t}\n\t\tif(a[0] != b[0]){\n\t\t\tt.sort!(\"a.p[0] < b.p[0]\")();\n\t\t} else {\n\t\t\tt.sort!(\"a.p[1] < b.p[1]\")();\n\t\t}\n\t\tauto l = [0,1];\n\t\tauto ans = [0,0];\n\t\tforeach(ti; t) {\n\t\t\tforeach(i; 0..2){\n\t\t\t\tif((ti.o == 0 && ti.l == l[i]) || (ti.o == 1 && ti.l != l[i])){\n\t\t\t\t\tl[i] ^= 1;\n\t\t\t\t\t++ans[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twriteln(reduce!min(ans));\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) const {\n        static if (op == \"+\" || op == \"-\") {\n            return Point(mixin(\"x\" ~ op ~ \"a.x\"),\n                         mixin(\"y\" ~ op ~ \"a.y\"));\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\" || op == \"/\") {\n            return Point(mixin(\"x\" ~ op ~ \"a\"),\n                         mixin(\"y\" ~ op ~ \"a\"));\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nint CCW(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (b.norm < c.norm) return -2;\n    return 0;\n}\n\nstruct Segment {\n    Point a, b;\n}\nbool intersect(in Segment s, in Segment t) {\n    return CCW(s.a, s.b, t.a) * CCW(s.a, s.b, t.b) <= 0 &&\n        CCW(t.a, t.b, s.a) * CCW(t.a, t.b, s.b) <= 0;\n}\nPoint intersection(in Segment s, in Segment t) {\n    double d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * (cross(t.b - t.a, t.b - s.a) / d);\n}\n\nSegment S;\nSegment[] T;\nint N;\nint[] W;\nvoid input() {\n    scanf(\"%lf %lf %lf %lf\\n\", &S.a.x, &S.a.y, &S.b.x, &S.b.y);\n    scanf(\"%d\\n\", &N);\n    T = new Segment[N];\n    W = new int[N];\n    foreach (i; 0 .. N) {\n        scanf(\"%lf %lf %lf %lf\", &T[i].a.x, &T[i].a.y, &T[i].b.x, &T[i].b.y);\n        int o, l;\n        scanf(\"%d %d\\n\", &o, &l);\n        W[i] = (o ^ l);\n    }\n}\n\nvoid solve() {\n    alias Tuple!(Point, int) Z;\n    Z[] ips;\n    foreach (i; 0 .. N) {\n        if (S.intersect(T[i])) {\n            ips ~= Z(S.intersection(T[i]), W[i]);\n        }\n    }\n    ips.sort!\"a[0].x < b[0].x\";\n    int ans = 0;\n    int prev = ips[0][1];\n    foreach (i; ips[1 .. $].map!(\"a[1]\")) {\n        if (i == prev) continue;\n        prev = i;\n        ans++;\n    }\n    ans.writeln;\n}\n \nvoid main() {\n    int T; scanf(\"%d\\n\", &T);\n    foreach (t; 0 .. T) {\n        input;\n        solve;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point opBinary(string op)(in Point a) const {\n        static if (op == \"+\" || op == \"-\") {\n            return Point(mixin(\"x\" ~ op ~ \"a.x\"),\n                         mixin(\"y\" ~ op ~ \"a.y\"));\n        }\n    }\n    Point opBinary(string op)(double a) const {\n        static if (op == \"*\" || op == \"/\") {\n            return Point(mixin(\"x\" ~ op ~ \"a\"),\n                         mixin(\"y\" ~ op ~ \"a\"));\n        }\n    }\n}\ndouble dot(in Point a, in Point b) {\n    return a.x * b.x + a.y * b.y;\n}\ndouble cross(in Point a, in Point b) {\n    return a.x * b.y - a.y * b.x;\n}\ndouble norm(in Point a) {\n    return sqrt(a.x * a.x + a.y * a.y);\n}\nint CCW(Point a, Point b, Point c) {\n    b = b - a; c = c - a;\n    if (cross(b, c) > EPS) return +1;\n    if (cross(b, c) < -EPS) return -1;\n    if (dot(b, c) < 0) return 2;\n    if (b.norm < c.norm) return -2;\n    return 0;\n}\n\nstruct Segment {\n    Point a, b;\n}\nbool intersect(in Segment s, in Segment t) {\n    return CCW(s.a, s.b, t.a) * CCW(s.a, s.b, t.b) <= 0 &&\n        CCW(t.a, t.b, s.a) * CCW(t.a, t.b, s.b) <= 0;\n}\nPoint intersection(in Segment s, in Segment t) {\n    double d = cross(t.b - t.a, s.b - s.a);\n    assert(abs(d) >= EPS);\n    return s.a + (s.b - s.a) * (cross(t.b - t.a, t.b - s.a) / d);\n}\n\nSegment S;\nSegment[] T;\nint N;\nint[] W;\nvoid input() {\n    scanf(\"%lf %lf %lf %lf\\n\", &S.a.x, &S.a.y, &S.b.x, &S.b.y);\n    scanf(\"%d\\n\", &N);\n    T = new Segment[N];\n    W = new int[N];\n    foreach (i; 0 .. N) {\n        scanf(\"%lf %lf %lf %lf\", &T[i].a.x, &T[i].a.y, &T[i].b.x, &T[i].b.y);\n        int o, l;\n        scanf(\"%d %d\\n\", &o, &l);\n        W[i] = (o ^ l);\n    }\n}\n\nvoid solve() {\n    alias Tuple!(Point, int) Z;\n    Z[] ips;\n    foreach (i; 0 .. N) {\n        if (S.intersect(T[i])) {\n            ips ~= Z(S.intersection(T[i]), W[i]);\n        }\n    }\n    ips.sort!\"a[0].x < b[0].x\";\n    int ans = 0;\n    if (ips.length <= 1) {\n        ans = 0;\n    } else {\n        int prev = ips[0][1];\n        foreach (i; ips[1 .. $].map!(\"a[1]\")) {\n            if (i == prev) continue;\n            prev = i;\n            ans++;\n        }\n    }\n    ans.writeln;\n}\n \nvoid main() {\n    int T; scanf(\"%d\\n\", &T);\n    foreach (t; 0 .. T) {\n        input;\n        solve;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef intersection(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)\n    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n    ramda = ksi / delta;\n    mu = eta / delta;\n    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:\n        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))\n\n    return None\n\ndef main():\n    rr = []\n\n    n = I()\n    ni = 0\n\n    while ni < n:\n        ni += 1\n        xa,ya,xb,yb = LI()\n        a1 = (xa,ya)\n        a2 = (xb,yb)\n        m = I()\n        a = [LI() for _ in range(m)]\n        t = []\n        for xs,ys,xt,yt,o,l in a:\n            k = intersection(a1,a2,(xs,ys),(xt,yt))\n            if k is None:\n                continue\n            t.append((k,o^l))\n        if len(t) == 0:\n            rr.append(0)\n            continue\n\n        t.sort()\n        c = t[0][1]\n        r = 0\n        for _,tc in t:\n            if tc != c:\n                r += 1\n                c = tc\n\n        rr.append(r)\n\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "for i in range(int(input())):\n    xa, ya, xb, yb = map(int, input().split())\n    n = int(input())\n    ip = []\n    for j in range(n):\n        xs, ys, xt, yt, o, l = map(int, input().split())\n        d = (xb - xa) * (yt - ys) - (yb - ya) * (xt - xs)\n        if d == 0:\n            continue\n        t0 = ((yt - ys) * (xs - xa) - (xt - xs) * (ys - ya)) / d\n        t1 = ((yb - ya) * (xs - xa) - (xb - xa) * (ys - ya)) / d\n        if (t0 > 0 and t0 < 1) and (t1 > 0 and t1 < 1):\n            ip.append((t0, o == l))\n    count = 0\n    if len(ip) > 0:\n        ip.sort(key=lambda x: x[0])\n        for j in range(len(ip) - 1):\n            if ip[j][1] != ip[j + 1][1]:\n                count += 1\n    print(count)"
  },
  {
    "language": "Python",
    "code": "for i in range(int(input())):\n    xa, ya, xb, yb = map(int, input().split(' '))\n    n = int(input())\n    ip = []\n    for j in range(n):\n        xs, ys, xt, yt, o, l = map(int, input().split(' '))\n        d = (xb - xa) * (yt - ys) - (yb - ya) * (xt - xs)\n        if d == 0:\n            continue\n        t0 = ((yt - ys) * (xs - xa) - (xt - xs) * (ys - ya)) / d\n        t1 = ((yb - ya) * (xs - xa) - (xb - xa) * (ys - ya)) / d\n        if (t0 > 0 and t0 < 1) and (t1 > 0 and t1 < 1):\n            ip.append((t0, o == l))\n    count = 0\n    if len(ip) > 0:\n        ip.sort(key=lambda x: x[0])\n        for j in range(len(ip) - 1):\n            if ip[j][1] != ip[j + 1][1]:\n                count += 1\n    print(count)"
  },
  {
    "language": "Python",
    "code": "def getlineeq(x1,y1,x2,y2):\n    if x1==x2:\n        return(0,0,x1) #x=a\n    else:\n        a=(y2-y1)/(x2-x1)\n        b=y1-a*x1\n        return(1,a,b)  #y=ax+b\n\ndef getcross(d1,a1,b1,d2,a2,b2,x1,x2,y1,y2,xs1,xs2,ys1,ys2):\n    if d1==0 and d2==0:\n        cp=[0,99999,99999]\n    elif d1==0:\n        cp= [0,b1,a2*b1+b2]\n    elif d2==0:\n        cp=[0,b2,a1*b2+b1]\n    else:\n        if a1==a2:\n            cp=[0,99999,99999]\n        else:\n            cp=[0,(b2-b1)/(a1-a2),(b2-b1)/(a1-a2)*a1+b1]\n    if cp[1]<=max(x1,x2) and cp[1]>=min(x1,x2) and cp[2]<=max(y1,y2) and cp[2]>=min(y1,y2):\n        if cp[1]<=max(xs1,xs2) and cp[1]>=min(xs1,xs2) and cp[2]<=max(ys1,ys2) and cp[2]>=min(ys1,ys2):\n            cp[0]=1\n    return cp\n\nn=int(raw_input())\nfor i in range(n):\n    [xa,ya,xb,yb]=[float(x) for x in raw_input().split()]\n    m=int(raw_input())\n    [d1,a1,b1]=getlineeq(xa,ya,xb,yb)\n    crosspoints=[]\n    for j in range(m):\n        linedata=raw_input().split()\n        [xs1,ys1,xs2,ys2]=[float(x) for x in linedata[:4]]\n        [o,h]=[int(x) for x in linedata[4:]]\n        (d2,a2,b2)=getlineeq(xs1,ys1,xs2,ys2)\n        crosspoints.append((getcross(d1,a1,b1,d2,a2,b2,xa,xb,ya,yb,xs1,xs2,ys1,ys2),o,h))\n    crosspoints.sort(key=lambda x:x[0][1])\n    k=2 #height now\n    S=0\n    print crosspoints\n    for j in range(m):\n        [cpd,o,h]=crosspoints[j]\n        [cd,cx,cy]=cpd\n        s=1-(o^h) #height supposed to be\n        if cd!=0:\n            if k!=s:\n                S=S+1\n                k=s\n    print max(S-1,0)"
  },
  {
    "language": "Python",
    "code": "def getlineeq(x1,y1,x2,y2):\n    if x1==x2:\n        return(0,0,x1) #x=a\n    else:\n        a=(y2-y1)/(x2-x1)\n        b=y1-a*x1\n        return(1,a,b)  #y=ax+b\n\ndef getcross(d1,a1,b1,d2,a2,b2,x1,x2,y1,y2,xs1,xs2,ys1,ys2):\n    if d1==0 and d2==0:\n        cp=[0,99999,99999]\n    elif d1==0:\n        cp= [0,b1,a2*b1+b2]\n    elif d2==0:\n        cp=[0,b2,a1*b2+b1]\n    else:\n        if a1==a2:\n            cp=[0,99999,99999]\n        else:\n            cp=[0,(b2-b1)/(a1-a2),(b2-b1)/(a1-a2)*a1+b1]\n    if cp[1]<=max(x1,x2) and cp[1]>=min(x1,x2) and cp[2]<=max(y1,y2) and cp[2]>=min(y1,y2):\n        if cp[1]<=max(xs1,xs2) and cp[1]>=min(xs1,xs2) and cp[2]<=max(ys1,ys2) and cp[2]>=min(ys1,ys2):\n            cp[0]=1\n    return cp\n\nn=int(raw_input())\nfor i in range(n):\n    [xa,ya,xb,yb]=[float(x) for x in raw_input().split()]\n    m=int(raw_input())\n    [d1,a1,b1]=getlineeq(xa,ya,xb,yb)\n    crosspoints=[]\n    for j in range(m):\n        linedata=raw_input().split()\n        [xs1,ys1,xs2,ys2]=[float(x) for x in linedata[:4]]\n        [o,h]=[int(x) for x in linedata[4:]]\n        (d2,a2,b2)=getlineeq(xs1,ys1,xs2,ys2)\n        crosspoints.append((getcross(d1,a1,b1,d2,a2,b2,xa,xb,ya,yb,xs1,xs2,ys1,ys2),o,h))\n    crosspoints.sort(key=lambda x:x[0][1])\n    k=2 #height now\n    S=0\n    for j in range(m):\n        [cpd,o,h]=crosspoints[j]\n        [cd,cx,cy]=cpd\n        s=1-(o^h) #height supposed to be\n        if cd!=0:\n            if k!=s:\n                S=S+1\n                k=s\n    print S-1"
  },
  {
    "language": "Python",
    "code": "for i in range(int(input())):\n    xa, ya, xb, yb = map(int, input().split(' '))\n    n = int(input())\n    ip = []\n    for j in range(n):\n        xs, ys, xt, yt, o, l = map(int, input().split(' '))\n        d = (xb - xa) * (yt - ys) - (yb - ya) * (xt - xs)\n            continue\n        t0 = ((yt - ys) * (xs - xa) - (xt - xs) * (ys - ya)) / d\n        t1 = ((yb - ya) * (xs - xa) - (xb - xa) * (ys - ya)) / d\n        if (t0 >= 0 and t0 <= 1) and (t1 >= 0 and t1 <= 1):\n            ip.append((t0, o == l))\n    count = 0\n    if len(ip) > 0\n        ip.sort(key=lambda x: x[0])\n        for j in range(len(ip) - 1):\n            if ip[i][1] != ip[i + 1][1]:\n                count += 1\n    print(count)"
  },
  {
    "language": "Python",
    "code": "m = int(input())\nwhile m:\n    m -= 1\n    ax, ay, bx, by = map(int, input().split())\n    n = int(input())\n    dx, dy = bx - ax, by - ay\n    intersections = set()\n    while n:\n        n -= 1\n        sx, sy, tx, ty, o, l = map(int, input().split())\n        tdx, tdy = tx - sx, ty - sy\n        asx, asy = sx - ax, sy - ay\n        denom = dx * tdy - dy * tdx\n        if not denom:\n            continue\n        r = (tdy * asx - tdx * asy) / denom\n        s = (dy * asx - dx * asy) / denom\n        if not 0 < r < 1 or not 0 < s < 1:\n            continue\n        px = ax + r * dx\n        intersections.add((px, o == l))\n\n    pl, counter = -1, -1\n    for px, l in sorted(intersections):\n        counter += pl != l\n        pl = l\n    print(max(counter, 0))"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef intersection(a1, a2, b1, b2):\n    x1,y1 = a1\n    x2,y2 = a2\n    x3,y3 = b1\n    x4,y4 = b2\n\n    ksi = (y4 - y3) * (x4 - x1) - (x4 - x3) * (y4 - y1)\n    eta = (x2 - x1) * (y4 - y1) - (y2 - y1) * (x4 - x1)\n    delta = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n    if delta == 0:\n        return None\n    ramda = ksi / delta;\n    mu = eta / delta;\n    if ramda >= 0 and ramda <= 1 and mu >= 0 and mu <= 1:\n        return (x1 + ramda * (x2 - x1), y1 + ramda * (y2 - y1))\n\n    return None\n\ndef main():\n    rr = []\n\n    n = I()\n    ni = 0\n\n    while ni < n:\n        ni += 1\n        xa,ya,xb,yb = LI()\n        a1 = (xa,ya)\n        a2 = (xb,yb)\n        m = I()\n        a = [LI() for _ in range(m)]\n        t = []\n        for xs,ys,xt,yt,o,l in a:\n            k = intersection(a1,a2,(xs,ys),(xt,yt))\n            if k is None:\n                continue\n            t.append((k,o^l))\n        if len(t) == 0:\n            rr.append(0)\n            continue\n\n        t.sort()\n        c = t[0][1]\n        r = 0\n        for _,tc in t:\n            if tc != c:\n                r += 1\n                c = tc\n\n        rr.append(r)\n\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\ndef in_sec(a, b, c):\n    return min(a, b) <= c <= max(a, b)\n\nq = input()\n\nfor loop in range(q):\n    x0, y0, x1, y1 = map(int, raw_input().split())\n    n = input()\n    ls = []\n    for i in range(n):\n        x2, y2, x3, y3, o, l = map(int, raw_input().split())\n        flag = (o + l) % 2\n        #(y1 - y0)(x - x0) = (x1 - x0)(y - y0)\n        a1, b1, c1 = [y1 - y0, x0 - x1, x0 * (y1 - y0) - y0 * (x1 - x0)]\n        a2, b2, c2 = [y3 - y2, x2 - x3, x2 * (y3 - y2) - y2 * (x3 - x2)]\n        det = a1 * b2 - b1 * a2\n        if det == 0:\n            dx, dy = [x2 - x0, y2 - y0]\n            if dx * a1 + dy * b1 != 0:\n                pass\n            elif max(x0, x1) < min(x2, x3) or max(x2, x3) < min(x0, x1) \\\n                or max(y0, y1) < min(y2, y3) or max(y2, y3) < min(y0, y1):\n                pass\n            else:\n                p = [(x0, y0), (x1, y1), (x2, y2), (x3, y3)]\n                ls += [(p[i], flag) for i in range(4) for j in range(4) if p[i] == p[j]]\n            continue\n        \n        xdet = c1 * b2 - c2 * b1\n        ydet = c2 * a1 - c1 * a2\n        if in_sec(det * x0, det * x1, xdet) and in_sec(det * y0, det * y1, ydet) \\\n            and in_sec(det * x2, det * x3, xdet) and in_sec(det * y2, det * y3, ydet):\n            det = float(det)\n            ls += [((xdet / det, ydet / det), flag)]\n    ls.sort()\n    ans = 0\n    for i in range(len(ls) - 1):\n        if ls[i][1] != ls[i + 1][1]:\n            ans += 1\n    print ans\n"
  },
  {
    "language": "Python",
    "code": "def getlineeq(x1,y1,x2,y2):\n    if x1==x2:\n        return(0,0,x1) #x=a\n    else:\n        a=(y2-y1)/(x2-x1)\n        b=y1-a*x1\n        return(1,a,b)  #y=ax+b\n\ndef getcross(d1,a1,b1,d2,a2,b2,x1,x2,xs1,xs2):\n    if d1==0 and d2==0:\n        cp=[0,99999,99999]\n    elif d1==0:\n        cp= [0,b1,a2*b1+b2]\n    elif d2==0:\n        cp=[0,b2,a1*b2+b1]\n    else:\n        if a1==a2:\n            cp=[0,99999,99999]\n        else:\n            cp=[0,(b2-b1)/(a1-a2),(b2-b1)/(a1-a2)*a1+b1]\n    if cp[1]<=max(x1,x2) and cp[1]>=min(x1,x2):\n        if cp[1]<=max(xs1,xs2) and cp[1]>=min(xs1,xs2):\n            cp[0]=1\n    return cp\n\nn=int(raw_input())\nfor i in range(n):\n    [xa,ya,xb,yb]=[float(x) for x in raw_input().split()]\n    m=int(raw_input())\n    [d1,a1,b1]=getlineeq(xa,ya,xb,yb)\n    crosspoints=[]\n    for j in range(m):\n        linedata=raw_input().split()\n        [xs1,ys1,xs2,ys2]=[float(x) for x in linedata[:4]]\n        [o,h]=[int(x) for x in linedata[4:]]\n        (d2,a2,b2)=getlineeq(xs1,ys1,xs2,ys2)\n        crosspoints.append((getcross(d1,a1,b1,d2,a2,b2,xa,xb,xs1,xs2),o,h))\n    crosspoints.sort(key=lambda x:x[0][1])\n    k=2 #height now\n    S=0\n    for j in range(m):\n        [cpd,o,h]=crosspoints[j]\n        [cd,cx,cy]=cpd\n        s=1-(o^h) #height supposed to be\n        if cd!=0:\n            if k!=s:\n                S=S+1\n                k=s\n    print S-1"
  },
  {
    "language": "Python",
    "code": "m = int(input())\nwhile m:\n    m -= 1\n    ax, ay, bx, by = map(int, input().split())\n    n = int(input())\n    dx, dy = bx - ax, by - ay\n    intersections = set()\n    while n:\n        n -= 1\n        sx, sy, tx, ty, o, l = map(int, input().split())\n        tdx, tdy = tx - sx, ty - sy\n        asx, asy = sx - ax, sy - ay\n        denom = dx * tdy - dy * tdx\n        if not denom:\n            continue\n        r = (tdy * asx - tdx * asy) / denom\n        s = (dy * asx - dx * asy) / denom\n        if not 0 < r < 1 or not 0 < s < 1:\n            continue\n        intersections.add((r, o == l))\n\n    pl, counter = -1, -1\n    for r, l in sorted(intersections):\n        counter += pl != l\n        pl = l\n    print(max(counter, 0))"
  },
  {
    "language": "Python",
    "code": "def getlineeq(x1,y1,x2,y2):\n    if x1==x2:\n        return(0,0,x1) #x=a\n    else:\n        a=(y2-y1)/(x2-x1)\n        b=y1-a*x1\n        return(1,a,b)  #y=ax+b\n\ndef getcross(d1,a1,b1,d2,a2,b2,x1,x2,y1,y2,xs1,xs2,ys1,ys2):\n    if d1==0 and d2==0:\n        cp=[0,99999,99999]\n    elif d1==0:\n        cp= [0,b1,a2*b1+b2]\n    elif d2==0:\n        cp=[0,b2,a1*b2+b1]\n    else:\n        if a1==a2:\n            cp=[0,99999,99999]\n        else:\n            cp=[0,(b2-b1)/(a1-a2),(b2-b1)/(a1-a2)*a1+b1]\n    if cp[1]<=max(x1,x2) and cp[1]>=min(x1,x2) and cp[2]<=max(y1,y2) and cp[2]>=min(y1,y2):\n        if cp[1]<=max(xs1,xs2) and cp[1]>=min(xs1,xs2) and cp[2]<=max(ys1,ys2) and cp[2]>=min(ys1,ys2):\n            cp[0]=1\n    return cp\n\nn=int(raw_input())\nfor i in range(n):\n    [xa,ya,xb,yb]=[float(x) for x in raw_input().split()]\n    m=int(raw_input())\n    [d1,a1,b1]=getlineeq(xa,ya,xb,yb)\n    crosspoints=[]\n    for j in range(m):\n        linedata=raw_input().split()\n        [xs1,ys1,xs2,ys2]=[float(x) for x in linedata[:4]]\n        [o,h]=[int(x) for x in linedata[4:]]\n        (d2,a2,b2)=getlineeq(xs1,ys1,xs2,ys2)\n        crosspoints.append((getcross(d1,a1,b1,d2,a2,b2,xa,xb,ya,yb,xs1,xs2,ys1,ys2),o,h))\n    crosspoints.sort(key=lambda x:x[0][1])\n    k=2 #height now\n    S=0\n    for j in range(m):\n        [cpd,o,h]=crosspoints[j]\n        [cd,cx,cy]=cpd\n        s=1-(o^h) #height supposed to be\n        if cd!=0:\n            if k!=s:\n                S=S+1\n                k=s\n    print max(S-1,0)"
  },
  {
    "language": "Python",
    "code": "m = int(input())\nwhile m:\n    m -= 1\n    ax, ay, bx, by = map(int, input().split())\n    n = int(input())\n    dx, dy = bx - ax, by - ay\n    intersections = set()\n    while n:\n        n -= 1\n        sx, sy, tx, ty, o, l = map(int, input().split())\n        tdx, tdy = tx - sx, ty - sy\n        asx, asy = sx - ax, sy - ay\n        denom = dx * tdy - dy * tdx\n        if not denom:\n            continue\n        r = (tdy * asx - tdx * asy) / denom\n        s = (dy * asx - dx * asy) / denom\n        if not 0 < r < 1 or not 0 < s < 1:\n            continue\n        intersections.add((r, o == l))\n\n    intersections = [l[1] for l in sorted(intersections)]\n    print(sum(i != j for i, j in zip(intersections, intersections[1:])))"
  },
  {
    "language": "Python",
    "code": "m = int(input())\nwhile m:\n    m -= 1\n    ax, ay, bx, by = map(int, input().split())\n    n = int(input())\n    dx, dy = bx - ax, by - ay\n    intersections = set()\n    while n:\n        n -= 1\n        sx, sy, tx, ty, o, l = map(int, input().split())\n        tdx, tdy = tx - sx, ty - sy\n        asx, asy = sx - ax, sy - ay\n        denom = dx * tdy - dy * tdx\n        if not denom:\n            continue\n        r = (tdy * asx - tdx * asy) / denom\n        s = (dy * asx - dx * asy) / denom\n        if not 0 < r < 1 or not 0 < s < 1:\n            continue\n        px = ax + r * dx\n        intersections.add((px, o == l))\n\n    if not intersections:\n        print(0)\n        continue\n\n    pl, counter = -1, -1\n    for px, l in sorted(intersections):\n        if pl != l:\n            counter += 1\n            pl = l\n    print(counter)"
  },
  {
    "language": "Python",
    "code": "m = int(input())\nwhile m:\n    m -= 1\n    ax, ay, bx, by = map(int, input().split())\n    n = int(input())\n    dx, dy = bx - ax, by - ay\n    intersections = set()\n    while n:\n        n -= 1\n        sx, sy, tx, ty, o, l = map(int, input().split())\n        tdx, tdy = tx - sx, ty - sy\n        asx, asy = sx - ax, sy - ay\n        denom = dx * tdy - dy * tdx\n        if not denom:\n            continue\n        r = (tdy * asx - tdx * asy) / denom\n        s = (dy * asx - dx * asy) / denom\n        if not 0 < r < 1 or not 0 < s < 1:\n            continue\n        px = ax + r * dx\n        intersections.add((px, o == l))\n    pl, counter = -1, -1\n    for px, l in sorted(intersections):\n        if pl != l:\n            counter += 1\n            pl = l\n    print(counter)"
  },
  {
    "language": "Python",
    "code": "for i in range(int(input())):\n    xa, ya, xb, yb = map(int, input().split(' '))\n    n = int(input())\n    ip = []\n    for j in range(n):\n        xs, ys, xt, yt, o, l = map(int, input().split(' '))\n        d = (xb - xa) * (yt - ys) - (yb - ya) * (xt - xs)\n        if d == 0:\n            continue\n        t0 = ((yt - ys) * (xs - xa) - (xt - xs) * (ys - ya)) / d\n        t1 = ((yb - ya) * (xs - xa) - (xb - xa) * (ys - ya)) / d\n        if (t0 >= 0 and t0 <= 1) and (t1 >= 0 and t1 <= 1):\n            ip.append((t0, o == l))\n    count = 0\n    if len(ip) > 0\n        ip.sort(key=lambda x: x[0])\n        for j in range(len(ip) - 1):\n            if ip[i][1] != ip[i + 1][1]:\n                count += 1\n    print(count)"
  },
  {
    "language": "Python",
    "code": "for i in range(int(input())):\n    xa, ya, xb, yb = map(int, input().split(' '))\n    n = int(input())\n    ip = []\n    for j in range(n):\n        xs, ys, xt, yt, o, l = map(int, input().split(' '))\n        d = (xb - xa) * (yt - ys) - (yb - ya) * (xt - xs)\n        if d == 0:\n            continue\n        t0 = ((yt - ys) * (xs - xa) - (xt - xs) * (ys - ya)) / d\n        t1 = ((yb - ya) * (xs - xa) - (xb - xa) * (ys - ya)) / d\n        if t0 < 0 or t0 > 1 or t1 < 0 or t1 > 1:\n            continue\n        ip.append((t0, o, l))\n    ip.sort(key=lambda x: x[0])\n    count = 0\n    if len(ip) > 0:\n        l = ip[0][2] if ip[0][1] == 1 else abs(ip[0][2] - 1)\n        for p in ip[1:]:\n            if p[1] == 0 and l == p[2]:\n                l = abs(l - 1)\n                count += 1\n            elif p[1] == 1 and l != p[2]:\n                l = abs(l - 1)\n                count += 1\n    print(count)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\n\ndef solve():\n    file_input = stdin\n    data_sets_num = int(file_input.readline())\n    for i in range(data_sets_num):\n        xa, ya, xb, yb = map(int, file_input.readline().split())\n        x_ab = xb - xa\n        y_ab = yb - ya\n        n = int(file_input.readline())\n        cross_points = []\n        for j in range(n):\n            xs, ys, xt, yt, o, l = map(int, file_input.readline().split())\n            # Intersection judgment\n            c_abs = x_ab * (ys - ya) - y_ab * (xs - xa)\n            c_abt = x_ab * (yt - ya) - y_ab * (xt - xa)\n            if c_abs * c_abt <= 0:\n                x_st = xt - xs\n                y_st = yt - ys\n                c_sta = x_st * (ya - ys) - y_st * (xa - xs)\n                c_stb = x_st * (yb - ys) - y_st * (xb - xs)\n                if c_sta * c_stb < 0:\n                    # find cross point\n                    r = -c_abs / (x_ab * y_st - y_ab * x_st)\n                    cross_points.append((xs + r * x_st, ys + r * y_st, o, l))\n        if cross_points:\n            cross_points.sort()\n            owner = cross_points[0][2]\n            pos = cross_points[0][3]\n            ans = 0\n            for x_cp, y_cp, o, l in cross_points[1:]:\n                if (o == owner and l != pos ) or (o != owner and l == pos):\n                    ans += 1\n                owner = o\n                pos = l\n            print(ans)\n        else:\n            print(0)\n\nsolve()\n"
  }
]