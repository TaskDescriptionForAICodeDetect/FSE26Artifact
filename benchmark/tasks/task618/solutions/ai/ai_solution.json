[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_VERTICES 1000\n\ntypedef struct Edge {\n    int dest;\n    int weight;\n    struct Edge* next;\n} Edge;\n\ntypedef struct {\n    int vertices;\n    Edge* adjacencyList[MAX_VERTICES];\n} Graph;\n\nGraph* createGraph(int vertices) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    graph->vertices = vertices;\n    \n    for (int i = 0; i < vertices; i++) {\n        graph->adjacencyList[i] = NULL;\n    }\n    \n    return graph;\n}\n\nvoid addEdge(Graph* graph, int src, int dest, int weight) {\n    Edge* newEdge = (Edge*)malloc(sizeof(Edge));\n    newEdge->dest = dest;\n    newEdge->weight = weight;\n    newEdge->next = graph->adjacencyList[src];\n    graph->adjacencyList[src] = newEdge;\n}\n\nvoid dijkstra(Graph* graph, int source) {\n    int dist[MAX_VERTICES];\n    bool visited[MAX_VERTICES];\n    \n    for (int i = 0; i < graph->vertices; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = false;\n    }\n    \n    dist[source] = 0;\n    \n    for (int count = 0; count < graph->vertices - 1; count++) {\n        int u, min = INT_MAX;\n        \n        for (int v = 0; v < graph->vertices; v++) {\n            if (!visited[v] && dist[v] <= min) {\n                min = dist[v];\n                u = v;\n            }\n        }\n        \n        visited[u] = true;\n        \n        Edge* edge = graph->adjacencyList[u];\n        while (edge != NULL) {\n            int v = edge->dest;\n            \n            if (!visited[v] && \n                dist[u] != INT_MAX && \n                dist[u] + edge->weight < dist[v]) {\n                dist[v] = dist[u] + edge->weight;\n            }\n            \n            edge = edge->next;\n        }\n    }\n    \n    printf(\"Vertex   Distance from Source\\n\");\n    for (int i = 0; i < graph->vertices; i++) {\n        printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n    }\n}\n\nint main() {\n    int vertices = 5;\n    Graph* graph = createGraph(vertices);\n    \n    addEdge(graph, 0, 1, 4);\n    addEdge(graph, 0, 2, 1);\n    addEdge(graph, 1, 3, 1);\n    addEdge(graph, 2, 1, 2);\n    addEdge(graph, 2, 3, 5);\n    addEdge(graph, 3, 4, 3);\n    \n    dijkstra(graph, 0);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:19:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_VERTICES 100\n#define INF INT_MAX\n\ntypedef struct {\n    int u, v, weight;\n} Edge;\n\ntypedef struct {\n    int V, E;\n    Edge* edges;\n} Graph;\n\nGraph* createGraph(int V, int E) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    graph->V = V;\n    graph->E = E;\n    graph->edges = (Edge*)malloc(E * sizeof(Edge));\n    return graph;\n}\n\nvoid bellmanFord(Graph* graph, int src) {\n    int V = graph->V;\n    int E = graph->E;\n    int dist[MAX_VERTICES];\n\n    for (int i = 0; i < V; i++) {\n        dist[i] = INF;\n    }\n    dist[src] = 0;\n\n    for (int i = 1; i <= V - 1; i++) {\n        for (int j = 0; j < E; j++) {\n            int u = graph->edges[j].u;\n            int v = graph->edges[j].v;\n            int weight = graph->edges[j].weight;\n            if (dist[u] != INF && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n            }\n        }\n    }\n\n    for (int i = 0; i < E; i++) {\n        int u = graph->edges[i].u;\n        int v = graph->edges[i].v;\n        int weight = graph->edges[i].weight;\n        if (dist[u] != INF && dist[u] + weight < dist[v]) {\n            printf(\"Graph contains negative weight cycle\\n\");\n            return;\n        }\n    }\n\n    printf(\"Vertex   Distance from Source\\n\");\n    for (int i = 0; i < V; i++) {\n        printf(\"%d \\t\\t %d\\n\", i, dist[i]);\n    }\n}\n\nint main() {\n    int V, E, src;\n    printf(\"Enter number of vertices and edges: \");\n    scanf(\"%d %d\", &V, &E);\n\n    Graph* graph = createGraph(V, E);\n\n    printf(\"Enter edges (u v weight):\\n\");\n    for (int i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &graph->edges[i].u, &graph->edges[i].v, &graph->edges[i].weight);\n    }\n\n    printf(\"Enter source vertex: \");\n    scanf(\"%d\", &src);\n\n    bellmanFord(graph, src);\n\n    free(graph->edges);\n    free(graph);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid dijkstra(const vector<vector<pii>>& graph, int source, vector<int>& dist) {\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[source] = 0;\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push({0, source});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int current_dist = pq.top().first;\n        pq.pop();\n\n        if (current_dist > dist[u]) continue;\n\n        for (const auto& edge : graph[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n\n            if (dist[v] > dist[u] + weight) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int V, E, r;\n    cin >> V >> E >> r;\n    vector<vector<pii>> graph(V);\n\n    for (int i = 0; i < E; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n    }\n\n    vector<int> dist;\n    dijkstra(graph, r, dist);\n\n    for (int i = 0; i < V; ++i) {\n        if (dist[i] == INT_MAX) {\n            cout << \"INF\" << endl;\n        } else {\n            cout << dist[i] << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to;\n    int weight;\n\n    Edge(int to, int weight) {\n        this.to = to;\n        this.weight = weight;\n    }\n}\n\npublic class Dijkstra {\n    public static int[] dijkstra(List<List<Edge>> graph, int source) {\n        int n = graph.size();\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[source] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.offer(new int[]{source, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int d = current[1];\n\n            if (d > dist[u]) continue;\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = dist[u] + edge.weight;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[]{v, newDist});\n                }\n            }\n        }\n\n        return dist;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int source = scanner.nextInt();\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = scanner.nextInt();\n            graph.get(u).add(new Edge(v, w));\n        }\n\n        int[] dist = dijkstra(graph, source);\n\n        for (int i = 0; i < n; i++) {\n            System.out.println(\"Distance from \" + source + \" to \" + i + \" is \" + dist[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:20:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Graph {\n    private int V;\n    private List<List<Node>> adjacencyList;\n\n    class Node implements Comparable<Node> {\n        int vertex;\n        int weight;\n\n        Node(int vertex, int weight) {\n            this.vertex = vertex;\n            this.weight = weight;\n        }\n\n        @Override\n        public int compareTo(Node other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n\n    Graph(int v) {\n        V = v;\n        adjacencyList = new ArrayList<>(V);\n        for (int i = 0; i < V; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n    }\n\n    void addEdge(int source, int destination, int weight) {\n        adjacencyList.get(source).add(new Node(destination, weight));\n        adjacencyList.get(destination).add(new Node(source, weight)); // Uncomment for undirected graph\n    }\n\n    int[] dijkstra(int source) {\n        int[] distances = new int[V];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[source] = 0;\n\n        PriorityQueue<Node> pq = new PriorityQueue<>();\n        pq.add(new Node(source, 0));\n\n        while (!pq.isEmpty()) {\n            Node current = pq.poll();\n            int u = current.vertex;\n            int dist = current.weight;\n\n            if (dist > distances[u]) continue;\n\n            for (Node neighbor : adjacencyList.get(u)) {\n                int v = neighbor.vertex;\n                int weight = neighbor.weight;\n\n                if (distances[u] + weight < distances[v]) {\n                    distances[v] = distances[u] + weight;\n                    pq.add(new Node(v, distances[v]));\n                }\n            }\n        }\n\n        return distances;\n    }\n\n    public static void main(String[] args) {\n        int V = 5;\n        Graph graph = new Graph(V);\n\n        graph.addEdge(0, 1, 4);\n        graph.addEdge(0, 2, 1);\n        graph.addEdge(1, 3, 1);\n        graph.addEdge(2, 1, 2);\n        graph.addEdge(2, 3, 5);\n        graph.addEdge(3, 4, 3);\n\n        int source = 0;\n        int[] shortestDistances = graph.dijkstra(source);\n\n        System.out.println(\"Shortest distances from source \" + source + \":\");\n        for (int i = 0; i < V; i++) {\n            System.out.println(\"To vertex \" + i + \": \" + shortestDistances[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:21:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n    int V;\n    vector<vector<pair<int, int>>> adj;\n\npublic:\n    Graph(int vertices) : V(vertices), adj(vertices) {}\n\n    void addEdge(int u, int v, int weight) {\n        adj[u].push_back({v, weight});\n        adj[v].push_back({u, weight});\n    }\n\n    vector<int> dijkstra(int source) {\n        vector<int> dist(V, numeric_limits<int>::max());\n        dist[source] = 0;\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({0, source});\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int curr_dist = pq.top().first;\n            pq.pop();\n\n            if (curr_dist > dist[u]) continue;\n\n            for (auto& edge : adj[u]) {\n                int v = edge.first;\n                int weight = edge.second;\n\n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n\n        return dist;\n    }\n};\n\nint main() {\n    int V = 5;\n    Graph g(V);\n\n    g.addEdge(0, 1, 4);\n    g.addEdge(0, 2, 1);\n    g.addEdge(1, 3, 1);\n    g.addEdge(2, 3, 3);\n    g.addEdge(3, 4, 2);\n\n    int source = 0;\n    vector<int> shortest_paths = g.dijkstra(source);\n\n    for (int i = 0; i < V; i++) {\n        cout << \"Distance from \" << source << \" to \" << i << \": \" << shortest_paths[i] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(graph, source):\n    # Initialize the distance to each vertex as infinity, except for the source vertex\n    distances = {vertex: float('infinity') for vertex in graph}\n    distances[source] = 0\n    # Priority queue to hold vertices to be explored, sorted by distance\n    priority_queue = [(0, source)]\n    \n    while priority_queue:\n        # Explore the vertex with the smallest known distance\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n        \n        # If the distance is greater than the current known shortest distance, continue\n        if current_distance > distances[current_vertex]:\n            continue\n        \n        # Explore each adjacent vertex\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            # If a shorter path to the neighbor is found, update the distance and add to the queue\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n                \n    return distances\n\n# Example usage:\ngraph = {\n    'a': {'b': 1, 'c': 4},\n    'b': {'a': 1, 'c': 2, 'd': 5},\n    'c': {'a': 4, 'b': 2, 'd': 1},\n    'd': {'b': 5, 'c': 1}\n}\n\nsource = 'a'\nprint(dijkstra(graph, source))",
    "timestamp": "2025-08-13 10:04:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass Dijkstra {\n    static class Edge {\n        int target, weight;\n        Edge(int target, int weight) {\n            this.target = target;\n            this.weight = weight;\n        }\n    }\n\n    static List<Integer> dijkstra(List<List<Edge>> graph, int source) {\n        int n = graph.size();\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[source] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.offer(new int[] {source, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int currentDist = current[1];\n\n            if (currentDist > dist[u]) {\n                continue;\n            }\n\n            for (Edge edge : graph.get(u)) {\n                int v = edge.target;\n                int weight = edge.weight;\n                int newDist = dist[u] + weight;\n\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[] {v, newDist});\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int d : dist) {\n            result.add(d);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<List<Edge>> graph = new ArrayList<>();\n        int vertices = 5; // Number of vertices\n        for (int i = 0; i < vertices; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        // Example edges: (source, target, weight)\n        graph.get(0).add(new Edge(1, 10));\n        graph.get(0).add(new Edge(2, 3));\n        graph.get(1).add(new Edge(2, 1));\n        graph.get(1).add(new Edge(3, 2));\n        graph.get(2).add(new Edge(1, 4));\n        graph.get(2).add(new Edge(3, 8));\n        graph.get(2).add(new Edge(4, 2));\n        graph.get(3).add(new Edge(4, 7));\n        graph.get(4).add(new Edge(3, 9));\n\n        int source = 0;\n        List<Integer> shortestPaths = dijkstra(graph, source);\n\n        System.out.println(\"Shortest paths from source \" + source + \": \" + shortestPaths);\n    }\n}",
    "timestamp": "2025-08-13 10:05:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_VERTICES 100\n\nvoid dijkstra(int graph[MAX_VERTICES][MAX_VERTICES], int numVertices, int source) {\n    int dist[MAX_VERTICES];\n    int visited[MAX_VERTICES] = {0};\n    \n    for (int i = 0; i < numVertices; i++) {\n        dist[i] = INT_MAX;\n    }\n    dist[source] = 0;\n\n    for (int count = 0; count < numVertices - 1; count++) {\n        int minDist = INT_MAX, minIndex;\n        for (int v = 0; v < numVertices; v++) {\n            if (!visited[v] && dist[v] <= minDist) {\n                minDist = dist[v];\n                minIndex = v;\n            }\n        }\n\n        visited[minIndex] = 1;\n\n        for (int v = 0; v < numVertices; v++) {\n            if (!visited[v] && graph[minIndex][v] && dist[minIndex] != INT_MAX &&\n                dist[minIndex] + graph[minIndex][v] < dist[v]) {\n                dist[v] = dist[minIndex] + graph[minIndex][v];\n            }\n        }\n    }\n\n    for (int i = 0; i < numVertices; i++) {\n        printf(\"Vertex %d, Distance from source %d\\n\", i, dist[i]);\n    }\n}\n\nint main() {\n    int graph[MAX_VERTICES][MAX_VERTICES], numVertices, source;\n\n    printf(\"Enter number of vertices: \");\n    scanf(\"%d\", &numVertices);\n\n    printf(\"Enter adjacency matrix with weights (use 0 if no edge):\\n\");\n    for (int i = 0; i < numVertices; i++) {\n        for (int j = 0; j < numVertices; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    printf(\"Enter source vertex: \");\n    scanf(\"%d\", &source);\n\n    dijkstra(graph, numVertices, source);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:05:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(graph, source):\n    # Initialize distances and previous nodes\n    distances = {vertex: float('inf') for vertex in graph}\n    distances[source] = 0\n    previous = {vertex: None for vertex in graph}\n    \n    # Priority queue to track vertices to visit\n    pq = [(0, source)]\n    \n    # Track visited vertices\n    visited = set()\n    \n    while pq:\n        current_distance, current_vertex = heapq.heappop(pq)\n        \n        # Skip if already visited\n        if current_vertex in visited:\n            continue\n        \n        visited.add(current_vertex)\n        \n        # Check neighbors\n        for neighbor, weight in graph[current_vertex].items():\n            distance = current_distance + weight\n            \n            # Update if shorter path found\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                previous[neighbor] = current_vertex\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances, previous",
    "timestamp": "2025-08-13 10:05:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef dijkstra(graph, r):\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[r] = 0\n    heap = [(0, r)]\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist[u]:\n            continue\n        for v, weight in graph[u]:\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(heap, (dist[v], v))\n    return dist\n\n# Example usage:\n# graph = [\n#     [(1, 4), (2, 1)],  # Node 0\n#     [(3, 1)],           # Node 1\n#     [(1, 2), (3, 5)],   # Node 2\n#     [(4, 3)],           # Node 3\n#     []                  # Node 4\n# ]\n# source = 0\n# print(dijkstra(graph, source))",
    "timestamp": "2025-08-13 10:05:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nclass Graph {\n    int V;\n    vector<vector<pair<int, int>>> adj;\n\npublic:\n    Graph(int V) : V(V), adj(V) {}\n\n    void addEdge(int u, int v, int weight) {\n        adj[u].emplace_back(v, weight);\n    }\n\n    vector<int> dijkstra(int source) {\n        vector<int> dist(V, INF);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n        dist[source] = 0;\n        pq.emplace(0, source);\n\n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n\n            for (const auto& neighbor : adj[u]) {\n                int v = neighbor.first;\n                int weight = neighbor.second;\n\n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    pq.emplace(dist[v], v);\n                }\n            }\n        }\n\n        return dist;\n    }\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    Graph g(V);\n\n    for (int i = 0; i < E; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        g.addEdge(u, v, w);\n    }\n\n    int source;\n    cin >> source;\n\n    vector<int> distances = g.dijkstra(source);\n\n    for (int i = 0; i < V; ++i) {\n        if (distances[i] == INF) {\n            cout << \"Distance from \" << source << \" to \" << i << \" is infinity\" << endl;\n        } else {\n            cout << \"Distance from \" << source << \" to \" << i << \" is \" << distances[i] << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:10"
  }
]