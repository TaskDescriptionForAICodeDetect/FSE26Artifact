[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\nint H, W;\n\nvoid dfs(int i, int j, char fruit) {\n    if (i < 0 || i >= H || j < 0 || j >= W || visited[i][j] || grid[i][j] != fruit) {\n        return;\n    }\n    visited[i][j] = 1;\n    dfs(i + 1, j, fruit);\n    dfs(i - 1, j, fruit);\n    dfs(i, j + 1, fruit);\n    dfs(i, j - 1, fruit);\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        int count = 0;\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!visited[i][j]) {\n                    count++;\n                    dfs(i, j, grid[i][j]);\n                }\n            }\n        }\n        \n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:27:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class OrchardDivision {\n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int H = scanner.nextInt();\n            int W = scanner.nextInt();\n            \n            if (H == 0 && W == 0) break;\n            \n            char[][] orchard = new char[H][W];\n            boolean[][] visited = new boolean[H][W];\n            \n            for (int i = 0; i < H; i++) {\n                orchard[i] = scanner.next().toCharArray();\n            }\n            \n            int sections = 0;\n            \n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j]) {\n                        bfs(orchard, visited, i, j);\n                        sections++;\n                    }\n                }\n            }\n            \n            System.out.println(sections);\n        }\n        \n        scanner.close();\n    }\n    \n    static void bfs(char[][] orchard, boolean[][] visited, int startX, int startY) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{startX, startY});\n        visited[startX][startY] = true;\n        char fruit = orchard[startX][startY];\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k];\n                int ny = y + dy[k];\n                \n                if (nx >= 0 && nx < orchard.length && ny >= 0 && ny < orchard[0].length \n                    && !visited[nx][ny] && orchard[nx][ny] == fruit) {\n                    queue.offer(new int[]{nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:28:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvoid bfs(const vector<string>& grid, vector<vector<bool>>& visited, int i, int j, int H, int W) {\n    queue<pair<int, int>> q;\n    q.push({i, j});\n    visited[i][j] = true;\n    char current = grid[i][j];\n    \n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        for (int k = 0; k < 4; ++k) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            \n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny] && grid[nx][ny] == current) {\n                visited[nx][ny] = true;\n                q.push({nx, ny});\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int H, W;\n    while (cin >> H >> W, H || W) {\n        vector<string> grid(H);\n        for (int i = 0; i < H; ++i) {\n            cin >> grid[i];\n        }\n        \n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        int count = 0;\n        \n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (!visited[i][j]) {\n                    bfs(grid, visited, i, j, H, W);\n                    ++count;\n                }\n            }\n        }\n        \n        cout << count << '\\n';\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:28:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_H 50\n#define MAX_W 50\n\nint H, W;\nchar orchard[MAX_H][MAX_W + 1];\nint visited[MAX_H][MAX_W];\n\nvoid dfs(int row, int col, char fruit) {\n    if (row < 0 || row >= H || col < 0 || col >= W || \n        visited[row][col] || orchard[row][col] != fruit) {\n        return;\n    }\n    \n    visited[row][col] = 1;\n    \n    dfs(row - 1, col, fruit);\n    dfs(row + 1, col, fruit);\n    dfs(row, col - 1, fruit);\n    dfs(row, col + 1, fruit);\n}\n\nint countSections() {\n    int sections = 0;\n    memset(visited, 0, sizeof(visited));\n    \n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!visited[i][j]) {\n                dfs(i, j, orchard[i][j]);\n                sections++;\n            }\n        }\n    }\n    \n    return sections;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        \n        if (H == 0 && W == 0) break;\n        \n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", orchard[i]);\n        }\n        \n        printf(\"%d\\n\", countSections());\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:28:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint countSections(vector<string>& orchard) {\n    int H = orchard.size();\n    int W = orchard[0].length();\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    int sections = 0;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (!visited[i][j]) {\n                sections++;\n                char currentFruit = orchard[i][j];\n                queue<pair<int, int>> q;\n                q.push({i, j});\n                visited[i][j] = true;\n\n                while (!q.empty()) {\n                    int r = q.front().first;\n                    int c = q.front().second;\n                    q.pop();\n\n                    vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n                    for (auto& dir : directions) {\n                        int nr = r + dir.first;\n                        int nc = c + dir.second;\n\n                        if (nr >= 0 && nr < H && nc >= 0 && nc < W && \n                            !visited[nr][nc] && orchard[nr][nc] == currentFruit) {\n                            q.push({nr, nc});\n                            visited[nr][nc] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return sections;\n}\n\nint main() {\n    int H, W;\n    while (cin >> H >> W && H != 0 && W != 0) {\n        vector<string> orchard(H);\n        for (int i = 0; i < H; i++) {\n            cin >> orchard[i];\n        }\n        cout << countSections(orchard) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:28:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            H = scanner.nextInt();\n            W = scanner.nextInt();\n            if (H == 0 && W == 0) break;\n            grid = new char[H][W];\n            visited = new boolean[H][W];\n            for (int i = 0; i < H; i++) {\n                String line = scanner.next();\n                for (int j = 0; j < W; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n            int count = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (!visited[i][j]) {\n                        dfs(i, j, grid[i][j]);\n                        count++;\n                    }\n                }\n            }\n            System.out.println(count);\n        }\n        scanner.close();\n    }\n\n    static void dfs(int x, int y, char fruit) {\n        visited[x][y] = true;\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny] && grid[nx][ny] == fruit) {\n                dfs(nx, ny, fruit);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:29:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dfs(x, y, visited, orchard, H, W):\n    stack = [(x, y)]\n    fruit_type = orchard[x][y]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while stack:\n        cx, cy = stack.pop()\n        for dx, dy in directions:\n            nx, ny = cx + dx, cy + dy\n            if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny] and orchard[nx][ny] == fruit_type:\n                visited[nx][ny] = True\n                stack.append((nx, ny))\n\ndef count_sections(orchard, H, W):\n    visited = [[False] * W for _ in range(H)]\n    sections_count = 0\n\n    for i in range(H):\n        for j in range(W):\n            if not visited[i][j]:\n                visited[i][j] = True\n                dfs(i, j, visited, orchard, H, W)\n                sections_count += 1\n\n    return sections_count\n\nimport sys\n\ndef main():\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    i = 0\n    results = []\n    while True:\n        dimensions = data[i].strip().split()\n        H, W = int(dimensions[0]), int(dimensions[1])\n        if H == 0 and W == 0:\n            break\n        orchard = data[i + 1: i + 1 + H]\n        i += 1 + H\n        results.append(count_sections(orchard, H, W))\n    \n    for result in results:\n        print(result)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-12 23:21:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class OrchardDistribution {\n    private static final char APPLE = '@';\n    private static final char PERSIMMON = '#';\n    private static final char ORANGE = '*';\n    private static final char VISITED = '.';\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            int H = scanner.nextInt();\n            int W = scanner.nextInt();\n            if (H == 0 && W == 0) break;\n\n            scanner.nextLine(); // consume the leftover newline character\n            char[][] orchard = new char[H][W];\n            for (int i = 0; i < H; i++) {\n                orchard[i] = scanner.nextLine().toCharArray();\n            }\n\n            int sections = 0;\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    if (orchard[i][j] == APPLE || orchard[i][j] == PERSIMMON || orchard[i][j] == ORANGE) {\n                        sections++;\n                        dfs(orchard, i, j, orchard[i][j]);\n                    }\n                }\n            }\n\n            System.out.println(sections);\n        }\n    }\n\n    private static void dfs(char[][] orchard, int i, int j, char fruitType) {\n        int H = orchard.length;\n        int W = orchard[0].length;\n        if (i < 0 || i >= H || j < 0 || j >= W || orchard[i][j] != fruitType) {\n            return;\n        }\n\n        orchard[i][j] = VISITED;\n        dfs(orchard, i - 1, j, fruitType);\n        dfs(orchard, i + 1, j, fruitType);\n        dfs(orchard, i, j - 1, fruitType);\n        dfs(orchard, i, j + 1, fruitType);\n    }\n}",
    "timestamp": "2025-08-12 23:21:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 100\n\nint H, W;\nchar orchard[MAX][MAX];\nint visited[MAX][MAX];\n\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nvoid dfs(int x, int y, char fruit) {\n    if (x < 0 || x >= H || y < 0 || y >= W) return;\n    if (visited[x][y] || orchard[x][y] != fruit) return;\n\n    visited[x][y] = 1;\n\n    for (int i = 0; i < 4; i++) {\n        int newX = x + directions[i][0];\n        int newY = y + directions[i][1];\n        dfs(newX, newY, fruit);\n    }\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d %d\", &H, &W);\n        if (H == 0 && W == 0) break;\n\n        for (int i = 0; i < H; i++) {\n            scanf(\"%s\", orchard[i]);\n        }\n\n        memset(visited, 0, sizeof(visited));\n\n        int sections = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (!visited[i][j]) {\n                    dfs(i, j, orchard[i][j]);\n                    sections++;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", sections);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-12 23:21:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_sections(H, W, orchard):\n    def dfs(r, c, fruit):\n        if r < 0 or r >= H or c < 0 or c >= W or orchard[r][c] != fruit:\n            return\n        orchard[r] = orchard[r][:c] + 'X' + orchard[r][c+1:]\n        dfs(r+1, c, fruit)\n        dfs(r-1, c, fruit)\n        dfs(r, c+1, fruit)\n        dfs(r, c-1, fruit)\n\n    sections = 0\n    for r in range(H):\n        for c in range(W):\n            if orchard[r][c] in '@#*':\n                dfs(r, c, orchard[r][c])\n                sections += 1\n    return sections\n\ndef main():\n    while True:\n        H, W = map(int, input().split())\n        if H == 0 and W == 0:\n            break\n        \n        orchard = [input() for _ in range(H)]\n        print(count_sections(H, W, orchard))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-12 23:21:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    while True:\n        H, W = map(int, sys.stdin.readline().split())\n        if H == 0 and W == 0:\n            break\n        grid = [sys.stdin.readline().strip() for _ in range(H)]\n        visited = [[False for _ in range(W)] for _ in range(H)]\n        count = 0\n        \n        for i in range(H):\n            for j in range(W):\n                if not visited[i][j]:\n                    count += 1\n                    queue = deque()\n                    queue.append((i, j))\n                    visited[i][j] = True\n                    current_char = grid[i][j]\n                    \n                    while queue:\n                        x, y = queue.popleft()\n                        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < H and 0 <= ny < W:\n                                if not visited[nx][ny] and grid[nx][ny] == current_char:\n                                    visited[nx][ny] = True\n                                    queue.append((nx, ny))\n        print(count)\n\nsolve()",
    "timestamp": "2025-08-12 23:21:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvoid bfs(vector<string>& orchard, vector<vector<bool>>& visited, int startX, int startY, char fruitType, int H, int W) {\n    queue<pair<int, int>> q;\n    q.push({startX, startY});\n    visited[startX][startY] = true;\n    \n    int directionX[] = {-1, 1, 0, 0};\n    int directionY[] = {0, 0, -1, 1};\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        for (int i = 0; i < 4; ++i) {\n            int newX = x + directionX[i];\n            int newY = y + directionY[i];\n            \n            if (newX >= 0 && newX < H && newY >= 0 && newY < W &&\n                !visited[newX][newY] && orchard[newX][newY] == fruitType) {\n                visited[newX][newY] = true;\n                q.push({newX, newY});\n            }\n        }\n    }\n}\n\nint main() {\n    int H, W;\n    while (cin >> H >> W && (H != 0 || W != 0)) {\n        vector<string> orchard(H);\n        for (int i = 0; i < H; ++i) {\n            cin >> orchard[i];\n        }\n        \n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        int sections = 0;\n        \n        for (int i = 0; i < H; ++i) {\n            for (int j = 0; j < W; ++j) {\n                if (!visited[i][j]) {\n                    sections++;\n                    bfs(orchard, visited, i, j, orchard[i][j], H, W);\n                }\n            }\n        }\n        \n        cout << sections << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:49:52"
  }
]