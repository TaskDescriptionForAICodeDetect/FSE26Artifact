[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_SIZE 50\n\nint rows, cols;\nchar grid[MAX_SIZE][MAX_SIZE];\nchar red[MAX_SIZE][MAX_SIZE];\nchar blue[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\nbool dfs_component(char color, int x, int y, bool is_mark) {\n    if (!is_valid(x, y) || visited[x][y] || grid[x][y] != color) \n        return false;\n\n    visited[x][y] = true;\n    if (is_mark) {\n        if (color == 'R') red[x][y] = '#';\n        else blue[x][y] = '#';\n    }\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        dfs_component(color, nx, ny, is_mark);\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    \n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    memset(red, '.', sizeof(red));\n    memset(blue, '.', sizeof(blue));\n    memset(visited, 0, sizeof(visited));\n\n    bool found_red = false, found_blue = false;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 'P' && !visited[i][j]) {\n                memset(visited, 0, sizeof(visited));\n                \n                bool red_possible = dfs_component('R', i, j, false);\n                memset(visited, 0, sizeof(visited));\n                bool blue_possible = dfs_component('B', i, j, false);\n\n                if (red_possible && blue_possible) {\n                    memset(visited, 0, sizeof(visited));\n                    dfs_component('R', i, j, true);\n                    memset(visited, 0, sizeof(visited));\n                    dfs_component('B', i, j, true);\n                    found_red = found_blue = true;\n                    break;\n                }\n            }\n        }\n        if (found_red && found_blue) break;\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%c\", red[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%c\", blue[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:36:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 50\n\nint R, C;\nchar grid[MAX_SIZE][MAX_SIZE + 1];\nchar red[MAX_SIZE][MAX_SIZE + 1];\nchar blue[MAX_SIZE][MAX_SIZE + 1];\n\nint main() {\n    scanf(\"%d %d\", &R, &C);\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Initialize red and blue grids\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            red[i][j] = '.';\n            blue[i][j] = '.';\n        }\n        red[i][C] = '\\0';\n        blue[i][C] = '\\0';\n    }\n\n    // Fill red and blue grids\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (grid[i][j] == '#') {\n                red[i][j] = '#';\n                blue[i][j] = '#';\n            }\n        }\n    }\n\n    // Ensure 4-connectivity for red\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (red[i][j] == '#') {\n                if (i > 0 && red[i-1][j] == '.') red[i-1][j] = '#';\n                if (i < R-1 && red[i+1][j] == '.') red[i+1][j] = '#';\n                if (j > 0 && red[i][j-1] == '.') red[i][j-1] = '#';\n                if (j < C-1 && red[i][j+1] == '.') red[i][j+1] = '#';\n            }\n        }\n    }\n\n    // Ensure 4-connectivity for blue\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (blue[i][j] == '#') {\n                if (i > 0 && blue[i-1][j] == '.') blue[i-1][j] = '#';\n                if (i < R-1 && blue[i+1][j] == '.') blue[i+1][j] = '#';\n                if (j > 0 && blue[i][j-1] == '.') blue[i][j-1] = '#';\n                if (j < C-1 && blue[i][j+1] == '.') blue[i][j+1] = '#';\n            }\n        }\n    }\n\n    // Output red grid\n    for (int i = 0; i < R; i++) {\n        printf(\"%s\\n\", red[i]);\n    }\n    printf(\"\\n\");\n    // Output blue grid\n    for (int i = 0; i < R; i++) {\n        printf(\"%s\\n\", blue[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    vector<string> red(H, string(W, '.'));\n    vector<string> blue(H, string(W, '.'));\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '#') {\n                red[i][j] = '#';\n                blue[i][j] = '#';\n            }\n        }\n    }\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (i % 2 == 0) {\n                if (j != W - 1) {\n                    red[i][j] = '#';\n                }\n            } else {\n                if (j == 0) {\n                    red[i][j] = '#';\n                }\n            }\n        }\n    }\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == '#') {\n                continue;\n            }\n            if (red[i][j] == '#') {\n                blue[i][j] = '.';\n            } else {\n                blue[i][j] = '#';\n            }\n        }\n    }\n\n    for (const string &row : red) {\n        cout << row << endl;\n    }\n    cout << endl;\n    for (const string &row : blue) {\n        cout << row << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n    static int H, W;\n    static char[][] grid;\n    static boolean[][] visited;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            grid[i] = sc.next().toCharArray();\n        }\n\n        char[][] red = new char[H][W];\n        char[][] blue = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            Arrays.fill(red[i], '.');\n            Arrays.fill(blue[i], '.');\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == '#') {\n                    red[i][j] = '#';\n                    blue[i][j] = '#';\n                }\n            }\n        }\n\n        // Expand red to the left and right\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (red[i][j] == '#') {\n                    if (j > 0 && red[i][j-1] == '.') {\n                        red[i][j-1] = '#';\n                    }\n                    if (j < W-1 && red[i][j+1] == '.') {\n                        red[i][j+1] = '#';\n                    }\n                }\n            }\n        }\n\n        // Expand blue up and down\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (blue[i][j] == '#') {\n                    if (i > 0 && blue[i-1][j] == '.') {\n                        blue[i-1][j] = '#';\n                    }\n                    if (i < H-1 && blue[i+1][j] == '.') {\n                        blue[i+1][j] = '#';\n                    }\n                }\n            }\n        }\n\n        // Ensure 4-connectivity for red\n        visited = new boolean[H][W];\n        boolean redFound = false;\n        for (int i = 0; i < H && !redFound; i++) {\n            for (int j = 0; j < W && !redFound; j++) {\n                if (red[i][j] == '#') {\n                    dfsRed(red, i, j);\n                    redFound = true;\n                }\n            }\n        }\n\n        // Ensure 4-connectivity for blue\n        visited = new boolean[H][W];\n        boolean blueFound = false;\n        for (int i = 0; i < H && !blueFound; i++) {\n            for (int j = 0; j < W && !blueFound; j++) {\n                if (blue[i][j] == '#') {\n                    dfsBlue(blue, i, j);\n                    blueFound = true;\n                }\n            }\n        }\n\n        // Output red\n        for (int i = 0; i < H; i++) {\n            System.out.println(new String(red[i]));\n        }\n        System.out.println();\n        // Output blue\n        for (int i = 0; i < H; i++) {\n            System.out.println(new String(blue[i]));\n        }\n    }\n\n    static void dfsRed(char[][] red, int i, int j) {\n        visited[i][j] = true;\n        for (int d = 0; d < 4; d++) {\n            int ni = i + dx[d];\n            int nj = j + dy[d];\n            if (ni >= 0 && ni < H && nj >= 0 && nj < W && red[ni][nj] == '#' && !visited[ni][nj]) {\n                dfsRed(red, ni, nj);\n            }\n        }\n    }\n\n    static void dfsBlue(char[][] blue, int i, int j) {\n        visited[i][j] = true;\n        for (int d = 0; d < 4; d++) {\n            int ni = i + dx[d];\n            int nj = j + dy[d];\n            if (ni >= 0 && ni < H && nj >= 0 && nj < W && blue[ni][nj] == '#' && !visited[ni][nj]) {\n                dfsBlue(blue, ni, nj);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:38:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SnukeCielPainting {\n    static final int[] dx = {0, 0, 1, -1};\n    static final int[] dy = {1, -1, 0, 0};\n    \n    public static void solve(char[][] purple) {\n        int H = purple.length;\n        int W = purple[0].length;\n        char[][] red = new char[H][W];\n        char[][] blue = new char[H][W];\n        \n        for (int i = 0; i < H; i++) {\n            Arrays.fill(red[i], '.');\n            Arrays.fill(blue[i], '.');\n        }\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (purple[i][j] == '#') {\n                    if (!tryPaint(purple, red, blue, i, j)) {\n                        System.out.println(\"No Solution\");\n                        return;\n                    }\n                }\n            }\n        }\n        \n        printSolution(red);\n        System.out.println(\"---\");\n        printSolution(blue);\n    }\n    \n    static boolean tryPaint(char[][] purple, char[][] red, char[][] blue, int startX, int startY) {\n        if (red[startX][startY] == '#' || blue[startX][startY] == '#') \n            return true;\n        \n        Queue<int[]> redQueue = new LinkedList<>();\n        Queue<int[]> blueQueue = new LinkedList<>();\n        \n        redQueue.offer(new int[]{startX, startY});\n        red[startX][startY] = '#';\n        \n        while (!redQueue.isEmpty()) {\n            int[] curr = redQueue.poll();\n            int x = curr[0], y = curr[1];\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                \n                if (nx < 0 || nx >= purple.length || ny < 0 || ny >= purple[0].length) \n                    continue;\n                \n                if (purple[nx][ny] == '#') {\n                    if (blue[nx][ny] == '#') \n                        return false;\n                    \n                    if (red[nx][ny] == '.') {\n                        red[nx][ny] = '#';\n                        redQueue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n        \n        blueQueue.offer(new int[]{startX, startY});\n        blue[startX][startY] = '#';\n        \n        while (!blueQueue.isEmpty()) {\n            int[] curr = blueQueue.poll();\n            int x = curr[0], y = curr[1];\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = x + dx[k], ny = y + dy[k];\n                \n                if (nx < 0 || nx >= purple.length || ny < 0 || ny >= purple[0].length) \n                    continue;\n                \n                if (purple[nx][ny] == '#') {\n                    if (red[nx][ny] == '#') \n                        return false;\n                    \n                    if (blue[nx][ny] == '.') {\n                        blue[nx][ny] = '#';\n                        blueQueue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    static void printSolution(char[][] matrix) {\n        for (char[] row : matrix) {\n            System.out.println(new String(row));\n        }\n    }\n    \n    public static void main(String[] args) {\n        char[][] purple = {\n            {'#', '.', '#'},\n            {'.', '#', '.'},\n            {'#', '.', '#'}\n        };\n        solve(purple);\n    }\n}",
    "timestamp": "2025-08-05 23:39:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <string>\n#include <iostream>\nusing namespace std;\n\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nvector<vector<char>> solve(vector<vector<char>>& purple) {\n    int h = purple.size(), w = purple[0].size();\n    vector<vector<char>> result(h, vector<char>(w, '.'));\n    \n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (purple[i][j] == '#') {\n                bool foundRed = false, foundBlue = false;\n                \n                for (int bit = 0; bit < (1 << 4); bit++) {\n                    bool valid = true;\n                    vector<vector<char>> temp = result;\n                    \n                    for (int k = 0; k < 4; k++) {\n                        if (bit & (1 << k)) {\n                            int nx = i + dx[k], ny = j + dy[k];\n                            if (nx < 0 || nx >= h || ny < 0 || ny >= w || \n                                purple[nx][ny] == '#') {\n                                valid = false;\n                                break;\n                            }\n                            temp[nx][ny] = '#';\n                        }\n                    }\n                    \n                    if (valid) {\n                        temp[i][j] = '#';\n                        if (!foundRed) {\n                            result = temp;\n                            foundRed = true;\n                        } else if (!foundBlue) {\n                            for (int x = 0; x < h; x++) {\n                                for (int y = 0; y < w; y++) {\n                                    if (result[x][y] == '#' && temp[x][y] == '#') {\n                                        valid = false;\n                                        break;\n                                    }\n                                }\n                                if (!valid) break;\n                            }\n                            \n                            if (valid) {\n                                for (int x = 0; x < h; x++) {\n                                    for (int y = 0; y < w; y++) {\n                                        if (temp[x][y] == '#') {\n                                            result[x][y] = temp[x][y];\n                                        }\n                                    }\n                                }\n                                foundBlue = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                \n                if (!foundRed || !foundBlue) return {};\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    \n    vector<vector<char>> purple(h, vector<char>(w));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> purple[i][j];\n        }\n    }\n    \n    vector<vector<char>> result = solve(purple);\n    \n    if (result.empty()) {\n        cout << \"No solution\" << endl;\n    } else {\n        for (auto& row : result) {\n            for (char c : row) {\n                cout << c;\n            }\n            cout << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:39:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_connected_component(matrix, start, mark, target):\n    n, m = len(matrix), len(matrix[0])\n    queue = [start]\n    matrix[start[0]][start[1]] = mark\n\n    while queue:\n        x, y = queue.pop(0)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == target:\n                matrix[nx][ny] = mark\n                queue.append((nx, ny))\n\ndef find_solution(matrix):\n    n, m = len(matrix), len(matrix[0])\n    red = [['.'] * m for _ in range(n)]\n    blue = [['.'] * m for _ in range(n)]\n\n    # Find the first purple cell and use BFS to mark two connected components\n    found = False\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == '#':\n                find_connected_component(matrix, (i, j), 'R', '#')\n                found = True\n                break\n        if found: break\n\n    found = False\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == '#':\n                find_connected_component(matrix, (i, j), 'B', '#')\n                found = True\n                break\n        if found: break\n\n    # Create separate matrices for red and blue components\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 'R':\n                red[i][j] = '#'\n            elif matrix[i][j] == 'B':\n                blue[i][j] = '#'\n\n    return red, blue\n\ndef print_matrix(matrix):\n    for row in matrix:\n        print(''.join(row))\n\ndef main():\n    import sys\n    sys.setrecursionlimit(10**6)\n\n    # Read and parse input\n    matrix = [list(line.strip()) for line in sys.stdin if line.strip()]\n    \n    # Find consistent red and blue sets and output them\n    red, blue = find_solution(matrix)\n    print_matrix(red)\n    print()  # Blank line between outputs\n    print_matrix(blue)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 16:22:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphPaper {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        scanner.nextLine();\n\n        char[][] purpleCells = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            purpleCells[i] = scanner.nextLine().toCharArray();\n        }\n\n        char[][] redCells = new char[h][w];\n        char[][] blueCells = new char[h][w];\n        for (int i = 0; i < h; i++) {\n            Arrays.fill(redCells[i], '.');\n            Arrays.fill(blueCells[i], '.');\n        }\n\n        // Use a BFS or DFS to fill in red and blue cells\n        fillCells(purpleCells, redCells, '#', h, w);\n        fillCells(purpleCells, blueCells, 'B', h, w);\n\n        // Output the red cells\n        for (int i = 0; i < h; i++) {\n            System.out.println(new String(redCells[i]));\n        }\n        System.out.println();\n        // Output the blue cells\n        for (int i = 0; i < h; i++) {\n            System.out.println(new String(blueCells[i]));\n        }\n    }\n\n    private static void fillCells(char[][] purpleCells, char[][] resultCells, char mark, int h, int w) {\n        boolean found = false;\n        for (int i = 0; i < h && !found; i++) {\n            for (int j = 0; j < w && !found; j++) {\n                if (purpleCells[i][j] == '#') {\n                    dfs(purpleCells, resultCells, i, j, mark, h, w);\n                    found = true;\n                }\n            }\n        }\n    }\n\n    private static void dfs(char[][] purpleCells, char[][] resultCells, int x, int y, char mark, int h, int w) {\n        if (x < 0 || y < 0 || x >= h || y >= w || purpleCells[x][y] != '#' || resultCells[x][y] == '#') {\n            return;\n        }\n        resultCells[x][y] = mark;\n        dfs(purpleCells, resultCells, x + 1, y, mark, h, w);\n        dfs(purpleCells, resultCells, x - 1, y, mark, h, w);\n        dfs(purpleCells, resultCells, x, y + 1, mark, h, w);\n        dfs(purpleCells, resultCells, x, y - 1, mark, h, w);\n    }\n}",
    "timestamp": "2025-08-13 16:23:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 50\n\ntypedef struct {\n    int row, col;\n} Cell;\n\nCell queue[MAXN * MAXN];\nint front, rear;\n\nvoid enqueue(int r, int c) {\n    queue[rear].row = r;\n    queue[rear].col = c;\n    rear++;\n}\n\nCell dequeue() {\n    return queue[front++];\n}\n\nint isEmpty() {\n    return front == rear;\n}\n\nvoid bfs(char grid[MAXN][MAXN], int n, int m, char targetChar, char fillChar, int startRow, int startCol) {\n    int dr[] = {-1, 1, 0, 0}, dc[] = {0, 0, -1, 1};\n\n    front = rear = 0;\n    enqueue(startRow, startCol);\n\n    while (!isEmpty()) {\n        Cell curr = dequeue();\n        int row = curr.row;\n        int col = curr.col;\n\n        if (grid[row][col] == targetChar) {\n            grid[row][col] = fillChar;\n\n            for (int k = 0; k < 4; k++) {\n                int newRow = row + dr[k];\n                int newCol = col + dc[k];\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m && grid[newRow][newCol] == targetChar) {\n                    enqueue(newRow, newCol);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    char purpleGrid[MAXN][MAXN];\n    char redGrid[MAXN][MAXN];\n    char blueGrid[MAXN][MAXN];\n\n    // Read the purple grid and initialize red and blue grids as empty\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", purpleGrid[i]);\n        for (int j = 0; j < m; j++) {\n            redGrid[i][j] = '.';\n            blueGrid[i][j] = '.';\n        }\n    }\n\n    // Find the first purple cell and use it as a starting point for red\n    for (int i = 0; i < n; i++) {\n        int found = 0;\n        for (int j = 0; j < m; j++) {\n            if (purpleGrid[i][j] == '#') {\n                bfs(purpleGrid, n, m, '#', 'R', i, j);\n                found = 1;\n                break;\n            }\n        }\n        if (found) break;\n    }\n\n    // Copy the results to the red grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (purpleGrid[i][j] == 'R') {\n                redGrid[i][j] = '#';\n            }\n        }\n    }\n\n    // Find the first remaining purple cell and use it as a starting point for blue\n    for (int i = 0; i < n; i++) {\n        int found = 0;\n        for (int j = 0; j < m; j++) {\n            if (purpleGrid[i][j] == '#') {\n                bfs(purpleGrid, n, m, '#', 'B', i, j);\n                found = 1;\n                break;\n            }\n        }\n        if (found) break;\n    }\n\n    // Copy the results to the blue grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (purpleGrid[i][j] == 'B') {\n                blueGrid[i][j] = '#';\n            }\n        }\n    }\n\n    // Output the red grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", redGrid[i]);\n    }\n\n    // Output a blank line\n    printf(\"\\n\");\n\n    // Output the blue grid\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", blueGrid[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:23:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvoid bfs(vector<vector<char>>& result, int startRow, int startCol, char color) {\n    int h = result.size();\n    int w = result[0].size();\n    queue<pair<int, int>> q;\n    vector<vector<bool>> visited(h, vector<bool>(w, false));\n    q.push({startRow, startCol});\n    visited[startRow][startCol] = true;\n\n    int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    while (!q.empty()) {\n        auto [r, c] = q.front();\n        q.pop();\n        result[r][c] = color;\n        \n        for (auto& dir : dirs) {\n            int nr = r + dir[0], nc = c + dir[1];\n            if (nr >= 0 && nr < h && nc >= 0 && nc < w && !visited[nr][nc] && result[nr][nc] != '#') {\n                visited[nr][nc] = true;\n                q.push({nr, nc});\n            }\n        }\n    }\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n\n    vector<vector<char>> grid(h, vector<char>(w));\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<vector<char>> red(h, vector<char>(w, '.'));\n    vector<vector<char>> blue(h, vector<char>(w, '.'));\n\n    // Finding the first purple cell to be part of the red component\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (grid[i][j] == '#') {\n                bfs(red, i, j, '#');\n                goto found1;\n            }\n        }\n    }\n\nfound1:\n\n    // Finding the first purple cell to be part of the blue component\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (grid[i][j] == '#' && red[i][j] == '.') {\n                bfs(blue, i, j, '#');\n                goto found2;\n            }\n        }\n    }\n\nfound2:\n\n    // Output the result\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cout << red[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cout << blue[i][j];\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 16:23:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_color_overlap(purple_grid):\n    rows, cols = len(purple_grid), len(purple_grid[0])\n    \n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n    \n    def is_4_connected(grid):\n        visited = [[False]*cols for _ in range(rows)]\n        components = 0\n        \n        def dfs(r, c):\n            if not is_valid(r, c) or not grid[r][c] or visited[r][c]:\n                return\n            visited[r][c] = True\n            for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n                dfs(r+dr, c+dc)\n        \n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] and not visited[r][c]:\n                    dfs(r, c)\n                    components += 1\n        \n        return components == 1\n    \n    for red_config in range(1 << (rows * cols)):\n        red_grid = [[False]*cols for _ in range(rows)]\n        for r in range(rows):\n            for c in range(cols):\n                red_grid[r][c] = bool((red_config >> (r*cols + c)) & 1)\n        \n        blue_grid = [[False]*cols for _ in range(rows)]\n        for r in range(rows):\n            for c in range(cols):\n                blue_grid[r][c] = (purple_grid[r][c] != '.') and not red_grid[r][c]\n        \n        if all(red_grid[r][c] or blue_grid[r][c] or purple_grid[r][c] == '.' \n               for r in range(rows) for c in range(cols)) and \\\n           is_4_connected(red_grid) and is_4_connected(blue_grid):\n            result = []\n            for r in range(rows):\n                row = ''\n                for c in range(cols):\n                    row += '#' if red_grid[r][c] else '#' if blue_grid[r][c] else '.'\n                result.append(row)\n            return result\n    \n    return None",
    "timestamp": "2025-08-13 16:23:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [list(sys.stdin.readline().strip()) for _ in range(H)]\n    \n    red = [['.' for _ in range(W)] for _ in range(H)]\n    blue = [['.' for _ in range(W)] for _ in range(H)]\n    \n    # Mark purple cells as red and blue\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                red[i][j] = '#'\n                blue[i][j] = '#'\n    \n    # Expand red to the left and right\n    for i in range(H):\n        for j in range(W):\n            if red[i][j] == '#':\n                # Mark left and right in red\n                if j > 0 and red[i][j-1] == '.':\n                    red[i][j-1] = '#'\n                if j < W-1 and red[i][j+1] == '.':\n                    red[i][j+1] = '#'\n    \n    # Expand blue up and down\n    for j in range(W):\n        for i in range(H):\n            if blue[i][j] == '#':\n                # Mark up and down in blue\n                if i > 0 and blue[i-1][j] == '.':\n                    blue[i-1][j] = '#'\n                if i < H-1 and blue[i+1][j] == '.':\n                    blue[i+1][j] = '#'\n    \n    # Output red\n    for row in red:\n        print(''.join(row))\n    print()\n    # Output blue\n    for row in blue:\n        print(''.join(row))\n\nsolve()",
    "timestamp": "2025-08-13 16:23:48"
  }
]