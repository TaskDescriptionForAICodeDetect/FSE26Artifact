[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_H 300\n#define MAX_W 300\n\nchar grid[MAX_H][MAX_W + 1];\n\nbool can_make_symmetric(int H, int W) {\n    char rows[MAX_H][MAX_W + 1];\n    char cols[MAX_W][MAX_H + 1];\n    \n    // Copy original grid\n    for (int i = 0; i < H; i++) {\n        strcpy(rows[i], grid[i]);\n    }\n    \n    // Prepare columns\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            cols[j][i] = grid[i][j];\n        }\n        cols[j][H] = '\\0';\n    }\n    \n    // Check symmetry\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] != grid[H - 1 - i][W - 1 - j]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    printf(\"%s\\n\", can_make_symmetric(H, W) ? \"YES\" : \"NO\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\nint H, W;\nchar grid[MAX_SIZE][MAX_SIZE + 1];\nbool used_row[MAX_SIZE];\nbool used_col[MAX_SIZE];\n\nbool check_rows() {\n    memset(used_row, 0, sizeof(used_row));\n    for (int i = 0; i < H; i++) {\n        if (used_row[i]) continue;\n        for (int j = i + 1; j < H; j++) {\n            if (used_row[j]) continue;\n            bool match = true;\n            for (int k = 0; k < W; k++) {\n                if (grid[i][k] != grid[j][W - 1 - k]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                used_row[i] = used_row[j] = true;\n                break;\n            }\n        }\n        if (!used_row[i]) {\n            if (H % 2 == 0) return false;\n            bool is_palindrome = true;\n            for (int k = 0; k < W; k++) {\n                if (grid[i][k] != grid[i][W - 1 - k]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n            if (!is_palindrome) return false;\n            used_row[i] = true;\n        }\n    }\n    return true;\n}\n\nbool check_cols() {\n    memset(used_col, 0, sizeof(used_col));\n    for (int k = 0; k < W; k++) {\n        if (used_col[k]) continue;\n        for (int l = k + 1; l < W; l++) {\n            if (used_col[l]) continue;\n            bool match = true;\n            for (int i = 0; i < H; i++) {\n                if (grid[i][k] != grid[H - 1 - i][l]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                used_col[k] = used_col[l] = true;\n                break;\n            }\n        }\n        if (!used_col[k]) {\n            if (W % 2 == 0) return false;\n            bool is_palindrome = true;\n            for (int i = 0; i < H; i++) {\n                if (grid[i][k] != grid[H - 1 - i][k]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n            if (!is_palindrome) return false;\n            used_col[k] = true;\n        }\n    }\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    if (check_rows() && check_cols()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nbool canMakeSymmetric(vector<string>& grid, int H, int W) {\n    // Check rows\n    vector<bool> rowUsed(H, false);\n    for (int i = 0; i < H; ++i) {\n        if (rowUsed[i]) continue;\n        string target = grid[i];\n        reverse(target.begin(), target.end());\n        bool found = false;\n        for (int j = i + 1; j < H; ++j) {\n            if (!rowUsed[j] && grid[j] == target) {\n                rowUsed[j] = true;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (H % 2 == 1 && !rowUsed[H / 2]) {\n                string temp = grid[i];\n                reverse(temp.begin(), temp.end());\n                if (temp == grid[i]) {\n                    rowUsed[H / 2] = true;\n                    continue;\n                }\n            }\n            return false;\n        }\n    }\n\n    // Check columns\n    vector<string> transposed(W, string(H, ' '));\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            transposed[j][i] = grid[i][j];\n        }\n    }\n\n    vector<bool> colUsed(W, false);\n    for (int i = 0; i < W; ++i) {\n        if (colUsed[i]) continue;\n        string target = transposed[i];\n        reverse(target.begin(), target.end());\n        bool found = false;\n        for (int j = i + 1; j < W; ++j) {\n            if (!colUsed[j] && transposed[j] == target) {\n                colUsed[j] = true;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (W % 2 == 1 && !colUsed[W / 2]) {\n                string temp = transposed[i];\n                reverse(temp.begin(), temp.end());\n                if (temp == transposed[i]) {\n                    colUsed[W / 2] = true;\n                    continue;\n                }\n            }\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n    if (canMakeSymmetric(grid, H, W)) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine();\n        String[] grid = new String[H];\n        for (int i = 0; i < H; i++) {\n            grid[i] = scanner.nextLine();\n        }\n\n        boolean[] rowUsed = new boolean[H];\n        boolean possible = true;\n\n        for (int i = 0; i < H; i++) {\n            if (rowUsed[i]) continue;\n            boolean found = false;\n            for (int j = i + 1; j < H; j++) {\n                if (!rowUsed[j] && isReverse(grid[i], grid[j])) {\n                    rowUsed[i] = true;\n                    rowUsed[j] = true;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found && H % 2 == 1) {\n                if (isPalindrome(grid[i])) {\n                    rowUsed[i] = true;\n                    found = true;\n                }\n            }\n            if (!found) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            System.out.println(\"NO\");\n            return;\n        }\n\n        possible = true;\n        boolean[] colUsed = new boolean[W];\n        for (int j = 0; j < W; j++) {\n            if (colUsed[j]) continue;\n            boolean found = false;\n            for (int k = j + 1; k < W; k++) {\n                if (!colUsed[k] && isColumnReverse(grid, j, k)) {\n                    colUsed[j] = true;\n                    colUsed[k] = true;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found && W % 2 == 1) {\n                if (isColumnPalindrome(grid, j)) {\n                    colUsed[j] = true;\n                    found = true;\n                }\n            }\n            if (!found) {\n                possible = false;\n                break;\n            }\n        }\n\n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n\n    private static boolean isReverse(String a, String b) {\n        for (int i = 0; i < a.length(); i++) {\n            if (a.charAt(i) != b.charAt(b.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isColumnReverse(String[] grid, int col1, int col2) {\n        int H = grid.length;\n        for (int i = 0; i < H; i++) {\n            if (grid[i].charAt(col1) != grid[H - 1 - i].charAt(col2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isColumnPalindrome(String[] grid, int col) {\n        int H = grid.length;\n        for (int i = 0; i < H / 2; i++) {\n            if (grid[i].charAt(col) != grid[H - 1 - i].charAt(col)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:08:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public boolean canMakeSymmetric(String[] grid) {\n        int H = grid.length;\n        int W = grid[0].length();\n        \n        // Check row frequencies\n        int[] rowFreq = new int[26];\n        for (String row : grid) {\n            for (char c : row.toCharArray()) {\n                rowFreq[c - 'a']++;\n            }\n        }\n        \n        // Check column frequencies\n        int[] colFreq = new int[26];\n        for (int j = 0; j < W; j++) {\n            for (int i = 0; i < H; i++) {\n                colFreq[grid[i].charAt(j) - 'a']++;\n            }\n        }\n        \n        // Check if row frequencies match\n        for (int i = 0; i < 26; i++) {\n            if (rowFreq[i] % 2 != 0) return false;\n        }\n        \n        // Check if column frequencies match\n        for (int i = 0; i < 26; i++) {\n            if (colFreq[i] % 2 != 0) return false;\n        }\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:08:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    bool canMakeSymmetric(vector<string>& grid) {\n        int H = grid.size();\n        int W = grid[0].length();\n        \n        vector<vector<char>> charGrid(H, vector<char>(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                charGrid[i][j] = grid[i][j];\n            }\n        }\n        \n        vector<int> rowSignature(H);\n        vector<int> colSignature(W);\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                rowSignature[i] += (1 << (charGrid[i][j] - 'a'));\n                colSignature[j] += (1 << (charGrid[i][j] - 'a'));\n            }\n        }\n        \n        vector<int> rowOrder(H);\n        vector<int> colOrder(W);\n        iota(rowOrder.begin(), rowOrder.end(), 0);\n        iota(colOrder.begin(), colOrder.end(), 0);\n        \n        sort(rowOrder.begin(), rowOrder.end(), \n            [&](int a, int b) { return rowSignature[a] < rowSignature[b]; });\n        sort(colOrder.begin(), colOrder.end(), \n            [&](int a, int b) { return colSignature[a] < colSignature[b]; });\n        \n        for (int i = 0; i < H; i++) {\n            if (charGrid[i][0] != charGrid[H - 1 - i][W - 1]) {\n                swap(rowOrder[i], rowOrder[H - 1 - i]);\n            }\n        }\n        \n        for (int j = 0; j < W; j++) {\n            if (charGrid[0][j] != charGrid[H - 1][W - 1 - j]) {\n                swap(colOrder[j], colOrder[W - 1 - j]);\n            }\n        }\n        \n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (charGrid[rowOrder[i]][colOrder[j]] != \n                    charGrid[H - 1 - rowOrder[i]][W - 1 - colOrder[j]]) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n};",
    "timestamp": "2025-08-05 23:08:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_symmetric_grid_possible(grid):\n    H = len(grid)\n    W = len(grid[0])\n    \n    for i in range(H // 2):\n        row1, row2 = grid[i], grid[H - 1 - i]\n        \n        if sorted(row1) != sorted(row2):\n            return False\n\n    for j in range(W // 2):\n        col1 = [grid[i][j] for i in range(H)]\n        col2 = [grid[i][W - 1 - j] for i in range(H)]\n\n        if sorted(col1) != sorted(col2):\n            return False\n\n    return True\n\n# Example usage\nH = 4\nW = 4\ngrid = [\n    \"abca\",\n    \"bdec\",\n    \"cdeb\",\n    \"acba\"\n]\n\nprint(is_symmetric_grid_possible(grid))  # Output: True",
    "timestamp": "2025-08-13 13:46:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SymmetricGrid {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine(); // Consume the remaining newline\n\n        char[][] grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            grid[i] = scanner.nextLine().toCharArray();\n        }\n\n        // Check if symmetry can be achieved\n        boolean canBeSymmetric = canMakeSymmetric(grid, H, W);\n\n        if (canBeSymmetric) {\n            System.out.println(\"YES\");\n        } else {\n            System.out.println(\"NO\");\n        }\n\n        scanner.close();\n    }\n\n    private static boolean canMakeSymmetric(char[][] grid, int H, int W) {\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] != grid[H - 1 - i][W - 1 - j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 13:46:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool canMakeSymmetric(char grid[][100], int H, int W) {\n    for (int i = 0; i < H / 2; ++i) {\n        bool rowMatchFound = false;\n        for (int k = i; k < H; ++k) {\n            bool isRowSymmetric = true;\n            for (int j = i; j < W; ++j) {\n                if (grid[i][j] != grid[H - 1 - k][W - 1 - j]) {\n                    isRowSymmetric = false;\n                    break;\n                }\n            }\n            if (isRowSymmetric) {\n                rowMatchFound = true;\n                break;\n            }\n        }\n        if (!rowMatchFound) {\n            return false;\n        }\n\n        bool colMatchFound = false;\n        for (int k = i; k < W; ++k) {\n            bool isColSymmetric = true;\n            for (int j = i; j < H; ++j) {\n                if (grid[j][i] != grid[H - 1 - j][W - 1 - k]) {\n                    isColSymmetric = false;\n                    break;\n                }\n            }\n            if (isColSymmetric) {\n                colMatchFound = true;\n                break;\n            }\n        }\n        if (!colMatchFound) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int H, W;\n    char grid[100][100];\n    \n    // Read grid dimensions\n    scanf(\"%d %d\", &H, &W);\n\n    // Read the grid strings\n    for (int i = 0; i < H; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    if (canMakeSymmetric(grid, H, W)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:46:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canMakeSymmetric(grid) {\n    const H = grid.length;\n    const W = grid[0].length;\n\n    for (let i = 0; i < Math.floor(H / 2); i++) {\n        const row1 = grid[i];\n        const row2 = grid[H - 1 - i];\n        const row1Sorted = row1.slice().sort().join('');\n        const row2Sorted = row2.slice().sort().join('');\n        if (row1Sorted !== row2Sorted) return false;\n    }\n\n    for (let j = 0; j < Math.floor(W / 2); j++) {\n        const col1 = [];\n        const col2 = [];\n        for (let i = 0; i < H; i++) {\n            col1.push(grid[i][j]);\n            col2.push(grid[i][W - 1 - j]);\n        }\n        const col1Sorted = col1.sort().join('');\n        const col2Sorted = col2.sort().join('');\n        if (col1Sorted !== col2Sorted) return false;\n    }\n\n    return true;\n}",
    "timestamp": "2025-08-13 13:46:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def isSymmetric(self, grid):\n        H, W = len(grid), len(grid[0])\n        \n        # Create row and column arrays\n        rows = [''.join(row) for row in grid]\n        cols = [''.join(grid[r][c] for r in range(H)) for c in range(W)]\n        \n        # Check if rows can be sorted to make the grid symmetric\n        sorted_rows = sorted(rows)\n        \n        # Check if columns can be sorted to make the grid symmetric\n        sorted_cols = sorted(cols)\n        \n        # Try all permutations of row sorting\n        for r_perm in self.generate_permutations(sorted_rows):\n            # Try all permutations of column sorting\n            for c_perm in self.generate_permutations(sorted_cols):\n                # Construct test grid\n                test_grid = [list(row) for row in r_perm]\n                test_grid = list(zip(*[list(col) for col in c_perm]))\n                test_grid = [list(map(''.join, zip(*row))) for row in test_grid]\n                \n                # Check symmetry of test grid\n                if self.check_symmetry(test_grid):\n                    return True\n        \n        return False\n    \n    def generate_permutations(self, arr):\n        if len(arr) <= 1:\n            yield arr\n            return\n        \n        for i in range(len(arr)):\n            rest = arr[:i] + arr[i+1:]\n            for perm in self.generate_permutations(rest):\n                yield [arr[i]] + perm\n    \n    def check_symmetry(self, grid):\n        H, W = len(grid), len(grid[0])\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] != grid[H-1-i][W-1-j]:\n                    return False\n        return True",
    "timestamp": "2025-08-13 13:46:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canMakeSymmetric(grid) {\n    const H = grid.length;\n    const W = grid[0].length;\n    \n    let rowFreq = new Array(H).fill(0).map(() => new Array(26).fill(0));\n    let colFreq = new Array(W).fill(0).map(() => new Array(26).fill(0));\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            let charCode = grid[i][j].charCodeAt(0) - 'a'.charCodeAt(0);\n            rowFreq[i][charCode]++;\n            colFreq[j][charCode]++;\n        }\n    }\n    \n    let rowPossibleSwaps = new Set();\n    let colPossibleSwaps = new Set();\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = i + 1; j < H; j++) {\n            if (JSON.stringify(rowFreq[i]) === JSON.stringify(rowFreq[j])) {\n                rowPossibleSwaps.add(i);\n                rowPossibleSwaps.add(j);\n            }\n        }\n    }\n    \n    for (let i = 0; i < W; i++) {\n        for (let j = i + 1; j < W; j++) {\n            if (JSON.stringify(colFreq[i]) === JSON.stringify(colFreq[j])) {\n                colPossibleSwaps.add(i);\n                colPossibleSwaps.add(j);\n            }\n        }\n    }\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (grid[i][j] !== grid[H - 1 - i][W - 1 - j]) {\n                if (!(rowPossibleSwaps.has(i) && rowPossibleSwaps.has(H - 1 - i)) &&\n                    !(colPossibleSwaps.has(j) && colPossibleSwaps.has(W - 1 - j))) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}",
    "timestamp": "2025-08-13 13:46:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Check row symmetry\n    used = [False] * H\n    for i in range(H):\n        if used[i]:\n            continue\n        found = -1\n        for j in range(i+1, H):\n            if not used[j] and grid[i] == grid[j][::-1]:\n                found = j\n                break\n        if found != -1:\n            used[i] = used[found] = True\n        else:\n            if grid[i] != grid[i][::-1]:\n                print(\"NO\")\n                return\n            if H % 2 == 0:\n                print(\"NO\")\n                return\n            else:\n                if any(used[k] and k == H//2 for k in range(H)):\n                    print(\"NO\")\n                    return\n                used[i] = True\n    \n    # Transpose the grid to check column symmetry\n    transposed = []\n    for j in range(W):\n        col = ''.join([grid[i][j] for i in range(H)])\n        transposed.append(col)\n    \n    used_col = [False] * W\n    for i in range(W):\n        if used_col[i]:\n            continue\n        found = -1\n        for j in range(i+1, W):\n            if not used_col[j] and transposed[i] == transposed[j][::-1]:\n                found = j\n                break\n        if found != -1:\n            used_col[i] = used_col[found] = True\n        else:\n            if transposed[i] != transposed[i][::-1]:\n                print(\"NO\")\n                return\n            if W % 2 == 0:\n                print(\"NO\")\n                return\n            else:\n                if any(used_col[k] and k == W//2 for k in range(W)):\n                    print(\"NO\")\n                    return\n                used_col[i] = True\n    print(\"YES\")\n\nsolve()",
    "timestamp": "2025-08-13 13:46:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let H, W;\n    let grid = [];\n    let lineCount = 0;\n\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            [H, W] = line.split(' ').map(Number);\n            lineCount++;\n        } else {\n            grid.push(line.trim());\n            if (grid.length === H) {\n                rl.close();\n            }\n        }\n    });\n\n    rl.on('close', () => {\n        let possible = true;\n        let usedRows = new Array(H).fill(false);\n        \n        for (let i = 0; i < H; i++) {\n            if (usedRows[i]) continue;\n            let found = -1;\n            for (let j = i + 1; j < H; j++) {\n                if (usedRows[j]) continue;\n                let match = true;\n                for (let k = 0; k < W; k++) {\n                    if (grid[i][k] !== grid[j][W - 1 - k]) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    found = j;\n                    break;\n                }\n            }\n            if (found !== -1) {\n                usedRows[i] = true;\n                usedRows[found] = true;\n            } else {\n                if (H % 2 === 1) {\n                    let isCenterPossible = true;\n                    for (let k = 0; k < W; k++) {\n                        if (grid[i][k] !== grid[i][W - 1 - k]) {\n                            isCenterPossible = false;\n                            break;\n                        }\n                    }\n                    if (isCenterPossible) {\n                        usedRows[i] = true;\n                    } else {\n                        possible = false;\n                        break;\n                    }\n                } else {\n                    possible = false;\n                    break;\n                }\n            }\n        }\n        \n        if (possible) {\n            console.log(\"YES\");\n        } else {\n            console.log(\"NO\");\n        }\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:47:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool isSymmetricPossible(const std::vector<std::string>& grid) {\n    int H = grid.size();\n    int W = grid[0].size();\n    for (int i = 0; i < H / 2; ++i) {\n        if (grid[i] != grid[H - 1 - i]) {\n            return false;\n        }\n    }\n    std::vector<std::string> cols(W);\n    for (int j = 0; j < W; ++j) {\n        for (int i = 0; i < H; ++i) {\n            cols[j].push_back(grid[i][j]);\n        }\n    }\n    for (int j = 0; j < W / 2; ++j) {\n        if (cols[j] != cols[W - 1 - j]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int H, W;\n    std::cin >> H >> W;\n    std::vector<std::string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        std::cin >> grid[i];\n    }\n    \n    if (isSymmetricPossible(grid)) {\n        std::cout << \"Yes\\n\";\n    } else {\n        std::cout << \"No\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:40:46"
  }
]