[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 100005\n#define MAX_M 100005\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N];\nint rank[MAX_N];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int px = find(x);\n    int py = find(y);\n    \n    if (px == py) return;\n    \n    if (rank[px] < rank[py]) {\n        parent[px] = py;\n    } else if (rank[px] > rank[py]) {\n        parent[py] = px;\n    } else {\n        parent[py] = px;\n        rank[px]++;\n    }\n}\n\nbool checkConsistency(int N, int M, Edge* edges) {\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n        \n        if (find(u) == find(v)) {\n            continue;\n        }\n        \n        unionSet(u, v);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n        \n        if (find(u) != find(v)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    Edge* edges = malloc(M * sizeof(Edge));\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n    \n    bool result = checkConsistency(N, M, edges);\n    \n    printf(\"%s\\n\", result ? \"YES\" : \"NO\");\n    \n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int to;\n    int d;\n} Edge;\n\nEdge *graph[100001];\nint size[100001];\nint x[100001];\nint visited[100001];\n\nvoid add_edge(int from, int to, int d) {\n    graph[from] = realloc(graph[from], (size[from] + 1) * sizeof(Edge));\n    graph[from][size[from]].to = to;\n    graph[from][size[from]].d = d;\n    size[from]++;\n}\n\nint dfs(int v) {\n    visited[v] = 1;\n    for (int i = 0; i < size[v]; i++) {\n        int to = graph[v][i].to;\n        int d = graph[v][i].d;\n        if (visited[to]) {\n            if (x[to] != x[v] + d) {\n                return 0;\n            }\n        } else {\n            x[to] = x[v] + d;\n            if (!dfs(to)) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < M; i++) {\n        int L, R, D;\n        scanf(\"%d %d %d\", &L, &R, &D);\n        add_edge(L, R, D);\n        add_edge(R, L, -D);\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        if (!visited[i]) {\n            x[i] = 0;\n            if (!dfs(i)) {\n                printf(\"No\\n\");\n                return 0;\n            }\n        }\n    }\n    \n    printf(\"Yes\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    long long cost;\n};\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<Edge>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int L, R;\n        long long D;\n        cin >> L >> R >> D;\n        adj[L].push_back({R, D});\n        adj[R].push_back({L, -D});\n    }\n\n    vector<long long> pos(N + 1, -1);\n    for (int i = 1; i <= N; ++i) {\n        if (pos[i] == -1) {\n            queue<int> q;\n            q.push(i);\n            pos[i] = 0;\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (const Edge& e : adj[u]) {\n                    if (pos[e.to] == -1) {\n                        pos[e.to] = pos[u] + e.cost;\n                        q.push(e.to);\n                    } else if (pos[e.to] != pos[u] + e.cost) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    if (solve()) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:10:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PositionChecker {\n    static class Edge {\n        int to;\n        long cost;\n        Edge(int to, long cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int L = sc.nextInt();\n            int R = sc.nextInt();\n            long D = sc.nextLong();\n            graph.get(L).add(new Edge(R, D));\n            graph.get(R).add(new Edge(L, -D));\n        }\n\n        long[] x = new long[N + 1];\n        boolean[] visited = new boolean[N + 1];\n        boolean consistent = true;\n\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                Queue<Integer> q = new LinkedList<>();\n                q.add(i);\n                x[i] = 0;\n                visited[i] = true;\n                while (!q.isEmpty()) {\n                    int current = q.poll();\n                    for (Edge edge : graph.get(current)) {\n                        if (!visited[edge.to]) {\n                            visited[edge.to] = true;\n                            x[edge.to] = x[current] + edge.cost;\n                            q.add(edge.to);\n                        } else if (x[edge.to] != x[current] + edge.cost) {\n                            consistent = false;\n                            break;\n                        }\n                    }\n                    if (!consistent) break;\n                }\n                if (!consistent) break;\n            }\n        }\n\n        System.out.println(consistent ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-05 23:10:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PositionConsistency {\n    public static boolean isConsistent(int N, int[][] constraints) {\n        List<List<Edge>> graph = new ArrayList<>(N);\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int[] constraint : constraints) {\n            int u = constraint[0] - 1;\n            int v = constraint[1] - 1;\n            int dist = constraint[2];\n            graph.get(u).add(new Edge(v, dist));\n            graph.get(v).add(new Edge(u, -dist));\n        }\n\n        int[] distances = new int[N];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[0] = 0;\n\n        for (int i = 0; i < N - 1; i++) {\n            for (int u = 0; u < N; u++) {\n                if (distances[u] == Integer.MAX_VALUE) continue;\n                for (Edge edge : graph.get(u)) {\n                    int v = edge.to;\n                    int weight = edge.weight;\n                    if (distances[u] != Integer.MAX_VALUE && distances[v] > distances[u] + weight) {\n                        distances[v] = distances[u] + weight;\n                    }\n                }\n            }\n        }\n\n        for (int u = 0; u < N; u++) {\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int weight = edge.weight;\n                if (distances[u] != Integer.MAX_VALUE && \n                    distances[v] > distances[u] + weight) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    static class Edge {\n        int to;\n        int weight;\n\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    public static void main(String[] args) {\n        int N = 3;\n        int[][] constraints = {{1, 2, 5}, {2, 3, 3}, {1, 3, 7}};\n        System.out.println(isConsistent(N, constraints));\n    }\n}",
    "timestamp": "2025-08-05 23:10:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n    vector<long long> diff;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        diff.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            int root = find(parent[x]);\n            diff[x] += diff[parent[x]];\n            parent[x] = root;\n        }\n        return parent[x];\n    }\n\n    bool unionSet(int x, int y, long long d) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) {\n            return diff[x] + d == diff[y];\n        }\n\n        if (rank[rootX] < rank[rootY]) {\n            swap(rootX, rootY);\n            swap(x, y);\n            d = -d;\n        }\n\n        parent[rootY] = rootX;\n        diff[rootY] = diff[x] - diff[y] + d;\n\n        if (rank[rootX] == rank[rootY]) {\n            rank[rootX]++;\n        }\n\n        return true;\n    }\n};\n\nbool solve(int N, int M, vector<int>& L, vector<int>& R, vector<int>& D) {\n    UnionFind uf(N);\n\n    for (int i = 0; i < M; i++) {\n        if (!uf.unionSet(L[i], R[i], D[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<int> L(M), R(M), D(M);\n    for (int i = 0; i < M; i++) {\n        cin >> L[i] >> R[i] >> D[i];\n        L[i]--; R[i]--;\n    }\n\n    bool possible = solve(N, M, L, R, D);\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_consistent(N, M, information):\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(10**6)\n\n    def dfs(node):\n        if visited[node]:\n            return True\n        visited[node] = True\n        for neighbor, distance in graph[node]:\n            if distances[neighbor] is None:\n                distances[neighbor] = distances[node] + distance\n                if not dfs(neighbor):\n                    return False\n            else:\n                if distances[neighbor] != distances[node] + distance:\n                    return False\n        return True\n    \n    graph = defaultdict(list)\n    for L_i, R_i, D_i in information:\n        graph[L_i].append((R_i, D_i))\n        graph[R_i].append((L_i, -D_i))\n    \n    distances = [None] * (N + 1)\n    visited = [False] * (N + 1)\n    \n    for i in range(1, N + 1):\n        if not visited[i]:\n            distances[i] = 0\n            if not dfs(i):\n                return False\n    \n    return True\n\n# Example usage:\nN = 5\nM = 3\ninformation = [\n    (1, 2, 3),\n    (2, 3, 4),\n    (1, 3, 7)\n]\n\nprint(is_consistent(N, M, information))  # Outputs: True or False",
    "timestamp": "2025-08-13 13:58:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ConsistentPositions {\n\n    static class Graph {\n        int V;\n        List<List<Edge>> adj;\n\n        Graph(int V) {\n            this.V = V;\n            adj = new ArrayList<>(V);\n            for (int i = 0; i < V; i++) {\n                adj.add(new ArrayList<>());\n            }\n        }\n\n        void addEdge(int u, int v, long weight) {\n            adj.get(u).add(new Edge(v, weight));\n        }\n\n        class Edge {\n            int target;\n            long weight;\n\n            Edge(int target, long weight) {\n                this.target = target;\n                this.weight = weight;\n            }\n        }\n    }\n\n    boolean isConsistent(int N, int[][] info) {\n        Graph graph = new Graph(N);\n        for (int[] piece : info) {\n            int L = piece[0], R = piece[1], D = piece[2];\n            graph.addEdge(L, R, D);\n        }\n\n        long[] dist = new long[N];\n        Arrays.fill(dist, Long.MAX_VALUE / 2);\n        dist[0] = 0;\n        boolean updated = false;\n\n        for (int i = 0; i < N; i++) {\n            updated = false;\n            for (int u = 0; u < N; u++) {\n                if (dist[u] != Long.MAX_VALUE / 2) {\n                    for (Graph.Edge edge : graph.adj.get(u)) {\n                        if (dist[edge.target] > dist[u] + edge.weight) {\n                            dist[edge.target] = dist[u] + edge.weight;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if (!updated) break;\n        }\n\n        for (int u = 0; u < N; u++) {\n            if (dist[u] != Long.MAX_VALUE / 2) {\n                for (Graph.Edge edge : graph.adj.get(u)) {\n                    if (dist[edge.target] > dist[u] + edge.weight) {\n                        return false; // Negative cycle detected\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        ConsistentPositions cp = new ConsistentPositions();\n        int N = 3;\n        int[][] info = {{0, 1, 5}, {1, 2, 3}, {0, 2, 8}};\n        System.out.println(cp.isConsistent(N, info)); // Expected output: true\n    }\n}",
    "timestamp": "2025-08-13 13:58:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n\n#define INF 1000000000\n#define MAXN 100000\n\ntypedef struct {\n    int L, R, D;\n} Information;\n\nint parent[MAXN];\nlong long pos[MAXN];\n\nint find(int x) {\n    if (parent[x] != x) {\n        int p = parent[x];\n        parent[x] = find(parent[x]);\n        pos[x] += pos[p];\n    }\n    return parent[x];\n}\n\nbool unionSets(int a, int b, int dist) {\n    int rootA = find(a);\n    int rootB = find(b);\n\n    if (rootA == rootB) {\n        return pos[a] - pos[b] == dist;\n    } else {\n        parent[rootB] = rootA;\n        pos[rootB] = pos[a] - pos[b] + dist;\n        return true;\n    }\n}\n\nbool isConsistent(int n, int m, Information info[]) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        pos[i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        if (!unionSets(info[i].L, info[i].R, info[i].D)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Information info[M];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &info[i].L, &info[i].R, &info[i].D);\n    }\n\n    if (isConsistent(N, M, info)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:58:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(n) {\n        this.parent = Array.from({ length: n }, (_, i) => i);\n        this.rank = Array(n).fill(0);\n        this.distance = Array(n).fill(0);\n    }\n\n    find(x) {\n        if (this.parent[x] !== x) {\n            const origParent = this.parent[x];\n            this.parent[x] = this.find(this.parent[x]);\n            this.distance[x] += this.distance[origParent];\n        }\n        return this.parent[x];\n    }\n\n    union(x, y, d) {\n        const rootX = this.find(x);\n        const rootY = this.find(y);\n\n        if (rootX === rootY) {\n            const existing = this.distance[x] - this.distance[y];\n            return existing === d;\n        }\n\n        if (this.rank[rootX] < this.rank[rootY]) {\n            this.parent[rootX] = rootY;\n            this.distance[rootX] = this.distance[y] + d - this.distance[x];\n        } else if (this.rank[rootX] > this.rank[rootY]) {\n            this.parent[rootY] = rootX;\n            this.distance[rootY] = this.distance[x] - d - this.distance[y];\n        } else {\n            this.parent[rootY] = rootX;\n            this.distance[rootY] = this.distance[x] - d - this.distance[y];\n            this.rank[rootX]++;\n        }\n        return true;\n    }\n}\n\nfunction isConsistent(N, M, constraints) {\n    const uf = new UnionFind(N);\n\n    for (let i = 0; i < M; i++) {\n        const [L, R, D] = constraints[i];\n        if (!uf.union(L, R, D)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "timestamp": "2025-08-13 13:58:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_positioning(N, constraints):\n    graph = [[] for _ in range(N)]\n    dist = [float('inf')] * N\n    \n    for L, R, D in constraints:\n        L -= 1\n        R -= 1\n        graph[L].append((R, D))\n        graph[R].append((L, -D))\n    \n    def bellman_ford(start):\n        dist[start] = 0\n        for _ in range(N - 1):\n            updated = False\n            for u in range(N):\n                if dist[u] == float('inf'):\n                    continue\n                for v, w in graph[u]:\n                    if dist[v] > dist[u] + w:\n                        dist[v] = dist[u] + w\n                        updated = True\n            if not updated:\n                break\n        \n        for u in range(N):\n            if dist[u] == float('inf'):\n                continue\n            for v, w in graph[u]:\n                if dist[v] > dist[u] + w:\n                    return False\n        return True\n    \n    for i in range(N):\n        if dist[i] == float('inf'):\n            dist = [float('inf')] * N\n            if not bellman_ford(i):\n                return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    N, M = map(int, input().split())\n    constraints = []\n    for _ in range(M):\n        L, R, D = map(int, input().split())\n        constraints.append((L, R, D))\n    \n    print(solve_positioning(N, constraints))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 13:58:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function canArrangePeople(N, M, constraints) {\n    const graph = Array.from({ length: N }, () => []);\n    const indegree = new Array(N).fill(0);\n    const dist = new Array(N).fill(Infinity);\n\n    for (const [L, R, D] of constraints) {\n        graph[L - 1].push([R - 1, D]);\n        indegree[R - 1]++;\n    }\n\n    const queue = [];\n    for (let i = 0; i < N; i++) {\n        if (indegree[i] === 0) {\n            queue.push(i);\n            dist[i] = 0;\n        }\n    }\n\n    while (queue.length > 0) {\n        const curr = queue.shift();\n\n        for (const [next, distance] of graph[curr]) {\n            const newDist = dist[curr] + distance;\n\n            if (dist[next] === Infinity) {\n                dist[next] = newDist;\n                queue.push(next);\n            } else if (dist[next] !== newDist) {\n                return false;\n            }\n\n            indegree[next]--;\n            if (indegree[next] === 0) {\n                queue.push(next);\n            }\n        }\n    }\n\n    return true;\n}",
    "timestamp": "2025-08-13 13:58:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        L, R, D = map(int, sys.stdin.readline().split())\n        adj[L].append((R, D))\n        adj[R].append((L, -D))\n    \n    INF = float('inf')\n    x = [INF] * (N+1)\n    \n    for i in range(1, N+1):\n        if x[i] == INF:\n            q = deque()\n            q.append(i)\n            x[i] = 0\n            while q:\n                u = q.popleft()\n                for v, d in adj[u]:\n                    if x[v] == INF:\n                        x[v] = x[u] + d\n                        q.append(v)\n                    else:\n                        if x[v] != x[u] + d:\n                            print(\"No\")\n                            return\n    print(\"Yes\")\n\nsolve()",
    "timestamp": "2025-08-13 13:58:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let N, M;\n    let edges = [];\n    let adjacencyList = [];\n    let x = [];\n    let visited = [];\n\n    rl.on('line', (line) => {\n        const parts = line.trim().split(' ').map(Number);\n        if (parts.length === 2) {\n            [N, M] = parts;\n            adjacencyList = Array.from({ length: N + 1 }, () => []);\n        } else if (parts.length === 3) {\n            const [L, R, D] = parts;\n            adjacencyList[L].push({ to: R, dist: D });\n            adjacencyList[R].push({ to: L, dist: -D });\n        }\n    });\n\n    rl.on('close', () => {\n        x = new Array(N + 1).fill(0);\n        visited = new Array(N + 1).fill(false);\n        let isConsistent = true;\n\n        for (let i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                let queue = [i];\n                visited[i] = true;\n                x[i] = 0;\n\n                while (queue.length > 0 && isConsistent) {\n                    let current = queue.shift();\n                    for (let edge of adjacencyList[current]) {\n                        if (!visited[edge.to]) {\n                            visited[edge.to] = true;\n                            x[edge.to] = x[current] + edge.dist;\n                            queue.push(edge.to);\n                        } else if (x[edge.to] !== x[current] + edge.dist) {\n                            isConsistent = false;\n                            break;\n                        }\n                    }\n                }\n                if (!isConsistent) break;\n            }\n        }\n\n        console.log(isConsistent ? \"Yes\" : \"No\");\n    });\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:58:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nbool canDeterminePositions(int N, int M, vector<tuple<int, int, int>>& info) {\n    vector<long long> position(N + 1, numeric_limits<long long>::max());\n    position[1] = 0;\n    \n    bool updated = true;\n    for (int i = 0; i < N && updated; ++i) {\n        updated = false;\n        for (int j = 0; j < M; ++j) {\n            int L, R, D;\n            tie(L, R, D) = info[j];\n            if (position[L] != numeric_limits<long long>::max() && \n                position[L] + D < position[R]) {\n                position[R] = position[L] + D;\n                updated = true;\n            }\n        }\n    }\n    \n    for (int j = 0; j < M; ++j) {\n        int L, R, D;\n        tie(L, R, D) = info[j];\n        if (position[L] != numeric_limits<long long>::max() && \n            position[L] + D < position[R]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<tuple<int, int, int>> info(M);\n    for (int i = 0; i < M; ++i) {\n        int L, R, D;\n        cin >> L >> R >> D;\n        info[i] = make_tuple(L, R, D);\n    }\n    \n    if (canDeterminePositions(N, M, info)) {\n        cout << \"Consistent\" << endl;\n    } else {\n        cout << \"Inconsistent\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:41:53"
  }
]