[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 2000\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nvoid longestPalindromeSubseq(char *s, char *result) {\n    int n = strlen(s);\n    if (n < 3) {\n        result[0] = '\\0';\n        return;\n    }\n\n    int dp[MAX_LEN][MAX_LEN];\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            if (s[i] == s[j] && len == 2) {\n                dp[i][j] = 2;\n            } else if (s[i] == s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    int length = dp[0][n - 1];\n    if (length < 3) {\n        result[0] = '\\0';\n        return;\n    }\n\n    result[length] = '\\0';\n    int i = 0, j = n - 1;\n    int left = 0, right = length - 1;\n\n    while (i <= j) {\n        if (s[i] == s[j]) {\n            result[left++] = s[i];\n            if (i != j) {\n                result[right--] = s[j];\n            }\n            i++;\n            j--;\n        } else if (dp[i + 1][j] > dp[i][j - 1]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n}\n\nint main() {\n    char s[MAX_LEN + 1];\n    char result[MAX_LEN + 1];\n    while (scanf(\"%s\", s) != EOF) {\n        longestPalindromeSubseq(s, result);\n        printf(\"%s\\n\", result);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring longestPalindromeSubsequence(const string &s) {\n    int n = s.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 1;\n    }\n    \n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i <= n - len; ++i) {\n            int j = i + len - 1;\n            if (s[i] == s[j]) {\n                dp[i][j] = 2 + (len > 2 ? dp[i + 1][j - 1] : 0);\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    int maxLen = dp[0][n - 1];\n    if (maxLen < 3) {\n        return \"\";\n    }\n    \n    string res;\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        if (s[i] == s[j]) {\n            res += s[i];\n            i++;\n            j--;\n        } else {\n            if (dp[i + 1][j] > dp[i][j - 1]) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n    }\n    \n    string rev = res.substr(0, res.size() - (maxLen % 2 == 0 ? 0 : 1));\n    reverse(rev.begin(), rev.end());\n    res += rev;\n    \n    return res;\n}\n\nint main() {\n    string line;\n    while (getline(cin, line)) {\n        string res = longestPalindromeSubsequence(line);\n        if (!res.empty()) {\n            cout << res << endl;\n        } else {\n            cout << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class LongestPalindromeSubsequence {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String s = scanner.nextLine().trim();\n            String result = longestPalindromeSubsequence(s);\n            System.out.println(result);\n        }\n        scanner.close();\n    }\n\n    private static String longestPalindromeSubsequence(String s) {\n        int n = s.length();\n        if (n < 3) return \"\";\n\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int cl = 2; cl <= n; cl++) {\n            for (int i = 0; i < n - cl + 1; i++) {\n                int j = i + cl - 1;\n                if (s.charAt(i) == s.charAt(j) && cl == 2) {\n                    dp[i][j] = 2;\n                } else if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                } else {\n                    dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);\n                }\n            }\n        }\n\n        int length = dp[0][n - 1];\n        if (length < 3) return \"\";\n\n        char[] result = new char[length];\n        int i = 0, j = n - 1;\n        int left = 0, right = length - 1;\n\n        while (i <= j) {\n            if (s.charAt(i) == s.charAt(j)) {\n                result[left++] = s.charAt(i);\n                if (i != j) {\n                    result[right--] = s.charAt(j);\n                }\n                i++;\n                j--;\n            } else {\n                if (dp[i][j - 1] > dp[i + 1][j]) {\n                    j--;\n                } else {\n                    i++;\n                }\n            }\n        }\n\n        return new String(result);\n    }\n}",
    "timestamp": "2025-08-05 21:08:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LongestPalindromeSubsequence {\n    public static String findLongestPalindromeSubsequence(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        \n        // Every single character is a palindrome of length 1\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n        \n        // Check palindromes of increasing lengths\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i < n - len + 1; i++) {\n                int j = i + len - 1;\n                \n                if (s.charAt(i) == s.charAt(j) && len == 2) {\n                    dp[i][j] = 2;\n                }\n                else if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i+1][j-1] + 2;\n                }\n                else {\n                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);\n                }\n            }\n        }\n        \n        // Reconstruct the palindrome\n        StringBuilder palindrome = new StringBuilder();\n        int left = 0, right = n - 1;\n        while (left <= right) {\n            if (left == right) {\n                if (dp[left][right] > 0) {\n                    palindrome.append(s.charAt(left));\n                }\n                break;\n            }\n            \n            if (s.charAt(left) == s.charAt(right)) {\n                if (dp[left][right] > 2) {\n                    palindrome.append(s.charAt(left));\n                    left++;\n                    right--;\n                }\n                else if (dp[left][right] == 2) {\n                    palindrome.append(s.charAt(left));\n                    palindrome.append(s.charAt(right));\n                    break;\n                }\n            }\n            else if (dp[left+1][right] > dp[left][right-1]) {\n                left++;\n            }\n            else {\n                right--;\n            }\n        }\n        \n        // Add mirrored half if necessary\n        if (palindrome.length() > 0 && dp[0][n-1] > 2) {\n            StringBuilder reversePalindrome = new StringBuilder(palindrome).reverse();\n            if (palindrome.length() > 1) {\n                reversePalindrome.deleteCharAt(0);\n            }\n            palindrome.append(reversePalindrome);\n        }\n        \n        return palindrome.length() > 2 ? palindrome.toString() : \"\";\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        scanner.nextLine();\n        \n        for (int i = 0; i < datasets; i++) {\n            String input = scanner.nextLine();\n            System.out.println(findLongestPalindromeSubsequence(input));\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:08:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEN 2001\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint longestPalindromeSubseq(char* str) {\n    int n = strlen(str);\n    int dp[MAX_LEN][MAX_LEN] = {0};\n    \n    for (int i = n - 1; i >= 0; i--) {\n        dp[i][i] = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (str[i] == str[j]) {\n                dp[i][j] = dp[i+1][j-1] + 2;\n            } else {\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n            }\n        }\n    }\n    \n    return dp[0][n-1] > 2 ? dp[0][n-1] : 0;\n}\n\nint main() {\n    char input[MAX_LEN];\n    \n    while (scanf(\"%s\", input) != EOF) {\n        int result = longestPalindromeSubseq(input);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring longestPalindromeSubsequence(const string& s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    vector<vector<string>> palindromes(n, vector<string>(n, \"\"));\n\n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i < n - len + 1; ++i) {\n            int j = i + len - 1;\n            \n            if (s[i] == s[j] && len == 2) {\n                dp[i][j] = 2;\n                palindromes[i][j] = s.substr(i, len);\n            }\n            else if (s[i] == s[j]) {\n                if (len > 2) {\n                    dp[i][j] = dp[i+1][j-1] + 2;\n                    palindromes[i][j] = s[i] + palindromes[i+1][j-1] + s[j];\n                }\n            }\n            else {\n                if (dp[i+1][j] > dp[i][j-1]) {\n                    dp[i][j] = dp[i+1][j];\n                    palindromes[i][j] = palindromes[i+1][j];\n                }\n                else {\n                    dp[i][j] = dp[i][j-1];\n                    palindromes[i][j] = palindromes[i][j-1];\n                }\n            }\n        }\n    }\n\n    return palindromes[0][n-1];\n}\n\nint main() {\n    string input;\n    while (getline(cin, input) && !input.empty()) {\n        string result = longestPalindromeSubsequence(input);\n        cout << (result.length() > 2 ? result : \"IMPOSSIBLE\") << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def longest_palindrome_subseq(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n+1):\n        for start in range(n-length+1):\n            end = start + length - 1\n            if s[start] == s[end]:\n                dp[start][end] = dp[start+1][end-1] + 2\n            else:\n                dp[start][end] = max(dp[start+1][end], dp[start][end-1])\n    \n    return reconstruct_palindrome(s, dp)\n\ndef reconstruct_palindrome(s, dp):\n    n = len(s)\n    res = []\n    i, j = 0, n - 1\n    while i <= j:\n        if s[i] == s[j]:\n            res.append(s[i])\n            i += 1\n            j -= 1\n        elif dp[i+1][j] > dp[i][j-1]:\n            i += 1\n        else:\n            j -= 1\n    \n    # Create the palindrome\n    palindrome = ''.join(res)\n    if len(res) > 1 and res[-1] == res[-2]:\n        return palindrome + ''.join(reversed(res[:-1]))\n    return palindrome + ''.join(reversed(res))\n\ndef process_datasets(datasets):\n    results = []\n    for data in datasets:\n        res = longest_palindrome_subseq(data)\n        if len(res) > 2:\n            results.append(res)\n        else:\n            results.append(\"\")\n    return results\n\n# Example usage\ndatasets = [\n    \"AACCA\",\n    \"BBABCBAB\",\n    \"ABCDEDCBA\"\n]\n\nresults = process_datasets(datasets)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 05:07:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class LongestPalindromeSubsequence {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            System.out.println(longestPalindromeSubsequence(line.trim()));\n        }\n    }\n\n    private static String longestPalindromeSubsequence(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        \n        // Fill the dp array\n        for (int i = n - 1; i >= 0; i--) {\n            dp[i][i] = 1;\n            for (int j = i + 1; j < n; j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                } else {\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        // Reconstruct the longest palindromic subsequence from the dp table\n        StringBuilder sb = new StringBuilder();\n        int i = 0, j = n - 1;\n        while (i <= j) {\n            if (s.charAt(i) == s.charAt(j)) {\n                sb.append(s.charAt(i));\n                i++;\n                j--;\n            } else if (dp[i + 1][j] > dp[i][j - 1]) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n        \n        // Construct the final palindrome string\n        String firstHalf = sb.toString();\n        String secondHalf = (sb.length() > 1) ? \n            new StringBuilder(sb.substring(0, s.charAt(i - 1) == s.charAt(j + 1) ? sb.length() - 1 : sb.length())).reverse().toString() : \n            \"\";\n        \n        String result = firstHalf + secondHalf;\n        // Check for one or two character result to avoid returning invalid palindromes\n        return result.length() > 2 ? result : \"\";\n    }\n}",
    "timestamp": "2025-08-13 05:07:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEN 2000\n\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nvoid printLongestPalindromicSubsequence(char *str) {\n    int n = strlen(str);\n    int dp[MAX_LEN][MAX_LEN];\n    int i, j, cl;\n\n    // Initialize single letter palindromes\n    for (i = 0; i < n; i++)\n        dp[i][i] = 1;\n\n    // Build the table for substrings longer than one character\n    for (cl = 2; cl <= n; cl++) {\n        for (i = 0; i < n - cl + 1; i++) {\n            j = i + cl - 1;\n            if (str[i] == str[j] && cl == 2)\n                dp[i][j] = 2;\n            else if (str[i] == str[j])\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            else\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);\n        }\n    }\n\n    // Reconstruct the longest palindromic subsequence\n    int index = dp[0][n - 1];\n    char lps[index + 1];\n    lps[index] = '\\0';\n\n    i = 0;\n    j = n - 1;\n    while (i <= j) {\n        if (str[i] == str[j]) {\n            lps[index - 1] = str[i];\n            i++;\n            j--;\n            index -= 1;\n        } else if (dp[i][j - 1] > dp[i + 1][j]) {\n            j--;\n        } else {\n            i++;\n        }\n    }\n\n    if (strlen(lps) > 2)\n        printf(\"%s\\n\", lps);\n    else\n        printf(\"\\n\");\n}\n\nint main() {\n    char input[MAX_LEN + 1];\n    while (scanf(\"%s\", input) != EOF) {\n        printLongestPalindromicSubsequence(input);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 05:07:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def longest_palindrome_subsequence(s):\n    n = len(s)\n    if n <= 2:\n        return \"\"\n    \n    dp = [[0] * n for _ in range(n)]\n    \n    # Initialize single characters\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Check pairs\n    for i in range(n-1):\n        if s[i] == s[i+1]:\n            dp[i][i+1] = 2\n    \n    # Check longer subsequences\n    for length in range(3, n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            \n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    \n    # Reconstruct palindrome\n    if dp[0][n-1] <= 2:\n        return \"\"\n    \n    result = []\n    i, j = 0, n-1\n    while i <= j:\n        if i == j:\n            result.append(s[i])\n            break\n        \n        if s[i] == s[j]:\n            result.append(s[i])\n            if i != j-1:\n                result.insert(0, s[j])\n            i += 1\n            j -= 1\n        elif dp[i+1][j] > dp[i][j-1]:\n            i += 1\n        else:\n            j -= 1\n    \n    return ''.join(result)\n\n# Read number of test cases\nt = int(input())\n\n# Process each test case\nfor _ in range(t):\n    s = input().strip()\n    print(longest_palindrome_subsequence(s))",
    "timestamp": "2025-08-13 05:07:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def longest_palindrome_subsequence(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for cl in range(2, n + 1):\n        for i in range(n - cl + 1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    length = dp[0][n - 1]\n    if length < 3:\n        return \"\"\n    \n    res = [\"\"] * length\n    i, j = 0, n - 1\n    left, right = 0, length - 1\n    while i <= j:\n        if s[i] == s[j]:\n            res[left] = s[i]\n            res[right] = s[j]\n            left += 1\n            right -= 1\n            i += 1\n            j -= 1\n        elif dp[i][j - 1] > dp[i + 1][j]:\n            j -= 1\n        else:\n            i += 1\n    return ''.join(res)\n\ndef main():\n    import sys\n    input_lines = sys.stdin.read().splitlines()\n    for line in input_lines:\n        line = line.strip()\n        if not line:\n            continue\n        result = longest_palindrome_subsequence(line)\n        print(result if result else \"\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:08:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring longestPalindromeSubseq(string s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    \n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    string result;\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        if (s[i] == s[j]) {\n            result += s[i];\n            i++;\n            j--;\n        } else if (dp[i + 1][j] > dp[i][j - 1]) {\n            i++;\n        } else {\n            j--;\n        }\n    }\n    \n    string secondHalf = result;\n    if (result.size() > 1) {\n        secondHalf.pop_back();\n    }\n    \n    reverse(secondHalf.begin(), secondHalf.end());\n    result += secondHalf;\n    \n    return result;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        string s;\n        cin >> s;\n        cout << longestPalindromeSubseq(s) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:23:04"
  }
]