[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n#define MAX_M 200005\n\nint N, M;\nint A[MAX_N], B[MAX_N];\nint graph[MAX_N][MAX_N];\nint degree[MAX_N];\nint visited[MAX_N];\n\nint dfs(int node, int money) {\n    visited[node] = 1;\n    money -= A[node];\n    \n    if (money < 0) return 0;\n    \n    money += B[node];\n    \n    for (int i = 0; i < degree[node]; i++) {\n        int neighbor = graph[node][i];\n        if (!visited[neighbor]) {\n            if (!dfs(neighbor, money)) return 0;\n        }\n    }\n    \n    return 1;\n}\n\nint can_win(int initial_money) {\n    memset(visited, 0, sizeof(visited));\n    return dfs(0, initial_money);\n}\n\nint solve() {\n    int left = 0, right = INT_MAX;\n    \n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        \n        if (can_win(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    return left;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        \n        graph[u][degree[u]++] = v;\n        graph[v][degree[v]++] = u;\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_N 100000\n#define INF 1LL << 60\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_N * 2];\nint head[MAX_N + 1];\nint edge_count = 0;\n\nint A[MAX_N + 1];\nint B[MAX_N + 1];\nbool visited[MAX_N + 1];\nlong long min_W;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, long long current_sum) {\n    visited[u] = true;\n    if (current_sum < A[u]) {\n        min_W += A[u] - current_sum;\n        current_sum = A[u];\n    }\n    current_sum += B[u];\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (!visited[v]) {\n            dfs(v, current_sum);\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n        head[i] = -1;\n        visited[i] = false;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n\n    min_W = 0;\n    long long low = 0, high = INF;\n    long long answer = INF;\n\n    while (low <= high) {\n        long long mid = (low + high) / 2;\n        bool possible = true;\n        for (int i = 1; i <= N; i++) {\n            visited[i] = false;\n        }\n        min_W = 0;\n        dfs(1, mid);\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                possible = false;\n                break;\n            }\n        }\n        if (possible) {\n            answer = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    printf(\"%lld\\n\", answer);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to, a, b;\n};\n\nstruct State {\n    long long cost;\n    int vertex;\n    bool operator>(const State& other) const {\n        return cost > other.cost;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<Edge>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v, a, b;\n        cin >> u >> v >> a >> b;\n        adj[u].push_back({v, a, b});\n        adj[v].push_back({u, a, b});\n    }\n\n    vector<long long> maxB(N + 1, -1);\n    priority_queue<State, vector<State>, greater<State>> pq;\n    pq.push({0, 1});\n    maxB[1] = 0;\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        if (current.cost > maxB[current.vertex]) continue;\n        for (const Edge& e : adj[current.vertex]) {\n            long long new_cost = current.cost + e.a;\n            if (maxB[e.to] < new_cost - e.b) {\n                maxB[e.to] = new_cost - e.b;\n                pq.push({new_cost, e.to});\n            }\n        }\n    }\n\n    cout << maxB[N] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n    static class Edge {\n        int to;\n        Edge(int to) {\n            this.to = to;\n        }\n    }\n\n    static class Vertex implements Comparable<Vertex> {\n        int id;\n        long cost;\n        Vertex(int id, long cost) {\n            this.id = id;\n            this.cost = cost;\n        }\n        @Override\n        public int compareTo(Vertex other) {\n            return Long.compare(this.cost, other.cost);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int N = Integer.parseInt(line[0]);\n        int M = Integer.parseInt(line[1]);\n\n        int[] A = new int[N];\n        int[] B = new int[N];\n        for (int i = 0; i < N; i++) {\n            line = br.readLine().split(\" \");\n            A[i] = Integer.parseInt(line[0]);\n            B[i] = Integer.parseInt(line[1]);\n        }\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            line = br.readLine().split(\" \");\n            int u = Integer.parseInt(line[0]) - 1;\n            int v = Integer.parseInt(line[1]) - 1;\n            adj.get(u).add(new Edge(v));\n            adj.get(v).add(new Edge(u));\n        }\n\n        PriorityQueue<Vertex> pq = new PriorityQueue<>();\n        boolean[] visited = new boolean[N];\n        long[] maxW = new long[N];\n        Arrays.fill(maxW, -1);\n\n        for (int i = 0; i < N; i++) {\n            pq.add(new Vertex(i, A[i] - B[i]));\n        }\n\n        long res = 0;\n        while (!pq.isEmpty()) {\n            Vertex current = pq.poll();\n            if (visited[current.id]) continue;\n            visited[current.id] = true;\n            res = Math.max(res, current.cost);\n\n            for (Edge edge : adj.get(current.id)) {\n                if (!visited[edge.to]) {\n                    long newCost = Math.min(current.cost, A[edge.to] - B[edge.to]);\n                    if (newCost > maxW[edge.to]) {\n                        maxW[edge.to] = newCost;\n                        pq.add(new Vertex(edge.to, newCost));\n                    }\n                }\n            }\n        }\n\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:07:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphGame {\n    static class Edge {\n        int to, cost;\n        Edge(int to, int cost) {\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    public static int findMinimumInitialMoney(int N, List<List<Edge>> graph, int[] A, int[] B) {\n        int left = 0, right = 1_000_000_000;\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (canWinGame(N, graph, A, B, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n\n    private static boolean canWinGame(int N, List<List<Edge>> graph, int[] A, int[] B, int initialMoney) {\n        boolean[] visited = new boolean[N];\n        return dfs(0, graph, A, B, initialMoney, visited, initialMoney);\n    }\n\n    private static boolean dfs(int node, List<List<Edge>> graph, int[] A, int[] B, int money, boolean[] visited, int initialMoney) {\n        if (visited[node]) return false;\n        visited[node] = true;\n        \n        if (money < A[node]) return false;\n        money -= A[node];\n        money += B[node];\n        \n        for (Edge edge : graph.get(node)) {\n            if (!visited[edge.to]) {\n                if (money < edge.cost) return false;\n                if (!dfs(edge.to, graph, A, B, money - edge.cost, visited, initialMoney)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int N = 4;\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Add edges (example)\n        graph.get(0).add(new Edge(1, 2));\n        graph.get(1).add(new Edge(0, 2));\n        graph.get(1).add(new Edge(2, 3));\n        graph.get(2).add(new Edge(1, 3));\n        graph.get(2).add(new Edge(3, 1));\n        graph.get(3).add(new Edge(2, 1));\n        \n        int[] A = {1, 2, 3, 4};\n        int[] B = {5, 6, 7, 8};\n        \n        int result = findMinimumInitialMoney(N, graph, A, B);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:07:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long minInitialMoney(int N, int M, vector<int>& A, vector<int>& B, vector<vector<int>>& edges) {\n        vector<vector<pair<int, int>>> graph(N);\n        for (auto& edge : edges) {\n            graph[edge[0] - 1].push_back({edge[1] - 1, 0});\n            graph[edge[1] - 1].push_back({edge[0] - 1, 0});\n        }\n\n        long long left = 0, right = 1e15;\n        while (left < right) {\n            long long mid = left + (right - left) / 2;\n            if (canWinGame(N, graph, A, B, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n\nprivate:\n    bool canWinGame(int N, vector<vector<pair<int, int>>>& graph, vector<int>& A, vector<int>& B, long long initialMoney) {\n        vector<bool> visited(N, false);\n        vector<long long> money(N, 0);\n        money[0] = initialMoney;\n\n        queue<int> q;\n        q.push(0);\n        visited[0] = true;\n\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n\n            // Donate money to current vertex\n            if (money[curr] < A[curr]) return false;\n            money[curr] -= A[curr];\n            money[curr] += B[curr];\n\n            for (auto& neighbor : graph[curr]) {\n                int next = neighbor.first;\n                if (!visited[next]) {\n                    visited[next] = true;\n                    money[next] = money[curr];\n                    q.push(next);\n                }\n            }\n        }\n\n        return all_of(visited.begin(), visited.end(), [](bool v) { return v; });\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<int> A(N), B(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i] >> B[i];\n    }\n\n    vector<vector<int>> edges(M, vector<int>(2));\n    for (int i = 0; i < M; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n    }\n\n    Solution sol;\n    cout << sol.minInitialMoney(N, M, A, B, edges) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:08:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef min_initial_money(n, m, edges, a, b):\n    def can_win(w):\n        visited = [False] * n\n        queue = deque([0])\n        while queue:\n            node = queue.popleft()\n            if visited[node]:\n                continue\n            visited[node] = True\n            money = w\n            for neighbor in graph[node]:\n                if visited[neighbor]:\n                    continue\n                donation = (money + a[neighbor] - b[neighbor])\n                if donation >= 0:\n                    queue.append(neighbor)\n                    money = donation\n        return all(visited)\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    low, high = 0, sum(a) + sum(b)\n    ans = high\n    while low <= high:\n        mid = (low + high) // 2\n        if can_win(mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return ans\n\n# Example inputs\nn = 3\nm = 3\nedges = [(0, 1), (1, 2), (0, 2)]\na = [1, 2, 3]\nb = [1, 1, 1]\n\n# Run the function\nprint(min_initial_money(n, m, edges, a, b))",
    "timestamp": "2025-08-13 13:39:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphGame {\n    static class Vertex {\n        int a, b;\n        List<Integer> neighbors = new ArrayList<>();\n\n        Vertex(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    private static boolean canWin(Vertex[] vertices, int startMoney, int currentVertex, Set<Integer> visited) {\n        if (visited.size() == vertices.length) return true;\n\n        for (int neighbor : vertices[currentVertex].neighbors) {\n            if (!visited.contains(neighbor) && startMoney >= vertices[neighbor].a) {\n                // Visit neighbor with remaining money after donating\n                visited.add(neighbor);\n                if (canWin(vertices, startMoney + vertices[neighbor].b, neighbor, visited)) {\n                    return true;\n                }\n                visited.remove(neighbor);\n            }\n        }\n\n        return false;\n    }\n    \n    public static int findMinimumStartMoney(Vertex[] vertices) {\n        int low = 0, high = Integer.MAX_VALUE, answer = -1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (canWin(vertices, mid, 0, new HashSet<>(Collections.singleton(0)))) {\n                answer = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return answer;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n\n        Vertex[] vertices = new Vertex[n];\n        for (int i = 0; i < n; ++i) {\n            int a = scanner.nextInt();\n            int b = scanner.nextInt();\n            vertices[i] = new Vertex(a, b);\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            vertices[u].neighbors.add(v);\n            vertices[v].neighbors.add(u);\n        }\n\n        System.out.println(findMinimumStartMoney(vertices));\n    }\n}",
    "timestamp": "2025-08-13 13:39:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int to;\n    struct Edge *next;\n} Edge;\n\nEdge pool[MAX_M * 2];\nEdge *graph[MAX_N];\nint pool_index;\n\nint N, M;\nint A[MAX_N], B[MAX_N];\nint visited[MAX_N];\n\nvoid add_edge(int u, int v) {\n    Edge *e = &pool[pool_index++];\n    e->to = v;\n    e->next = graph[u];\n    graph[u] = e;\n}\n\nint dfs(int node, int money) {\n    visited[node] = 1;\n    if (money < A[node]) return 0;\n    money += B[node];\n    for (Edge *e = graph[node]; e; e = e->next) {\n        if (!visited[e->to]) {\n            if (!dfs(e->to, money)) return 0;\n        }\n    }\n    return 1;\n}\n\nint can_win_game(int W) {\n    for (int i = 0; i < N; i++) visited[i] = 0;\n    return dfs(0, W);\n}\n\nint find_min_initial_money() {\n    int left = 0, right = INT_MAX, answer = INT_MAX;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (can_win_game(mid)) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return answer;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n    }\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    int result = find_min_initial_money();\n    printf(\"%d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 13:40:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findMinimumInitialAmount(N, M, edges, A, B) {\n    const graph = Array.from({ length: N }, () => []);\n    edges.forEach(([u, v]) => {\n        graph[u].push(v);\n        graph[v].push(u);\n    });\n\n    let low = 0, high = 1e9;\n\n    function canWinGame(initialAmount) {\n        const visited = new Array(N).fill(false);\n        let stack = [];\n        for (let i = 0; i < N; i++) {\n            if (visited[i]) continue;\n            let componentMoney = initialAmount;\n            stack.push(i);\n            while (stack.length > 0) {\n                const node = stack.pop();\n                if (visited[node]) continue;\n                visited[node] = true;\n                componentMoney = componentMoney + A[node] - B[node];\n                if (componentMoney < 0) return false;\n                graph[node].forEach(neighbor => {\n                    if (!visited[neighbor]) {\n                        stack.push(neighbor);\n                    }\n                });\n            }\n        }\n        return true;\n    }\n\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (canWinGame(mid)) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    return low;\n}\n\n// Example usage:\n// Number of vertices (N) and edges (M)\n// let N = 3, M = 3;\n// let edges = [[0, 1], [1, 2], [2, 0]];\n// let A = [10, 20, 30];\n// let B = [15, 25, 5];\n// console.log(findMinimumInitialAmount(N, M, edges, A, B));",
    "timestamp": "2025-08-13 13:40:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_min_initial_money(N, edges, A, B):\n    def can_win(W):\n        money = [W] * N\n        visited = [False] * N\n        \n        def dfs(node):\n            visited[node] = True\n            current_money = money[node]\n            \n            # Donate to current node\n            if current_money < A[node]:\n                return False\n            current_money -= A[node]\n            current_money += B[node]\n            money[node] = current_money\n            \n            # Visit neighbors\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    money[neighbor] += current_money\n                    if not dfs(neighbor):\n                        return False\n            \n            return True\n        \n        # Try starting from each node\n        for start in range(N):\n            if not visited[start]:\n                money = [W] * N\n                visited = [False] * N\n                if dfs(start):\n                    all_visited = all(visited)\n                    if all_visited:\n                        return True\n        \n        return False\n    \n    # Build adjacency list\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    # Binary search for minimum initial money\n    left, right = 0, 10**15\n    while left < right:\n        mid = (left + right) // 2\n        if can_win(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Example usage\ndef main():\n    # Input format\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    edges = []\n    for _ in range(M):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    result = solve_min_initial_money(N, edges, A, B)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 13:40:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumInitialMoney(N, edges, A, B) {\n    const graph = Array.from({ length: N }, () => []);\n    for (const [u, v] of edges) {\n        graph[u - 1].push(v - 1);\n        graph[v - 1].push(u - 1);\n    }\n\n    function canWinWithInitialMoney(initialMoney) {\n        const visited = new Array(N).fill(false);\n        const money = new Array(N).fill(0);\n\n        function dfs(vertex, currentMoney) {\n            if (visited[vertex]) return false;\n            visited[vertex] = true;\n\n            currentMoney += initialMoney - A[vertex];\n            money[vertex] = currentMoney;\n\n            if (currentMoney < B[vertex]) return false;\n\n            for (const neighbor of graph[vertex]) {\n                if (!visited[neighbor]) {\n                    if (!dfs(neighbor, currentMoney)) return false;\n                }\n            }\n            return true;\n        }\n\n        return dfs(0, 0);\n    }\n\n    let left = 1;\n    let right = 10 ** 9;\n\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (canWinWithInitialMoney(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left;\n}",
    "timestamp": "2025-08-13 13:40:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M = map(int, input[ptr:ptr+2])\n    ptr +=2\n    \n    A = []\n    B = []\n    for _ in range(N):\n        a, b = map(int, input[ptr:ptr+2])\n        A.append(a)\n        B.append(b)\n        ptr +=2\n    \n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, input[ptr:ptr+2])\n        u -=1\n        v -=1\n        adj[u].append(v)\n        adj[v].append(u)\n        ptr +=2\n    \n    visited = [False] * N\n    heap = []\n    \n    for i in range(N):\n        heapq.heappush(heap, (A[i], i))\n    \n    W = 0\n    current_money = 0\n    \n    while heap:\n        a, u = heapq.heappop(heap)\n        if visited[u]:\n            continue\n        \n        if current_money < a:\n            W += (a - current_money)\n            current_money = a\n        \n        visited[u] = True\n        current_money += B[u]\n        \n        for v in adj[u]:\n            if not visited[v]:\n                heapq.heappush(heap, (A[v], v))\n    \n    print(W)\n\nsolve()",
    "timestamp": "2025-08-13 13:40:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class UnionFind {\n    constructor(size) {\n        this.parent = Array.from({ length: size }, (_, i) => i);\n        this.rank = new Array(size).fill(0);\n    }\n\n    find(u) {\n        if (this.parent[u] !== u) {\n            this.parent[u] = this.find(this.parent[u]);\n        }\n        return this.parent[u];\n    }\n\n    union(u, v) {\n        let rootU = this.find(u);\n        let rootV = this.find(v);\n        if (rootU === rootV) return false;\n        if (this.rank[rootU] > this.rank[rootV]) {\n            this.parent[rootV] = rootU;\n        } else if (this.rank[rootU] < this.rank[rootV]) {\n            this.parent[rootU] = rootV;\n        } else {\n            this.parent[rootV] = rootU;\n            this.rank[rootU]++;\n        }\n        return true;\n    }\n}\n\nfunction solve() {\n    const input = require('fs').readFileSync(0, 'utf-8').trim().split('\\n');\n    let ptr = 0;\n    const [N, M] = input[ptr++].split(' ').map(Number);\n    const A = [];\n    const B = [];\n    for (let i = 0; i < N; i++) {\n        const [a, b] = input[ptr++].split(' ').map(Number);\n        A.push(a);\n        B.push(b);\n    }\n    const edges = [];\n    for (let i = 0; i < M; i++) {\n        const [u, v] = input[ptr++].split(' ').map(Number);\n        edges.push([u - 1, v - 1]);\n    }\n\n    const nodes = Array.from({ length: N }, (_, i) => i);\n    nodes.sort((i, j) => (A[i] - B[i]) - (A[j] - B[j]));\n\n    const uf = new UnionFind(N);\n    let res = 0;\n    let total = 0;\n\n    for (const i of nodes) {\n        total += B[i];\n        res = Math.max(res, A[i] - total);\n    }\n\n    const candidates = [];\n    for (const [u, v] of edges) {\n        candidates.push([Math.max(A[u] - B[u], A[v] - B[v]), u, v]);\n    }\n    candidates.sort((a, b) => a[0] - b[0]);\n\n    let sumB = 0;\n    const uf2 = new UnionFind(N);\n    let maxA = 0;\n    const active = new Set();\n\n    for (const i of nodes) {\n        active.add(i);\n        sumB += B[i];\n        maxA = Math.max(maxA, A[i]);\n        let currentRes = maxA - sumB;\n\n        for (const [val, u, v] of candidates) {\n            if (val > A[i] - B[i]) break;\n            if (active.has(u) && active.has(v) && uf2.find(u) !== uf2.find(v)) {\n                uf2.union(u, v);\n                const root = uf2.find(u);\n                sumB -= B[u] + B[v];\n                sumB += B[root];\n                maxA = Math.max(maxA, A[u], A[v]);\n                currentRes = Math.max(currentRes, maxA - sumB);\n            }\n        }\n        res = Math.min(res, currentRes);\n    }\n\n    console.log(res);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:40:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int weight;\n};\n\nbool is_possible_to_donate(int start_vertex, int initial_money, const vector<vector<Edge>>& graph, const vector<int>& A, const vector<int>& B, int N) {\n    vector<bool> visited(N, false);\n    queue<pair<int, int>> q;\n    q.push({start_vertex, initial_money});\n\n    while (!q.empty()) {\n        auto [current_vertex, current_money] = q.front();\n        q.pop();\n        \n        if (visited[current_vertex]) continue;\n        \n        visited[current_vertex] = true;\n        \n        int required_money = A[current_vertex] - current_money;\n        if (required_money > 0) return false;\n\n        current_money += B[current_vertex];\n\n        for (const Edge& edge : graph[current_vertex]) {\n            if (!visited[edge.to]) {\n                q.push({edge.to, current_money});\n            }\n        }\n    }\n\n    return all_of(visited.begin(), visited.end(), [](bool v) { return v; });\n}\n\nint find_minimum_initial_money(const vector<vector<Edge>>& graph, const vector<int>& A, const vector<int>& B, int N) {\n    int low = 0, high = 1e9; // Assuming the maximum possible money is 1e9\n    int result = high;\n\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        bool possible = false;\n        \n        for (int start_vertex = 0; start_vertex < N; ++start_vertex) {\n            if (is_possible_to_donate(start_vertex, mid, graph, A, B, N)) {\n                possible = true;\n                break;\n            }\n        }\n        \n        if (possible) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<int> A(N), B(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i] >> B[i];\n    }\n    \n    vector<vector<Edge>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v; // Assuming input vertices are 1-based index, convert to 0-based\n        graph[u].push_back({v, 0});\n        graph[v].push_back({u, 0});\n    }\n    \n    int result = find_minimum_initial_money(graph, A, B, N);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:40:42"
  }
]