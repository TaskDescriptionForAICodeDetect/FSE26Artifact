[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nint bh[N],bt;\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nbool rdcmp(int a,int b){\n\treturn rand()%2;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tLL ans=1e16;\n\tdfs(root,0);\n\tans=min(ans,need[root]);\n\tsrand(19260817);\n\tbt=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (A[i]==A[root]){\n\t\t\tbh[++bt]=i;\n\t\t}\n\t}\n\tsort(bh+1,bh+bt+1,rdcmp);\n\tfor (int i=1;i<=min(50,bt);i++){\n\t\troot=bh[i];\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tfor (int i=1;i<=50;i++){\n\t\troot=rand()%n+1;\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m;\nvector<int> g[N];\nlong long a[N], b[N];\nint p[N];\nbool used[N];\nlong long sum[N];\nset<pair<long long, int> > st[N];\n\nint find(int x) { return p[x] < 0 ? x : p[x] = find(p[x]); }\n\n\nbool can(long long x) {\n  for (int i = 0; i < n; ++i) {\n    st[i].clear();\n    for (int u : g[i])\n      st[i].insert(make_pair(a[u], u));\n    sum[i] = b[i];\n  }\n  fill(p, p+n, -1);\n  fill(used, used+n, 0);\n  int cnt = 0;\n  stack<int> stak;\n  for (int i = 0; i < n; ++i) {\n    if (x >= a[i]) {\n      stak.push(i);\n      used[i] = 1;\n    }\n  }\n  // cerr << \" cek \" << x << endl;\n  while (!stak.empty()) {\n    int v = stak.top();\n    stak.pop();\n    v = find(v);\n    // cerr << \" sumber \" << v << endl;\n    while (!st[v].empty()) {\n      auto it = st[v].begin();\n      int u = it->second;\n      if (a[u] > sum[v] + x) break;\n      st[v].erase(it);\n      used[u] = 1;\n      u = find(u);\n      // cerr << \" tambah \" << u << endl;\n      if (u == v) continue;\n      if (st[u].size() > st[v].size()) swap(u, v);\n      for (auto it2 : st[u])\n        st[v].insert(it2);\n      st[u].clear();\n      sum[v] += sum[u];\n      p[u] = v;\n    }\n  }\n  for (int i = 0; i < n; ++i) if (!used[i]) return false;\n  return true;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d %d\", a+i, b+i);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v); --u, --v; \n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long lo = 0, hi = 0;\n  for (int i = 0; i < n; ++i)\n    if (a[i] > hi) hi = a[i];\n  for (int i = 0; i < n; ++i)\n    a[i] -= b[i];\n  long long all = 0;\n  for (int i = 0; i < n; ++i)\n    all += b[i];\n  while (lo < hi) {\n    long long mid = (lo + hi) >> 1;\n    if (can(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  cerr << lo << endl;\n  printf(\"%lld\\n\", lo+all);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <set>\n#include <map>\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> sz;\n    \n  UnionFind(int n = 210000) { init(n); }\n  void init(int n = 210000) {\n\tpar.resize(n); sz.resize(n);\n\tfor (int i = 0; i < n; ++i) par[i] = i, sz[i] = 1;\n  }\n    \n  int root(int x) {\n\tif (par[x] == x) return x;\n\telse return par[x] = root(par[x]);\n  }\n    \n  bool issame(int x, int y) {\n\treturn root(x) == root(y);\n  }\n\n  int size(int x) {\n\treturn sz[root(x)];\n  }\n\n  bool direct(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tpar[x] = y;\n\treturn true;\n  }\n    \n  friend ostream& operator << (ostream& s, UnionFind uf) {\n\tmap<int, vector<int> > res;\n\tfor (int i = 0; i < uf.par.size(); ++i) {\n\t  int r = uf.root(i);\n\t  res[r].push_back(i);\n\t}\n\tfor (map<int, vector<int> >::iterator it = res.begin(); it != res.end(); ++it) {\n\t  s << endl;\n\t  for (int j = 0; j < (int)it->second.size(); ++j) {\n\t\ts << it->second[j] << \", \";\n\t  }\n\t}\n\treturn s << endl;\n  }\n};\n\ntypedef pair<long long, long long> pll;\n\nint N, M;\nvector<long long> a, b;\nvector<vector<int> > G;\n\nbool cmp(int i, int j) {\n  return a[i] - b[i] < a[j] - b[j];\n}\n\nint main() {\n  cin >> N >> M;\n  a.resize(N); b.resize(N);\n  for (int i = 0; i < N; ++i) {\n\tcin >> a[i] >> b[i];\n  }\n  G.clear(); G.resize(N);\n  for (int i = 0; i < M; ++i) {\n\tint u, v; cin >> u >> v; --u, --v;\n\tG[u].push_back(v); G[v].push_back(u);\n  }\n  vector<int> ord(N);;\n  std::iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), cmp);\n\n  vector<long long> sumB(N), dp(N), seen(N, 0);\n  for (int i = 0; i < N; ++i) {\n\tsumB[i] = b[i];\n\tdp[i] = max(a[i], b[i]);\n  }\n  UnionFind uf(N);\n  for (auto v : ord) {\n\tset<int> adj;\n\tfor (auto to : G[v]) {\n\t  if (!seen[to]) continue;\n\t  adj.insert(uf.root(to));\n\t}\n\tlong long tmpsum = b[v];\n\tfor (auto r : adj) {\n\t  tmpsum += sumB[r];\n\t  uf.direct(r, v);\n\t}\n\tsumB[v] = tmpsum;\n\tif (!adj.empty()) {\n\t  long long minv = 1LL<<59;\n\t  for (auto r : adj) {\n\t\tlong long subB = tmpsum - sumB[r];\n\t\tlong long tmp = subB + max(a[v] - b[v], dp[r]);\n\t\tminv = min(minv, tmp);\n\t  }\n\t  dp[v] = minv;\n\t}\n\tseen[v] = true;\n\n\t//cout << \"-------------------------\" << endl;\n\t//cout << v << \": \" << dp[v] << \", \" << sumB[v] << endl;\n  }\n  cout << dp[uf.root(0)] << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long v,nxt;\n};\nnode edge[200001];\nstruct reads\n{\n\tlong long num,data;\n\tbool operator < (const reads &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nreads t[100001];\nlong long n,m,a[100001],b[100001],head[100001],len,rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].nxt=head[x];\n\thead[x]=len;\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tt[i].num=i;\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t\tt[i].data=Mx[i];\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(t+1,t+n+1);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=head[t[i].num];j>0;j=edge[j].nxt)\n\t\t\tif (a[t[i].num]>=a[edge[j].v]&&find(edge[j].v)!=find(t[i].num))\n\t\t\t\tunionn(edge[j].v,t[i].num);\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll INF = 1LL << 60;\nll A[100000], B[100000], C[100000];\nll sumB[100000];\nll dp[100000];\nbool used[100000];\nvector<int> G[100000];\nstruct UnionFind {\n\tvector<int> par;\n\n\tUnionFind(int n) {\n\t\tpar = vector<int>(n);\n\t\tfor (int i = 0; i < n; i++) par[i] = i;\n\t}\n\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y) { // x->y\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t}\n};\nbool cmp(int i, int j) {\n\treturn C[i] < C[j];\n}\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tC[i] = max(A[i] - B[i], 0LL);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tvector<int> ord(N);\n\tiota(ord.begin(), ord.end(), 0);\n\tsort(ord.begin(), ord.end(), cmp);\n\tUnionFind U(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint u = ord[i];\n\t\tset<int> adj;\n\t\tfor (int to : G[u]) {\n\t\t\tif (!used[to]) continue;\n\t\t\tadj.insert(U.find(to));\n\t\t}\n\t\tsumB[u] = B[u];\n\t\tfor (int v : adj) {\n\t\t\tsumB[u] += sumB[v];\n\t\t\tU.unite(v, u);\n\t\t}\n\t\tdp[u] = C[u] + sumB[u];\n\t\tfor (int v : adj) {\n\t\t\tdp[u] = min(dp[u], max(dp[v], C[u]) + sumB[u] - sumB[v]);\n\t\t}\n\t\tused[u] = 1;\n\t}\n\tcout << dp[U.find(0)] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Use[n] == 0)\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total += B[neighb];\n                            break;\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 10000000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct UnionFind {\n    int n, cc, *u;\n    UnionFind() : n(0), cc(0), u(NULL) {}\n    UnionFind(int n_) : n(n_), cc(n_) {\n\tu = new int[n_];\n\tmemset(u, -1, sizeof (int) * n);\n    }\n    UnionFind(const UnionFind &y) : n(y.n), cc(y.cc) {\n\tu = new int[y.n];\n\tmemcpy(u, y.u, sizeof (int) * n);\n    }\n    ~UnionFind() {\n\tdelete[] u; u = NULL;\n\tn = cc = 0;\n    }\n    friend void swap(UnionFind &x, UnionFind &y) {\n\tswap(x.n, y.n); swap(x.cc, y.cc); swap(x.u, y.u);\n    }\n    UnionFind& operator=(UnionFind y) { \n\tswap(*this, y);\n\treturn *this;\n    }\n    int root(int x) {\n\tint y = x, t;\n\twhile (u[y] >= 0) y = u[y];\n\twhile (x != y) { t = u[x]; u[x] = y; x = t; }\n\treturn y;\n    }\n    bool link(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tif (u[y] < u[x]) swap(x, y);\n\tu[x] += u[y]; u[y] = x; cc--;\n\treturn true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -u[root(x)]; }\n    int count() { return cc; }\n};\n\nint N, M;\nint A[100011];\nint B[100011];\nVI G[100011];\nint mark[100011];\nbool use[100011];\npair<int, int> P[100011];\nLL R[100011], sumB[100011];\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &M);\n    REP (i, N) scanf(\"%d%d\", A+i, B+i);\n    REP (i, M) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tx--; y--;\n\tG[x].push_back(y);\n\tG[y].push_back(x);\n    }\n\n    REP (i, N) P[i] = make_pair(A[i]-B[i], i);\n    sort(P, P+N);\n    memset(mark, -1, sizeof mark);\n\n    UnionFind U(N);\n    REP (i_, N) {\n\tint v = P[i_].second;\n\tuse[v] = true;\n\tVI ch;\n\tEACH (e, G[v]) if (use[*e]) {\n\t    int w = U.root(*e);\n\t    if (mark[w] == v) continue;\n\t    mark[w] = v;\n\t    ch.push_back(w);\n\t}\n\tEACH (e, ch) U.link(*e, v);\n\n\tLL c = max(A[v] - B[v], 0);\n\tLL sum = B[v];\n\tEACH (e, ch) {\n\t    sum += sumB[*e];\n\t}\n\tLL r = c + sum;\n\n\tEACH (e, ch) {\n\t    LL tmp = max(c, R[*e]) + sum - sumB[*e];\n\t    amin(r, tmp);\n\t}\n\tint w = U.root(v);\n\tR[w] = r;\n\tsumB[w] = sum;\n    }\n\n    int v = U.root(P[N-1].second);\n    printf(\"%lld\\n\", R[v]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{int to,next;}e[200010],E[200010];\nint n,m,a[100010],b[100010],Hd[100010],id[100010],fa[100010],bel[100010],x,y,hd[100010],cnt,p[100010];\nlong long sum[100010],f[100010],ans;\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid addedge(int x,int y) {e[++cnt]=(node){y,hd[x]},hd[x]=cnt;}\n\nvoid Addedge(int x,int y)\n{\n\tE[++cnt]=(node){y,Hd[x]},Hd[x]=cnt;\n\tE[++cnt]=(node){x,Hd[y]},Hd[y]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tsum[x]=b[x];\n\tlong long mi=1000000000000000000ll;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tdfs(e[i].to),sum[x]+=sum[e[i].to],\n\t\tmi=min(mi,max(1ll*a[x],b[x]+f[e[i].to])-sum[e[i].to]),\n\tf[x]=min(sum[x]-b[x]+mi,sum[x]-b[x]+max(a[x],b[x]));\n}\n\nint main()\n{\n\tsrand(12019687);\n\tscanf(\"%d%d\",&n,&m),ans=1000000000000000000ll;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tfor (int qaq=1; qaq<20; qaq++)\n\t{\n\t\trandom_shuffle(id+1,id+1+n),sort(id+1,id+1+n,cmp),cnt=0;\n\t\tfor (int i=1; i<=n; i++) p[id[i]]=i;\n\t\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=hd[i]=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tx=id[i];\n\t\t\tfor (int j=Hd[x]; j; j=E[j].next)\n\t\t\t\tif (p[E[j].to]<i&&ask(E[j].to)!=x) fa[ask(E[j].to)]=x,bel[ask(E[j].to)]=x;\n\t\t}\n\t\tcnt=0;\n\t\tfor (int i=1; i<=n; i++) if (fa[i]) addedge(fa[i],i);\n\t\tdfs(id[n]),ans=min(ans,f[id[n]]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y;\nvector<int> a[100020];\nint A[100020];\nint B[100020];\nint f[100020];\nint g[100020];\nint s[100020];\nint r[100020];\nint v[100020];\nint F(int x) {\n\treturn f[x] != x ? f[x] = F(f[x]) : x;\n}\nint cmp(int x, int y) {\n\treturn A[x] < B[x];\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tA[i] = max(A[i] - B[i], 0);\n\t\tr[i] = i;\n\t}\n\tsort(r + 1, r + 1 + n, cmp);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tv[r[i]] = 1;\n\t\tf[r[i]] = r[i];\n\t\tg[r[i]] = A[r[i]];\n\t\tfor (int j: a[r[i]]) {\n\t\t\tif (v[j] && F(j) != F(r[i])) {\n\t\t\t\tB[r[i]] += B[j];\n\t\t\t\tg[r[i]] = min(g[r[i]], max(g[j], A[r[i]] - B[j]));\n\t\t\t\tf[F(j)] = r[i];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", g[F(1)] + B[F(1)]);\n\treturn 0;;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m;\nvector<int> g[N];\nint a[N], b[N], p[N];\nbool used[N];\nlong long sum[N];\nset<pair<int, int> > st[N];\n\nint find(int x) { return p[x] < 0 ? x : p[x] = find(p[x]); }\n\n\nbool can(long long x) {\n  for (int i = 0; i < n; ++i) {\n    st[i].clear();\n    for (int u : g[i])\n      st[i].insert(make_pair(a[u], u));\n    sum[i] = b[i];\n  }\n  fill(p, p+n, -1);\n  fill(used, used+n, 0);\n  int cnt = 0;\n  stack<int> stak;\n  for (int i = 0; i < n; ++i) {\n    if (b[i] + x >= a[i]) {\n      stak.push(i);\n      used[i] = 1;\n    }\n  }\n  // cerr << \" cek \" << x << endl;\n  while (!stak.empty()) {\n    int v = stak.top();\n    stak.pop();\n    // cerr << \" sumber \" << v << endl;\n    while (!st[v].empty()) {\n      auto it = st[v].begin();\n      int u = it->second;\n      st[v].erase(it);\n      if (a[u] > sum[v] + x + b[u]) break;\n      used[u] = 1;\n      u = find(u);\n      // cerr << \" tambah \" << u << endl;\n      if (u == v) continue;\n      if (st[u].size() > st[v].size()) swap(u, v);\n      for (auto it2 : st[u])\n        st[v].insert(it2);\n      st[u].clear();\n      sum[v] += sum[u];\n      p[u] = v;\n    }\n  }\n  for (int i = 0; i < n; ++i) if (!used[i]) return false;\n  return true;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d %d\", a+i, b+i);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v); --u, --v; \n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long lo = 0, hi = 0;\n  for (int i = 0; i < n; ++i)\n    if (a[i] > hi) hi = a[i];\n  long long all = 0;\n  for (int i = 0; i < n; ++i)\n    all += b[i];\n  while (lo < hi) {\n    long long mid = (lo + hi) >> 1;\n    if (can(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  printf(\"%lld\\n\", hi+all);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nconst int N=100005;\nconst int P=998244353;\nconst long long INFll=0x3f3f3f3f3f3f3f3fll;\n\nint n,m;\nint a[N],b[N],c[N],id[N];\nint top=-1;\nint p[N],fa[N];\nlong long f[N],size[N];\n\nvector<int> son[N];\n\nstruct edge{\n\tint u,v;\n\tinline edge(){}\n\tinline edge(int _u,int _v){\n\t\tu=_u;\n\t\tv=_v;\n\t\tif(c[u]<c[v]) swap(u,v);\n\t}\n\tinline bool operator<(const edge &w)const{\n\t\tif(c[u]==c[w.u]) return c[v]>c[w.v];\n\t\treturn c[u]<c[w.u];\n\t}\n}d[N];\n\nint find(int x){\n\tif(p[x]==0) return x;\n\treturn p[x]=find(p[x]);\n}\n\ninline void onion(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x==y) return ;\n\tp[y]=x;\n\tfa[y]=x;\n}\n\ninline bool cmp(int x,int y){\n\treturn c[x]<c[y];\n}\n\n#define min(x,y) ((x<y)?x:y)\n#define max(x,y) ((x>y)?x:y)\n\nvoid init(){\n\tint x1,x2;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]),c[i]=max(a[i]-b[i],0),id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++) c[id[i]]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x1,&x2);\n\t\td[i]=edge(x1,x2);\n\t}\n\t//printf(\"id : \");\tfor(int i=1;i<=n;i++) printf(\"%d \",id[i]); printf(\"\\n\");\n\tsort(d+1,d+m+1);\n\tfor(int i=1,j=0;i<=n;i++){\n\t\t//int u=id[i];\n\t\twhile(c[d[j+1].u]==i && j<=m){\n\t\t\tj++;\n\t\t\tonion(d[j].u,d[j].v);\n\t\t\t//printf(\"edge: %d %d\\n\",d[j].u,d[j].v);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) c[i]=max(a[i]-b[i],0);\n\tfor(int i=1;i<=n;i++) son[fa[i]].push_back(i);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=id[i],len=son[u].size();\n\t\tif(len==0) f[u]=c[u]+b[u],size[u]=b[u];\n\t\telse{\n\t\t\tf[u]=INFll;\n\t\t\tsize[u]=b[u];\n\t\t\tfor(int j=0;j<len;j++) size[u]+=size[son[u][j]];\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tint v=son[u][j];\n\t\t\t\tf[u]=min(f[u],size[u]-size[v]+max(c[u],f[v]));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tprintf(\"a : \");\t\tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]); printf(\"\\n\");\n\tprintf(\"b : \");\t\tfor(int i=1;i<=n;i++) printf(\"%d \",b[i]); printf(\"\\n\");\n\tprintf(\"id : \");\tfor(int i=1;i<=n;i++) printf(\"%d \",id[i]); printf(\"\\n\");\n\tprintf(\"fa : \");\tfor(int i=1;i<=n;i++) printf(\"%d \",fa[i]); printf(\"\\n\");\n\tprintf(\"size : \");\tfor(int i=1;i<=n;i++) printf(\"%lld \",size[i]); printf(\"\\n\");\n\tprintf(\"f : \");\t\tfor(int i=1;i<=n;i++) printf(\"%lld \",f[i]); printf(\"\\n\");\n\t*/\n\tprintf(\"%lld\\n\",f[id[n]]);\n}\n\nint main(){\n\tinit();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UF {\n  vint data;\n  UF(int n):data(n, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  cin >> N >> M;\n  vint A(N), B(N);\n  rep(i, N) cin >> A[i] >> B[i];\n  vector<vint> graph(N);\n  rep(i, M) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  vint id(N);\n  iota(all(id), 0);\n  sort(all(id), [&](int i, int j) {\n      return A[i]-B[i] < A[j]-B[j];\n    });\n  vint dp(N, -1);\n  UF uf(N);\n  vint bsum(N);\n  for(int i : id) {\n    int res = max(0ll, A[i]-B[i]);\n    int sum = B[i];\n    for(int j : graph[i]) {\n      int v = uf.find(j);\n      if(uf.same(i, v) || dp[v] == -1) continue;\n      chmin(res, max(dp[v], A[i]-(B[i]+bsum[v])));\n      sum += bsum[v];\n      uf.unite(i, v);\n    }\n    int u = uf.find(i);\n    dp[u] = res;\n    bsum[u] = sum;\n  }\n  //cout<<accumulate(all(B), 0ll)<<\" \"<<bsum[uf.find(id.back())]<<endl;\n  cout << bsum[uf.find(id.back())] + dp[uf.find(id.back())] << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll sum[MX];\nint n, m, a[MX], b[MX], p[MX];\nvector<vi> e;\nint root(int x){\n\treturn p[x] == x ? x : (p[x] = root(p[x]));\n}\nvoid merge(int a, int b){\n\ta = root(a); b = root(b);\n\tif(a != b){\n\t\tp[b] = a;\n\t\tsum[a] += sum[b];\n\t}\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m; e.resize(n);\n\trep(i, n) cin >> a[i] >> b[i];\n\trep(i, m){\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\t\n\tif(n == 1){\n\t\tcout << max(a[0], b[0]) << endl;\n\t\treturn 0;\n\t}\n\t\n\tvector<tuple<ll, int, int>> es;\n\trep(i, n) for(int j : e[i]) es.emplace_back(a[j] - b[j] - sum[i], i, j);\n\tsort(all(es));\n\t\n\trep(i, n) p[i] = i, sum[i] = b[i];\n\t\n\tll ans = 0;\n\twhile(es.size()){ //計算量？\n\t\tll mn = 1e18;\n\t\tvector<tuple<ll, int, int>> next;\n\t\tfor(auto i : es){\n\t\t\tll p; int q, r; tie(p, q, r) = i;\n\t\t\tint Q = root(q), R = root(r);\n\t\t\tif(Q == R) continue;\n\t\t\t\n\t\t\tll c = a[r] - b[r] - sum[Q];\n\t\t\tll st = sum[Q] > b[q] ? 0 : a[q] - b[q];\n\t\t\tif(ans >= st && ans >= c){\n\t\t\t\tdbg(p, q, r, c, Q); dbg(ans, st);\n\t\t\t\tmerge(q, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext.emplace_back(c, q, r);\n\t\t\t}\n\t\t\tmn = min(mn, max(st, c));\n\t\t}\n\t\t//dbg(es.size(), next.size(), mn);\n\t\tif(mn < 1e18) ans = max(ans, mn);\n\t\tes = next;\n\t\tsort(all(es));\n\t}\n\t//dbg(ans, root(0), sum[root(0)]); rep(i, n) cerr<<root(i)<<(i==n-1?\"\\n\":\" \");\n\tcout << ans + sum[root(0)] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,m,a[N],b[N],c[N],p[N],rk[N];\nvector<int> G[N],E[N];\nbool cmp(int x,int y) { return c[x]<c[y]; }\n\nint f[N];\nint find(int x) { return x==f[x]?x:f[x]=find(f[x]); }\n\nll dp[N],sum[N];\nvoid dfs(int u) {\n\tsum[u]=b[u],dp[u]=1e18;\n\tif (E[u].empty()) { dp[u]=max(a[u],b[u]); return; }\n\tfor (int v:E[u]) dfs(v),sum[u]+=sum[v];\n\tfor (int v:E[u])\t\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max(1ll*c[u],dp[v]));\n}\n\nint main() {\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i) a[i]=read(),b[i]=read();\n\tfor (int i=1;i<=m;++i) {\n\t\tint u=read(),v=read();\n\t\tG[u].emplace_back(v),G[v].emplace_back(u);\n\t}\n\tfor (int i=1;i<=n;++i) c[i]=max(0,a[i]-b[i]),p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor (int i=1;i<=n;++i) rk[p[i]]=f[i]=i;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int v:G[p[i]])\n\t\t\tif (find(v)!=p[i]&&rk[v]<i)\n\t\t\t\tE[p[i]].emplace_back(find(v)),f[find(v)]=p[i];\n\tdfs(p[n]); printf(\"%lld\\n\",dp[p[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<P, Int> T;\nInt n, k, v,m;\nInt a[216000];\nInt b[216000];\nInt c[216000];\nInt u[216000];\nInt us[216000];\nInt vs[216000];\nInt memo[216000];\nInt sum[216000];\nInt res = 1LL << 40;\nvector<P> edges;\nvector<int> child[108000];\nint init(){\n\tfor(int i = 0;i < 216000;i++)u[i] = i;\n}\n\nint r(int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nint unite(int x, int y){\n\tx = r(x);\n\ty = r(y);\n\tif(x != y)u[y]= x;\n}\n\nint dp(int x){\n\tInt &ans = memo[x];\n\tsum[x] = b[x];\n\tfor(int i = 0;i < child[x].size();i++){\n\t\tint to = child[x][i];\n\t\tdp(to);\n\t\tsum[x] += sum[to];\n\t}\n\tans = c[x] + sum[x];\n\tfor(Int i = 0;i < child[x].size();i++){\n\t\tInt to = child[x][i];\n\t\tans = min(ans, sum[x] - sum[to] + max(c[x], memo[to]));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tcin >> n >> m;\n\tfor(Int i = 0;i < n;i++){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i], b[i]);\n\t\tc[i] = a[i] - b[i];\n\t}\n\tfor(Int i = 0;i < m;i++){\n\t\tcin >> us[i] >> vs[i];us[i]--,vs[i]--;\n\t\tedges.push_back(P(max(c[us[i]],c[vs[i]]),i));\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(Int i = 0;i < edges.size();i++){\n\t\tInt cost = edges[i].first;\n\t\tInt ind = edges[i].second;\n\t\tInt u = us[ind], v = vs[ind];\n\t\tif(r(u) == r(v))continue;\n\t\tif(c[u] < c[v])swap(u,v);\n\t\tchild[r(u)].push_back(r(v));\n\t\tunite(u, v);\n\t}\n\tcout << dp(r(0)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 100100\nusing namespace std;\ntypedef long long ll;\n\nstruct edge {\n    int u, v, w;\n    edge() { }\n    edge(int a, int b, int c) : u(a), v(b), w(c) { }\n    bool operator<(const edge &b) { return w < b.w;}\n};\n\nint n, m, b[N], c[N], fa[N];\nll sum[N], f[N];\nedge e[N];\nvector<int> G[N];\n\nint find(int x) {\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\n\nvoid dfs(int u, int p = 0) {\n    sum[u] = b[u];\n    for (int v : G[u])\n        if (v != p) dfs(v, u), sum[u] += sum[v];\n}\n\nll dfs2(int u, int p = 0) {\n    ll res = max(1ll * c[u], f[u] = max(f[p], c[p] - sum[u]));\n    for (int v : G[u])\n        if (v != p) res = min(res, dfs2(v, u));\n    return res;\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", c + i, b + i);\n        c[i] = max(c[i] - b[i], 0);\n    }\n\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (c[u] < c[v]) swap(u, v);\n        e[i] = edge(u, v, c[u]);\n    }\n\n    sort(e + 1, e + m + 1);\n\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n\n    int rt = 0;\n    for (int i = 1; i <= m; ++i) {\n        int u = find(e[i].u), v = find(e[i].v);\n        if (u != v) fa[v] = rt = u, G[u].push_back(v);\n    }\n\n    dfs(rt);\n\n    cout << dfs2(rt) + sum[rt] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG fprintf(stderr, \"Passing [%s] line %d\\n\", __FUNCTION__, __LINE__)\n#define File(x) freopen(x\".in\",\"r\",stdin); freopen(x\".out\",\"w\",stdout)\n#define int long long\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIII;\n\ninline int gi()\n{\n\tint f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') {if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f * x;\n}\n\ninline LL gl()\n{\n\tLL f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') {if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f * x;\n}\n\nconst int INF = 0x3f3f3f3f, N = 100003, M = N << 1;\n\nint n, m;\nint a[N], b[N], dp[N], s[N];\nint c[N], id[N];\nint fa[N], x[N];\nvector <int> g[N];\nint head[N], ver[M], nxt[M], tot;\n\ninline bool cmp(int x, int y) {return c[x] < c[y];}\n\nint getf(int u) {return fa[u] == u ? u : fa[u] = getf(fa[u]);}\n\nvoid dfs(int u, int f)\n{\n\ts[u] = b[u];\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = ver[i];\n\t\tif (v == f) continue;\n\t\tdfs(v, u);\n\t\ts[u] += s[v];\n\t}\n}\n\nvoid dfs1(int u, int f)\n{\n\tif (!head[u]) dp[u] = b[u] + c[u];\n\telse dp[u] = 1e18;\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = ver[i];\n\t\tif (v == f) continue;\n\t\tdfs1(v, u);\n\t\tdp[u] = min(dp[u], s[u] - s[v] + max(c[u], dp[v]));\n\t}\n}\n\ninline void add(int u, int v)\n{\n\tver[++tot] = v, nxt[tot] = head[u], head[u] = tot;\n}\n\nsigned main()\n{\n\t//File(\"\");\n\tn = gi(), m = gi();\n\tfor (int i = 1; i <= n; i+=1) a[i] = gi(), b[i] = gi(), c[i] = max(0ll, a[i] - b[i]), id[i] = i;\n\tsort(id + 1, id + 1 + n, cmp);\n\tfor (int i = 1; i <= m; i+=1) {int u = gi(), v = gi(); g[u].push_back(v), g[v].push_back(u);}\n//\tfor (int i = 1; i <= n; i+=1, puts(\"\"))\n//\t\tfor (int j = 0; j < g[i].size(); j+=1) cout << i << ' ' << g[i][j] << endl;\n//\tputs(\"?\");\n\tfor (int i = 1; i <= n; i+=1) fa[i] = i, x[id[i]] = i;\n//\tfor (int i = 1; i <= n; i+=1) cout << c[i] << ' ' << id[i] << endl;\n//\tputs(\"!\");\n//\tfor (int i = 1; i <= n; i+=1) cout << x[i] << ' '; puts(\"$\");\n\tfor (int i = 1; i <= n; i+=1)\n\t{\n\t\tint u = id[i], sz = g[u].size();\n\t\tfor (int j = 0; j < sz; j+=1)\n\t\t{\n\t\t\tint v = getf(g[u][j]);\n//\t\t\tcout << u << ' ' << v << endl;\n            if (x[v] < x[u]) add(u, v), fa[v] = u;\n\t\t}\n\t}\n//\tfor (int i = 1; i <= n; i+=1, puts(\"\")) for (int j = head[i]; j; j = nxt[j]) cout << i << ' ' << j << endl;\n\tdfs(id[n], 0);\n//\tfor (int i = 1; i <= n; i+=1) cout << s[i] << ' '; puts(\"#\");\n\tdfs1(id[n], 0);\n  \tprintf(\"%lld\\n\", dp[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nstruct UF {\n\tvi e;\n\tUF(int n) : e(n, -1) {}\n\tbool same_set(int a, int b) { return find(a) == find(b); }\n\tint size(int x) { return -e[find(x)]; }\n\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\tvoid join(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a == b) return;\n\t\tif (e[a] > e[b]) swap(a, b);\n\t\te[a] += e[b]; e[b] = a;\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<ll> a(n), b(n);\n    rep(i,0,n) cin >> a[i] >> b[i];\n    vector<vi> g(n);\n    rep(i,0,m) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<tuple<ll,ll,int>> os;\n    rep(i,0,n) os.emplace_back(a[i],b[i],i);\n    sort(all(os));\n    UF uf(n);\n    vector<ll> sum(n), ans(n);\n    int last=-1;\n    vector<bool> vis(n);\n    rep(t,0,n) {\n        int u = get<2>(os[t]);\n        vis[u]=true;\n        int r = u;\n        vi cs;\n        {\n            set<int> ch;\n            for(int v:g[r]) {\n                if(vis[v]) ch.insert(uf.find(v));\n            }\n            for(int v:ch) cs.push_back(v);\n        }\n        for(int v:cs) uf.join(r,v);\n        r = uf.find(r);\n        ll su = b[u];\n        for(int v:cs) su += sum[v];\n        ll best=max(a[u],b[u])+su-b[u];\n        for(int i:cs) {\n            best=min(best,su-b[u]-sum[i]+max(a[u],b[u]+ans[i]));\n        }\n        ans[r]=best;\n        sum[r]=su;\n        last=r;\n    }\n    cout<<ans[last]<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch;\n\tdo{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n\tdo{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n\treturn x*f;\n}\nconst int N=100010;\nconst ll INF=0x3f3f3f3f3f3f3f3f;\nstruct node{\n\tint v,next;\n}edge[N<<1];\nint last[N],le;\nvoid add(int u,int v){\n\tedge[++le].v=v,edge[le].next=last[u],last[u]=le;\n\tedge[++le].v=u,edge[le].next=last[v],last[v]=le;\n}\nll a[N],b[N],dp[N],sum[N];\nint f[N],fa[N],pos[N],rt;\ninline int find(int x){\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\ninline bool cmp(int t1,int t2){\n\treturn a[t1]<a[t2];\n}\nvector<int> G[N];\nvoid dfs(int u){\n\tsum[u]=b[u];\n\tif (!G[u].size()){\n\t\tdp[u]=a[u]+b[u];\n\t\treturn;\n\t}\n\tfor (int i=G[u].size()-1;~i;--i){\n\t\tint v=G[u][i];\n\t\tdfs(v);\n\t\tsum[u]+=sum[v];\n\t}\n\tdp[u]=INF;\n\tfor (int i=G[u].size()-1;~i;--i){\n\t\tint v=G[u][i];\n\t\tdp[u]=min(dp[u],max(dp[v],a[u])+sum[u]-sum[v]);\n\t}\n}\nint main(){\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;++i){\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tpos[i]=f[i]=i,fa[i]=-1;\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tint u=read(),v=read();\n\t\tadd(u,v);\n\t}\n\tsort(pos+1,pos+n+1,cmp);\n\tfor (int j=1;j<=n;++j){\n\t\tint u=pos[j];\n\t\tfor (int i=last[u];i;i=edge[i].next){\n\t\t\tint v=edge[i].v;\n\t\t\tif (fa[find(v)]==0) fa[find(v)]=f[find(v)]=u;\n\t\t}\n\t\tfa[u]=0;\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tif (!fa[i]) rt=i;\n\t\telse G[fa[i]].push_back(i);\n\t}\n\tdfs(rt);\n\tprintf(\"%lld\\n\",dp[rt]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55) + 1e9;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass UF{\npublic:\n  Int V;\n  vector<Int> par,rnk,sz;\n  UF(){}\n  UF(Int V):V(V),par(V),rnk(V,0),sz(V,1){for(Int i=0;i<V;i++)par[i]=i;}\n  \n  Int find(Int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(Int x,Int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rnk[x]<rnk[y])par[x]=y, sz[y] += sz[x];\n    else{\n      par[y]=x;\n      sz[x] += sz[y];\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  bool same(Int x,Int y){return find(x)==find(y);}\n\n  Int size(Int x){return sz[find(x)];}\n};\n\n\nInt n;\nvector<vector<Int> > G;\nvector<Int> A, B;\n\nInt solve(){\n  vector<Int> ord(n); iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](Int a,Int b){return A[a] - B[a] < A[b] - B[b];});\n  vector<Int> dp(n,INF);\n  \n  UF uf(n);\n  for(Int i=0;i<n;i++) uf.sz[i] = B[i];\n  \n  vector<Int> used(n, 0);\n  for(Int v:ord){\n    assert(v == uf.find(v));\n    Int c = max(0LL, A[v] - B[v]);\n    used[v] = 1;\n    Int mn = INF;\n    for(Int to:G[v]){\n      to = uf.find(to);\n      if(used[to] == 0) continue;\n      Int a = max(0LL, c - uf.size(to));\n      Int b = dp[to];\n      Min(mn, max(a, b));\n      uf.unite(v, to);\n    }\n    v = uf.find(v);\n    if(mn == INF) mn = c;\n    dp[v] = mn;\n  }\n\n  Int res = accumulate(B.begin(), B.end(), 0LL);\n  assert(res == uf.size(0));\n  Int last = uf.find(ord.back());\n  res += max(0LL, dp[last]);\n  return res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int m;\n  cin>>n>>m;\n  G.resize(n);\n  A.resize(n); B.resize(n);\n  for(Int i=0;i<n;i++) cin>>A[i]>>B[i];\n  \n  for(Int i=0;i<m;i++){\n    Int u, v;\n    cin>>u>>v; u--, v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  Int ans = solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\ntypedef long long ll; \nint a[100005], b[100005], fa[100005], idx[100005]; \nll dp[100005], sum[100005]; \nstd::vector<int> adj[100005], son; \nbool vis[100005]; \nint getfa(int u)\n{\n\tif (u == fa[u])\n\t\treturn u; \n\treturn fa[u] = getfa(fa[u]); \n}\nint main()\n{\n\t// freopen(\"ARC098-F.in\", \"r\", stdin); \n\tint n, m; \n\tscanf(\"%d%d\", &n, &m); \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d%d\", a + i, b + i); \n\t\ta[i] = std::max(a[i] - b[i], 0); \n\t\tfa[i] = idx[i] = i; \n\t}\n\tstd::sort(idx, idx + n, [&] (int x, int y) { return a[x] < a[y]; }); \n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint u, v; \n\t\tscanf(\"%d%d\", &u, &v); \n\t\tadj[--u].pb(--v); \n\t\tadj[v].pb(u); \n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint u = idx[i]; \n\t\tvis[u] = true; \n\t\tson.clear(); \n\t\tsum[u] = b[u]; \n\t\tfor (int v : adj[u])\n\t\t{\n\t\t\tif (!vis[v] || getfa(v) == getfa(u))\n\t\t\t\tcontinue; \n\t\t\tsum[u] += sum[getfa(v)]; \n\t\t\tson.pb(getfa(v)); \n\t\t\tfa[getfa(v)] = getfa(u); \n\t\t}\n\t\tdp[u] = sum[u] + a[u]; \n\t\tfor (int v : son)\n\t\t\tdp[u] = std::min(dp[u], sum[u] - sum[v] + std::max((ll)a[u], dp[v])); \n\t}\n\tprintf(\"%lld\\n\", dp[idx[n - 1]]);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Use[n] == 0)\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total += B[neighb];\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 10000000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<long long> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.resize(n);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        UnionFind uf(n);\n        vector<pair<long long, int>> c(n);\n        vector<int> bs(n);\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                c[i] = make_pair(max(0LL, (long long) a - b), i);\n                uf.num[i] = b;\n        }\n        sort(c.begin(), c.end());\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        vector<long long> dp(n);\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; i ++) {\n                long long mi = c[i].first;\n                int u = c[i].second;\n                for (auto v : g[u]) if (used[v]) {\n                        int ch = uf.find(v);\n                        mi = min(mi, max(dp[ch], c[i].first - uf.num[ch]));\n                }\n                used[u] = true;\n                for (auto v : g[u]) if (used[v]) {\n                        uf.unite(u, v);\n                }\n                dp[uf.find(u)] = mi;\n        }\n        printf(\"%lld\\n\", dp[uf.find(0)] + uf.num[uf.find(0)]);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=s-1;\n  Int r=1e18;\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree;\n  vector<vector<int>> list;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    list.resize(v);\n    REP(i,v) tree[i] = i, list[i].push_back(i);\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return list[root(i)].size();\n  }\n\n  vector<int> nodes(int no){\n    return list[root(no)];\n  }\n\n  bool unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x==y) return false;\n    if(list[x].size() < list[y].size()) swap(x,y);\n    for(int no:list[y]) list[x].emplace_back(no);\n    tree[y] = x;\n    return true;\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nconst int N = 1e5+10;\nvector<P> e[N];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  vector<int> a(n),b(n);\n  vector<P> c(n);\n  REP(i,n) cin >> a[i] >> b[i], c[i] = P(max(0LL,a[i]-b[i]),i);\n  \n  using T = tuple<int,int,int>;\n  vector<int> edge[n];\n  REP(_,m){\n    int x,y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].emplace_back(y);\n    edge[y].emplace_back(x);\n  }\n\n  sort(c.begin(),c.end());\n\n  UnionFind uf(n);\n  vec sb = b, dp(n), used(n,0);\n  REP(i,n) dp[c[i].sc] = c[i].fs;\n\n  REP(i,n){\n    int no = c[i].sc, mn = c[i].fs, sum = b[no];\n    //cout << no SP mn SP sum << endl;\n    for(int to:edge[no]){\n      if(!used[to]) continue;\n      int v = uf.root(to);\n      mn = min(mn,max(dp[v],c[i].fs-sb[v]));\n    }\n    used[no]++;\n    for(int to:edge[no]){\n      if(!used[to]) continue;\n      if(!uf.isUnit(no,to)){\n        sum += sb[uf.root(to)];\n        uf.unit(no,to);\n      }\n    }\n    //cout << uf.root(no) SP mn SP sum << endl;\n    dp[uf.root(no)] = mn;\n    sb[uf.root(no)] = sum;\n  }\n\n  REP(i,n) cout << dp[i] << endl;\n\n  int v = uf.root(0);\n  cout << dp[v] + sb[v] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nconst int N = 3e5 + 233;\nlo b[N], c[N], sumb[N], f[N];\nint n, m, pre[N], id[N];\nvector <int> G[N], F[N];\n\ninline bool cmp_c(int x, int y) {\n\treturn c[x] < c[y];\n}\n\ninline int find(int x) {\n\treturn pre[x] == x ? x : pre[x] = find(pre[x]);\n}\n\ninline void make(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y) return ;\n\tpre[y] = x; F[x].push_back(y);\n\t// cerr << x << \" -> \" << y << \"\\n\";\n}\n\ninline void dfs(int u) {\n\tsumb[u] = b[u];\n\tfor (int v : F[u]) {\n\t\tdfs(v);\n\t\tsumb[u] += sumb[v];\n\t}\n\tif (F[u].size()) {\n\t\tf[u] = 1e18;\n\t\tfor (int v : F[u]) {\n\t\t\tlo vtotal = sumb[u] - sumb[v];\n\t\t\tassert(vtotal >= 0);\n\t\t\tf[u] = min(f[u], max(c[u], f[v]) + vtotal);\n\t\t}\n\t}\n\tf[u] = max(f[u], c[u] + b[u]);\n\t// cout << u << \" \" << f[u] << \" \" << c[u] << \" \" << b[u] << \"\\n\";\n}\n\nint main(void) {\n\tread(n); read(m);\n\trep (i, n) read(c[i]), read(b[i]), c[i] = max(0ll, c[i] - b[i]);\n\trep (i, m) {\n\t\tint x, y; read(x); read(y);\n\t\tG[x].push_back(y); G[y].push_back(x);\n\t}\n\trep (i, n) id[i] = i, pre[i] = i;\n\tsort(id + 1, id + n + 1, cmp_c);\n\trep (i, n) {\n\t\tint u = id[i];\n\t\tsort(G[u].begin(), G[u].end(), cmp_c);\n\t\tfor (int v : G[u])\n\t\t\tif (c[v] < c[u]) make(u, v);\n\t}\n\tdfs(find(1));\n\tcout << f[find(1)] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 100100;\nint a[N], b[N], n, m, vis[N], fa[N], c[N];\ntypedef long long ll;\nvector<int>g[N];\nll sum[N], mn[N];\nbool cmp(const int& x, const int& y) {\n\tif (a[x] != a[y])return a[x] < a[y];\n\treturn b[x] > b[y];\n}\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) { cin >> a[i] >> b[i]; c[i] = i; }\n\tsort(c + 1, c + n + 1, cmp);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tg[x].push_back(y); g[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; ++i)fa[i] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint u = c[i]; sum[u] = b[u]; mn[u] = max(0, a[u] - b[u]);\n\t\tvis[u] = 1;\n\t\tfor (int j : g[u])if (vis[j]) {\n\t\t\tint v = find(j); if (u == v)continue;\n\t\t\tsum[u] += sum[v]; mn[u] = min(mn[u], max(a[u] - sum[v] - b[u], mn[v]));\n\t\t\tfa[v] = u;\n\t\t}\n\t}\n\tcout << sum[c[n]] + mn[c[n]] <<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 100010>\nstruct UF{\n\tint par[N],r[N];\n\tll sum[N];\n\tpriority_queue<P> *que[N];\n\tUF(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tvoid init(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tif(que[i] != nullptr)delete que[i];\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unit_(int x,int y){\n\t\tpar[x] = y;\n\t\tsum[y] += sum[x];\n\t\tif(que[x]->size() < que[y]->size()){\n\t\t\twhile(!que[x]->empty()){\n\t\t\t\tP p = que[x]->top(); que[x]->pop();\n\t\t\t\tque[y]->push(p);\n\t\t\t}\n\t\t\tdelete que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\telse {\n\t\t\twhile(!que[y]->empty()){\n\t\t\t\tP p = que[y]->top(); que[y]->pop();\n\t\t\t\tque[x]->push(p);\n\t\t\t}\n\t\t\tdelete que[y];\n\t\t\tque[y] = que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\tif(r[x] == r[y])r[y] ++;\n\t}\n\tvoid unit(int x,int y){\n\t\tif(same(x,y))return;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(r[x] < r[y]){\n\t\t\tunit_(x,y);\n\t\t}\n\t\telse {\n\t\t\tunit_(y,x);\n\t\t}\n\t}\n\tvoid run(int v,int w){\n\t\twhile(1){\n\t\t\tv = find(v);\n\t\t\tif(que[v]->empty())break;\n\t\t\tP p = que[v]->top();\n\t\t\tif(find(p.sc) == v)que[v]->pop();\n\t\t\telse if(p.fr+sum[v]+w >= 0){\n\t\t\t\tque[v]->pop();\n\t\t\t\tunit(v,p.sc);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n};\n\nUF<100010> uf;\n\nint main(){\n\tstatic int n,m;\n\tstatic int a[100010],b[100010];\n\tstatic int u[100010],v[100010];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tfor(int i = 0 ; i < m ; i ++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tu[i] --;\n\t\tv[i] --;\n\t}\n\t\n\tif(n == 1){\n\t\tcout << max( a[0] , b[0] ) << endl;\n\t\treturn 0;\n\t}\n\t\n\tll l = 0, r = 1000000000;\n\twhile(l<r){\n\t\tint mi = (l+r)/2;\n\t\tuf.init();\n\t\tfor(int i = 0 ; i < m ; i ++){\n\t\t\tuf.que[u[i]]->push(P(b[v[i]]-a[v[i]],v[i]));\n\t\t\tuf.que[v[i]]->push(P(b[u[i]]-a[u[i]],u[i]));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tuf.sum[i] = b[i];\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tif(a[i] <= b[i]+mi)uf.run(i,mi);\n\t\t}\n\t\tint root = uf.find(0);\n\t\tbool ok = true;\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tok &= uf.find(i) == root;\n\t\t}\n\t\tif(ok)r = mi;\n\t\telse l = mi+1;\n\t}\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tl += b[i];\n\t}\n\tcout << l << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nint bh[N],bt;\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nbool rdcmp(int a,int b){\n\treturn rand()%2;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tLL ans=1e16;\n\tdfs(root,0);\n\tans=min(ans,need[root]);\n\tsrand(19260817);\n\tbt=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (A[i]==A[root]){\n\t\t\tbh[++bt]=i;\n\t\t}\n\t}\n\tsort(bh+1,bh+bt+1,rdcmp);\n\tfor (int i=1;i<=min(50,bt);i++){\n\t\troot=bh[i];\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tfor (int i=1;i<=800;i++){\n\t\troot=rand()%n+1;\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\n\tvector<int> par, ran;\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u1, u2; cin >> u1 >> u2; u1--; u2--;\n\t\tu1 = trans[u1], u2= trans[u2];\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i]+csum);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = mi;\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\nint n,m,x,y,L,R,M,T,fl;\nint f[100005],vis[100005],a[100005],b[100005],rt[100005];\nvector <int> e[100005];\nint g[500005],lc[500005],rc[500005];\nLL sum,w[100005];\nint find(int x){\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nint he(int u,int v){\n\tif (!u||!v) return u+v;\n\tif (a[g[u]]-b[g[u]]>a[g[v]]-b[g[v]]) swap(u,v);\n\tlc[u]=he(lc[u],v);\n\tswap(lc[u],rc[u]);\n\treturn u;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&a[i],&b[i]),sum+=b[i];\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tL=0; R=1000000000;\n\twhile (L<R){\n\t\tM=(L+R)/2; T=0; fl=0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t\t{f[i]=i; w[i]=M; vis[i]=0;}\n\t\tfor (int i=1;i<=n;++i)\n\t\tif (a[i]<=b[i]+M&&!vis[i]){\n\t\t\tg[++T]=i; lc[T]=rc[T]=0; rt[i]=T;\n\t\t\twhile (rt[i]){\n\t\t\t\tx=g[rt[i]];\n\t\t\t\tif (a[x]-b[x]>w[i]) break;\n\t\t\t\trt[i]=he(lc[rt[i]],rc[rt[i]]);\n\t\t\t\tif (vis[x]) continue;\n\t\t\t\tw[i]+=b[x]; f[x]=i; vis[x]=1;\n\t\t\t\tfor (unsigned j=0;j<e[x].size();++j){\n\t\t\t\t\ty=find(e[x][j]);\n\t\t\t\t\tif (y==i) continue;\n\t\t\t\t\tif (!vis[y]){\n\t\t\t\t\t\tg[++T]=y; lc[T]=rc[T]=0;\n\t\t\t\t\t\trt[i]=he(rt[i],T);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trt[i]=he(rt[i],rt[y]);\n\t\t\t\t\t\tf[y]=i; w[i]+=w[y]-M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (w[i]==sum+M) {fl=1; break;}\n\t\t\t}\n\t\t\tif (fl) break;\n\t\t}\n\t\tif (fl) R=M; else L=M+1;\n\t}\n\tprintf(\"%lld\\n\",sum+L);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nnamespace loquat {\nclass disjoint_set {\npublic:\n\tusing value_type = size_t;\nprivate:\n\tstd::vector<value_type> m_parents;\n\tstd::vector<value_type> m_ranks;\npublic:\n\texplicit disjoint_set(size_t n)\n\t\t: m_parents(n)\n\t\t, m_ranks(n)\n\t{\n\t\tfor(size_t i = 0; i < n; ++i){\n\t\t\tm_parents[i] = i;\n\t\t}\n\t}\n\tvalue_type find(size_t x){\n\t\tif(m_parents[x] == x){ return x; }\n\t\tm_parents[x] = find(m_parents[x]);\n\t\treturn m_parents[x];\n\t}\n\tvalue_type unite(size_t x, size_t y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){ return x; }\n\t\tif(m_ranks[x] < m_ranks[y]){\n\t\t\tm_parents[x] = y;\n\t\t\treturn y;\n\t\t}else if(m_ranks[x] > m_ranks[y]){\n\t\t\tm_parents[y] = x;\n\t\t\treturn x;\n\t\t}else{\n\t\t\tm_parents[y] = x;\n\t\t\t++m_ranks[x];\n\t\t\treturn x;\n\t\t}\n\t}\n\tbool same(size_t x, size_t y){\n\t\treturn find(x) == find(y);\n\t}\n};\n}\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing tiii = tuple<int, int, int>;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<ll> a(n), b(n);\n\tfor(int i = 0; i < n; ++i){ cin >> a[i] >> b[i]; }\n\tvector<vector<int>> conn(n);\n\tfor(int i = 0; i < m; ++i){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tconn[u].push_back(v);\n\t\tconn[v].push_back(u);\n\t}\n\tvector<tiii> vorder(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tvorder[i] = tiii(a[i], b[i], i);\n\t}\n\tsort(vorder.begin(), vorder.end());\n\tloquat::disjoint_set ds(n);\n\tvector<bool> done(n);\n\tvector<ll> w(n), c(n);\n\tfor(const auto& vp : vorder){\n\t\tconst int u = get<2>(vp);\n\t\tvector<pll> ws;\n\t\tfor(const int v : conn[u]){\n\t\t\tif(done[v] && !ds.same(u, v)){\n\t\t\t\tconst int g = ds.find(v);\n\t\t\t\tws.emplace_back(w[g], c[g]);\n\t\t\t\tds.unite(u, v);\n\t\t\t}\n\t\t}\n\t\tsort(ws.begin(), ws.end());\n\t\tconst int g = ds.find(u);\n\t\tif(ws.empty()){\n\t\t\tw[g] = max(a[u], b[u]);\n\t\t\tc[g] = b[u];\n\t\t}else{\n\t\t\tll csum = 0;\n\t\t\tfor(const auto& p : ws){ csum += p.second; }\n\t\t\tll w_best = max(a[u], b[u]) + csum;\n\t\t\tfor(const auto& p : ws){\n\t\t\t\tw_best = min(w_best, max(a[u], p.first + b[u]) + (csum - p.second));\n\t\t\t}\n\t\t\tw[g] = w_best;\n\t\t\tc[g] = csum + b[u];\n\t\t}\n\t\tdone[u] = true;\n\t}\n\tcout << *max_element(w.begin(), w.end()) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll LLINF = 1ll << 60;\nconst int N = 100010;\nint n, m, va[N], vb[N], id[N], per[N], uni[N];\nll sum[N], dp[N], ans;\nint getfa(int pos) {\n  return pos == uni[pos] ? pos : uni[pos] = getfa(uni[pos]);\n}\nvector<int> vec[N];\nint main() {\n  int x,y;\n  read(n), read(m);\n  rep (i, 1, n) read(va[i]), read(vb[i]);\n  rep (i, 1, n) per[i] = i;\n  sort(per + 1, per + n + 1, [=](int a,int b) -> bool {\n      return max(va[a] - vb[a], 0) < max(va[b] - vb[b], 0);\n    });\n  rep (i, 1, n) id[per[i]] = i;\n  rep (i, 1, m) {\n    read(x), read(y);\n    if (id[x] < id[y]) swap(x, y);\n    vec[x].push_back(y);\n  }\n  rep (i, 1, n) {\n    uni[i] = i;\n    sum[i] = vb[i];\n    dp[i] = max(va[i], vb[i]);\n  }\n  rep (i, 1, n) {\n    int j = per[i];\n    vector<int> tmp;\n    rep (k, 0, (int)vec[j].size()-1)\n      tmp.push_back(getfa(vec[j][k]));\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n    ll ssum = 0;\n    rep (k, 0, (int)tmp.size()-1)\n      ssum += sum[tmp[k]];\n    ssum += vb[j];\n    dp[j] = LLINF;\n    if (tmp.empty()) dp[j] = max(va[j], vb[j]);\n    rep (k, 0, (int)tmp.size()-1)\n      dp[j] = min(dp[j], max(dp[tmp[k]], (ll)max(va[j] - vb[j], 0)) + ssum - sum[tmp[k]]);\n    rep (k, 0, (int)tmp.size()-1) {\n      sum[j] += sum[tmp[k]];\n      uni[tmp[k]] = j;\n    }\n  }\n  cout << dp[per[n]] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define SIZE 200000\ntypedef long long ll;\ntypedef pair<ll, ll>pii;\nclass unionfind\n{\npublic:\n\tint par[SIZE];\n\tint ran[SIZE];\n\tll ren[SIZE];\n\tll dp[SIZE];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i<SIZE; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t\tren[i] = 1;\n\t\t}\n\t}\n\tint find(int a)\n\t{\n\t\tif (a == par[a])return a;\n\t\telse return par[a] = find(par[a]);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b)return;\n\t\tif (ran[a]>ran[b])\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tren[a] += ren[b];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[a] = b;\n\t\t\tren[b] += ren[a];\n\t\t}\n\t\tif (ran[a] == ran[b])ran[b]++;\n\t}\n};\nunionfind uf;\nll da[101010], db[101010];\nvector<int>pat[101010];\nbool flag[101010];\nint main()\n{\n\tint num, way;\n\tscanf(\"%d%d\", &num, &way);\n\tvector<pii>zat;\n\tfor (int i = 0; i < num; i++)scanf(\"%lld%lld\", &da[i], &db[i]), zat.push_back(make_pair(max(0LL, da[i] - db[i]), i));\n\tsort(zat.begin(), zat.end());\n\tfor (int i = 0; i < way; i++)\n\t{\n\t\tint za, zb;\n\t\tscanf(\"%d%d\", &za, &zb);\n\t\tza--, zb--;\n\t\tpat[za].push_back(zb);\n\t\tpat[zb].push_back(za);\n\t}\n\tuf.init();\n\tfor (int i = 0; i < num; i++)uf.ren[i] = db[i];\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tll mini = zat[i].first;\n\t\tint v = zat[i].second;\n\t\tfor (int j = 0; j < pat[v].size(); j++)\n\t\t{\n\t\t\tif (!flag[pat[v][j]])continue;\n\t\t\tint w = uf.find(pat[v][j]);\n\t\t\tmini = min(mini, max(uf.dp[w], zat[i].first - uf.ren[w]));\n\t\t}\n\t\tflag[v] = true;\n\t\tfor (int j = 0; j < pat[v].size(); j++)if (flag[pat[v][j]])uf.unite(v, pat[v][j]);\n\t\tuf.dp[uf.find(v)] = mini;\n\t}\n\tprintf(\"%lld\\n\", uf.dp[uf.find(0)] + uf.ren[uf.find(0)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=1e5,MAX_M=1e5;\n\nint N,M;\nll A[MAX_N],B[MAX_N],C[MAX_N];\nconst ll INF=1e17;\nvector<int> G[MAX_N];\n\nint tpar[MAX_N];\nvector<int> tre[MAX_N];\nll dp[MAX_N],bsm[MAX_N];\n\nint upar[MAX_N];\n\nvoid init(){\n\tREP(i,N){\n\t\tupar[i]=i;\n\t}\n}\n\nint fpar(int v){\n\tif (upar[v]==v){\n\t\treturn v;\n\t}\n\treturn upar[v]=fpar(upar[v]);\n}\n\nvoid unite(int s,int t){\n\ts=fpar(s);\n\tt=fpar(t);\n\tupar[t]=s;\n}\n\nvoid dfs(int v,int p){\n\tfor(auto e:tre[v]){\n\t\tif (e!=p){\n\t\t\tdfs(e,v);\n\t\t}\n\t}\n\tbsm[v]+=B[v];\n\tfor(auto e:tre[v]){\n\t\tif (e!=p){\n\t\t\tbsm[v]+=bsm[e];\n\t\t}\n\t}\n\tdp[v]=C[v]+bsm[v];\n\tfor(auto e:tre[v]){\n\t\tif (e!=p){\n\t\t\tdp[v]=min(dp[v],max(dp[e],C[v])+bsm[v]-bsm[e]);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>N>>M;\n\tREP(i,N){\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]=max(A[i]-B[i],0ll);\n\t}\n\tREP(i,M){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tinit();\n\tREP(i,N){\n\t\ttpar[i]=i;\n\t}\n\t{\n\t\tvector<bool> flg;\n\t\tvector<int> vec;\n\t\tREP(i,N){\n\t\t\tvec.push_back(i);\n\t\t\tflg.push_back(false);\n\t\t}\n\t\tsort(vec.begin(),vec.end(),[](int a,int b){\n\t\t\treturn C[a]<C[b];\n\t\t});\n\t\tfor(auto v:vec){\n\t\t\tfor(auto e:G[v]){\n\t\t\t\tif (C[v]>C[e] || (C[v]==C[e] && flg[e])){\n\t\t\t\t\ttpar[fpar(e)]=v;\n\t\t\t\t\tupar[fpar(e)]=v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tflg[v]=true;\n\t\t}\n\t}\n\tint rot;\n\tREP(v,N){\n\t\tif (tpar[v]==v){\n\t\t\trot=v;\n\t\t}else{\n\t\t\ttre[v].push_back(tpar[v]);\n\t\t\ttre[tpar[v]].push_back(v);\n\t\t}\n\t}\n\tdfs(rot,-1);\n\tcout<<dp[rot]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<sys/time.h>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ninline int ri()\n{\n\tregister int x=0;register bool f=0;register char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();};\n\treturn f?-x:x;\n}\nvoid wi(int x)\n{\n\tif(x<0)\tx=-x,putchar('-');\n\tif(x>9)\twi(x/10);\n\tputchar('0'+x%10);\n}\n#define N 100005\nstruct edge\n{\n\tint to,next;\n}e[N*2];\nint n,m,tot,head[N];\nint a[N],b[N],id[N],fa[N];\nlong long qd[N],S[N];\nbool cmp(int x,int y)\n{\n\treturn a[x]<a[y];\n}\nvoid add(int x,int y)\n{\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint get(int x)\n{\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint vis[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)\tid[i]=i,fa[i]=i,qd[i]=a[i],S[i]=b[i]; \n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id[i];\n\t\tvis[x]=1;\n\t\tfor(int j=head[x];j;j=e[j].next)\n\t\t\tif(vis[e[j].to])\n\t\t\t{\n\t\t\t\tint X=get(x),Y=get(e[j].to);\n\t\t\t\tif(X==Y) continue;\n\t\t\t\tfa[Y]=X;S[X]+=S[Y];\n\t\t\t\tqd[X]=min(qd[X],qd[Y]+max(0ll,a[x]-S[Y]-qd[Y]));\n\t\t\t}\n\t}\n\tint x=get(1);\n\tprintf(\"%lld\",qd[x]+S[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define pb emplace_back\nusing namespace std;\nvector<int> e[N];\nint m,n,w[N],x,y,f[N];\nll a[N],b[N],sb[N],dp[N];\nvoid jb(int x,int y){e[x].pb(y);}\nbool xi(int x,int y){return (a[x]-b[x]<a[y]-b[y])||(a[x]-b[x]==a[y]-b[y]&&x<y);}\nbool c1(const int &x,const int &y){return xi(x,y);}\nint quef(int x){if (f[x]!=x) f[x]=quef(f[x]);return f[x];}\nvoid lb(int x,int y){\n\tif (x==y)return ;f[y]=x;\n\tsb[x]+=sb[y];dp[x]=min(dp[x],max(dp[y],a[x]-b[x])-sb[y]);\n}\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++){cin>>a[i]>>b[i];w[i]=f[i]=i;}\n\tfor (int i=1;i<=m;i++){cin>>x>>y;jb(x,y);jb(y,x);}\n\tsort(w+1,w+n+1,c1);\n\tfor (int i=1;i<=n;i++){\n\t\tdp[w[i]]=max(0ll,a[w[i]]-b[w[i]]),sb[w[i]]=b[w[i]];\n\t\tfor (auto j:e[w[i]]){\n\t\t\tif (xi(j,w[i]))lb(w[i],quef(j));\n\t\t}\n\t\tdp[w[i]]+=sb[w[i]];\n\t}\n\tcout<<dp[w[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],rk[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(const int&x,const int&y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:par[x]=getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) \n        par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i){ \n        A[i]=read();\n        B[i]=read();\n        C[i]=max(A[i]-B[i],0LL);\n    }\n\tfor(i=1;i<=M;++i) {\n        x=read();\n        y=read();\n        G[x].pb(y);\n        G[y].pb(x);\n    }\n\tsort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)rk[id[i]]=i;\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j){\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&rk[y]<i) \n            par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\n\ntypedef pair<ll,ll> ii;\n\nint a[N];\nint b[N];\nint vis[N];\n\nint p[N];\nint c[N];\n\nint lead(int x) {   return  p[x] == 0 ? x : p[x] = lead(p[x]);  }\n\nvector<int> g[N];\n\nii  dfs(int u)  {\n    vector<ii>  vec;\n\n    for(int v : g[u])\n        vec.pb(dfs(v));\n    \n    ll  S = b[u];\n    ll  F = g[u].empty() ? max(a[u],b[u]) : 1e18;\n\n    for(ii  T : vec)    S += T.X;\n    for(ii  T : vec)    {\n        ll  nxt = max(T.Y,1ll * c[u]) + S - T.X;\n\n        if (F > nxt)\n            F = nxt;\n    }\n    return  ii(S,F);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n    int m;  cin >> m;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        cin >> a[i];\n        cin >> b[i];\n        c[i] = a[i] - b[i];\n\n        if (c[i] < 0)\n            c[i] = 0;\n    }\n    vector<int> perm(n);\n\n    iota(all(perm),1);\n    sort(all(perm),[&](int x,int y) {   return  c[x] < c[y];    });\n\n    for(int i = 1 ; i <= m ; ++i)   {\n        int x;  cin >> x;\n        int y;  cin >> y;\n\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    for(int x : perm)   {\n        vector<int> vec = g[x]; g[x].clear();\n        vis[x] = 1;\n\n        for(int y : vec)    {\n            y = lead(y);\n            if (vis[y] && y != x)   {\n                g[x].pb(y);\n                p[y] = x;\n            }\n        }\n    }\n    cout << dfs(perm[n - 1]).Y << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//ProblemE\n\n//#define USE_STDIO\n//#define USE_LOG\n//#define FILE_ERR\n\n#ifdef _MYPC\n#include \"mypc.h\"\n#endif // _MYPC\n\n#ifndef debug\n#define debug(...)\n#endif // !LOG\n\n//include\n#include <iostream>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <memory>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\n//for\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define forbe(i, begin, end) for(decltype(begin) i = (begin); i != (end); ++i)\n#define forbes(i, begin, end, step) for(decltype(begin) i = (begin); i != (end); i += (step))\n\n//int\nusing ll = long long;\nusing ull = unsigned long long;\nusing uint = unsigned;\n\n//pair\nusing pii = std::pair<int, int>;\nusing pll = std::pair<ll, ll>;\n#define fi first\n#define se second\n\n//vector\ntemplate <typename Value>\nstatic inline void fillv(Value& x, const Value& val) { x = val; }\ntemplate <typename Vector, typename Value>\nstatic inline void fillv(Vector& v, const Value& val) { for (auto& x : v) fillv(x, val); }\n\nstatic inline void Solve();\n\nint main(int argc, char* argv[]) {\n#ifdef REDIRECT_STDIO\n\tREDIRECT_STDIO;\n#endif // REDIRECT_STDIO\n\n\tSolve();\n\treturn 0;\n}\n\nconstexpr int MAXN = 2000;\nconstexpr int INF = 0x7FFFFFFF;\nint a[MAXN];\nint b[MAXN];\nint n, k, q;\n\nvector<pii> get_ps(int i) {\n\tvector<pii> rst;\n\tfor (int j = 0; j <= n; j++) {\n\t\tif (j < n && b[j] >= b[i]) {\n\t\t\tif (rst.empty() || rst.back().second != j - 1) {\n\t\t\t\trst.push_back({ j, j });\n\t\t\t}\n\n\t\t\trst.back().second = j;\n\t\t}\n\t\telse {\n\t\t\tif (!rst.empty() && rst.back().second - rst.back().first + 1 < k) {\n\t\t\t\trst.pop_back();\n\t\t\t}\n\t\t}\n\t}\n\treturn rst;\n}\n\nint tmp[MAXN];\nint solve(int i) {\n\tfor (int j = 0; j < n; j++) b[j] = a[j];\n\tauto ps = get_ps(i);\n\tbool hasi = false;\n\tvector<int> minv;\n\n\tfor (auto &p : ps) {\n\t\tif (p.first <= i && i <= p.second) {\n\t\t\thasi = true;\n\t\t}\n\t\tint num = p.second - p.first + 1;\n\t\tsort(b + p.first, b + p.second - 1);\n\t\tfor (auto it = b + p.first; it != b + p.first + num - k + 1; it++) {\n\t\t\tminv.push_back(*it);\n\t\t}\n\t}\n\n\tif (!hasi) return INF;\n\tif ((int)minv.size() < q) return INF;\n\tsort(minv.begin(), minv.end());\n\treturn minv[q-1] - a[i];\n}\n\n//ProblemE\nvoid Solve() {\n\tcin >> n >> k >> q;\n\tforn(i, n) cin >> a[i];\n\n\tint ans = INF;\n\tfor (int i = 0; i < n; i++) {\n\t\tans = min(ans, solve(i));\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#ifdef CX_TEST\n#define Debug printf\n#else\n#define Debug(...)\n#endif\n#define LL long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int maxn = 1e5 + 5;\n\nint a[maxn], b[maxn], c[maxn], p[maxn];\nLL s[maxn], d[maxn];\nbool vis[maxn];\nvector<int> g[maxn];\n\nbool cmp(const int x, const int y) {\n    return a[x] < a[y];\n}\n\nint ff(int x) {\n    if(p[x] != x) p[x] = ff(p[x]);\n    return p[x];\n}\n\nint main() {\n#ifdef CX_TEST\n    freopen(\"E:\\\\program--GG\\\\test_in.txt\", \"r\", stdin);\n#endif\n    int n, m, i, j, u, v;\n    scanf(\"%d%d\", &n, &m);\n    for(i = 1;i <= n; i++) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n        a[i] = max(a[i] - b[i], 0);\n        s[i] = b[i];\n        d[i] = a[i];\n    }\n    for(i = 1;i < n; i++) {\n        scanf(\"%d%d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    for(i = 1;i <= n; i++) c[i] = i;\n    for(i = 1;i <= n; i++) p[i] = i;\n    sort(c + 1, c + n + 1, cmp);\n    for(i = 1;i <= n; i++) {\n        j = c[i];\n        vis[j] = 1;\n        for(auto e:g[j]) {\n            if(vis[e]) {\n                u = ff(j), v = ff(e);\n                if(u != v) {\n                    s[u] += s[v];\n                    p[v] = u;\n                    d[u] = min(d[u], d[v] + max(0LL, a[u] - d[v] - s[v]));\n                }\n            }\n        }\n    }\n    cout << s[c[n]] + d[c[n]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.05.2018 15:10:27       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n  public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  vector<vector<int>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  vector<int> add(n);\n  iota(add.begin(), add.end(), 0);\n  sort(add.begin(), add.end(), [&](int i, int j) {\n    return a[i] < a[j];\n  });\n  dsu d(n);\n  vector<long long> sum_b(n);\n  vector<long long> ans(n);\n  for (int i = 0; i < n; i++) {\n    sum_b[i] = b[i];\n    ans[i] = max(a[i], b[i]);\n  }\n  vector<int> was(n, 0);\n  for (int i : add) {\n    set<int> s;\n    for (int j : graph[i]) {\n      if (was[j]) {\n        s.insert(d.get(j));\n      }\n    }\n    for (int j : s) {\n      sum_b[i] += sum_b[j];\n      d.unite(j, i);\n    }\n    if (!s.empty()) {\n      long long best = (long long) 1e18;\n      for (int j : s) {\n        long long sum_b_without = sum_b[i] - sum_b[j];\n        long long cur = max(ans[j] + sum_b_without, a[i] + sum_b_without - b[i]);\n        best = min(best, cur);\n      }\n      ans[i] = best;\n    }\n    was[i] = 1;\n  }\n  cout << ans[d.get(0)] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N],z[N],nxt[N],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t}\n\tint root=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tdfs(root,0);\n\tprintf(\"%lld\",need[root]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n#define AddMult(x, y, z) x = (x + (y) * (z)) % mod\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost = 0){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost = 0){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n};\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, ans, get;\n\n    Union_find(int N, vec A, vec B){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        ans = A;\n        get = B;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        //int tmp = ans[x];\n        //if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        get[x] += get[y];\n        //ans[x] = tmp;\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n    void unite2(int x, int y, vec &A){\n        if(is_union(x, y)) return;\n        y = find(y);\n        Min(ans[x], max(ans[y], A[x] - get[y]));\n        unite(x, y);\n\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    pairs p(N);\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        A[i] = max(0LL, A[i] - B[i]);\n        p[i] = Pii(A[i], i);\n    }\n    Sort(p);\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1);\n    }\n\n    Union_find UF(N, A, B);\n    bools used(N, false);\n    REP(i, N){\n        int i0 = p[i].second;\n        for(auto e: G.G[i0]) if(used[e.to]) UF.unite2(i0, e.to, A);\n        used[i0] = true;\n    }\n    int ans = UF.ans[p[N - 1].second];\n    REP(i, N) ans += B[i];\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nint par[N],n,b[N],m;\nlong long sum[N],v[N];\nvector<int>g[N];\nvector<pair<int,int>>temp;\nbool vis[N];\nint get(int u){return par[u] == u ? u : par[u] = get(par[u]);}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0,a;i < n;i++){\n\t\tpar[i] = i;\n\t\tscanf(\"%d%d\",&a,b + i);\n\t\ttemp.push_back({a - b[i],i});\n\t}\n\tfor(int i = 0,a,b;i < m;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[--a].push_back(--b);\n\t\tg[b].push_back(a);\n\t}\n\tsort(temp.begin(),temp.end());\n\tfor(auto i : temp){\n\t\tint need = max(0,i.first),at = i.second;\n\t\tsum[at] = b[at];\n\t\tv[at] = need;\n\t\tvis[at] = 1;\n\t\tfor(auto j : g[at]){\n\t\t\tint from = get(j);\n\t\t\tif(from == at || !vis[from])continue;\n\t\t\tsum[at]+=sum[from];\n\t\t\tif(sum[from] + v[from] >= need)v[at] = min(v[at],v[from]);\n\t\t\telse v[at] = min(v[at],need - sum[from]);\n\t\t\t// v[at] = min(v[at],max(v[from],need - sum[from]));\n\t\t\tpar[from] = at;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum[temp.back().second] + v[temp.back().second]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n#define GG puts(\"FUCK\")\n#define N 100050\nint head[N],to[N],nxt[N],fa[N],a[N],b[N],c[N],n,m,vis[N],id[N],cnt;\nvector<int>v[N];\nll f[N],s[N];\nint find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nbool cmp(int x,int y) {return c[x]<c[y];}\ninline void add(int u,int v) {\n\tto[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt;\n}\nvoid dfs(int x) {\n\tint i; s[x]=b[x];\n\tfor(i=head[x];i;i=nxt[i]) {\n\t\tdfs(to[i]); s[x]+=s[to[i]];\n\t}\n\tf[x]=s[x]+c[x];\n\tfor(i=head[x];i;i=nxt[i]) {\n\t\tf[x]=min(f[x],s[x]-s[to[i]]+max(f[to[i]],1ll*c[x]));\n\t}\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tint i,x,y,j;\n\tfor(i=1;i<=n;i++) {\n\t\tscanf(\"%d%d\",&a[i],&b[i]); c[i]=max(a[i]-b[i],0); fa[i]=id[i]=i;\n\t}\n\tfor(i=1;i<=m;i++) {\n\t\tscanf(\"%d%d\",&x,&y); v[x].push_back(y); v[y].push_back(x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor(i=1;i<=n;i++) {\n\t\tx=id[i]; int lim=v[x].size(); vis[x]=1;\n\t\tfor(j=0;j<lim;j++) {\n\t\t\ty=v[x][j]; if(!vis[y]) continue;\n\t\t\ty=find(y);\n\t\t\tif(x!=y) {\n\t\t\t\tfa[y]=x; add(x,y);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(id[n]);\n\tprintf(\"%lld\\n\",f[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100000\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nll f[MN+5],g[MN+5];\nint n,m,a[MN+5],b[MN+5],c[MN+5],s[MN+5],rk[MN+5],used[MN+5],head[MN+5],cnt,vis[MN+5];\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\ninline int getfa(int x){return s[x]?s[x]=getfa(s[x]):x;}\nbool cmp(int x,int y){return c[x]<c[y];}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i) a[i]=read(),b[i]=read(),c[i]=max(a[i]-b[i],0),rk[i]=i;\n\tsort(rk+1,rk+n+1,cmp);\n\tfor(int i=1;i<=m;++i) ins(read(),read());\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=rk[i];used[x]=1;ll mn=1e18;g[x]=b[x];\n\t\tfor(int j=head[x];j;j=e[j].next) if(used[e[j].to])\n\t\t{\n\t\t\tint y=getfa(e[j].to);\n\t\t\tif(y==x) continue;vis[y]=i;\n\t\t\ts[y]=x;g[x]+=g[y];\n\t\t\tmn=min(mn,max((ll)c[x],f[y])-g[y]);\n\t\t}\n\t\tf[x]=g[x]+(mn>1e17?0:mn);\n\t}\n\tprintf(\"%lld\",f[rk[n]]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define int ll\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nVI e[MAXN];\nint a[MAXN],b[MAXN],f[MAXN],sum[MAXN],vis[MAXN],id[MAXN],ans[MAXN];\nint compare(int x,int y) { return a[id[x]]<a[id[y]]; }\nint find(int x) { return f[x]==x?f[x]:f[x]=find(f[x]); }\nint main()\n{\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,compare);\n\tfor (int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].PB(v),e[v].PB(u);\n\tfor (int i=1;i<=n;i++) f[i]=i;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tVI to; int x=id[i];\n\t\tvis[x]=1,sum[x]=b[x];\n\t\tfor (auto v:e[x])\n\t\t{\n\t\t\tif (!vis[v]||find(x)==find(v)) continue;\n\t\t\tto.PB(find(v));\n\t\t\tsum[x]+=sum[find(v)];\n\t\t\tf[find(v)]=x;\n\t\t}\n\t\tans[x]=sum[x]+a[x];\n\t\tfor (auto v:to) ans[x]=min(ans[x],sum[x]-sum[v]+max(a[x],ans[v]));\n\t}\n\tprintf(\"%d\\n\",ans[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        if (aa.first - aa.second == bb.first - bb.second)\n        {\n            if (abs(aa.first - a[v]) < abs(bb.first - a[v]))\n            {\n                return aa.first < bb.first;\n            }\n            return abs(aa.first - a[v]) < abs(bb.first - a[v]);\n        }\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int maxn=1e5+7;\nbool vis[maxn];\nint a[maxn],b[maxn],p[maxn],fa[maxn];\nll c[maxn];\nll dp[maxn],sum[maxn];\nstruct Edge{\n\tint nxt,to;\n}G[maxn<<1],T[maxn<<1];\nint bG=0,hG[maxn],bT=0,hT[maxn<<1];\nvoid addG(int x,int y){\n\tG[bG].nxt=hG[x];G[bG].to=y;hG[x]=bG++;\n\tG[bG].nxt=hG[y];G[bG].to=x;hG[y]=bG++;\n}\nvoid addT(int x,int y){\n\tT[bT].nxt=hT[x];T[bT].to=y;hT[x]=bT++;\n\tT[bT].nxt=hT[y];T[bT].to=x;hT[y]=bT++;\n}\nbool cmp(int x,int y){\n\treturn c[x]<c[y];\n}\nvoid dfs(int v,int p){\n\tsum[v]=b[v];\n\tfor (int i=hT[v];i!=-1;i=T[i].nxt){\n\t\tint u=T[i].to;\n\t\tif (u==p) continue;\n\t\tdfs(u,v);\n\t\tsum[v]+=sum[u];\n\t}\n\tdp[v]=sum[v]+c[v];\n\tfor (int i=hT[v];i!=-1;i=T[i].nxt){\n\t\tint u=T[i].to;\n\t\tif (u==p) continue;\n\t\tdp[v]=min(dp[v],sum[v]-sum[u]+max(dp[u],c[v]));\n\t}\n}\nint Get(int x){\n\tif (fa[x]==x) return x;\n\tfa[x]=Get(fa[x]);return fa[x];\n}\nint main(){\n\tfreopen(\"xxjac.in\",\"r\",stdin);\n\tmemset(hG,-1,sizeof(hG));\n\tmemset(hT,-1,sizeof(hT));\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tc[i]=max(a[i]-b[i],0);\n\t\tp[i]=i;fa[i]=i;\n\t}\n\tfor (int i=0;i<m;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);u--;v--;addG(u,v);\n\t}\n\tsort(p,p+n,cmp);\n\tfor (int i=0;i<n;i++){\n\t\tint v=p[i];\n\t\tvis[v]=true;\n\t\tfor (int e=hG[v];e!=-1;e=G[e].nxt){\n\t\t\tint u=G[e].to;\n\t\t\tint fu=Get(u);\n\t\t\tif (vis[u] && v!=fu){\n\t\t\t\tfa[fu]=v;\n\t\t\t\taddT(fu,v);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(p[n-1],-1);\n\tprintf(\"%lld\\n\",dp[p[n-1]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (a[v] - b[v] >= cp[i].first - cp[i].second)\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tll bsum = 0;\n\tREP(i, n) bsum += b[i];\n\n\tauto check = [&](int w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<ll> sum(n);\n\t\tREP(i, n) sum[i] = b[i];\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tll nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tif (nowsum < nowP.first) break;\n\t\t\t\tint now = nowP.second;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (!uf.same(start, now)) {\n\t\t\t\t\tll t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tif (uf.size(start) == n) return true;\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + sum[uf.find(start)];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if (!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uf.size(0) == n;\n\t};\n\n\tint l = -1, r = INFINT_LIM - 1;\n\twhile (r - l > 1) {\n\t\tint m = ((ll)l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\tOUT(r + bsum)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            if (S[top[uf.find(to)]] <= S[i] and not uf.same(to, i)) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    assert(uf.getSize(0) == N);\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        for (const int to : T[v]) {\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    int r = -1;\n    for (int i = 0; i < N; i++) {\n        if (T.rev_edge[i].empty()) { r = i; }\n    }\n    assert(r >= 0);\n    dfs(dfs, r);\n    std::cout << f[r] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n      \n      if(q.empty()){\n\tfor(Int i=0;i<n;i++) if(used[i]) push(i);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=s+*min_element(a.begin(),a.end())-1;\n  Int r=s+*max_element(a.begin(),a.end())+;\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\n\nconst int N = 1e6 + 5;\n\n/***************************************************************************/\n\nint A[N], B[N];\nvector<int> adj[N];\nvector<pii> ord;\n\nint par[N];\nll summ[N], DP[N];\n\nint find(int i) {\n\tif(par[i] != i) par[i] = find(par[i]);\n\treturn par[i];\n} \n\nvoid Union(int a, int b) {\n\ta = find(a), b = find(b);\n\tif(a == b) return;\n\tpar[b] = a;\n}\n\nset<int> S;\nint done[N];\n\nint main() {\n\n\tboost;\n\tint n, m; cin>>n>>m;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>A[i]>>B[i];\n\t\tord.push_back(pii(max(A[i]-B[i], 0), i));\n\t\tpar[i] = i;\n\t}\n\tfor(int i=1; i<=m; i++) {\n\t\tint a, b; cin>>a>>b;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\tsort(ord.begin(), ord.end());\n\n\tint v;\n\tfor(auto vv : ord) {\n\t\tv = vv.se;\n\t\tdone[v] = 1;\n\n\t\tS.clear();\n\t\tfor(auto it : adj[v]) if(done[it]) S.insert(find(it));\n\n\t\tsumm[v] = B[v];\n\t\tfor(auto it : S) summ[v] += summ[it];\n\n\t\tDP[v] = summ[v] + vv.fi;\n\t\tfor(auto it : S) {\n\t\t\tDP[v] = min(DP[v], summ[v]-summ[it] + max(ll(vv.fi), DP[it]));\n\t\t\tUnion(v, it);\n\t\t}\n\t}\n\n\tcout<<DP[v]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n    using namespace std;\n    vector<vector<int> > data;\n    vector<int> cst, pay;\n    vector<bool> used;\n    long long solve(int v){\n        set<pair<int, int> > sums;\n        fill(used.begin(), used.end(), false);\n        long long S = 0;\n        sums.insert({cst[v], v});\n        used[v] = true;\n        for (int i=0; i < data.size(); i++){\n            S = max(S, (long long) (*sums.begin()).first);\n            pair<int, int> p = *sums.begin();\n            sums.erase(sums.begin());\n            S += (long long) pay[p.second];\n            for (int j=0; j < data[p.second].size(); j++){\n                int to = data[p.second][j];\n                if (used[to]) continue;\n                sums.insert({cst[to], to});\n                used[to] = true;\n            }\n        }\n        return S;\n     \n    }\n    signed main()\n    {\n        int n, m;\n       // freopen(\"1.txt\", \"r\", stdin);\n        cin >> n >> m;\n        for (int i=0; i < n; i++){\n            data.push_back({});\n            int a, b;\n            cin >> a >> b;\n            cst.push_back(a-b);\n            pay.push_back(b);\n            used.push_back(false);\n        }\n        for (int i=0; i < m; i++){\n            int a, b;\n            cin >> a >> b;\n            data[a-1].push_back(b-1);\n            data[b-1].push_back(a-1);\n        }\n        long long ans = 1e18;\n        while (clock()<=1.7*CLOCKS_PER_SEC){\n            int vrt = rand() % n;\n            ans = min(ans, solve(vrt));\n        }\n        cout << ans << endl;\n        return 0;\n    }\n     \n    //delta + S >= A-B"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 100010>\nstruct UF{\n\tint par[N],r[N];\n\tll sum[N];\n\tpriority_queue<P> *que[N];\n\tUF(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tvoid init(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tif(que[i] != nullptr)delete que[i];\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unit_(int x,int y){\n\t\tpar[x] = y;\n\t\tsum[y] += sum[x];\n\t\tif(que[x]->size() < que[y]->size()){\n\t\t\twhile(!que[x]->empty()){\n\t\t\t\tP p = que[x]->top(); que[x]->pop();\n\t\t\t\tque[y]->push(p);\n\t\t\t}\n\t\t\tdelete que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\telse {\n\t\t\twhile(!que[y]->empty()){\n\t\t\t\tP p = que[y]->top(); que[y]->pop();\n\t\t\t\tque[x]->push(p);\n\t\t\t}\n\t\t\tdelete que[y];\n\t\t\tque[y] = que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\tif(r[x] == r[y])r[y] ++;\n\t}\n\tvoid unit(int x,int y){\n\t\tif(same(x,y))return;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(r[x] < r[y]){\n\t\t\tunit_(x,y);\n\t\t}\n\t\telse {\n\t\t\tunit_(y,x);\n\t\t}\n\t}\n\tvoid run(int v,int w){\n\t\twhile(1){\n\t\t\tv = find(v);\n\t\t\tif(que[v]->empty())break;\n\t\t\tP p = que[v]->top();\n\t\t\tif(find(p.sc) == v)que[v]->pop();\n\t\t\telse if(p.fr+sum[v]+w >= 0){\n\t\t\t\tque[v]->pop();\n\t\t\t\tunit(v,p.sc);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n};\n\nUF<100010> uf;\n\nint main(){\n\tstatic int n,m;\n\tstatic int a[100010],b[100010];\n\tstatic int u[100010],v[100010];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tfor(int i = 0 ; i < m ; i ++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tu[i] --;\n\t\tv[i] --;\n\t}\n\t\n\tif(n == 1){\n\t\tcout << max( a[i] , b[i] ) << endl;\n\t\treturn 0;\n\t}\n\t\n\tll l = 0, r = 1000000000;\n\twhile(l<r){\n\t\tint mi = (l+r)/2;\n\t\tuf.init();\n\t\tfor(int i = 0 ; i < m ; i ++){\n\t\t\tuf.que[u[i]]->push(P(b[v[i]]-a[v[i]],v[i]));\n\t\t\tuf.que[v[i]]->push(P(b[u[i]]-a[u[i]],u[i]));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tuf.sum[i] = b[i];\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tif(a[i] <= b[i]+mi)uf.run(i,mi);\n\t\t}\n\t\tint root = uf.find(0);\n\t\tbool ok = true;\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tok &= uf.find(i) == root;\n\t\t}\n\t\tif(ok)r = mi;\n\t\telse l = mi+1;\n\t}\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tl += b[i];\n\t}\n\tcout << l << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma G++ optimize(2)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define LL long long\n#define O4 __inline__ __attribute__((always_inline))\n#define inf 0x7fffffff\n#define UL unsigned LL\n#define LD long double\n#ifdef ONLINE_JUDGE\n#define getchar nc\n#endif\n#define int LL\nnamespace FastIO{\n\tO4 char nc(){\n\t\tstatic char buf[100000],*p1=buf,*p2=buf;\n\t\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n\t}\n\tO4 int read(){\n\t\tchar t;int u=0,k=1;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\treturn u*k;\n\t}\n\ttemplate <typename T>\n\tO4 void read(T &u){\n\t\tchar t;T k=1;u=0;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\tif(t=='.'){\n\t\t\tT mass=0.1;t=getchar();\n\t\t\twhile(t>='0'&&t<='9'){u+=mass*(t-'0');mass/=10;t=getchar();}\n\t\t}u*=k;\n\t}\n\tO4 int read(char asd[]){\n\t\tchar t=getchar();int u=0;\n\t\twhile(t==' '||t=='\\n'||t=='\\r')t=getchar();\n\t\tif(t==EOF)return -1;\n\t\twhile(t!=' '&&t!='\\n'&&t!=EOF&&t!='\\r')asd[u++]=t,t=getchar();\n\t\tasd[u]='\\0';return u;\n\t}\n\tchar sr[1<<23],z[23];int C=-1,Z;\n\tO4 void wer(int x,char T){\n\t\tint y=0;if(x<0)y=1,x=-x;\n\t\twhile(z[++Z]=x%10+'0',x/=10);if(y)z[++Z]='-';\n\t\twhile(sr[++C]=z[Z],--Z);sr[++C]=T;\n\t}\n\tO4 void wer(char T[],char QWQ){\n\t\tfor(int i=0;T[i]!='\\0';i++)sr[++C]=T[i];\n\t\tsr[++C]=QWQ;\n\t}\n\tO4 void wer(char T){sr[++C]=T;}\n\tO4 void out(){fwrite(sr,1,C+1,stdout);C=-1;}\n}\nusing namespace std;\nusing namespace FastIO;\nconst int N=1e5+5;\nint n,m;\nint val[N],sum[N],A[N],B[N],fa[N],id[N],F[N];\nbool vis[N];\nvector <int> Map[N];\nint get_fa(int x){return fa[x]==x?x:fa[x]=get_fa(fa[x]);}\nsigned main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=read();B[i]=read();\n\t\tA[i]=max(A[i]-B[i],0ll);\n\t\tfa[i]=id[i]=i;\n\t}\n\twhile(m--){\n\t\tint a=read(),b=read();\n\t\tMap[a].push_back(b);\n\t\tMap[b].push_back(a);\n\t}\n\tsort(id+1,id+1+n,[](int a,int b){return A[a]<A[b];});\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];sum[x]=B[x];\n\t\tvector <int> load;vis[x]=1;\n\t\tfor(int to:Map[x]){\n\t\t\tif(!vis[to])continue;\n\t\t\tint a=get_fa(x),b=get_fa(to);\n\t\t\tif(a==b)continue;\n\t\t\tload.push_back(b);\n\t\t\tsum[x]+=sum[b];fa[b]=a;\n\t\t}\n\t\tF[x]=sum[x]+A[x];\n\t\tfor(int to:load)F[x]=min(F[x],sum[x]-sum[to]+max(F[to],A[x]));\n\t}\n\tcout<<F[id[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <functional>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst int MAXN = 1e5 + 1;\nint n, m;\nint a[MAXN];\nint b[MAXN];\nvector<int> edge[MAXN];\nint ord[MAXN];\nint par[MAXN];\nint need[MAXN];\nllong cost[MAXN];\nbool visited[MAXN];\nbool ch[MAXN];\n\nint find(int x) {\n    if (par[x]) return par[x] = find(par[x]);\n    return x;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tint x, y;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n        cin >> a[i] >> b[i];\n\t}\n\twhile (m--) {\n        cin >> x >> y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n        ord[i] = i + 1;\n\t}\n\tsort(ord, ord + n, [&](int i, int j) {\n        return a[i] - b[i] < a[j] - b[j];\n    });\n    \n    for (int it = 0; it < n; ++it) {\n        int x = ord[it];\n        visited[x] = 1;\n        vector<int> qs;\n        for (int i : edge[x]) {\n            if (!visited[i]) continue;\n            i = find(i);\n            if (!ch[i]) {\n                qs.push_back(i);\n                ch[i] = 1;\n            }\n        }\n        \n        need[x] = max(a[x] - b[x], 0);\n        cost[x] = b[x];\n        for (int i : qs) {\n            need[x] = min((llong)need[x], max((llong)need[i], a[x] - b[x] - cost[i]));\n            cost[x] += cost[i];\n            par[i] = x;\n            ch[i] = 0;\n        }\n    }\n    \n    int i = find(1);\n    printf(\"%lld\\n\", cost[i] + need[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include<bits/stdc++.h>\n    #define LL long long\n    #define db long double\n     \n    using namespace std;\n    const int N=3e5+10;\n    int rd()\n    {\n    \tint x=0,w=1;char ch=0;\n    \twhile(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    \twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n    \treturn x*w;\n    }\n    int to[N<<1],nt[N<<1],hd[N],tot=1;\n    void adde(int x,int y)\n    {\n    \t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n    \t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n    }\n    int n,m,sq[N],ff[N],st[N],tp;\n    LL a[N],b[N],f[N],g[N];\n    bool vs[N];\n    bool cmp(int aa,int bb){return a[aa]-b[aa]<a[bb]-b[bb];}\n    int findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\n     \n    int main()\n    {\n    \tn=rd(),m=rd();\n    \tfor(int i=1;i<=n;++i) a[i]=rd(),b[i]=rd(),sq[i]=ff[i]=i;\n    \tsort(sq+1,sq+n+1,cmp);\n    \tfor(int i=1;i<=m;++i) adde(rd(),rd());\n    \tfor(int i=1;i<=n;++i)\n    \t{\n    \t\tint x=sq[i];\n    \t\tg[x]=b[x],vs[x]=1;\n    \t\tfor(int j=hd[x];j;j=nt[j])\n    \t\t{\n    \t\t\tint y=findf(to[j]);\n    \t\t\tif(!vs[y]||y==x) continue;\n    \t\t\tff[y]=x,g[x]+=g[y],st[++tp]=y;\n    \t\t}\n    \t\tif(!tp) f[x]=max(a[x],b[x]);\n    \t\telse\n    \t\t{\n    \t\t\tf[x]=1ll<<50;\n    \t\t\twhile(tp)\n    \t\t\t{\n    \t\t\t\tint y=st[tp--];\n    \t\t\t\tf[x]=min(f[x],-g[y]+max(f[y],max(a[x]-b[x],0ll)));\n    \t\t\t}\n    \t\t\tf[x]+=g[x];\n    \t\t}\n    \t}\n    \tprintf(\"%lld\\n\",f[sq[n]]);\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 100005\n#define maxm 5000005\n#define ll long long \nusing namespace std;\n\nint n,m,i,j,k,a[maxn],b[maxn];\nint tot,t[maxm],tl[maxm],tr[maxm];\nint em,e[maxn*2],nx[maxn*2],ls[maxn];\n\nvoid insert(int x,int y){\n\tem++; e[em]=y; nx[em]=ls[x]; ls[x]=em;\n\tem++; e[em]=x; nx[em]=ls[y]; ls[y]=em;\n}\n\nint fa[maxn],rt[maxn]; ll g[maxn];\nint father(int x){return (fa[x]==x)?x:fa[x]=father(fa[x]);}\nint newnode(){tot++,t[tot]=tl[tot]=tr[tot]=0;return tot;}\nint com(int i,int j){\n\tif (i&&j) return (a[i]-b[i]<a[j]-b[j])?i:j;\n\treturn max(i,j);\n}\n\nvoid add(int &x,int l,int r,int p){\n\tif (!x) x=newnode();\n\tif (l==r) {t[x]=l;return;}\n\tint mid=(l+r)>>1;\n\tif (p<=mid) add(tl[x],l,mid,p); \n\telse add(tr[x],mid+1,r,p);\n\tt[x]=com(t[tl[x]],t[tr[x]]);\n}\n\nvoid del(int &x,int l,int r,int p){\n\tif (!x) return;\n\tif (l==r) {t[x]=0;return;}\n\tint mid=(l+r)>>1;\n\tif (p<=mid) del(tl[x],l,mid,p);\n\telse del(tr[x],mid+1,r,p);\n\tt[x]=com(t[tl[x]],t[tr[x]]);\n}\n\nvoid merge(int x,int y,int l,int r){\n\tt[x]=com(t[x],t[y]);\n\tint mid=(l+r)>>1;\n\tif (tl[x]&&tl[y]) merge(tl[x],tl[y],l,mid);\n\telse if (!tl[x]) tl[x]=tl[y];\n\tif (tr[x]&&tr[y]) merge(tr[x],tr[y],mid+1,r);\n\telse if (!tr[x]) tr[x]=tr[y];\n\tif (tl[x]&&t[tl[x]]==0) tl[x]=0;\n\tif (tr[x]&&t[tr[x]]==0) tr[x]=0;\n}\n\nint check(ll mid){\n\ttot=0;\n\tfor(i=1;i<=n;i++) {\n\t\tfa[i]=i,g[i]=b[i],rt[i]=0;\n\t\tfor(j=ls[i];j;j=nx[j]) add(rt[i],1,n,e[j]);\n\t}\n\tfor(i=1;i<=n;i++) if (mid+b[i]>=a[i]){\n\t\tfa[i]=father(i);\n\t\twhile (t[rt[fa[i]]]&&mid+g[fa[i]]+b[t[rt[fa[i]]]]>=a[t[rt[fa[i]]]]){\n\t\t\tj=t[rt[fa[i]]];\n\t\t\tif (father(i)!=father(j)){\n\t\t\t\tmerge(rt[fa[i]],rt[fa[j]],1,n);\n\t\t\t\tg[fa[i]]+=g[fa[j]],fa[fa[j]]=fa[i];\n\t\t\t}\n\t\t\tdel(rt[fa[i]],1,n,j); \n\t\t}\n\t}\n\tint cnt=0;\n\tfor(i=1;i<=n;i++) cnt+=(fa[i]==i);\n\tfor(i=1;i<=n;i++) if (mid+g[father(i)]<a[i]) return 0;\n\treturn cnt==1;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]);\n\tfor(i=1;i<=m;i++) scanf(\"%d%d\",&j,&k),insert(j,k);\n\tll L=0,R=1e9,mid,ans;\n\twhile (L<=R){\n\t\tmid=(L+R)>>1;\n\t\tif (check(mid)) ans=mid,R=mid-1;\n\t\telse L=mid+1;\n\t}\n\tfor(i=1;i<=n;i++) ans+=b[i];\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn=100010;\n\nint n,m,a[maxn],b[maxn],w[maxn],id[maxn],fa[maxn],x[maxn],y[maxn];\nint tot,nex[maxn*5],las[maxn*5],tov[maxn*5];\nlong long f[maxn],siz[maxn];\nbool bz[maxn];\n\nint getfather(int x)\n{\n\tif (fa[x]==x) return x;\n\tfa[x]=getfather(fa[x]);\n\treturn fa[x];\n}\n\nlong long max(long long a,long long b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nvoid insert(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=w[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (w[i]>m) i++;\n\t\twhile (w[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(w[i],w[j]);\n\t\t\tswap(a[i],a[j]);\n\t\t\tswap(b[i],b[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nint main()\n{\n\tfreopen(\"data.in\",\"r\",stdin);\n//\tfreopen(\"data.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tf[i]=a[i];\n\t\tw[i]=max(a[i]-b[i],0);\n\t\tid[i]=i;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tx[id[i]]=w[i];\n\t\ty[id[i]]=b[i];\n\t\tfa[i]=i;\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint xx,yy;\n\t\tscanf(\"%d%d\",&xx,&yy);\n\t\tinsert(xx,yy);\n\t\tinsert(yy,xx);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint s=id[i];\n\t\tbz[s]=true;\n\t\tsiz[s]=b[s];\n\t\tfor (int j=las[s];j;j=nex[j])\n\t\t{\n\t\t\tif (!bz[tov[j]])\n\t\t\t{\n\t\t\t\tint xx=getfather(s);\n\t\t\t\tint yy=getfather(tov[j]);\n\t\t\t\tif (xx!=yy)\n\t\t\t\t{\n\t\t\t\t\tfa[yy]=s;\n\t\t\t\t\tsiz[s]=siz[s]+siz[yy];\n\t\t\t\t\tf[xx]=min(f[xx],max(f[yy],x[xx]-siz[yy]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[getfather(1)]+siz[getfather(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100500\nint vis[N],fa[N],s[N],v[N],n,m,a,b,head[N],cnt,is[N];\nlong long su[N],dp[N];\nstruct edge{int t,next;}ed[N*2];\nvoid adde(int f,int t){ed[++cnt]=(edge){t,head[f]};head[f]=cnt;ed[++cnt]=(edge){f,head[t]};head[t]=cnt;}\nint finds(int x){return fa[x]==x?x:fa[x]=finds(fa[x]);}\npriority_queue<pair<long long,int> > tp;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&s[i],&v[i]),tp.push(make_pair(-s[i]*2000000000ll+v[i],i));\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&a,&b),adde(a,b);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint s1=tp.top().second;tp.pop();dp[s1]=1e17;is[s1]=1;\n\t\tfor(int j=head[s1];j;j=ed[j].next)if(finds(ed[j].t)!=s1&&is[finds(ed[j].t)])vis[finds(ed[j].t)]=1,dp[s1]=min(dp[s1],max(1ll*s[s1],dp[finds(ed[j].t)]+v[s1])-su[finds(ed[j].t)]),su[s1]+=su[finds(ed[j].t)],fa[finds(ed[j].t)]=s1;\n\t\tdp[s1]+=su[s1];su[s1]+=v[s1];\n\t\tdp[s1]=min(dp[s1],max(s[s1],v[s1])+su[s1]-v[s1]);\n\t}\n\tprintf(\"%lld\\n\",dp[finds(1)]);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nstruct node\n{\n\tint x,y,next;\n}e[100010];int len,last[100010];\ninline void ins(int x,int y)\n{\n\tlen++;\n\te[len].x=x;e[len].y=y;\n\te[len].next=last[x];last[x]=len;\n}\nlong long a[100010],b[100010];\nbool cmp(node u,node v){return a[u.x]<a[v.x];}\nint rt,fa[100010];\ninline int findfa(int x)\n{\n\tif(fa[x]!=x)fa[x]=findfa(fa[x]);\n\treturn fa[x];\n}\nlong long uf,tot[100010],s[100010];\ninline void dfs(int x)\n{\n\tfor(int k=last[x];k;k=e[k].next)\n\t{\n\t\tint y=e[k].y;\n\t\ts[y]=max(s[x],a[x]-tot[y]);\n\t\tdfs(y);\n\t}\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read(),m=read();\n    for(int i=1;i<=n;i++){a[i]=read(),b[i]=read();a[i]=max(0LL,a[i]-b[i]),uf+=b[i];}\n    for(int i=1;i<=m;i++)\n    {\n    \tint x=read(),y=read();if(a[x]<a[y])swap(x,y);\n    \te[i].x=x,e[i].y=y;\n    }sort(e+1,e+m+1,cmp);\n    for(int i=1;i<=n;i++)fa[i]=i,tot[i]=b[i];\n    for(int i=1;i<=m;i++)\n    {\n    \tint fx=findfa(e[i].x),fy=findfa(e[i].y);\n    \tif(fx!=fy){fa[fy]=fx,rt=fx,tot[fx]+=tot[fy];ins(fx,fy);}\n    }dfs(rt);\n    long long ans=max(a[1],s[1])+uf;\n    for(int i=2;i<=n;i++)ans=min(ans,max(a[i],s[i])+uf);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,a,b) for(int i=(a),ed=(b);i<=ed;++i)\n#define pb(x) push_back((x))\ninline int read(){\n\tregister int x=0,f=1;register char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n\treturn f?x:-x;\n}\n\nconst int N=1e5+10;\nint n,m,p[N],vis[N],f[N],head[N],num;\ninline int find(int x){return f[x]=f[x]==x?f[x]:find(f[x]);}\nstruct edge{int to,next;}e[N<<1];\ninline void add(int u,int v){e[++num]=(edge){v,head[u]},head[u]=num;}\nvector<int> E[N];\nll dp[N],s[N],a[N],b[N],w[N];\ninline bool cmp_w(const int &a,const int &b){return w[a]<w[b];}\n\ninline void Dfs(int u){\n\ts[u]=b[u];\n\tfor(int v:E[u]){\n\t\tDfs(v);s[u]+=s[v];\n\t}\n\tif(s[u]==b[u]){dp[u]=b[u]+w[u];return;}\n\tfor(int v:E[u]){\n\t\tdp[u]=min(dp[u],s[u]-s[v]+max(w[u],dp[v]));\n\t}\n}\n\nint main(){\n\t//freopen(\"in.in\",\"r\",stdin);\n\tn=read(),m=read();\n\tREP(i,1,n)a[i]=read(),b[i]=read(),w[i]=max(a[i]-b[i],0ll),p[i]=i;\n\tREP(i,1,m){\n\t\tint u=read(),v=read();\n\t\tadd(u,v),add(v,u);\n\t}\n\tREP(i,1,n)f[i]=i;\n\tsort(p+1,p+n+1,cmp_w);\n\tREP(i,1,n){\n\t\tvis[p[i]]=1;\n\t\tfor(int j=head[p[i]];j;j=e[j].next){\n\t\t\tif(!vis[e[j].to])continue;\n\t\t\tint x=find(e[j].to);\n\t\t\tif(x^p[i])f[x]=p[i],E[p[i]].pb(x);\n\t\t}\n\t}\n\tint pa=find(1);\n\tREP(i,1,n)dp[i]=1e18;\n\tDfs(pa);\n\tprintf(\"%lld\\n\",dp[pa]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector<vector<int> > data;\nvector<int> cst, pay;\nvector<bool> used;\nint solve(int v){\n    set<pair<int, int> > sums;\n    fill(used.begin(), used.end(), false);\n    int S = 0;\n    sums.insert({cst[v], v});\n    used[v] = true;\n    for (int i=0; i < data.size(); i++){\n        S = max(S, (*sums.begin()).first);\n        pair<int, int> p = *sums.begin();\n        sums.erase(sums.begin());\n        S += pay[p.second];\n        for (int j=0; j < data[p.second].size(); j++){\n            int to = data[p.second][j];\n            if (used[to]) continue;\n            sums.insert({cst[to], to});\n            used[to] = true;\n        }\n    }\n    return S;\n\n}\nsigned main()\n{\n    int n, m;\n   // freopen(\"1.txt\", \"r\", stdin);\n    cin >> n >> m;\n    for (int i=0; i < n; i++){\n        data.push_back({});\n        int a, b;\n        cin >> a >> b;\n        cst.push_back(a-b);\n        pay.push_back(b);\n        used.push_back(false);\n    }\n    for (int i=0; i < m; i++){\n        int a, b;\n        cin >> a >> b;\n        data[a-1].push_back(b-1);\n        data[b-1].push_back(a-1);\n    }\n    int ans = 1e18;\n    while (clock()<=1.7*CLOCKS_PER_SEC){\n        int vrt = rand() % n;\n        ans = min(ans, solve(vrt));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n//delta + S >= A-B\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#define ll long long\nusing namespace std;\n\nconst int N=100005;\n\nint n,m,x,y,cnt;\nint a[N],b[N],fa[N],id[N],son[N],vis[N];\nll dp[N],sum[N];\nvector<int> lev[N];\n\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\n\nint find(int k){\n\tif (fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\n\nint main(){\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tid[i]=i;\n\t}\n\tfor (i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlev[x].push_back(y);\n\t\tlev[y].push_back(x);\n\t}\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) fa[i]=i;\n\tfor (i=1;i<=n;i++){\n\t\tcnt=0; x=id[i]; vis[x]=1; sum[x]=1ll*b[x];\n\t\tfor (j=0;j<lev[x].size();j++){\n\t\t\ty=lev[x][j];\n\t\t\tif (!vis[y]||find(x)==find(y)) continue;\n\t\t\tson[++cnt]=find(y);\n\t\t\tsum[x]+=1ll*sum[find(y)];\n\t\t\tfa[find(y)]=find(x);\n\t\t}\n\t\tdp[x]=sum[x]+1ll*a[x];\n\t\tfor (j=1;j<=cnt;j++) dp[x]=min(dp[x],sum[x]-sum[son[j]]+max(1ll*a[x],dp[son[j]]));\n\t}\n\tprintf(\"%lld\\n\",dp[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=100005;\nusing namespace std;\nlong long b[N],g[N];\nint n,m,a[N],c[N],no[N],re[N],p[N],f[N],\nto[N*2],hd[N*2],lk[N],cnt;\nbool vis[N];\ninline void add(int u,int v){\n\tto[++cnt]=v,hd[cnt]=lk[u],lk[u]=cnt;\n}int u,v;\nint get(int x){return p[x]?p[x]=get(p[x]):x;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\tscanf(\"%d%lld\",a+i,c+i),\n\tno[i]=i,a[i]-=c[i];\n\tsort(no,no+n,[](int x,int y){\n\t\treturn a[x]<a[y];\n\t});\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)\n\tb[i]=c[no[i]],re[no[i]]=i,g[i]=max(a[i],0);\n\tfor(;m--;)\n\tscanf(\"%d%d\",&u,&v),\n\tu=re[u-1],v=re[v-1],\n\tadd(u,v),add(v,u);\n\tfor(int i=0,j,s;i<n;i++){\n\t\tvis[i]=1;\n\t\tfor(j=lk[i];j;j=hd[j])\n\t\tif(vis[s=to[j]]){\n\t\t\tif((u=get(s))<i)\n\t\t\tf[u]=p[u]=i,g[i]=1e18;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(i<n-1)b[f[i]]+=b[i];\n\t\tg[f[i]]=min(g[f[i]],max(a[f[i]]-b[i],g[i]));\n\t}\n\tprintf(\"%lld\",g[n-1]+b[n-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 5;\n\n\tint n, m, A[N], B[N], C[N], Fa[N], P[N], Vis[N];\n\tll F[N], Sum[N];\n\tvector<int> E[N], T[N];\n\n\tbool cmp(const int a, const int b) { return C[a] < C[b]; }\n\n\tint find(const int a) { return a == Fa[a] ? a : Fa[a] = find(Fa[a]); }\n\n\tvoid dfs(const int u)\n\t{\n\t\tSum[u] = B[u];\n\t\tfor (int v : T[u])\n\t\t{\n\t\t\tdfs(v);\n\t\t\tSum[u] += Sum[v];\n\t\t}\n\t\tif (!T[u].size())\n\t\t\tF[u] = C[u] + B[u];\n\t\telse \n\t\t{\n\t\t\tF[u] = LLONG_MAX;\n\t\t\tfor (int v : T[u])\n\t\t\t\tF[u] = min(F[u], max(F[v], (ll)C[u]) + Sum[u] - Sum[v]); \n\t\t}\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\t\tC[i] = max(A[i] - B[i], 0);\n\t\t\tP[i] = Fa[i] = i;\n\t\t}\n\t\tfor (int i = 1, u, v; i <= m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tE[u].push_back(v);\n\t\t\tE[v].push_back(u);\n\t\t}\n\t\tsort(P + 1, P + 1 + n, cmp);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tint u = P[i], f;\n\t\t\tVis[u] = 1;\n\t\t\tfor (int v : E[u])\n\t\t\t\tif (Vis[v] && (f = find(v))\t!= u)\n\t\t\t\t{\n\t\t\t\t\tFa[f] = u;\n\t\t\t\t\tT[u].push_back(f);\n\t\t\t\t}\n\t\t}\n\t\tdfs(P[n]);\n\t\tprintf(\"%lld\\n\", F[P[n]]);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i)\n    cin >> a[i] >> b[i];\n  vector<vector<int>> g(n);\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    --u; --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  vector<pair<int, int>> vertex(n);\n  for (int i = 0; i < n; ++i)\n    vertex[i] = make_pair(a[i] - b[i], i);\n  sort(vertex.begin(), vertex.end());\n  vector<int> f(n, -1), dp(n);\n  vector<ll> s(n);\n  function<int(int)> find = [&](int x) { return f[x] == x ? x : f[x] = find(f[x]); };\n  for (int i = 0; i < n; ++i) {\n    int u = vertex[i].second;\n    dp[u] = max(a[u] - b[u], 0);\n    f[u] = u;\n    s[u] = b[u];\n    for (int v : g[u]) {\n      if (f[v] == -1) continue;\n      int x = find(v);\n      if (x == u) continue;\n      f[x] = u;\n      s[u] += s[x];\n      dp[u] = min((ll)dp[u], max((ll)dp[x], a[u] - b[u] - s[x]));\n    }\n    if (i == n - 1) {\n      cerr << s[u] << '\\n';\n      cout << (dp[u] + s[u]);\n    }\n  }\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<ll> vll;\ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 1e5 + 41;\nint const INF = 1e9 + 41;\n\nint n, m;\nint a[MAX];\nint b[MAX];\nint per[MAX];\nvi e[MAX];\n\nll sumb, ans;\n\nbool cmp(int x, int y) {\n\treturn b[x] > b[y];\t\n}\n\nint par[MAX];\n\nvoid init() {\n\tfi(1, n) {\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool uni(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) return false;\n\tpar[b] = a;\n\treturn true;\n}\n\nbool can(int h) {\n\tfi(1, n) {\n\t\tint root = per[i];\n\t\tif (b[root] + h < a[root]) continue;\n\t\tll sum = b[root] + h;\n\t\tinit();\n\t\tset<pii> t;\n\t\tint q = 1;\n\t\tfor (int y : e[root]) {\n\t\t\tt.insert(mp(a[y] - b[y], y));\n\t\t}\t\t\n\t\twhile (q < n) {\n\t\t\tif (!sz(t)) break;\n\t\t\tpii cur = (*t.begin());\n\t\t\tt.erase(t.begin());\n\t\t\tif (cur.first > sum) break;\n\t\t\tint x = cur.second;\n\t\t\tif (!uni(root, x)) continue;\n\t\t\tq++;\n\t\t\tsum += b[x];\n\t\t\t//\n\t\t\tif (sum >= INF) return 1;\n\t\t\t//\n\t\t\tfor (int y : e[x]) {\n\t\t\t\tif (find(y) == root) continue;\n\t\t\t\tt.insert(mp(a[y] - b[y], y));\n\t\t\t}\t\t\n\t\t}\n\t\tif (q == n) return true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tfi(1, n) {\n\t\tper[i] = i;\n\t}\n\tsort(per + 1, per + n + 1, cmp);\n\tfi(1, n) {\n\t\tsumb += b[i];\n\t}\n\tint l = -1;\n\tint r = INF;\t\n\t\n\twhile (r - l > 1) {\n\t\tint h = (l + r) / 2;\n\t\tif (can(h)) {\n\t\t\tr = h;\n\t\t} else {\n\t\t\tl = h;\n\t\t}\n\t}\n\tans = r + sumb;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n  scanf(\"%d %d\", &n, &m);\n  fi(1, n) {\n  \tscanf(\"%d %d\", &a[i], &b[i]);\n  }\n  fi(1, m) {\n  \tint x, y;\n  \tscanf(\"%d %d\", &x, &y);\n  \te[x].pb(y);\n  \te[y].pb(x);\n  }\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n/**\n * Currently this design only allows one arena per arena size\n *\n * @tparam SIZE size of arena in bytes, default is 200 MB\n */\ntemplate <size_t SIZE = 200 << 20> class Arena {\n  static char buf[];\n  static size_t buf_ind;\n\n public:\n  template <class T> struct Allocator {\n    typedef T value_type;\n\n    Allocator() {}\n\n    template <class U> Allocator(const U&) {}\n\n    T* allocate(size_t n) {\n      buf_ind -= n * sizeof(T);\n      buf_ind &= 0 - alignof(T);\n      return (T*) (buf + buf_ind);\n    }\n\n    void deallocate(T*, size_t) {}\n  };\n\n  /**\n   * Frees the arena, be very sure no allocation is still used when calling this\n   */\n  static void Clear() {\n    buf_ind = SIZE;\n  }\n};\n\ntemplate <size_t SIZE> char Arena<SIZE>::buf[SIZE];\ntemplate <size_t SIZE> size_t Arena<SIZE>::buf_ind = SIZE;\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll, Alloc<ll>> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, int, int>> pq, bad;// -cost, from, to\n  auto poss = [&](ll rem) {\n    Arena<>::Clear();\n    DisjointSet<Arena<>::Allocator> dsu(n);\n    fill(ALL(vis), false);\n    ll vis_cnt = 0;\n    while (not pq.empty())\n      pq.pop();\n    VEVE(i, 0, n) {\n      dsu.sum[i] = recv[i];\n      if (need[i] <= rem) {\n        vis[i] = true;\n        ++vis_cnt;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    if (vis_cnt == n)\n      return true;\n    while (true) {\n      bool changed = false;\n      while (not bad.empty())\n        bad.pop();\n      while (not pq.empty()) {\n        ll cost;\n        int fr, to;\n        tie(cost, fr, to) = pq.top();\n        pq.pop();\n        cost = -cost;\n        if (dsu.IsSameSet(fr, to))\n          continue;\n        if (dsu.sum[dsu.Find(fr)] + rem >= cost) {\n          dsu.Unite(fr, to);\n          changed = true;\n          if (not vis[to]) {\n            vis[to] = true;\n            if (++vis_cnt == n) {\n              return true;\n            }\n            RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n          }\n        } else {\n          bad.emplace(-cost, fr, to);\n        }\n      }\n      if (not changed)\n        break;\n      pq.swap(bad);\n    }\n    return false;\n  };\n  ll low = *min_element(ALL(need)), hig = *max_element(ALL(need));\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],s[N],q[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR pi p=Q[v].top();Q[v].pop();\n\t\tif(find(p.se)!=find(u))Q[u].push(p);\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n\t\t\tif(s[u]+s[p.se]>=mx)return true;\n\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,merge(u,p.se);\n\t\t}\n\t}\n\tR int rt=find(1);\n\tfp(i,2,n)if(find(i)!=rt)return false;\n\treturn true;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst int M = 2e5 + 5;\n\nint fir[N] , ne[M] , to[M] , cnt , x , y , A[N] , B[N] , fa[N] , id[N] , n , m;\nlong long S[N] , More[N];\n\nvoid add(int x , int y) {\n  ne[++ cnt] = fir[x];\n  fir[x] = cnt;\n  to[cnt] = y;\n}\n\nvoid link(int x , int y) {\n  add(x , y);\n  add(y , x);\n}\n\n#define Foreachson(i , x) for(int i = fir[x];i;i = ne[i])\n\nint getf(int x) {\n  return (fa[x] == x) ? x : (fa[x] = getf(fa[x]));\n}\n\nbool cmp(int x , int y) {\n  return A[x] < A[y];\n}\n\nbool vis[N];\n\nint main() {\n  scanf(\"%d%d\" , &n , &m);\n  int it = 0;\n  for(int i = 1;i <= n;++ i) {\n    scanf(\"%d%d\" , &A[i] , &B[i]);\n    More[i] = A[i] = max(0 , A[i] - B[i]);\n    fa[i] = id[i] = i;\n    S[i] = B[i];\n  }\n  for(int i = 1;i <= m;++ i) {\n    scanf(\"%d%d\" , &x , &y);\n    link(x , y);\n  }\n  sort(id + 1 , id + n + 1 , cmp);\n  for(int i = 1;i <= n;++ i) {\n    int x = id[i];\n    vis[x] = 1;\n    Foreachson(j , x) {\n      int V = to[j];\n      if(!vis[V])\n\tcontinue;\n      int a = getf(x) , b = getf(V);\n      if(a == b)\n\tcontinue;\n      fa[b] = a; S[a] += S[b];\n      More[a] = min(More[a] , More[b] + max(0LL , A[x] - More[b] - S[b]));\n    }\n  }\n  int now = getf(1);\n  cout << S[now] + More[now] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            const int V = S[top[uf.find(to)]];\n            if (V < S[i]) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    assert(uf.getSize(0) == N);\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        std::set<int> used;\n        for (const int to : T[v]) {\n            assert(used.find(to) == used.end());\n            used.insert(to);\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    int r = -1;\n    for (int i = 0; i < N; i++) {\n        if (T.rev_edge[i].empty()) { r = i; }\n    }\n    assert(r >= 0);\n    dfs(dfs, r);\n    std::cout << f[r] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,b;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  UnionFind(Int sz,vector<Int> b):n(sz),r(sz,1),p(sz,0),b(b){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    b[x]+=b[y];   \n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n  vector<Int> ord(n);\n  iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),\n       [&](Int x,Int y){\n\t return a[x]-b[x]<a[y]-b[y];\n       });\n\n  vector<Int> rev(n);\n  for(Int i=0;i<n;i++) rev[ord[i]]=i;\n\n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  UnionFind uf(n,b);\n  vector<Int> dp(n,0);\n  for(Int v:ord){\n    dp[v]=a[v]-b[v];\n    for(Int t:G[v]){\n      Int u=uf.find(t);\n      if(rev[u]>rev[v]) continue;\n      chmin(dp[v],max(dp[u],a[v]-(uf.b[u]+b[v])));\n    }\n    //cout<<v<<\":\"<<a[v]-b[v]<<\":\"<<dp[v]<<endl;\n    chmax(dp[v],0);\n    for(Int u:G[v])\n      if(rev[u]<rev[v]) uf.unite(v,u);\n  }\n  //cout<<dp[ord[n-1]]<<endl;\n  cout<<s+dp[ord[n-1]]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m;\nint a[maxn],b[maxn],ord[maxn];\nbool ok[maxn],occ[maxn];\nvector<int>edge[maxn],vec[maxn];\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nnamespace Dsu{\n\tint f[maxn],rk[maxn];\n\tll v[maxn]; \n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\trk[i]=1;\n\t\t\tv[i]=b[i];\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(rk[x]>rk[y])swap(x,y);\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t\tif(rk[x]==rk[y])rk[y]++;\n\t}\n}\n\nvoid fix(int x,int y){\n\trep(i,int(vec[x].size())){\n\t\tok[vec[x][i]]=true;\n\t\tint ori=Dsu::find(vec[x][i]);\n\t\tDsu::merge(vec[x][i],y);\n\t\tfix(ori,y);\n\t}\n\tvec[x].clear();\n}\n\nbool check(ll val){\n\tREP(i,n)vec[i].clear(),ok[i]=occ[i]=false;\n\tDsu::init();\n\tREP(i,n){\n\t\tint x=ord[i];\n\t\tocc[x]=true;\n\t\tif(val+b[x]>=a[x])ok[x]=true;\n\t\trep(j,int(edge[x].size())){\n\t\t\tint y=edge[x][j];\n\t\t\tif(!occ[y])continue;\n\t\t\tll nowx=Dsu::v[Dsu::find(x)]+val;\n\t\t\tll nowy=Dsu::v[Dsu::find(y)]+val;\n\t\t\tif((ok[y]&&nowy+b[x]>=a[x])||(ok[x]&&nowx+b[y]>=a[y])){\n\t\t\t\tok[x]=ok[y]=true;\n\t\t\t\tint orix=Dsu::find(x),oriy=Dsu::find(y);\n\t\t\t\tDsu::merge(x,y);\n\t\t\t\tfix(orix,x);\n\t\t\t\tfix(oriy,y);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvec[Dsu::find(y)].pb(x);\n\t\t\t\tvec[Dsu::find(x)].pb(y);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e9);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 100005;\nint n, m, q[MX], u, v, p[MX];\nll a[MX], b[MX], dp[MX], s[MX];\nvi adj[MX], to[MX];\nint parent (int a) { return p[a] == a ? a : p[a] = parent(p[a]); }\n\nvoid dfs (int u) {\n\tfor (int v : to[u]) dfs(v), s[u] += s[v];\n\ts[u] += b[u], dp[u] = to[u].size() ? 1e18 : a[u] + b[u];\n\tfor (int v : to[u]) dp[u] = min(dp[u], s[u] - s[v] + max(dp[v], a[u]));\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tiota(p, p+MX, 0);\n\tiota(q, q+MX, 1);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i] - b[i], 0ll);\n\t}\n\n\twhile (m--) {\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);\n\t\tadj[v].pb(u);\n\t}\n\n\tsort(q, q+n, [&] (int i, int j) {\n\t\treturn a[i] < a[j];\n\t});\n\n\tfor (int i = 0; i < n; i++) {\n\t\tu = q[i];\n\t\tfor (int v : adj[u]) {\n\t\t\tif (parent(u) == parent(v) || a[u] < a[v]) continue;\n\t\t\tv = parent(v);\n\t\t\tto[u].pb(v);\n\t\t\tp[v] = u;\n\t\t}\n\t}\n\n\tdfs(q[n-1]);\n\tcout << dp[q[n-1]] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <ctime>\n#include <climits>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <set>\nusing namespace std;\nstruct UnionFind {\n    vector<int> par, sz;\n    int n_tree;\n\n    explicit UnionFind(int n) : par(n), sz(n, 1), n_tree(n) { //0-indexed\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int n_cluster() const {\n        return n_tree;\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if (rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool is_root(int x) const {\n        return par[x] == x;\n    }\n};\nint main() {\n#ifdef LOCAL\n    ifstream in(\"in.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //仿tourist的做法\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n    }\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> c(n);\n    iota(c.begin(), c.end(), 0);\n    sort(c.begin(), c.end(), [&](int x, int y) {return a[x] - b[x] < a[y] - b[y]; });\n    vector<long long> sum_b(n);\n    // ans[i]：子树i的最优解\n    vector<bool> done(n, false);\n    vector<long long> ans(n);\n    for (int i = 0; i < n; ++i) {\n        ans[i] = max(a[i], b[i]);\n        sum_b[i] = b[i];\n    }\n    //vector<bool> added(n, false);\n    UnionFind uf(n);\n    for (auto v : c) {\n        set<int> s;\n        for (auto u : g[v]) {\n            if (done[u]) {\n                //并查集用来查找子树的根\n                s.insert(uf.root(u));\n            }\n        }\n        for (auto u : s) {\n            sum_b[v] += sum_b[u];\n            uf.unite(u, v);\n        }\n        //cout << v << ' ' << sum_b[v] << endl;\n        if (!s.empty()) {\n            long long best = LLONG_MAX;\n            for (auto u : s) {\n                long long sum_b_without = sum_b[v] - sum_b[u];\n                long long cur = max(sum_b_without + ans[u], sum_b_without + a[v] - b[v]);\n                best = min(best, cur);\n                uf.unite(u, v);\n            }\n            ans[v] = best;\n        }\n        done[v] = true;\n        //assert(uf.root(v) == v);\n    }\n    //for (int i = 0; i < n; ++i) {\n    //    cout << c[i] << ' ' << sum_b[c[i]] << ' ' << ans[c[i]] << endl;\n    //}\n    cout << ans[c[n - 1]] << '\\n';\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\n\ntypedef long long LL;\n\nint fa[N]; \n\nstruct edge {\n    int to, next;\n} e[N * 2];\n\nint head[N], ecnt;\n\ninline void adde(int from, int to) {\n    e[++ecnt] = (edge){ to, head[from] }, head[from] = ecnt;\n    e[++ecnt] = (edge){ from, head[to] }, head[to] = ecnt;\n}\n\nLL dp[N], a[N], b[N], sum[N];\n\nvoid dfs(int u, int f) {\n    sum[u] = b[u];\n    for (int i = head[u]; i; i = e[i].next)\n        if (e[i].to != f) dfs(e[i].to, u), sum[u] += sum[e[i].to];\n    dp[u] = sum[u] + a[u];\n    for (int i = head[u]; i; i = e[i].next)\n        if (e[i].to != f) dp[u] = min(dp[u], sum[u] - sum[e[i].to] + max(a[u], dp[e[i].to]));\n}\n\nint id[N], vis[N]; vector<int> G[N];\n\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%lld%lld\", &a[i], &b[i]), a[i] = max(0ll, a[i] - b[i]);\n    for (int i = 1; i <= n; i++) id[i] = fa[i] = i;\n    for (int i = 1, a, b; i <= m; i++) scanf(\"%d%d\", &a, &b), G[a].push_back(b), G[b].push_back(a);\n    sort(id + 1, id + n + 1, [](int i, int j) { return a[i] < a[j]; }), vis[id[1]] = 1;\n    for (int i = 2; i <= n; i++) {\n        int u = id[i]; vis[u] = 1;\n        for (auto v : G[u]) if (vis[v]) {\n            if (find(u) == find(v)) continue;\n            adde(find(v), u), fa[find(v)] = u;\n        }\n    }\n    dfs(id[n], 0), printf(\"%lld\\n\", dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nstruct node{\n\tint a,b,id;\n\tbool operator < (node &o){ return a-b<o.a-o.b; }\n}x[N];\nint cur[N],pa[N],n,m,u,v;\nll f[N],s[N]; vi e[N];\n\nint getpa(int x){\n\treturn pa[x]==x?x:pa[x]=getpa(pa[x]);\n}\n\nint main(){\n\tread(n),read(m);\n\trep(i,1,n){\n\t\tread(x[i].a),read(x[i].b);\n\t\tx[i].id=i,x[i].a=max(x[i].a,x[i].b);\n\t}\n\tsort(x+1,x+n+1);\n\trep(i,1,n)cur[x[i].id]=i;\n\trep(i,1,m){\n\t\tread(u),read(v);\n\t\te[cur[u]].pb(cur[v]);\n\t\te[cur[v]].pb(cur[u]);\n\t}\n\trep(i,1,n){\n\t\tpa[i]=i,f[i]=x[i].a,s[i]=x[i].b;\n\t}\n\trep(u,1,n){\n\t\tll mn=max(x[u].a,x[u].b),S=0;\n\t\tfor(auto v:e[u])\n\t\t\tif(v<u&&getpa(u)!=getpa(v)){\n\t\t\t\tmn=min(mn,max((ll)x[u].a,x[u].b+f[getpa(v)])-s[getpa(v)]);\n\t\t\t\tS+=s[getpa(v)];\n\t\t\t\tpa[getpa(v)]=getpa(u);\n\t\t\t}\n\t\ts[getpa(u)]=S+x[u].b;\n\t\tf[getpa(u)]=S+mn;\n\t}\n\tcout<<f[getpa(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nlong long a[100005], b[100005];\nlong long c[100005];\nint order[100005];\nlong long sum[100005], p[100005];\nstd::vector<int>g[100005];\nstd::vector<int>e[100005];\nint vis[100005];\nlong long f[100005];\n\nlong long min(long long a,long long b){ return a>b?b:a; }\n\nlong long max(long long a,long long b){ return a>b?a:b; }\n\nint find(int u){\n    if(p[u]==u) return u;\n    else return p[u] = find(p[u]);\n}\n\nvoid dp(int u){\n    sum[u] = b[u];\n    for(int v: e[u]){\n        dp(v);\n        sum[u] += sum[v];\n    }\n    f[u] = c[u]+sum[u];\n    for(int v: e[u]){\n        f[u] = min(f[u],max(f[v],c[u])+sum[u]-sum[v]);\n    }\n}\n\nint cmp(int a,int b){ return c[a]<c[b]; }\n\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i = 1; i <= n; i++){\n        order[i] = p[i] = i;\n        sum[i] = 0;\n        scanf(\"%lld%lld\",&a[i],&b[i]);\n        c[i] = a[i]-b[i];\n        if(c[i]<0) c[i] = 0;\n    }\n    for(int i = 0; i < m; i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    std::sort(order+1,order+1+n,cmp);\n    for(int i = 1; i <= n; i++){\n        int u = order[i]; \n        vis[u] = 1;\n        for(int v: g[u]){\n            if(vis[v] && find(v)!=u){\n                int root = find(v);\n                p[root] = u;\n                //sum[u] += sum[root];\n                e[u].push_back(root);\n            }\n        }\n    }\n    //printf(\"ok\\n\");\n    int root = find(1);\n    dp(root);\n    printf(\"%lld\\n\",f[root]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll sum[MX];\nint n, m, a[MX], b[MX], p[MX];\nvector<vi> e;\nint root(int x){\n\treturn p[x] == x ? x : (p[x] = root(p[x]));\n}\nvoid merge(int a, int b){\n\ta = root(a); b = root(b);\n\tif(a != b){\n\t\tp[b] = a;\n\t\tsum[a] += sum[b];\n\t}\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m; e.resize(n);\n\trep(i, n) cin >> a[i] >> b[i];\n\trep(i, m){\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\t\n\tif(n == 1){\n\t\tcout << max(a[0], b[0]) << endl;\n\t\treturn 0;\n\t}\n\t\n\tvector<tuple<ll, int, int>> es;\n\trep(i, n) for(int j : e[i]) es.emplace_back(a[j] - b[j] - sum[i], i, j);\n\tsort(all(es));\n\t\n\trep(i, n) p[i] = i, sum[i] = b[i];\n\t\n\tll ans = 0;\n\twhile(es.size()){ //計算量？\n\t\tll mn = 1e18;\n\t\tvector<tuple<ll, int, int>> next;\n\t\tfor(auto i : es){\n\t\t\tll p; int q, r; tie(p, q, r) = i;\n\t\t\tint Q = root(q), R = root(r);\n\t\t\tif(Q == R) continue;\n\t\t\t\n\t\t\tll c = a[r] - b[r] - sum[Q];\n\t\t\tll st = sum[Q] > b[q] ? 0 : a[q] - b[q];\n\t\t\tif(ans >= st && ans >= c){\n\t\t\t\tmerge(q, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext.emplace_back(c, q, r);\n\t\t\t}\n\t\t\tmn = min(mn, max(st, c));\n\t\t}\n\t\tif(mn < 1e18) ans = max(ans, mn);\n\t\tes = next;\n\t\tsort(all(es));\n\t}\n\tcout << ans + sum[root(0)] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n      \n      if(q.empty()){\n\tfor(Int i=0;i<n;i++) if(used[i]) push(i);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=s-1;\n  Int r=1e18;\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (cp[0].first < a[v] - b[v])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nint rt[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nstruct pt{int a,id;}w[MAXN];\nint n,m,A[MAXN],B[MAXN];\nbool cmp(pt n1,pt n2){return n1.a<n2.a;}\nvector<int> vec[MAXN];\nLL sum[MAXN];\nvoid init(int x)\n{\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)init(a[k].y),sum[x]+=sum[a[k].y];\n}\nLL ans;\nvoid cal(int x,LL ls1,LL ls2)//留下来的速度  上面会用掉的速度 \n{\n\tif(x==10)\n\t{\n\t\tint gg;\n\t\tgg++;\n\t}\n\tLL down=sum[x]-B[x];//不考虑我走完要多少速度 \n\tLL nx=max(ls1,(LL)max(A[x],B[x]));\n\tLL canuse=min(down,nx-max(A[x],B[x]));//可以提供给子树的 \n\tans=min(ans,nx-ls1+down-canuse+ls2);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tcal(y,nx-B[x]-min(canuse,down-sum[y]),down-sum[y]+ls2+nx-ls1-min(canuse,down-sum[y]));\n\t}\n}\nint ri[MAXN];\nbool is[MAXN];\nint main()\n{\n//\tfreopen(\"subtask_1_09.in\",\"r\",stdin);\n//\tfreopen(\"rescue.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)w[i].a=A[i]=read(),B[i]=read(),w[i].id=i;\n\tsort(w+1,w+1+n,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(y);vec[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tis[w[i].id]=true; \n\t\tfor(int j=0;j<vec[w[i].id].size();j++)\n\t\t{\n\t\t\tint x=vec[w[i].id][j];\n\t\t\tint p=findrt(w[i].id),q=findrt(x);\n\t\t\tif(p!=q&&is[q])ins(w[i].id,q),ri[q]++,rt[q]=p;\n\t\t}\n\t}\n//\tfor(int i=1;i<=len;i++)printf(\"YES %d %d\\n\",a[i].x,a[i].y);\n//\tfor(int i=1;i<=n;i++)pr1(A[i]),pr2(B[i]);\n\tint root;\n\tfor(int i=1;i<=n;i++)if(!ri[i])root=i;\n\tinit(root);\n\tans=(1LL<<63-1);\n\tcal(root,0,0);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 101000\nusing namespace std;\nstruct point{\n\tint a, b, num;\n\tbool operator<(const point &p)const {\n\t\treturn a != p.a?a<p.a:b>p.b;\n\t}\n}w[N_];\nint A[N_], B[N_];\nvector<int>E[N_];\nlong long SB[N_], M[N_], mmm;\nint UF[N_], chk[N_];\nint n, m, v[N_];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nstruct TT {\n\tlong long sb, m;\n\tbool operator <(const TT &p)const {\n\t\treturn sb - m < p.sb - p.m;\n\t}\n};\nlong long G[N_], BB[N_], EE[N_];\nvoid Go(int a, vector<int> &T) {\n\tchk[a] = 1;\n\tif (T.empty()) {\n\t\tSB[a] = B[a];\n\t\tM[a] = max(A[a], B[a]);\n\t\treturn;\n\t}\n\tint sz = T.size();\n\tvector<TT> U(sz);\n\tmmm = A[a];\n\tint c = 0;\n\tfor (auto &t : T) {\n\t\tUF[t] = a;\n\t\tU[c++] = { SB[t], M[t] };\n\t}\n\tsort(U.begin(), U.end());\n\tlong long mm = 0, sb = 0;\n\tint i;\n\tfor (i = 0; i < sz; i++) {\n\t\tmm = max(mm, sb + U[i].m);\n\t\tG[i] = sb + U[i].m;\n\t\tsb += U[i].sb;\n\t}\n\tmm = max(mm, sb + max(A[a], B[a]));\n\tfor (i = 0; i < sz; i++) {\n\t\tif (i == 0 || G[i] > BB[i - 1])BB[i] = G[i];\n\t\telse BB[i] = BB[i - 1];\n\t}\n\tfor (i = sz - 1; i >= 0; i--) {\n\t\tif (i == sz - 1 || G[i] > EE[i + 1])EE[i] = G[i];\n\t\telse EE[i] = EE[i + 1];\n\t}\n \n\tfor (i = 0; i < sz; i++) {\n\t\tlong long t = sb - U[i].sb + B[a] + U[i].m;\n\t\tt = max(t, sb - U[i].sb + max(A[a], B[a]));\n\t\tif (i != 0)t = max(t, BB[i - 1]);\n\t\tif (i != sz - 1)t = max(t, EE[i + 1] - U[i].sb);\n\t\tmm = min(mm, t);\n\t}\n \n\tsb += B[a];\n\tM[a] = mm;\n\tSB[a] = sb;\n}\nint main() {\n\tint i, a, b;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &w[i].a, &w[i].b);\n\t\tA[i] = w[i].a, B[i] = w[i].b;\n\t\tUF[i] = i;\n\t\tw[i].num = i;\n\t}\n\tsort(w + 1, w + n + 1);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint a = w[i].num;\n\t\tvector<int>T;\n\t\tfor (auto &x : E[a]) {\n\t\t\tif (!chk[x])continue;\n\t\t\tint t = Find(x);\n\t\t\tif (!v[t]) {\n\t\t\t\tT.push_back(t);\n\t\t\t\tv[t] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : T)v[t] = 0;\n\t\tGo(a, T);\n\t}\n\tprintf(\"%lld\\n\",M[w[n].num]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint a[N],b[N],n,m,vis[N],fa[N],c[N];\ntypedef long long ll;\nvector<int>g[N];\nll sum[N],mn[N];\nbool cmp(const int&x,const int&y){\n\tif(a[x]!=a[y])return a[x]<a[y];\n\treturn b[x]<b[y];\n}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i){cin>>a[i]>>b[i];c[i]=i;}\n\tsort(c+1,c+n+1,cmp);\n\tfor(int i=1;i<=m;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg[x].push_back(y);g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;++i)fa[i]=i;//,sort(g[i].begin(),g[i].end(),cmp);\n\tfor(int i=1;i<=n;++i){\n\t\tint u=c[i];sum[u]=b[u];mn[u]=max(0,a[u]-b[u]);\n\t\tvis[u]=1;\n\t\tfor(int j:g[u])if(vis[j]){\n\t\t\tint v=find(j);if(u==v)continue;\n\t\t\tsum[u]+=sum[v];mn[u]=min(mn[u],max(a[u]-sum[v]-b[u],mn[v]));\n\t\t\tfa[v]=u;\n\t\t}\n\t}\n\tcout<<sum[c[n]]+mn[c[n]]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, m, a[MAXN], b[MAXN], sec[MAXN];\nvector<int> adj[MAXN];\nint par[MAXN];\nll ans[MAXN], sumB[MAXN];\npair<ll, ll> gec[MAXN];\n\nbool cmp(int u, int v){return a[u]-b[u] < a[v]-b[v];}\n\nint getPar(int v){return par[v]==v? v: par[v]=getPar(par[v]);}\n\nbool mark[MAXN];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> a[i] >> b[i], a[i] = max(a[i], b[i]);\n\twhile (m--){\n\t\tint u, v; cin >> u >> v, u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tiota(sec, sec + n, 0);\n\tsort(sec, sec + n, cmp);\n\n\tiota(par, par + n, 0);\n\tfor (int i = 0; i < n; i++){\n\t\tint v = sec[i];\n\t\tmark[v] = true;\n\t\tsumB[v] = b[v];\n\n\t\tint tt = 0;\n\t\tfor (int u:adj[v]){\n\t\t\tif (!mark[u]) continue;\n\t\t\tint pu = getPar(u);\n\t\t\tif (pu == v) continue;\n\n\t\t\tgec[tt++] = {ans[pu], sumB[pu]};\n\t\t\tpar[pu] = v;\n\t\t\tsumB[v] += sumB[pu];\n\t\t}\n\n\t\tans[v] = sumB[v] + (a[v] - b[v]);\n\t\tfor (int j = 0; j < tt; j++){\n\t\t\tauto x = gec[j];\n\t\t\tans[v] = min(ans[v], max((ll)a[v], x.F+b[v]) + (sumB[v] - b[v] - x.S));\n\t\t}\n\t}\n\n\tcout << ans[sec[n-1]] << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5+10;\n\nint n, m, a[maxn], b[maxn], p[maxn];\nvector<int> to[maxn];\n\nbool cmd(int i, int j) { return a[i]-b[i] < a[j]-b[j]; }\n\nint f[maxn];\nlong long B[maxn], w[maxn];\nint find(int x) { return f[x]>0?f[x]=find(f[x]):x; }\n\nbool vis[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d\", a+i, b+i);\n\t\tB[i] = b[i];\n\t\tp[i] = i;\n\t}\n\tint u, v;\n\tfor (int j = 1; j <= m; ++j) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tto[u].push_back(v);\n\t\tto[v].push_back(u);\n\t}\n\tsort(p+1, p+1+n, cmd);\n\tfor (int _ = 1; _ <= n; ++_) {\n\t\tint i = p[_];\n//\t\tprintf(\"%d: %d\\n\", i, a[i]-b[i]);\n\t\tw[i] = max(0, a[i]-b[i]);\n\t\tfor (auto __: to[i]) if (vis[__]) {\n\t\t\tint j = find(__);\n\t\t\tif (j == i) continue;\n\t\t\tif (B[j]+w[j] >= a[i]-b[i]) w[i] = min(w[i], w[j]);\n\t\t\telse w[i] = min(w[i], (a[i]-b[i])-B[j]);\n\t\t\tB[i] += B[j];\n\t\t\tf[j] = i;\n\t\t}\n\t\tvis[i] = 1;\n//\t\tprintf(\"%d: B=%d w=%d\\n\", i, B[i], w[i]);\n\t}\n\tcout << w[p[n]]+B[p[n]] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nusing int64 = long long;\nconst int64 INF = 1LL << 60;\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    //if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main() {\n  int N, M;\n  int A[100000], B[100000];\n  vector< int > g[100000];\n\n  cin >> N >> M;\n  vector< pair< int64, int > > ord(N);\n  for(int i = 0; i < N; i++) {\n    cin >> A[i] >> B[i];\n    ord[i] = {max(A[i] - B[i], 0), i};\n  }\n  sort(begin(ord), end(ord));\n  for(int i = 0; i < M; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x, --y;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  UnionFind uf(N);\n  vector< int64 > dp(N, INF);\n  vector< int64 > dp2(N);\n  for(auto &p : ord) {\n    int64 need;\n    int to;\n    tie(need, to) = p;\n    int64 all = 0;\n    vector< int64 > f;\n    for(auto &from : g[to]) {\n      from = uf.find(from);\n      if(dp[from] == INF) {\n        continue;\n      }\n      if(to != from) {\n        f.emplace_back(from);\n        all += dp2[from];\n        dp2[to] += dp2[from];\n        uf.unite(to, from);\n      }\n    }\n    dp[to] = INF;\n    if(f.empty()) {\n      dp[to] = need + B[to];\n    }\n    for(auto &from : f) {\n      dp[to] = min(dp[to], dp[from] + B[to] + max(0LL, need - dp[from]) + all - dp2[from]);\n    }\n    dp2[to] += B[to];\n  }\n  cout << *max_element(begin(dp), end(dp)) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 100005;\nint n, m, q[MX], u, v, p[MX];\nll a[MX], b[MX], dp[MX], s[MX];\nvi adj[MX], to[MX];\nint parent (int a) { return p[a] == a ? a : p[a] = parent(p[a]); }\n\nvoid dfs (int u) {\n\tfor (int v : to[u]) dfs(v), s[u] += s[v];\n\ts[u] += b[u], dp[u] = to[u].size() ? 1e18 : a[u] + b[u];\n\tfor (int v : to[u]) dp[u] = min(dp[u], s[u] - s[v] + max(dp[v], a[u]));\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tiota(p, p+MX, 0);\n\tiota(q, q+MX, 1);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i] - b[i], 0ll);\n\t}\n\n\twhile (m--) {\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);\n\t\tadj[v].pb(u);\n\t}\n\n\tsort(q, q+n, [&] (int i, int j) {\n\t\treturn a[i] < a[j];\n\t});\n\n\tfor (int i = 0; i < n; i++) {\n\t\tu = q[i];\n\t\tfor (int v : adj[u]) {\n\t\t\tv = parent(v);\n\t\t\tif (u == v || a[u] < a[v]) continue;\n\t\t\tto[u].pb(v);\n\t\t\tp[v] = u;\n\t\t}\n\t}\n\n\tdfs(q[n-1]);\n\tcout << dp[q[n-1]] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) const {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    friend bool operator< (Info a , Info b)  {return a.cost < b.cost;}\n};\n\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n}\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) \n                unlock(y);\n            else\n                out[p].insert(y);  \n        }\n    }\n    x = find(x);\n    while(out[x].size()) {\n        int t = *out[x].begin();\n        if(find(t) == x) {\n            out[x].erase(out[x].begin());\n            continue;\n        }\n        if(money[x] + init >= limit[t]) {\n            out[x].erase(out[x].begin());\n            unlock(t);\n            x = find(x);\n            continue;\n        }\n        modifycost(t , (int)max(limit[t] - money[x] , 0LL));\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,A[MN],B[MN],id[MN],par[MN];\nll f[MN],sz[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(int x,int y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&C[y]<=C[x]) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%d\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define double long double\n    const int INF=0x3f3f3f3f;\n    const ll LLINF=0x3f3f3f3f3f3f3f3fll;\n    ll qread()\n    {\n        ll ans=0;char c=getchar();int f=1;\n        while(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) {num=-num;putchar('-');}\n        if(num>9) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);puts(\"\");}\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define pr pair<int,int>\n    #define PB push_back\n    #define vc vector\n    void chmax(ll &x,const ll y) {x=x>y?x:y;}\n    void chmin(ll &x,const ll y) {x=x<y?x:y;}\n    const int MAX_N=1e5+10;\n    const ll MOD=998244353;\n\t\n\tstruct DSU\n\t{\n\t\tint fa[MAX_N];DSU(){memset(fa,0,sizeof fa);}\n\t\tint findfa(int x){return x==fa[x]?x:findfa(fa[x]);}\n\t}dsu;\n\tll b[MAX_N];int c[MAX_N];\n\tvc<int> son[MAX_N];\n\tll g[MAX_N];\n\tvoid dp(int x)\n\t{\n\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t{\n\t\t\tint y=son[x][t];dp(y);\n\t\t\tb[x]+=b[y];\n\t\t}\n\t\tif(son[x].size())\n\t\t{\n\t\t\tg[x]=LLINF;\n\t\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=son[x][t];\n\t\t\t\tchmin(g[x], max(g[y],(ll)c[x])+(b[x]-b[y]) );\n\t\t\t}\n\t\t}\n\t\telse g[x]=b[x]+c[x];\n\t}\n\tint pos[MAX_N];bool cmp(int x,int y){return c[x]<c[y];}\n\tvc<int> to[MAX_N];\n    void main()\n    {\n\t\tint n=qread(),m=qread();for(int i=1;i<=n;i++) c[i]=qread(),b[i]=qread(),c[i]=max(int(c[i]-b[i]),0);\n\t\tfor(int i=1;i<=n;i++) pos[i]=i;sort(pos+1,pos+n+1,cmp);\n\t\tfor(int i=1;i<=m;i++){int x=qread(),y=qread();to[x].PB(y);to[y].PB(x);}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=pos[i];dsu.fa[x]=x;\n\t\t\tfor(int t=0;t<(int)to[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=to[x][t],tt=dsu.findfa(y);\n\t\t\t\tif(dsu.fa[y]!=0 and tt!=x) dsu.fa[tt]=x,son[x].PB(tt);\n\t\t\t}\n\t\t}\n\t\tdp(pos[n]);write(g[pos[n]]);\n    }\n};\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nint n,m;\nstruct edge{\n\tint y,next;\n}s[N<<1];\nvector<int> out[N];\nint first[N],len=0,a[N],b[N],id[N],rk[N],fa[N];\nlong long sum[N],dp[N];\n\nbool cmp(int x,int y){return a[x]<a[y];}\nint findpa(int x){return fa[x]!=x?fa[x]=findpa(fa[x]):x;}\nvoid ins(int x,int y){s[++len]=(edge){y,first[x]};first[x]=len;}\n\nvoid dfs(int x,int fa){\n\tsum[x]=b[x];\n\tfor(int i=first[x];i!=0;i=s[i].next) if(s[i].y!=fa) dfs(s[i].y,x),sum[x]+=sum[s[i].y];\n}\n\nvoid get_ans(int x,int fa){\n\tif(first[x]==0) dp[x]=a[x]+b[x];\n\telse dp[x]=1e18;\n\tfor(int i=first[x];i!=0;i=s[i].next) if(s[i].y!=fa){\n\t\tget_ans(s[i].y,x);\n\t\tdp[x]=min(dp[x],sum[x]-sum[s[i].y]+max(dp[s[i].y],1ll*a[x]));\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tint x,y;\n\tfor(int i=1;i<=n;i++) scanf(\"%d %d\",&a[i],&b[i]),a[i]=max(a[i]-b[i],0),id[i]=i;\n\tfor(int i=1;i<=m;i++) scanf(\"%d %d\",&x,&y),out[x].push_back(y),out[y].push_back(x);\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++) rk[id[i]]=i,fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tx=id[i];\n\t\tfor(int j=0;j<out[x].size();j++){\n\t\t\ty=findpa(out[x][j]);\n\t\t\tif(rk[y]<rk[x]) ins(x,y),fa[y]=x;\n\t\t}\n\t}\n\tdfs(id[n],0);\n\tget_ans(id[n],0);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint a[N],b[N],n,m,vis[N],fa[N];\ntypedef long long ll;\npair<int,int>c[N];\nvector<int>g[N];\nll sum[N],mn[N];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i]>>b[i];\n\t\tc[i].first=a[i];c[i].second=i;\n\t}\n\tsort(c+1,c+n+1);\n\tfor(int i=1;i<=m;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg[x].push_back(y);g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;++i)fa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tint u=c[i].second;sum[u]=b[u];mn[u]=max(0,a[u]-b[u]);\n\t\tvis[u]=1;\n\t\tfor(int j:g[u])if(vis[j]){\n\t\t\tint v=find(j);if(u==v)continue;\n\t\t\tsum[u]+=sum[v];mn[u]=min(mn[u],max(a[u]-sum[v]-b[u],mn[v]));\n\t\t\tfa[v]=u;\n\t\t}\n\t}\n\tcout<<sum[c[n].second]+mn[c[n].second]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i <= i##_END_; i++)\n#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i >= i##_END_; i--)\n\ntemplate <typename Tp> void in(Tp &x) {\n\tchar ch = getchar(), f = 1; x = 0;\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') ch = getchar(), f = -1;\n\twhile (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n\tx *= f;\n}\n\ntemplate <typename Tp> void out(Tp x) {\n\tif (x > 9) out(x / 10);\n\tputchar(x % 10 + '0');\n\treturn;\n}\n\ntemplate <typename Tp> Tp Max(const Tp &x, const Tp &y) {return x > y ? x : y;}\ntemplate <typename Tp> Tp Min(const Tp &x, const Tp &y) {return x < y ? x : y;}\ntemplate <typename Tp> bool chkmax(Tp &x, Tp y) {return x >= y ? 0 : (x=y, 1);}\ntemplate <typename Tp> bool chkmin(Tp &x, Tp y) {return x <= y ? 0 : (x=y, 1);}\n\nconst int MAXN = 100010;\n\nint n, m, A[MAXN], B[MAXN], to[MAXN];\nint head[MAXN], data[MAXN << 1], nxt[MAXN << 1], cnt;\n\nint fa[MAXN], rnk[MAXN];\n\nLL sum[MAXN];\n\nchar cmp(const int &x, const int &y) {return A[x] - B[x] < A[y] - B[y];}\n\nvoid add(int x, int y)\n{\n\tnxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++;\n\tnxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;\n}\n\nint find(int x) {while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x;}\n\nint main()\n{\n\tin(n); in(m);\n\tFOR(i, 1, n) in(A[i]), in(B[i]);\n\tFOR(i, 1, n) to[i] = i;\n\n\tstd::sort(to + 1, to + n + 1, cmp);\n\n\tmemset(head, -1, sizeof head);\n\tFOR(i, 1, n) fa[i] = i;\n\tFOR(i, 1, m) {int x, y; in(x); in(y); add(x, y);}\n\n\tFOR(i, 1, n) rnk[to[i]] = i;\n\n\tLL wmin = 0;\n\n\tFOR(i, 1, n) sum[i] = 0;\n\n\tchkmax(wmin, 0ll + A[to[1]] - B[to[1]]);\n\n\tLL msz = 0, all = 0;\n\n\tFOR(i, 1, n) all += B[i];\n\t\n\tFOR(i, 1, n - 1) {\n\t\tint now = to[i];\n\t\tsum[find(now)] = B[now];\n\t\tfor (int j = head[now]; j != -1; j = nxt[j]) {\n\t\t\tint fx;\n\t\t\tif ((fx = find(data[j])) != find(now) && rnk[data[j]] < i) {\n\t\t\t\tfa[fx] = find(now); sum[find(now)] += sum[fx];\n\t\t\t}\n\t\t}\n\t\tchkmax(msz, sum[find(now)]);\n\t\tchkmax(wmin, A[to[i + 1]] - B[to[i + 1]] - msz);\n\t}\n\n\tprintf(\"%lld\\n\", wmin + all);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nCerberus97\nHanit Banga\n*/\n\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nll a[N], b[N], temp[N];\nint parent[N], sz[N];\nvector<int> g[N];\nvector<int> pend[N];\n\nbool check(ll s_mon, int n);\nint dsu_find(int x);\nvoid dsu_join(int x, int y);\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tll bsum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tbsum += b[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 0, hi = 1e9;\n\twhile (lo <= hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (check(mid, n)) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tcout << hi + 1 + bsum;\n\t// cout << check(100, n) << endl;\n}\n\nbool check(ll s_mon, int n) {\n\tmemset(temp, 0, sizeof(temp));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tparent[i] = i;\n\t\tsz[i] = 1;\n\t\tpend[i].clear();\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\t// cout << i << ' ';\n\t\tif (dsu_find(i) != i or s_mon < a[i] - b[i]) {\n\t\t\t// cout << \"skipped\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t// cout << endl;\n\t\tint ind = i;\n\t\tll w = s_mon;\n\t\tpriority_queue<pll, vector<pll>, greater<pll>> pq;\n\t\tpq.push({a[i] - b[i], i});\n\t\twhile (!pq.empty()) {\n\t\t\tauto cur = pq.top();\n\t\t\t// cout << cur.first << ' ' << cur.second << ' ' << dsu_find(cur.second) << ' ' << w << endl;\n\t\t\tpq.pop();\n\t\t\tif (cur.first > w) {\n\t\t\t\tpend[ind].pb(cur.second);\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tpend[ind].pb(pq.top().second);\n\t\t\t\t\tpq.pop();\n\t\t\t\t}\n\t\t\t} else if (dsu_find(cur.second) == cur.second) {\n\t\t\t\tdsu_join(ind, cur.second);\n\t\t\t\tind = dsu_find(ind);\n\t\t\t\tw += b[cur.second];\n\t\t\t\tfor (auto &v : g[cur.second]) {\n\t\t\t\t\tif (dsu_find(v) != ind) {\n\t\t\t\t\t\tpq.push({a[v] - b[v], v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw += temp[dsu_find(cur.second)];\n\t\t\t\tfor (auto &v : pend[dsu_find(cur.second)]) {\n\t\t\t\t\tif (dsu_find(v) != ind) {\n\t\t\t\t\t\tpq.push({a[v] - b[v], v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdsu_join(ind, cur.second);\n\t\t\t\tind = dsu_find(ind);\n\t\t\t}\n\t\t}\n\t\ttemp[ind] = w - s_mon;\n\t\t// cout << ind << ' ' << dsu_find(ind) << ' ' << sz[ind] << endl;\n\t\tif (sz[ind] == n) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint dsu_find(int x) {\n\tif (x == parent[x]) {\n\t\treturn x;\n\t}\n\tparent[x] = dsu_find(parent[x]);\n\treturn parent[x];\n}\n\nvoid dsu_join(int x, int y) {\n\tx = dsu_find(x);\n\ty = dsu_find(y);\n\tif (x == y) {\n\t\treturn;\n\t}\n\tif (sz[x] < sz[y]) {\n\t\tparent[x] = y;\n\t\tsz[y] += sz[x];\n\t} else {\n\t\tparent[y] = x;\n\t\tsz[x] += sz[y];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct node{\n\tint x,v;\n\tnode(int a=0,int b=0){x=a;v=b;}\n}p[100010];\nint h[100010],nex[200010],to[200010],a[100010],b[100010],fa[100010],M;\nll s[100010],f[100010];\nbool v[100010];\nvoid add(int a,int b){\n\tM++;\n\tto[M]=b;\n\tnex[M]=h[a];\n\th[a]=M;\n}\nbool operator<(node a,node b){return a.v<b.v;}\nint get(int x){return x==fa[x]?x:(fa[x]=get(fa[x]));}\nint main(){\n\tint n,m,i,j,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tp[i]=node(i,a[i]);\n\t}\n\twhile(m--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(p+1,p+n+1);\n\tfor(i=1;i<=n;i++){\n\t\tfa[i]=i;\n\t\ts[i]=b[i];\n\t\tf[i]=a[i];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tv[p[i].x]=1;\n\t\tfor(j=h[p[i].x];j;j=nex[j]){\n\t\t\tif(v[to[j]]){\n\t\t\t\tx=get(p[i].x);\n\t\t\t\ty=get(to[j]);\n\t\t\t\tif(x==y)continue;\n\t\t\t\tfa[y]=x;\n\t\t\t\ts[x]+=s[y];\n\t\t\t\tif(a[x]>f[y]+s[y])\n\t\t\t\t\tf[x]=min(f[x],a[x]-s[y]);\n\t\t\t\telse\n\t\t\t\t\tf[x]=min(f[x],f[y]);\n\t\t\t}\n\t\t}\n\t}\n\tx=get(1);\n\tprintf(\"%lld\",f[x]+s[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline void myassert(bool a,string s){ if(!a)cerr<<s<<endl,exit(0);}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=1e5+20;\n\nint n,m;\nvector<int>ed[maxn];\nint a[maxn],b[maxn];\nint fa[maxn],vis[maxn],id[maxn];\nll sum[maxn],mn[maxn];\n\ninline void init()\n{\n\tn=read();m=read();\n\tREP(i,1,n)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tfa[i]=id[i]=i;\n\t\tsum[i]=b[i]; mn[i]=a[i];\n\t}\n\tREP(i,1,m)\n\t{\n\t\tint x=read(),y=read();\n\t\ted[x].push_back(y);\n\t\ted[y].push_back(x);\n\t}\n\tsort(id+1,id+n+1,[](int x,int y){ return a[x]<a[y];});\n}\n\nint fin(int x){ return x==fa[x]?x:fa[x]=fin(fa[x]);}\n\ninline void doing()\n{\n\tREP(i,1,n)\n\t{\n\t\tint x=id[i]; vis[x]=1;\n\t\tfor(int y:ed[x])\n\t\t\tif(vis[y])\n\t\t\t{\n\t\t\t\tint u=fin(x),v=fin(y);\n\t\t\t\tif(u==v)continue;\n\t\t\t\tfa[v]=u;\n\t\t\t\tmn[u]=min(max(mn[v]-sum[u],mn[u]),max(a[u]-sum[v],mn[v]));\n\t\t\t\tsum[u]+=sum[v];\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum[id[n]]+mn[id[n]]);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=100010;\nconst int inf=2147483647;\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n    return x*f;\n}\nint fa[Maxn],n,m,to[Maxn];\nvector<int>G[Maxn];\nstruct P{int a,b,id;}p[Maxn];\nbool cmp(P a,P b)\n{\n\treturn max(a.a-a.b,0)<max(b.a-b.b,0);\n//\tif(a.a!=b.a)return a.a<b.a;\n//\treturn a.b>b.b;\n}\nstruct Edge{int y,next;}e[Maxn];\nint last[Maxn],len=0;\nvoid ins(int x,int y)\n{\n\tint t=++len;\n\te[t].y=y;e[t].next=last[x];last[x]=t;\n}\nint rt[Maxn];\nint findrt(int x){return((rt[x]==x)?x:rt[x]=findrt(rt[x]));}\nLL f[Maxn],g[Maxn];\nvoid dfs(int x)\n{\n\tbool flag=true;g[x]=p[x].b;\n\tfor(int i=last[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].y;\n\t\tdfs(y);flag=false;\n\t\tg[x]+=g[y];\n\t}\n\tif(flag)\n\t{\n\t\tf[x]=max(p[x].a,p[x].b);\n\t\treturn;\n\t}\n\tf[x]=1LL<<60;\n\tfor(int i=last[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].y;\n\t\tf[x]=min(f[x],max((LL)max(p[x].a-p[x].b,0),f[y])+g[x]-g[y]);\n\t}\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++)rt[i]=i,p[i].a=read(),p[i].b=read(),p[i].id=i;\n\tsort(p+1,p+1+n,cmp);\n\tfor(int i=1;i<=n;i++)to[p[i].id]=i;\n//\tfor(int i=1;i<=n;i++)printf(\"%d %d %d\\n\",i,p[i].a,p[i].b);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=to[read()],y=to[read()];\n//\t\tprintf(\"  %d %d\\n\",x,y);\n\t\tG[x].push_back(y),G[y].push_back(x);\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int i=0;i<G[x].size();i++)\n\t\t{\n\t\t\tint y=G[x][i],fy=findrt(y);\n\t\t\tif(y>x)continue;\n\t\t\tif(fy==x)continue;\n\t\t\tfa[fy]=x,rt[fy]=x;\n\t\t}\n\t}\n\tint root;\n\tfor(int i=1;i<=n;i++)\n\tif(!fa[i])root=i;\n\telse ins(fa[i],i);//printf(\"ins %d %d\\n\",fa[i],i);\n\tdfs(root);\n//\tfor(int i=1;i<=n;i++)printf(\"%d %lld %lld\\n\",i,f[i],g[i]);\n\tprintf(\"%lld\",f[root]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\ntypedef vector<int> vi;\n#define pb push_back\ntypedef long long ll;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,a[N],b[N],fa[N],id[N];\nll s[N],f[N],g[N];\nvi E[N];\nbool vis[N];\n\nint getf(int x) {\n\treturn x==fa[x]?x:fa[x]=getf(fa[x]);\n}\n\nbool cmp(int x,int y) {\n\treturn a[x]<a[y];\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i]=gi(),b[i]=gi();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tid[i]=fa[i]=i;s[i]=b[i];f[i]=g[i]=a[i]+b[i];\n\t}\n\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++) {\n\t\tint u=id[i];vis[u]=1;\n\t\tfor(auto v:E[u])\n\t\t\tif(vis[v]) {\n\t\t\t\tint x=u,y=getf(v);\n\t\t\t\tif(x!=y) {\n\t\t\t\t\tfa[y]=x;\n\t\t\t\t\tll new_f=min(max(g[x],s[x]+f[y]),max(g[y],s[y]+f[x])),new_g=s[x]+s[y]+a[x];\n\t\t\t\t\tf[x]=new_f;g[x]=new_g;s[x]+=s[y];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcout<<f[getf(1)];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            const int V = S[top[uf.find(to)]];\n            if (V < S[i]) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        std::set<int> used;\n        for (const int to : T[v]) {\n            assert(used.find(to) == used.end());\n            used.insert(to);\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    int r = -1;\n    for (int i = 0; i < N; i++) {\n        if (T.rev_edge[i].empty()) { r = i; }\n    }\n    dfs(dfs, r);\n    std::cout << f[r] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int, int>> L;\nvector<int> Y[1 << 17];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\t\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) scanf(\"%lld%lld\", &A[i], &B[i]);\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\t\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(t);\n\t\t\t}\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 1000006200);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 100005\n#define ll long long \nusing namespace std;\n\nint n,m,i,j,k,a[maxn],b[maxn],c[maxn],id[maxn];\nint em,e[maxn*2],nx[maxn*2],ls[maxn];\nint cmp(int i,int j){return c[i]<c[j];}\n\nvoid insert(int x,int y){\n\tem++; e[em]=y; nx[em]=ls[x]; ls[x]=em;\n\tem++; e[em]=x; nx[em]=ls[y]; ls[y]=em;\n}\n\nint fa[maxn]; ll g[maxn],f[maxn];\nint father(int x){return (fa[x]==x)?x:fa[x]=father(fa[x]);}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]),c[i]=a[i]-b[i];\n\tfor(i=1;i<=m;i++) scanf(\"%d%d\",&j,&k),insert(j,k);\n\tfor(i=1;i<=n;i++) id[i]=i;sort(id+1,id+1+n,cmp);\n\tfor(int now=1;now<=n;now++){int x=id[now];\n\t\tfa[x]=x,f[x]=max(0,c[x]),g[x]=b[x];\n\t\tfor(i=ls[x];i;i=nx[i]) if (fa[e[i]]){int y=e[i];\n\t\t\tif (father(x)!=father(y)){\n\t\t\t\ty=fa[y];\n\t\t\t\tf[x]=min(f[x],max(f[y],c[y]-g[y]));\n\t\t\t\tg[x]+=g[y],fa[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[father(1)]+g[father(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint n, m, z[100005], par[100005], tb, tc;\nlong long x[100005], y[100005], sum[100005], dp[100005], ta;\nvector< int > v[100005], vv[100005];\n\nint find(int a) {\n\treturn par[a] == a ? a : par[a] = find(par[a]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld\", &ta, x + i);\n\t\ty[i] = max(ta - x[i], 0LL);\n\t\tz[i] = i;\n\t}\n\tsort(z + 1, z + n + 1, [](const int &a, const int &b) {return y[a] < y[b];});\n\twhile (m--) {\n\t\tscanf(\"%d%d\", &tb, &tc);\n\t\tv[tb].push_back(tc);\n\t\tv[tc].push_back(tb);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ttb = z[i];\n\t\tpar[tb] = tb;\n\t\tsum[tb] = x[tb];\n\t\tdp[tb] = y[tb];\n\t\tfor (int j: v[tb])\n\t\t\tif (par[j] && (j = find(j)) != tb) {\n\t\t\t\tvv[tb].push_back(j);\n\t\t\t\tpar[j] = tb;\n\t\t\t\tsum[tb] += sum[j];\n\t\t\t\tdp[tb] = min(dp[tb], max(dp[j], y[tb]) - sum[j]);\n\t\t\t}\n\t\tdp[tb] += sum[tb];\n\t}\n\tprintf(\"%lld\\n\", dp[z[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define pa pair<int,int>\nconst int Maxn=100010;\nconst int inf=2147483647;\nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n    return x*f;\n}\nint fa[Maxn],n,m,to[Maxn];\nvector<int>G[Maxn];\nstruct P{int a,b,id;}p[Maxn];\nbool cmp(P a,P b)\n{\n\treturn max(a.a-a.b,0)<max(b.a-b.b,0);\n//\tif(a.a!=b.a)return a.a<b.a;\n//\treturn a.b>b.b;\n}\nstruct Edge{int y,next;}e[Maxn];\nint last[Maxn],len=0;\nvoid ins(int x,int y)\n{\n\tint t=++len;\n\te[t].y=y;e[t].next=last[x];last[x]=t;\n}\nint rt[Maxn];\nint findrt(int x){return((rt[x]==x)?x:rt[x]=findrt(rt[x]));}\nLL f[Maxn],g[Maxn];\nvoid dfs(int x)\n{\n\tbool flag=true;g[x]=p[x].b;\n\tfor(int i=last[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].y;\n\t\tdfs(y);flag=false;\n\t\tg[x]+=g[y];\n\t}\n\tif(flag)\n\t{\n\t\tf[x]=max(p[x].a,p[x].b);\n\t\treturn;\n\t}\n\tf[x]=1LL<<60;\n\tfor(int i=last[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].y;\n\t\tf[x]=min(f[x],max((LL)max(p[x].a-p[x].b,0),f[y])+g[x]-g[y]);\n\t}\n}\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++)rt[i]=i,p[i].a=read(),p[i].b=read(),p[i].id=i;\n\tsort(p+1,p+1+n,cmp);\n\tfor(int i=1;i<=n;i++)to[p[i].id]=i;\n//\tfor(int i=1;i<=n;i++)printf(\"%d %d %d\\n\",i,p[i].a,p[i].b);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=to[read()],y=to[read()];\n//\t\tprintf(\"  %d %d\\n\",x,y);\n\t\tG[x].push_back(y),G[y].push_back(x);\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tfor(int i=0;i<G[x].size();i++)\n\t\t{\n\t\t\tint y=G[x][i],fy=findrt(y);\n\t\t\tif(y>x)continue;\n\t\t\tif(fy==x)continue;\n\t\t\tfa[fy]=x,rt[fy]=x;\n\t\t}\n\t}\n\tint root;\n\tfor(int i=1;i<=n;i++)\n\tif(!fa[i])root=i;\n\telse ins(fa[i],i);//printf(\"ins %d %d\\n\",fa[i],i);\n\tdfs(root);\n//\tfor(int i=1;i<=n;i++)printf(\"%d %lld %lld\\n\",i,f[i],g[i]);\n\tprintf(\"%lld\",f[root]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nvoid unite_que(priority_queue<Pii, vector<Pii>, greater<Pii>> &q1, priority_queue<Pii, vector<Pii>, greater<Pii>> &q2){\n    if(q2.size() > q1.size()) q1.swap(q2);\n    while(!q2.empty()){\n        q1.push(q2.top());\n        q2.pop();\n    }\n}\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, dat;\n    vector<priority_queue<Pii, vector<Pii>, greater<Pii>>> que;\n\n    Union_find(int N, vector<int> v){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        dat = v;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        dat[x] += dat[y];\n        unite_que(que[x], que[y]);\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int w, Union_find &UF){\n        if(UF.union_size(v) > 1) return;\n        while(!UF.que[UF.find(v)].empty()){\n            int par = UF.find(v);\n            Pii p = UF.que[par].top();\n            if(p.first > UF.dat[par] + w) break;\n            UF.que[par].pop();\n            UF.unite(par, p.second);\n        }\n    }\n\n};\n\nvoid init(Graph &G, Union_find &UF, vec &A, int N){\n    UF.que = vector<priority_queue<Pii, vector<Pii>, greater<Pii>>>(N);\n    REP(i, N) REP(k, G.G[i].size()) UF.que[i].push(Pii(A[G.G[i][k].to], G.G[i][k].to));\n}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    int S = 0;\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        S += B[i];\n        A[i] -= B[i];\n    }\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1, 0);\n    }\n\n    int w1 = -1, w2 = 1000000000;\n    while(w2 - w1 > 1){\n        int w = (w1 + w2 + 1) / 2;\n        Union_find UF(N, B);\n        init(G, UF, A, N);\n        REP(i, N) if(w >= A[i]) G.dfs(i, w, UF);\n        //cout << w << \",\" << UF.union_size(0) << endl;\n        if(UF.union_size(0) == N) w2 = w;\n        else w1 = w;\n    }\n    cout << w2 + S << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) p1=1;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// ARC098F.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 200;\n\ntypedef long long ll;\n\nint n, m, head[MAX_N], current, ai[MAX_N], bi[MAX_N], ci[MAX_N], id[MAX_N], rk[MAX_N], mem[MAX_N];\nll dp[MAX_N], tot[MAX_N];\nvector<int> G[MAX_N];\n\nstruct edge\n{\n    int to, nxt;\n} edges[MAX_N << 1];\n\nvoid addpath(int src, int dst)\n{\n    edges[current].to = dst, edges[current].nxt = head[src];\n    head[src] = current++;\n}\n\nint find(int x) { return mem[x] == x ? x : mem[x] = find(mem[x]); }\n\nvoid dfs(int u, int fa)\n{\n    tot[u] = bi[u];\n    for (auto son : G[u])\n        dfs(son, u), tot[u] += tot[son];\n}\n\nvoid calc(int u, int fa)\n{\n    if (G[u].empty())\n        return (void)(dp[u] = bi[u] + ci[u]);\n    dp[u] = 1e18;\n    for (auto v : G[u])\n        calc(v, u), dp[u] = min(dp[u], tot[u] - tot[v] + max(1LL * ci[u], dp[v]));\n}\n\nint main()\n{\n    memset(head, -1, sizeof(head));\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d%d\", &ai[i], &bi[i]), ci[i] = max(ai[i] - bi[i], 0), id[i] = i, mem[i] = i;\n    sort(id + 1, id + 1 + n, [](const int &rhs1, const int &rhs2) { return ci[rhs1] < ci[rhs2]; });\n    for (int i = 1; i <= n; i++)\n        rk[id[i]] = i;\n    for (int i = 1, u, v; i <= m; i++)\n        scanf(\"%d%d\", &u, &v), addpath(u, v), addpath(v, u);\n    for (int idx = 1; idx <= n; idx++)\n    {\n        int u = id[idx];\n        for (int i = head[u]; i != -1; i = edges[i].nxt)\n            if (u != find(edges[i].to) && rk[u] > rk[find(edges[i].to)])\n                G[u].push_back(find(edges[i].to)), mem[find(edges[i].to)] = u;\n    }\n    dfs(id[n], 0), calc(id[n], 0), printf(\"%lld\\n\", dp[id[n]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint n,m;\nint A[100010],B[100010];\nlong long dp[100010],S[100010];\nbool cmp(int x,int y)\n{\n\treturn S[x]-dp[x]<S[y]-dp[y];\n}\nvector<int>e[100010],son[100010];\nint id[100010];\nbool cmp2(int x,int y)\n{\n\treturn A[x]<A[y];\n}\nbool book[100010];\nint fa[100010];\nint find(int x)\n{\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nint work()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i;\n\tsort(id+1,id+n+1,cmp2);\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint u=id[j];\n\t\tbook[u]=true;\n\t\tfa[u]=u;\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint v=e[u][i];\n\t\t\tif(book[v])\n\t\t\t{\n\t\t\t\tint f=find(v);\n\t\t\t\tif(f!=u)\n\t\t\t\t{\n\t\t\t\t\tfa[f]=u;\n\t\t\t\t\tson[u].push_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn id[n];\n}\nlong long res1[100010],res2[100010];\nvoid solve(int u)\n{\n\tS[u]=B[u];\n\tif(!son[u].size()){\n\t\tdp[u]=A[u]+B[u];\n\t\treturn ;\n\t}\n\tfor(int i=0;i<son[u].size();i++)\n\t{\n\t\tsolve(son[u][i]);\n\t\tS[u]+=S[son[u][i]];\n\t}\n\tsort(son[u].begin(),son[u].end(),cmp);\n\tlong long nsum=0;\n\tfor(int i=0;i<son[u].size();i++)\n\t{\n\t\tint v=son[u][i];\n\t\tres1[i]=max(nsum+dp[v],i>0?res1[i-1]:0);\n\t\tnsum+=S[v];\n\t}\n\tres2[son[u].size()]=0;\n\tfor(int i=son[u].size()-1;i>=0;i--)\n\t{\n\t\tint v=son[u][i];\n\t\tres2[i]=max(dp[v],res2[i+1]+S[v]);\n\t}\n\tdp[u]=1e18;nsum=0;\n\tfor(int i=0;i<son[u].size();i++)\n\t{\n\t\tint v=son[u][i];\n\t\tlong long val=0;\n\t\tif(i>0)val=max(val,res1[i-1]);\n\t\tval=max(val,nsum+res2[i+2]);\n\t\tval=max(val,A[u]+S[u]-S[v]);\n\t\tval=max(val,S[u]-S[v]+dp[v]);\n\t\tdp[u]=min(dp[u],val);\n\t}\n\treturn ;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d %d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i]-B[i],0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tint rt=work();\n\tsolve(rt);\n\tprintf(\"%lld\\n\",dp[rt]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<ll> vll;\ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 1e5 + 41;\n\nint n, m;\nint a[MAX];\nint b[MAX];\nint c[MAX];\nvi e[MAX];\n\nvi e1[MAX];\n\nbool cmp(int i, int j) {\n\treturn c[i] < c[j];\n}\n\nint par[MAX];\n\nint find(int x) {\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool uni(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) return false;\n\tpar[b] = a;\n\treturn 1;\n}\n\nll d[MAX];\nll ds[MAX];\nll const INF = 1e18;\n\nvoid dfs(int x) {\n\tds[x] = b[x];\n\tfor (int y : e1[x]) {\n\t\tdfs(y);\n\t\tds[x] += ds[y];\n\t}\n\t\n\tvpll v;\n\tfor (int y : e1[x]) {\n\t\tv.pb(mp(d[y], y));\t\t\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\n\tll res = INF;\n\tif (sz(e1[x]) > 0) {\n\t\tll sum = ds[x];\t\t\n\t\tint k = sz(v);\n\t\tvll f(k, 0);\n\t\tvll suf(k, 0);\n\t\tfi(0, sz(v) - 1) {\n\t\t\tint id = v[i].second;\n\t\t\tsum -= ds[id];\n\t\t\tf[i] = v[i].first - sum;\t\t\t\n\t\t}\n\t\tfdi(k - 1, 0) {\n\t\t\tsuf[i] = f[i];\n\t\t\tif (i + 1 < k) {\n\t\t\t\tsuf[i] = max(suf[i], suf[i + 1]);\n\t\t\t}\n\t\t}\n\n\t\tll pref = 0;\n\t\tfi(0, k - 1) {\n\t\t\tint id = (int) v[i].second;\n\n\t\t\tll sf = (i + 1 < k ? suf[i + 1] : 0);\n\t\t\tsf = max(0LL, sf - ds[id]);\n\t\t\tll me = max(0LL, c[x] - ds[id]);\n\t\t\tll to = v[i].first;\n\t\t\tll pres = max(pref, max(sf, max(me, to)));\n\t\t\t\n\t\t\tres = min(res, pres);\n\n\t\t\tpref = max(pref, f[i]);\t\t\t\t\n\t\t}\n\t} else {\n\t\tres = c[x];\n\t}\n\n\td[x] = res;\n}\n\nll ans;\n\nvoid solve() {\n\tfi(1, n) {\n\t\tc[i] = max(0, a[i] - b[i]);\n\t}\n\n\tvi v;\n\tfi(1, n) {\n\t\tv.pb(i);\n\t}\n\tsort(v.begin(), v.end(), cmp);\n\n\tfi(1, n) {\n\t\tsort(e[i].begin(), e[i].end(), cmp);\n\t}\n\n\tfi(1, n) {\n\t\tpar[i] = i;\n\t}\n\t\n\tfor (int x : v) {\n\t\tfor (int z : e[x]) {\n\t\t\tint y = find(z);\n\t\t\tif (c[y] > c[x]) continue;\n\t\t\tif (find(x) != find(y)) {\n\t\t\t\te1[x].pb(find(y));\n\t\t\t\tuni(x, y);\n\t\t\t}\n\t\t}\n\t}\t\n\n\tfi(1, n) {\n\t\tsort(e1[i].begin(), e1[i].end());\n\t\te1[i].resize(unique(e1[i].begin(), e1[i].end()) - e1[i].begin());\n\t}\n\n/*\t\n\terr(\"root = %d\\n\", find(1));\n\tfi(1, n) {\n\t\terr(\"x = %d c = %d:\\n\", i, c[i]);\n\t\tfor (int y : e1[i]) {\n\t\t\terr(\"y = %d\\n\", y);\n\t\t}\n\t\terr(\"\\n\");\n\t}\n*/\n\n\tdfs(find(1));\n\n\tans = d[find(1)];\t\n\tfi(1, n) {\n\t\tans += b[i];\n\t}\n\n/*\n\tfi(1, n) {\n\t\terr(\"i = %d d = %lld\\n\", i, d[i]);\n\t}\n*/\n\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n  scanf(\"%d %d\", &n, &m);\n  fi(1, n) {\n  \tscanf(\"%d %d\", &a[i], &b[i]);\n  }\n  fi(1, m) {\n  \tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n  }\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define mxn 100010\n#define LL long long\nusing namespace std;\nint n,m,sl,fh,p[mxn],fa[mxn],vis[mxn];\nLL ans,a[mxn],b[mxn],s[mxn];\nint t,h[mxn];\nstruct edge\n{\n\tint to,nxt;\n}e[mxn<<1];\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nbool cmp(const int &x,const int &y) {return s[x]<s[y];}\nvoid add(int u,int v)\n{\n\te[++t]=(edge){v,h[u]};h[u]=t;\n\te[++t]=(edge){u,h[v]};h[v]=t;\n}\nint getfa(int x)\n{\n\tif(fa[x]!=x) fa[x]=getfa(fa[x]);\n\treturn fa[x];\n}\nint main()\n{\n\tn=rd();m=rd();int x,y;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=rd();b[i]=rd();\n\t\ts[i]=a[i]=max(0ll,a[i]-b[i]);\n\t\tfa[i]=p[i]=i;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<=m;++i) x=rd(),y=rd(),add(x,y);\n\tint u,v,fx,fy;\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tvis[u=p[k]]=1;\n\t\tfor(int i=h[u];i;i=e[i].nxt)\n\t\t\tif(vis[v=e[i].to])\n\t\t\t{\n\t\t\t\tfx=getfa(u);fy=getfa(v);\n\t\t\t\tif(fx==fy) continue;\n\t\t\t\tb[fx]+=b[fy];fa[fy]=fx;\n\t\t\t\ts[fx]=min(s[fx],s[fy]+max(0ll,a[fx]-s[fy]-b[fy]));\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",s[p[n]]+b[p[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint n;\nlong long x[210],k[210],a[210];\n\nlong long findsg(int x,int k)\n{\n\tif (x<k) return 0;\n\tif (x%k==0) return x/k;\n\tif (k>=1000000)\n\t{\n\t\tlong long op=x-k*(x/k);\n\t\tlong long oq=oq%(x/k+1);\n\t\tx=k*(x/k)+oq-(x/k)-1;\n\t\tfindsg(x,k);\n\t}\n\telse\n\treturn findsg(x-x/k-1,k);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&x[i],&k[i]);\n\t\ta[i]=findsg(x[i],k[i]);\n\t}\n\tlong long ans=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tans=ans^a[i];\n\t}\n\tif (ans!=0) printf(\"Takahashi\\n\");\n\telse printf(\"Aoki\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 100005\nusing namespace std;\nint a[N],b[N],c[N],d[N],e[N],g[N],f[N],m,n;long long h[N],x;\ninline bool cmp(int u,int v){return g[a[u]]==g[a[v]]?a[u]<a[v]:g[a[u]]<g[a[v]];}\nint find(int u)\n{\n\tif(!f[u])return u;\n\tint v=find(f[u]);\n\treturn e[u]=max(e[u],e[f[u]]),f[u]=v;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),x=0x7fffffffffffffffll;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%lld\",g+i,h+i),g[i]=g[i]<h[i]?0:g[i]-h[i];\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",a+i,b+i),c[i]=i,g[a[i]]<g[b[i]]||g[a[i]]==g[b[i]]&&a[i]<b[i]?a[i]^=b[i]^=a[i]^=b[i]:0;\n\tsort(c+1,c+m+1,cmp);\n\tfor(int i=1,u;i<=m;i++)if(a[c[i]]!=(u=find(b[c[i]])))e[u]=max((long long)e[u],g[a[c[i]]]-h[u]),f[u]=a[c[i]],h[a[c[i]]]+=h[u];\n\tfor(int i=1;i<=n;i++)x=min(x,max(g[i],e[i])+h[find(i)]);\n\treturn 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nCerberus97\nHanit Banga\n*/\n\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nll a[N], b[N], temp[N];\nint parent[N], sz[N];\nvector<int> g[N];\nvector<int> pend[N];\n\nbool check(ll s_mon, int n);\nint dsu_find(int x);\nvoid dsu_join(int x, int y);\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tll bsum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tbsum += b[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 0, hi = 1e9;\n\twhile (lo <= hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (check(mid, n)) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tcout << hi + 1 + bsum;\n\t// cout << check(100, n) << endl;\n}\n\nbool check(ll s_mon, int n) {\n\tmemset(temp, 0, sizeof(temp));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tparent[i] = i;\n\t\tsz[i] = 1;\n\t\tpend[i].clear();\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\t// cout << i << ' ';\n\t\tif (dsu_find(i) != i or s_mon < a[i] - b[i]) {\n\t\t\t// cout << \"skipped\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t// cout << endl;\n\t\tint ind = i;\n\t\tll w = s_mon;\n\t\tpriority_queue<pll, vector<pll>, greater<pll>> pq;\n\t\tpq.push({a[i] - b[i], i});\n\t\twhile (!pq.empty()) {\n\t\t\tauto cur = pq.top();\n\t\t\t// cout << cur.first << ' ' << cur.second << ' ' << dsu_find(cur.second) << ' ' << w << endl;\n\t\t\tpq.pop();\n\t\t\tint comp = dsu_find(cur.second);\n\t\t\tif (cur.first > w) {\n\t\t\t\tpend[ind].pb(cur.second);\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tpend[ind].pb(pq.top().second);\n\t\t\t\t\tpq.pop();\n\t\t\t\t}\n\t\t\t} else if (comp == cur.second) {\n\t\t\t\tdsu_join(ind, cur.second);\n\t\t\t\tind = dsu_find(ind);\n\t\t\t\tw += b[cur.second];\n\t\t\t\tfor (auto &v : g[cur.second]) {\n\t\t\t\t\tif (dsu_find(v) != ind) {\n\t\t\t\t\t\tpq.push({a[v] - b[v], v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw += temp[comp];\n\t\t\t\tdsu_join(ind, cur.second);\n\t\t\t\tind = dsu_find(ind);\n\t\t\t\tfor (auto &v : pend[comp]) {\n\t\t\t\t\tif (dsu_find(v) != ind) {\n\t\t\t\t\t\tpq.push({a[v] - b[v], v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttemp[ind] = w - s_mon;\n\t\t// cout << ind << ' ' << dsu_find(ind) << ' ' << sz[ind] << endl;\n\t\tif (sz[ind] == n) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint dsu_find(int x) {\n\tif (x == parent[x]) {\n\t\treturn x;\n\t}\n\tparent[x] = dsu_find(parent[x]);\n\treturn parent[x];\n}\n\nvoid dsu_join(int x, int y) {\n\tx = dsu_find(x);\n\ty = dsu_find(y);\n\tif (x == y) {\n\t\treturn;\n\t}\n\tif (sz[x] < sz[y]) {\n\t\tparent[x] = y;\n\t\tsz[y] += sz[x];\n\t} else {\n\t\tparent[y] = x;\n\t\tsz[x] += sz[y];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\nstruct uf{\n  static const int MAXN=100005;\n  int par[MAXN];\n  lint size[MAXN];\n  void init(int n,int* ar){\n    memset(par,-1,sizeof(par));\n    REP(i,n) size[i]=ar[i];\n  }\n  int root(int a){\n    if(par[a]==-1) return a;\n    return par[a]=root(par[a]);\n  }\n  void unite(int a,int b){\n    a=root(a);b=root(b);\n    if(a==b) return;\n\n    par[b]=a;\n    size[a]+=size[b];\n  }\n  bool same(int a,int b){\n    return root(a)==root(b);\n  }\n};\n\nuf u;\n\nconst lint INF=1e18;\nint n,m;\nint A[100005],B[100005];\nvector<int> g[100005];\n\n\nvoid ijk(int V,lint L){\n  priority_queue<pair<pi,int>,vector<pair<pi,int> >,greater<pair<pi,int> > >pq;\n  pq.push({{A[V],V},-1});\n  while(!pq.empty()){\n    pair<pi,int> cur=pq.top();pq.pop();\n    int v=cur.fr.sc,w=cur.fr.fr;\n    int p=cur.sc;\n    if(w>L){\n      break;\n    }\n    if(u.same(v,p)) continue;\n    L+=u.size[u.root(v)];\n    if(~p){\n      u.unite(v,p);\n    }\n    for(auto to:g[v]){\n      pq.push({{A[to],to},v});\n    }\n  }\n}\nbool check(lint L){\n  u.init(n,B);\n  REP(i,n) if(u.root(i)==i && u.size[i]==B[i] && A[i]<=L){\n    ijk(i,L);\n  }\n\n  REP(i,n) if(!u.same(i,0)) return false;\n  return true;\n}\nint main(){\n  cin>>n>>m;\n  REP(i,n){\n    scanf(\"%d%d\",&A[i],&B[i]);\n    A[i]=max(0,A[i]-B[i]);\n  }\n  REP(i,m){\n    int a,b;scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n\n  lint lb=-1,ub=1e15;\n  while(ub-lb>1){\n    lint md=(lb+ub)>>1;\n    if(check(md)) ub=md;\n    else lb=md;\n  }\n\n  lint res=ub+accumulate(B,B+n,0ll);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long giant;\ninline char nchar() {\n\tstatic const int bufl=1<<20;\n\tstatic char buf[bufl],*a=NULL,*b=NULL;\n\treturn a==b && (b=(a=buf)+fread(buf,1,bufl,stdin),a==b)?EOF:*a++;\n}\ninline int read() {\n\tint x=0,f=1;\n\tchar c=nchar();\n\tfor (;!isdigit(c);c=nchar()) if (c=='-') f=-1;\n\tfor (;isdigit(c);c=nchar()) x=x*10+c-'0';\n\treturn x*f;\n}\ntemplate<typename T> inline T& Min(T &x,const T &y) {return x>y?(x=y):x;}\nconst int maxn=1e5+1;\nint n,m,A[maxn],B[maxn],C[maxn],ord[maxn];\nnamespace uns {\n\tint f[maxn];\n\tvoid init() {\n\t\tiota(f+1,f+n+1,1);\n\t}\n\tint find(int x) {\n\t\treturn x==f[x]?x:(f[x]=find(f[x]));\n\t}\n\tvoid merge(int x,int y) {\n\t\tx=find(x),y=find(y);\n\t\tf[y]=x;\n\t}\n}\nnamespace tree {\n\tvector<int> g[maxn];\n\tgiant f[maxn],sum[maxn];\n\tinline void add(int x,int y) {\n\t\tg[x].push_back(y);\n\t}\n\tvoid dfs(int x) {\n\t\tgiant &sm=sum[x]=B[x];\n\t\tgiant &fx=f[x]=LLONG_MAX;\n\t\tif (g[x].empty()) {\n\t\t\tfx=C[x]+B[x];\n\t\t\treturn;\n\t\t}\n\t\tfor (const int &v:g[x]) {\n\t\t\tdfs(v);\n\t\t\tsm+=sum[v];\n\t\t}\n\t\tfor (const int &v:g[x]) Min(fx,sm-sum[v]+max<giant>(C[x],f[v]));\n\t}\n\tgiant work(int s) {\n\t\tdfs(s);\n\t\treturn f[s];\n\t}\n}\nnamespace graph {\n\tvector<int> g[maxn];\n\tbool vis[maxn];\n\tinline void add(int x,int y) {\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tvoid work(int x) {\n\t\tvis[x]=true;\n\t\tfor (const int &v:g[x]) if (vis[v]) {\n\t\t\tint k=uns::find(v);\n\t\t\tif (k==x) continue;\n\t\t\ttree::add(x,k);\n\t\t\tuns::merge(x,k);\n\t\t}\n\t}\n}\nint main() {\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i) {\n\t\tA[i]=read(),B[i]=read();\n\t\tC[i]=max(A[i]-B[i],0);\n\t\tord[i]=i;\n\t}\n\tuns::init();\n\tfor (int i=1;i<=m;++i) graph::add(read(),read());\n\tsort(ord+1,ord+n+1,[](int x,int y)->bool{return C[x]<C[y];});\n\tfor (int i=1;i<=n;++i) graph::work(ord[i]);\n\tgiant ans=tree::work(ord[n]);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N=110000;\nint father[N];\nlong long sum[N],w[N];\nint n,m,A[N],B[N],pos[N],in[N];\nint findfather(int k1){\n\tif (father[k1]==k1) return k1; return father[k1]=findfather(father[k1]);\n}\nvector<int> go[N];\nint compare(int k1,int k2){\n\treturn A[k1]<A[k2];\n}\nint pd[N],sign;\nvector<int> C;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&A[i],&B[i]);\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2);\n\t\tgo[k1].push_back(k2);\n\t\tgo[k2].push_back(k1);\n\t}\n\tfor (int i=1;i<=n;i++) pos[i]=i,father[i]=i;\n\tsort(pos+1,pos+n+1,compare);\n\tfor (int i=1;i<=n;i++){\n\t\tint k1=pos[i]; sign++; C.clear();\n\t\tfor (int j=0;j<go[k1].size();j++){\n\t\t\tint k2=go[k1][j];\n\t\t\tif (in[k2]){\n\t\t\t\tint root=findfather(k2);\n\t\t\t\tif (pd[root]!=sign){\n\t\t\t\t\tpd[root]=sign; C.push_back(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<C.size();j++){\n\t\t\tfather[C[j]]=k1;\n\t\t\tsum[k1]+=sum[C[j]];\n\t\t} in[k1]=1;\n\t\tw[k1]=max(A[k1]-B[k1],0);\n\t\tfor (int j=0;j<C.size();j++)\n\t\t\tw[k1]=min(w[k1],max(1ll*max(A[k1]-B[k1],0)-sum[C[j]]-w[C[j]],0ll)+w[C[j]]);\n\t\tsum[k1]+=B[k1];\n\t\t//cout<<k1<<\" \"<<w[k1]<<\" \"<<B[k1]<<endl;\n\t\t//for (int j=0;j<C.size();j++) cout<<C[j]<<\" \"; cout<<endl;\n\t}\n\tprintf(\"%lld\\n\",w[findfather(1)]+sum[findfather(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,m,a[maxn],b[maxn],c[maxn],x[maxn],dsu[maxn];\nll sum[maxn],f[maxn];\nvector<int> g[maxn];\nbool vis[maxn];\n\ninline bool cmp(int a,int b){\n\treturn c[a]<c[b];\n}\nint find(int x){\n\treturn dsu[x]==x?x:dsu[x]=find(dsu[x]);\n}\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[i]>>b[i];\n\t\tc[i]=max(a[i]-b[i],0);\n\t\tx[i]=i;\n\t\tdsu[i]=i;\n\t}\n\tfor(int i=1,u,v;i<=m;++i){\n\t\tcin>>u>>v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tsort(x+1,x+n+1,cmp);\n\tfor(int i=1;i<=n;++i){\n\t\tint pos=x[i];\n\t\tsum[pos]=b[pos];\n\t\tf[pos]=c[pos];\n\t\tvis[pos]=true;\n\t\tfor(int j=0,v;j<g[pos].size();++j)\n\t\t\tif(vis[v=find(g[pos][j])]&&v!=find(pos)){\n\t\t\t\tdsu[v]=pos;\n\t\t\t\tsum[pos]+=sum[v];\n\t\t\t\tf[pos]=min(f[pos],max(f[v],c[pos]-sum[v]));\n\t\t\t}\n\t}\n\tcout<<sum[find(1)]+f[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define ivorysi\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eps 1e-8\n#define mo 974711\n#define MAXN 100005\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE,id[MAXN],ra[MAXN],f[MAXN];\nint64 A[MAXN],B[MAXN],C[MAXN],dp[MAXN],siz[MAXN];\nvector<int> son[MAXN];\nint getfa(int x) {\n    return f[x] == x ? x : f[x] = getfa(f[x]);\n}\nbool cmp(int a,int b) {\n    return C[a] <= C[b];\n}\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    read(N);read(M);\n    for(int i = 1 ; i <= N ; ++i) {\n\tread(A[i]);read(B[i]);C[i] = max(A[i] - B[i],0LL);\n\tid[i] = i;\n    }\n    sort(id + 1,id + N + 1,cmp);\n    for(int i = 1 ; i <= N ; ++i) ra[id[i]] = i;\n    int u,v;\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(u);read(v);\n\tadd(u,v);add(v,u);\n    }\n}\nvoid dfs1(int u) {\n    siz[u] += B[u];\n    for(auto v : son[u]) {\n\tdfs1(v);\n\tsiz[u] += siz[v];\n    }\n}\nvoid dfs2(int u) {\n    if(son[u].size() == 0) {\n\tdp[u] = B[u] + C[u];\n\treturn;\n    }\n    dp[u] = 1e18;\n    for(auto v : son[u]) {\n\tdfs2(v);\n\tdp[u] = min(siz[u] - siz[v] + max(C[u],dp[v]),dp[u]);\n    }\n}\nvoid Solve() {\n    for(int i = 1 ; i <= N ; ++i) f[i] = i;\n    for(int i = 1 ; i <= N ; ++i) {\n\tint u = id[i];\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(ra[getfa(v)] < ra[u] && getfa(v) != u) {\n\t\tson[u].pb(getfa(v));\n\t\tf[getfa(v)] = u;\n\t    }\n\t}\n    }\n    dfs1(id[N]);\n    dfs2(id[N]);\n    out(dp[id[N]]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.05.2018 15:10:27       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n  public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  vector<vector<int>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  vector<int> add(n);\n  iota(add.begin(), add.end(), 0);\n  sort(add.begin(), add.end(), [&](int i, int j) {\n    return a[i] - b[i] < a[j] - b[j];\n  });\n  dsu d(n);\n  vector<long long> sum_b(n);\n  vector<long long> ans(n);\n  for (int i = 0; i < n; i++) {\n    sum_b[i] = b[i];\n    ans[i] = max(a[i], b[i]);\n  }\n  vector<int> was(n, 0);\n  for (int i : add) {\n    set<int> s;\n    for (int j : graph[i]) {\n      if (was[j]) {\n        s.insert(d.get(j));\n      }\n    }\n    for (int j : s) {\n      sum_b[i] += sum_b[j];\n      d.unite(j, i);\n    }\n    if (!s.empty()) {\n      long long best = (long long) 1e18;\n      for (int j : s) {\n        long long sum_b_without = sum_b[i] - sum_b[j];\n        long long cur = max(ans[j] + sum_b_without, a[i] + sum_b_without - b[i]);\n        best = min(best, cur);\n      }\n      ans[i] = best;\n    }\n    was[i] = 1;\n  }\n  cout << ans[d.get(0)] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n#define VEC(TYPE, A, NAME, INIT) vector<TYPE> NAME(A, INIT)\n#define VEC2(TYPE, A, B, NAME, INIT) vector<vector<TYPE>> NAME(A, vector<TYPE>(B, (INIT)))\n#define cInf 9e18\n\nclass UnionFind\n{\n  public:\n\texplicit UnionFind(ll size)\n\t\t: mParent(size, -1)\n\t\t, mRank(size, 0)\n        , mData(size, -1)\n\t\t, mData2(size, -1)\n\t\t{}\n\tbool unionSet(ll x, ll y)\n\t{\n\t\tif ((x = root(x)) == (y = root(y)))\n\t\t\treturn false;\n\t\tif( mRank[x] < mRank[y] )\n\t\t{\n\t\t\tmParent[y] += mParent[x];\n\t\t\tmParent[x] = y;\n            unionData( mData[y], mData[x] );\n\t\t\tmData2[y] += mData2[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmParent[x] += mParent[y];\n\t\t\tmParent[y] = x;\n\t\t\tif( mRank[x] == mRank[y] ) ++mRank[x];\n            unionData( mData[x], mData[y] );\n\t\t\tmData2[x] += mData2[y];\n\t\t}\n\t\treturn true;\n\t}\n\tbool isEqualSet(ll x, ll y)\n\t{\n\t\treturn root(x) == root(y);\n\t}\n\tll root(ll x)\n\t{\n\t\treturn mParent[x] < 0 ? x : mParent[x] = root(mParent[x]);\n\t}\n\tll size(ll x)\n\t{\n\t\treturn -mParent[root(x)];\n\t}\n\n    void unionData( ll& parent, ll& child )\n    {\n        parent = max( parent, child );\n    }\n    void setData( ll x, ll data )\n    {\n        mData[root(x)] = data;\n    }\n    ll getData( ll x )\n    {\n        return mData[root(x)];\n    }\n\tvoid setData2( ll x, ll data2 )\n\t{\n\t\tmData2[root(x)] = data2;\n\t}\n\tll getData2( ll x )\n\t{\n\t\treturn mData2[root(x)];\n\t}\n\n  public:\n\tvector<ll> mParent; // = mSize\n\tvector<ll> mRank;\n\tvector<ll> mData;\n\tvector<ll> mData2;\n};\n\nstruct Node{\n    ll a = 0;\n    ll b = 0;\n\tll c = 0;\n\tll idx = 0;\n};\nbool operator<(const Node& l, const Node& r)\n{ return l.c != r.c ? l.c < r.c : l.idx < r.idx; }\nbool operator>(const Node& l, const Node& r)\n{ return l.c != r.c ? l.c > r.c : l.idx > r.idx; }\n\nint main()\n{\n    ll n, m;\n    cin >> n >> m;\n\tVEC( Node, n, node, Node() );\n\tREP(i,n)\n\t{\n\t\tnode[i].idx = i;\n\t\tcin >> node[i].a >> node[i].b;\n\t\tnode[i].c = max( 0ll, node[i].a-node[i].b );\n\t}\n\tvector< vector<ll> > edge(n);\n\tREP( i, m )\n\t{\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tedge[a-1].push_back( b-1 );\n\t\tedge[b-1].push_back( a-1 );\n\t}\n\n\tsort( ALL(node) );\n\n\tUnionFind uf(n);\n\tREP( i,n )\n\t{\n\t\tauto& nod = node[i];\n\t\tuf.setData2( nod.idx, nod.b );\n\t\tll dataMin = cInf;\n\t\tvector<ll> vec;\n\t\tfor( auto e : edge[nod.idx] )\n\t\t{\n\t\t\tif( uf.getData(e) < 0 )\n\t\t\t{ continue; }\n\t\t\tbool is = false;\n\t\t\tfor( auto v : vec )\n\t\t\t{\n\t\t\t\tif( uf.root(e) == uf.root(v) )\n\t\t\t\t{ is = true; break; }\n\t\t\t}\n\t\t\tif( !is ){ vec.push_back( e ); }\n\t\t}\n\t\tfor( auto e : vec )\n\t\t{\n\t\t\tauto data = uf.getData(e);\n\t\t\tdata = nod.c <= data ? data + nod.b : nod.a;\n\t\t\tfor( auto e2 : vec )\n\t\t\t{\n\t\t\t\tif( uf.root(e) != uf.root(e2) )\n\t\t\t\t{\n\t\t\t\t\tdata += uf.getData2( e2 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tdataMin = min( dataMin, data );\n\t\t}\n\t\t\n\t\tif( dataMin == cInf )\n\t\t{\n\t\t\tdataMin = max( nod.a, nod.b );\n\t\t}\n\t\tuf.setData( nod.idx, dataMin );\n\t\t\n\t\tfor( auto e : vec )\n\t\t{\n\t\t\tuf.unionSet( nod.idx, e );\n\t\t}\n\t}\n\t\n\tcout << uf.getData(0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Use[n] == 0)\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total += B[n];\n                            break;\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 10000000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nstruct edge{\n\tint to,next;\n}e[N*2];\nint n,m,tot,head[N];\nint a[N],b[N],id[N],fa[N];\nlong long qd[N],S[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint get(int x){\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint vis[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tid[i]=i,fa[i]=i,qd[i]=a[i],S[i]=b[i]; \n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint x=id[i]; vis[x]=1;\n\t\tfor (int j=head[x];j;j=e[j].next)\n\t\t\tif (vis[e[j].to]){\n\t\t\t\tint X=get(x),Y=get(e[j].to);\n\t\t\t\tif (X==Y) continue;\n\t\t\t\tfa[Y]=X; S[X]+=S[Y];\n\t\t\t\tqd[X]=min(qd[X],qd[Y]+max(0ll,a[x]-S[Y]-qd[Y]));\n\t\t\t}\n\t}\n\tint x=get(1);\n\tprintf(\"%lld\",qd[x]+S[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,u,v,a[100001],b[100001],c[100001],s[100001],d[100001];\nlong long x[100001][481],y[100001][481],f[100001],sr[100001];\nbool bo[100001];\ninline long long read()\n{\n    long long sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(long long x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(long long x,long long y)\n{\n\treturn c[x]<c[y];\n}\ninline long long find(long long x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(long long u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register long long i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u][++x[u][0]]=v;\n\t\tx[v][++x[v][0]]=u;\n\t}\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\tlong long u=d[i];\n\t\tfor (register long long j=1;j<=x[u][0];++j)\n\t\t{\n\t\t\tlong long v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u][++y[u][0]]=vv;\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    friend bool operator< (Info a , Info b)  {return a.cost < b.cost;}\n};\n\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nvoid unlock(int x) ;\nvoid merge(int x , int y) ;\n\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) unlock(y);\n            else {\n                out[p].insert(y);\n                modifycost(y , (int)max(limit[y] - money[p] , 0LL));                \n            }\n        }\n    }\n}\n\n\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n    while(out[y].size()) {\n        x = *out[y].begin();\n        if(find(x) == y) {\n            out[y].erase(*out[y].begin());\n            continue;\n        }\n        if(money[y] + init >= limit[x]) {\n            out[y].erase(*out[y].begin());\n            unlock(x);\n            y = find(y);\n            continue;\n        }\n        modifycost(x , (int)max(limit[x] - money[y] , 0LL));\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing P = pair<ll, int>;\n\nint n;\nVV<int> g;\nV<ll> lw, us;\n\nV<set<P>> gx;\n\nV<int> ig;\nVV<int> gi;\nvoid uf_init() {\n    ig = V<int>(n); gi = VV<int>(n);\n    for (int i = 0; i < n; i++) {\n        ig[i] = i; gi[i] = {i};\n    }\n}\n\nbool uf_same(int a, int b) {\n    return ig[a] == ig[b];\n}\n\nvoid uf_merge(int a, int b) {\n    if (uf_same(a, b)) return;\n    int x = ig[a], y = ig[b];\n    if (gi[x].size() < gi[y].size()) swap(x, y);\n    for (int j: gi[y]) {\n        ig[j] = x;\n    }\n    gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n    gi[y].clear();\n\n    us[x] += us[y];\n    us[y] = 0;\n\n    if (gx[x].size() > gx[y].size()) swap(gx[x], gx[y]);\n    for (auto d: gx[y]) {\n        gx[x].insert(d);\n    }\n    gx[y].clear();\n}\n\nll ans;\nV<bool> vis;\npriority_queue<P, V<P>, greater<P>> que;\n\nvoid on(int p) {\n    vis[p] = true;\n    for (int d: g[p]) {\n        if (vis[d]) {\n            uf_merge(p, d);\n        }\n    }\n    int x = ig[p];\n    while (gx[x].size()) {\n        auto tp = *(gx[x].begin());\n        gx[x].erase(gx[x].begin());\n        if (vis[tp.second]) continue;\n        if (tp.first <= ans+us[x]) {\n            on(tp.second);\n            break;\n        } else {\n            que.push(P(tp.first - us[x], tp.second));\n            break;\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int m;\n    cin >> n >> m;\n    g = VV<int>(n);\n    lw = V<ll>(n); us = V<ll>(n);\n    ll off = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> lw[i] >> us[i]; lw[i] -= us[i];\n        off += us[i];\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b); g[b].push_back(a);\n    }\n    uf_init();\n    \n    gx = V<set<P>>(n);\n    for (int i = 0; i < n; i++) {\n        for (int d: g[i]) {\n            gx[i].insert(P(lw[d], d));\n        }\n    }\n    vis = V<bool>(n);\n\n    for (int i = 0; i < n; i++) {\n        que.push(P(lw[i], i));\n    }\n    \n    ans = 0;\n    while (que.size()) {\n        P tp = que.top(); que.pop();\n        int p = tp.second;\n        if (vis[p]) continue;\n        ans = max(ans, tp.first);\n        on(p);\n    }\n    cout << ans+off << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing db = double;\nusing vi = vector<int>;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define debug(x) cout << #x <<'\t' << x <<endl\nconst int inf = 0x3f3f3f3f;\nconst db eps = 1e-8;\nconst int mod = 1e9+7;\nll qpow(ll a, ll b){\n    ll ret = 1;\n    while(b){\n        if(b&1)ret = ret*a%mod;\n        a = a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\n\nconst int maxn = 200010;\nint n, m;\nll a[maxn], b[maxn], sum[maxn], f[maxn], p[maxn], dp[maxn], vis[maxn];\nint Find(int x){\n\treturn f[x] == x?x:f[x]=Find(f[x]);\n} \nvector<int>G[maxn];\nbool cmp(int x, int y){\n\treturn a[x] < a[y];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; ++i){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i]-b[i], 0ll);\n\t\tp[i] = f[i] = i;\n\t\tsum[i] = b[i];\n\t\tdp[i] = a[i];\n\t}\n\tfor(int i=0, u, v; i<m; ++i){\n\t\tcin >> u >> v;\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tsort(p+1, p+1+n, cmp);\n\tfor(int i=1; i<=n; ++i){\n\t\tint u = p[i];\n\t\tvis[u] = 1;\n\t\tfor(auto v:G[u]){\n\t\t\tif(vis[v]){\n\t\t\t\tint x = Find(u), y = Find(v);\n\t\t\t\tif(x!=y){\n\t\t\t\t\tf[y] = x;\n\t\t\t\t\tsum[x] += sum[y];\n\t\t\t\t\tdp[x] = min(dp[x], max(dp[y], a[x]-sum[y]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\tcout << dp[Find(1)] + sum[Find(1)] <<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N=100005;\nLL n,m; \nstruct qq\t{LL a,b,id;}s[N];\nLL fa[N];\nLL find_fa (LL x)\t{return fa[x]==x?x:fa[x]=find_fa(fa[x]);}\nbool cmp (qq x,qq y)\t{return x.a<y.a;}\nLL id[N];\nbool vis[N];\nvector<LL> vec[N],e[N];\nbool tf;\nLL tot[N];\nvoid dfs (LL x,LL lim)\n{\n\t//printf(\"YES:%lld %lld %lld\\n\",x,lim,lim-(tot[x]-s[x].b));\n\tif (lim-(tot[x]-s[x].b)>=max(s[x].a,s[x].b))\t{tf=true;return ;}\n\tLL siz=vec[x].size();\n\tfor (LL u=0;u<siz;u++)\n\t{\n\t\tLL y=vec[x][u];\n\t\tLL t=lim-(tot[x]-tot[y]-s[x].b);\n\t\tif (t>=max(s[x].b,s[x].a)) dfs(y,t-s[x].b);\n\t}\n}\nvoid dfs1 (LL x)\n{\n\ttot[x]=s[x].b;\n\tLL siz=vec[x].size();\n\tfor (LL u=0;u<siz;u++)\t{dfs1(vec[x][u]);tot[x]=tot[x]+tot[vec[x][u]];}\n}\nint main()\n{\n//\tfreopen(\"rescue.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (LL u=1;u<=n;u++) fa[u]=u,vis[u]=false;\n\tLL l=0,r=0,lalal=-1;\n\tfor (LL u=1;u<=n;u++)\t\n\t{\n\t\tscanf(\"%lld%lld\",&s[u].a,&s[u].b);\n\t\tl=l+s[u].b;\n\t\tr=r+s[u].a+s[u].b;\n\t\ts[u].id=u;\n\t}\n\tsort(s+1,s+1+n,cmp);\n\tfor (LL u=1;u<=n;u++) id[s[u].id]=u;\n\tfor (LL u=1;u<=m;u++)\n\t{\n\t\tLL x,y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx=id[x];y=id[y];\n\t\te[x].push_back(y);e[y].push_back(x);\n\t}\n\t//printf(\"YES!\\n\");\n\tfor (LL u=1;u<=n;u++)\n\t{\n\t\tLL siz=e[u].size();vis[u]=true;\n\t\tfor (LL i=0;i<siz;i++)\n\t\t{\n\t\t\tLL y=find_fa(e[u][i]);\n\t\t\tif (vis[y]==false) continue;\n\t\t\tif (y==u) continue;\n\t\t\tfa[y]=u;vec[u].push_back(y);\n\t\t\t//printf(\"link:%lld %lld\\n\",u,y);\n\t\t}\n\t}\n\tdfs1(n);\n\t/*for (LL u=1;u<=n;u++) printf(\"%lld %lld\\n\",s[u].a,s[u].b);\n\tfor (LL u=1;u<=n;u++) printf(\"%lld \",tot[u]);printf(\"\\n\");*/\n//\tprintf(\"YES:%lld %lld\\n\",l,r);\n\twhile (l<=r)\n\t{\n\t\tLL mid=(l+r)>>1;\n\t\ttf=false;dfs(n,mid);\n\t\tif (tf)\t{lalal=mid;r=mid-1;}\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",lalal);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fir first\n#define sec second\n#define db double\n#define ll long long\n#define ev eg[i].v\n#define pb push_back\n#define INF 1000000007\n#define pir pair<int,int>\n#define Rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define RepD(i,r,l) for(int i=(r);i>=(l);--i)\n#define RepG(i,x) for(int i=hd[x];i;i=eg[i].nxt)\nusing namespace std;\n\nconst int N=1e5+5;\n\nint hd[N],cnt=0;bool vis[N];\nstruct Eg{int v,nxt;}eg[N*2];\nint a[N],b[N],c[N],fa[N],f[N],g[N];\n\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid add(int u,int v){eg[++cnt]=(Eg){v,hd[u]},hd[u]=cnt;}\n\nbool cmp(int x,int y){return a[x]<a[y];}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tRep(i,1,n) scanf(\"%d%d\",&a[i],&b[i]),a[i]=max(a[i]-b[i],0);\n\tRep(i,1,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v),add(v,u);\t\n\t}\n\tRep(i,1,n) c[i]=fa[i]=i;\n\tsort(c+1,c+n+1,cmp);\n\tRep(k,1,n){\n\t\tint x=c[k];\n\t\tvis[x]=1,f[x]=a[x],g[x]=b[x];\n\t\tRepG(i,x)\n\t\t\tif(vis[ev]){\n\t\t\t\tint ff=find(ev);\n\t\t\t\tif(x==ff) continue;\n\t\t\t\tfa[ff]=x,g[x]+=g[ff];\n\t\t\t\tf[x]=min(f[x],max(f[ff],a[x]-g[ff]));\t\n\t\t\t}\n\t}\n\tprintf(\"%d\\n\",f[c[n]]+g[c[n]]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n/// {{{ DEBUG --- ///\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { if(&o == &cerr) { o << '{'; for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \", \" : \"\"); o << \"}\"; } else { for(size_t i = 0; i < v.size(); i++) o << v[i] << (i + 1 != v.size() ? \" \" : \"\"); } return o; }\n#ifdef DEBUG\n#ifdef USE_COUT\n#define dump(...) (cout<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#else\n#define dump(...) (cerr<<\"[\"<<__LINE__<< \"] \"<<#__VA_ARGS__<<\" = \"<<make_tuple(__VA_ARGS__)<<\"\\n\")\n#endif\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\n#else\n#define dump(...) (0)\n#endif\n/// }}}--- ///\n\n/// --- Union Find Library {{{ ///\n\nstruct UF {\n  int n;\n  vector<int> par, rank;\n  UF(int n): n(n), par(n, -1), rank(n, 0) {}\n  int find(int x) {\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n  int size(int x) {\n    return -par[find(x)];\n  }\n  bool same(int a, int b) {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if(a == b) return;\n    if(rank[a] > rank[b]) swap(a, b);\n    par[b] += par[a];\n    par[a] = b;\n    if(rank[a] == rank[b]) rank[b]++;\n  }\n};\n\n/// }}}--- ///\n\nconst int N = 1e5;\nvector<int> g[N];\nint n, m;\nint a[N], b[N], c[N];\nll sumb[N];\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n >> m;\n  for(int i = 0; i < n; i++) cin >> a[i] >> b[i], c[i] = a[i] - b[i];\n  for(int i = 0; i < m; i++) {\n    int a, b; cin >> a >> b;\n    a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  vector<int> ord(n);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), [&](int a, int b) {\n    return c[a] < c[b];\n  });\n  UF uf(n);\n  ll ans[N] = {};\n  bool used[N] = {};\n  for(int i = 0; i < n; i++) {\n    int id = ord[i];\n    used[id] = 1;\n    ll nsumb = b[id];\n    ll nans = 1e18;\n    set<int> go;\n    for(int j : g[id]) if(used[j] && !go.count(uf.find(j))) {\n      nsumb += sumb[uf.find(j)];\n      go.emplace(uf.find(j));\n    }\n    for(int gj : go) {\n      if(ans[gj] < c[id]) {\n        nans = min(nans, c[id] + nsumb - sumb[gj]);\n      } else {\n        dump(ans[gj], sumb[gj], nsumb);\n        nans = min(nans, ans[gj] - sumb[gj] + nsumb);\n      }\n    }\n    for(int j : g[id]) if(used[j]) {\n      uf.unite(id, j);\n    }\n    if(nans == 1e18) nans = max(a[id], b[id]);\n    ans[uf.find(id)] = nans;\n    sumb[uf.find(id)] = nsumb;\n    dump(id + 1, c[id], b[id], nans, nsumb);\n  }\n  cout << ans[uf.find(ord[n-1])] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->S<=val[u]){\n        q.push({u,s[u].begin()->F});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5;\nint n, m;\nll a[maxn + 10], b[maxn + 10];\nvector<int> g[maxn + 10];\nint fa[maxn + 10];\nll sum[maxn + 10], f[maxn + 10];\nint id[maxn + 10];\nbool vis[maxn + 10];\n\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\n\nint getf(int p) {\n\treturn fa[p] == p ? p : fa[p] = getf(fa[p]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\ta[i] = max(a[i] - b[i], 0ll);\n\t\tsum[i] = b[i]; id[i] = fa[i] = i;\n\t}\n\tsort(id + 1, id + n + 1, cmp);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tg[l].push_back(r); g[r].push_back(l);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint p = id[i]; vis[p] = 1;\n\t\tbool fd = 1;\n\t\tf[p] = 1e18;\n\t\tfor (int j = 0; j < (int)g[p].size(); ++j) {\n\t\t\tint e = g[p][j];\n\t\t\tif (vis[e]) {\n\t\t\t\te = getf(e);\n\t\t\t\tif (e != p) {\n\t\t\t\t\tfa[e] = p; sum[p] += sum[e];\n\t\t\t\t\tf[p] = min(f[p], max(a[p], f[e]) - sum[e]);\n\t\t\t\t\tfd = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fd) f[p] = 0;\n\t\tf[p] += sum[p];\n\t}\n\tprintf(\"%lld\", f[id[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tdfs(root,0);\n\tprintf(\"%lld\",need[root]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\nconst int Max_M(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nint N, M, B[Max_N], C[Max_N], P[Max_N], Father[Max_N], X[Max_N], Head[Max_N], Total, To[Max_M << 1], Next[Max_M << 1];\nLL F[Max_N], Sum[Max_N];\n\ninline bool comp(int a, int b)\n{\n\treturn C[a] < C[b];\n}\n\ninline void Add_Edge(int s, int t)\n{\n\t++Total, To[Total] = t, Next[Total] = Head[s], Head[s] = Total;\n}\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N), gi(M);\n\tfor (int i = 1, a;i <= N;++i)\n\t\tgi(a), gi(B[i]), C[i] = max(a - B[i], 0), P[i] = i;\n\tfor (int u, v;M--;)\n\t\tgi(u), gi(v), Add_Edge(u, v), Add_Edge(v, u);\n\tsort(P + 1, P + 1 + N, comp);\n\tfor (int pos = 1, u;pos <= N;++pos)\n\t{\n\t\tu = P[pos], Father[u] = u, Sum[u] = B[u], X[0] = 0;\n\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\tif (Father[v = To[i]])\n\t\t\t\tX[++X[0]] = Get_Father(v);\n\t\tsort(X + 1, X + 1 + X[0]), X[0] = unique(X + 1, X + 1 + X[0]) - (X + 1);\n\t\tfor (int i = 1;i <= X[0];++i)\n\t\t\tSum[u] += Sum[X[i]], Father[X[i]] = u;\n\t\tif (!X[0])\n\t\t\tF[u] = B[u] + C[u];\n\t\telse\n\t\t{\n\t\t\tF[u] = 0X3F3F3F3F3F3F3F3FLL;\n\t\t\tfor (int i = 1;i <= X[0];++i)\n\t\t\t\tF[u] = min(F[u], Sum[u] - Sum[X[i]] + max(C[u] * 1LL, F[X[i]]));\n\t\t}\n\t}\n\tprint(F[Get_Father(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = max(0LL, A[i]-B[i]);\n\t\tVs[i].ss = -i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = -Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne?\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int, int>> L;\nvector<int> X[1 << 17], Y[1 << 17];\nMergeTech UF1, UF2;\nbool used[1 << 17];\n\nvoid dfs1(int pos) {\n\tused[pos] = true; Subtree[pos] += B[pos];\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tY[pos].push_back(X[pos][i]);\n\t\tdfs1(X[pos][i]);\n\t\tSubtree[pos] += Subtree[X[pos][i]];\n\t}\n}\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\t\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) scanf(\"%lld%lld\", &A[i], &B[i]);\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\t\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tX[r1].push_back(r2);\n\t\t\tX[r2].push_back(r1);\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\tdfs1(I[I.size() - 1].second);\n\n\tdfs(I[I.size() - 1].second, 600);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = max(0LL, A[i]-B[i]);\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\n\t\tif(sz > 1) for(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tcat w_mi = max(A[c]+s, B[c]+s+W[comp_adj[j]])-1, w_mx = W[c];\n\t\t\tif(w_mx <= w_mi+1) continue;\n\t\t\tvector< pair<cat, cat> > Vs;\n\t\t\tfor(int k = 0; k < sz; k++)\n\t\t\t\tif(k != j) Vs.push_back(make_pair(W[comp_adj[k]], sumB[comp_adj[k]]));\n\t\t\tsort(begin(Vs), end(Vs));\n\t\t\tvector<bool> vis(sz-1);\n\t\t\tint a = sz-1;\n\t\t\twhile(w_mx-w_mi > 1) {\n\t\t\t\tcat w_cur = (w_mi + w_mx) / 2;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int l = sz-2; l >= 0; l--) {\n\t\t\t\t\tif(vis[l]) continue;\n\t\t\t\t\tif(Vs[l].ff > w_cur) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta = min(a, l-1);\n\t\t\t\t\tif(a >= 0 && Vs[a].ff > w_cur-Vs[l].ss) {\n\t\t\t\t\t\tvis[a] = true;\n\t\t\t\t\t\tw_cur -= Vs[a].ss;\n\t\t\t\t\t\ta--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvis[l] = true;\n\t\t\t\t\tw_cur -= Vs[l].ss;\n\t\t\t\t}\n\t\t\t\tif(ok) w_mx = (w_mi + w_mx) / 2;\n\t\t\t\telse w_mi = (w_mi + w_mx) / 2;\n\t\t\t}\n\t\t\t// cout << j << \" \" << i << endl;\n\t\t\tW[c] = min(W[c], w_mx);\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\t\telse {\n\t\t\tW[c] = min(W[c], max(m+B[c], max(A[c], B[c]+s)));\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nclass UnionFind{\nprivate:\n  vector<int> node;\n\npublic:\n  UnionFind(int n){\n    node=vector<int>(n);\n    iota(all(node),0);\n  }\n  int root(int x){\n    if(node[x]==x) return x;\n    else return node[x]=root(node[x]);\n  }\n  bool uni(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    node[y]=x;\n    return true;\n  }\n};\n\nstruct sta{\n  LL cost;\n  LL w; \n  LL totalb;\n};\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<LL> a(n), b(n);\n  rep(i,n) cin >> a[i] >> b[i];\n  vector<vector<int>> e(n);\n  int u,v;\n  rep(i,m){\n    cin >> u >> v;\n    e[u-1].push_back(v-1);\n    e[v-1].push_back(u-1);\n  }\n  vector<int> p(n);\n  iota(all(p), 0);\n  sort(all(p),[&](const int &l, const int &r){\n    return a[l]-b[l] < a[r]-b[r];\n  });\n  vector<bool> merged(n, false);\n  UnionFind uf(n);\n  vector<sta> tmp(n);\n  rep(i,n){\n    int x = p[i];\n    merged[x] = true;\n    LL mic = LINF;\n    for(auto ad:e[x]){\n      if(!merged[ad]) continue;\n      ad = uf.root(ad);\n      if(tmp[ad].cost+max(a[x]-b[x]-tmp[ad].w,0LL) < mic){\n        mic = tmp[ad].cost+max(a[x]-b[x]-tmp[ad].w,0LL);\n      }\n    }\n    sta now = {0, 0, 0};\n    if(mic==LINF) now.cost = max(a[x]-b[x],0LL);\n    else now.cost = mic;\n    now.totalb = b[x];\n    for(auto ad:e[x]){\n      if(!merged[ad]) continue;\n      LL t = tmp[uf.root(ad)].totalb;\n      if(uf.uni(x,ad)){\n        now.totalb+=t;\n      }\n    }\n    now.w = now.cost + now.totalb;\n    tmp[uf.root(x)] = now;\n  }\n  cout << tmp[uf.root(0)].w << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nlong long a[100001],n,m,head[100001],nxt[200001],b[200001],k,fa[100001];\nlong long B[100001],f[100001];\nbool vis[100001];\nvoid push(int s,int t){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n}\nint find(int x){return f[x]?f[x]=find(f[x]):x;}\nstd::pair<int,int>p[100001];\nvoid dfs(int x){\n\tfor(int i=head[x];i;i=nxt[i])dfs(b[i]),B[x]+=B[b[i]];\n\tf[x]=a[x]+B[x];\n\tfor(int i=head[x];i;i=nxt[i])f[x]=std::min(f[x],B[x]-B[b[i]]+std::max(a[x],f[b[i]]));\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",a+i,B+i),a[i]=std::max(a[i]-B[i],0ll),p[i]=std::make_pair(a[i],i);\n\tfor(int i=1,u,v;i<=m;i++)scanf(\"%d%d\",&u,&v),push(u,v),push(v,u);\n\tstd::sort(p+1,p+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=p[i].second;\n\t\tfor(int j=head[u];j;j=nxt[j])\n\t\t\tif(vis[b[j]]&&find(b[j])!=find(u)){\n\t\t\t\tint fu=find(b[j]);\n\t\t\t\tfa[fu]=u;\n\t\t\t\tf[fu]=u;\n\t\t\t}\n\t\tvis[u]=1;\n\t}\n\tmemset(head,0,sizeof head);\n\tk=0;\n\tint root;\n\tfor(int i=1;i<=n;i++)(fa[i])?push(fa[i],i),0:root=i;\n\tdfs(root);\n\tprintf(\"%lld\\n\",f[root]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst LL Infll = 0x3f3f3f3f3f3f3f3f;\nconst int MN = 100005;\n\nint N, M, A[MN], B[MN], P[MN], vis[MN];\nstd::vector<int> G[MN], T[MN];\n\nint fa[MN];\ninline int ff(int x) { return fa[x] ? fa[x] = ff(fa[x]) : x; }\n\nLL f[MN], s[MN];\n\nvoid DFS(int u) {\n\ts[u] = B[u], f[u] = Infll;\n\tfor (auto v : T[u]) DFS(v), s[u] += s[v];\n\tfor (auto v : T[u]) f[u] = std::min(f[u], s[u] - s[v] + std::max((LL)A[u], f[v]));\n\tif (T[u].empty()) f[u] = A[u] + B[u];\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; ++i)\n\t\tscanf(\"%d%d\", &A[i], &B[i]),\n\t\tA[i] = std::max(A[i] - B[i], 0),\n\t\tP[i] = i;\n\tfor (int i = 1, x, y; i <= M; ++i)\n\t\tscanf(\"%d%d\", &x, &y),\n\t\tG[x].push_back(y),\n\t\tG[y].push_back(x);\n\tstd::sort(P + 1, P + N + 1, [](int i, int j) { return A[i] < A[j]; });\n\tfor (int i = 1; i <= N; ++i) {\n\t\tint u = P[i];\n\t\tfor (auto v : G[u])\n\t\t\tif (vis[v] && ff(v) != u)\n\t\t\t\tT[u].push_back(ff(v)),\n\t\t\t\tfa[ff(v)] = u;\n\t\tvis[u] = 1;\n\t}\n\tDFS(P[N]);\n\tprintf(\"%lld\\n\", f[P[N]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nint i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nint tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tint x,y;\n}a[N];\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(int x,int y) {\n\treturn a[x].x<a[y].x;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tint r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=s[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tfor (j=1;j<=r;j++) M=min(M,max(1ll*a[id[i]].x,A[q[j]]+a[id[i]].y)+S-s[q[j]]);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%lld\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,b;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  UnionFind(Int sz,vector<Int> b):n(sz),r(sz,1),p(sz,0),b(b){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    b[x]+=b[y];   \n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int x,y;\n    cin>>x>>y;\n    x--;y--;\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n  }\n  vector<Int> ord(n);\n  iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),\n       [&](Int x,Int y){\n\t return a[x]-b[x]<a[y]-b[y];\n       });\n\n  vector<Int> rev(n);\n  for(Int i=0;i<n;i++) rev[ord[i]]=i;\n\n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  UnionFind uf(n,b);\n  vector<Int> dp(n,0);\n  for(Int v:ord){\n    Int res=a[v]-b[v];\n    for(Int t:G[v]){\n      Int u=uf.find(t);\n      if(rev[u]>rev[v]) continue;\n      chmin(res,max(dp[u],a[v]-(uf.b[u]+b[v])));\n    }\n    //cout<<v<<\":\"<<a[v]-b[v]<<\":\"<<dp[v]<<endl;\n    chmax(res,0);\n    for(Int u:G[v])\n      if(rev[u]<rev[v]) uf.unite(v,u);\n    v=uf.find(v);\n    dp[v]=res;\n  }\n  //cout<<dp[ord[n-1]]<<endl;\n  cout<<s+dp[uf.find(ord[n-1])]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,A[MN],B[MN],id[MN],par[MN];\nll f[MN],sz[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(int x,int y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&C[y]<=C[x]) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%d\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR int w=Q[v].top().se;Q[v].pop();\n\t\tif(find(w)!=find(u))Q[u].push(pi(dx[w],w));\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tif(h>t)return false;\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR int v=Q[u].top().se;if(dx[v]>s[u])break;\n\t\t\tQ[u].pop();if(find(v)==find(u))continue;\n\t\t\tif(s[u]+s[v]>=mx)return true;\n\t\t\ts[u]+=s[v],fa[find(v)]=u,++cnt,merge(u,v);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tfp(i,1,n)cmax(mx,a[i]-b[i]);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tl=1,r=mx;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjoint set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n\nint t1,t2;\n\nint n,m;\n\nstruct edge{int u,v,w;};\nbool esort(edge e1,edge e2)\n{\n    return e1.w<e2.w;\n}\nedge e[200005];\nint e2=0;\n\nint a[100005];\nint b[100005];\n\n// disjoint set stuff\nint endval;\nint up[100005];\nint lv[100005];\nlong long money[100005];\nbool active[100005];\n\nint getroot(int u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(int u,int v)\n{\n    up[v]=u;\n    money[u]+=money[v]-endval;\n    active[u]=1;\n}\n\nvoid join(int u,int v)\n{\n    //printf(\"join %d %d\\n\",u,v);\n    u=getroot(u);\n    v=getroot(v);\n    if (lv[u]>=lv[v]) {\n        if (lv[u]==lv[v]) lv[u]++;\n        join2(u,v);\n    }\n    else {\n        join2(v,u);\n    }\n}\n\nbool good(int x)\n{\n    endval=x;\n    memset(lv,0,sizeof lv);\n    memset(active,0,sizeof active);\n    for (int i=1; i<=n; i++) {\n        up[i]=i;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n    }\n    for (int asdf=0; asdf<10; asdf++)\n    for (int i=0; i<e2; i++) {\n        //printf(\"i %d = %d %d %d\\n\",i,e[i].u,e[i].v,e[i].w);\n        if (!active[getroot(e[i].u)]) continue;\n    //printf(\"try %d %d and %lld %d\\n\",e[i].u,e[i].v,money[getroot(e[i].u)],e[i].w);\n        if (money[getroot(e[i].u)]<e[i].w) continue;\n        join(e[i].u,e[i].v);\n    }\n    // check\n    for (int i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nint lo=0;\nint hi=0x3f3f3f3f;\nint mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (int i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        e[e2].u=t1;\n        e[e2].v=t2;\n        e[e2].w=a[t2]-b[t2];\n        e2++;\n        e[e2].u=t2;\n        e[e2].v=t1;\n        e[e2].w=a[t1]-b[t1];\n        e2++;\n    }\n    std::sort(e,e+e2,esort);\n    //good(105); return 0;\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%d %d\\n\",lo,hi);\n    }\n    ans=lo;\n    for (int i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int>> L;\nvector<int> Y[1 << 17];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\t\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) scanf(\"%lld%lld\", &A[i], &B[i]);\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\t\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<1>(L[i]), r2 = get<2>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(t);\n\t\t\t}\n\t\t\tUF1.unite(get<1>(L[i]), get<2>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 600);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m;\nvector<int> g[N];\nint a[N], b[N];\nint p[N];\nbool used[N];\nlong long sum[N];\nset<pair<int, int> > st[N];\n\nint find(int x) { return p[x] < 0 ? x : p[x] = find(p[x]); }\n\n\nbool can(long long x) {\n  for (int i = 0; i < n; ++i) {\n    st[i].clear();\n    for (int u : g[i])\n      st[i].insert(make_pair(a[u], u));\n    sum[i] = b[i];\n  }\n  fill(p, p+n, -1);\n  fill(used, used+n, 0);\n  int cnt = 0;\n  stack<int> stak;\n  for (int i = 0; i < n; ++i) {\n    if (x >= a[i]) {\n      stak.push(i);\n      used[i] = 1;\n    }\n  }\n  // cerr << \" cek \" << x << endl;\n  while (!stak.empty()) {\n    int v = stak.top();\n    stak.pop();\n    v = find(v);\n    // cerr << \" sumber \" << v << endl;\n    while (!st[v].empty()) {\n      auto it = st[v].begin();\n      int u = it->second;\n      if (a[u] > sum[v] + x) break;\n      st[v].erase(it);\n      used[u] = 1;\n      u = find(u);\n      // cerr << \" tambah \" << u << endl;\n      if (u == v) continue;\n      if (st[u].size() > st[v].size()) swap(u, v);\n      for (auto it2 : st[u])\n        st[v].insert(it2);\n      st[u].clear();\n      sum[v] += sum[u];\n      p[u] = v;\n    }\n  }\n  for (int i = 0; i < n; ++i) if (!used[i]) return false;\n  return true;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d %d\", a+i, b+i);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v); --u, --v; \n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long lo = 0, hi = 0;\n  for (int i = 0; i < n; ++i)\n    a[i] -= b[i];\n  for (int i = 0; i < n; ++i)\n    if (a[i] > hi) hi = a[i];\n  long long all = 0;\n  for (int i = 0; i < n; ++i)\n    all += b[i];\n  while (lo < hi) {\n    long long mid = (lo + hi) >> 1;\n    if (can(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  // cerr << lo << endl;\n  printf(\"%lld\\n\", lo+all);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 1e5 + 10;\nint n;\nll a[N], b[N];\nVI e[N];\n\nll score(int i){\n    return b[i] - a[i];\n}\n\nll calc(int r){\n    priority_queue<PL> que;\n    que.push(PL(score(r), r));\n    ll sum = max(a[r], b[r]), ans = sum;\n    VI visit(n);\n    visit[r] = 1;\n    while (!que.empty()){\n        PL p = que.top();\n        que.pop();\n        int now = p.second;\n        for (int next : e[now]){\n            if (visit[next]) continue;\n            visit[next] = 1;\n            sum = max(sum + b[next], a[next]);\n            ans = max(ans, sum);\n            que.push(PL(score(next), next));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int m;\n    cin >> n >> m;\n    REP(i,n){\n        a[i] = in(), b[i] = in();\n    }\n    REP(i,m){\n        int u = in() - 1, v = in() - 1;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    // int r;\n    // ll ma = -1e18;\n    // REP(i,n){\n    //     if (b[i] - 2 * a[i] > ma){\n    //         ma = b[i] - 2 * a[i];\n    //         r = i;\n    //     }\n    // }\n\n    ll ans = 1e18;\n    REP(_,100){\n        ans = min(ans, calc(rand() % n));\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#define LL long long\nusing namespace std;\nconst LL inf = 0x3f3f3f3f3f3f3f3fll;\nconst int maxn = 100100;\nvector <int> e[maxn],t[maxn];\nstruct node {\n    LL a,b;\n    int id;\n    bool operator < (const node & x) const {\n        return a-b < (x.a-x.b);\n    }\n}x[maxn],g[maxn],y[maxn],z[maxn];\nint f[maxn],vis[maxn];\nint fnd(int u) {\n    return u==f[u]?u:(f[u]=fnd(f[u]));\n}\nnode mul(node a,node b) {\n    return (node){max(a.a,max(b.a,b.b)+a.b),a.b+b.b};\n}\n\nvoid dp(int u) {\n    int sz=t[u].size();\n    if (sz == 0) {\n        g[u]=x[u];\n//        printf(\"g[%d] = (%lld,%lld) diff %lld\\n\",u,g[u].a,g[u].b,g[u].a-g[u].b);\n        return ;\n    }\n    for (int i=0;i<sz;i++) dp(t[u][i]);\n    for (int i=0;i<sz;i++) y[i]=g[t[u][i]];\n    sort(y,y+sz);\n    z[sz]=(node){0,0};\n    for (int i=sz-1;i>=0;i--) z[i]=mul(z[i+1],y[i]);\n    node a,b=(node){0,0};\n    g[u] = (node){inf,0};\n    for (int i=0;i<sz;i++) {\n        a=mul(mul(mul(z[i+1],b),x[u]),y[i]);\n        b=mul(y[i],b);\n        if (g[u].a > a.a) g[u]=a;\n    }\n//    printf(\"g[%d] = (%lld,%lld) diff = %lld\\n\",u,g[u].a,g[u].b,g[u].a-g[u].b);\n}\nint main(void) {\n//    freopen(\"f.in\",\"r\",stdin);\n    int n,m; scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%lld%lld\",&x[i].a,&x[i].b), x[i].id=i;\n        y[i]=x[i];\n    }\n    for (int i=0;i<m;i++) {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    for (int i=1;i<=n;i++) f[i]=i;\n    sort(y+1,y+n+1);\n    for (int i=1;i<=n;i++) {\n        int u = y[i].id;\n        for (int j=0;j<e[u].size();j++) {\n            int v=e[u][j];\n            if (vis[v]) {\n                v=fnd(v);\n                if (v!=u) {\n                    f[v]=u;\n                    t[u].push_back(v);\n                }\n            }\n        }\n        vis[u]=1;\n    }\n    int rt = y[n].id;\n//    for (int i=1;i<=n;i++) {\n//        printf(\"%d: \",i);\n//        for (int j=0;j<t[i].size();j++) printf(\"%d \",t[i][j]); puts(\"\");\n//    }\n    dp(rt);\n    printf(\"%lld\\n\",g[rt].a);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, A[N], B[N], C[N], par[N], sm[N], ans[N], sz[N];\nvector<pii> E;\n\nint getpar(int v){\n\treturn (par[v] == v?v:par[v]=getpar(par[v]));\n}\n\nbool cmp(pii x, pii y){\n\treturn (max(C[x.F], C[x.S]) < max(C[y.F], C[y.S]));\n}\n\nvoid merge(int v, int u){\n//\tcout << v << ' ' << u << '\\n';\n\tv = getpar(v), u = getpar(u);\n//\tcout << v << ' ' << u << '\\n';\n\tif (u == v) return;\n\tif (sz[v] < sz[u]) swap(v, u);\n\tans[v] = min(max(ans[v], max(0ll, C[u] - sm[v])), max(ans[u], max(0ll, C[v] - sm[u])));\n\tpar[u] = v;\n//\tcout << ans[v] << '\\n';\n\tsz[v] += sz[u];\n\tsm[v] += sm[u];\n}\n\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> A[i] >> B[i];\n\t\tC[i] = max(0ll, A[i] - B[i]);\n//\t\tcout << \"YES \" << i << ' ' << C[i] << '\\n';\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tE.pb({v, u});\n\t}\n\tsort(all(E), cmp);\n\tfor (int i = 1; i <= n; i++) par[i] = i, sz[i] = 1, sm[i] = B[i], ans[i] = C[i];\n//\tfor (int i = 1; i <= n; i++) cout<<\"Fuck \" << ans[i] << '\\n';\n\tfor (auto u:E){\n\t\tmerge(u.F, u.S);\n\t}\t\n\tcout << ans[getpar(1)];\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define maxn 100010\n#define inf 0x3f3f3f3f\ninline ll read()\n{\n    ll x=0; char c=getchar(),f=1;\n    for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n    for(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n    return x*f;\n}\ninline void write(ll x)\n{\n    static int buf[20],len; len=0;\n    if(x<0)x=-x,putchar('-');\n    for(;x;x/=10)buf[len++]=x%10;\n    if(!len)putchar('0');\n    else while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],a[maxn],b[maxn],c[maxn],id[maxn],fa[maxn],mark[maxn];\nll f[maxn],size[maxn];\nstd::vector<int>son[maxn];\nint n,m,tot=0;\nbool cmp(int x,int y){return c[x]<c[y];}\ninline void add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dp(int now)\n{\n\tsize[now]=b[now];\n\tfor(int i:son[now]){\n\t\tdp(i);\n\t\tsize[now]+=size[i];\n\t}\n\tf[now]=(son[now].size()?1ll<<60:c[now]+b[now]);\n\tfor(int i:son[now]){\n\t\tf[now]=std::min(f[now],std::max((ll)c[now],f[i])+size[now]-size[i]);\n\t\t// printf(\"%d -> %d : %lld %lld\\n\",now,i,std::max((ll)c[now],f[i]),size[now]-size[i]);\n\t}\n}\nint main()\n{\n\tn=read(); m=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read(),b[i]=read(),c[i]=std::max(a[i]-b[i],0);\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfa[i]=i,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tmark[id[i]]=1;\n\t\tfor(int j=fir[id[i]];~j;j=e[j].nxt)\n\t\t\tif(mark[e[j].to]){\n\t\t\t\tint fx=find(id[i]),fy=find(e[j].to);\n\t\t\t\tif(fx!=fy){\n\t\t\t\t\tfa[fy]=fx;\n\t\t\t\t\tson[id[i]].push_back(fy);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tdp(id[n]);\n\twriteln(f[id[n]]);\n\t// for(int i=1;i<=n;i++)\n\t// \twritesp(id[i]);\n\t// putchar('\\n');\n\t// for(int i=1;i<=n;i++){\n\t// \tprintf(\"%d : \",i);\n\t// \tfor(int j:son[i])\n\t// \t\twritesp(j);\n\t// \tputchar('\\n');\n\t// }\n\t// for(int i=1;i<=n;i++)\n\t// \tprintf(\"%d %d %d %d %lld %lld\\n\",i,a[i],b[i],c[i],size[i],f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long inf = 0x3f3f3f3f3f3f3f3fLL;\nint n, m, f[100010], fst[100010], num = 0, pos[100010];\nstruct th\n{\n    int a, b, c, id;\n} a[100010];\nstruct edge\n{\n    int x, y, n;\n} e[100010];\nvector<int> e1[100010];\nlong long sum[100010], dp[100010];\n\nvoid ins(int x, int y)\n{\n    e[++num] = {x, y, fst[x]};\n    fst[x] = num;\n}\nint cmp(th x, th y) { return x.c < y.c; }\nint fd(int x) { return f[x] == x ? x : f[x] = fd(f[x]); }\nvoid dfs(int x)\n{\n    sum[x] = a[x].b;\n    for (int i = fst[x]; i; i = e[i].n)\n    {\n        int y = e[i].y;\n        dfs(y);\n        sum[x] += sum[y];\n    }\n    if (fst[x])\n    {\n        dp[x] = inf;\n        for (int i = fst[x]; i; i = e[i].n)\n        {\n            int y = e[i].y;\n            dp[x] = min(dp[x], sum[x] - sum[y] + max(1LL * a[x].c, dp[y]));\n        }\n    }\n    else dp[x] = a[x].b + a[x].c;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%d%d\", &a[i].a, &a[i].b);\n        a[i].c = max(a[i].a - a[i].b, 0);\n        a[i].id = i;\n    }\n    sort(a + 1, a + 1 + n, cmp);\n    for (int i = 1; i <= n; i++)\n        pos[a[i].id] = i;\n    for (int i = 0; i < m; i++)\n    {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        e1[pos[x]].push_back(pos[y]);\n        e1[pos[y]].push_back(pos[x]);\n    }/*\n    for (int i = 1; i <= n; i++)\n        printf(\"%d %d %d\\n\", a[i].a, a[i].b, a[i].c);*/\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = i;\n        for (int y : e1[i])\n            if (y < i && fd(y) != i)\n            {\n                ins(i, fd(y));\n                f[fd(y)] = i;\n            }\n    }/*\n    for (int i = 1; i <= num; i++)\n        printf(\"%d %d\\n\", e[i].x, e[i].y);*/\n    dfs(n);\n    printf(\"%lld\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nint fa[100050];\nvector<int> edge[100050],tr[100050];\nint id[100050];\nint a[100050],b[100050];\nlong long dp[100050];\nlong long su[100050];\nbool vi[100050];\n\nbool cmp(int A,int B)\n{\n\treturn a[A] < a[B];\n}\n\nint find_fa(int u)\n{\n\treturn fa[u] == u ? u : fa[u] = find_fa(fa[u]);\n}\n\nvoid dfs(int pos)\n{\n\tfor(auto v : tr[pos])\n\t{\n\t\tdfs(v);\n\t\tsu[pos] += su[v];\n\t}\n\tsu[pos] += b[pos];\n\tdp[pos] = su[pos] + a[pos];\n\tfor(auto v : tr[pos])\n\t\tdp[pos] = min(dp[pos],su[pos] - su[v] + max(a[pos] * 1ll,dp[v]));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1;i <= n; ++ i)\n\t\tscanf(\"%d%d\",&a[i],&b[i]),a[i] = max(0,a[i] - b[i]),id[i] = i;\n\tsort(id + 1,id + 1 + n,cmp);\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tfor(int i = 1;i <= n; ++ i) fa[i] = i;\n\tfor(int i = 1;i <= n; ++ i)\n\t{\n\t\tint x = id[i];\n\t\tvi[x] = 1;\n\t\tfor(auto v : edge[x])\n\t\t\tif(vi[v] && find_fa(v) != find_fa(x))\n\t\t\t{\n\t\t\t\tint f = find_fa(v);\n\t\t\t\ttr[x].push_back(f);\n\t\t\t\tfa[f] = x;\n\t\t\t}\n\t}\n\tdfs(id[n]);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace cqz{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*S=SZB,*T=SZB;\n    inline char gc(){   if (S==T){  T=(S=SZB)+fread(SZB,1,GYN,stdin); if (S==T) return '\\n';  }   return *S++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace cqz;\nconst ll N=3000010,inf=1e18;\nll m,n,fa[N],a[N],b[N],vis[N],sum[N],ans[N],cur[N];\nvector<ll>g[N];\nstruct dt{ll a,b,id;}p[N];\nbool cmp(dt a,dt b){return a.a<b.a;}\nll find(ll x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint main(){\n\tn=read();m=read();\n\tFor(i,1,n){a[i]=read(),b[i]=read();a[i]=max(a[i],b[i]);p[i]=(dt){a[i],b[i],i};sum[i]=b[i];}\n\tFor(i,1,m){ll x=read(),y=read();g[x].push_back(y);g[y].push_back(x);}\n\tsort(p+1,p+n+1,cmp);\n\tFor(i,1,n)fa[i]=i,ans[i]=inf;\n\tfor(ll i=1,j;i<=n;i=j+1){\n\t\tj=i;for(;p[j+1].a==p[i].a;++j);\n\t\tFor(k,i,j)vis[p[k].id]=1;\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=find(g[x][edge]);\n\t\t\t\tif (!vis[to])continue;\n\t\t\t\tcur[g[x][edge]]=to;\n\t\t\t}\n\t\t}\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=find(g[x][edge]);\n\t\t\t\tif (!vis[to]||find(x)==to)continue;\n\t\t\t\tfa[find(to)]=find(x);\n\t\t\t\tsum[find(x)]+=sum[to];\n\t\t\t}\n\t\t}\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=cur[g[x][edge]];\n\t\t\t\tif (!vis[to]||vis[to]==i)continue;\n\t\t\t\tll now=find(x);\n\t\t\t\tll cost=max(a[x],ans[to]+b[x])+sum[now]-sum[to]-b[x];\n\t\t\t\tMin(ans[now],cost);\n\t\t\t}\n\t\t\tMin(ans[find(x)],a[find(x)]+sum[find(x)]-b[x]);\n\t\t} \n\t}writeln(ans[find(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nlong long Val[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n        Val[y] += Val[x];\n    }\n    else\n        TT[y] = x, Val[x] += Val[y];\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        Val[i] = B[i];\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total = Val[Father(node)];\n                        if(total >= 1000000000000000)\n                            return 1;\n                        //if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Father(n) != Father(node))\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total = Val[Father(node)];\n                            if(total >= 1000000000000000)\n                            return 1;\n                            break;\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 110000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n            else if (mol[par[i]].size()!=n){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]!=-1 && z!=par[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int & \n#define SZ(a) ((int)(a.size()))\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n\tfor (T x : a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\nconst int N = 1e5 + 9;\nconst ll oo = 1e15;\nint parent[N];\nint is_free[N];\nll bsum[N];\nvi g[N];\nint n, m;\nll a[N], b[N];\n\nset<int> inside[N];\nset<pair<ll, int>> neibs[N];\nll gw, gb;\nset<pair<ll, int>> fre;\nint counter = 0;\n\nvoid make_set(int v) {\n\t++counter;\n\tinside[v].insert(v);\n\tparent[v] = v;\n\tbsum[v] = b[v];\n\tfor (int to : g[v]) \n\t\tneibs[v].insert(mp(a[to] - b[to], to));\n}\n\nint find_set(int v) {\n\tif (parent[v] == v) return v;\n\treturn parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int u, int v) {\n\tu = find_set(u);\n\tv = find_set(v);\n\tif (u == v) return;\n\t--counter;\n\tis_free[v] = 1;\n\tif (SZ(neibs[u]) < SZ(neibs[v]))\n\t\tswap(v, u);\n\tinside[u].insert(ALL(inside[v]));\n\tbsum[u] += bsum[v];\n\tparent[v] = u;\n\tneibs[u].insert(ALL(neibs[v]));\n}\n\nvoid add_to_free(int u) {\n\twhile (!neibs[u].empty()) {\n\t\tbool ok = 0;\n\t\tif (inside[u].count((*neibs[u].begin()).second)) {\n\t\t\tok = 1;\n\t\t\tneibs[u].erase(neibs[u].begin());\n\t\t}\n\t\tif (!ok) break;\n\t}\n\tif (neibs[u].empty()) {\n\t\tassert(counter == 1);\n\t\treturn;\n\t}\n\tint superv = (*neibs[u].begin()).second;\n\tfre.insert(mp(a[superv] - b[superv] - bsum[u], u));\n}\n\nvoid add_to_cool(int v) {\n\tv = find_set(v);\n\tis_free[v] = 1;\n\twhile (!neibs[v].empty() && (*neibs[v].begin()).first + gb - bsum[v] <= gw) {\n\t\tint u = (*neibs[v].begin()).second;\n\t\tneibs[v].erase(neibs[v].begin());\n\t\tunion_sets(v, u);\n\t\tv = find_set(v);\n\t}\n\tadd_to_free(v);\n}\n\n\n\nll solve() {\n\tgb = accumulate(b + 1, b + n + 1, 0LL);\n\tfori(i, n) {\n\t\tmake_set(i + 1);\n\t\tfre.insert(mp(a[i + 1] - b[i + 1], i + 1));\n\t}\n\twhile (counter > 1) {\n\t\tll minim = (*fre.begin()).first;\n\t\t// minim + gb <= gw\n\t\t//watch(minim);\n\t\tgw = minim + gb; \n\t\twhile (!fre.empty() && (*fre.begin()).first + gb == gw) {\n\t\t\tint v = find_set((*fre.begin()).second);\n\t\t\tadd_to_cool(v);\n\t\t\tfre.erase(fre.begin());\n\t\t}\n\t}\n\treturn gw;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tmmax(a[i], b[i]);\n\t}\n\tfori(iter, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\tcout << solve() << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+5;\ntypedef pair<int,int> pi;\nint n,m,a[N],b[N];\nint par[N];ll sz[N];\ninline int find(int x){\n\treturn par[x]==x?par[x]:par[x]=find(par[x]);\n}\n\nstruct node{\n\tint l,r,h,x;\n}f[N<<3];\nint cnt;\n\nint merge(int a,int b){\n\tif(!a||!b)return a|b;\n\tif(f[a].x>f[b].x)swap(a,b);\n\tf[a].r=merge(f[a].r,b);\n\tif(f[f[a].l].h<f[f[a].r].h)swap(f[a].l,f[a].r);\n\tf[a].h=f[a].r?f[f[a].r].h+1:0;\n\treturn a;\n}\n\nint pop(int a){\n\treturn merge(f[a].l,f[a].r);\n}\n\nll ans;\n\nint rt[N],u[N], v[N];\nqueue<int> q;\n\nbool check(ll p){\n\t// cout << \"check\" << p << endl;\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]-b[i]<=p)q.push(i);\n\t\tpar[i] = i;\n\t\trt[i] = 0;\n\t\tsz[i] = b[i];\n\t}\n\tfor(int i=2;i<=m*2+1;i++){\n\t\tf[i].l=f[i].r=f[i].h=0;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\trt[u[i]] = merge(rt[u[i]], i*2);\n\t\trt[v[i]] = merge(rt[v[i]], i*2+1);\n\t}\n\twhile(q.size()){\n\t\tint u = q.front();q.pop();\n\t\t// cout << u << \":\" << endl;\n\t\tif(find(u)!=u)continue;\n\t\t// cout << u << \" \" << sz[u] << \":\" << rt[u] << \" \" << f[rt[u]].x << endl;\n\t\twhile(rt[u] && f[rt[u]].x<=sz[u]+p){\n\t\t\t// cout << rt[u]/2 << endl;\n\t\t\tint id = rt[u]/2;\n\t\t\trt[u] = merge(f[rt[u]].l, f[rt[u]].r);\n\t\t\tint nxt = find(::v[id]) + find(::u[id]) - u;\n\t\t\tif(nxt==u)continue;\n\t\t\telse{\n\t\t\t\t// cout << nxt << endl;\n\t\t\t\trt[u] = merge(rt[u], rt[nxt]);\n\t\t\t\tpar[nxt] = u;\n\t\t\t\tsz[u] += sz[nxt];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(find(i)!=find(1))return 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i], &b[i]);\n\tif(n==1){\n\t\tcout << max(a[1],b[1]) << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\t::u[i] = u, ::v[i] = v;\n\t\tf[i*2].x = a[v] - b[v];\n\t\tf[i*2+1].x = a[u] - b[u];\n\t}\n\tint l=0,r=1e9;\n\twhile(l<r){\n\t\tint mid = (l+r)>>1;\n\t\tbool ret=check(mid);\n\t\tif(ret)r=mid;\n\t\telse l=mid+1;\n\t}\n\t// check(0);\n\tans = l;\n\tfor(int i=1;i<=n;i++)ans += b[i];\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i <= i##_END_; i++)\n#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i >= i##_END_; i--)\n\ntemplate <typename Tp> void in(Tp &x) {\n\tchar ch = getchar(), f = 1; x = 0;\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') ch = getchar(), f = -1;\n\twhile (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n\tx *= f;\n}\n\ntemplate <typename Tp> void out(Tp x) {\n\tif (x > 9) out(x / 10);\n\tputchar(x % 10 + '0');\n\treturn;\n}\n\ntemplate <typename Tp> Tp Max(const Tp &x, const Tp &y) {return x > y ? x : y;}\ntemplate <typename Tp> Tp Min(const Tp &x, const Tp &y) {return x < y ? x : y;}\ntemplate <typename Tp> bool chkmax(Tp &x, Tp y) {return x >= y ? 0 : (x=y, 1);}\ntemplate <typename Tp> bool chkmin(Tp &x, Tp y) {return x <= y ? 0 : (x=y, 1);}\n\nconst int MAXN = 100010;\n\nint n, m, A[MAXN], B[MAXN], to[MAXN];\nint head[MAXN], data[MAXN << 1], nxt[MAXN << 1], cnt;\n\nint fa[MAXN], rnk[MAXN];\n\nLL need[MAXN];\nLL sum[MAXN];\n\nchar cmp(const int &x, const int &y) {return A[x] - B[x] < A[y] - B[y];}\n\nvoid add(int x, int y)\n{\n\tnxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++;\n\tnxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;\n}\n\nint find(int x) {while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x;}\n\nint main()\n{\n\tin(n); in(m);\n\tFOR(i, 1, n) in(A[i]), in(B[i]);\n\tFOR(i, 1, n) to[i] = i;\n\n\tstd::sort(to + 1, to + n + 1, cmp);\n\n\tmemset(head, -1, sizeof head);\n\tFOR(i, 1, n) fa[i] = i;\n\tFOR(i, 1, m) {int x, y; in(x); in(y); add(x, y);}\n\n\tFOR(i, 1, n) rnk[to[i]] = i;\n\tFOR(i, 1, n) sum[i] = 0;\n\n\tLL all = 0;\n\n\tFOR(i, 1, n) all += B[i];\n\n\tmemset(need, 0x3f, sizeof need);\n\t\n\tFOR(i, 1, n) {\n\t\tint now = to[i];\n\t\t\n\t\tfor (int j = head[now]; j != -1; j = nxt[j]) {\n\t\t\tint fx;\n\t\t\tif ((fx = find(data[j])) != find(now) && rnk[data[j]] < i) {\n\t\t\t\tfa[fx] = find(now); sum[find(now)] += sum[fx];\n\t\t\t\tchkmin(need[find(now)], Max(need[fx], A[now] - B[now] - sum[fx]));\n\t\t\t}\n\t\t}\n\n\t\tchkmin(need[find(now)], A[now] - B[now] + 0ll);\n\t\tsum[find(now)] += B[now];\n\t}\n\n\tprintf(\"%lld\\n\", need[find(1)] + all);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int N=100010;\nconst LL LINF=1ll<<60;\nint n,m;\nint cost[N];\nint h[N],tot;\nstruct Edge{\n\tint v,next;\n}e[N*2];\nstruct Node{\n\tint u,t;\n}p[N];\ninline LL min(LL x,LL y){\n\treturn x<y?x:y;\n}\ninline LL max(LL x,LL y){\n\treturn x>y?x:y;\n}\nvoid addEdge(int u,int v){\n\te[++tot]=(Edge){v,h[u]}; h[u]=tot;\n\te[++tot]=(Edge){u,h[v]}; h[v]=tot;\n}\nvoid readData(){\n\tscanf(\"%d%d\",&n,&m);\n\tint a,b;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tcost[i]=b;\n\t\tp[i]=(Node){i,max(a-b,0)};\n\t}\n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t}\n}\nint bel[N];\nbool active[N];\nLL f[N],sum[N];\nbool cmpThreshold(const Node &x,const Node &y){\n\treturn x.t<y.t;\n}\nint find(int x){\n\treturn bel[x]==x?x:(bel[x]=find(bel[x]));\n}\nvoid solve(){\n\tsort(p+1,p+1+n,cmpThreshold);\n\tfor(int i=1;i<=n;i++) bel[i]=i;\n\tfor(int ii=1;ii<=n;ii++){\n\t\tint u=p[ii].u;\n\t\tactive[u]=true;\n\t\tsum[u]=cost[u];\n\t\tf[u]=LINF;\n\t\tbool haveSon=false;\n\t\tfor(int i=h[u],v;i;i=e[i].next){\n\t\t\tv=find(e[i].v);\n\t\t\tif(v!=u&&active[v]){\n\t\t\t\tactive[v]=false;\n\t\t\t\thaveSon=true;\n\t\t\t\tbel[v]=u;\n\t\t\t\tsum[u]+=sum[v];\n\t\t\t\tf[u]=min(f[u],max(f[v],p[ii].t-sum[v]));\n\t\t\t}\n\t\t}\n\t\tif(!haveSon)\n\t\t\tf[u]=p[ii].t;\n\t}\n\tint last=p[n].u;\n\tprintf(\"%lld\\n\",sum[last]+f[last]);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int maxn=1e5+7;\nbool vis[maxn];\nint a[maxn],b[maxn],p[maxn],fa[maxn];\nll c[maxn];\nll dp[maxn],sum[maxn];\nstruct Edge{\n\tint nxt,to;\n}G[maxn<<1],T[maxn<<1];\nint bG=0,hG[maxn],bT=0,hT[maxn<<1];\nvoid addG(int x,int y){\n\tG[bG].nxt=hG[x];G[bG].to=y;hG[x]=bG++;\n\tG[bG].nxt=hG[y];G[bG].to=x;hG[y]=bG++;\n}\nvoid addT(int x,int y){\n\tT[bT].nxt=hT[x];T[bT].to=y;hT[x]=bT++;\n\tT[bT].nxt=hT[y];T[bT].to=x;hT[y]=bT++;\n}\nbool cmp(int x,int y){\n\treturn c[x]<c[y];\n}\nvoid dfs(int v,int p){\n\tsum[v]=b[v];\n\tfor (int i=hT[v];i!=-1;i=T[i].nxt){\n\t\tint u=T[i].to;\n\t\tif (u==p) continue;\n\t\tdfs(u,v);\n\t\tsum[v]+=sum[u];\n\t}\n\tdp[v]=sum[v]+c[v];\n\tfor (int i=hT[v];i!=-1;i=T[i].nxt){\n\t\tint u=T[i].to;\n\t\tif (u==p) continue;\n\t\tdp[v]=min(dp[v],sum[v]-sum[u]+max(dp[u],c[v]));\n\t}\n}\nint Get(int x){\n\tif (fa[x]==x) return x;\n\tfa[x]=Get(fa[x]);return fa[x];\n}\nint main(){\n\tmemset(hG,-1,sizeof(hG));\n\tmemset(hT,-1,sizeof(hT));\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tc[i]=max(a[i]-b[i],0);\n\t\tp[i]=i;fa[i]=i;\n\t}\n\tfor (int i=0;i<m;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);u--;v--;addG(u,v);\n\t}\n\tsort(p,p+n,cmp);\n\tfor (int i=0;i<n;i++){\n\t\tint v=p[i];\n\t\tvis[v]=true;\n\t\tfor (int e=hG[v];e!=-1;e=G[e].nxt){\n\t\t\tint u=G[e].to;\n\t\t\tint fu=Get(u);\n\t\t\tif (vis[u] && v!=fu){\n\t\t\t\tfa[fu]=v;\n\t\t\t\taddT(fu,v);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(p[n-1],-1);\n\tprintf(\"%lld\\n\",dp[p[n-1]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint N, M;\nllint A[100005], B[100005];\nvector<llint> G[100005];\nbool valid[100005];\n\nllint maxm;\nllint parent[100005];\nllint money[100005];\nllint size[100005];\n\nvoid init(){\n\tfor(llint i = 1; i <= N; i++){\n\t\tparent[i] = i;\n\t\tmoney[i] = B[i];\n\t\tsize[i] = 1;\n\t}\n}\n\nllint root(llint i)\n{\n\tif(parent[i] == i) return i;\n\treturn parent[i] = root(parent[i]);\n}\n\nvoid unite(llint i, llint j)\n{\n\tllint root_i = root(i), root_j = root(j);\n\tif(root_i == root_j) return;\n\tparent[root_i] = root_j;\n\tmoney[root_j] += money[root_i];\n\tsize[root_j] += size[root_i];\n\tmoney[root_i] = 0;\n\tmaxm = max(maxm, money[root_j]);\n}\n\nbool same(llint i, llint j)\n{\n\treturn root(i) == root(j);\n}\n\nbool check(llint x)\n{\n\tinit();\n\tmaxm = 0;\n\tfor(int i = 1; i <= N; i++) valid[i] = false;\n\t\n\tllint m = x;\n\twhile(1){\n\t\t//cout << x << \" \" << m << endl;\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tif(!valid[i] && A[i] <= m){\n\t\t\t\tvalid[i] = true;\n\t\t\t\tmaxm = max(maxm, B[i]);\n\t\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\t\tif(valid[G[i][j]]) unite(i, G[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(m == x + maxm) return false;\n\t\tm = x + maxm;\n\t\tif(size[1] == N) return true;\n\t}\n}\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor(int i = 1; i <= N; i++) cin >> A[i] >> B[i];\n\tint u, v;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tllint sum = 0;\n\tfor(int i = 1; i <= N; i++) sum += A[i];\n\t\n\tllint ub = 1e18, lb = 0, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(check(mid)) ub = mid;\n\t\telse lb = mid;\n\t\t//cout << mid << endl;\n\t}\n\t\n\tcout << ub + sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 100000;\nvector<int> g[N + 1];\nint n, m, a[N + 1], b[N + 1], pa[N + 1], ex[N + 1];\nll sm[N + 1];\npair<int, int> x[N];\n\nint P(int v) { return pa[v] < 0 ? v : pa[v] = P(pa[v]); }\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tf(i, 1, n + 1)scanf(\"%d%d\", a + i, b + i);\n\tf(i, 0, n)x[i] = make_pair(a[i + 1] - b[i + 1], i + 1);\n\tsort(x, x + n);\n\tf(i, 0, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tpa[0] = -1;\n\tf(i, 0, n){\n\t\tint v = x[i].second, need = a[v] - b[v];\n\t\tsm[v] = b[v];\n\t\tex[v] = max(0, need);\n\t\tpa[v] = -1;\n\t\tf(j, 0, g[v].size()){\n\t\t\tint u = P(g[v][j]);\n\t\t\tif (u == 0 || u == v)continue;\n\t\t\tsm[v] += sm[u];\n\t\t\tex[v] = min((ll)ex[v], max((ll)ex[u], need - sm[u]));\n\t\t\tpa[u] = v;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sm[x[n - 1].second] + ex[x[n - 1].second]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tll a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].a,&a[i].b);\nif(n==1) return 1;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e17,mid,ans=0;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e17;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;continue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mx,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n            else if (mol[par[i]].size()!=n){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]!=-1 && z!=par[i]) p1=1;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define MN 101000\n\ntypedef long long ll;\n\nint h[MN], nxt[2 * MN], to[2 * MN], K = 0;\nint n, m, fa[MN]; \nint a[MN], c[MN], p[MN];\nstd::vector<int> e[MN];\nll sum[MN];\nbool vis[MN];\nll Ans = 1e18;\n\nvoid ins(int u, int v) {nxt[++K] = h[u]; h[u] = K; to[K] = v;} \n\nint Find(int x) {return fa[x] == x ? x : fa[x] = Find(fa[x]);}\n\nbool cmp(int a, int b) {return c[a] < c[b];}\n\nvoid dfs(int x)\n{\n\tsum[x] = a[x] - c[x];\n\tfor(int i = h[x]; i; i = nxt[i])\n\t\tdfs(to[i]), sum[x] += sum[to[i]];\n}\n\nvoid solve(int x, ll w)  \n{\n\tAns = std::min(Ans, std::max((ll)c[x], w));\n\tfor(int i = h[x]; i; i = nxt[i])\n\t{\n\t\tsolve(to[i], std::max(w, c[x] - sum[to[i]]));\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\ta = std::max(a, b);\n\t\t::a[i] = a; c[i] = a - b;\n\t\tfa[i] = i; p[i] = i;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\n\tstd::sort(p + 1, p + n + 1, cmp);\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x = p[i]; vis[x] = 1;\n\t\tfor(int j = 0; j < e[x].size(); j++)\n\t\t{\n\t\t\tif(vis[e[x][j]])\n\t\t\t{\n\t\t\t\tint y = Find(e[x][j]);\n\t\t\t\tif(x != y)\n\t\t\t\t{\n\t\t\t\t\tins(x, y);\n\t\t\t\t\tfa[y] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(p[n]);\n\tsolve(p[n], 0);\n\t\n\tprintf(\"%lld\\n\", Ans + sum[p[n]]); \n}\n\n/*\na_i = max(a_i, b_i)  c_i = a_i - b_i\n一定存在一种方案，使得不经过已经捐赠过的点（并且可以只考虑目前要捐赠的点的权值，不用考虑路径上的其它点） \n就是在捐赠过程中，一直保持未捐赠的点形成一个连通块\n考虑倒着做，就是-c_i+a_i，那么假设你知道了起始点，肯定是找相邻的c_i最小的点捐赠\n那么找一棵最小生成树就好了嘛\n但是一般的最小生成树性质不够好，不好求每个点出发的答案 \n考虑找一棵树，满足大根堆的性质（按 c_i 从小到大排序，连边的时候向连通块的点权最大那个点连边（因为做生成树过程中往哪个点连边都是一样的，如果从那个连通块出发，那么肯定是先把连通块走遍，如果从当前这个点出发，那么目前的钱一定够以任何顺序走遍这个连通块）） \n那么从每个点出发肯定是先把它的子树走遍，然后往父亲走，这个点答案为 max(c_i,c_{fa_i}-{sum_i},c_{fa_{fa_i}}-{sum_{fa_i}}...) \n*/ "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100010\n#define M 100010\nusing namespace std;\nstruct EDGE{\n\tint u, v;\n\tint Next;\n}G[M << 1];\nint Head[N];\nint tot = 0;\ninline void Add(int u, int v)\n{\n\t++ tot;\n\tG[tot].u = u;\n\tG[tot].v = v;\n\tG[tot].Next = Head[u];\n\tHead[u] = tot;\n}\nstruct Node{\n\tint a, b, num;\n}E[N];\ninline bool cmp(Node x, Node y)\n{\n\treturn x.a - x.b < y.a - y.b;\n}\nint f[N];\nint b[N];\nint w[N];\ninline int Get(int u)\n{\n\treturn f[u] == u ? u : f[u] = Get(f[u]);\n}\nbool vis[N];\nint d[N], top;\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++ i)\n\t\tscanf(\"%d%d\", &E[i].a, &E[i].b);\n\tfor(int i = 1; i <= m; ++ i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tAdd(u, v);\n\t\tAdd(v, u);\n\t}\n\tfor(int i = 1; i <= n; ++ i)\n\t{\n\t\tE[i].num = i;\n\t\tb[i] = E[i].b;\n\t\tf[i] = i;\n\t}\n\tsort(E + 1, E + n + 1, cmp);\n\tfor(int i = 1; i <= n; ++ i)\n\t{\n\t\tvis[E[i].num] = true;\n\t\tint sumb = 0;\n\t\ttop = 0;\n\t\tfor(int j = Head[E[i].num]; j; j = G[j].Next)\n\t\t{\n\t\t\tint v = G[j].v;\n\t\t\tif(! vis[v])\n\t\t\t\tcontinue;\n\t\t\tint fv = Get(v);\n\t\t\tif(fv != E[i].num)\n\t\t\t{\n\t\t\t\tsumb += b[fv];\n\t\t\t\td[++ top] = fv;\n\t\t\t\tf[fv] = E[i].num;\n\t\t\t}\n\t\t}\n\t\tb[E[i].num] = sumb + E[i].b;\n\t\tw[E[i].num] = 2147483647;\n\t\tfor(int j = 1; j <= top; ++ j)\n\t\t\tw[E[i].num] = min(w[E[i].num], sumb - b[d[j]] + max(w[d[j]] + E[i].b, E[i].a));\n\t\tw[E[i].num] = min(w[E[i].num], sumb + max(E[i].a, E[i].b));\n\t}\n\tprintf(\"%d\", w[E[n].num]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long A[110000];\nlong long B[110000];\nvector<int>g[110000];\nint UF[110000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n}\npair<long long,int> v[110000];\npair<long long,pair<int,int> > e[110000];\nvector<pair<int,int> >G[210000];\nint pt[210000];\nlong long dp[210000];\nlong long sum[210000];\nint N;\nvoid dfs(int a){\n\tif(a<N)sum[a]+=B[a];\n\tfor(int i=0;i<G[a].size();i++){\n\t\tdfs(G[a][i].first);\n\t\tsum[a]+=sum[G[a][i].first];\n\t}\n\tif(a<N){\n\t\tdp[a]=A[a];\n\t}else{\n\t\tdp[a]=max(dp[G[a][0].first],A[G[a][1].second]-B[G[a][1].second])+sum[G[a][1].first];\n\t\tdp[a]=min(dp[a],max(dp[G[a][1].first],A[G[a][0].second]-B[G[a][0].second])+sum[G[a][0].first]);\n\t}\n//\tprintf(\"%d: %lld %lld\\n\",a,dp[a],sum[a]);\n}\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);N=a;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld%lld\",A+i,B+i);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t\te[i]=make_pair(max(A[p]-B[p],A[q]-B[q]),make_pair(p,q));\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tUF[i]=-1;\n\t\tpt[i]=i;\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tv[i]=make_pair(A[i]-B[i],i);\n\t}\n\tstd::sort(v,v+a);\n\tstd::sort(e,e+b);\n\tint id=a;\n\tfor(int i=0;i<b;i++){\n\t\tif(FIND(e[i].second.first)==FIND(e[i].second.second))continue;\n\t\tG[id].push_back(make_pair(pt[FIND(e[i].second.first)],e[i].second.first));\n\t\tG[id].push_back(make_pair(pt[FIND(e[i].second.second)],e[i].second.second));\n\t\tUNION(e[i].second.first,e[i].second.second);\n\t\tpt[FIND(e[i].second.first)]=id;\n\t\tid++;\n\t}\n\tdfs(id-1);\n\tprintf(\"%lld\\n\",dp[id-1]);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<ctime>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (int i=head[u]; i!=0; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\ntypedef long long ll;\nusing namespace std;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\nconst int N = 400000;\nint n,m,a[N],b[N],dot[N]; ll ans;\nVi e[N]; bool gg[N];\ninline ui R() {\n\tstatic ui seed=time(0);\n\treturn seed^=seed<<13,seed^=seed>>7,seed^=seed<<17;\n}\nstruct node {\n\tint u;\n\tnode(int X=0) {u=X;}\n\tbool operator > (const node &x) const {\n\t\treturn b[u]-a[u]>b[x.u]-a[x.u];\n\t}\n\tbool operator < (const node &x) const {\n\t\treturn b[u]-a[u]<b[x.u]-a[x.u];\n\t}\n};\npriority_queue<node> heap;\nll getans(int p) {\n\tll ans=0; memset(gg,0,sizeof(gg));\n\tans=max(b[p],a[p]); gg[p]=1; //printf(\"%d : %d \\n\",p,b[p]-a[p]);\n\tper(i,SZ(e[p])-1,0) if (!gg[e[p][i]]) heap.push(node(e[p][i]));\n\twhile (!heap.empty()) {\n\t\tint u=heap.top().u; heap.pop(); if (gg[u]) continue;\n\t\tgg[u]=1; ans=max(a[u]*1LL,b[u]+ans);\n\t\tper(i,SZ(e[u])-1,0) if (!gg[e[u][i]]) heap.push(node(e[u][i]));\n\t}\n\treturn ans;\n}\nbool cmp(int i, int j) {return b[i]-a[i]>b[j]-a[j];}\nint main() {\n\tread(n);read(m);\n\trep(i,1,n)read(a[i]),read(b[i]);\n\trep(i,1,m){int u,v;read(u);read(v);e[u].push_back(v);e[v].push_back(u);}\n\t\n\tll ans=6e18;\n\trep(i,1,n) dot[i]=i;\n\tsort(dot+1,dot+n+1,cmp);\n\tfor (int i=1; i<=n&&clock()<=1.70*CLOCKS_PER_SEC; i++) \n\t\tans=min(ans,getans(dot[i]));\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REPD(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\nint main(int argc, char *argv[])\n{\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int>> G(N);\n  vector<ll> A(N);\n  vector<ll> B(N);\n  vector<pair<ll, int>> vs;\n  REP(i, N) {\n    cin >> A[i] >> B[i];\n    vs.push_back(make_pair(A[i], i));\n  }\n  sort(ALL(vs));\n\n  REP(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UnionFind uf(N);\n  vector<ll> sum(N, -1);\n  vector<ll> dp(N, -1);\n\n  REP(i, N) {\n    ll a = vs[i].first;\n    int v = vs[i].second;\n\n    vector<int> cs;\n    for (const auto &w : G[v]) {\n      int wc = uf.find(w);\n      if (sum[wc] < 0) continue;\n      cs.push_back(wc);\n    }\n    sort(ALL(cs));\n    cs.erase(unique(ALL(cs)), cs.end());\n\n    ll csum = 0;\n    for (int c : cs) {\n      csum += sum[c];\n    }\n    \n    if (int(cs.size()) == 0) {\n      dp[uf.find(v)] = max(A[v], B[v]);\n      sum[uf.find(v)] = B[v];\n    } else {\n      ll res = csum + max(A[v], B[v]);\n      REP(i, cs.size()) {\n        int c = cs[i];\n        res = min(res, max(A[v], dp[c] + B[v]) + csum - sum[c]);\n      }\n\n      for (const auto &w : G[v]) {\n        int wc = uf.find(w);\n        if (sum[wc] < 0) continue;\n        uf.unite(v, wc);\n      }\n      sum[uf.find(v)] = csum + B[v];\n      dp[uf.find(v)] = res;\n    }\n  }\n  cout << dp[uf.find(vs[N - 1].second)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n/**\n * Currently this design only allows one arena per arena size\n *\n * @tparam SIZE size of arena in bytes, default is 200 MB\n */\ntemplate <size_t SIZE = 200 << 20> class Arena {\n  static char buf[];\n  static size_t buf_ind;\n\n public:\n  template <class T> struct Allocator {\n    typedef T value_type;\n\n    Allocator() {}\n\n    template <class U> Allocator(const U&) {}\n\n    T* allocate(size_t n) {\n      buf_ind -= n * sizeof(T);\n      buf_ind &= 0 - alignof(T);\n      return (T*) (buf + buf_ind);\n    }\n\n    void deallocate(T*, size_t) {}\n  };\n\n  /**\n   * Frees the arena, be very sure no allocation is still used when calling this\n   */\n  static void Clear() {\n    buf_ind = SIZE;\n  }\n};\n\ntemplate <size_t SIZE> char Arena<SIZE>::buf[SIZE];\ntemplate <size_t SIZE> size_t Arena<SIZE>::buf_ind = SIZE;\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll, Alloc<ll>> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  int n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<int> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n    need[i] = max(0, need[i]);\n  }\n  vector<vector<int>> adj(n);\n  VEVE(e, 0, m) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<int, int, int>> pq, bad;// -cost, from, to\n  auto poss = [&](ll rem) {\n    Arena<>::Clear();\n    DisjointSet<Arena<>::Allocator> dsu(n);\n    fill(ALL(vis), false);\n    ll vis_cnt = 0;\n    while (not pq.empty())\n      pq.pop();\n    VEVE(i, 0, n) {\n      dsu.sum[i] = recv[i];\n      if (need[i] <= rem) {\n        vis[i] = true;\n        ++vis_cnt;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    if (vis_cnt == n)\n      return true;\n    while (true) {\n      bool changed = false;\n      while (not bad.empty())\n        bad.pop();\n      while (not pq.empty()) {\n        int cost, fr, to;\n        tie(cost, fr, to) = pq.top();\n        pq.pop();\n        cost = -cost;\n        if (dsu.IsSameSet(fr, to))\n          continue;\n        if (dsu.sum[dsu.Find(fr)] + rem >= cost) {\n          dsu.Unite(fr, to);\n          changed = true;\n          if (not vis[to]) {\n            vis[to] = true;\n            if (++vis_cnt == n) {\n              return true;\n            }\n            RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n          }\n        } else {\n          bad.emplace(-cost, fr, to);\n        }\n      }\n      if (not changed)\n        break;\n      pq.swap(bad);\n    }\n    return false;\n  };\n  ll low = *min_element(ALL(need)), hig = *max_element(ALL(need));\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\ntypedef long long ll;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=1e5+5;\n\nint t[N<<1],nxt[N<<1],lst[N],l;\nvoid add(int x,int y) {t[++l]=y;nxt[l]=lst[x];lst[x]=l;}\n\nint n,m,a[N],b[N],fa[N],ord[N];\nbool vis[N];\nll f[N],sum[N];\n\nvector<int> to[N];\n\nint get(int x) {return fa[x]?fa[x]=get(fa[x]):x;}\n\nbool cmp(int x,int y) {return a[x]<a[y];}\n\nvoid merge(int x,int y) {\n\tint a=get(x),b=get(y);\n\tif (a==b) return;\n\tfa[b]=a;to[x].push_back(b);\n}\n\nvoid dfs(int x) {\n\tif (to[x].empty()) {\n\t\tsum[x]=b[x];f[x]=a[x];\n\t\treturn;\n\t}\n\tsum[x]=b[x];\n\tfor(int y:to[x]) dfs(y),sum[x]+=sum[y];\n\tf[x]=1e18;\n\tfor(int y:to[x]) f[x]=min(f[x],max(f[y],a[x]-sum[y]));\n}\n\nint main() {\n\tn=read();m=read();\n\tfo(i,1,n) a[i]=read(),b[i]=read(),a[i]=max(0,a[i]-b[i]);\n\tfo(i,1,m) {\n\t\tint x=read(),y=read();\n\t\tadd(x,y);add(y,x);\n\t}\n\tfo(i,1,n) ord[i]=i;\n\tsort(ord+1,ord+n+1,cmp);\n\tfo(i,1,n) {\n\t\tint x=ord[i];vis[x]=1;\n\t\trep(j,x) {\n\t\t\tint y=t[j];\n\t\t\tif (!vis[y]) continue;\n\t\t\tmerge(x,y);\n\t\t}\n\t}\n\tdfs(ord[n]);\n\tprintf(\"%lld\\n\",f[ord[n]]+sum[ord[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\n#define inf 1000000001\nusing namespace std;\nll read(){\n\tchar ch=getchar();ll x=0;int op=1;\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') op=-1;\n\tfor (;isdigit(ch);ch=getchar()) x=(x<<1)+(x<<3)+ch-'0';\n\treturn x*op;\n}\n#define N 100005\nint n,m,cnt,head[N],a[N],b[N],fa[N],id[N],vis[N];ll s1[N],s2[N];\nstruct edge{int to,nxt;}e[N<<1];\nvoid adde(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nvoid ins(int x,int y){adde(x,y);adde(y,x);}\nconst bool cmp(const int x,const int y){return a[x]<a[y];}\nint getfa(int x){return x==fa[x]?x:fa[x]=getfa(fa[x]);}\nint main(){\n\tn=read(),m=read();\n\trep (i,1,n){a[i]=read(),b[i]=read();a[i]=max(a[i]-b[i],0);}\n\trep (i,1,m){int x=read(),y=read();ins(x,y);}\n\trep (i,1,n) fa[i]=id[i]=i,s1[i]=a[i],s2[i]=b[i];\n\tsort(&id[1],&id[n+1],cmp);\n\trep (i,1,n){\n\t\tint x=id[i];vis[x]=1;\n\t\tfor (int j=head[x],y;j;j=e[j].nxt){\n\t\t\ty=e[j].to;if (!vis[y]) continue;\n\t\t\tint fx=getfa(x),fy=getfa(y);\n\t\t\tif (fx!=fy){\n\t\t\t\tfa[fy]=fx;s2[fx]+=s2[fy];\n\t\t\t\ts1[fx]=min(s1[fx],s1[fy]+max(0ll,a[x]-s1[fy]-s2[fy]));\n\t\t\t}\n\t\t}\n\t}\n\tint x=getfa(1);\n\tcout<<s1[x]+s2[x]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (a[v] - b[v] > cp[i].first - cp[i].second)\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || cp[0].first < a[v] - b[v])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n \nconst int N = 1e5 + 5;\n\nint A[N], B[N], P[N];\nll S[N], W[N];\nvector< pair<int, pii> > E;\n\nint GetPar(int v) { return P[v] == v ? v : P[v] = GetPar(P[v]); }\nvoid Merge(int v, int u) {\n\tif (A[v] - B[v] < A[u] - B[u]) swap(v, u);\n\tint pv = GetPar(v), pu = GetPar(u);\n\tif (pv == pu) return;\n\tW[pv] = min(W[pv], (W[pu] + S[pu] >= A[v] - B[v] ? W[pu] : A[v] - B[v] - S[pu]));\n\tS[pv] += S[pu];\n\tP[pu] = pv;\n}\n\nint main() {\n \n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\t\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> A[i] >> B[i], P[i] = i, S[i] = B[i], W[i] = A[i] - B[i];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint v, u; cin >> v >> u;\n\t\tE.push_back(make_pair(max(A[v] - B[v], A[u] - B[u]), make_pair(v, u)));\n\t}\n\tsort(all(E));\n\tfor (auto e : E) {\n\t\tint v = e.second.first, u = e.second.second;\n\t\tMerge(v, u);\n\t}\n\tcout << max(0LL, W[GetPar(1)] + S[GetPar(1)]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, m, cnt, top, s, maxi, now, sta[Maxn], a[Maxn], b[Maxn], w[Maxn], head[Maxn];\nlong long sum[Maxn], mini[Maxn];\nvector <int> Ve[Maxn];\nqueue <int> Qu;\nbool vis[Maxn], vis2[Maxn];\nstruct edg\n{\n\tint nxt, to;\n}edge[2 * Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs(int u)\n{\n\tvis2[u] = true;\n\tsta[++top] = u;\n\tif (w[u] > maxi) maxi = w[u], now = u;\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tif (!vis[to] && !vis2[to])\n\t\t\tdfs(to);\n\t}\n}\nvoid dfs2(int u)\n{\n\tmini[u] = 0x3f3f3f3f3f3f3f3f;\n\tsum[u] = b[u];\n\tfor (vector <int> :: iterator it = Ve[u].begin(); it != Ve[u].end(); it++)\n\t{\n\t\tint to = *it;\n\t\tdfs2(to);\n\t\tsum[u] += sum[to];\n\t\tmini[u] = min(mini[u], max((long long) w[u], mini[to]) - sum[to]);\n\t}\n\tif (!Ve[u].size()) mini[u] = w[u] + b[u];\n\telse mini[u] += sum[u];\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0, a[i] - b[i]);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (w[i] > maxi) maxi = w[i], s = i;\n\tQu.push(s);\n\twhile (!Qu.empty())\n\t{\n\t\tint u = Qu.front();\n\t\tvis[u] = true;\n\t\tQu.pop();\n\t\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tnow = -1, maxi = -1;\n\t\t\tint to = edge[i].to;\n\t\t\tif (vis[to] || vis2[to]) continue;\n\t\t\tdfs(to);\n\t\t\tif (now != -1)\n\t\t\t{\n\t\t\t\tVe[u].push_back(now);\n\t\t\t\tQu.push(now);\n\t\t\t}\n\t\t}\n\t\twhile (top) vis2[sta[top--]] = false;\n\t}\n\tdfs2(s);\n\tprintf(\"%lld\", mini[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* UnionFind */\n\nstruct UnionFind{\n  vector<int> data, tree_size;\n  UnionFind(int s):data(s,-1),tree_size(s,1) {}\n  \n  int root(int x){\n    if(data[x]==-1) return x;\n    return data[x]=root(data[x]);\n  }\n  \n  bool set(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    data[y]=x;\n    tree_size[x] += tree_size[y];\n    tree_size[y] = 0;\n    return true;\n  }\n  \n  bool check(int x,int y){\n    x=root(x);\n    y=root(y);\n    return x==y;\n  }\n  \n  int size(int x){\n    return tree_size[root(x)];\n  }\n  \n};\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE];\n  vector<pair<int,int> > vec;\n  vector<int> g[SIZE];\n  pair<ll,ll> dp[SIZE];\n  \n  scanf(\"%d%d\", &n, &m);\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\", a+i, b+i);\n    vec.push_back({a[i], i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  for(int i=0;i<m;i++){\n    int u, v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  UnionFind uf(n);\n\n  bool used[SIZE] = {};\n  \n  for(int i=0;i<n;i++){\n    int p = vec[i].second;\n    vector<int> uni;\n    \n    for(int j=0;j<g[p].size();j++){\n      if (used[g[p][j]])\n        uni.push_back(uf.root(g[p][j]));\n    }\n    used[p] = true;\n\n    sort(uni.begin(), uni.end());\n    uni.erase(unique(uni.begin(), uni.end()), uni.end());\n    \n    ll sum = 0;\n\n    for(int j=0;j<uni.size();j++){\n      sum += dp[uni[j]].second;\n    }\n    sum += b[p];\n\n    pair<ll,ll> calc = {LLINF, LLINF};\n    \n    for(int j=0;j<uni.size();j++){\n      int q = uni[j];\n      ll nowcost = dp[q].first;\n\n      nowcost += b[p];\n      nowcost = max(nowcost, (ll)a[p]);\n      nowcost += sum - (dp[q].second + b[p]);\n\n      calc = min(calc, make_pair(nowcost, sum));\n    }\n\n    calc = min(calc, make_pair(max(a[p], b[p]) + (sum - b[p]), sum));\n    \n    for(int j=0;j<uni.size();j++){\n      uf.set(p, uni[j]);\n    }\n\n    dp[uf.root(p)] = calc;\n\n    //debug(uf.root(p));\n    //debug(calc.first);\n  }\n  \n  printf(\"%lld\\n\", dp[uf.root(0)].first);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing db = double;\nusing vi = vector<int>;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define debug(x) cout << #x <<'\t' << x <<endl\nconst int inf = 0x3f3f3f3f;\nconst db eps = 1e-8;\nconst int mod = 1e9+7;\nll qpow(ll a, ll b){\n    ll ret = 1;\n    while(b){\n        if(b&1)ret = ret*a%mod;\n        a = a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\n\nconst int maxn = 200010;\nint n, m;\nll a[maxn], b[maxn], sum[maxn], f[maxn], p[maxn], dp[maxn], vis[maxn];\nint Find(int x){\n\treturn f[x] == x?x:Find(f[x]);\n} \nvector<int>G[maxn];\nbool cmp(int x, int y){\n\treturn a[x] < a[y];\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; ++i){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i]-b[i], 0ll);\n\t\tp[i] = f[i] = i;\n\t\tsum[i] = b[i];\n\t\tdp[i] = a[i];\n\t}\n\tfor(int i=0, u, v; i<m; ++i){\n\t\tcin >> u >> v;\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tsort(p+1, p+1+n, cmp);\n\tfor(int i=1; i<=n; ++i){\n\t\tint u = p[i];\n\t\tvis[u] = 1;\n\t\tfor(auto v:G[u]){\n\t\t\tif(vis[v]){\n\t\t\t\tint x = Find(u), y = Find(v);\n\t\t\t\tif(x!=y){\n\t\t\t\t\tf[y] = x;\n\t\t\t\t\tsum[x] += sum[y];\n\t\t\t\t\tdp[x] = min(dp[x], max(dp[y], a[x]-sum[y]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n\tcout << dp[Find(1)] + sum[Find(1)] <<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define int ll\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nVI e[MAXN];\nint a[MAXN],b[MAXN],f[MAXN],sum[MAXN],vis[MAXN],id[MAXN],ans[MAXN];\nint compare(int x,int y) { return a[id[x]]<a[id[y]]; }\nint find(int x) { return f[x]==x?f[x]:f[x]=find(f[x]); }\nsigned main()\n{\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tid[i]=f[i]=i;\n\t}\n\tsort(id+1,id+n+1,compare);\n\tfor (int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].PB(v),e[v].PB(u);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tVI to; int x=id[i];\n\t\tto.clear(),vis[x]=1,sum[x]=b[x];\n\t\tfor (auto v:e[x])\n\t\t{\n\t\t\tif (!vis[v]||find(x)==find(v)) continue;\n\t\t\tto.PB(find(v));\n\t\t\tsum[x]+=sum[find(v)];\n\t\t\tf[find(v)]=x;\n\t\t}\n\t\tans[x]=sum[x]+a[x];\n\t\tfor (auto v:to) upmin(ans[x],sum[x]-sum[v]+max(a[x],ans[v]));\n\t}\n\tprintf(\"%lld\\n\",ans[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm>\n#include <vector> \nusing namespace std; \ninline int gi() {\n    register int data = 0, w = 1;\n    register char ch = 0;\n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 1e5 + 5; \nint N, M, a[MAX_N], b[MAX_N], p[MAX_N]; \nint pa[MAX_N]; \nint getf(int x) { while (x != pa[x]) x = pa[x] = pa[pa[x]]; return x; } \nvector<int> G[MAX_N]; \nlong long f[MAX_N], sum[MAX_N];\nbool vis[MAX_N]; \nint main () { \n\tN = gi(), M = gi();\n\tfor (int i = 1; i <= N; i++) { \n\t\ta[i] = gi(), b[i] = gi(); \n\t\ta[i] = max(a[i] - b[i], 0);\n\t\tp[i] = i, pa[i] = i; \n\t} \n\tsort(&p[1], &p[N + 1], [](const int &l, const int &r) { return a[l] < a[r]; } ); \n\tfor (int i = 1; i <= M; i++) { \n\t\tint u = gi(), v = gi(); \n\t\tG[u].push_back(v), G[v].push_back(u); \n\t} \n\tfor (int i = 1; i <= N; i++) { \n\t\tvector<int> son;\n\t\tint x = p[i]; \n\t\tvis[x] = 1, sum[x] = b[x]; \n\t\tfor (auto v : G[x]) {\n\t\t\tif (!vis[v] || getf(x) == getf(v)) continue; \n\t\t\tson.push_back(getf(v)); \n\t\t\tsum[x] += sum[getf(v)]; \n\t\t\tpa[getf(v)] = getf(x); \n\t\t} \n\t\tf[x] = sum[x] + a[x]; \n\t\tfor (auto v : son) f[x] = min(f[x], sum[x] - sum[v] + max(1ll * a[x], f[v])); \n\t} \n\tprintf(\"%lld\\n\", f[p[N]]); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <sstream>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nusing int64 = long long;\n\n#define repeat(i, n) for (auto i = decltype(n)(); (i) < (n); (i)++)\n\nstruct Edge {\n  using Weight = int;\n\n  int end1, end2;\n  Weight weight;\n\n  Edge() = default;\n  Edge(int end1, int end2, Weight weight): end1(end1), end2(end2), weight(weight) {}\n\n  bool operator<(const Edge& e) const {\n    return weight < e.weight;\n  }\n};\n\nstruct Graph {\n  int node_num;\n  std::vector<std::vector<Edge>> adjacent_list;\n  std::vector<Edge> edges;\n\n  Graph() = default;\n  Graph(int node_num): node_num(node_num), adjacent_list(node_num) {}\n\n  const std::vector<Edge>& operator[](std::size_t u) const {\n    return adjacent_list[u];\n  }\n  std::vector<Edge>& operator[](std::size_t u) {\n    return adjacent_list[u];\n  }\n\n  void AddEdge(int end1, int end2, Edge::Weight weight = 0) {\n    adjacent_list[end1].emplace_back(end1, end2, weight);\n    adjacent_list[end2].emplace_back(end2, end1, weight);\n    edges.emplace_back(end1, end2, weight);\n  }\n};\n\nstruct UnionFindTree {\n  int size; \n  std::vector<int> parent;\n\n  UnionFindTree() = default;\n  UnionFindTree(int size): size(size), parent(size, -1) {}\n  \n  int Size() const { return size; }\n  int Size(int e) { return -parent[Root(e)]; }\n\n  bool Same(int e1, int e2) { return Root(e1) == Root(e2); }\n\n  void Unite(int e1, int e2) {\n    if ((e1 = Root(e1)) != (e2 = Root(e2))) {\n      if (Size(e1) < Size(e2)) {\n        std::swap(e1, e2);\n      }\n      // e1の属する集合にe2の属する集合を併合\n      parent[e1] += parent[e2];\n      parent[e2] = e1;\n      size--;\n    }\n  }\n\n  int Root(int e) { \n    if (parent[e] < 0) return e;\n    parent[e] = Root(parent[e]);\n    return parent[e];\n  }\n};\n\nint N, M;\nGraph graph;\nint64 A[100000], B[100000];\n\nbool CanClearGame(int64 w) {\n  int start = 0;\n  int64 sum_B = 0;\n  for (int u = 0; u < N; u++) {\n    if (B[u] > B[start] or (B[u] == B[start] and A[u] < A[start])) {\n      start = u;\n    }\n    sum_B += B[u];\n  }\n  if (w < sum_B) return false;\n\n  int64 cur_yen = w - (sum_B - B[start]);\n  if (cur_yen < A[start]) return false;\n\n  vector<bool> visited(N, false);\n  queue<int> que;\n  que.push(start);\n  visited[start] = true;\n  int num_visited = 0;\n\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    num_visited++;\n\n    for (Edge& e : graph[u]) {\n      if (!visited[e.end2] and cur_yen + B[e.end2] >= A[e.end2]) {\n        visited[e.end2] = true;\n        cur_yen += B[e.end2];\n\n        que.push(e.end2);\n      }\n    }\n  }\n  return num_visited == N and cur_yen == w;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n\n  cin >> N >> M;\n\n  graph = Graph(N);\n\n  int64 max_A = 0, sum_B = 0;\n  repeat (i, N) {\n    cin >> A[i] >> B[i];\n    max_A = max(max_A, A[i]);\n    sum_B += B[i];\n  }\n  repeat (i, M) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    graph.AddEdge(u, v);\n  }\n\n  int64 lb = 0, \n        ub = max_A + sum_B;\n  while (ub - lb > 1) {\n    int64 mid = (ub + lb) / 2;\n\n    if (CanClearGame(mid)) ub = mid;\n    else lb = mid;\n  }\n  cout << ub << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define int long long\nusing namespace std;\nconst int N=200010;\nint n,m,x,y,z,tot,pool,cnt,ans,A[N],B[N],s[N],f[N],rt[N],first[N],a[N<<1][2];\nstruct tjm{int node,val;} now;\nstruct tree{int lc,rc,node,val;} t[N<<1];\nstruct cmp{\n\tbool operator () (tjm p,tjm q) {\n\t\treturn p.val>q.val;\n\t}\n};\npriority_queue<tjm,vector<tjm>,cmp> h,hh;\ninline int read() {\n\tint tmp=0, fh=1; char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') fh=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') tmp=tmp*10+c-48, c=getchar();\n\treturn tmp*fh;\n}\ninline void ins_ed(int x,int y) {\n\ta[++tot][1]=y;\n\ta[tot][0]=first[x];\n\tfirst[x]=tot;\n}\nint gf(int x) {return x==f[x]?x:f[x]=gf(f[x]);}\ninline int newnode(int x) {\n\tt[++pool]=(tree){0,0,x,A[x]-B[x]};\n\treturn pool;\n}\nint merge(int x,int y) {\n\tif ((!x)||(!y)) return x+y;\n\tif (t[x].val>t[y].val) swap(x,y);\n\tt[x].rc=merge(t[x].rc,y);\n\tswap(t[x].lc,t[x].rc);\n\treturn x;\n}\ninline void gather(int x,int y) {\n\tf[y]=x; s[x]+=s[y];\n\trt[x]=merge(rt[x],rt[y]);\n}\ninline void update(int x) {\n\twhile (gf(t[rt[x]].node)==x) rt[x]=merge(t[rt[x]].lc,t[rt[x]].rc);\n}\nsigned main() {\n\tn=read(); m=read();\n\tfor (int i=1;i<=n;i++) A[i]=read(), B[i]=read();\n\tfor (int i=1;i<=m;i++) {\n\t\tx=read(); y=read();\n\t\tins_ed(x,y); ins_ed(y,x);\n\t}\n\tfor (int i=1;i<=n;i++) hh.push((tjm){i,A[i]-B[i]});\n//\tfor (int i=1;i<=n;i++) if (A[i]<=B[i]) f[i]=i, s[i]=B[i], cnt++;\n//\tfor (int i=1;i<=n;i++) if (f[i]) {\n//\t\tx=gf(i);\n//\t\tfor (int j=first[i];j;j=a[j][0]) {\n//\t\t\ty=a[j][1];\n//\t\t\tif (!f[y]) rt[x]=merge(rt[x],newnode(y));\n//\t\t\telse if (gf(y)!=x) gather(x,gf(y));\n//\t\t}\n//\t}\n//\tfor (int i=1;i<=n;i++) if (f[i]==i) {\n//\t\tupdate(i);\n//\t\th.push((tjm){i,t[rt[i]].val-s[i]});\n//\t}\n\tans=0;\n\twhile (cnt<n) {\n\t\t//printf(\"! %d %d\\n\",hh.top().node,hh.top().val);\n\t\tif (h.empty()||(hh.top().val<=h.top().val)) {\n\t\t\tnow=hh.top(); hh.pop();\n\t\t\tx=now.node; if (f[x]) continue;\n\t\t\t//printf(\" %d %d\\n\",x,now.val);\n\t\t\tans=max(ans,now.val);\n\t\t\tf[x]=x; s[x]=B[x], cnt++;\n\t\t\tfor (int i=first[x];i;i=a[i][0]) {\n\t\t\t\ty=a[i][1];\n\t\t\t\tif (!f[y]) rt[x]=merge(rt[x],newnode(y));\n\t\t\t\telse gather(x,gf(y));\n\t\t\t}\n\t\t\tif (rt[x]) {\n\t\t\t\tupdate(x); h.push((tjm){x,t[rt[x]].val-s[x]});\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnow=h.top(); h.pop();\n\t\tx=now.node; if (f[x]!=x) continue;\n\t\ty=t[rt[x]].node; ans=max(ans,now.val);\n\t\t//printf(\"%d %d %d\\n\",x,y,now.val);\n\t\trt[x]=merge(t[rt[x]].lc,t[rt[x]].rc);\n\t\tf[y]=x; s[x]+=B[y]; cnt++;\n\t\tfor (int i=first[y];i;i=a[i][0]) {\n\t\t\tz=a[i][1];\n\t\t\tif (!f[z]) rt[x]=merge(rt[x],newnode(z));\n\t\t\telse if (gf(z)!=x) gather(x,gf(z));\n\t\t}\n\t\tif (rt[x]) {\n\t\t\tupdate(x);\n\t\t\th.push((tjm){x,t[rt[x]].val-s[x]});\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) ans+=B[i];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n#define FOR(i, a, b) for (int i = (a), i##_END_ = (b); i <= i##_END_; i++)\n#define DNF(i, a, b) for (int i = (a), i##_END_ = (b); i >= i##_END_; i--)\n\ntemplate <typename Tp> void in(Tp &x) {\n\tchar ch = getchar(), f = 1; x = 0;\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') ch = getchar(), f = -1;\n\twhile (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n\tx *= f;\n}\n\ntemplate <typename Tp> void out(Tp x) {\n\tif (x > 9) out(x / 10);\n\tputchar(x % 10 + '0');\n\treturn;\n}\n\ntemplate <typename Tp> Tp Max(const Tp &x, const Tp &y) {return x > y ? x : y;}\ntemplate <typename Tp> Tp Min(const Tp &x, const Tp &y) {return x < y ? x : y;}\ntemplate <typename Tp> bool chkmax(Tp &x, Tp y) {return x >= y ? 0 : (x=y, 1);}\ntemplate <typename Tp> bool chkmin(Tp &x, Tp y) {return x <= y ? 0 : (x=y, 1);}\n\nconst int MAXN = 100010;\n\nint n, m, A[MAXN], B[MAXN], to[MAXN];\nint head[MAXN], data[MAXN << 1], nxt[MAXN << 1], cnt;\n\nint fa[MAXN], rnk[MAXN];\n\nLL need[MAXN];\nLL sum[MAXN];\n\nchar cmp(const int &x, const int &y) {return A[x] - B[x] < A[y] - B[y];}\n\nvoid add(int x, int y)\n{\n\tnxt[cnt] = head[x]; data[cnt] = y; head[x] = cnt++;\n\tnxt[cnt] = head[y]; data[cnt] = x; head[y] = cnt++;\n}\n\nint find(int x) {while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x;}\n\nint main()\n{\n\tin(n); in(m);\n\tFOR(i, 1, n) in(A[i]), in(B[i]);\n\tFOR(i, 1, n) to[i] = i;\n\n\tstd::sort(to + 1, to + n + 1, cmp);\n\n\tmemset(head, -1, sizeof head);\n\tFOR(i, 1, n) fa[i] = i;\n\tFOR(i, 1, m) {int x, y; in(x); in(y); add(x, y);}\n\n\tFOR(i, 1, n) rnk[to[i]] = i;\n\tFOR(i, 1, n) sum[i] = 0;\n\n\tLL all = 0;\n\n\tFOR(i, 1, n) all += B[i];\n\n\tmemset(need, 0x3f, sizeof need);\n\t\n\tFOR(i, 1, n) {\n\t\tint now = to[i];\n\t\t\n\t\tfor (int j = head[now]; j != -1; j = nxt[j]) {\n\t\t\tint fx;\n\t\t\tif ((fx = find(data[j])) != find(now) && rnk[data[j]] < i) {\n\t\t\t\tfa[fx] = find(now); sum[find(now)] += sum[fx];\n\t\t\t\tchkmin(need[find(now)], Max(need[fx], Max(0ll, A[now] - B[now] - sum[fx])));\n\t\t\t}\n\t\t}\n\n\t\tchkmin(need[find(now)], Max(0ll, A[now] - B[now] + 0ll));\n\t\tsum[find(now)] += B[now];\n\t}\n\n\tprintf(\"%lld\\n\", need[find(1)] + all);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int & \n#define SZ(a) ((int)(a.size()))\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n\tfor (T x : a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\nconst int N = 1e5 + 9;\nconst ll oo = 1e15;\nint parent[N];\nint is_free[N];\nll bsum[N];\nvi g[N];\nint n, m;\nll a[N], b[N];\n\nset<int> inside[N];\nset<pair<ll, int>> neibs[N];\nll gw, gb;\nset<pair<ll, int>> fre;\nint counter = 0;\n\nvoid make_set(int v) {\n\t++counter;\n\tinside[v].insert(v);\n\tparent[v] = v;\n\tbsum[v] = b[v];\n\tfor (int to : g[v]) \n\t\tneibs[v].insert(mp(a[to] - b[to], to));\n}\n\nint find_set(int v) {\n\tif (parent[v] == v) return v;\n\treturn parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int u, int v) {\n\tu = find_set(u);\n\tv = find_set(v);\n\tif (u == v) return;\n\t--counter;\n\tis_free[v] = 1;\n\tif (SZ(neibs[u]) < SZ(neibs[v]))\n\t\tswap(v, u);\n\tinside[u].insert(ALL(inside[v]));\n\tbsum[u] += bsum[v];\n\tparent[v] = u;\n\tneibs[u].insert(ALL(neibs[v]));\n}\n\nvoid add_to_free(int u) {\n\twhile (!neibs[u].empty()) {\n\t\tbool ok = 0;\n\t\tif (inside[u].count((*neibs[u].begin()).second)) {\n\t\t\tok = 1;\n\t\t\tneibs[u].erase(neibs[u].begin());\n\t\t}\n\t\tif (!ok) break;\n\t}\n\tif (neibs[u].empty()) {\n\t\tassert(counter == 1);\n\t\treturn;\n\t}\n\tint superv = (*neibs[u].begin()).second;\n\tfre.insert(mp(a[superv] - b[superv] - bsum[u], u));\n}\n\nvoid add_to_cool(int v) {\n\tv = find_set(v);\n\tis_free[v] = 1;\n\twhile (!neibs[v].empty() && (*neibs[v].begin()).first + gb - bsum[v] <= gw) {\n\t\tint u = (*neibs[v].begin()).second;\n\t\tneibs[v].erase(neibs[v].begin());\n\t\tunion_sets(v, u);\n\t\tv = find_set(v);\n\t}\n\tadd_to_free(v);\n}\n\n\n\nll solve() {\n\tgb = accumulate(b + 1, b + n + 1, 0LL);\n\tfori(i, n) {\n\t\tmake_set(i + 1);\n\t\tfre.insert(mp(a[i + 1] - b[i + 1], i + 1));\n\t}\n\twhile (counter > 1) {\n\t\tll minim = (*fre.begin()).first;\n\t\t// minim + gb <= gw\n\t\t//watch(minim);\n\t\tgw = minim + gb; \n\t\twhile (!fre.empty() && (*fre.begin()).first + gb == gw) {\n\t\t\tint v = find_set((*fre.begin()).second);\n\t\t\tfre.erase(fre.begin());\n\t\t\tadd_to_cool(v);\n\t\t}\n\t}\n\treturn gw;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tmmax(a[i], b[i]);\n\t}\n\tfori(iter, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\tcout << solve() << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#define MAXN 100010\n\nint n, m, a[MAXN], b[MAXN], c[MAXN], p[MAXN];\nstruct edge {\n    int u, v, w;\n    inline friend bool operator<(const edge &a, const edge &b) {\n        return a.w < b.w;\n    }\n} e[MAXN];\ninline int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); }\nstd::vector<int> next[MAXN];\nlong long sum[MAXN];\n\nlong long dp(int x) {\n    long long ret = c[x];\n    sum[x] = b[x];\n    for (int y : next[x]) {\n        long long res = dp(y);\n        ret = std::min(ret, std::max(0LL + c[x], res) - sum[y]);\n        sum[x] += sum[y];\n    }\n    return ret + sum[x];\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n        a[i] = std::max(a[i], b[i]);\n        c[i] = a[i] - b[i];\n        p[i] = i;\n    }\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d%d\", &e[i].u, &e[i].v);\n        e[i].w = std::max(c[e[i].u], c[e[i].v]);\n    }\n    std::sort(e + 1, e + m + 1);\n    for (int i = 1; i <= n; i++) {\n        int U = find(e[i].u), V = find(e[i].v);\n        if (U == V) continue;\n        if (c[e[i].u] < c[e[i].v]) std::swap(e[i].u, e[i].v);\n        next[find(e[i].u)].push_back(find(e[i].v));\n        p[U] = V;\n    }\n    printf(\"%lld\\n\", dp(find(1)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<ll> vll;\ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 1e5 + 41;\nint const INF = 1e9 + 41;\n\nint n, m;\nint a[MAX];\nint b[MAX];\nint per[MAX];\nvi e[MAX];\n\nll sumb, ans;\n\nbool cmp(int x, int y) {\n\treturn b[x] > b[y];\t\n}\n\nint par[MAX];\n\nvoid init() {\n\tfi(1, n) {\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool uni(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) return false;\n\tpar[b] = a;\n\treturn true;\n}\n\nbool can(int h) {\n\tfi(1, n) {\n\t\tint root = per[i];\n\t\tif (b[root] + h < a[root]) continue;\n\t\tll sum = b[root] + h;\n\t\tinit();\n\t\tset<pii> t;\n\t\tint q = 1;\n\t\tfor (int y : e[root]) {\n\t\t\tt.insert(mp(a[y] - b[y], y));\n\t\t}\t\t\n\t\twhile (q < n) {\n\t\t\tif (!sz(t)) break;\n\t\t\tpii cur = (*t.begin());\n\t\t\tt.erase(t.begin());\n\t\t\tif (cur.first > sum) break;\n\t\t\tint x = cur.second;\n\t\t\tif (!uni(root, x)) continue;\n\t\t\tq++;\n\t\t\tsum += cur.first;\n\t\t\tfor (int y : e[x]) {\n\t\t\t\tif (find(y) == root) continue;\n\t\t\t\tt.insert(mp(a[y] - b[y], y));\n\t\t\t}\t\t\n\t\t}\n\t\tif (q == n) return true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tfi(1, n) {\n\t\tper[i] = i;\n\t}\n\tsort(per + 1, per + n + 1, cmp);\n\tfi(1, n) {\n\t\tsumb += b[i];\n\t}\n\tint l = -1;\n\tint r = INF;\t\n\t\n\twhile (r - l > 1) {\n\t\tint h = (l + r) / 2;\n\t\tif (can(h)) {\n\t\t\tr = h;\n\t\t} else {\n\t\t\tl = h;\n\t\t}\n\t}\n\tans = r + sumb;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n  scanf(\"%d %d\", &n, &m);\n  fi(1, n) {\n  \tscanf(\"%d %d\", &a[i], &b[i]);\n  }\n  fi(1, m) {\n  \tint x, y;\n  \tscanf(\"%d %d\", &x, &y);\n  \te[x].pb(y);\n  \te[y].pb(x);\n  }\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=100007;\nint a[maxn],n,m,f[maxn],vis[maxn],sum[maxn],b[maxn],c[maxn],p[maxn],fa[maxn];\nvector<int>v[maxn];\nint find(int x){return fa[x]==x?fa[x]:fa[x]=find(fa[x]);}\ninline bool cmp(int x,int y){return c[x]<c[y];}\nsigned main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)cin>>a[i]>>b[i],p[i]=fa[i]=i,c[i]=max(a[i]-b[i],0ll);\n\tsort(p+1,p+1+n,cmp);\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tcin>>x>>y;v[x].push_back(y);v[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tint x=p[i];vis[x]=1;\n\t\tsum[x]=b[x];vector<int>son;\n\t\tfor(auto y:v[x])if(find(y)^find(x)&&vis[y])sum[x]+=sum[find(y)],son.push_back(find(y)),fa[find(y)]=find(x);\n\t\tf[x]=sum[x]-b[x]+max(a[x],b[x]);\n\t\tfor(auto y:son)f[x]=min(f[x],sum[x]-b[x]-sum[y]+max(max(a[x],b[x]),f[y]+b[x]));\n\t}\n\tcout<<f[p[n]];\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\n#include<fstream>\nusing namespace std;\n\nconst int maxn = 30;\n\nstruct node\n{\n    int x,y;\n    node(int x,int y):x(x),y(y){}\n};\n\nint mp[maxn][maxn],n,m,a[maxn],b[maxn],vis[maxn][maxn];\n\nqueue<node>q;\n\nvoid check(int x,int y)\n{\n    if (mp[x][y]<=0 || mp[x][y]>20)\n        {\n            q.push(node(x,y));\n            vis[x][y]=1;\n        }\n}\n\nint main()\n{\n//\tfstream in,out;\n//\tin.open(\"test.txt\",ios::in);\n//\tout.open(\"510.out\",ios::out);\n//\t#define cin in\n//\t#define cout out\n\t\n    std::ios::sync_with_stdio(false);\n    cin>>n>>m;\n    memset(vis,0,sizeof(vis));\n    int suma=0,sumb=0;\n    for (int i=1;i<=n;i++) {cin>>a[i];suma+=a[i];}\n    for (int j=1;j<=m;j++) {cin>>b[j];sumb+=b[j];}\n\n    if (suma!=sumb) cout<<\"No\";\n    else\n    {\n        for (int i=2;i<=n;i++)\n        {\n            int temp=a[i]/m;\n            for (int j=1;j<m;j++) mp[i][j]=temp;\n            mp[i][m]=a[i]-temp*(m-1);\n        }\n        for (int j=1;j<=m;j++)\n        {\n            int temp=b[j];\n            for (int i=2;i<=n;i++) temp-=mp[i][j];\n            mp[1][j]=temp;\n        }\n\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=m;j++)\n                check(i,j);\n\n        int cnt=0,flag=0;\n        while (!q.empty())\n        {\n          //  cnt++;\n          //  if (cnt>10000) {flag=1;break;}\n            int r=q.front().x;\n            int c=q.front().y;\n            if (mp[r][c]>0 && mp[r][c]<=20) {q.pop();continue;}\n            for (int i=1;i<=n;i++)\n                for (int j=1;j<=m;j++) if (i!=r && j!=c && vis[i][j]==0)\n                {\n                    if (mp[r][c]>0 && mp[r][c]<=20) break;\n                    int d;\n                    if (mp[r][c]<=0)\n                    {\n                        if (mp[i][j]>=20 || mp[i][c]<=1 || mp[r][j]<=1) continue;\n                        d=1-mp[r][c];\n                        mp[r][c]+=d;mp[i][j]+=d;\n                        mp[r][j]-=d;mp[i][c]-=d;\n                    }\n                    else if (mp[r][c]>20)\n                    {\n                        if (mp[r][c]<=1 || mp[i][c]>=20 || mp[r][j]>=20) continue;\n                        d=mp[r][c]-20;\n                        mp[r][c]-=d;mp[i][j]-=d;\n                        mp[r][j]+=d;mp[i][c]+=d;\n                    }\n                    check(i,j);check(r,j);check(i,c);\n                }\n            q.pop();vis[r][c]=0;\n        }\n\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=m;j++)\n                if (mp[i][j]<=0 || mp[i][j]>20) flag=1;\n\n        if (flag) cout<<\"No\"<<endl;\n        else\n        {\n            cout<<\"Yes\"<<endl;\n            for (int i=1;i<=n;i++)\n            {\n                for (int j=1;j<=m;j++) cout<<mp[i][j]<<\" \";\n                cout<<endl;\n            }\n        }\n    }\n//\tin.close();\n//\tout.close();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    friend bool operator< (Info a , Info b)  {return a.cost < b.cost;}\n};\n\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nvoid unlock(int x) ;\nvoid merge(int x , int y) ;\n\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) unlock(y);\n            else {\n                out[p].insert(y);\n                modifycost(y , (int)max(limit[y] - money[p] , 0LL));                \n            }\n        }\n    }\n}\n\n\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n    while(out[y].size()) {\n        x = *out[y].begin();\n        if(find(x) == y) {\n            out[y].erase(*out[y].begin());\n            continue;\n        }\n        if(money[y] + init >= limit[x]) {\n            out[y].erase(*out[y].begin());\n            unlock(x);\n            y = find(y);\n            continue;\n        }\n        modifycost(x , (int)max(limit[x] - money[y] , 0LL));\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef unsigned int uint;\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nconst int MX = 200005;\n\nstruct UF{\n\tint t[MX];\n\tll ans[MX], tB[MX];\n\tint find(int x){ return t[x] ? t[x] = find(t[x]) : x; }\n\tint merge(int a, int b){ // a <- b\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return false;\n\t\tt[b] = a; tB[a] += tB[b]; return true;\n\t}\n}uf;\n\nint N, M;\npii D[MX];\nvector<int> G[MX];\nint P[MX], chk[MX];\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d%d\", &D[i].first, &D[i].second);\n\tfor(int i = 1; i <= M; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++) P[i] = i;\n\tsort(P+1, P+N+1, [](int l, int r){ \n\t\treturn D[l].first - D[l].second < D[r].first - D[r].second;\n\t});\n\tfor(int i = 1; i <= N; i++) uf.tB[i] = D[i].second;\n\tfor(int i = 1; i <= N; i++){\n\t\tint cur = P[i], A = D[cur].first, B = D[cur].second;\n\t\tll ans = max(A-B, 0);\n\t\tfor(int c : G[cur]){\n\t\t\tif(!chk[c]) continue;\n\t\t\tint u = uf.find(c);\n\t\t\tans = min(ans, max(uf.ans[u], A - (B+uf.tB[u])));\n\t\t}\n\t\tuf.ans[cur] = ans;\n\t\tfor(int c : G[cur]) if(chk[c]) uf.merge(cur, c);\n\t\tchk[cur] = 1;\n\t}\n\tint p = uf.find(1);\n\tprintf(\"%lld\\n\", uf.ans[p] + uf.tB[p]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, ll, ll>> pq;// -cost, from, to\n  auto poss = [&](ll rem) {\n    DisjointSet<> dsu(n);\n    fill(ALL(vis), false);\n    VEVE(i, 0, n) {\n      dsu.sum[i] = recv[i];\n      if (need[i] <= rem) {\n        vis[i] = true;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    while (not pq.empty()) {\n      ll cost, fr, to;\n      tie(cost, fr, to) = pq.top();\n      pq.pop();\n      cost = -cost;\n      if (dsu.IsSameSet(fr, to))\n        continue;\n      if (dsu.sum[dsu.Find(fr)] + rem >= cost) {\n        dsu.Unite(fr, to);\n        if (not vis[to]) {\n          vis[to] = true;\n          dsu.sum[dsu.Find(to)] += recv[to];\n          RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n        }\n      }\n    }\n    VEVE(i, 0, n) if (not vis[i]) return false;\n    return true;\n  };\n  poss(0);\n  ll low = 0, hig = 1e9;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int maxn=1e5+5;\ntypedef long long ll;\nll dp[maxn],s[maxn];\nll val[maxn];\nvector<int> adj[maxn],bdj[maxn];\nint a[maxn],b[maxn],n,m;\npair<int,int> c[maxn];\nint ufs[maxn];\nint vis[maxn];\ninline int find(int u){\n\tif (ufs[u]==u) return u;\n\telse return ufs[u]=find(ufs[u]);\n}\ninline bool cmp1(pair<int,int> a1,pair<int,int> b1){\n\treturn a1.first<b1.first;\n}\ninline void dfs(int u,int fa){\n\ts[u]=b[u];\n\tfor (int i=0;i<bdj[u].size();i++){\n\t\tint v=bdj[u][i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,u);\n\t\ts[u]+=s[v];\n\t}\n\tif (bdj[u].size()==0){\n\t\tdp[u]=s[u]+val[u];\n\t\treturn;\n\t}\n\telse dp[u]=1e16;\n\tfor (int i=0;i<bdj[u].size();i++){\n\t\tint v=bdj[u][i];\n\t\tif (v==fa) continue;\n\t\tdp[u]=min(dp[u],max(dp[v],val[u])+s[u]-s[v]);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tc[i].first=max(0,a[i]-b[i]); \n\t\tval[i]=c[i].first;\n\t\tc[i].second=i;\n\t\tufs[i]=i;\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tsort(c+1,c+n+1,cmp1);\n\tfor (int i=1;i<=n;i++){\n\t\tint id=c[i].second;\n\t\tvis[id]=1;\n\t\tfor (int j=0;j<adj[id].size();j++){\n\t\t\tint v=adj[id][j];\n\t\t\tif (vis[v]==0) continue;\n\t\t\tv=find(v);\n\t\t\tif (v==id) continue;\n\t\t\tbdj[id].push_back(v);\n\t\t\tufs[v]=id;\n\t\t}\n\t}\n\tdfs(c[n].second,c[n].second);\n\tcout<<dp[c[n].second]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  set<tuple<ll, ll, ll>> pq;// cost, from, to\n  auto poss = [&](ll rem) {\n    DisjointSet<> dsu(n);\n    fill(ALL(vis), false);\n    VEVE(i, 0, n) {\n      if (need[i] <= rem) {\n        dsu.sum[i] = rem + recv[i];\n        vis[i] = true;\n        RARA(to, adj[i]) pq.emplace(need[to], i, to);\n      }\n    }\n    while (not pq.empty()) {\n      ll cost, fr, to;\n      tie(cost, fr, to) = *pq.begin();\n      pq.erase(pq.begin());\n      if (dsu.IsSameSet(fr, to))\n        continue;\n      if (dsu.sum[dsu.Find(fr)] >= cost) {\n        dsu.Unite(fr, to);\n        if (not vis[to]) {\n          vis[to] = true;\n          dsu.sum[dsu.Find(to)] += recv[to];\n          RARA(v, adj[to]) pq.emplace(need[v], to, v);\n        } else {\n          dsu.sum[dsu.Find(to)] -= rem;\n        }\n      }\n    }\n    VEVE(i, 0, n) if (not vis[i]) return false;\n    return true;\n  };\n  poss(0);\n  ll low = 0, hig = 1e18;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=100100;\nint n,m,a[N],b[N],tot,Next[N<<1],head[N],tree[N<<1],f[N];\nll ans[N],g[N];\nbool vis[N];\nstruct node{int x,y;}A[N];\nvoid add(int x,int y)\n{\n\ttot++;\n\tNext[tot]=head[x];\n\thead[x]=tot;\n\ttree[tot]=y;\n}\nbool cmp(node a,node b) { return a.x<b.x;}\nint get(int x)\n{\n\tif (f[x]==x) return x;else f[x]=get(f[x]);\n\treturn f[x];\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(0,a[i]-b[i]);\n\t\tA[i]=(node){a[i],i};\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tsort(A+1,A+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tf[i]=i;\n\t\tans[i]=a[i];\n\t\tg[i]=b[i];\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint u=A[i].y;\n\t\tvis[u]=1;\n\t\tfor (int j=head[u];j;j=Next[j])\n\t\t{\n\t\t\tint v=tree[j],x=get(v);\n\t\t\tif (x==u||!vis[x]) continue;\n\t\t\tf[x]=u;\n\t\t\tg[u]+=g[x];\n\t\t\tans[u]=min(ans[u],max(ans[x],a[u]-g[x]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans[A[n].y]+g[A[n].y]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nlong long Val[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n        Val[y] += Val[x];\n    }\n    else\n        TT[y] = x, Val[x] += Val[y];\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        Val[i] = B[i];\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            Val[i] = total;\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total = Val[Father(node)];\n                        if(total >= 1000000000000000)\n                            return 1;\n                        //if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Father(n) != Father(node))\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total = Val[Father(node)];\n                            if(total >= 1000000000000000)\n                            return 1;\n                            break;\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 110000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N, M;\n   cin >> N >> M;\n   vector<int> A(N), B(N);\n   vector<int> par(N);\n   vector<ll> sum(N);\n   vector<ll> ans(N);\n   for (int i = 0; i < N; ++i) {\n      cin >> A[i] >> B[i];\n      par[i] = i, sum[i] = B[i], ans[i] = max(A[i], B[i]);\n   }\n   vector<vector<int>> adj(N);\n   for (int i = 0; i < M; ++i) {\n      int x, y;\n      cin >> x >> y;\n      --x, --y;\n      adj[x].emplace_back(y);\n      adj[y].emplace_back(x);\n   }\n   vector<int> ord(N);\n   iota(ord.begin(), ord.end(), 0);\n   sort(ord.begin(), ord.end(), [&](int x, int y) {\n      return A[x] - B[x] < A[y] - B[y];\n   });\n   function<int(int)> getPar = [&](int v) {\n      if (v != par[v]) {\n         par[v] = getPar(par[v]);\n      }\n      return par[v];\n   };\n   vector<bool> visited(N);\n   for (int v : ord) {\n      vector<int> nxts;\n      for (int u : adj[v]) {\n         if (visited[u]) nxts.emplace_back(getPar(u));\n      }\n      sort(nxts.begin(), nxts.end());\n      nxts.resize(unique(nxts.begin(), nxts.end()) - nxts.begin());\n      for (int u : nxts) {\n         par[u] = v;\n         sum[v] += sum[u];\n      }\n      if (nxts.size()) {\n         ans[v] = 1e18;\n         for (int u : nxts) {\n            ans[v] = min(ans[v], max(ll(A[v] - B[v]), ans[u]) + sum[v] - sum[u]);\n         }\n      }\n      visited[v] = true;\n   }\n   cout << ans[ord.back()] << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=100010;\nbool w[N];\nlong long sz[N];\nint fa[N],a[N],b[N],Mx[N],id[N];\nvector <int> q[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline bool cmp(const int &x,const int &y) {return a[x]<a[y];}\ninline int find(int x) {return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main() {\n    int n,m;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) {\n\ta[i]=gi(),b[i]=gi(),id[i]=i,fa[i]=i;\n\tMx[i]=a[i]=max(0,a[i]-b[i]),sz[i]=b[i];\n    }\n    for(int i=1;i<=m;i++) {\n\tint x=gi(),y=gi();\n\tq[x].push_back(y),q[y].push_back(x);\n    }\n    sort(id+1,id+1+n,cmp);\n    for(int i=1;i<=n;i++) {\n\tint x=id[i];w[x]=1;\n\tfor(int j=0;j<q[x].size();j++)\n\t    if(w[q[x][j]]) {\n\t\tint y=find(q[x][j]);\n\t\tif(x!=y) {\n\t\t    sz[x]+=sz[y],fa[y]=x;\n\t\t    Mx[x]=min(1LL*Mx[x],Mx[y]+max(0LL,a[x]-sz[y]-Mx[y]));\n\t\t}\n\t    }\n\tif(i==n) cout<<Mx[x]+sz[x];\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll N = 100005, inf = 2e9;\n\nll n, m, a[N], b[N], inv[N], s;\n\nvector<ll> adj[N];\npll o[N];\n\nll p[N], v[N];\nbool c[N];\n\nll Find (ll X) {\n\tif(p[X] == X) return X;\n\treturn p[X] = Find(p[X]);\n}\n\nbool can (ll X) {\n\tfor(ll i=1;i<=n;i++) {\n\t\tp[i] = i;\n\t\tv[i] = b[i];\n\t}\n\tfor(ll i=1;i<=n;i++) {\n\t\tll I = o[i].Y;\n\t\tc[I] = (a[I]-b[I] <= X);\n\t\tfor(auto &T : adj[I]) {\n\t\t\tif(inv[T] >= i) continue;\n\t\t\tT = Find(T);\n\t\t\tif(T == I) continue;\n\t\t\tif(c[T] && a[I]-b[I] <= v[T]+X) c[I] = true;\n\t\t\tv[I] += v[T];\n\t\t\tp[T] = I;\n\t\t}\n\t}\n\treturn c[Find(1)];\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\to[i] = {a[i]-b[i], i};\n\t\ts += b[i];\n\t}\n\tsort(o+1, o+1+n);\n\tfor(ll i=1;i<=n;i++) {\n\t\tinv[o[i].Y] = i;\n\t}\n\tfor(ll i=1;i<=m;i++) {\n\t\tll A, B;\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tll S = 0, E = inf;\n\twhile(S<E) {\n\t\tll M = (S+E)/2;\n\t\tcan(M) ? E = M : S = M+1;\n\t}\n\tprintf(\"%lld\\n\",S+s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nstruct UnionFind {\n  vector<int> data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return false;\n    if (data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n\n  int find(int k) {\n    if (data[k] < 0) return k;\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return -data[find(k)];\n  }\n};\n\nvoid solve() {\n  int n, m; cin >> n >> m;\n  vl money(n), donate(n);\n  rep(i,n) {\n    cin >> money[i] >> donate[i];\n    chmax(money[i], donate[i]);\n  }\n  Graph<int> g(n);\n  rep(i,m) {\n    int u, v; cin >> u >> v; --u, --v;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n\n  vi order(n);\n  iota(ALL(order), 0);\n  sort(ALL(order), [&](int a, int b) { return money[a] - donate[a] < money[b] - donate[b]; });\n\n  UnionFind uf(n);\n  vb seen(n, false);\n\n  for (auto &v : order) {\n    seen[v] = true;\n    int x = uf.find(v);\n    vi add;\n\n    for (auto &nv : g[v]) {\n      if (seen[nv]) {\n        int y = uf.find(nv);\n        if (uf.unite(x, y)) add.emplace_back(y);\n      }\n    }\n\n    ll sum = 0;\n    for (auto &y : add) sum += donate[y];\n\n    ll cost = money[x] + sum;\n    for (auto &y : add) {\n      ll tmp = max(money[x], money[y] + donate[x]) + sum - donate[y];\n      chmin(cost, tmp);\n    }\n\n    sum += donate[x];\n\n    x = uf.find(x);\n    money[x] = cost;\n    donate[x] = sum;\n  }\n\n  cout << money[uf.find(0)] << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nll a[ten(5)], b[ten(5)];\nvector<int> e[ten(5)];\n\nclass UnionFind {\nprivate:\n\tint n;\n\tvector<int> a;\npublic:\n\tUnionFind(int n) : n(n), a(n, -1) {}\n\tint find(int x) { return a[x] < 0 ? x : (a[x] = find(a[x])); }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tbool same(Pii& p) { return same(p.first, p.second); }\n\tbool unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return false;\n\t\tif (a[x] > a[y]) swap(x, y);\n\t\ta[x] += a[y];\n\t\ta[y] = x;\n\t\tn--;\n\t\treturn true;\n\t}\n\tbool unite(Pii& p) { return unite(p.first, p.second); }\n\tint size() const { return n; }\n\tint size(int x) { return -a[find(x)]; }\n};\n\nstruct P {\n\tll val;\n\tint v;\n\tP() {}\n\tP(ll val, int v) : val(val), v(v) {}\n\n\tbool operator>(const P& r) {\n\t\treturn val > r.val;\n\t}\n};\n\nstruct Heap {\n\tHeap *l, *r;\n\tP val;\n};\n\nint __heap_pt = 0;\n\nHeap* heapAlloc(P val) {\n\tstatic Heap buf[ten(6) * 3];\n\n\tauto& ret = buf[__heap_pt++];\n\tret.l = ret.r = nullptr;\n\tret.val = val;\n\treturn &ret;\n}\n\nvoid clearHeap() {\n\t__heap_pt = 0;\n}\n\nHeap *meld(Heap *a, Heap *b) {\n\tif (!a) return (b);\n\tif (!b) return (a);\n\n\tif (a->val > b->val) swap(a, b);\n\ta->r = meld(a->r, b);\n\tswap(a->l, a->r);\n\n\treturn (a);\n}\n\nvoid pop(Heap*& root) {\n\troot = meld(root->r, root->l);\n}\n\nHeap* nodes[ten(5)];\nll curB[ten(5)];\n\nbool solve(ll sval, int n) {\n\tclearHeap();\n\tmemset(curB, 0, sizeof(curB));\n\tFOR(i, n) {\n\t\tnodes[i] = nullptr;\n\t\tfor (auto to : e[i]) {\n\t\t\tnodes[i] = meld(nodes[i], heapAlloc(P(a[to], to)));\n\t\t}\n\t\tcurB[i] = b[i];\n\t}\n\n\tbool used = false;\n\tUnionFind uf(n);\n\tFOR(i, n) {\n\t\tif (uf.size(i) != 1) continue;\n\t\tif (a[i] - sval > 0) continue;\n\t\tused = true;\n\n\t\twhile (true) {\n\t\t\tauto& curHeap = nodes[uf.find(i)];\n\t\t\tif (!curHeap) break;\n\n\t\t\tauto& bval = curB[uf.find(i)];\n\n\t\t\tP val = curHeap->val;\n\t\t\tif (uf.same(i, val.v)) {\n\t\t\t\tpop(curHeap);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (val.val - sval > bval) break;\n\t\t\tpop(curHeap);\n\t\t\t\n\t\t\tint vpar = uf.find(val.v);\n\t\t\tcurHeap = meld(curHeap, nodes[vpar]);\n\t\t\tbval += curB[vpar];\n\n\t\t\tuf.unite(i, val.v);\n\t\t\tint nid = uf.find(i);\n\t\t\tnodes[nid] = curHeap;\n\t\t\tcurB[nid] = bval;\n\t\t}\n\t}\n\n\tbool ok = used && (uf.size() == 1);\n\treturn ok;\n}\n\nint main() {\n\tint n, m; reader(n, m);\n\tFOR(i, n) {\n\t\treader(a[i], b[i]);\n\t\ta[i] -= b[i];\n\t}\n\tFOR(i, m) {\n\t\tint x, y; reader(x, y);\n\t\tx--; y--;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\n\tbool cur = solve(0, n);\n\n\tll l = -1, r = ten(9) + 1;\n\twhile (r - l != 1) {\n\t\tll md = (l + r) / 2;\n\t\tbool ok = solve(md, n);\n\t\tif (ok) r = md;\n\t\telse l = md;\n\t}\n\tll ans = r;\n\tFOR(i, n) ans += b[i];\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto x : v) cerr << x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int i = 0; i < (n); ++i) cerr << a[i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 100005;\nint A[MAXN], B[MAXN], C[MAXN];\nvector<int> E[MAXN];\nbool used[MAXN];\nint par[MAXN];\nll sumb[MAXN], dp[MAXN];\nint root(int a) {\n\tif (par[a] == a) return a;\n\treturn par[a] = root(par[a]);\n}\nint main() {\n\tint N, M;\n\tscanf(\"%d%d\", &N, &M);\n\tvector<pair<int, int>> order;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tC[i] = max(0, A[i] - B[i]);\n\t\torder.push_back({C[i], i});\n\t\tpar[i] = i;\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tsort(order.begin(), order.end());\n\tfor (auto ord : order) {\n\t\tint v = ord.second;\n\t\tset<int> trees;\n\t\tsumb[v] = B[v];\n\t\tfor (int w : E[v]) {\n\t\t\tif (!used[w]) continue;\n\t\t\tint pw = root(w);\n\t\t\tif (trees.count(pw)) continue;\n\t\t\tsumb[v] += sumb[pw];\n\t\t\ttrees.insert(pw);\n\t\t}\n\t\tused[v] = true;\n\t\tdp[v] = C[v] + sumb[v];\n\t\tfor (int w : trees) {\n\t\t\tll amt = sumb[v] - sumb[w] + max(dp[w], (ll)C[v]);\n\t\t\tdp[v] = min(dp[v], amt);\n\t\t\tpar[w] = v;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[root(1)]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i];\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n\t\tif(sz < 30) {\n\t\t\tvector<int> P(sz);\n\t\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\t\tbool is_ok = false;\n\t\t\twhile(true) {\n\t\t\t\tcat w = W[c];\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tw -= B[c];\n\t\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tw = W[c];\n\t\t\t\tok = true;\n\t\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t\t}\n\t\t\tassert(is_ok);\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tdfs(root,0);\n\tprintf(\"%lld\",need[root]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nint n, m, id[101000]; ll a[101000], b[101000], f[101000], sb[101000];\nvector<int>G[101000];\nint fa[101000], fl[101000];\nint GF(int x){\n    return fa[x]==x? x: fa[x]=GF(fa[x]);\n}\nint main(){\n    cin>>n>>m;\n    for (int i=1;i<=n;++i){\n        scanf(\"%lld%lld\",&a[i],&b[i]);\n        a[i]=max(a[i],b[i])-b[i];\n    }\n    for (int x,y;m--;){\n        scanf(\"%d%d\",&x,&y);\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    for (int i=1;i<=n;++i){\n        fa[i]=i; id[i]=i;\n    }\n    sort(id+1,id+n+1,[](int i,int j){return a[i]<a[j];});\n    for (int i=1;i<=n;++i){\n        int x=id[i]; fl[x]=1; sb[x]=b[x];\n        vector<int>ch;\n        for (auto y:G[x]){\n            if (!fl[y=GF(y)]) continue;\n            if (y==x) continue;\n            ch.push_back(y); fa[y]=x;\n        }\n        for (auto y:ch) sb[x]+=sb[y];\n        f[x]=sb[x]+a[x];\n        for (auto y:ch) f[x]=min(f[x],sb[x]-sb[y]+max(a[x],f[y]));\n        //printf(\" %d %lld %lld\\n\",x,sb[x],f[x]);\n    }\n    cout<<*max_element(f+1,f+n+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=100005;\nint n,m,fa[N],A[N],B[N],C[N],id[N];bool pd[N];LL sum[N],f[N];\nint pp,lnk[N],nxt[N*2],to[N*2];\nvoid ae(int k1,int k2){to[++pp]=k2,nxt[pp]=lnk[k1],lnk[k1]=pp;}\nint fd(int k1){return fa[k1]==k1?k1:fa[k1]=fd(fa[k1]);}\nbool cmp(int k1,int k2){return C[k1]<C[k2];}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n)scanf(\"%d%d\",&A[i],&B[i]),C[i]=max(A[i]-B[i],0),sum[i]=B[i];\n\trep(i,1,m){\n\t\tint k1,k2;scanf(\"%d%d\",&k1,&k2);\n\t\tae(k1,k2),ae(k2,k1);\n\t}\n\trep(i,1,n)fa[i]=i,id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\trep(_,1,n){\n\t\tint k1=id[_];\n\t\tpd[k1]=1;LL c=C[k1];\n\t\tfor(int i=lnk[k1];i;i=nxt[i])if(pd[to[i]]){\n\t\t\tint k2=fd(to[i]);if(k2==k1)continue;\n\t\t\tfa[k2]=k1,sum[k1]+=sum[k2],c=min(c,max((LL)C[k1],f[k2])-sum[k2]);\n\t\t}\n\t\tf[k1]=sum[k1]+c;\n//\t\tfprintf(stderr,\"f[%d]=%lld\\n\",k1,f[k1]);\n\t}\n\tprintf(\"%lld\\n\",f[fd(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            if (S[to] <= S[i] and not uf.same(to, i)) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    assert(uf.getSize(0) == N);\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        for (const int to : T[v]) {\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    int r = -1;\n    for (int i = 0; i < N; i++) {\n        if (T.rev_edge[i].empty()) { r = i; }\n    }\n    assert(r >= 0);\n    dfs(dfs, r);\n    std::cout << f[r] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint a[N], b[N], fa[N], p[N];\nLL f[N], siz[N];\nvector<int> e[N];\nbool vis[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nbool cmp(int x, int y) { return a[x] > a[y]; }\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>(), m = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>(), siz[i] = b[i] = gi<int>();\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x = gi<int>(), y = gi<int>();\n\t\te[x].push_back(y), e[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; i++) fa[i] = p[i] = i, a[i] = max(0, a[i] - b[i]);\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u = p[i]; vector<int> son; vis[u] = 1;\t\t\n\t\tfor (int v : e[u]) {\n\t\t\tif (!vis[v] || find(u) == find(v)) continue;\n\t\t\tson.push_back(find(v));\n\t\t\tsiz[u] += siz[find(v)]; fa[find(v)] = u;\n\t\t}\n\t\tf[u] = siz[u] + a[u];\n\t\tfor (int v : son) f[u] = min(f[u], siz[u] - siz[v] + max(1ll * a[u], f[v]));\n\t}\n\tprintf(\"%lld\\n\", f[p[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tll bsum = 0;\n\tREP(i, n) bsum += b[i];\n\n\tauto check = [&](ll w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<ll> sum(n);\n\t\tREP(i, n) sum[i] = b[i];\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tll nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tif (nowsum < nowP.first) break;\n\t\t\t\tint now = nowP.second;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (!uf.same(start, now)) {\n\t\t\t\t\tll t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tif (uf.size(start) == n) return true;\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + sum[uf.find(start)];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if (!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uf.size(0) == n;\n\t};\n\n\tll l = -1, r = INFLL;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\tOUT(r + bsum)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m;\nint a[maxn],b[maxn],ord[maxn];\nbool ok[maxn],occ[maxn];\nvector<int>edge[maxn],vec[maxn];\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nnamespace Dsu{\n\tint f[maxn],rk[maxn];\n\tll v[maxn]; \n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\trk[i]=1;\n\t\t\tv[i]=b[i];\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(rk[x]>rk[y])swap(x,y);\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t\tif(rk[x]==rk[y])rk[y]++;\n\t}\n}\n\nvoid fix(int x,int y){\n\twhile(!vec[x].empty()){\n\t\tint z=vec[x].back();\n\t\tvec[x].pop_back();\n\t\tok[z]=true;\n\t\tint ori=Dsu::find(z);\n\t\tDsu::merge(ori,y);\n\t\tfix(ori,y);\n\t}\n}\n\nbool check(ll val){\n\tREP(i,n)vec[i].clear(),ok[i]=occ[i]=false;\n\tDsu::init();\n\tREP(i,n){\n\t\tint x=ord[i];\n\t\tocc[x]=true;\n\t\tif(val+b[x]>=a[x])ok[x]=true;\n\t\trep(j,int(edge[x].size())){\n\t\t\tint y=edge[x][j];\n\t\t\tif(!occ[y])continue;\n\t\t\tll nowx=Dsu::v[Dsu::find(x)]+val;\n\t\t\tll nowy=Dsu::v[Dsu::find(y)]+val;\n\t\t\tif((ok[y]&&nowy+b[x]>=a[x])||(ok[x]&&nowx+b[y]>=a[y])){\n\t\t\t\tok[x]=ok[y]=true;\n\t\t\t\tint orix=Dsu::find(x),oriy=Dsu::find(y);\n\t\t\t\tDsu::merge(x,y);\n\t\t\t\tfix(orix,x);\n\t\t\t\tfix(oriy,y);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvec[Dsu::find(y)].pb(x);\n\t\t\t\tvec[Dsu::find(x)].pb(y);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e9);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjoint set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nlong long t1,t2;\n\nlong long n,m;\n\nstd::vector<long long> g[100005];\n\nlong long a[100005];\nlong long b[100005];\n\n// disjoint set stuff\nstd::vector<long long> todo;\nbool todo2[100005];     // determine if a vertex is in todo\n\nstd::priority_queue<std::pair<long long,long long> > pq[100005];\nlong long endval;\nlong long up[100005];\nlong long sz[100005];\nlong long money[100005];\nbool active[100005];\n\nlong long getroot(long long u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(long long u,long long v)\n{\n    up[v]=u;\n    sz[u]+=sz[v];\n    money[u]+=money[v]-endval;\n    active[u]=1;\n    while (!pq[v].empty()) {\n        pq[u].push(pq[v].top());\n        pq[v].pop();\n    }\n}\n\nlong long join(long long u,long long v)\n{\n    // return the root of their union\n    u=getroot(u);\n    v=getroot(v);\n    if (u==v) return u;\n    if (sz[u]>=sz[v]) {\n        join2(u,v);\n        return u;\n    }\n    else {\n        join2(v,u);\n        return v;\n    }\n}\n\nbool good(long long x)\n{\n    endval=x;\n    memset(active,0,sizeof active);\n    // make the pq\n    for (long long i=1; i<=n; i++) {\n        up[i]=i;\n        sz[i]=1;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n        while (!pq[i].empty()) pq[i].pop();\n        for (long long j:g[i]) pq[i].push({b[j]-a[j],j});\n    }\n    // do vertices\n    bool change=1;\n    while (change) {\n        change=0;\n        for (long long i=1; i<=n; i++) {\n            long long u=getroot(i);\n            if (!active[u]) continue;\n            //printf(\"start at %lld\\n\",i);\n            // do this vertex\n            while (!pq[u].empty() && -pq[u].top().first<=money[u]) {\n                long long v=pq[u].top().second;\n                pq[u].pop();\n                //printf(\"do %lld -> %lld\\n\",u,v);\n                u=join(u,v);\n                change=1;\n            }\n        }\n    }\n    // check\n    for (long long i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nlong long lo=0;\nlong long hi=0x3f3f3f3f;\nlong long mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (long long i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (long long i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    //good(105); return 0;\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%lld %lld\\n\",lo,hi);\n    }\n    ans=lo;\n    for (long long i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[100010], t[100010];\nint a[100010], b[100010];\nint par[100010];\nlong long cost[100010];\nlong long sub[100010];\n\nint main(int argc, char const *argv[])\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector <int> ord;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\tpar[i] = i;\n\t\tord.push_back(i);\n\t}\n\tfor(int i = 1; i <= m; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tsort(ord.begin(), ord.end(), [&] (int i, int j) { return a[i] - b[i] < a[j] - b[j]; });\n\t\n\tvector <int> done (n + 1, false);\n\tfunction <int(int)>  root = [&] (int x) {\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = root(par[x]);\n\t};\n\tfor(int i : ord) {\n\t\tfor(auto j : g[i]) {\n\t\t\tif(done[j] && root(j) != i) {\n\t\t\t\tt[i].push_back(root(j));\n\t\t\t\tpar[root(j)] = i;\n\t\t\t}\n\t\t}\n\t\tdone[i] = true;\n\t}\n\tfunction <void(int)> dfs = [&] (int x) {\n\t\tsub[x] = b[x];\n\t\tfor(auto i : t[x]) {\n\t\t\tdfs(i);\n\t\t\tsub[x] += sub[i];\n\t\t}\n\t\tlong long var = max(0, a[x] - b[x]);\n\t\tcost[x] = sub[x] + var;\n\t\tfor(auto i : t[x]) {\t\t\t\n\t\t\tcost[x] = min(cost[x], sub[x] - sub[i] + max(var, cost[i]));\n\t\t}\n\t};\n\tdfs(root(1));\n\tcout << cost[root(1)] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for(int i=(a);i<=(b);++i)\n#define F_(i,a,b) for(int i=(a);i>=(b);--i)\n#define G(i,u) for(int i=head[u];i;i=nxt[i])\n\ntypedef long long ll;\n\nconst int N = 100005;\n\ntemplate<typename T> inline T min(T& a, T b) {return a<b?a:a=b;}\n\nint head[N], to[N<<1], nxt[N<<1], a[N], b[N], r[N], g[N], son[N], ecnt;\nvoid add(int u, int v) { to[++ecnt] = v; nxt[ecnt] = head[u]; head[u] = ecnt; }\nbool cmp(const int& x, const int& y) { return a[x] < a[y]; }\nint find(int x) { return g[x] == x? x: g[x] = find(g[x]); }\nll f[N], sum[N];\nint main() {\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n\t#endif\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tF(i,1,n) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i] = std::max(a[i]-b[i],0); \n\t\tr[i] = i;\n\t}\n\tF(i,1,m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u,v); add(v,u);\n\t}\n\tstd::sort(r+1,r+n+1,cmp);\n\tF(i,1,n) {\n\t\tint x = r[i], tot = 0; g[x] = x; sum[x] = b[x];\n\t\tG(j,x) {\n\t\t\tint v = to[j], p = find(v);\n\t\t\tif(!p || p == x) continue;\n\t\t\tson[++tot] = p;\n\t\t\tsum[x] += sum[p];\n\t\t\tg[p] = x;\n\t\t}\n\t\tf[x] = a[x] + sum[x];\n\t\tF(j,1,tot) min(f[x],sum[x]-sum[son[j]]+std::max(f[son[j]],1ll*a[x]));\n\t}\n\tprintf(\"%lld\\n\", f[r[n]]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nint i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nint tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tint x,y;\n}a[N];\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(int x,int y) {\n\treturn a[x].x<a[y].x;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tint r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=max(a[id[i]].x,a[id[i]].y);\n\t\t\ts[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tif (r==1) {\n\t\t\ts[id[i]]=S+a[id[i]].y;\n\t\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\t\tint p=max(a[id[i]].x,a[id[i]].y);\n\t\t\tA[id[i]]=min(max(1ll*a[id[i]].x,1ll*a[id[i]].y+A[q[1]]),S+p);\n\t\t\tcontinue;\n\t\t}\n\t\tint p=max(a[id[i]].x,a[id[i]].y);\n\t\tfor (j=1;j<=r;j++) M=min(M,S-s[q[j]]+max(1ll*a[id[i]].x,1ll*a[id[i]].y+A[q[j]]));\n\t\tM=min(M,S+p);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%lld\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i]*1LL*OVER9000 - B[i];\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne?\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nlong long i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nlong long tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tlong long x,y;\n}a[N];\ninline void add(long long x,long long y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(long long x,long long y) {\n\treturn a[x].x<a[y].x;\n}\ninline long long get(long long x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%lld%lld\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tlong long r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=max(a[id[i]].x,a[id[i]].y);\n\t\t\ts[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tif (r==1) {\n\t\t\ts[id[i]]=S+a[id[i]].y;\n\t\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\t\tlong long p=max(a[id[i]].x,a[id[i]].y);\n\t\t\tA[id[i]]=min(max(1ll*a[id[i]].x,1ll*a[id[i]].y+A[q[1]]),S+p);\n\t\t\tcontinue;\n\t\t}\n\t\tlong long p=max(a[id[i]].x,a[id[i]].y);\n\t\tfor (j=1;j<=r;j++) M=min(M,S-s[q[j]]+max(1ll*a[id[i]].x,1ll*a[id[i]].y+A[q[j]]));\n\t\tM=min(M,S+p);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%lld\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "\t\t\t\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n\ntypedef long long LL;\nconst LL INF=1e18;\nconst int N=200005;\n\nstd:: vector <int> E[N],G[N];\n\nLL a[N],b[N],f[N],g[N];\nint fa[N],rk[N];\n\nbool vis[N];\n\nint read() {\n\tint x=0,v=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';v=(ch=='-')?(-1):v,ch=getchar());\n\tfor (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n\treturn x*v;\n}\n\nvoid dfs(int x) {\n\tif (G[x].empty()) {\n\t\tf[x]=a[x]+b[x],g[x]=b[x];\n\t\treturn ;\n\t}\n\tg[x]=b[x],f[x]=INF;\n\tfor (int y:G[x]) dfs(y),g[x]+=g[y];\n\tfor (int y:G[x]) {\n\t\tf[x]=std:: min(f[x],std:: max(f[y],a[x])+g[x]-g[y]);\n\t}\n}\n\nint find(int x) {\n\treturn !fa[x]?x:(fa[x]=find(fa[x]));\n}\n\nbool cmp(int x,int y) {\n\treturn a[x]<a[y];\n}\n\nint main(void) {\n\tint n=read(),m=read();\n\trep(i,1,n) {\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=std:: max(a[i]-b[i],0LL);\n\t\trk[i]=i;\n\t}\n\trep(i,1,m) {\n\t\tint x=read(),y=read();\n\t\tE[x].push_back(y);\n\t\tE[y].push_back(x);\n\t}\n\tstd:: sort(rk+1,rk+n+1,cmp);\n\trep(ti,1,n) {\n\t\tint x=rk[ti]; vis[x]=1;\n\t\tfor (int y:E[x]) {\n\t\t\tif (!vis[y]) continue;\n\t\t\tif (find(y)==find(x)) continue;\n\t\t\tG[x].push_back(find(y));\n\t\t\tfa[find(y)]=find(x);\n\t\t}\n\t}\n\trep(i,1,n) if (find(i)==i) {\n\t\tdfs(i),printf(\"%lld\\n\", f[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <ctime>\n#include <climits>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <set>\nusing namespace std;\nstruct UnionFind {\n    vector<int> par, sz;\n    int n_tree;\n\n    explicit UnionFind(int n) : par(n), sz(n, 1), n_tree(n) { //0-indexed\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int n_cluster() const {\n        return n_tree;\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if (rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool is_root(int x) const {\n        return par[x] == x;\n    }\n};\nint main() {\n#ifdef LOCAL\n    ifstream in(\"in.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n    //仿tourist的做法\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n    }\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> c(n);\n    iota(c.begin(), c.end(), 0);\n    sort(c.begin(), c.end(), [&](int x, int y) {return a[x] - b[x] < a[y] - b[y]; });\n    vector<long long> sum_b(n);\n    // ans[i]：子树i的最优解\n    vector<bool> done(n, false);\n    vector<long long> ans(n);\n    for (int i = 0; i < n; ++i) {\n        ans[i] = max(a[i], b[i]);\n        sum_b[i] = b[i];\n    }\n    //vector<bool> added(n, false);\n    UnionFind uf(n);\n    for (auto v : c) {\n        set<int> s;\n        for (auto u : g[v]) {\n            if (done[u]) {\n                //并查集用来查找子树的根\n                s.insert(uf.root(u));\n            }\n        }\n        for (auto u : s) {\n            sum_b[v] += sum_b[u];\n            uf.unite(u, v);\n        }\n        //cout << v << ' ' << sum_b[v] << endl;\n        if (!s.empty()) {\n            long long best = LLONG_MAX;\n            for (auto u : s) {\n                long long sum_b_without = sum_b[v] - sum_b[u];\n                long long cur = max(sum_b_without + ans[u], sum_b_without + a[v] - b[v]);\n                best = min(best, cur);\n                uf.unite(u, v);\n            }\n            ans[v] = best;\n        }\n        done[v] = true;\n        //assert(uf.root(v) == v);\n    }\n    //for (int i = 0; i < n; ++i) {\n    //    cout << c[i] << ' ' << sum_b[c[i]] << ' ' << ans[c[i]] << endl;\n    //}\n    cout << ans[c[n - 1]] << '\\n';\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200005;\nint flag[N],f[N],c[N],dp[N],x,y,n,m,id[N],rk[N],ne[N],fi[N],zz[N],tot,size[N],a[N],b[N];\nvector<int> G[N];\nint find(int x){\n\tif (x==f[x])return x;\n\treturn f[x]=find(f[x]);\n}\nint cmp(int x,int y){\n\treturn c[x]<c[y];\n}\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nvoid dfs1(int x){\n\tsize[x]=b[x];\n\tfor (int i=0;i<G[x].size();i++)dfs1(G[x][i]),size[x]+=size[G[x][i]];\n}\nvoid dfs2(int x){\n\tif (!G[x].size()){\n\t\tdp[x]=b[x]+c[x];\n\t\treturn;\n\t}\n\tdp[x]=1e18;\n\tfor (int i=0;i<G[x].size();i++)dfs2(G[x][i]),dp[x]=min(dp[x],max(c[x],dp[G[x][i]])+size[x]-size[G[x][i]]);\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld%lld\",&a[i],&b[i]),c[i]=max(a[i]-b[i],0ll);\n\tfor (int i=1;i<=n;i++)f[i]=i,id[i]=i;\n\twhile (m--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tjb(x,y);jb(y,x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++)rk[id[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=fi[id[i]];j;j=ne[j]){\n\t\t\tx=find(id[i]),y=find(zz[j]);\n\t\t\tif (id[i]!=y&&rk[x]>rk[y])G[id[i]].push_back(y),f[y]=id[i],flag[y]=1;\n\t\t}\n\tint root=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])root=i;\n\tdfs1(root);\n\tdfs2(root);\n\tprintf(\"%lld\\n\",dp[root]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long u,v,data;\n\tbool operator < (const node &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nnode edge[200001];\nlong long n,m,a[100001],b[100001],head[100001],rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>edge[i].u>>edge[i].v;\n\t\tif (a[edge[i].u]>a[edge[i].v])\n\t\t\tswap(edge[i].u,edge[i].v);\n\t\tedge[i].data=a[edge[i].v];\n\t}\n\tsort(edge+1,edge+m+1);\n\tfor (int i=1;i<=m;++i)\n\t\tif (find(edge[i].u)!=find(edge[i].v))\n\t\t\tunionn(edge[i].u,edge[i].v);\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define MN 101000\n\ntypedef long long ll;\n\nint h[MN], nxt[2 * MN], to[2 * MN], K = 0;\nint n, m, fa[MN]; \nint a[MN], c[MN], p[MN];\nstd::vector<int> e[MN];\nll sum[MN];\nbool vis[MN];\nll Ans = 1e18;\n\nvoid ins(int u, int v) {nxt[++K] = h[u]; h[u] = K; to[K] = v;} \n\nint Find(int x) {return fa[x] == x ? x : fa[x] = Find(fa[x]);}\n\nbool cmp(int a, int b) {return c[a] < c[b];}\n\nvoid dfs(int x)\n{\n\tsum[x] = a[x] - c[x];\n\tfor(int i = h[x]; i; i = nxt[i])\n\t\tdfs(to[i]), sum[x] += sum[to[i]];\n}\n\nvoid solve(int x, ll w)\n{\n\tAns = std::min(Ans, std::max((ll)c[x], w - sum[x]));\n\tfor(int i = h[x]; i; i = nxt[i])\n\t{\n\t\tll d = std::max(w - (sum[x] - sum[to[i]]), (ll)c[x]);\n\t\tsolve(to[i], d);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\ta = std::max(a, b);\n\t\t::a[i] = a; c[i] = a - b;\n\t\tfa[i] = i; p[i] = i;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\n\tstd::sort(p + 1, p + n + 1, cmp);\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x = p[i]; vis[x] = 1;\n\t\tfor(int j = 0; j < e[x].size(); j++)\n\t\t{\n\t\t\tif(vis[e[x][j]])\n\t\t\t{\n\t\t\t\tint y = Find(e[x][j]);\n\t\t\t\tif(x != y)\n\t\t\t\t{\n\t\t\t\t\tins(x, y);\n\t\t\t\t\tfa[y] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(p[n]);\n\tsolve(p[n], 0);\n\t\n\tprintf(\"%lld\\n\", Ans + sum[p[n]]); \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM= +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nint a[NN]={};\nint b[NN]={};\nvector<int> p[NN];\nbool has[NN]={};\nint fa[NN]={};\nint ord[NN]={};\nLL dp[NN]={};\nLL sumb[NN]={};\nint getfa(int x){\n\treturn x==fa[x]?x:fa[x]=getfa(fa[x]);\n}\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nint main(){\n\t//open();\n\tn=read();\n\tm=read();\n\tfor(int i=1;i<=n;++i){\n\t\ta[i]=read();\n\t\tb[i]=read();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tfa[i]=i;\n\t\tord[i]=i;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint x=read(),y=read();\n\t\tp[x].push_back(y);\n\t\tp[y].push_back(x);\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tfor(int i=1;i<=n;++i){\n\t\tint x=ord[i];\n\t\thas[x]=1;\n\t\tdp[x]=a[x];\n\t\tsumb[x]=b[x];\n\t\tfor(int j=0;j<p[x].size();++j){\n\t\t\tint cur=p[x][j];\n\t\t\tif(has[cur]){\n\t\t\t\tint rt=getfa(cur);\n\t\t\t\tif(rt==x)continue;\n\t\t\t\tsumb[x]+=sumb[rt];\n\t\t\t\tdp[x]=min(dp[x],max(dp[rt],a[x]-sumb[rt]));\n\t\t\t\tfa[rt]=x;\n\t\t\t}\n\t\t}\n\n\t}\n\tprintf(\"%lld\\n\",dp[getfa(1)]+sumb[getfa(1)]);\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y,w;\n}e[N<<1];\nstruct P{\n\tint a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].a,&a[i].b);\n\tif(n==1) return printf(\"%d\",max(a[1].a,a[1].b)),0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e15,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e15;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mid+siz[find(1)],r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 100005\nusing namespace std;\nint a[N],b[N],c[N],d[N],e[N],g[N],f[N],m,n;long long h[N],x;\ninline bool cmp(int u,int v){return g[a[u]]==g[a[v]]?a[u]<a[v]:g[a[u]]<g[a[v]];}\nint find(int u)\n{\n\tif(!f[u])return u;\n\tint v=find(f[u]);\n\treturn e[u]=max(e[u],e[f[u]]),f[u]=v;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),x=0x7fffffffffffffffll;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%lld\",g+i,h+i),g[i]=g[i]<h[i]?0:g[i]-h[i];\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",a+i,b+i),c[i]=i,g[a[i]]<g[b[i]]||g[a[i]]==g[b[i]]&&a[i]<b[i]?a[i]^=b[i]^=a[i]^=b[i]:0;\n\tsort(c+1,c+m+1,cmp);\n\tfor(int i=1,u;i<=m;i++)if(a[c[i]]!=(u=find(b[c[i]])))e[u]=max((long long)e[u],g[a[c[i]]]-h[u]),f[u]=a[c[i]],h[a[c[i]]]+=h[u];\n\tfor(int i=1,u;i<=n;i++)u=find(i),x=min(x,max(g[i],e[i])+h[u]);\n\treturn 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親のインデックスを記憶する配列\n\tvector<int> sz; // サイズを記憶する。\n\tvector<int> rank;\n\t// 初期化\n\tUF(int n):par(n),sz(n),rank(n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;rank[i] = 0;\n\t\t}\n\t}\n\t// 親を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsz[y] += sz[x];\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tsz[x] += sz[y];\n\t\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\t// 素の集合のサイズを求める\n\tint size(int n){return sz[find(n)];}\n};\n\nll n,m;\nll a[111111];\nll b[111111];\nll c[111111];\nvector<pair<ll,pair<ll,ll>>> edge;\nvector<vector<int>> v(111111);\n\nll dfs(ll node){\n\tll ret = LLINF;\n\tll tmp_sum = b[node];\n\tvector<ll> seica(v[node].size());\n\tREP(i,v[node].size()){\n\t\tseica[i] = max(dfs(v[node][i]),c[node]);\n\t\ttmp_sum += b[v[node][i]];\n\t}\n\tREP(i,v[node].size()){\n\t\tret = min(ret,seica[i]+tmp_sum-b[v[node][i]]);\n\t}\n\t\n\tret = min(ret,c[node]+tmp_sum);\n\t\n\tb[node] = tmp_sum;\n\treturn ret;\n}\n\nint main(){\n\t\n\tREP(i,111111)dp[i] = -1;\n\t\n\tcin >> n >> m;\n\tll ma = -1;\n\tll node;\n\tREP(i,n){\n\t\tcin >> a[i] >> b[i];\n\t\tc[i] = max(0LL,a[i] - b[i]);\n\t\tif(ma < c[i]){ma = c[i],node = i;}\n\t}\n\tREP(i,m){\n\t\tint x,y;cin >> x >> y;\n\t\tx--;y--;\n\t\tedge.PB(MP(max(c[x],c[y]),MP(x,y)));\n\t}\n\t\n\tsort(ALL(edge));\n\t\n\tUF uf(n);\n\t\n\tREP(i,m){\n\t\tll A = edge[i].SE.FI;\n\t\tll B = edge[i].SE.SE;\n\t\tif(uf.same(A,B))continue;\n\t\tif(c[A] < c[B]){\n\t\t\tv[B].PB(uf.find(A));\n\t\t\tuf.par[uf.find(A)] = B;\n\t\t}\n\t\telse{\n\t\t\tv[A].PB(uf.find(B));\n\t\t\tuf.par[uf.find(B)] = A;\n\t\t}\n\t\tuf.unite(A,B);\n\t}\n\t\n\tcout << dfs(node) << endl;\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define For(i, j, k) for (int i = j; i <= k; i++)\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\ntypedef long long LL;\n\nvector<int> G[N];\nint fa[N], rk[N], n, m;\nint A[N], B[N];\nLL dp[N], sum[N];\n\nint find(int x) {\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nbool cmp(int x, int y) {\n\treturn A[x] - B[x] < A[y] - B[y]; \n}\n\nint main() {\n\n\tscanf(\"%d%d\", &n, &m);\n\tFor(i, 1, n) rk[i] = i, scanf(\"%d%d\", &A[i], &B[i]);\n\tFor(i, 1, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v), G[v].pb(u);\n\t}\n\t\n\tsort(rk + 1, rk + n + 1, cmp);\n\tFor(i, 1, n) {\n\t\tint o = rk[i];\n\t\tfa[o] = o;\n\t\tdp[o] = max(0, A[o] - B[o]), sum[o] = B[o];\n\t\tfor (int v : G[o]) {\n\t\t\tif (!fa[v] || find(v) == o) continue;\n\t\t\tint x = find(v);\n\t\t\tfa[x] = o;\n\t\t\tdp[o] = min(dp[o], max(dp[x], A[o] - B[o] - sum[x]));\n\t\t\tsum[o] += sum[x];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[find(1)] + sum[find(1)]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nint rt[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nstruct pt{int a,id;}w[MAXN];\nint n,m,A[MAXN],B[MAXN];\nbool cmp(pt n1,pt n2){return n1.a<n2.a;}\nvector<int> vec[MAXN];\nLL sum[MAXN];\nvoid init(int x)\n{\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)init(a[k].y),sum[x]+=sum[a[k].y];\n}\nLL ans;\nvoid cal(int x,LL ls1,LL ls2)//留下来的速度  上面会用掉的速度 \n{\n\tif(x==10)\n\t{\n\t\tint gg;\n\t\tgg++;\n\t}\n\tLL down=sum[x]-B[x];//不考虑我走完要多少速度 \n\tLL nx=max(ls1,(LL)max(A[x],B[x]));\n\tLL canuse=min(down,nx-max(A[x],B[x]));//可以提供给子树的 \n\tans=min(ans,nx-ls1+down-canuse+ls2);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tcal(y,nx-B[x]-min(canuse,down-sum[y]),down-sum[y]+ls2+nx-ls1-min(canuse,down-sum[y]));\n\t}\n}\nint ri[MAXN];\nbool is[MAXN];\nint main()\n{\n//\tfreopen(\"subtask_1_09.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)w[i].a=A[i]=read(),B[i]=read(),w[i].id=i;\n\tsort(w+1,w+1+n,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(y);vec[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tis[w[i].id]=true; \n\t\tfor(int j=0;j<vec[w[i].id].size();j++)\n\t\t{\n\t\t\tint x=vec[w[i].id][j];\n\t\t\tint p=findrt(w[i].id),q=findrt(x);\n\t\t\tif(p!=q&&is[q])ins(w[i].id,q),ri[q]++,rt[q]=p;\n\t\t}\n\t}\n\tfor(int i=1;i<=len;i++)printf(\"YES %d %d\\n\",a[i].x,a[i].y);\n\tfor(int i=1;i<=n;i++)pr1(A[i]),pr2(B[i]);\n\tint root;\n\tfor(int i=1;i<=n;i++)if(!ri[i])root=i;\n\tinit(root);\n\tans=(1LL<<63-1);\n\tcal(root,0,0);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 1e5 + 3;\n\nclass UF{\n\tint x[UF_MAX];\n\tLL p[UF_MAX];\n\tpriority_queue<pair<LL,int>,vector<pair<LL,int>>,greater<pair<LL,int>>> Q[UF_MAX];\n\t\npublic:\n\n\tvoid clear(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tfill(p,p+UF_MAX,0);\n\t\trepp(i,0,UF_MAX) while(!Q[i].empty()) Q[i].pop();\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\tif(Q[s].size() < Q[t].size()) swap(s,t);\n\t\t\twhile(!Q[t].empty()){\n\t\t\t\tQ[s].push(Q[t].top());\n\t\t\t\tQ[t].pop();\n\t\t\t}\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t\tp[s] += p[t];\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t\tp[t] += p[s];\n\t\t\t\tswap(Q[s],Q[t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tLL get_p(int a){\n\t\treturn p[boss(a)];\n\t}\n\n\tint get_q(int a){\n\t\ta = boss(a);\n\t\treturn Q[a].empty()?-1:Q[a].top().second;\n\t}\n\n\tvoid set(int a , LL b){\n\t\tp[a] = b;\n\t}\n\n\tvoid push(int a , int b , LL c){\n\t\tQ[a].push({c,b});\n\t}\n\n\tvoid pop(int a){\n\t\tQ[boss(a)].pop();\n\t}\n};\n\nconst int MC = 1e5 + 3;\nint N,M;\nLL A[MC],B[MC],S;\nvector<int> V[MC];\nUF uf;\n\nbool eval(LL z){\n\tvector<int> used(N,0);\n\tqueue<int> Q;\n\tuf.clear();\n\trepp(i,0,N){\n\t\tfor(auto u : V[i]) uf.push(i,u,A[u]);\n\t\tif(z >= A[i]){\n\t\t\tQ.push(i);\n\t\t\tuf.set(i,B[i]);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint k = Q.front(); Q.pop();\n\t\tfor(int u = uf.get_q(k) ; u >= 0 && (z + uf.get_p(k) >= A[u] || (used[u] && z + uf.get_p(u) >= A[k])) ; u = uf.get_q(k)){\n\t\t\tif(!used[u]){\n\t\t\t\tQ.push(u);\n\t\t\t\tuf.set(u,B[u]);\n\t\t\t\tused[u] = 1;\n\t\t\t}\n\t\t\tuf.pop(k);\n\t\t\tuf.uni(k,u);\n\t\t}\n\t}\n\tint c = 0;\n\trepp(i,0,N) c += used[i];\n\treturn c == N;\n}\n\nLL BS(LL x , LL y){\n\tif(x-y<2) return x;\n\tLL z = (x+y)/2;\n\treturn eval(z)?BS(z,y):BS(x,z);\n}\n\nint main(){\n\tcin >> N >> M;\n\trepp(i,0,N){\n\t\tcin >> A[i] >> B[i];\n\t\tS += B[i];\n\t\tA[i] -= B[i];\n\t}\n\trepp(i,0,M){\n\t\tint x,y; cin >> x >> y;\n\t\tV[--x].push_back(--y);\n\t\tV[y].push_back(x);\n\t}\n\tcout << S + BS(1e9,-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n    register int x=0;\n    register char ch=getchar();\n    while(ch<'0'||ch>'9')   ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();\n    return x;\n}\nconst int N=2e5+5;\nint n,m,now,a[N],b[N],v[N],fa[N],id[N],vi[N],nex[N],head[N];\nvoid addedges(int x,int y){\n    nex[++now]=head[x];\n    head[x]=now,v[now]=y;\n}\nvector<int>d[N];\nlong long f[N],s[N];\nbool com(int x,int y){\n    return a[x]<a[y];\n}\nint find(int x){\n    return fa[x]?fa[x]=find(fa[x]):x;\n}\nvoid dfs(int x){\n    int si=d[x].size();\n    for(int i=0;i<si;i++){\n        int v=d[x][i];\n        dfs(v),s[x]+=s[v];\n    }\n    s[x]+=b[x],f[x]=s[x]+a[x];\n    for(int i=0;i<si;i++){\n        int v=d[x][i];\n        f[x]=min(f[x],s[x]-s[v]+max(f[v],1LL*a[x]));\n    }\n}\nint main(){\n    //freopen(\"1.out\",\"w\",stdout);\n    //freopen(\"1.in\",\"r\",stdin);\n    n=read(),m=read();\n    for(int i=1;i<=n;i++)   a[i]=read(),b[i]=read(),a[i]=max(a[i]-b[i],0);\n    for(int i=1;i<=m;i++){\n        int x=read(),y=read();\n        addedges(x,y),addedges(y,x);\n    }\n    for(int i=1;i<=n;i++)   id[i]=i;\n    sort(id+1,id+n+1,com);\n    for(int i=1;i<=n;i++){\n        int x=id[i];    vi[x]=1;\n        for(int j=head[x];j;j=nex[j])\n            if(vi[v[j]]){\n                int y=find(v[j]);\n                if(y==x)    continue;\n                d[x].push_back(y),fa[y]=x;\n            }\n    }\n    dfs(id[n]);\n    printf(\"%lld\\n\",f[id[n]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 100010>\nstruct UF{\n\tint par[N],r[N];\n\tll sum[N];\n\tpriority_queue<P> *que[N];\n\tUF(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tvoid init(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tif(que[i] != nullptr)delete que[i];\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unit_(int x,int y){\n\t\tpar[x] = y;\n\t\tsum[y] += sum[x];\n\t\tif(que[x]->size() < que[y]->size()){\n\t\t\twhile(!que[x]->empty()){\n\t\t\t\tP p = que[x]->top(); que[x]->pop();\n\t\t\t\tque[y]->push(p);\n\t\t\t}\n\t\t\tdelete que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\telse {\n\t\t\twhile(!que[y]->empty()){\n\t\t\t\tP p = que[y]->top(); que[y]->pop();\n\t\t\t\tque[x]->push(p);\n\t\t\t}\n\t\t\tdelete que[y];\n\t\t\tque[y] = que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\tif(r[x] == r[y])r[y] ++;\n\t}\n\tvoid unit(int x,int y){\n\t\tif(same(x,y))return;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(r[x] < r[y]){\n\t\t\tunit_(x,y);\n\t\t}\n\t\telse {\n\t\t\tunit_(y,x);\n\t\t}\n\t}\n\tvoid run(int v,int w){\n\t\twhile(1){\n\t\t\tv = find(v);\n\t\t\tif(que[v]->empty())break;\n\t\t\tP p = que[v]->top();\n\t\t\tif(find(p.sc) == v)que[v]->pop();\n\t\t\telse if(p.fr+sum[v]+w >= 0){\n\t\t\t\tque[v]->pop();\n\t\t\t\tunit(v,p.sc);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n};\n\nUF<100010> uf;\n\nint main(){\n\tstatic int n,m;\n\tstatic int a[100010],b[100010];\n\tstatic int u[100010],v[100010];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tfor(int i = 0 ; i < m ; i ++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tu[i] --;\n\t\tv[i] --;\n\t}\n\t\n\tint l = 0, r = 1000000000;\n\twhile(l<r){\n\t\tint mi = (l+r)/2;\n\t\tuf.init();\n\t\tfor(int i = 0 ; i < m ; i ++){\n\t\t\tuf.que[u[i]]->push(P(b[v[i]]-a[v[i]],v[i]));\n\t\t\tuf.que[v[i]]->push(P(b[u[i]]-a[u[i]],u[i]));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tuf.sum[i] = b[i];\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tif(a[i] <= b[i]+mi)uf.run(i,mi);\n\t\t}\n\t\tint root = uf.find(0);\n\t\tbool ok = true;\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tok &= uf.find(i) == root;\n\t\t}\n\t\tif(ok)r = mi;\n\t\telse l = mi+1;\n\t}\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tl += b[i];\n\t}\n\tcout << l << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef TRI<int, ll, ll> tri;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz,0); rep(i,sz) par[i] = i; }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]) swap(x,y); par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\nvector<int> G[MAX_N];\nll bsum[MAX_N], val[MAX_N];\nint unzip[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vl a(n),b(n);\n    rep(i,n){\n        cin >> a[i] >> b[i];\n    }\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        --u, --v;\n        G[u].pb(v), G[v].pb(u);\n    }\n    UF uf(n);\n    vi index(n);\n    iota(all(index),0);\n    sort(all(index),[&](const int& p, const int& q){\n        return a[p]-b[p] < a[q]-b[q];\n    });\n    rep(i,n){\n        unzip[index[i]] = i;\n    }\n    each(id, index){\n        vector<tri> vec;\n        ll wa = b[id];\n        each(v, G[id]){\n            if(unzip[v] < unzip[id] && !uf.same(v, id)){\n                vec.pb((tri){v, bsum[uf.find(v)], val[uf.find(v)]});\n                wa += vec.back().se;\n                uf.unite(v, id);\n            }\n        }\n        int root = uf.find(id);\n        bsum[root] = wa;\n        ll mn = wa + max(0LL, a[id] - b[id]);\n        each(p, vec){\n            cmn(mn, wa-p.se+max(max(a[id]-b[id], 0LL), p.th));\n        }\n        val[root] = mn;\n        if(id == index.back()){\n            cout << mn << \"\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 1e5 + 7;\nconst ll inf = 1e18;\nint n, m, p[N], f[N];\nll a[N], b[N], c[N], s[N], ans[N];\nvi g[N], e[N];\nbool v[N];\n\nint get(int x) {\n\treturn x == f[x] ? x : (f[x] = get(f[x]));\n}\n\nvoid dfs(int x) {\n\ts[x] = b[x], ans[x] = inf;\n\tfor (int y : e[x])\n\t\tdfs(y), s[x] += s[y];\n\tfor (int y : e[x])\n\t\tans[x] = min(ans[x], s[x] - s[y] + max(c[x], ans[y]));\n\tif (ans[x] == inf) ans[x] = b[x] + c[x];\n}\n\nint main() {\n\trd(n, m);\n\tfor (int i = 1; i <= n; i++)\n\t\trd(a[i], b[i]), c[i] = max(0ll, a[i] - b[i]), p[i] = f[i] = i;\n\tsort(p + 1, p + n + 1, [&](int i, int j) { return c[i] < c[j]; });\n\tfor (int i = 1, x, y; i <= m; i++)\n\t\trd(x, y), g[x].pb(y), g[y].pb(x);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = p[i];\n\t\tfor (int y : g[x])\n\t\t\tif (v[y] && get(y) != x)\n\t\t\t\te[x].pb(get(y)), f[get(y)] = x;\n\t\tv[x] = 1;\n\t}\n\tdfs(p[n]);\n\tprint(ans[p[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define Size(x) ((int)x.size())\nusing namespace std;\ntypedef long long ll;\nconst int N = 400010;\nint n, m, a[N], b[N], value[N], id[N], fa[N];\nvector<int> e[N];\nll f[N], g[N]; bool vis[N];\n\ntemplate<typename T> void gi(T &x) {\n\tx = 0; register char c = getchar();\n\tfor(; c < '0' || c > '9'; c = getchar());\n\tfor(; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + (c ^ 48);\n}\ninline bool cmp(const int &x, const int &y) { return value[x] < value[y]; }\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\nint main() {\n\tgi(n), gi(m);\n\trep(i, 1, n) gi(a[i]), gi(b[i]), value[i] = max(0, a[i] - b[i]), id[i] = fa[i] = i;\n\tsort(id + 1, id + n + 1, cmp);\n\trep(i, 1, m) { int x, y; gi(x), gi(y), e[x].pb(y), e[y].pb(x); }\n\trep(i, 1, n) {\n\t\tvector<int> edge; int u = id[i]; vis[u] = 1, g[u] = b[u];\n\t\tfor(auto v : e[u]) if(vis[v] && find(u) != find(v))\n\t\t\tedge.pb(v), edge.pb(find(v)), g[u] += g[find(v)], fa[find(v)] = u;\n\t\tf[u] = g[u] + value[u];\n\t\tfor(auto v : edge) f[u] = min(f[u], g[u] - g[v] + max(1ll * value[u], f[v]));\n\t}\n\tprintf(\"%lld\\n\", f[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define int long long\nusing namespace std;\nconst int N=1000010;\nint n,m,x,y,z,tot,pool,cnt,ans,A[N],B[N],s[N],f[N],rt[N],first[N],a[N<<1][2];\nstruct tjm{int node,val;} now;\nstruct tree{int lc,rc,node,val;} t[N<<1];\nstruct cmp{\n\tbool operator () (tjm p,tjm q) {\n\t\treturn p.val>q.val;\n\t}\n};\npriority_queue<tjm,vector<tjm>,cmp> h,hh;\ninline int read() {\n\tint tmp=0, fh=1; char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') fh=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') tmp=tmp*10+c-48, c=getchar();\n\treturn tmp*fh;\n}\ninline void ins_ed(int x,int y) {\n\ta[++tot][1]=y;\n\ta[tot][0]=first[x];\n\tfirst[x]=tot;\n}\nint gf(int x) {return x==f[x]?x:f[x]=gf(f[x]);}\ninline int newnode(int x) {\n\tt[++pool]=(tree){0,0,x,A[x]-B[x]};\n\treturn pool;\n}\nint merge(int x,int y) {\n\tif ((!x)||(!y)) return x+y;\n\t//printf(\"merge %lld %lld\\n\",x,y);\n\tif (t[x].val>t[y].val) swap(x,y);\n\tt[x].rc=merge(t[x].rc,y);\n\tswap(t[x].lc,t[x].rc);\n\treturn x;\n}\ninline void gather(int x,int y) {\n\tf[y]=x; s[x]+=s[y];\n\trt[x]=merge(rt[x],rt[y]);\n}\ninline void update(int x) {\n\twhile (gf(t[rt[x]].node)==x) rt[x]=merge(t[rt[x]].lc,t[rt[x]].rc);\n}\nsigned main() {\n\tn=read(); m=read();\n\tfor (int i=1;i<=n;i++) A[i]=read(), B[i]=read();\n\tfor (int i=1;i<=m;i++) {\n\t\tx=read(); y=read();\n\t\tins_ed(x,y); ins_ed(y,x);\n\t}\n\tfor (int i=1;i<=n;i++) hh.push((tjm){i,A[i]-B[i]});\n//\tfor (int i=1;i<=n;i++) if (A[i]<=B[i]) f[i]=i, s[i]=B[i], cnt++;\n//\tfor (int i=1;i<=n;i++) if (f[i]) {\n//\t\tx=gf(i);\n//\t\tfor (int j=first[i];j;j=a[j][0]) {\n//\t\t\ty=a[j][1];\n//\t\t\tif (!f[y]) rt[x]=merge(rt[x],newnode(y));\n//\t\t\telse if (gf(y)!=x) gather(x,gf(y));\n//\t\t}\n//\t}\n//\tfor (int i=1;i<=n;i++) if (f[i]==i) {\n//\t\tupdate(i);\n//\t\th.push((tjm){i,t[rt[i]].val-s[i]});\n//\t}\n\tans=0;\n\twhile (cnt<n) {\n\t\t//printf(\"! %d %d\\n\",hh.top().node,hh.top().val);\n\t\tif (h.empty()||(hh.top().val<=h.top().val)) {\n\t\t\tnow=hh.top(); hh.pop();\n\t\t\tx=now.node; if (f[x]) continue;\n\t\t\t//printf(\" %d %d\\n\",x,now.val);\n\t\t\tans=max(ans,now.val);\n\t\t\tf[x]=x; s[x]=B[x], cnt++;\n\t\t\tfor (int i=first[x];i;i=a[i][0]) {\n\t\t\t\ty=a[i][1];\n\t\t\t\tif (!f[y]) rt[x]=merge(rt[x],newnode(y));\n\t\t\t\telse if (gf(y)!=x) gather(x,gf(y));\n\t\t\t}\n\t\t\tif (rt[x]) {\n\t\t\t\tupdate(x); h.push((tjm){x,t[rt[x]].val-s[x]});\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tnow=h.top(); h.pop();\n\t\tx=now.node; if (f[x]!=x) continue;\n\t\ty=t[rt[x]].node; ans=max(ans,now.val);\n\t\t//printf(\"%d %d %d\\n\",x,y,now.val);\n\t\trt[x]=merge(t[rt[x]].lc,t[rt[x]].rc);\n\t\tf[y]=x; s[x]+=B[y]; cnt++;\n\t\tfor (int i=first[y];i;i=a[i][0]) {\n\t\t\tz=a[i][1];\n\t\t\tif (!f[z]) rt[x]=merge(rt[x],newnode(z));\n\t\t\telse if (gf(z)!=x) gather(x,gf(z));\n\t\t}\n\t\tif (rt[x]) {\n\t\t\tupdate(x);\n\t\t\th.push((tjm){x,t[rt[x]].val-s[x]});\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) ans+=B[i];\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjolong long set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nlong long t1,t2;\n\nlong long n,m;\n\nstd::vector<long long> g[100005];\n\nlong long a[100005];\nlong long b[100005];\n\n// disjolong long set stuff\nstd::vector<long long> todo;\nbool todo2[100005];     // determine if a vertex is in todo\n\nstd::priority_queue<std::pair<long long,long long> > pq[100005];\nlong long endval;\nlong long up[100005];\nlong long sz[100005];\nlong long money[100005];\nbool active[100005];\n\nlong long getroot(long long u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(long long u,long long v)\n{\n    up[v]=u;\n    sz[u]+=sz[v];\n    money[u]+=money[v]-endval;\n    active[u]=1;\n    while (!pq[v].empty()) {\n        pq[u].push(pq[v].top());\n        pq[v].pop();\n    }\n}\n\nlong long join(long long u,long long v)\n{\n    // return the root of their union\n    u=getroot(u);\n    v=getroot(v);\n    if (u==v) return u;\n    if (sz[u]>=sz[v]) {\n        join2(u,v);\n        return u;\n    }\n    else {\n        join2(v,u);\n        return v;\n    }\n}\n\nbool good(long long x)\n{\n    endval=x;\n    memset(active,0,sizeof active);\n    // make the pq\n    for (long long i=1; i<=n; i++) {\n        up[i]=i;\n        sz[i]=1;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n        while (!pq[i].empty()) pq[i].pop();\n        for (long long j:g[i]) pq[i].push({b[j]-a[j],j});\n    }\n    // do vertices\n    for (long long i=1; i<=n; i++) {\n        long long u=getroot(i);\n        if (!active[u]) continue;\n        //printf(\"start at %lld\\n\",i);\n        // do this vertex\n        while (!pq[u].empty() && -pq[u].top().first<=money[u]) {\n            long long v=pq[u].top().second;\n            pq[u].pop();\n            //printf(\"do %lld -> %lld\\n\",u,v);\n            u=join(u,v);\n        }\n    }\n    // check\n    for (long long i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nlong long lo=0;\nlong long hi=0x3f3f3f3f;\nlong long mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (long long i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (long long i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    //good(105); return 0;\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%lld %lld\\n\",lo,hi);\n    }\n    ans=lo;\n    for (long long i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nclass unionfind {\n\tvector<int> par, rank;\n\tvector<ll> bsum;\n\npublic:\n\tvoid init(int n, vi bs) {\n\t\tpar.resize(n);\n\t\trank.resize(n);\n\t\tbsum.resize(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tbsum[i] = bs[i];\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return ;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t\tbsum[y] += bsum[x];\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tbsum[x] += bsum[y];\n\t\t}\n\n\t\tif (rank[x] == rank[y]) ++rank[x];\n\t}\n\n\tbool same(int x, int y) { return (find(x) == find(y)); }\n\n\tll sum(int v) {\n\t\treturn bsum[find(v)];\n\t}\n} uf;\n\nconst int maxn = 100010;\nconst ll INF = TEN(18);\n\nvi g[maxn];\nbool vis[maxn];\nll dp[maxn];\n\nint main() {\n\tint N, M; cin >> N >> M;\n\n\tvector<pii> vec(N);\n\n\tvi A(N), B(N), C(N);\n\n\trep(i, N) {\n\t\tcin >> A[i] >> B[i];\n\t\tC[i] = max(A[i] - B[i], 0);\n\t\tvec[i] = mp(C[i], i);\n\t}\n\n\tuf.init(N, B);\n\n\trep(i, M) {\n\t\tint a, b;\n\t\tcin >> a >> b; --a; --b;\n\t\tg[a].pb(b); g[b].pb(a);\n\t}\n\n\tsort(ALL(vec));\n\n\trep(i, N) {\n\t\tint v = vec[i].se;\n\t\tvis[v] = true;\n\n\t\tll mini = C[v];\n\n\t\tfor (int to : g[v]) if (vis[to]) {\n\t\t\tmini = min(mini, max<ll>(C[v], dp[uf.find(to)]) - uf.sum(to));\n\t\t}\n\t\tfor (int to : g[v]) if (vis[to]) {\n\t\t\tuf.unite(v, to);\n\t\t}\n\n\t\tdp[uf.find(v)] = mini + uf.sum(v);\n\t}\n\n\tcout << dp[uf.find(0)] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint read()\n{\n   int x=0,f=1;char ch=getchar();\n   while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n   while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n   return x*f;\n}\n\nint cnt,head[N],a[N],b[N],id[N],u,v,fa[N],n,m,x,vis[N];\nlong long f[N],bsum[N];\nstruct node{int to,next;}num[N*2];\nvoid add(int x,int y) {num[++cnt].to=y;num[cnt].next=head[x];head[x]=cnt;}\nbool cmp(int A,int B) {return a[A]<a[B];}\nint getfather(int x) {return fa[x]?fa[x]=getfather(fa[x]):x;}\nint main()\n{\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++) a[i]=read(),b[i]=read(),a[i]=max(a[i]-b[i],0),id[i]=i;\n\tfor (int i=1;i<=m;i++) u=read(),v=read(),add(u,v),add(v,u);\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tx=id[i];vis[x]=1;f[x]=a[x];bsum[x]=b[x];\n\t\tfor (int j=head[x];j;j=num[j].next)\n\t\t  if (vis[num[j].to])\n\t\t  {\n\t\t  \t  int y=getfather(num[j].to);\n\t\t  \t  if (x==y) continue;\n\t\t  \t  fa[y]=x;bsum[x]+=bsum[y];\n\t\t  \t  f[x]=min(f[x],max(f[y],a[x]-bsum[y]));\n\t\t  }\n\t}\n\tprintf(\"%lld\\n\",bsum[id[n]]+f[id[n]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n#define int long long\n#define MMAX 16384\n#define fast_io() ios::sync_with_stdio(false)\n#define FOR(i, l, r) for(int i = (l); i < (r); i++)\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef double ld;\ntypedef pair<ld, ld> dd;\n\nconst ll INF = 1000000000000000000LL;\nconst int NMAX = 1e5+4;\nconst int mod = 1e9+7;\nconst ld eps = 1e-10;\nconst ld PI = acos(-1);\n\nvi A, B;\nvi adj[NMAX];\nint N, M;\nvii As, Bs;\n\nvi p;\nint find(int a) { return p[a] = p[a] == a ? a : find(p[a]); }\nvoid comb(int a, int b) {p[find(b)] = find(a);}\n\nsigned main(){\n    fast_io();\n    cin >> N >> M;\n    FOR(i, 0, N) p.pb(i);\n    FOR(i, 0, N){\n        int a, b;\n        cin >> a >> b;\n        a = max(a - b, 0LL);\n        A.pb(a);\n        As.pb({a, i});\n        B.pb(b);\n        Bs.pb({b, i});\n    }\n    sort(As.begin(), As.end());\n    sort(Bs.begin(), Bs.end(), greater<ii>());\n    FOR(i, 0, M){\n        int u, v;\n        cin >> u >> v;\n        adj[u].pb(v);\n        adj[v].pb(u);\n    }\n    int W = Bs[0].fst;\n    // Moving backwards from before payment, standing at position Bs[i].snd, moving to Bs[i+1].snd\n    int j = 0;\n    FOR(i, 0, N-1){\n        int u = As[i].snd, v = As[i+1].snd;\n        while(find(u) != find(v)){\n            // add As[j].snd\n            int a = As[j].fst, u = As[j].snd;\n            for(v : adj[u])\n                if(A[v] <= a)\n                    comb(u, v);\n            W = max(W, a);\n            j++;\n        }\n        W += B[v];\n    }\n    cout << W << endl;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    ll max_a = -1;\n    for (int i = 0; i < cp.size(); i++) if (cp[i].first <= a[v] - b[v]) max_a = min(max_a, cp[i].first);\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if ((max_a == -1 && i == 0) || cp[0].first == max_a)\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#pragma G++ optimize(2)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define LL long long\n#define O4 __inline__ __attribute__((always_inline))\n#define inf 0x7fffffff\n#define UL unsigned LL\n#define LD long double\n#ifdef ONLINE_JUDGE\n#define getchar nc\n#endif\n#define int LL\nnamespace FastIO{\n\tO4 char nc(){\n\t\tstatic char buf[100000],*p1=buf,*p2=buf;\n\t\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n\t}\n\tO4 int read(){\n\t\tchar t;int u=0,k=1;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\treturn u*k;\n\t}\n\ttemplate <typename T>\n\tO4 void read(T &u){\n\t\tchar t;T k=1;u=0;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\tif(t=='.'){\n\t\t\tT mass=0.1;t=getchar();\n\t\t\twhile(t>='0'&&t<='9'){u+=mass*(t-'0');mass/=10;t=getchar();}\n\t\t}u*=k;\n\t}\n\tO4 int read(char asd[]){\n\t\tchar t=getchar();int u=0;\n\t\twhile(t==' '||t=='\\n'||t=='\\r')t=getchar();\n\t\tif(t==EOF)return -1;\n\t\twhile(t!=' '&&t!='\\n'&&t!=EOF&&t!='\\r')asd[u++]=t,t=getchar();\n\t\tasd[u]='\\0';return u;\n\t}\n\tchar sr[1<<23],z[23];int C=-1,Z;\n\tO4 void wer(int x,char T){\n\t\tint y=0;if(x<0)y=1,x=-x;\n\t\twhile(z[++Z]=x%10+'0',x/=10);if(y)z[++Z]='-';\n\t\twhile(sr[++C]=z[Z],--Z);sr[++C]=T;\n\t}\n\tO4 void wer(char T[],char QWQ){\n\t\tfor(int i=0;T[i]!='\\0';i++)sr[++C]=T[i];\n\t\tsr[++C]=QWQ;\n\t}\n\tO4 void wer(char T){sr[++C]=T;}\n\tO4 void out(){fwrite(sr,1,C+1,stdout);C=-1;}\n}\nusing namespace std;\nusing namespace FastIO;\nconst int N=1e5+5;\nint n,m;\nint val[N],sum[N],A[N],B[N],fa[N],id[N],F[N];\nbool vis[N];\nvector <int> Map[N];\nint get_fa(int x){return fa[x]==x?x:fa[x]=get_fa(fa[x]);}\nsigned main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=read();B[i]=read();\n\t\tA[i]=max(A[i]-B[i],0);\n\t\tfa[i]=id[i]=i;\n\t}\n\twhile(m--){\n\t\tint a=read(),b=read();\n\t\tMap[a].push_back(b);\n\t\tMap[b].push_back(a);\n\t}\n\tsort(id+1,id+1+n,[](int a,int b){return A[a]<A[b];});\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];sum[x]=B[x];\n\t\tvector <int> load;vis[x]=1;\n\t\tfor(int to:Map[x]){\n\t\t\tif(!vis[to])continue;\n\t\t\tint a=get_fa(x),b=get_fa(to);\n\t\t\tif(a==b)continue;\n\t\t\tload.push_back(b);\n\t\t\tsum[x]+=sum[b];fa[b]=a;\n\t\t}\n\t\tF[x]=sum[x]+A[x];\n\t\tfor(int to:load)F[x]=min(F[x],sum[x]-sum[to]+max(F[to],A[x]));\n\t}\n\tcout<<F[id[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,u,v,a[100001],b[100001],c[100001],s[100001],d[100001];\nlong long x[100001][401],y[100005][401],f[100001],sr[100001];\nbool bo[100001];\ninline long long read()\n{\n    long long sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(long long x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(long long x,long long y)\n{\n\treturn c[x]<c[y];\n}\ninline long long find(long long x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(long long u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register long long i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u][++x[u][0]]=v;\n\t\tx[v][++x[v][0]]=u;\n\t}\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\tlong long u=d[i];\n\t\tfor (register long long j=1;j<=x[u][0];++j)\n\t\t{\n\t\t\tlong long v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u][++y[u][0]]=vv;\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        //if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Father(n) != Father(node))\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total += B[n];\n                            break;\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 10000000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll a[100005],b[100005];\n\nstruct quickfind{\n\tint par[200005];\n\tll val[200005];\n\tpriority_queue<P,vector<P>,greater<P> > que[200005];\n\tquickfind(){\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\tval[i]=b[i];\n\t\t\twhile(que[i].size())que[i].pop();\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\n\tll getval(int x){\n\t\treturn val[find(x)];\n\t}\n\n\tvoid insert(int x,P y){\n\t\tque[find(x)].push(y);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)return;\n\t\tif(que[x].size()<que[y].size()){\n\t\t\tpar[x]=y;\n\t\t\tval[y]+=val[x];\n\t\t\twhile(que[x].size()){\n\t\t\t\tque[y].push(que[x].top());\n\t\t\t\tque[x].pop();\n\t\t\t}\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tval[x]+=val[y];\n\t\t\twhile(que[y].size()){\n\t\t\t\tque[x].push(que[y].top());\n\t\t\t\tque[y].pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nquickfind qi;\nint n,m;\n\nvector<int> G[100005];\nbool flag[200005];\nbool searched[200005];\nll maxi=0;\n\nbool C(ll val){\n\tmemset(flag,false,sizeof(flag));\n\tmemset(searched,false,sizeof(searched));\n\tmaxi=0;\n\tqi.init(n);\n\tfor(int i=0;i<n;i++){\n\t\tif(val+b[i]>=a[i]){\n\t\t\tif(val<=52){\n\t\t\t\t//printf(\"st %lld %d\\n\",val,i);\n\t\t\t}\n\t\t\tflag[i]=true;\n\t\t\tmaxi=max(maxi,b[i]+val);\n\t\t}\n\t}\n\tqueue<int> nxt;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfor(int i=0;i<n;i++){\n\t\tif(flag[i]){\n\t\t\tsearched[i]=true;\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tint v=G[i][j];\n\t\t\t\tif(flag[v]){\n\t\t\t\t\t//printf(\"unite %d-%d\\n\",i,v);\n\t\t\t\t\tqi.unite(i,v);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(i));\n\t\t\t\t}else if(val+qi.getval(i)>=a[v]-b[v]){\n\t\t\t\t\t//printf(\"unite %d-%d\\n\",i,v);\n\t\t\t\t\tflag[v]=true;\n\t\t\t\t\tqi.unite(i,v);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(i));\n\t\t\t\t\tnxt.push(v);\n\t\t\t\t}else{\n\t\t\t\t\t//printf(\"que in%d->%d\\n\",i,v);\n\t\t\t\t\tque.push(P(a[v],v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(nxt.size() || que.size()){\n\t\tif(nxt.size()){\n\t\t\tint v=nxt.front();\n\t\t\tnxt.pop();\n\t\t\tif(searched[v])continue;\n\t\t\tif(val<=52){\n\t\t\t\t//printf(\"%lld %lld %d\\n\",val,qi.getval(v),v);\n\t\t\t}\n\t\t\tsearched[v]=true;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint nv=G[v][i];\n\t\t\t\tif(flag[nv]){\n\t\t\t\t\tqi.unite(v,nv);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(v));\n\t\t\t\t}else if(val+qi.getval(v)>=a[nv]-b[nv]){\n\t\t\t\t\tflag[nv]=true;\n\t\t\t\t\tqi.unite(v,nv);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(v));\n\t\t\t\t\tnxt.push(nv);\n\t\t\t\t}else{\n\t\t\t\t\tque.push(P(a[nv],nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\t//printf(\"f-que %d\\n\",p.second);\n\t\t\tif(p.first-b[p.second]>maxi)continue;\n\t\t\tint v=p.second;\n\t\t\tif(flag[v])continue;\n\t\t\t//printf(\"que %d\\n\",v);\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint nv=G[v][i];\n\t\t\t\tif(flag[nv] && val+qi.getval(nv)>=p.first-b[nv]){\n\t\t\t\t\tflag[v]=true;\n\t\t\t\t\tnxt.push(v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!flag[i])return false;\n\t}\n\t//printf(\"%lld\\n\",val);\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tll all=0;\n\tll l=-1,r=0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tr+=(a[i]+b[i]);\n\t\tall+=b[i];\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\twhile(l+1LL<r){\n\t\tll mid=(l+r)/2LL;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%lld\\n\",r+all);\n\t//printf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1){\n                s[u1].insert({a[v1]-b[v1],v1});\n                s[v1].insert({a[u1]-b[u1],u1});\n                continue;\n            }\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        \n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+9;\nint n,m,a[N],b[N],_[N],u,v,fa[N],t,d[N];\nvector<int>e[N];\nll f[N],sz[N];\nbool p[N];\nint min(int x,int y) {return x<y?x:y;}\nint max(int x,int y) {return x>y?x:y;}\nbool cmp(int x,int y) {return a[x]<a[y];}\nint gef(int x) {return fa[x]?fa[x]=gef(fa[x]):x;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d%d\",a+i,b+i), a[_[i]=i]=max(a[i]-b[i],0), sz[i]=b[i];\n\tfo(i,1,m) scanf(\"%d%d\",&u,&v), e[u].push_back(v), e[v].push_back(u);\n\tsort(_+1,_+n+1,cmp);\n\tfo(i,1,n)\n\t{\n\t\tint x=_[i]; p[x]=1,t=0;\n\t\tfor(int y:e[x]) if(p[y]&&gef(x)!=gef(y)) fa[v=gef(y)]=x, sz[x]+=sz[d[++t]=v];\n\t\tf[x]=sz[x]+a[x];\n\t\tfor(int y;y=d[t];t--) f[x]=min(f[x],sz[x]-sz[y]+max(a[x],f[y]));\n\t}\n\tprintf(\"%lld\",f[gef(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* UnionFind */\n\nstruct UnionFind{\n  vector<int> data, tree_size;\n  UnionFind(int s):data(s,-1),tree_size(s,1) {}\n  \n  int root(int x){\n    if(data[x]==-1) return x;\n    return data[x]=root(data[x]);\n  }\n  \n  bool set(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    data[y]=x;\n    tree_size[x] += tree_size[y];\n    tree_size[y] = 0;\n    return true;\n  }\n  \n  bool check(int x,int y){\n    x=root(x);\n    y=root(y);\n    return x==y;\n  }\n  \n  int size(int x){\n    return tree_size[root(x)];\n  }\n  \n};\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE];\n  vector<pair<int,int> > vec;\n  vector<int> g[SIZE];\n  pair<ll,ll> dp[SIZE];\n  \n  scanf(\"%d%d\", &n, &m);\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\", a+i, b+i);\n    vec.push_back({a[i], i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  for(int i=0;i<m;i++){\n    int u, v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  UnionFind uf(n);\n\n  for(int i=0;i<n;i++){\n    int p = vec[i].second;\n    vector<int> uni;\n    \n    for(int j=0;j<g[p].size();j++){\n      if (a[p] > a[g[p][j]])\n        uni.push_back(uf.root(g[p][j]));\n    }\n\n    sort(uni.begin(), uni.end());\n    uni.erase(unique(uni.begin(), uni.end()), uni.end());\n    \n    ll sum = 0;\n\n    for(int j=0;j<uni.size();j++){\n      sum += dp[uni[j]].second;\n    }\n    sum += b[p];\n\n    pair<ll,ll> calc = {LLINF, LLINF};\n    \n    for(int j=0;j<uni.size();j++){\n      int q = uni[j];\n      ll nowcost = dp[q].first;\n\n      nowcost += b[p];\n      nowcost = max(nowcost, (ll)a[p]);\n      nowcost += sum - (dp[q].second + b[p]);\n\n      calc = min(calc, make_pair(nowcost, sum));\n    }\n\n    calc = min(calc, make_pair(max(a[p], b[p]) + (sum - b[p]), sum));\n    \n    for(int j=0;j<uni.size();j++){\n      uf.set(p, uni[j]);\n    }\n\n    dp[uf.root(p)] = calc;\n\n    //debug(uf.root(p));\n    //debug(calc.first);\n  }\n  \n  printf(\"%lld\\n\", dp[uf.root(0)].first);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fir first\n#define sec second\n#define db double\n#define ll long long\n#define ev eg[i].v\n#define pb push_back\n#define INF 1000000007\n#define pir pair<int,int>\n#define Rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define RepD(i,r,l) for(int i=(r);i>=(l);--i)\n#define RepG(i,x) for(int i=hd[x];i;i=eg[i].nxt)\nusing namespace std;\n\nconst int N=1e5+5;\n\nll hd[N],cnt=0;bool vis[N];\nstruct Eg{ll v,nxt;}eg[N*2];\nll a[N],b[N],c[N],fa[N],f[N],g[N];\n\nll find(ll x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid add(ll u,ll v){eg[++cnt]=(Eg){v,hd[u]},hd[u]=cnt;}\n\nbool cmp(ll x,ll y){return a[x]<a[y];}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tll n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\tRep(i,1,n) scanf(\"%lld%lld\",&a[i],&b[i]),a[i]=max(a[i]-b[i],0ll);\n\tRep(i,1,m){\n\t\tll u,v;\n\t\tscanf(\"%lld%lld\",&u,&v);\n\t\tadd(u,v),add(v,u);\t\n\t}\n\tRep(i,1,n) c[i]=fa[i]=i;\n\tsort(c+1,c+n+1,cmp);\n\tRep(k,1,n){\n\t\tll x=c[k];\n\t\tvis[x]=1,f[x]=a[x],g[x]=b[x];\n\t\tRepG(i,x)\n\t\t\tif(vis[ev]){\n\t\t\t\tll ff=find(ev);\n\t\t\t\tif(x==ff) continue;\n\t\t\t\tfa[ff]=x,g[x]+=g[ff];\n\t\t\t\tf[x]=min(f[x],max(f[ff],a[x]-g[ff]));\t\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[c[n]]+g[c[n]]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, M;\nint A[100000], B[100000];\nvector<int> G[100000];\nint U[100000], R[100000];\nint repr[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\nvector<int> G2[100000];\nbool used[100000];\nlong long dp[100000], sum[100000];\n\nvoid dfs(int x) {\n  sum[x] = B[x];\n  if (G2[x].empty()) dp[x] = B[x];\n  for (int t : G2[x]) {\n    dfs(t);\n    sum[x] += sum[t];\n  }\n  //dp[x] = max(dp[x], sum[x]);\n  for (int t : G2[x]) {\n    dp[x] = min(dp[x], max(dp[t] + (sum[x]-sum[t]), max(A[x]+sum[x]-B[x]-sum[t], A[t]+sum[x]-sum[t])));\n  }\n  dp[x] = min(dp[x], sum[x]-B[x]+max(A[x], B[x]));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, N) cin >> A[i] >> B[i];\n  rep(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) U[i] = i, R[i] = 1, repr[i] = i;\n  vector<P> ord;\n  rep(i, N) ord.pb(P(A[i]-B[i], i));\n  sort(all(ord));\n  for (P p : ord) {\n    int x = p._2;\n    used[x] = true;\n    for (int t : G[x]) if (used[t] && !same(x, t)) {\n      assert(repr[find(x)] == x);\n      int c = repr[find(t)];\n      unite(x, t);\n      repr[find(x)] = x;\n      G2[x].pb(c);\n      //cout<<x<<\"->\"<<c<<\"\\n\";\n    }\n  }\n  rep(i, N) dp[i] = INF;\n  int root = ord.back()._2;\n  assert(root == repr[find(0)]);\n  dfs(root);\n  long long m = dp[root];\n  rep(i, N) m = max(m, A[i]);\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nint M;\nLL ans;\nLL A[114514];\nLL B[114514];\nLL C[114514];\nbool used[114514];\nvector<int> es[114514];\npriority_queue<pll, vector<pll>, greater<pll>> order;\n\nstruct UfData {\n  int parsz;\n  LL exc;\n  LL bsum;\n  LL W;\n\n  UfData() : parsz(-1) {\n    W = 0;\n    bsum = 0;\n    exc = 0;\n  }\n\n  void Merge(const UfData &d, int u, int v) {\n    parsz += d.parsz;\n    \n    LL a = exc + max(C[v] - W, 0LL);\n    LL b = d.exc + max(C[u] - d.W, 0LL);\n    if (a < b) {\n      W = max(W, C[v]) + d.bsum;\n    } else if (a > b) {\n      W = max(d.W, C[u]) + bsum;\n    } else {\n      LL f = max(W, C[v]) + d.bsum;\n      LL g = max(d.W, C[u]) + bsum;\n      W = max(f, g);\n    }\n\n    exc = min(a, b);\n    bsum += d.bsum;\n    // w += d.w;\n  }\n};\n\nstruct UnionFind {\n  vector<UfData> dat;\n\n  UnionFind() {}\n  UnionFind(int n) {\n    Init(n);\n  }\n\n  void Init(int n) {\n    dat.assign(n, UfData());\n  }\n\n  int Root(int v) {\n    if (dat[v].parsz < 0) return v;\n    return dat[v].parsz=Root(dat[v].parsz);\n  }\n\n  bool Unite(int u, int v) {\n    int p = Root(u); \n    int q = Root(v);\n    if (p == q) return false;\n    //printf(\"unite %d %d from %d %d\\n\", p, q, u, v);\n\n    if (dat[p].parsz > dat[q].parsz) {\n      swap(p, q);\n      swap(u, v);\n    }\n\n    dat[p].Merge(dat[q], u, v);\n    dat[q].parsz = p;\n\n    return true;\n  }\n  \n  bool Same(int u, int v) {\n    return Root(u) == Root(v);\n  }\n\n  int Size(int v) {\n    return -dat[Root(v)].parsz;\n  }\n\n  UfData& Data(int v) {\n    return dat[Root(v)];\n  }\n};\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    scanf(\"%lld%lld\", &A[i], &B[i]);\n    C[i] = max(A[i]-B[i], 0LL);\n    order.push(pll(C[i], i));\n    ans += B[i];\n  }\n\n  rep(i, M) { \n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    --u;\n    --v;\n    es[u].emplace_back(v);\n    es[v].emplace_back(u);\n  }\n\n  UnionFind uf(N);\n  rep(v, N) {\n    auto &d = uf.Data(v);\n    d.bsum = B[v];\n    if (A[v] > B[v]) {\n      d.exc = A[v] - B[v];\n      d.W = A[v];\n    } else {\n      d.exc = 0;\n      d.W = B[v];\n    }\n  }\n\n  while (!order.empty()) {\n    auto p = order.top(); order.pop();\n    int v = p.Y;\n    //printf(\"p: %lld %d\\n\", p.X, v);\n    used[v] = true;\n    for (int u : es[v]) {\n      if (!used[u]) continue;\n      //printf(\"uniting %d, %d\\n\", u, v);\n\n      uf.Unite(u, v);\n    }\n  }\n\n  auto &d = uf.Data(0);\n  assert(d.bsum == ans);\n  printf(\"%lld\\n\", d.bsum + d.exc);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N=110000;\nint father[N];\nlong long sum[N],w[N];\nint n,m,A[N],B[N],pos[N],in[N];\nint findfather(int k1){\n\tif (father[k1]==k1) return k1; return father[k1]=findfather(father[k1]);\n}\nvector<int> go[N];\nint compare(int k1,int k2){\n\treturn max(0,A[k1]-B[k1])<max(0,A[k2]-B[k2]);\n}\nint pd[N],sign;\nvector<int> C;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&A[i],&B[i]);\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2);\n\t\tgo[k1].push_back(k2);\n\t\tgo[k2].push_back(k1);\n\t}\n\tfor (int i=1;i<=n;i++) pos[i]=i,father[i]=i;\n\tsort(pos+1,pos+n+1,compare);\n\tfor (int i=1;i<=n;i++){\n\t\tint k1=pos[i]; sign++; C.clear();\n\t\tfor (int j=0;j<go[k1].size();j++){\n\t\t\tint k2=go[k1][j];\n\t\t\tif (in[k2]){\n\t\t\t\tint root=findfather(k2);\n\t\t\t\tif (pd[root]!=sign){\n\t\t\t\t\tpd[root]=sign; C.push_back(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<C.size();j++){\n\t\t\tfather[C[j]]=k1;\n\t\t\tsum[k1]+=sum[C[j]];\n\t\t} in[k1]=1;\n\t\tif (C.size()==0){\n\t\t\tw[k1]=max(A[k1],B[k1]); sum[k1]=B[k1]; continue;\n\t\t}\n\t\tw[k1]=sum[k1]+max(A[k1],B[k1]);\n\t\tfor (int j=0;j<C.size();j++)\n\t\t\tw[k1]=min(w[k1],sum[k1]-sum[C[j]]+max(1ll*A[k1],w[C[j]]+B[k1]));\n\t\tsum[k1]+=B[k1];\n\t\t//cout<<k1<<\" \"<<w[k1]<<\" \"<<B[k1]<<endl;\n\t}\n\tprintf(\"%lld\\n\",w[findfather(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing P = pair<ll, int>;\n\nint n;\nVV<int> g;\nV<ll> lw, us;\n\nV<set<P>> gx;\n\nV<int> ig;\nVV<int> gi;\nvoid uf_init() {\n    ig = V<int>(n); gi = VV<int>(n);\n    for (int i = 0; i < n; i++) {\n        ig[i] = i; gi[i] = {i};\n    }\n}\n\nbool uf_same(int a, int b) {\n    return ig[a] == ig[b];\n}\n\nvoid uf_merge(int a, int b) {\n    if (uf_same(a, b)) return;\n    int x = ig[a], y = ig[b];\n    if (gi[x].size() < gi[y].size()) swap(x, y);\n    for (int j: gi[y]) {\n        ig[j] = x;\n    }\n    gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n    gi[y].clear();\n\n    us[x] += us[y];\n    us[y] = 0;\n\n    if (gx[x].size() < gx[y].size()) swap(gx[x], gx[y]);\n    for (auto d: gx[y]) {\n        gx[x].insert(d);\n    }\n    gx[y].clear();\n}\n\nll ans;\nV<bool> vis;\npriority_queue<P, V<P>, greater<P>> que;\n\nvoid on(int p) {\n    vis[p] = true;\n    for (int d: g[p]) {\n        if (vis[d]) {\n            uf_merge(p, d);\n        }\n    }\n    int x = ig[p];\n    while (gx[x].size()) {\n        auto tp = *(gx[x].begin());\n        if (vis[tp.second]) {\n            gx[x].erase(gx[x].begin());\n            continue;\n        }\n        if (tp.first <= ans+us[x]) {\n            on(tp.second);\n        } else {\n            que.push(P(tp.first - us[x], tp.second));\n        }\n        break;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int m;\n    cin >> n >> m;\n    g = VV<int>(n);\n    lw = V<ll>(n); us = V<ll>(n);\n    ll off = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> lw[i] >> us[i]; lw[i] -= us[i];\n        off += us[i];\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b); g[b].push_back(a);\n    }\n    uf_init();\n    \n    gx = V<set<P>>(n);\n    for (int i = 0; i < n; i++) {\n        for (int d: g[i]) {\n            gx[i].insert(P(lw[d], d));\n        }\n    }\n    vis = V<bool>(n);\n\n    for (int i = 0; i < n; i++) {\n        que.push(P(lw[i], i));\n    }\n    \n    ans = 0;\n    while (que.size()) {\n        P tp = que.top(); que.pop();\n        int p = tp.second;\n        if (vis[p]) continue;\n        ans = max(ans, tp.first);\n        on(p);\n    }\n    cout << ans+off << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e5 + 20 ;\nint n , m , a[N] , b[N] , c[N] , sec[N] ;\nvector <int> tmp[N] , g[N] ;\n\nint par[N] ;\n\ninline bool byC (int i , int j) { return c[i] < c[j] ; }\n\nint root (int v) { return par[v] < 0 ? v : par[v] = root(par[v]) ; }\n\ninline void merge (int u , int v) { // c[u] >= c[v]\n\tif ((u = root(u)) == (v = root(v))) return ;\n\n\tg[u].push_back(v) ;\n\tpar[v] = u ;\n}\n\nll sum[N] , res[N] ;\n\nvoid dfs (int v) {\n\tll mx = 0 ;\n\n\tsum[v] = b[v] ;\n\n\tfor (int u : g[v]) {\n\t\tdfs(u) ;\n\n\t\tsum[v] += sum[u] ;\n\t\tmx = max(mx , sum[u] - max(0ll , res[u] - c[v])) ;\n\t}\n\n\tres[v] = sum[v] + c[v] - mx ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> m ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] >> b[i] ;\n\t\ta[i] = max(a[i] , b[i]) ;\n\t\t\n\t\tc[i] = a[i] - b[i] ;\n\t}\n\n\tiota(sec , sec + n , 0) ;\n\tsort(sec , sec + n , byC) ;\n\n\tfor (int i = 0 , u , v ; i < m ; i ++) {\n\t\tcin >> u >> v ;\n\t\tu -- , v -- ;\n\n\t\ttmp[u].push_back(v) ;\n\t\ttmp[v].push_back(u) ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) par[i] = -1 ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tint v = sec[i] ;\n\t\tfor (int u : tmp[v])\n\t\t\tif (c[u] <= c[v]) merge(v , u) ;\t\n\t}\n\n\tint root = sec[n - 1] ;\n\tdfs(root) ;\n\n\tcout << res[root] << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nvoid unite_que(priority_queue<Pii, vector<Pii>, greater<Pii>> &q1, priority_queue<Pii, vector<Pii>, greater<Pii>> &q2){\n    if(q2.size() > q1.size()) q1.swap(q2);\n    while(!q2.empty()){\n        q1.push(q2.top());\n        q2.pop();\n    }\n}\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, dat;\n    vector<priority_queue<Pii, vector<Pii>, greater<Pii>>> que;\n\n    Union_find(int N){\n        par = vector<int>(N);\n        //REP(i, N) par[i] = i;\n        sz = vector<int>(N);\n        dat = vector<int>(N);\n        //dat = v;\n        que = vector<priority_queue<Pii, vector<Pii>, greater<Pii>>>(N);\n    }\n\n    void init(vector<int> v, int N){\n        REP(i, N) par[i] = i;\n        fill(sz.begin(), sz.end(), 1);\n        REP(i, N) dat[i] = v[i];\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        dat[x] += dat[y];\n        unite_que(que[x], que[y]);\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int w, Union_find &UF){\n        if(UF.union_size(v) > 1) return;\n        while(!UF.que[UF.find(v)].empty()){\n            int par = UF.find(v);\n            Pii p = UF.que[par].top();\n            if(p.first > UF.dat[par] + w) break;\n            UF.que[par].pop();\n            UF.unite(par, p.second);\n        }\n    }\n\n};\n\nvoid init(Graph &G, Union_find &UF, vec &A, int N){\n    //UF.que = vector<priority_queue<Pii, vector<Pii>, greater<Pii>>>(N);\n    REP(i, N){\n        UF.que[i] = priority_queue<Pii, vector<Pii>, greater<Pii>>();\n        REP(k, G.G[i].size()) UF.que[i].push(Pii(A[G.G[i][k].to], G.G[i][k].to));\n    }\n}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    int S = 0;\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        S += B[i];\n        A[i] -= B[i];\n    }\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1, 0);\n    }\n    if(N == 1){\n        cout << max(A[0] + B[0], B[0]) << endl;\n        return 0;\n    }\n\n    int w1 = -1, w2 = 1000000000;\n    Union_find UF(N);\n    while(w2 - w1 > 1){\n        int w = (w1 + w2 + 1) / 2;\n        UF.init(B, N);\n        init(G, UF, A, N);\n        REP(i, N) if(w >= A[i]) G.dfs(i, w, UF);\n        //cout << w << \",\" << UF.union_size(0) << endl;\n        if(UF.union_size(0) == N) w2 = w;\n        else w1 = w;\n    }\n    cout << w2 + S << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || a[v] - b[v] >= cp[i].first - cp[i].second)\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(int x,int y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&C[y]<=C[x]) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\n#define int long long\nusing namespace std;\nconst int maxn=200010;\nint n,m,cnt1,head1[maxn],cnt2,head2[maxn],vis[maxn],fa[maxn],a[maxn],b[maxn],c[maxn],sumb[maxn],rk[maxn],dp[maxn];\nstruct edge1\n{\n    int to,next;\n}e1[maxn<<1];\nstruct edge2\n{\n    int to,next;\n}e2[maxn<<1];\ninline int read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n    {\n\tif(ch=='-')\n\t    f=-1;\n\tch=getchar();\n    }\n    while(ch>='0'&&ch<='9')\n    {\n\tx=(x<<1)+(x<<3)+(ch^48);\n\tch=getchar();\n    }\n    return x*f;\n}\ninline void write(int a)\n{\n    if(a<0)\n    {\n\tchar a='-',b='1';\n\tputchar(a);\n\tputchar(b);\n    }\n    else\n    {\n\tif(a>=10)\n\t    write(a/10);\n\tputchar(a%10+'0');\n    }\n}\nvoid add1(int from,int to)\n{\n    e1[++cnt1]=(edge1){to,head1[from]};\n    head1[from]=cnt1;\n}\nvoid add2(int from,int to)\n{\n    e2[++cnt2]=(edge2){to,head2[from]};\n    head2[from]=cnt2;\n}\nint find(int x)\n{\n    return fa[x]==x?x:fa[x]=find(fa[x]);\n}\nbool cmp(const int &a,const int &b)\n{\n    return c[a]<c[b];\n}\nvoid dfs(int now)\n{\n    sumb[now]=b[now];\n    for(int i=head2[now];i;i=e2[i].next)\n    {\n\tint to=e2[i].to;\n\tdfs(to);\n\tsumb[now]+=sumb[to];\n    }\n    dp[now]=sumb[now]+c[now];\n    for(int i=head2[now];i;i=e2[i].next)\n    {\n\tint to=e2[i].to;\n\tdp[now]=min(dp[now],sumb[now]-sumb[to]+max(dp[to],c[now]));\n    }\n}\nsigned main()\n{\n    n=read(),m=read();\n    for(int i=1;i<=n;i++)\n    {\n\ta[i]=read(),b[i]=read();\n\tc[i]=max(a[i]-b[i],0LL);\n\tfa[i]=rk[i]=i;\n    }\n    for(int i=1;i<=m;i++)\n    {\n\tint u=read(),v=read();\n\tadd1(u,v),add1(v,u);\n    }\n    sort(rk+1,rk+n+1,cmp);\n    for(int i=1;i<=n;i++)\n    {\n\tint now=rk[i];\n\tvis[now]=1;\n\tfor(int j=head1[now];j;j=e1[j].next)\n\t{\n\t    int to=e1[j].to;\n\t    if(vis[to])\n\t    {\n\t\tint f=find(to);\n\t\tif(f!=now)\n\t\t{\n\t\t    fa[f]=now;\n\t\t    add2(now,f);\n\t\t}\n\t    }\n\t}\n    }\n    dfs(rk[n]);\n    write(dp[rk[n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        if(total >= 1000000000000000)\n                            return 1;\n                        //if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Father(n) != Father(node))\n                    for(int j = 0; j < G[n].size(); j++)\n                    {\n                        int neighb = G[n][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[n] = 1;\n                            Q.push(n);\n                            total += B[n];\n                            if(total >= 1000000000000000)\n                            return 1;\n                            break;\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 110000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int MAX_N = 1E5;\nconstexpr LL INF = 1E18;\nint n, m;\nvector<int> e[MAX_N];\nint a[MAX_N], b[MAX_N];\nint fa[MAX_N];\nint p[MAX_N];\nLL f[MAX_N], s[MAX_N];\nint find(int x) {\n    while (fa[x] >= 0 && fa[fa[x]] >= 0)\n        x = fa[x] = fa[fa[x]];\n    return fa[x] >= 0 ? fa[x] : x;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n        a[i] = max(a[i] - b[i], 0);\n    }\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    fill(fa, fa + n, -1);\n    iota(p, p + n, 0);\n    sort(p, p + n, [&](int i, int j) {return a[i] < a[j] || a[i] == a[j] && i < j;});\n    for (int i = 0; i < n; ++i) {\n        int u = p[i];\n        f[u] = a[u];\n        s[u] = b[u];\n        for (int v : e[u]) {\n            if (a[v] > a[u] || a[v] == a[u] && v > u)\n                continue;\n            v = find(v);\n            if (u == v)\n                continue;\n            fa[v] = u;\n            s[u] += s[v];\n            f[u] = min(f[u], max((LL)a[u], f[v]) - s[v]);\n        }\n        f[u] += s[u];\n    }\n    cout << f[find(0)] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\ninline int read()\n{\n\tint data = 0, w = 1; char ch = getchar();\n\twhile (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n\treturn data * w;\n}\n\nconst int N(1e5 + 10); const long long INF(1e16);\ntemplate <typename T> inline void chkmin(T &x, const T &y) { if (x > y) x = y; }\nint n, m, id[N], rnk[N], fa[N];\nlong long f[N], sum[N], a[N], b[N], c[N];\nstd::vector<int> G[N], T[N];\nint cmp(int x, int y) { return c[x] < c[y]; }\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nvoid dfs(int x)\n{\n\tsum[x] = b[x], f[x] = INF;\n\tif (T[x].empty()) return (void) (f[x] = b[x] + c[x]);\n\tfor (auto i : T[x]) dfs(i), sum[x] += sum[i];\n\tfor (auto i : T[x]) chkmin(f[x], sum[x] - sum[i] + std::max(c[x], f[i]));\n}\n\nint main()\n{\n\tn = read(), m = read();\n\tfor (int i = 1; i <= n; i++) fa[i] = id[i] = i;\n\tfor (int i = 1; i <= n; i++)\n\t\ta[i] = read(), b[i] = read(), c[i] = std::max(a[i] - b[i], 0ll);\n\tfor (int i = 1, x, y; i <= m; i++)\n\t\tx = read(), y = read(), G[x].push_back(y), G[y].push_back(x);\n\tstd::sort(id + 1, id + n + 1, cmp);\n\tfor (int i = 1; i <= n; i++) rnk[id[i]] = i;\n\tfor (int i = 1, t; i <= n; i++) for (auto j : G[id[i]])\n\t\tif ((t = find(j)) != id[i] && rnk[j] < i)\n\t\t\tfa[t] = id[i], T[id[i]].push_back(t);\n\tdfs(id[n]); printf(\"%lld\\n\", f[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+500;\ntypedef long long ll;\n\nint gti(void)\n{\n    char c=getchar();\n    int ret=0,st=1;\n    for (;!isdigit(c);c=getchar()) if (c=='-') st=-1;\n    for (;isdigit(c);c=getchar()) ret=ret*10+c-'0';\n    return ret*st;\n}\n\nstruct edge{edge *nxt;int to;}pool[N<<1],*pt[N],*ep=pool;\nvoid add(int a,int b)\n{\n    *(++ep)=(edge){pt[a],b},pt[a]=ep;\n    *(++ep)=(edge){pt[b],a},pt[b]=ep;\n}\n\nstruct P\n{\n    int a,b,id;\n    bool operator<(const P &y)const\n    {\n        return a<y.a||(a==y.a&&id<y.id);\n    }\n}p[N],q[N];\n\nint fa[N],vis[N];\nint getfa(int v)\n{\n    if (fa[v]==v) return v;\n    return fa[v]=getfa(fa[v]);\n}\n\nll f[N],g[N];\nint main(void)\n{\n    int n=gti(),m=gti();\n    for (int i=1;i<=n;i++)\n    {\n        p[i].a=gti(),p[i].b=gti(),p[i].id=i;\n        p[i].a=max(0,p[i].a-p[i].b),q[i]=p[i];\n    }\n    for (int i=1;i<=m;i++)\n    {\n        int u=gti(),v=gti();\n        add(u,v);\n    }\n    sort(p+1,p+1+n);\n    for (int i=1;i<=n;i++)\n    {\n        int v=p[i].id;\n        g[v]=q[v].b,f[v]=1e18,fa[v]=v;\n        for (edge *e=pt[v];e;e=e->nxt)\n            if (q[e->to]<q[v]&&vis[getfa(e->to)]<i)\n                g[v]+=g[fa[e->to]],vis[fa[e->to]]=i;\n        for (edge *e=pt[v];e;e=e->nxt)\n            if (q[e->to]<q[v])\n            {\n                f[v]=min(f[v],g[v]-g[fa[e->to]]+max(f[fa[e->to]],1ll*q[v].a));\n                fa[fa[e->to]]=v;\n            }\n        if (f[v]==1e18) f[v]=q[v].a+q[v].b;\n    }\n    printf(\"%lld\\n\",f[p[n].id]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 18], B[1 << 18], U[1 << 18], V[1 << 18];\nlong long Subtree[1 << 18];\nvector<tuple<long long, int, int, int>> L;\nvector<int> Y[1 << 18];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\t//if (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nlong long solve_Donation() {\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(t);\n\t\t\t}\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 530);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\treturn minx;\n}\n\nint main() {\n\tlong long cn, cm; cin >> cn >> cm;\n\tvector<pair<long long, long long>> v1(cn, make_pair(0, 0)); for (int i = 0; i < cn; i++) cin >> v1[i].first >> v1[i].second;\n\tvector<pair<long long, long long>> v2(cm, make_pair(0, 0)); for (int i = 0; i < cm; i++) { cin >> v2[i].first >> v2[i].second; v2[i].first--; v2[i].second--; }\n\n\tN = 2 * cn;\n\tfor (int i = 0; i < cn; i++) {\n\t\tA[i * 2] = v1[i].first;\n\t\tB[i * 2 + 1] = v1[i].second;\n\t}\n\tM = cn + cm;\n\tfor (int i = 0; i < cm; i++) {\n\t\tU[i] = v2[i].first * 2 + 1;\n\t\tV[i] = v2[i].second * 2;\n\t}\n\tfor (int i = 0; i < cn; i++) {\n\t\tU[cm + i] = i * 2;\n\t\tV[cm + i] = i * 2 + 1;\n\t}\n\n\tlong long ret = solve_Donation();\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long v,nxt;\n};\nnode edge[200001];\nstruct reads\n{\n\tlong long num,data;\n\tbool operator < (const reads &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nreads t[100001];\nlong long n,m,a[100001],b[100001],head[100001],len,rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].nxt=head[x];\n\thead[x]=len;\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tt[i].num=i;\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t\tt[i].data=Mx[i];\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(t+1,t+n+1);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=head[t[i].num];j>0;j=edge[j].nxt)\n\t\t\tif (a[t[i].num]>=a[edge[j].v]&&find(edge[j].v)!=find(t[i].num))\n\t\t\t\tunionn(edge[j].v,t[i].num);\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n \nusing namespace std;\n \nconst int N=100005;\nconst int P=998244353;\nconst long long INFll=0x3f3f3f3f3f3f3f3fll;\n \nint n,m;\nint a[N],b[N],c[N],id[N];\nint top=-1;\nint p[N],fa[N];\nlong long f[N],size[N];\n \nvector<int> son[N];\n \nstruct edge{\n\tint u,v;\n\tinline edge(){}\n\tinline edge(int _u,int _v){\n\t\tu=_u;\n\t\tv=_v;\n\t\tif(c[u]<c[v]) swap(u,v);\n\t}\n\tinline bool operator<(const edge &w)const{\n\t\tif(c[u]==c[w.u]) return c[v]>c[w.v];\n\t\treturn c[u]<c[w.u];\n\t}\n}d[N];\n \nint find(int x){\n\tif(p[x]==0) return x;\n\treturn p[x]=find(p[x]);\n}\n \ninline void onion(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x==y) return ;\n\tp[y]=x;\n\tfa[y]=x;\n}\n \ninline bool cmp(int x,int y){\n\treturn c[x]<c[y];\n}\n \n#define min(x,y) ((x<y)?x:y)\n#define max(x,y) ((x>y)?x:y)\n \nvoid init(){\n\tint x1,x2;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]),c[i]=max(a[i]-b[i],0),id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++) c[id[i]]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x1,&x2);\n\t\td[i]=edge(x1,x2);\n\t}\n\t//printf(\"id : \");\tfor(int i=1;i<=n;i++) printf(\"%d \",id[i]); printf(\"\\n\");\n\tsort(d+1,d+m+1);\n\tfor(int i=1,j=0;i<=n;i++){\n\t\t//int u=id[i];\n\t\twhile(c[d[j+1].u]==i && j<=m){\n\t\t\tj++;\n\t\t\tonion(d[j].u,d[j].v);\n\t\t\t//printf(\"edge: %d %d\\n\",d[j].u,d[j].v);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) c[i]=max(a[i]-b[i],0);\n\tfor(int i=1;i<=n;i++) son[fa[i]].push_back(i);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=id[i],len=son[u].size();\n\t\tif(len==0) f[u]=c[u]+b[u],size[u]=b[u];\n\t\telse{\n\t\t\tf[u]=INFll;\n\t\t\tsize[u]=b[u];\n\t\t\tfor(int j=0;j<len;j++) size[u]+=size[son[u][j]];\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tint v=son[u][j];\n\t\t\t\tf[u]=min(f[u],size[u]-size[v]+max(c[u],f[v]));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tprintf(\"a : \");\t\tfor(int i=1;i<=n;i++) printf(\"%d \",a[i]); printf(\"\\n\");\n\tprintf(\"b : \");\t\tfor(int i=1;i<=n;i++) printf(\"%d \",b[i]); printf(\"\\n\");\n\tprintf(\"id : \");\tfor(int i=1;i<=n;i++) printf(\"%d \",id[i]); printf(\"\\n\");\n\tprintf(\"fa : \");\tfor(int i=1;i<=n;i++) printf(\"%d \",fa[i]); printf(\"\\n\");\n\tprintf(\"size : \");\tfor(int i=1;i<=n;i++) printf(\"%lld \",size[i]); printf(\"\\n\");\n\tprintf(\"f : \");\t\tfor(int i=1;i<=n;i++) printf(\"%lld \",f[i]); printf(\"\\n\");\n\t*/\n\tprintf(\"%lld\\n\",f[id[n]]);\n}\n \nint main(){\n\tinit();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\nusing namespace std;\n#define pii pair <int , int>\n#define F first\n#define S second\nconst int N = 1e5 + 5, inf = 1e9 + 1;\nint A[N], B[N], par[N], C, n, m;\nlong long W[N], Sum;\nvector <int> g[N];\npriority_queue <pii, vector<pii>, greater<pii>> pq[N];\n\nvoid init() {\n    C = n;\n    for (int v = 1; v <= n; v++) {\n        par[v] = v, W[v] = B[v];\n        while (!pq[v].empty()) pq[v].pop();\n        for (int u : g[v]) pq[v].push({A[u] - B[u], u});\n    }\n}\nint getpar(int v) {return par[v] = (par[v] == v ? v : getpar(par[v]));}\nvoid Union(int u, int v) {\n    u = getpar(u);\n    if (u == v) return ;\n    par[u] = v, W[v] += W[u], C--;\n    if (pq[u].size() > pq[v].size()) swap(pq[u], pq[v]);\n    while (!pq[u].empty()) pq[v].push(pq[u].top()), pq[u].pop();\n}\nbool check(int w) {\n    init();\n    for (int v = 1; v <= n; v++) if (par[v] == v && w + W[v] >= A[v]) {\n        while (!pq[v].empty()) {\n            int u = pq[v].top().S;\n            if (A[u] - B[u] > W[v] + w) break ;\n            pq[v].pop(), Union(u, v);\n        }\n    }\n    return C == 1;\n}\nint32_t main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> A[i] >> B[i], Sum += B[i];\n    if (n == 1) return cout << max(A[1], B[1]) << \"\\n\", 0;\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    int dw = -1, up = inf;\n    while (up - dw > 1) {\n        int md = (up+dw)>>1;\n        if (check(md)) up = md;\n        else dw = md;\n    }\n    cout << Sum + up << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,par[100005],fa[100005];\nlong long a[100005],b[100005],c[100005],s[100005],ans[100005];\nvector<int>E[100005],E1[100005];\nbool vis[100005];\nbool cmp(int x,int y){\n\treturn c[x]<c[y];\n}\nint find(int x){\n\tif(x!=fa[x])fa[x]=find(fa[x]);\n\treturn fa[x];\n}\nvoid dfs(int u){\n\ts[u]=b[u];ans[u]=1e18;\n\tfor(int i=0;i<E1[u].size();i++){\n\t\tint v=E1[u][i];\n\t\tdfs(v);\n\t\ts[u]+=s[v];\n\t}\n\tfor(int i=0;i<E1[u].size();i++){\n\t\tint v=E1[u][i];\n\t\tans[u]=min(ans[u],s[u]-s[v]+max(c[u],ans[v]));\n\t} \n\tif(ans[u]==1e18)ans[u]=b[u]+c[u];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tc[i]=max(0LL,a[i]-b[i]);\n\t\tpar[i]=fa[i]=i;\n\t}\n\tsort(par+1,par+n+1,cmp);\n\twhile(m--){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tE[u].push_back(v);\t\n\t\tE[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint u=par[i];\n\t\tfor(int j=0;j<E[u].size();j++){\n\t\t\tint v=E[u][j];\n\t\t\tif(vis[v]&&find(v)!=u){\n\t\t\t\tE1[u].push_back(find(v));\n\t\t\t\tfa[find(v)]=u;\n\t\t\t}\n\t\t}\n\t\tvis[u]=1;\n\t}\n\tdfs(par[n]);\n\tprintf(\"%lld\\n\",ans[par[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\ntypedef pair<int, char> ICpair;\n\nint N, M;\n\nconst int MAXN = 200000;\n\nvector<int> G[MAXN];\nvector<LL> A, B;\n\nbool done[MAXN];\n\nconst int UNION_FIND_N = MAXN;\nint parent[UNION_FIND_N];\n\nLL has[MAXN];\n\n// assumes that if vertex v does not have parent,\n// i.e. if v is root, then parent[v] = v\nint root(int v) {\n\tif (parent[v] == v)\n\t\treturn v;\n\treturn parent[v] = root(parent[v]);\n}\n\nvoid merge(int u, int v) {\n\tparent[root(v)] = root(u);\n}\n\nvoid init_union_find() {\n\tfor (int i = 0; i < UNION_FIND_N; i++)\n\t\tparent[i] = i;\n}\n\npriority_queue<pair<LL, pair<int, int> > > heap;\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> N >> M;\n\tFOR (i, N)\n\t\tG[i].clear();\n\tA.clear();\n\tB.clear();\n\tint x, y;\n\tFOR (i, N) {\n\t\tcin >> x >> y;\n\t\tA.pb(x);\n\t\tB.pb(y);\n\t}\n\t\n\tvector<pair<LL, pair<int, int> > > edges;\n\tedges.clear();\n\tFOR (i, M) {\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tsort(all(edges));\n\t\n\tLL s = 0LL, e = 10000000000000000LL, mid;\n\t\n\tLL ret = -1LL;\n\twhile (s <= e) {\n\t\tmid = (s + e) >> 1;\n\t\tSET(done, 0);\n\t\twhile (!heap.empty())\n\t\t\theap.pop();\n\t\tFOR (i, N) {\n\t\t\tLL val = max(0LL, A[i] - B[i]);\n\t\t\thas[i] = mid + B[i];\n\t\t\tif (mid >= val) {\n\t\t\t\tdone[i] = true;\n\t\t\t\tFOR (j, G[i].sz) {\n\t\t\t\t\tint x = i, y = G[i][j];\n\t\t\t\t\tLL valy = max(0LL, A[y] - B[y]);\n\t\t\t\t\theap.push(make_pair(-valy, make_pair(x, y)));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tinit_union_find();\n\t\twhile (!heap.empty()) {\n\t\t\tpair<LL, pair<int, int> > edge = heap.top();\n\t\t\theap.pop();\n\t\t\tint x = edge.second.first;\n\t\t\tint y = edge.second.second;\n\t\t\tif (root(x) == root(y))\n\t\t\t\tcontinue;\n\t\t\tif (has[root(x)] >= -edge.first) {\n\t\t\t\tLL tmp = has[root(x)] + has[root(y)] - mid;\n\t\t\t\tmerge(x, y);\n\t\t\t\thas[root(x)] = tmp;\n\t\t\t\tif (!done[y]) {\n\t\t\t\t\tdone[y] = true;\n\t\t\t\t\tFOR (j, G[y].sz) {\n\t\t\t\t\t\tint z = G[y][j];\n\t\t\t\t\t\tLL valz = max(0LL, A[z] - B[z]);\n\t\t\t\t\t\theap.push(make_pair(-valz, make_pair(y, z)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool allDone = true;\n\t\tFOR (i, N)\n\t\t\tallDone &= done[i];\n\t\tif (!allDone) {\n\t\t\ts = mid + 1;\n\t\t}\n\t\telse {\n\t\t\te = mid - 1;\n\t\t\tif (ret < 0LL || has[root(0)] < ret)\n\t\t\t\tret = has[root(0)];\n\t\t}\n\t}\n\t\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int maxn=100010;\n\nint n,m,a[maxn],b[maxn],w[maxn],id[maxn],fa[maxn],x[maxn],y[maxn];\nint tot,nex[maxn*5],las[maxn*5],tov[maxn*5];\nlong long f[maxn],siz[maxn];\nbool bz[maxn];\n\nint getfather(int x)\n{\n\tif (fa[x]==x) return x;\n\tfa[x]=getfather(fa[x]);\n\treturn fa[x];\n}\n\nlong long max(long long a,long long b)\n{\n\tif (a>b) return a;\n\treturn b;\n}\n\nvoid insert(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=w[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (w[i]>m) i++;\n\t\twhile (w[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(w[i],w[j]);\n\t\t\tswap(a[i],a[j]);\n\t\t\tswap(b[i],b[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tsiz[i]=b[i];\n\t\tw[i]=max(a[i]-b[i],0);\n\t\tx[i]=w[i];\n\t\tf[i]=w[i];\n\t\tid[i]=i;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ty[id[i]]=b[i];\n\t\tfa[i]=i;\n\t}\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint xx,yy;\n\t\tscanf(\"%d%d\",&xx,&yy);\n\t\tinsert(xx,yy);\n\t\tinsert(yy,xx);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint s=id[i];\n\t\tbz[s]=true;\n\t\tfor (int j=las[s];j;j=nex[j])\n\t\t{\n\t\t\tif (!bz[tov[j]])\n\t\t\t{\n\t\t\t\tint xx=getfather(s);\n\t\t\t\tint yy=getfather(tov[j]);\n\t\t\t\tif (xx!=yy)\n\t\t\t\t{\n\t\t\t\t\tfa[yy]=xx;\n\t\t\t\t\tsiz[xx]=siz[xx]+siz[yy];\n\t\t\t\t\tf[xx]=min(f[xx],max(f[yy],x[xx]-siz[yy]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[getfather(1)]+siz[getfather(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    vector <pii> ras;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n        ras.pb({a[i]-b[i],i});\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    sort(ras.begin(),ras.end());\n    ll vv=ras[0].S;\n   // cout << vv << endl;\n    vv=7;\n    ll l=max((ll)-1,a[vv]-b[vv]-1),r=(ll)1e15;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        //cout << mid << endl;\n        for (int i=1;i<=n;i++){\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        swap(cp[0], cp[i]);\n        ll cost_in = max(a[v], cp[0].first + b[v]);\n        for (int i = 1; i < cp.size(); i++)\n        {\n            cost_in = max(cost_in + cp[i].second, cp[i].first);\n        }\n        min_cost_in = min(min_cost_in, cost_in);\n        swap(cp[0], cp[i]);\n        //next_permutation(all(cp));\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 100100\nusing namespace std;\ntypedef long long ll;\n\nstruct edge {\n    int u, v, w;\n    edge() { }\n    edge(int a, int b, int c) : u(a), v(b), w(c) { }\n    bool operator<(const edge &b) { return w < b.w;}\n};\n\nint n, m, b[N], c[N], fa[N];\nll sum[N], f[N];\nedge e[N];\nvector<int> G[N];\n\nint find(int x) {\n    return fa[x] == x ? x : fa[x] = find(fa[x]);\n}\n\nvoid dfs(int u, int p = 0) {\n    sum[u] = b[u];\n    for (int v : G[u])\n        if (v != p) dfs(v, u), sum[u] += sum[v];\n}\n\nll dfs2(int u, int p = 0) {\n    ll res = max(1ll * c[u], f[u] = max(f[p], c[p] - sum[u]));\n    for (int v : G[u])\n        if (v != p) res = min(res, dfs2(v, u));\n    return res;\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%d%d\", c + i, b + i);\n        c[i] = max(c[i] - b[i], 0);\n    }\n\n    for (int i = 1, u, v; i <= m; ++i) {\n        scanf(\"%d%d\", &u, &v);\n        if (c[u] < c[v]) swap(u, v);\n        e[i] = edge(u, v, c[u]);\n    }\n\n    sort(e + 1, e + m + 1);\n\n    for (int i = 1; i <= n; ++i)\n        fa[i] = i;\n\n    int rt = 1;\n    for (int i = 1; i <= m; ++i) {\n        int u = find(e[i].u), v = find(e[i].v);\n        if (u != v) fa[v] = rt = u, G[u].push_back(v);\n    }\n\n    dfs(rt);\n\n    cout << dfs2(rt) + sum[rt] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, m, a[MAXN], b[MAXN], sec[MAXN];\nvector<int> adj[MAXN];\nint par[MAXN];\nll ans[MAXN], sumB[MAXN];\npair<ll, ll> gec[MAXN];\n\nbool cmp(int u, int v){return a[u]-b[v] < a[v]-b[v];}\n\nint getPar(int v){return par[v]==v? v: par[v]=getPar(par[v]);}\n\nbool mark[MAXN];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> a[i] >> b[i], a[i] = max(a[i], b[i]);\n\twhile (m--){\n\t\tint u, v; cin >> u >> v, u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tiota(sec, sec + n, 0);\n\tsort(sec, sec + n, cmp);\n\n\tiota(par, par + n, 0);\n\tfor (int i = 0; i < n; i++){\n\t\tint v = sec[i];\n\t\tmark[v] = true;\n\t\tsumB[v] = b[v];\n\n\t\tint tt = 0;\n\t\tfor (int u:adj[v]){\n\t\t\tif (!mark[u]) continue;\n\t\t\tint pu = getPar(u);\n\t\t\tif (pu == v) continue;\n\n\t\t\tgec[tt++] = {ans[pu], sumB[pu]};\n\t\t\tpar[pu] = v;\n\t\t\tsumB[v] += sumB[pu];\n\t\t}\n\n\t\tans[v] = sumB[v] + (a[v] - b[v]);\n\t\tfor (int j = 0; j < tt; j++){\n\t\t\tauto x = gec[j];\n\t\t\tans[v] = min(ans[v], max((ll)a[v], x.F+b[v]) + (sumB[v] - b[v] - x.S));\n\t\t}\n\t}\n\n\tcout << ans[sec[n-1]] << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nstruct Edge\n{\n\tint to;\n\tint nxt;\n}e[200005];\nint p[100005],n,m,edgenum,head[100005],tmp[100005],top,out[100005],top2;\nll a[100005],b[100005];\nbool flag[100005],used[100005];\nqueue<int>q;\nvoid add(int u,int v)\n{\n\te[++edgenum].to=v;\n\te[edgenum].nxt=head[u];\n\thead[u]=edgenum;\n}\nbool cmp(int x,int y)\n{\n\treturn a[x]<a[y];\n}\nbool bfs(int st,ll v)\n{\n\twhile(!q.empty()) q.pop();\n\tq.push(st);\n\tflag[st]=used[st]=1;\n\tv+=b[st];\n\ttop=0;\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\ttmp[++top]=node;\n\t\ttop2=0;\n\t\tfor(int hd=head[node];hd;hd=e[hd].nxt)out[++top2]=e[hd].to;\n\t\tsort(out+1,out+top2+1,cmp);\n\t\tfor(int i=1;i<=top2;i++)\n\t\t{\n\t\t\tint to=out[i];\n\t\t\tif(flag[to])continue;\n\t\t\tif(a[to]>v)continue;\n\t\t\tflag[to]=used[to]=1;\n\t\t\tv+=b[to];\n\t\t\tq.push(to);\n\t\t}\n\t}\n\tfor(int i=1;i<=top;i++)flag[tmp[i]]=0;\n\treturn top==n;\n}\nbool check(ll v)\n{\n\tfor(int i=1;i<=n;i++)p[i]=i;\n\trandom_shuffle(p+1,p+n+1);\n\tmemset(used,0,sizeof(used));\n\tmemset(flag,0,sizeof(flag));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(used[p[i]])continue;\n\t\tif(a[i]>v)continue;\n\t\tif(bfs(p[i],v))return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]-=b[i];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tll l=0,r=1e15;\n\twhile(l<=r)\n\t{\n\t\tll mid=(l+r)>>1;\n\t\tif(check(mid))r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tfor(int i=1;i<=n;i++)l+=b[i];\n\tprintf(\"%lld\\n\",l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, M;\nint A[100000], B[100000];\nvector<int> G[100000];\nint U[100000], R[100000];\nint repr[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\nvector<int> G2[100000];\nbool used[100000];\nlong long dp[100000], sum[100000];\n\nvoid dfs(int x) {\n  if (G2[x].empty()) dp[x] = B[x];\n  sum[x] = B[x];\n  for (int t : G2[x]) {\n    dfs(t);\n    sum[x] += sum[t];\n  }\n  //dp[x] = max(dp[x], sum[x]);\n  for (int t : G2[x]) {\n    dp[x] = min(dp[x], max(dp[t] + (sum[x]-sum[t]), max(A[x]+sum[x]-B[x]-sum[t], A[t]+sum[x]-sum[t]-B[x])));\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, N) cin >> A[i] >> B[i];\n  rep(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) U[i] = i, R[i] = 1, repr[i] = i;\n  vector<P> ord;\n  rep(i, N) ord.pb(P(A[i], i));\n  sort(all(ord));\n  for (P p : ord) {\n    int x = p._2;\n    used[x] = true;\n    for (int t : G[x]) if (used[t] && !same(x, t)) {\n      assert(repr[find(x)] == x);\n      int c = repr[find(t)];\n      unite(x, t);\n      repr[find(x)] = x;\n      G2[x].pb(c);\n      //cout<<x<<\"->\"<<c<<\"\\n\";\n    }\n  }\n  rep(i, N) dp[i] = INF;\n  int root = ord.back()._2;\n  assert(root == repr[find(0)]);\n  dfs(root);\n  long long m = dp[root];\n  rep(i, N) m = max(m, A[i]);\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nint n,m,a[N],b[N],head[N],adj[N*2],nxt[N*2],c[N],p[N],l,Head[N],Adj[N*2],Nxt[N*2],id[N],i,j,k,fa[N];\nll sum[N],f[N];\nint find(int x)\n{\n\treturn !fa[x]?x:fa[x]=find(fa[x]);\n}\nbool cmp(int a,int b)\n{\n\treturn c[a]<c[b];\n}\nvoid Addedge(int u,int v)\n{\n\tAdj[++l]=v;\n\tNxt[l]=Head[u];\n\tHead[u]=l;\n}\nvoid dfs(int x)\n{\n\tint j;\n\tsum[x]=b[x];\n\tfor(j=Head[x];j;j=Nxt[j])\n\t{\n\t\tdfs(Adj[j]);\n\t\tsum[x]+=sum[Adj[j]];\n\t}\n\tf[x]=sum[x]+c[x];\n\tfor(j=Head[x];j;j=Nxt[j])\n\t\tf[x]=min(f[x],sum[x]-sum[Adj[j]]+max(1ll*c[x],f[Adj[j]]));\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tc[i]=max(0,a[i]-b[i]);\n\t}\n\tfor(i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d%d\",&j,&k);\n\t\tadj[i*2-1]=k;\n\t\tnxt[i*2-1]=head[j];\n\t\thead[j]=i*2-1;\n\t\tadj[i*2]=j;\n\t\tnxt[i*2]=head[k];\n\t\thead[k]=i*2;\n\t}\n\tfor(i=1;i<=n;++i)\n\t\tp[i]=i;\n\tsort(p+1,p+1+n,cmp);\n\tfor(i=1;i<=n;++i)\n\t\tid[p[i]]=i;\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=head[p[i]];j;j=nxt[j])\n\t\t\tif(id[adj[j]]<i&&find(adj[j])!=find(p[i]))\n\t\t\t{\n\t\t\t\tAddedge(p[i],find(adj[j]));\n\t\t\t\tfa[find(adj[j])]=p[i];\n\t\t\t}\n\tdfs(p[n]);\n\tprintf(\"%lld\",f[p[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M;\ni64 A[101010], B[101010];\nvector<int> graph[101010];\n\nint uf[101010];\nbool vis[101010];\n\nvector<int> child[101010];\nbool is_root[101010];\n\nint root(int p)\n{\n\treturn uf[p] < 0 ? p : (uf[p] = root(uf[p]));\n}\nvoid join(int p, int q)\n{\n\tp = root(p);\n\tq = root(q);\n\tif (p == q) return;\n\tuf[p] += uf[q];\n\tuf[q] = p;\n\tchild[p].push_back(q);\n\tis_root[q] = false;\n\t//printf(\"%d -> %d\\n\", p, q);\n}\n\n// { ans, sum }\npair<i64, i64> solve(int p)\n{\n\ti64 ret = 0, sum = 0;\n\n\tvector<pair<i64, i64>> tmp;\n\tfor (int q : child[p]) {\n\t\ttmp.push_back(solve(q));\n\t}\n\tfor (auto t : tmp) sum += t.second;\n\n\tret = 1LL << 62LL;\n\tfor (auto t : tmp) {\n\t\tret = min(ret, sum - t.second + max(t.first + B[p], A[p]));\n\t}\n\tret = min(ret, max(A[p], B[p]) + sum);\n\tif (sum == 0) ret = max(A[p], B[p]);\n\n\treturn { ret, sum + B[p] };\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < N; ++i) scanf(\"%lld%lld\", A + i, B + i);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\t--x; --y;\n\t\tgraph[x].push_back(y);\n\t\tgraph[y].push_back(x);\n\t}\n\n\tvector<pair<i64, int>> nds;\n\tfor (int i = 0; i < N; ++i) {\n\t\tnds.push_back({A[i], i});\n\t\tis_root[i] = true;\n\t}\n\tsort(nds.begin(), nds.end());\n\n\tfor (int i = 0; i < N; ++i) uf[i] = -1;\n\n\tfor (int i = 0; i < nds.size(); ++i) {\n\t\tint p = nds[i].second;\n\t\tvis[p] = true;\n\n\t\tfor (int q : graph[p]) if (vis[q]) {\n\t\t\tjoin(p, q);\n\t\t}\n\t}\n\n\tint root = -1;\n\tfor (int i = 0; i < N; ++i) if (is_root[i]) root = i;\n\n\tif (root == -1) {\n\t\tputs(\"><\");\n\t\treturn 1;\n\t}\n\n\tauto ret = solve(root);\n\tprintf(\"%lld\\n\", ret.first);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\nusing namespace std;\n#define int long long\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define all(a) a.begin(),a.end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define mp make_pair\n#define endl '\\n'\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\nconst ll inf=1e9;\nconst ll mod=998244353;\nsigned main(){\n    ll n,k,q;cin>>n>>k>>q;\n    vector<ll>a(n);\n    vector<pll>p(n);\n    rep(i,n){\n        cin>>a[i];\n        p[i]=mp(a[i],i);\n    }\n    sort(all(p));\n    ll ans=p[q-1].first-p[0].first;\n    set<ll>st;\n    a.pb(0);\n    st.insert(n);\n    n++;\n    rep(i,n){\n        priority_queue<ll>pq;\n        priority_queue<ll>qq;\n        rep(j,n){\n            if(st.find(j)!=st.end()){\n                while(pq.size()>=k){\n                    ll d=pq.top();\n                    pq.pop();\n                    qq.push(d);\n                }\n                while(!pq.empty()){\n                    pq.pop();\n                }\n            }else{\n                pq.push(a[i]);\n            }\n        }\n        if(qq.size()>=q){\n            ll mi=qq.top();\n            qq.pop();\n            ll ma=qq.top();\n            rep(o,q-1){\n                ma=qq.top();\n                qq.pop();\n            }\n            ans=min(ans,ma-mi);\n        }\n        st.insert(p[i].second);\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint read()\n{\n\tchar ch=getchar();int f=0,x=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') x=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){f=(f<<1)+(f<<3)+ch-'0';ch=getchar();}\n\treturn f*x;\n}\nstruct data\n{\n\tint from;\n\tint to;\n\tint w;\n}q[100005];\nstruct node\n{\n\tint from;\n\tint to;\n\tint next;\n\tint w;\n}edge[200005];\nstruct segtree\n{\n    int ls;\n    int rs;\n    int maxx;\n    int mark;\n}tree[800005];\n\nbool cmp(const data &x,const data &y)\n{\n\treturn x.w<y.w;\n}\nint head[100005],n,m,p[100005];\nint a[100005],b[100005],c[100005],aa[100005];\nll f[100005];\nint dep[100005],size[100005],fa[100005],son[100005];\nint pos[100005],npos[100005],top[100005],tot,cnt;\nint rt=1,anc[100005][25];bool vis[100005];\nvoid add(int u,int v,int w)\n{\n\tedge[tot].from=u;\n\tedge[tot].to=v;\n\tedge[tot].next=head[u];\n\tedge[tot].w=w;\n\thead[u]=tot++;\n}\nint find(int x)\n{\n\treturn p[x]==x?x:p[x]=find(p[x]);\n}\nbool cmp2(const int &x,const int &y)\n{\n\tif(a[x]<a[y])\n\treturn a[x]<a[y];\n\telse return b[x]>b[y];\n}\nvoid dfs1(int x)\n{\n    size[x]=1;\n    dep[x]=dep[fa[x]]+1;\n    for(int i=head[x];i!=-1;i=edge[i].next)\n    {\n        if(fa[x]!=edge[i].to)\n        {\n        \taa[edge[i].to]=edge[i].w;\n            fa[edge[i].to]=x;\n            dfs1(edge[i].to);\n            size[x]+=size[edge[i].to];\n            if(size[edge[i].to]>size[son[x]])\n            son[x]=edge[i].to;\n        }\n    }\n}\nvoid dfs2(int x)\n{\n    pos[x]=++cnt;\n    npos[cnt]=x;\n    if(son[fa[x]]==x) top[x]=top[fa[x]];\n    else top[x]=x;\n    if(son[x]) dfs2(son[x]);\n    for(int i=head[x];i!=-1;i=edge[i].next)\n    {\n        if(fa[x]!=edge[i].to&&son[x]!=edge[i].to)\n        dfs2(edge[i].to);\n    }\n}\nint sum=1;\nvoid build(int p,int l,int r)\n{\n    if(l==r)\n    {\n    \ttree[p].maxx=aa[npos[l]];\n    \tcout<<tree[p].maxx<<\" \";\n        return;\n    }\n    int mid=l+r>>1;\n    tree[p].ls=++sum;\n    tree[p].rs=++sum;\n    build(tree[p].ls,l,mid);\n    build(tree[p].rs,mid+1,r);\n    tree[p].maxx=max(tree[tree[p].ls].maxx,tree[tree[p].rs].maxx);\n}\nint query(int p,int l,int r,int x,int y)\n{\n    int mid=l+r>>1;\n    if(l==x&&r==y)\n    {\n        return tree[p].maxx;\n    }\n    if(y<=mid)\n    return query(tree[p].ls,l,mid,x,y);\n    else if(x>mid)\n    return query(tree[p].rs,mid+1,r,x,y);\n    else return max(query(tree[p].ls,l,mid,x,mid),query(tree[p].rs,mid+1,r,mid+1,y));\n}\nint query(int x,int y)\n{\n    int fx=top[x],fy=top[y],maxx=0;\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);\n        maxx=max(maxx,query(1,1,n,pos[fx],pos[x]));\n        x=fa[fx],fx=top[x];\n    }\n    if(dep[x]<dep[y]) swap(x,y);\n    maxx=max(maxx,query(1,1,n,pos[y],pos[x]));\n    cout<<maxx<<\" \";\n    return maxx;\n}\nvoid dfs(int x)\n{\n    vis[x]=1;\n    for(int i=1;i<=20;i++)\n    {\n        if(dep[x]<=(1<<i))\n        break;\n        anc[x][i]=anc[anc[x][i-1]][i-1];\n    }\n    for(int i=head[x];i!=-1;i=edge[i].next)\n    {\n        if(!anc[edge[i].to][0]&&edge[i].to!=rt)\n        {\n            anc[edge[i].to][0]=x;\n            dfs(edge[i].to);\n        }\n    }\n}\nint lca(int x,int y)\n{\n    if(dep[x]<dep[y]) swap(x,y);\n    for(int i=20;i>=0;i--)\n    {\n        if(dep[y]<=dep[anc[x][i]])\n        x=anc[x][i];\n    }\n    if(x==y) return x;\n    for(int i=20;i>=0;i--)\n    {\n        if(anc[x][i]!=anc[y][i])\n        {\n            x=anc[x][i];\n            y=anc[y][i];\n        }\n    }\n    if(x==y) return x;\n    if(!anc[x][0]) return rt;\n    return anc[x][0];\n}\nint lca1(int x,int y)\n{\n    if(dep[x]<dep[y]) swap(x,y);\n    for(int i=20;i>=0;i--)\n    {\n        if(dep[y]<dep[anc[x][i]])\n        x=anc[x][i];\n    }\n    return x;\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read(),b[i]=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tq[i].from=read();q[i].to=read();\n\t\tq[i].w=max(a[q[i].from],a[q[i].to]);\n\t}\n\tsort(q+1,q+m+1,cmp);\n\tfor(int i=1;i<=n;i++) p[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint fx=find(q[i].from),fy=find(q[i].to);\n\t\tif(fx!=fy)\n\t\t{\n\t\t\tadd(q[i].from,q[i].to,q[i].w);\n\t\t\tadd(q[i].to,q[i].from,q[i].w);\n\t\t\tp[fx]=fy;\n\t\t\tcout<<q[i].from<<\" \"<<q[i].to<<endl;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++) c[i]=i;\n\tsort(c+1,c+n+1,cmp2);\n\tdep[1]=1;\n\tdfs1(1);\n\tdfs2(1);\n\tdfs(1);\n\tbuild(1,1,n);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tcout<<\"ok\";\n\t\tcout<<c[i]<<\" \"<<c[i-1]<<\" \"<<fa[c[i]]<<\" \";\n\t\tint lc=lca(c[i],c[i-1]);\n\t\tcout<<lc<<endl;\n\t\tif(lc!=c[i])\n\t\tf[c[i]]=max(f[c[i-1]]+b[c[i-1]],(ll)query(fa[c[i]],c[i-1]));\n\t\telse if(lc==c[i])\n\t\t{\n\t\t\tcout<<\"qwq\";\n\t\t\tcout<<c[i]<<\" \"<<c[i-1]<<lca1(c[i],c[i-1])<<endl;\n\t\t\tf[c[i]]=max(f[c[i-1]]+b[c[i-1]],(ll)query(lca1(c[i],c[i-1]),c[i-1]));\n\t\t}\n\t\tcout<<f[c[i]]<<endl;\n\t}\n\tcout<<f[c[n]]+b[c[n]];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親のインデックスを記憶する配列\n\tvector<int> sz; // サイズを記憶する。\n\tvector<int> rank;\n\t// 初期化\n\tUF(int n):par(n),sz(n),rank(n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;rank[i] = 0;\n\t\t}\n\t}\n\t// 親を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsz[y] += sz[x];\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tsz[x] += sz[y];\n\t\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\t// 素の集合のサイズを求める\n\tint size(int n){return sz[find(n)];}\n};\n\nll n,m;\nll a[111111];\nll b[111111];\nll c[111111];\nll dp[111111];\nvector<pair<ll,pair<ll,ll>>> edge;\nvector<vector<int>> v(111111);\n\nll dfs(ll node){\n\tif(dp[node] != -1)return dp[node];\n\tll ret = LLINF;\n\tll tmp_sum = b[node];\n\tvector<ll> seica(v[node].size());\n\tREP(i,v[node].size()){\n\t\tseica[i] = max(dfs(v[node][i]),c[node]);\n\t\ttmp_sum += b[v[node][i]];\n\t}\n\tREP(i,v[node].size()){\n\t\tret = min(ret,seica[i]+tmp_sum-b[v[node][i]]);\n\t}\n\t\n\tret = min(ret,c[node]+tmp_sum);\n\t\n\tb[node] = tmp_sum;\n\treturn dp[node] = ret;\n}\n\nint main(){\n\t\n\tREP(i,111111)dp[i] = -1;\n\t\n\tcin >> n >> m;\n\tll ma = -1;\n\tll node;\n\tREP(i,n){\n\t\tcin >> a[i] >> b[i];\n\t\tc[i] = max(0LL,a[i] - b[i]);\n\t\tif(ma < c[i]){ma = c[i],node = i;}\n\t}\n\tREP(i,m){\n\t\tint x,y;cin >> x >> y;\n\t\tx--;y--;\n\t\tedge.PB(MP(max(c[x],c[y]),MP(x,y)));\n\t}\n\t\n\tsort(ALL(edge));\n\t\n\tUF uf(n);\n\t\n\tREP(i,m){\n\t\tll A = edge[i].SE.FI;\n\t\tll B = edge[i].SE.SE;\n\t\tif(uf.same(A,B))continue;\n\t\tif(c[A] < c[B]){\n\t\t\tv[B].PB(uf.find(A));\n\t\t\tuf.par[uf.find(A)] = B;\n\t\t}\n\t\telse{\n\t\t\tv[A].PB(uf.find(B));\n\t\t\tuf.par[uf.find(B)] = A;\n\t\t}\n\t\tuf.unite(A,B);\n\t}\n\t\n\tcout << dfs(node) << endl;\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector < vector<int> >ed;\n\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> sum;\n\tvector<int> res;\n\tUnionFind(int size) {\n\t\tdata.resize(size, -1);\n\t\tsum.resize(size, 0);\n\t\tres.resize(size, 0);\n\t}\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tsum[x] += sum[y];\n\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<pair<int, int> >  vp;\n\tvector<int> A(N);\n\tvector<int> B(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tvp.emplace_back(A[i] - B[i], i);\n\t}\n\tint a, b;\n\ted.resize(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\ted[a].push_back(b);\n\t\ted[b].push_back(a);\n\t}\n\tsort(vp.begin(), vp.end());\n\tUnionFind uf(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tuf.sum[i] = B[i];\n\t}\n\tint t;\n\tres = 0;\n\tvector<int> rank(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\trank[vp[i].second] = i;\n\t}\n\tset<int> st;\n\tfor (int i = 0; i < N; i++) {\n\t\ta = vp[i].second;\n\t\tt = (int)1 << 60;\n\t\tint all = 0;\n\t\tst.clear();\n\t\tfor (int j = 0; j < ed[a].size(); j++) {\n\t\t\tif (rank[a] > rank[ed[a][j]]) {\n\t\t\t\tst.insert(uf.root(ed[a][j]));\n\t\t\t}\n\t\t}\n\t\tfor (auto j : st) {\n\t\t\tall += uf.sum[j];\n\t\t}\n\t\tfor (auto j : st) {\n\t\t\tint x = uf.res[j];\n\t\t\tx = max(A[a], x + B[a]) + all - uf.sum[j];\n\t\t\tt = min(t, x);\n\t\t}\n\t\tif (t == ((int)1 << 60)) {\n\t\t\tt = max(A[a], B[a]);\n\t\t}\n\t\tfor (int j = 0; j < ed[a].size(); j++) {\n\t\t\tif (rank[a] > rank[ed[a][j]]) {\n\t\t\t\tuf.unionSet(ed[a][j], a);\n\t\t\t}\n\t\t}\n\t\tcerr << a << \" \" << t << endl;\n\t\tuf.res[uf.root(a)] = t;\n\t}\n\tcerr << uf.sum[uf.root(0)] << endl;\n\tres = uf.res[uf.root(0)];\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        if (aa.first - aa.second == bb.first - bb.second)\n            return abs(aa.first - a[v]) < abs(bb.first - a[v]);\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+9;\nint n,m,a[N],b[N],_[N],u,v,fa[N],t,d[N];\nvector<int>e[N];\nll f[N],sz[N];\nbool p[N];\nll min(ll x,ll y) {return x<y?x:y;}\nll max(ll x,ll y) {return x>y?x:y;}\nbool cmp(int x,int y) {return a[x]<a[y];}\nint gef(int x) {return fa[x]?fa[x]=gef(fa[x]):x;}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d%d\",a+i,b+i), a[_[i]=i]=max(a[i]-b[i],0), sz[i]=b[i];\n\tfo(i,1,m) scanf(\"%d%d\",&u,&v), e[u].push_back(v), e[v].push_back(u);\n\tsort(_+1,_+n+1,cmp);\n\tfo(i,1,n)\n\t{\n\t\tint x=_[i]; p[x]=1,t=0;\n\t\tfor(int y:e[x]) if(p[y]&&gef(x)!=gef(y)) {fa[v=gef(y)]=x; sz[x]+=sz[d[++t]=v];}\n\t\tf[x]=sz[x]+a[x];\n\t\tfor(int y;y=d[t];t--) f[x]=min(f[x],sz[x]-sz[y]+max(a[x],f[y]));\n\t}\n\tprintf(\"%lld\",f[gef(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "/*&@@@@@@@@&&&&&&&&&&&@@@@@@@@&%$$!'''..                                   .!&&&&&&&$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%|\n@@@@@@@@@@@@@@@@&&&&&@@@@&&&&&%%|:`.                                          `|$$$$$$$%%%%%%%%%%||||||||||||||||||||||\n@@@@@@@@@@@@@@@@@@&@@@&&$&&$!;:.                                                .;%%%%%%%%||||||||||!!!!|||||||||||||||\n@@@@@@@@@@@@@@@@@@@&&&$%$&$%;.                                                    .:|||||||||!!!!!!!!!!!!!!!|||||||||||\n@@@@@@@@@@@@@@&&&&&$$$$$$|'                                                          '||||||!!!!!!!!!!!!!!!!!!|||||||||\n@@@@@@@@&&&&&&&&&&&$%|%!`        ....                                                 .'||||!!!!!!!!!!!!!!!!!!|||||||||\n&&&&&&&&&&&&&$$$$$$$%!'         ...                                                     .;|||!!!!!!!!!!!!!!!!!!!|||||||\n&&&&&&$$$$$$$$$$$$%|:.         ...                                                      ..'!|||||||||||||||||||||||||||\n$$$$$$$$$$$$%%%%%|;`          ....            ......                                     ..`;||||||||||||||||||||||||||\n%%%%%%%%%%%%%%%|!:..         ..`..    ..........   .                               ....     `;|||||||||||||||||||||||||\n%%||%||%|%%%%||!:`.          .``..        ..........                          .        ....  `;||||||||||||||||||||||||\n||||||||||||%|!;'.          ..``...      .....  ........                      ......    ..... .:|||||||||||||||||||||||\n|||||||||||||!;:`        ....```..    ..............                          .  ...............:||||||||||||||||||||||\n||||||||||%||!:'.      .   ..`'`.......................  .    .....              ......... ......:|%|||||||||||||||||||\n|||||||||%||!;'.          ..````..........................               ....       ..............:|%%%||||||||||||||||\n||||||||%||!;:`. ..      ...`'''``...............................                       ........  `;%||||||||||||||||||\n||||||%%%||!;:..... .......``''''```..........................................  `:;;;'.   ........ `;%|||||||||||||||||\n|||||||||%|!:`.............`''''''''`````````````.................................````...  ........ `;|||||||||||||||||\n||||||||||!:`............``'::::::::'''``'''``````````.............    ........`....```...   ........'!||||||||||||||||\n||||||||||;`............``':;;;;!;;;::::'''::'''``....................     ...`'````````....   .......:||||||||||||||||\n|||||||||;`....     ...``':;;!!!!!!!!;;;:::::::::''`````.....................':::'``````'``..   ..  ...:|||||||||||||||\n|||||||!'..         ..``':;;!!!!!!!!!!!;;;;;;;:::::'''```````````....```````'::::''''''''''``..   .  ...:||||||||||||||\n|||||!:'`.          .`'':;;!!!!!!||!!!!!!!!!;;;;;;::::::'''''''''''''''`''''''':::'''''''::`....       ..:|||||||||||||\n|||!;;'..          .`''::;;!!!!!|||||||!!!!!!!!!!!!;;;;;;;;;;;;;;;;;;;;;;;:::;:::::'''';;;:'.   .    .   .:||||||||||||\n||;!;:'`            `'::;;;!!!!!||||||||!!!!!!!!!!!!!!!!!!!!!!!!!||||||!;;;::::;;;::'':;:::'.             .:||||||||||!\n|!!!:'`.            .'::;;;!!!!!!|||||||||!!!!!!!!|!!!!!!!!!!!|||||%%%%||!;;;::::::::::::;:`..             .:|||||||||!\n!!!;''`.            .'::;;;!!!!!!!!||||!!!!||||!!!!!!;;;!!!!!!||||%%%|||||!!;;:;;;;:'':::'.                  :||||||||!\n!|!:''`.             `'::;;;!!!!!!!!!!!!!!!!!!!;::'':;;!!!!!!!|||||||||||||!!;;;;;;;:::''`.                   '!||||||!\n!!!:''`.             .`':;;;!!!!!!!!!!!!!!;:''''':;;;;;;;;!!!!||||||||||||!!!;;;;;;;:::''`..                   `;|!!!|!\n!!!:'`.               .'::;;;;!!!!!!!!;:''``':;;;;;;;;;;;;;!!|||||||||||||!!!!!;;;;;;:::''`..                   .:|||!!\n||!:'`..               `'::;;;;;;!;;;;:''':;;;;;;;;;::'`';!!||||||||||||||!!!!!!!!!;;;:::'`..                     '!|||\n|!!:'`..                `:::::;;;;;;;;;;::;;;::::::''``';!!|||||||||||||||!!!!!!!!!!;;;;::'`.                      `;||\n||!;'.                   ....``'::;;;!!;;;;;::'''`...`:;!!!|||||||||||||||!!!!!!!!!!!;;;;::'`..                 .   .'!\n%||;'..  ..               .`''::::::;!!!!!!;;;::''`::;;!!!||||||||||||||||||||||||!!!!!;;;;::'`.                      '\n|%|!:`.                     `'':::'::;!||||!!!!!!;;;;!!!!!||||||||||||||||||||||||||!!!!!;;;;;:'`.                    .\n||%|;`                        `````..`;|||||||||||!!!!!!!!|||||||||||||||||||||%||||||!!!!!!!!;::'`..                 .\n%|%%|'.  ..                    .....`':!||||||||||||!!||||||||||!!!|||||||%%%%%%%||||||!!|||||!!;:''`.                .\n|||%|;.                         .`''::;;|||||||||||!!!!|||||!!!!!!!|||||||%%%%%%|%%%||||||||||||!!;;:'`..             .\n|||%|!'.  ..                     `':::;;!|%|||||||!!!!!!!!!!!!!!!!!||||||%%%%%%%%%%%%|||||%%%|||||!!!;;:'`.           .\n||||||;`   ..                     `::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||%%%%%%%$$%%%|||||%%%%%||||||||!!;:'`.        .\n||||||!:`  ...                     .::;;;!|||||||||||!!!!!!!!!!!!!!!!!||||||%%%%$$%%%||||%%%%%%%%||||%%%||!;;:'.      .\n|||||||;`     ..                    .':;;!|||||||||!!!;!!!!!!!!!!!!!!!!||||||%%%%%%%%||||%%%%%%%%%%%%%%%%%%%||!;:''`. .\n!!!!!!||;`.    ..              .      `:;;;!!!!!!;::;;!!!!!!!!!!!!!!!!!!|||||||||%%%||||%%%%%%%%||||%%%%%%%%%%%||!;;;::\n!!!!!!!!!:.  .......                    `::;;;;;;:;;;!!!||!!!;;;;:;;;!!!!!|||!!!|||||||%%%%%%%|||!||||%%%$$$%%%|||!!!!!\n!!!!!!!!!!:.  .......          .          `:::;;;;;;!!!!!!;;;:::;;;;;;!!!!!!!!!!!||||||%%%%%%%%|||!!!||||||||||||||!!!!\n;;;;;;!!!!!:`..........       ...           .`:::::;;;;;:'``':;!!!!!!!!!!|!!!!!!!||||||||%%%%%%%%%|||!!!!!!!!!!!!!!!!!!\n;;;;;;;!!!!!:`..........        .              .`::::''''':;;!!!!!!!!!|||||!!!!!!!!!!!||||||%%%$$$$%%|||!!!!!!!!!!!!!!!\n;;;;;!!!!!!!!;`............. ..                   .`::::;;;;;;;;;;!!!||%%||!!!!!!!;;;!!!!||||%%$$&&&$$%%%|||||||||||||!\n!!!!!!!!!!!!!!!:`............        ..               .':::::::;;!!|||%%%||!!!!;;;;;;;;;!!!!||%%$&&&&&$$$$$%%%%||||||||\n!!!!!!!!!!|!!!!!:`...............     .      ....        `::;;;!!||||||%||!!!:''::::;;;;;!!!!!|%$&&&&&&&$$$$%%%||||||||\n!!!!!!|||||||||!;`............         ...........         .';;!!!!!!!!!!!!;::::::::;;;;;!!!!!!|%$&&&&&&&$$$$%%%|||||||\n||||||||||||||||;`........... ...      .......`...           .';;;;;;;!!:``'':::;;;;;;!!!!|||||||$&@@@&&&&$$$$%%%%|||||\n||||||||||||||||:``.............       .............            .`':'`.....`':::;;;!!!!||%%%%%%||$@@@@@@&&&$$$%%%%%%%%|\n|||||||||||||%|!:'`.............      . ............                   ....`':::;;!|%$$$$$$$$$%%|%&@##@@@&&$$$$$$$$%%$%\n||||||||||%%%%|;;;`......  ....      ... ....     ...        ..       .....`':::;;!%$&&&&&&&&&&$%$&@@@@@@&&$$$$$$$$$$$$\n||||||%%%%%%%%%!;:'`.....   ...             ..     .......    ..   .....```''::;;!|%$&&@@@@@@@&&$$&&@@@@@&$$%%%%%%%$$$$\n%%%%%%%%%%%%%%%!!;'`...........               ...... ..........   ..``````'':;!%%$$$&&@@@###@@@@&&&&&&&$$%%%|||||%$$$&$\n%%%%%%%%%%%%%%%|!;'.....`''`..      .          ...............    .``````':!%%||||%$&@@######@@@&&&$$%%%||||||||%$&&&&&\n%%%%%%%%%%%%%%%|!:`.......`...     ...````''``````````````.......``''':;|%%|!!!!!!|%$@########@@@&$%%||||||||%%%$&&&@@@\n|%%%%%%%%%%%%%%%|;'`.`'`. .....`''''''::::::::::::::::;;:::'::::::;;;;!%%||!!!!!!!||$&########@&$%%|||||||%%$$$&@@@@@#@\nCoded by Shinmurn Shar, a 20-yr-old beautiful girl, in 2019/12/19.\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace dsu{\n\tint fa[100005];\n\n\tvoid init(){\n\t\tfor(int i=1;i<100005;i++){\n\t\t\tfa[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\tif(fa[x]!=x){\n\t\t\tfa[x]=root(fa[x]);\n\t\t}\n\t\treturn fa[x];\n\t}\n\n\tvoid conn(int a,int b){\n\t\ta=root(a);b=root(b);\n\t\tif(a==b){\n\t\t\treturn;\n\t\t}\n\t\tfa[a]=b;\n\t}\n}\n\nusing namespace dsu;\n\nint n,m;\nint a[100005],b[100005];\nvector<int> nei[100005];\nint id[100005];\nlong long dy[100005],nd[100005];\nbool lgl[100005];\n\nbool bijore(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tid[i]=i;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tnei[a].push_back(b);\n\t\tnei[b].push_back(a);\n\t}\n\tsort(id+1,id+n+1,bijore);\n\tfor(int I=1;I<=n;I++){\n\t\tint i=id[I];\n\t\tnd[i]=b[i];\n\t\tdy[i]=0x3f3f3f3f3f3f3f3fll;\n\t\tfor(int j=0;j<nei[i].size();j++){\n\t\t\tint to=nei[i][j];\n\t\t\tif(lgl[to]){\n\t\t\t\tint t=root(to);\n\t\t\t\tif(t==i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdy[i]=min(dy[i],max(a[i]-b[i]-nd[t],dy[t]));\n\t\t\t\tnd[i]+=nd[t];\n\t\t\t\tfa[t]=i;\n\t\t\t}\n\t\t}\n\t\tif(nd[i]==b[i]){\n\t\t\tdy[i]=max(a[i]-b[i],0);\n\t\t}\n\t\tlgl[i]=1;\n\t}\n\tprintf(\"%lld\\n\",dy[id[n]]+nd[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\n\tvector<int> par, ran;\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tu = trans[u], v = trans[v];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i]);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = mi;\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    vector<int> sc(cp.size(), 0);\n    sc[0] = 1;\n    for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[0].first - cp[0].second) sc[j] = 1;\n    sc[sc.size() - 1] = 1;\n    for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[cp.size() - 1].first - cp[cp.size() - 1].second) sc[j] = 1;\n    for (int i = 0; i + 1 < cp.size(); i++)\n    {\n        if (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second)\n        {\n            sc[i] = 1;\n            for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[i].first - cp[i].second) sc[j] = 1;\n        }\n    }\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (sc[i])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 100005\n#define maxm 5000005\n#define ll long long \nusing namespace std;\n\nint n,m,i,j,k,a[maxn],b[maxn],d[maxn];\nint tot,t[maxm],tl[maxm],tr[maxm];\nint em,e[maxn*2],nx[maxn*2],ls[maxn];\n\nvoid insert(int x,int y){\n\tem++; e[em]=y; nx[em]=ls[x]; ls[x]=em;\n\tem++; e[em]=x; nx[em]=ls[y]; ls[y]=em;\n}\n\nint fa[maxn],rt[maxn]; ll g[maxn];\nint father(int x){return (fa[x]==x)?x:fa[x]=father(fa[x]);}\nint newnode(){tot++,t[tot]=tl[tot]=tr[tot]=0;return tot;}\nint com(int i,int j){\n\tif (i&&j) return (a[i]-b[i]<a[j]-b[j])?i:j;\n\treturn max(i,j);\n}\n\nvoid add(int &x,int l,int r,int p){\n\tif (!x) x=newnode();\n\tif (l==r) {t[x]=l;return;}\n\tint mid=(l+r)>>1;\n\tif (p<=mid) add(tl[x],l,mid,p); \n\telse add(tr[x],mid+1,r,p);\n\tt[x]=com(t[tl[x]],t[tr[x]]);\n}\n\nvoid del(int &x,int l,int r,int p){\n\tif (!x) return;\n\tif (l==r) {t[x]=0;return;}\n\tint mid=(l+r)>>1;\n\tif (p<=mid) del(tl[x],l,mid,p);\n\telse del(tr[x],mid+1,r,p);\n\tt[x]=com(t[tl[x]],t[tr[x]]);\n}\n\nvoid merge(int x,int y,int l,int r){\n\tt[x]=com(t[x],t[y]);\n\tint mid=(l+r)>>1;\n\tif (tl[x]&&tl[y]) merge(tl[x],tl[y],l,mid);\n\telse if (!tl[x]) tl[x]=tl[y];\n\tif (tr[x]&&tr[y]) merge(tr[x],tr[y],mid+1,r);\n\telse if (!tr[x]) tr[x]=tr[y];\n}\n\nint check(ll mid){\n\ttot=0;\n\tfor(i=1;i<=n;i++) {\n\t\tfa[i]=i,g[i]=b[i];\n\t\trt[i]=0;for(j=ls[i];j;j=nx[j]) add(rt[i],1,n,e[j]);\n\t}\n\tfor(i=1;i<=n;i++) if (mid+b[i]>=a[i]){\n\t\tfa[i]=father(i);\n\t\twhile (t[rt[fa[i]]]&&mid+g[fa[i]]+b[t[rt[fa[i]]]]>=a[t[rt[fa[i]]]]){\n\t\t\tj=t[rt[fa[i]]];\n\t\t\tif (father(i)!=father(j)){\n\t\t\t\tmerge(rt[fa[i]],rt[fa[j]],1,n);\n\t\t\t\tg[fa[i]]+=g[fa[j]],fa[fa[j]]=fa[i];\n\t\t\t}\n\t\t\tdel(rt[fa[i]],1,n,j); \n\t\t}\n\t}\n\tint cnt=0;\n\tfor(i=1;i<=n;i++) cnt+=(fa[i]==i);\n\treturn cnt==1;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]);\n\tfor(i=1;i<=m;i++) scanf(\"%d%d\",&j,&k),insert(j,k);\n\tll L=0,R=1ll*n*1e9,mid,ans;\n\twhile (L<=R){\n\t\tmid=(L+R)>>1;\n\t\tif (check(mid)) ans=mid,R=mid-1;\n\t\telse L=mid+1;\n\t}\n\tfor(i=1;i<=n;i++) ans+=b[i];\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REPD(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\nint main(int argc, char *argv[])\n{\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int>> G(N);\n  vector<ll> A(N);\n  vector<ll> B(N);\n  vector<pair<ll, int>> vs;\n  REP(i, N) {\n    cin >> A[i] >> B[i];\n    vs.push_back(make_pair(A[i] - B[i], i));\n  }\n  sort(ALL(vs));\n\n  REP(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UnionFind uf(N);\n  vector<ll> sum(N, -1);\n  vector<ll> dp(N, -1);\n\n  REP(i, N) {\n    int v = vs[i].second;\n\n    vector<int> cs;\n    for (const auto &w : G[v]) {\n      int wc = uf.find(w);\n      if (sum[wc] < 0) continue;\n      cs.push_back(wc);\n    }\n    sort(ALL(cs));\n    cs.erase(unique(ALL(cs)), cs.end());\n\n    ll csum = 0;\n    for (int c : cs) {\n      csum += sum[c];\n    }\n\n    if (int(cs.size()) == 0) {\n      dp[uf.find(v)] = max(A[v], B[v]);\n      sum[uf.find(v)] = B[v];\n    } else {\n      ll res = csum + max(A[v], B[v]);\n      for (int c : cs) {\n        res = min(res, max(A[v], dp[c] + B[v]) + csum - sum[c]);\n      }\n\n      for (int w : G[v]) {\n        int wc = uf.find(w);\n        if (sum[wc] < 0) continue;\n        uf.unite(v, wc);\n      }\n      sum[uf.find(v)] = csum + B[v];\n      dp[uf.find(v)] = res;\n    }\n  }\n  cout << dp[uf.find(vs[N - 1].second)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int, int>> L;\nvector<int> Y[1 << 17];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem - B[pos] || Subtree[pos] > rem) return 0;\n\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= rem - Subtree[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) { scanf(\"%lld%lld\", &A[i], &B[i]); A[i] -= B[i]; }\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(t);\n\t\t\t}\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 1000006200);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n//    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, ll, ll>> pq;// -cost, from, to\n  auto poss = [&](ll rem) {\n    DisjointSet<> dsu(n);\n    fill(ALL(vis), false);\n    VEVE(i, 0, n) {\n      dsu.sum[i] = recv[i];\n      if (need[i] <= rem) {\n        vis[i] = true;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    while (not pq.empty()) {\n      ll cost, fr, to;\n      tie(cost, fr, to) = pq.top();\n      pq.pop();\n      cost = -cost;\n      if (dsu.IsSameSet(fr, to))\n        continue;\n      if (dsu.sum[dsu.Find(fr)] + rem >= cost) {\n        dsu.Unite(fr, to);\n        if (not vis[to]) {\n          vis[to] = true;\n          RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n        }\n      }\n    }\n    VEVE(i, 0, n) if (not vis[i]) return false;\n    return true;\n  };\n  ll low = 0, hig = 1e9;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct bian\n{\n\tint nxt,to;\n}bi[200020];\nint n,m,head[100010],num,a[100010],b[100010],c[100010],f[100010],p[100010];\nlong long sum[100010],dp[100010];\nvector<int>E[100010];\ninline void add(int from,int to){bi[++num]=bian{head[from],to};head[from]=num;}\nbool cmp(int x,int y){return c[x]<c[y];}\nint find(int x){if(x!=f[x])return f[x]=find(f[x]);return x;}\nvoid dfs(int v)\n{\n\tsum[v]=b[v];\n\tif(!E[v].size())\n\t{\n\t\tdp[v]=max(a[v],b[v]);\n\t\treturn ;\n\t}\n\tfor(auto u:E[v])\n\t{\n\t\tdfs(u);\n\t\tsum[v]+=sum[u];\n\t}\n\tdp[v]=0x3f3f3f3f3f3f3f3f;\n\tfor(auto u:E[v])dp[v]=min(dp[v],sum[v]-sum[u]+max(1ll*c[v],dp[u]));\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;++i)scanf(\"%d %d\",&a[i],&b[i]),c[i]=max(a[i]-b[i],0);\n\tint x,y;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadd(x,y),add(y,x);\n\t}\n\tfor(int i=1;i<=n;++i)p[i]=i;\n\tsort(p+1,p+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tx=p[i];\n\t\tf[x]=x;\n\t\tfor(int j=head[x],u;j;j=bi[j].nxt)\n\t\t{\n\t\t\tu=find(bi[j].to);\n\t\t\tif(u&&u!=x)\n\t\t\t{\n\t\t\t\tf[u]=x;\n\t\t\t\tE[x].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(p[n]);\n\tprintf(\"%lld\",dp[p[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define int ll\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nVI e[MAXN];\nint a[MAXN],b[MAXN],f[MAXN],sum[MAXN],vis[MAXN],id[MAXN],ans[MAXN];\nint compare(int x,int y) { return a[id[x]]<a[id[y]]; }\nint find(int x) { return f[x]==x?f[x]:f[x]=find(f[x]); }\nsigned main()\n{\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,compare);\n\tfor (int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].PB(v),e[v].PB(u);\n\tfor (int i=1;i<=n;i++) f[i]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tVI to; int x=id[i];\n\t\tvis[x]=1,sum[x]=b[x];\n\t\tfor (auto v:e[x])\n\t\t{\n\t\t\tif (!vis[v]||find(x)==find(v)) continue;\n\t\t\tto.PB(find(v));\n\t\t\tsum[x]+=sum[find(v)];\n\t\t\tf[find(v)]=x;\n\t\t}\n\t\tans[x]=sum[x]+a[x];\n\t\tfor (auto v:to) upmin(ans[x],sum[x]-sum[v]+max(a[x],ans[v]));\n\t}\n\tprintf(\"%lld\\n\",ans[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\n#define ll long long\n//#define file\nusing namespace std;\n\nstruct type{int x,y,s;} b[100001];\nstruct Type{int x;ll A,B;} d[100001];\nint a[200001][2],ls[100001],A[100001],B[100001],fa[100001],n,m,i,j,k,l,len,x,y;\nll f[100001],g[100001],F[100001],sum[100001],s1[100002],s2[100002],ss[100002],ans;\n\nvoid New(int x,int y) {++len;a[len][0]=y;a[len][1]=ls[x];ls[x]=len;}\nbool cmp(type a,type b) {return a.s<b.s;}\nbool Cmp(Type a,Type b) {return a.A-a.B>b.A-b.B;}\nint gf(int t) {if (fa[t]==t) return t;fa[t]=gf(fa[t]);return fa[t];}\n\nvoid dfs(int Fa,int t)\n{\n\tint i,j,k,l=0;\n\tll Sum,ans;\n\t\n\tsum[t]=B[t];\n\tfor (i=ls[t]; i; i=a[i][1])\n\tif (a[i][0]!=Fa)\n\tdfs(t,a[i][0]),sum[t]+=sum[a[i][0]];\n\t\n\tfor (i=ls[t]; i; i=a[i][1])\n\tif (a[i][0]!=Fa)\n\td[++l]={a[i][0],g[a[i][0]],sum[a[i][0]]};\n\t\n\tif (l)\n\tsort(d+1,d+l+1,Cmp);\n\t\n\tss[0]=0;fo(i,1,l) ss[i]=ss[i-1]+d[i].B;\n\ts1[0]=0;fo(i,1,l) s1[i]=s1[i-1]+max(d[i].A-(s1[i-1]-ss[i-1]),0);\n\tg[t]=s1[l]+max(max(A[t],B[t])-(s1[l]-ss[l]),0);\n}\nvoid Dfs(int Fa,int t)\n{\n\tint i,j,k,l=0;\n\tll Sum,ans;\n\t\n\tfor (i=ls[t]; i; i=a[i][1])\n\tif (a[i][0]!=Fa)\n\td[++l]={a[i][0],g[a[i][0]],sum[a[i][0]]};\n\tif (t>1)\n\td[++l]={0,F[t],sum[1]-sum[t]};\n\t\n\tif (l)\n\tsort(d+1,d+l+1,Cmp);\n\t\n\tss[0]=0;fo(i,1,l) ss[i]=ss[i-1]+d[i].B;\n\ts1[0]=0;fo(i,1,l) s1[i]=s1[i-1]+max(d[i].A-(s1[i-1]-ss[i-1]),0);\n\ts2[l+1]=0;fd(i,l,1) s2[i]=s2[i+1]+d[i].B+max(d[i].A-(s2[i+1]+d[i].B),0);\n\t\n\tf[t]=s1[l]+max(max(A[t],B[t])-(s1[l]-ss[l]),0);\n\tfo(i,1,l)\n\tif (d[i].x)\n\t{\n\t\tans=s1[i-1];Sum=s1[i-1]-ss[i-1];\n\t\tif (Sum<s2[i+1]) ans+=s2[i+1]-Sum,Sum=s2[i+1];Sum-=ss[l]-ss[i];\n\t\tif (Sum<max(A[t],B[t])) ans+=max(A[t],B[t])-Sum,Sum=max(A[t],B[t]);Sum-=B[t];\n\t\tF[d[i].x]=ans;\n\t}\n\tfor (i=ls[t]; i; i=a[i][1])\n\tif (a[i][0]!=Fa)\n\tDfs(t,a[i][0]);\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc098F.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d%d\",&A[i],&B[i]),fa[i]=i;\n\tfo(i,1,m) scanf(\"%d%d\",&b[i].x,&b[i].y),b[i].s=max(A[b[i].x]-B[b[i].x],A[b[i].y]-B[b[i].y]);\n\t\n\tsort(b+1,b+m+1,cmp);\n\tfo(i,1,m)\n\t{\n\t\tx=b[i].x,y=b[i].y;\n\t\tif (gf(x)!=gf(y))\n\t\t{\n\t\t\tfa[fa[x]]=fa[y];\n\t\t\tNew(x,y),New(y,x);\n\t\t}\n\t}\n\t\n\tdfs(0,1);\n\tDfs(0,1);\n\tans=9223372036854775807ll;\n\tfo(i,1,n) ans=min(ans,f[i]);\n\tprintf(\"%lld\\n\",ans);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\ninline int ri()\n{\n\tregister int x=0;register bool f=0;register char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();};\n\treturn f?-x:x;\n}\nvoid wi(int x)\n{\n\tif(x<0)\tx=-x,putchar('-');\n\tif(x>9)\twi(x/10);\n\tputchar('0'+x%10);\n}\nint main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tint n=ri();\n\tif(n==4)\tputs(\"6\");\n\tif(n==5)\tputs(\"44\");\n\tif(n==9)\tputs(\"582\");\n\treturn 0;\n}\n/*\n\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n#define pii pair <int , int>\n#define F first\n#define S second\nconst int N = 1e5 + 5, inf = 1e9 + 1;\nint A[N], B[N], par[N], C, n, m;\nlong long W[N], Sum;\nvector <int> g[N];\npriority_queue <pii, vector<pii>, greater<pii>> pq[N];\n\nvoid init(int w) {\n    C = n;\n    for (int v = 1; v <= n; v++) {\n        par[v] = v, W[v] = B[v];\n        while (!pq[v].empty()) pq[v].pop();\n        for (int u : g[v]) pq[v].push({A[u] - B[u], u});\n    }\n}\nint getpar(int v) {return par[v] = (par[v] == v ? v : getpar(par[v]));}\nvoid Union(int u, int v) {\n    u = getpar(u);\n    if (u == v) return ;\n    par[u] = v, W[v] += W[u], C--;\n    if (pq[u].size() > pq[v].size()) swap(pq[u], pq[v]);\n    while (!pq[u].empty()) pq[v].push(pq[u].top()), pq[u].pop();\n}\nbool check(int w) {\n    init(w);\n    for (int v = 1; v <= n; v++) if (par[v] == v && w + W[v] >= A[v]) {\n        while (!pq[v].empty()) {\n            int u = pq[v].top().S;\n            if (A[u] - B[u] > W[v] + w) break ;\n            pq[v].pop(), Union(u, v);\n        }\n    }\n    return C == 1;\n}\nint32_t main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> A[i] >> B[i], Sum += B[i];\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    int dw = -1, up = inf;\n    while (up - dw > 1) {\n        int md = (up+dw)>>1;\n        if (check(md)) up = md;\n        else dw = md;\n    }\n    cout << Sum + up << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nstruct node{int to,nxt;}sq[N<<1],sq1[N<<1];\nint head[N],head1[N],all=0,all1=0;\nint n,m,a[N],b[N],c[N],fa[N],id[N];\nll f[N],sum[N]; \nbool vis[N];\n\nbool cmp(int x,int y) {return c[x]<c[y];}\n\nint find(int x)\n{\n\tif (fa[x]==x) return fa[x];\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid addedge(int u,int v)\n{\n\tall++;sq[all].to=v;sq[all].nxt=head[u];head[u]=all;\n}\n\nvoid addedge1(int u,int v)\n{\n\tall1++;sq1[all1].to=v;sq1[all1].nxt=head1[u];head1[u]=all1;\n}\n\nvoid dfs(int u)\n{\n\tsum[u]=b[u];\n\tfor (int i=head1[u];i;i=sq1[i].nxt)\n\t{\n\t\tint v=sq1[i].to;\n\t\tdfs(v);sum[u]+=sum[v];\n\t}\n\tf[u]=sum[u]+c[u];\n\tfor (int i=head1[u];i;i=sq1[i].nxt)\n\t{\n\t\tint v=sq1[i].to;\n\t\tf[u]=min(f[u],sum[u]-sum[v]+max((ll)c[u],f[v]));\n\t}\n}\n\nint main()\n{\n\tn=read();m=read();\n\trep(i,1,n)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tc[i]=max(a[i]-b[i],0);\n\t}\n\trep(i,1,m)\n\t{\n\t\tint u=read(),v=read();\n\t\taddedge(u,v);addedge(v,u);\n\t}\n\trep(i,1,n) id[i]=fa[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\trep(i,1,n)\n\t{\n\t\tint u=id[i];vis[u]=1;\n\t\tgo(u,i)\n\t\t{\n\t\t\tif (vis[v])\n\t\t\t{\n\t\t\t\tint fx=find(u),fy=find(v);\n\t\t\t\tif (fx!=fy)\n\t\t\t\t{\n\t\t\t\t\tfa[fy]=fx;addedge1(fx,fy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(id[n]);printf(\"%lld\",f[id[n]]);\n\treturn 0;\n}\n\t\t\t\t\t\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nconst int MAXN = 1e5 + 5; \nint N,M,a[MAXN],b[MAXN],p[MAXN]; \nint pa[MAXN]; \nint getf(int x) { while (x != pa[x]) x = pa[x] = pa[pa[x]]; return x; } \nvector<int> G[MAXN]; \nlong long f[MAXN], sum[MAXN];\nbool vis[MAXN]; \nint main () { \n\tN = read(), M = read();\n\tfor (int i = 1; i <= N; i++) { \n\t\ta[i] = read(), b[i] = read(); \n\t\ta[i] = max(a[i] - b[i], 0);\n\t\tp[i] = i, pa[i] = i; \n\t} \n\tsort(&p[1], &p[N + 1], [](const int &l, const int &r) { return a[l] < a[r]; } ); \n\tfor (int i = 1; i <= M; i++) { \n\t\tint u = read(), v = read(); \n\t\tG[u].push_back(v), G[v].push_back(u); \n\t} \n\tfor (int i = 1; i <= N; i++) { \n\t\tvector<int> son;\n\t\tint x = p[i]; \n\t\tvis[x] = 1, sum[x] = b[x]; \n\t\tfor (auto v : G[x]) {\n\t\t\tif (!vis[v] || getf(x) == getf(v)) continue; \n\t\t\tson.push_back(getf(v)); \n\t\t\tsum[x] += sum[getf(v)]; \n\t\t\tpa[getf(v)] = x; \n\t\t} \n\t\tf[x] = sum[x] + a[x]; \n\t\tfor (auto v : son) f[x] = min(f[x], sum[x] - sum[v] + max(1ll * a[x], f[v])); \n\t} \n\tprintf(\"%lld\\n\", f[p[N]]); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nint bh[N],bt;\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nbool rdcmp(int a,int b){\n\treturn rand()%2;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tLL ans=1e16;\n\tdfs(root,0);\n\tans=min(ans,need[root]);\n\tsrand(19260817);\n\tbt=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (A[i]==A[root]){\n\t\t\tbh[++bt]=i;\n\t\t}\n\t}\n\tsort(bh+1,bh+bt+1,rdcmp);\n\tfor (int i=1;i<=min(50,bt);i++){\n\t\troot=bh[i];\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tfor (int i=1;i<=500;i++){\n\t\troot=rand()%n+1;\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tLL ans=1e16;\n\tdfs(root,0);\n\tans=min(ans,need[root]);\n\tsrand(19260817);\n\tfor (int i=1;i<=50;i++){\n\t\troot=rand()%n+1;\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m;\nvector<int> g[N];\nlong long a[N], b[N];\nint p[N];\nbool used[N];\nlong long sum[N];\nset<pair<long long, int> > st[N];\n\nint find(int x) { return p[x] < 0 ? x : p[x] = find(p[x]); }\n\n\nbool can(long long x) {\n  for (int i = 0; i < n; ++i) {\n    st[i].clear();\n    for (int u : g[i])\n      st[i].insert(make_pair(a[u], u));\n    sum[i] = b[i];\n  }\n  fill(p, p+n, -1);\n  fill(used, used+n, 0);\n  int cnt = 0;\n  stack<int> stak;\n  for (int i = 0; i < n; ++i) {\n    if (x >= a[i]) {\n      stak.push(i);\n      used[i] = 1;\n    }\n  }\n  // cerr << \" cek \" << x << endl;\n  while (!stak.empty()) {\n    int v = stak.top();\n    stak.pop();\n    v = find(v);\n    // cerr << \" sumber \" << v << endl;\n    while (!st[v].empty()) {\n      auto it = st[v].begin();\n      int u = it->second;\n      st[v].erase(it);\n      if (a[u] > sum[v] + x) break;\n      u = find(u);\n      used[u] = 1;\n      // cerr << \" tambah \" << u << endl;\n      if (u == v) continue;\n      if (st[u].size() > st[v].size()) swap(u, v);\n      for (auto it2 : st[u])\n        st[v].insert(it2);\n      st[u].clear();\n      sum[v] += sum[u];\n      p[u] = v;\n    }\n  }\n  for (int i = 0; i < n; ++i) if (!used[i]) return false;\n  return true;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d %d\", a+i, b+i);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v); --u, --v; \n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long lo = 0, hi = 0;\n  for (int i = 0; i < n; ++i)\n    if (a[i] > hi) hi = a[i];\n  for (int i = 0; i < n; ++i)\n    a[i] -= b[i];\n  long long all = 0;\n  for (int i = 0; i < n; ++i)\n    all += b[i];\n  while (lo < hi) {\n    long long mid = (lo + hi) >> 1;\n    if (can(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  cerr << lo << endl;\n  printf(\"%lld\\n\", lo+all);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100010;\nll sum[MX];\nint n, m, a[MX], b[MX], p[MX];\nvector<vi> e;\nint root(int x){\n\treturn p[x] == x ? x : (p[x] = root(p[x]));\n}\nvoid merge(int a, int b){\n\ta = root(a); b = root(b);\n\tif(a != b){\n\t\tp[b] = a;\n\t\tsum[a] += sum[b];\n\t}\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tcin >> n >> m; e.resize(n);\n\trep(i, n) cin >> a[i] >> b[i];\n\trep(i, m){\n\t\tint x, y; cin >> x >> y; x--; y--;\n\t\te[x].pb(y);\n\t\te[y].pb(x);\n\t}\n\t\n\tvector<tuple<ll, int, int>> es;\n\trep(i, n) for(int j : e[i]) es.emplace_back(a[j] - b[j] - sum[i], i, j);\n\tsort(all(es));\n\t\n\trep(i, n) p[i] = i, sum[i] = b[i];\n\t\n\tll ans = 0;\n\twhile(es.size()){ //計算量？\n\t\tll mn = 1e18;\n\t\tvector<tuple<ll, int, int>> next;\n\t\tfor(auto i : es){\n\t\t\tll p; int q, r; tie(p, q, r) = i;\n\t\t\tint Q = root(q), R = root(r);\n\t\t\tif(Q == R) continue;\n\t\t\t\n\t\t\tll c = sum[Q] + b[r] - a[r];\n\t\t\tll st = sum[Q] > b[q] ? 0 : a[q] - b[q];\n\t\t\tif(ans >= st && c + ans >= 0){\n\t\t\t\t//dbg(p, q, r, c, Q); dbg(ans, st);\n\t\t\t\tmerge(q, r);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext.emplace_back(-c, q, r);\n\t\t\t}\n\t\t\tmn = min(mn, max(st, -c));\n\t\t}\n\t\t//dbg(es.size(), next.size(), mn);\n\t\tif(mn < 1e18) ans = max(ans, mn);\n\t\tes = next;\n\t\tsort(all(es));\n\t}\n\t//dbg(ans, root(0), sum[root(0)]); rep(i, n) cerr<<root(i)<<(i==n-1?\"\\n\":\" \");\n\tcout << ans + sum[root(0)] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define sz(x) (int)x.size() \n#define pb push_back \n#define mp make_pair \n#define fi(a, b) for(int i=a; i<=b; i++) \n#define fj(a, b) for(int j=a; j<=b; j++) \n#define fo(a, b) for(int o=a; o<=b; o++) \n#define fdi(a, b) for(int i=a; i>=b; i--) \n#define fdj(a, b) for(int j=a; j>=b; j--) \n#define fdo(a, b) for(int o=a; o>=b; o--) \n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while(false) {}\n#endif\n\ntypedef long long ll; \ntypedef pair<int, int> pii; \ntypedef pair<ll, ll> pll; \ntypedef vector<int> vi; \ntypedef vector<ll> vll;\ntypedef vector<pii> vpii; \ntypedef vector<pll> vpll; \ntypedef long double ld;\ntypedef unsigned long long ull;\n\n/////////////////////////////////\n\nint const MAX = 1e5 + 41;\nint const INF = 1e9 + 41;\n\nint n, m;\nint a[MAX];\nint b[MAX];\nint per[MAX];\nvi e[MAX];\n\nll sumb, ans;\n\nbool cmp(int x, int y) {\n\treturn b[x] > b[y];\t\n}\n\nint par[MAX];\n\nvoid init() {\n\tfi(1, n) {\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool uni(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) return false;\n\tpar[b] = a;\n\treturn true;\n}\n\nbool can(int h) {\n\tfi(1, n) {\n\t\tint root = per[i];\n\t\tif (b[root] + h < a[root]) continue;\n\t\tll sum = b[root] + h;\n\t\tinit();\n\t\tset<pii> t;\n\t\tint q = 1;\n\t\tfor (int y : e[root]) {\n\t\t\tt.insert(mp(a[y] - b[y], y));\n\t\t}\t\t\n\t\twhile (q < n) {\n\t\t\tif (!sz(t)) break;\n\t\t\tpii cur = (*t.begin());\n\t\t\tt.erase(t.begin());\n\t\t\tif (cur.first > sum) break;\n\t\t\tint x = cur.second;\n\t\t\tif (!uni(root, x)) continue;\n\t\t\tq++;\n\t\t\tsum += cur.first;\n\t\t\t//\n\t\t\tif (sum >= INF) return 1;\n\t\t\t//\n\t\t\tfor (int y : e[x]) {\n\t\t\t\tif (find(y) == root) continue;\n\t\t\t\tt.insert(mp(a[y] - b[y], y));\n\t\t\t}\t\t\n\t\t}\n\t\tif (q == n) return true;\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tfi(1, n) {\n\t\tper[i] = i;\n\t}\n\tsort(per + 1, per + n + 1, cmp);\n\tfi(1, n) {\n\t\tsumb += b[i];\n\t}\n\tint l = -1;\n\tint r = INF;\t\n\t\n\twhile (r - l > 1) {\n\t\tint h = (l + r) / 2;\n\t\tif (can(h)) {\n\t\t\tr = h;\n\t\t} else {\n\t\t\tl = h;\n\t\t}\n\t}\n\tans = r + sumb;\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n  scanf(\"%d %d\", &n, &m);\n  fi(1, n) {\n  \tscanf(\"%d %d\", &a[i], &b[i]);\n  }\n  fi(1, m) {\n  \tint x, y;\n  \tscanf(\"%d %d\", &x, &y);\n  \te[x].pb(y);\n  \te[y].pb(x);\n  }\n\tsolve();\t\t\n\n\t\n#ifdef LOCAL\n\terr(\"ELAPSED TIME: %.3Lf\\n\", (ld) clock() / CLOCKS_PER_SEC);\n#endif\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{int to,next;}e[200010],E[200010];\nint n,m,a[100010],b[100010],Hd[100010],id[100010],fa[100010],bel[100010],x,y,hd[100010],cnt,p[100010];\nlong long sum[100010],f[100010];\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid addedge(int x,int y) {e[++cnt]=(node){y,hd[x]},hd[x]=cnt;}\n\nvoid Addedge(int x,int y)\n{\n\tE[++cnt]=(node){y,Hd[x]},Hd[x]=cnt;\n\tE[++cnt]=(node){x,Hd[y]},Hd[y]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tsum[x]=b[x];\n\tif (!hd[x]) {f[x]=max(a[x],b[x]); return;}\n\tlong long mi=1000000000000000000ll;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tdfs(e[i].to),sum[x]+=sum[e[i].to],mi=min(mi,max(1ll*a[x],b[x]+f[e[i].to])-sum[e[i].to]);\n\tf[x]=min(sum[x]-b[x]+mi,sum[x]-b[x]+max(a[x],b[x]));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp),cnt=0;\n\tfor (int i=1; i<=n; i++) p[id[i]]=i;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tx=id[i];\n\t\tfor (int j=Hd[x]; j; j=E[j].next)\n\t\t\tif (p[E[j].to]<i&&ask(E[j].to)!=x) fa[ask(E[j].to)]=x,bel[ask(E[j].to)]=x;\n\t}\n\tcnt=0;\n\tfor (int i=1; i<=n; i++) if (fa[i]) addedge(fa[i],i);\n\tdfs(id[n]),printf(\"%lld\\n\",f[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m, x, y;\nint a[N], b[N];\nint f[N], d[N], nd[N];\nint F(int x) {\n\treturn f[x] == x ? x : (f[x] = F(f[x]));\n}\n\n#define V vector<int>\n#define pb push_back\n#define si size()\nV e[N];\n\nint cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\n\nll sumb[N], g[N];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, n) scanf(\"%d %d\", &a[i], &b[i]), a[i] = max(0, a[i] - b[i]);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\te[x].pb(y); e[y].pb(x);\n\t}\n\tfo(i, 1, n) f[i] = i, sumb[i] = b[i], g[i] = a[i];\n\tfo(i, 1, n) d[i] = i;\n\tsort(d + 1, d + n + 1, cmp);\n\tfo(i, 1, n) nd[d[i]] = i;\n\tfo(i, 1, n) {\n\t\tint x = d[i];\n\t\tff(j, 0, e[x].si) {\n\t\t\tint y = e[x][j];\n\t\t\tif(nd[y] > nd[x]) continue;\n\t\t\tif(F(x) != F(y)) {\n\t\t\t\tint u = f[x], v = f[y];\n\t\t\t\tf[v] = u;\n\t\t\t\tsumb[u] += sumb[v];\n\t\t\t\tg[u] = min(g[u], max(g[v], a[u] - sumb[v]));\n\t\t\t} \n\t\t}\n\t}\n\tint x = F(d[n]);\n\tpp(\"%lld\\n\", g[x] + sumb[x]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\n\nllint n, m;\nllint a[100005], b[100005];\nvector<llint> G[100005];\nvector<P> vec;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\tvector<llint> gain, need;\n\t\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tgain.resize(size+1);\n\t\tneed.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++){\n\t\t\tparent[i] = i;\n\t\t\tneed[i] = a[i];\n\t\t\tgain[i] = b[i];\n\t\t}\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t\tgain[root_j] += gain[root_i];\n\t}\n};\n\nUnionFind uf(100005);\n\n\nint main(void)\n{\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] -= b[i];\n\t\ta[i] = max(a[i], 0LL);\n\t\tvec.push_back(P(a[i], i));\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tllint u, v;\n\tfor(int i = 1; i <= m; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tuf.init();\n\t\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tint v = vec[i].second;\n\t\tfor(int j = 0; j < G[v].size(); j++){\n\t\t\tint u = G[v][j];\n\t\t\tif(a[u] > a[v] || uf.same(u, v)) continue;\n\t\t\tu = uf.root(u);\n\t\t\tllint dif = max(0LL, a[v] - (uf.need[u] + uf.gain[u]));\n\t\t\tllint tmp = min(uf.need[u] + dif, uf.need[uf.root(v)]);\n\t\t\tuf.unite(u, v);\n\t\t\tu = uf.root(u);\n\t\t\tuf.need[u] = tmp;\n\t\t}\n\t}\n\tint r = uf.root(1);\n\tcout << uf.need[r] + uf.gain[r] << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR int w=Q[v].top().se;Q[v].pop();\n\t\tif(find(w)!=find(u))Q[u].push(pi(dx[w],w));\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR int v=Q[u].top().se;if(dx[v]>s[u])break;\n\t\t\tQ[u].pop();if(find(v)==find(u))continue;\n\t\t\tif(s[u]+s[v]>=mx)return true;\n\t\t\ts[u]+=s[v],fa[find(v)]=u,++cnt,merge(u,v);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n//\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1,r=1e9;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define int ll\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nVI e[MAXN];\nint a[MAXN],b[MAXN],f[MAXN],sum[MAXN],vis[MAXN],id[MAXN],ans[MAXN];\nint compare(int x,int y) { return a[id[x]]<a[id[y]]; }\nint find(int x) { return f[x]==x?f[x]:f[x]=find(f[x]); }\nsigned main()\n{\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,compare);\n\tfor (int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].PB(v),e[v].PB(u);\n\tfor (int i=1;i<=n;i++) f[i]=i;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tVI to; int x=id[i];\n\t\tvis[x]=1,sum[x]=b[x];\n\t\tfor (auto v:e[x])\n\t\t{\n\t\t\tif (!vis[v]||find(x)==find(v)) continue;\n\t\t\tto.PB(find(v));\n\t\t\tsum[x]+=sum[find(v)];\n\t\t\tf[find(v)]=x;\n\t\t}\n\t\tans[x]=sum[x]+a[x];\n\t\tfor (auto v:to) ans[x]=min(ans[x],sum[x]-sum[v]+max(a[x],ans[v]));\n\t}\n\tprintf(\"%lld\\n\",ans[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\n#define N 100002\nusing namespace std;\nint head[N],ver[N*2],nxt[N*2],l;\nint head1[N],ver1[N*2],nxt1[N*2],l1;\nint n,m,i,j,a[N],b[N],c[N],fa[N],p[N],f[N],sum[N];\nbool vis[N];\nint read()\n{\n\tchar c=getchar();\n\tint w=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c<='9'&&c>='0'){\n\t\tw=w*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn w;\n}\nvoid insert(int x,int y)\n{\n\tl++;\n\tver[l]=y;\n\tnxt[l]=head[x];\n\thead[x]=l;\n}\nvoid insert1(int x,int y)\n{\n\tl1++;\n\tver1[l1]=y;\n\tnxt1[l1]=head1[x];\n\thead1[x]=l1;\n}\nint my_comp(const int &x,const int &y)\n{\n\treturn c[x]<c[y];\n}\nint find(int x)\n{\n\tif(fa[x]!=x) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\nvoid dfs(int x)\n{\n\tsum[x]=b[x];\n\tfor(int i=head1[x];i;i=nxt1[i]){\n\t\tint y=ver1[i];\n\t\tdfs(y);\n\t\tsum[x]+=sum[y];\n\t}\n\tf[x]=sum[x]+c[x];\n\tfor(int i=head1[x];i;i=nxt1[i]){\n\t\tint y=ver1[i];\n\t\tf[x]=min(f[x],sum[x]-sum[y]+max(f[y],c[x]));\n\t}\n}\nsigned main()\n{\n\tn=read();m=read();\n\tfor(i=1;i<=n;i++){\n\t\ta[i]=read();b[i]=read();\n\t\tc[i]=max(a[i]-b[i],1LL*0);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tinsert(u,v);\n\t\tinsert(v,u);\n\t}\n\tfor(i=1;i<=n;i++) fa[i]=p[i]=i;\n\tsort(p+1,p+n+1,my_comp);\n\tfor(i=1;i<=n;i++){\n\t\tint x=p[i];\n\t\tvis[x]=1;\n\t\tfor(j=head[x];j;j=nxt[j]){\n\t\t\tint y=ver[j];\n\t\t\tif(vis[y]){\n\t\t\t\tint f=find(y);\n\t\t\t\tif(f!=x){\n\t\t\t\t\tfa[f]=x;\n\t\t\t\t\tinsert1(x,f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(p[n]);\n\tcout<<f[p[n]]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace cqz{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*S=SZB,*T=SZB;\n    inline char gc(){   if (S==T){  T=(S=SZB)+fread(SZB,1,GYN,stdin); if (S==T) return '\\n';  }   return *S++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace cqz;\nconst ll N=3000010,inf=1e18;\nll m,n,fa[N],a[N],b[N],vis[N],sum[N],ans[N],cur[N];\nvector<ll>g[N];\nstruct dt{ll a,b,id;}p[N];\nbool cmp(dt a,dt b){return a.a<b.a;}\nll find(ll x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint main(){\n\tn=read();m=read();\n\tFor(i,1,n){a[i]=read(),b[i]=read();a[i]=max(a[i],b[i]);p[i]=(dt){a[i],b[i],i};sum[i]=b[i];}\n\tFor(i,1,m){ll x=read(),y=read();g[x].push_back(y);g[y].push_back(x);}\n\tsort(p+1,p+n+1,cmp);\n\tFor(i,1,n)fa[i]=i,ans[i]=inf;\n\tfor(ll i=1,j;i<=n;i=j+1){\n\t\tj=i;for(;p[j+1].a==p[i].a;++j);\n\t\tFor(k,i,j)vis[p[k].id]=1;\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=find(g[x][edge]);\n\t\t\t\tif (!vis[to])continue;\n\t\t\t\tcur[g[x][edge]]=to;\n\t\t\t}\n\t\t}\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=find(g[x][edge]);\n\t\t\t\tif (!vis[to]||x==to)continue;\n\t\t\t\tfa[find(to)]=find(x);\n\t\t\t\tsum[x]+=sum[to];\n\t\t\t}\n\t\t}\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=cur[g[x][edge]];\n\t\t\t\tif (!vis[to]||vis[to]==i)continue;\n\t\t\t\tll now=find(x);\n\t\t\t\tll cost=max(a[x],ans[to]+b[x])+sum[now]-sum[to]-b[x];\n\t\t\t\tMin(ans[now],cost);\n\t\t\t}\n\t\t\tMin(ans[find(x)],a[find(x)]+sum[find(x)]-b[x]);\n\t\t} \n\t}writeln(ans[find(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約、条件を見落としているかも\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\ntypedef pair<lint,pint> tint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nstruct unionf{\n\tvector <int> data;\n\tvector<lint> dp,sum;\n\tunionf(int size):data(size,-1){}\n\tbool unions(int x,int y){\n\t\tx=root(x);y=root(y);\n\t\tif(x!=y){\n\t\t\t//if(data[y]<data[x]){int d=x;x=y;y=d;}\n\t\t\tdata[x]+=data[y];data[y]=x;\n\t\t\t//dp[x]=min(max(dp[x],dp[y]+sum[x]),max(dp[y],dp[x]+sum[y]));\n\t\t\t//sum[x]+=sum[y];\n\t\t}\n\t\treturn x!=y;\n\t}\n\tvoid set(lint x,lint y){\n\t\tdp.pb(x);sum.pb(y);\n\t}\n\tlint get(int x){\n\t\treturn dp[root(x)];\n\t}\n\tbool finds(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tint root(int x){\n\t\treturn data[x]<0?x:data[x]=root(data[x]);\n\t}\n\tint find(int x){\n\t\treturn -data[x];\n\t}\n};\nlint sum[100100],dp[100100];\nlint a[100100],b[100100];int c[100100];\nvector<int> gr[100100];\nvector<pint> ed;\nint main()\n{\n\tint n,m,u,v;\n\tcin>>n>>m;\n\trep(i,n){\n\t\tcin>>a[i]>>b[i];c[i]=max(0LL,a[i]-b[i]);ed.pb(mp(c[i],i));\n\t}\n\trep(i,m){\n\t\tcin>>u>>v;u--;v--;gr[u].pb(v);gr[v].pb(u);\n\t\t//lint w=max(0LL,max(a[u]-b[u],a[v]-b[v]));\n\t\t//ed.pb(mp(w,mp(u,v)));\n\t}\n\trep(i,n) dp[i]=a[i],sum[i]=b[i];\n\tunionf uni(n+10);\n\t//rep(i,n) uni.set(max(a[i],b[i]),b[i]);\n\tsort(All(ed));\n\trep(i,n){\n\t\tv=ed[i].se;\n\t\t//cout<<v+1<<endl;\n\t\tset<int> ch;\n\t\trep(j,gr[v].size()){\n\t\t\tint w=gr[v][j];\n\t\t\tif(c[w]>c[v] || (c[w]==c[v] && v<w)) continue;\n\t\t\tif(uni.finds(v,w)) continue;\n\t\t\tch.insert(uni.root(w));\n\t\t}\n\t\tif(ch.empty()) continue;\n\t\tvector<int> ch2=vector<int>(All(ch));\n\t\tm=ch2.size();\n\t\tlint su=0,mi=123456789012345678L;\n\t\trep(j,m){\n\t\t\tsu+=sum[ch2[j]];\n\t\t}\n\t\trep(j,m){\n\t\t\tmi=min(mi,max(dp[ch2[j]],dp[v]-sum[v])+sum[v]+su-sum[ch2[j]]);\n\t\t}\n\t\trep(j,m){\n\t\t\tuni.unions(v,ch2[j]);\n\t\t}\n\t\tsum[uni.root(v)]=sum[v]+su;\n\t\tdp[uni.root(v)]=max(sum[uni.root(v)],mi);\n\t\t//cout<<sum[uni.root(v)]<<' '<<dp[uni.root(v)]<<endl;\n\t}\n\tcout<<dp[uni.root(0)]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define int ll\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nVI e[MAXN];\nint a[MAXN],b[MAXN],f[MAXN],sum[MAXN],vis[MAXN],id[MAXN],ans[MAXN];\nint compare(int x,int y) { return a[id[x]]<a[id[y]]; }\nint find(int x) { return f[x]==x?f[x]:f[x]=find(f[x]); }\nsigned main()\n{\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,compare);\n\tfor (int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].PB(v),e[v].PB(u);\n\tfor (int i=1;i<=n;i++) f[i]=i;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tVI to; int x=id[i];\n\t\tvis[x]=1,sum[x]=b[x];\n\t\tfor (auto v:e[x])\n\t\t{\n\t\t\tif (!vis[v]||find(x)==find(v)) continue;\n\t\t\tto.PB(find(v));\n\t\t\tsum[x]+=sum[find(v)];\n\t\t\tf[find(v)]=x;\n\t\t}\n\t\tans[x]=sum[x]+a[x];\n\t\tfor (auto v:to) ans[x]=min(ans[x],sum[x]-sum[v]+max(a[x],ans[v]));\n\t}\n\tprintf(\"%d\\n\",ans[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define llong long long\nint n,m;\nint c[100100],b[100100];\nstruct data{\n    int to,nxt;\n}mp[200200];\nint head[100100],cnt;\nvoid link(int x,int y)\n{\n    mp[++cnt].to=y;\n    mp[cnt].nxt=head[x];\n    head[x]=cnt;\n}\nint ed[100100][2],ted;\n\nstruct UFS{\n    int fa[100100];\n    void reset(){for(int i=1;i<=n;++i)fa[i]=i;}\n    int f(int x){return fa[x]==x?x:fa[x]=f(fa[x]);}\n}ufs;\n\nint pos[100100];\nbool cmp(int a,int b){return c[a]<c[b];}\nbool did[100100];\n\nllong dp[100100];\nllong sb[100100];\nvoid dfs(int x,int fa)\n{\n    sb[x]=b[x];\n    int v;\n    for(int i=head[x];i;i=mp[i].nxt)\n        if(mp[i].to!=fa)\n        {\n            v=mp[i].to;\n            dfs(v,x);\n            sb[x]+=sb[v];\n        }\n    dp[x]=sb[x]+c[x];\n    for(int i=head[x];i;i=mp[i].nxt)\n        if(mp[i].to!=fa)\n        {\n            v=mp[i].to;\n            dp[x]=min(dp[x],sb[x]-sb[v]+max(1ll*c[x],dp[v]));\n        }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    ufs.reset();\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%d%d\",&c[i],&b[i]);\n        c[i]=max(c[i]-b[i],0);\n        pos[i]=i;\n    }\n    int xx,yy;\n    for(int i=1;i<=m;++i)\n        scanf(\"%d%d\",&xx,&yy),link(xx,yy),link(yy,xx);\n    sort(pos+1,pos+n+1,cmp);\n    for(int t=1;t<=n;++t)\n    {\n        xx=pos[t];\n        did[xx]=1;\n        for(int i=head[xx];i;i=mp[i].nxt)\n            if(did[mp[i].to])\n            {\n                yy=ufs.f(mp[i].to);\n                if(yy==xx)continue;\n                ufs.fa[yy]=xx;\n                ed[++ted][0]=yy;\n                ed[ted][1]=xx;\n            }\n    }\n    memset(head,0,sizeof(head));\n    cnt=0;\n    for(int i=1;i<=ted;++i)\n        link(ed[i][0],ed[i][1]),link(ed[i][1],ed[i][0]);\n    dfs(pos[n],0);\n    printf(\"%lld\\n\",dp[pos[n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define int ll\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nVI e[MAXN];\nint a[MAXN],b[MAXN],f[MAXN],sum[MAXN],vis[MAXN],id[MAXN],ans[MAXN];\nint compare(int x,int y) { return a[id[x]]<a[id[y]]; }\nint find(int x) { return f[x]==x?f[x]:f[x]=find(f[x]); }\nsigned main()\n{\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,compare);\n\tfor (int i=1,u,v;i<=m;i++) u=read(),v=read(),e[u].PB(v),e[v].PB(u);\n\tfor (int i=1;i<=n;i++) f[i]=i;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tVI to; int x=id[i];\n\t\tvis[x]=1,sum[x]=b[x];\n\t\tfor (auto v:e[x])\n\t\t{\n\t\t\tif (!vis[v]||find(x)==find(v)) continue;\n\t\t\tto.PB(find(v));\n\t\t\tsum[x]+=sum[find(v)];\n\t\t\tf[find(v)]=x;\n\t\t}\n\t\tans[x]=sum[x]+a[x];\n\t\tfor (auto v:to) ans[x]=min(ans[x],sum[x]-sum[v]+max(a[x],ans[v]));\n\t}\n\tprintf(\"%d\\n\",ans[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 100010\n#define ll long long\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mod 998244353\n#define fi first\n#define pi pair<int, int>\n#define se second\n#define mp make_pair\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\n// head\nint fa[maxn];\nll sz[maxn], ans[maxn];\nint gfa(int a) {\n\tif (fa[a] == a) return a;\n\treturn fa[a] = gfa(fa[a]);\n}\nint n, m;\nvi eg[maxn];\nint a[maxn], b[maxn];\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), \n\t\ta[i] -= b[i];\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\teg[u].pb(v), eg[v].pb(u);\n\t}\n\tvector<pi> r(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tr[i - 1] = mp(a[i], i), \n\t\tsz[i] = b[i];\n\tsort(r.begin(), r.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tint nid = r[i].se;\n\t\tfa[nid] = nid;\n\t\tll nans = max(0, a[nid]);\n\t\tfor (auto v : eg[nid]) {\n\t\t\tif (!fa[v]) continue;\n\t\t\telse {\n\t\t\t\tint nf = gfa(v);\n\t\t\t\tif (nf == nid) continue;\n\t\t\t\tfa[nf] = nid;\n\t\t\t\tnans = min(nans, max(ans[nf], a[nid] - sz[nf]));\n\t\t\t\tsz[nid] += sz[nf];\n\t\t\t}\n\t\t}\n\t\tans[nid] = nans;\n\t}\n\tcout << ans[gfa(1)] + sz[gfa(1)] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define int long long\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR pi p=Q[v].top();Q[v].pop();\n\t\tif(find(p.se)!=find(u))Q[u].push(p);\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n\t\t\tif(s[u]+s[p.se]>=mx)return true;\n\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,++cnt,merge(u,p.se);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nsigned main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%lld%lld\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%lld%lld\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 1e5 + 5;\nconst int mod = 1e9 + 7;\nint n, m;\nvector<int> adj[maxn],adj1[maxn];\nint lab[maxn];\nint FindLab(int u){return lab[u] < 0 ? u : lab[u] = FindLab(lab[u]);}\nint a[maxn],b[maxn];\nll dp[maxn] , sum[maxn];\nvoid dfs(int u){\n    sum[u] = b[u];\n    ll mi = a[u];\n    for(auto c : adj1[u]){\n        dfs(c);\n        sum[u] += sum[c];\n        dp[c] = max(dp[c] , (ll)a[u]);\n        mi = min(mi , -sum[c] + dp[c]);\n    }\n    dp[u] = sum[u] + mi;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    fill_n(lab,maxn,-1);\n    cin >> n >> m;\n    for(int i = 1 ; i <= n ; ++i){\n        cin >> a[i] >> b[i];\n        a[i] = max(0 , a[i] - b[i]);\n    }\n    for(int i = 1 ; i <= m ; ++i){\n        int u , v;cin >> u >> v;\n        adj[u].pb(v);adj[v].pb(u);\n    }\n    vector<int> order(n);iota(order.begin(),order.end(),1);\n    vector<int> id(n + 1);\n    sort(order.begin(),order.end(),[&](const int x , const int y){\n         return a[x] < a[y];\n         });\n    for(int i = 0 ; i < n ; ++i){\n        id[order[i]] = i;\n    }\n    for(auto u : order){\n        for(auto c : adj[u]){\n            c = FindLab(c);\n            if(id[c] < id[u] && c != u){\n                lab[c] = u;\n                adj1[u].pb(c);\n//                cout << u << \" \" << c << endl;\n\n            }\n        }\n    }\n    dfs(order.back());\n    cout << dp[order.back()];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjoint set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nint t1,t2;\n\nint n,m;\n\nstd::vector<int> g[100005];\n\nint a[100005];\nint b[100005];\n\n// disjoint set stuff\nstd::vector<int> todo;\nbool todo2[100005];     // determine if a vertex is in todo\n\nstd::priority_queue<std::pair<int,int> > pq[100005];\nint endval;\nint up[100005];\nint sz[100005];\nlong long money[100005];\nbool active[100005];\n\nint getroot(int u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(int u,int v)\n{\n    up[v]=u;\n    sz[u]+=sz[v];\n    money[u]+=money[v]-endval;\n    active[u]=1;\n    while (!pq[v].empty()) {\n        pq[u].push(pq[v].top());\n        pq[v].pop();\n    }\n}\n\nint join(int u,int v)\n{\n    // return the root of their union\n    u=getroot(u);\n    v=getroot(v);\n    if (u==v) return u;\n    if (sz[u]>=sz[v]) {\n        join2(u,v);\n        return u;\n    }\n    else {\n        join2(v,u);\n        return v;\n    }\n}\n\nbool good(int x)\n{\n    endval=x;\n    memset(active,0,sizeof active);\n    // make the pq\n    for (int i=1; i<=n; i++) {\n        up[i]=i;\n        sz[i]=1;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n        while (!pq[i].empty()) pq[i].pop();\n        for (int j:g[i]) pq[i].push({b[j]-a[j],j});\n    }\n    // do vertices\n    for (int i=1; i<=n; i++) {\n        int u=getroot(i);\n        if (!active[u]) continue;\n        //printf(\"start at %d\\n\",i);\n        // do this vertex\n        while (!pq[u].empty() && -pq[u].top().first<=money[u]) {\n            int v=pq[u].top().second;\n            pq[u].pop();\n            //printf(\"do %d -> %d\\n\",u,v);\n            u=join(u,v);\n        }\n    }\n    // check\n    for (int i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nint lo=0;\nint hi=0x3f3f3f3f;\nint mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (int i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    if (n==1) {\n        if (a[1]-b[1]>0) printf(\"%d\\n\",a[1]-b[1]);\n        else printf(\"0\\n\");\n        return 0;\n    }\n    //good(0); return 0;\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%d %d\\n\",lo,hi);\n    }\n    ans=lo;\n    for (int i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int, int>> L;\nvector<int> X[1 << 17], Y[1 << 17];\nMergeTech UF1, UF2;\nbool used[1 << 17];\n\nvoid dfs1(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (used[X[pos][i]] == true) continue;\n\t\tY[pos].push_back(X[pos][i]);\n\t\tdfs1(X[pos][i]);\n\t}\n}\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\t\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) scanf(\"%lld%lld\", &A[i], &B[i]);\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\t\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tX[r1].push_back(r2);\n\t\t\tX[r2].push_back(r1);\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tdfs1(I[I.size() - 1].second);\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 600);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nstruct UF {\n\tvi e;\n\tUF(int n) : e(n, -1) {}\n\tbool same_set(int a, int b) { return find(a) == find(b); }\n\tint size(int x) { return -e[find(x)]; }\n\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\tvoid join(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a == b) return;\n\t\tif (e[a] > e[b]) swap(a, b);\n\t\te[a] += e[b]; e[b] = a;\n\t}\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    vector<ll> a(n), b(n);\n    rep(i,0,n) cin >> a[i] >> b[i];\n    vector<vi> g(n);\n    rep(i,0,m) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<tuple<ll,ll,int>> os;\n    rep(i,0,n) os.emplace_back(a[i],-b[i],i);\n    sort(all(os));\n    UF uf(n);\n    vector<ll> sum(n), ans(n);\n    int last=-1;\n    vector<bool> vis(n);\n    rep(t,0,n) {\n        int u = get<2>(os[t]);\n        vis[u]=true;\n        int r = u;\n        vi cs;\n        {\n            set<int> ch;\n            for(int v:g[r]) {\n                if(vis[v]) ch.insert(uf.find(v));\n            }\n            for(int v:ch) cs.push_back(v);\n        }\n        for(int v:cs) uf.join(r,v);\n        r = uf.find(r);\n        ll su = b[u];\n        for(int v:cs) su += sum[v];\n        ll best=max(a[u],b[u])+su-b[u];\n        for(int i:cs) {\n            best=min(best,su-b[u]-sum[i]+max(a[u],b[u]+ans[i]));\n        }\n        ans[r]=best;\n        sum[r]=su;\n        last=r;\n    }\n    cout<<ans[last]<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        if (aa.first - aa.second == bb.first - bb.second)\n        {\n            if (abs(aa.first - a[v]) < abs(bb.first - a[v]))\n            {\n                return aa.first > bb.first;\n            }\n            return abs(aa.first - a[v]) < abs(bb.first - a[v]);\n        }\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        //if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 2e5 + 233;\n\nint n, m, id[N];\nlong long A[N], B[N], C[N];\nint vis[N], fa[N];\nlong long f[N], s[N];\n\nint find(int x) {\n  return !fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nstd::vector<int> G[N], T[N];\n\nvoid dfs(int x) {\n  s[x] = B[x], f[x] = T[x].empty() ? std::max(A[x], B[x]) : 1e18;\n  for (int y : T[x])\n    dfs(y), s[x] += s[y];\n  for (int y : T[x])\n    f[x] = std::min(f[x], std::max(f[y], 1ll * C[x]) + s[x] - s[y]);\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 1; i <= n; ++i)\n    scanf(\"%lld %lld\", A + i, B + i), C[i] = A[i] - B[i], id[i] = i;\n  for (int i = 1; i <= n; ++i)\n    C[i] = C[i] < 0 ? 0 : C[i];\n  for (int i = 1; i <= m; ++i) {\n    int x, y; scanf(\"%d %d\", &x, &y);\n    G[x].push_back(y), G[y].push_back(x);\n  }\n  std::sort(id + 1, id + n + 1, [&](int x, int y)\n    { return C[x] < C[y]; });\n  for (int i = 1; i <= n; ++i) {\n    int x = id[i]; vis[x] = 1;\n    for (int y : G[x])\n      if (vis[y] && find(y) != x) {\n        T[x].push_back(find(y));\n        fa[find(y)] = x;\n      }\n  }\n  dfs(id[n]);\n  std::cout << f[id[n]] << std::endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 100005;\nint n, m, fa[N];\nvector<int> g[N];\nll sumb[N], c[N], dp[N];\n\nint find(int x) {\n\treturn !fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tstatic int id[N], rk[N];\n\tfor (int i = 1, a, b; i <= n; ++i) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tid[i] = i;\n\t\tsumb[i] = b;\n\t\tc[i] = max(a - b, 0);\n\t}\n\tfor (int i = 1, u, v; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].push_back(v), g[v].push_back(u);\n\t}\n\tsort(id + 1, id + 1 + n, [](int x, int y) { return c[x] < c[y]; });\n\tfor (int i = 1; i <= n; ++i)\n\t\trk[id[i]] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdp[id[i]] = c[id[i]];\n\t\tfor (int v : g[id[i]]) {\n\t\t\tint j = find(v);\n\t\t\tif (rk[v] < i && j != id[i]) {\n\t\t\t\tfa[j] = id[i];\n\t\t\t\tsumb[id[i]] += sumb[j];\n\t\t\t\tdp[id[i]] = min(dp[id[i]], max(dp[j], c[id[i]] - sumb[j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dp[id[n]] + sumb[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 100005;\nint n, m, q[MX], u, v, p[MX];\nll a[MX], b[MX], dp[MX], s[MX];\nvi adj[MX], to[MX];\nbitset<MX> bs;\nint parent (int a) { return p[a] == a ? a : p[a] = parent(p[a]); }\n\nvoid dfs (int u) {\n\tfor (int v : to[u]) dfs(v), s[u] += s[v];\n\ts[u] += b[u], dp[u] = to[u].size() ? 1e18 : a[u] + b[u];\n\tfor (int v : to[u]) dp[u] = min(dp[u], s[u] - s[v] + max(dp[v], a[u]));\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tiota(p, p+MX, 0);\n\tiota(q, q+MX, 1);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i] - b[i], 0ll);\n\t}\n\n\twhile (m--) {\n\t\tcin >> u >> v;\n\t\tadj[u].pb(v);\n\t\tadj[v].pb(u);\n\t}\n\n\tsort(q, q+n, [&] (int i, int j) {\n\t\treturn a[i] < a[j];\n\t});\n\n\tfor (int i = 0; i < n; i++) {\n\t\tu = q[i];\n\t\tbs[u] = 1; \n\t\tfor (int v : adj[u]) {\n\t\t\tif (parent(u) == parent(v) || !bs[v]) continue;\n\t\t\tv = parent(v);\n\t\t\tto[u].pb(v);\n\t\t\tp[v] = u;\n\t\t}\n\t}\n\n\tdfs(q[n-1]);\n\tcout << dp[q[n-1]] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tint a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].a,&a[i].b);\n\tif(n==1) return printf(\"%d\",max(a[1].a,a[1].b)),0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e15,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e15;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mid+siz[find(1)],r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cstdio>\n# include <algorithm>\nusing namespace std;\nconst int N = 3e5 + 12;\nconst int inf = 0x7fffffff;\nint a[N],b[N],id[N],n,m,head[N],dt,fa[N];bool vis[N];\nlong long f[N],s[N];\nint find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}\nstruct Edge{int to,nex;}edge[N << 2];\nvoid AddEdge(int u,int v){edge[++dt] = (Edge){v,head[u]};head[u] = dt;}\nbool cmp(int x,int y){return a[x] < a[y];}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i = 1;i <= n;i++)scanf(\"%d %d\",&a[i],&b[i]),a[i] = max(a[i] - b[i],0),id[i] = fa[i] = i;\n\tsort(id + 1,id + n + 1,cmp);int u,v;\n\tfor(int i = 1;i <= m;i++)scanf(\"%d %d\",&u,&v),AddEdge(u,v),AddEdge(v,u);\n\tfor(int t = 1;t <= n;t++)\n\t{\n\t\tu = id[t];vis[u] = true;f[u] = a[u];s[u] = b[u];\n\t\tfor(int i = head[u];i;i = edge[i].nex)if(vis[edge[i].to])\n\t\t{\n\t\t\tv = find(edge[i].to);\n\t\t\tif(u == v)continue;\n\t\t\tfa[v] = u;s[u] += s[v];\n\t\t\tf[u] = min(f[u],max(f[v],a[u] - s[v])); \n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[id[n]] + s[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inc(l,i,r) for (int i=l;i<=r;i++)\n#define dec(r,i,l) for (int i=r;i>=l;i--)\n#define SIZE(V) ((int) V.size())\n#define forE(p,u) for (edge *p=head[u];p;p=p->nxt)\n#define forV(i,V) for (int i=0;i<SIZE(V);i++)\n#define pb push_back\n#define In inline\n#define fi first\n#define se second\n#define mp make_pair\n#define It iterator\n#define ___ putchar(10);\n#define cnt(x) __builtin_popcount(x)\n#define show(x) cout << #x << \" = \" << x << endl;\n#define mid ((l+r) >> 1)\n#define N 200100\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<typename T>\ninline void read(T &x) {\n\tstatic char c;\n\tfor (c=getchar();!isdigit(c);c=getchar());\n\tfor (x=0;isdigit(c);c=getchar()) x = (x<<1) + (x<<3) + c - '0';\n}\n\nstruct edge {int to;  edge *nxt;} *head[N], e[N*2];\n\nint edge_tot = 0;\ninline void AE(int u,int v) {\n\thead[u] = &(e[edge_tot++] = (edge) {v,head[u]});\n\thead[v] = &(e[edge_tot++] = (edge) {u,head[v]});\n}\n\nint n, m, A[N], B[N], fa[N];\npii a[N];\nll sumB[N], dp[N];\nvector<int> T[N];\n\nint getfa(int x) {return fa[x] == x ? x : fa[x] = getfa(fa[x]);}\ninline void merge(int x,int y) {fa[getfa(x)] = getfa(y);}\n\nvoid dfs(int u,int from) {\n\tsumB[u] = B[u];\n\tdp[u] = A[u];\n\tforE(p,u) if (p->to != from) {\n\t\tdfs(p->to,u);\n\t\tsumB[u] += sumB[p->to];\n\t\tdp[u] = min(dp[u], max(dp[p->to], A[u] - sumB[p->to]));\n\t}\n}\n\nint main() {\n//\tfreopen(\"rescue.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tread(n);   read(m);\n\tinc(1,i,n) read(A[i]), read(B[i]), a[i] = mp(A[i]-B[i],i), A[i] = max(A[i]-B[i], 0);\n\twhile (m--) {\n\t\tint u, v;  read(u);  read(v);\n\t\tAE(u,v);\n\t}\n\tsort(a+1,a+n+1);\n\t\n\tinc(1,i,n) {\n\t\tfa[a[i].se] = a[i].se;\n\t\tforE(p,a[i].se)\tif (fa[p->to] && getfa(p->to) != getfa(a[i].se)) {\n\t\t\tT[a[i].se].pb(getfa(p->to));\n\t\t\tmerge(p->to, a[i].se);\n\t\t}\n\t}\n\tedge_tot = 0;\n\tmemset(head,0,sizeof(edge*) * (n+1));\n\tinc(1,i,n) forV(j,T[i]) AE(i,T[i][j]);\n\t\n\tdfs(a[n].se, 0);\n\t\n\tprintf(\"%lld\\n\",dp[a[n].se] + sumB[a[n].se]);\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N],s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR int w=Q[v].top().se;Q[v].pop();\n\t\tif(find(w)!=find(u))Q[u].push(pi(dx[w],w));\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tif(h>t)return false;\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\twhile(!Q[u].empty()){\n\t\t\tR int v=Q[u].top().se;\n\t\t\tif(dx[v]>s[u])break;\n\t\t\tQ[u].pop();if(find(v)==find(u))continue;\n\t\t\tv=find(v);\n\t\t\tif(s[u]+s[v]>=mx)return true;\n\t\t\ts[u]+=s[v],fa[v]=find(u),++cnt,merge(u,v);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tfp(i,1,n)cmax(mx,a[i]-b[i]);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tl=1,r=mx;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\nconst int N=100100;\nconst ll INF=1e18;\nint n,m,u,v,o[N],p[N],fa[N],fd[N];\nll ans,a[N],b[N],f[N],sz[N];\nvector<int>ad[N];\nvoid add(int u,int v){ad[u].push_back(v);}\nint fi(int x){return x==fd[x]?x:fd[x]=fi(fd[x]);}\nbool cmp(int x,int y){return a[x]<a[y];}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tFOR(i,1,n) scanf(\"%lld%lld\",&a[i],&b[i]),a[i]-=b[i],o[i]=i;\n\tFOR(i,1,m) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tsort(o+1,o+n+1,cmp);\n\tFOR(i,1,n) p[o[i]]=i,fd[i]=i;\n\tFOR(i,1,n){\n\t\tu=o[i];sz[u]=b[u];\n\t\tfor(int x:ad[u])if(p[v=fi(x)]<i)\n\t\t\tfa[v]=fd[v]=u,sz[u]+=sz[v];\n\t}\n\tans=INF;\n\tROF(i,n,1){\n\t\tu=o[i];\n\t\tf[u]=max(f[fa[u]],a[fa[u]]-sz[u]);\n\t\tans=min(ans,max(a[u],f[u]));\n\t}\n\tcout<<ans+sz[o[n]]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 18], B[1 << 18], U[1 << 18], V[1 << 18];\nlong long Subtree[1 << 18];\nvector<tuple<long long, int, int, int>> L;\nvector<int> Y[1 << 18];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\t//if (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nlong long solve_Donation() {\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(t); cout << r1 << \" \" << t << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(t); cout << r2 << \" \" << t << endl;\n\t\t\t}\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 530);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\treturn minx;\n}\n\nint main() {\n\tlong long cn, cm; cin >> cn >> cm;\n\tvector<pair<long long, long long>> v1(cn, make_pair(0, 0)); for (int i = 0; i < cn; i++) cin >> v1[i].first >> v1[i].second;\n\tvector<pair<long long, long long>> v2(cm, make_pair(0, 0)); for (int i = 0; i < cm; i++) { cin >> v2[i].first >> v2[i].second; v2[i].first--; v2[i].second--; }\n\n\tN = 2 * cn;\n\tfor (int i = 0; i < cn; i++) {\n\t\tA[i * 2] = v1[i].first;\n\t\tB[i * 2 + 1] = v1[i].second;\n\t}\n\tM = cn + cm;\n\tfor (int i = 0; i < cm; i++) {\n\t\tU[i] = v2[i].first * 2 + 1;\n\t\tV[i] = v2[i].second * 2;\n\t}\n\tfor (int i = 0; i < cn; i++) {\n\t\tU[cm + i] = i * 2;\n\t\tV[cm + i] = i * 2 + 1;\n\t}\n\n\tlong long ret = solve_Donation();\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define repi(i, a, b) for (int i = (a); i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ull << (b))\n\nusing namespace std;\nusing i32 = long long;\nusing u32 = unsigned long long;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing vi32 = vector<i32>;\nusing vu32 = vector<u32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf64 = vector<f64>;\nusing vstr = vector<string>;\nusing vvi32 = vector<vi32>;\nusing vvu32 = vector<vu32>;\nusing vvi64 = vector<vi64>;\nusing vvu64 = vector<vu64>;\nusing vvf64 = vector<vf64>;\n\ntemplate<typename T, typename S> void amax(T &x, S y) { if (x < y) x = y; }\ntemplate<typename T, typename S> void amin(T &x, S y) { if (y < x) x = y; }\n\nint n, m;\nvector<vector<int>> edges;\nvector<tuple<int, int, int>> costs; // a, b, u\nvector<bool> go;\n\nbool bfs(int from, int to) {\n  queue<int> q;\n  vector<bool> visited(n + 1, false);\n  q.push(from);\n  while (!q.empty()) {\n    auto u = q.front();\n    q.pop();\n    visited[u] = true;\n    for (auto v: edges[u]) {\n      if (!go[v]) continue;\n      if (visited[v]) continue;\n      if (v == to) return true;\n      q.push(v);\n    }\n  }\n  return false;\n}\n\nbool check(i64 w) {\n  go = vector<bool>(n + 1, true);\n  int now = 0;\n  int idx = 0;\n  for (int i = 0; i < n; i++) {\n    int a, b, u;\n    tie(a, b, u) = costs[i];\n    if (a > w) return false;\n    if (now > 0 && !bfs(now, u)) return false;\n    w -= b;\n    if (w < 0) return false;\n    while (idx < n && get<0>(costs[idx]) > w) {\n      go[get<2>(costs[idx++])] = false;\n    }\n    now = u;\n  }\n  return true;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(16);\n  cin >> n >> m;\n  edges = vector<vector<int>>(n + 1, vector<int>());\n  rep(i, n) {\n    int a, b;\n    cin >> a >> b;\n    costs.push_back(make_tuple(a, b, i + 1));\n  }\n  sort(all(costs), greater<tuple<int, int, int>>());\n  rep(i, m) {\n    int u, v;\n    cin >> u >> v;\n    edges[u].push_back(v);\n    edges[v].push_back(u);\n  }\n  i64 ok = 10e16;\n  i64 ng = get<0>(costs[0]) - 1;\n  while (ok - ng > 1) {\n    i64 mid = (ok + ng) / 2;\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  cout << ok << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,m,fa[100010],a[100010],b[100010];\nvector<int> v[100010];\nll s[100010];\ninline int getf(int x)\n{\n\treturn x==fa[x]?x:fa[x]=getf(fa[x]);\n}\ninline void merge(int x,int y)\n{\n\tx=getf(x);y=getf(y);\n\tfa[x]=y;\n\tif(x!=y)s[y]+=s[x];\n}\npair<int,int> p[100010];\nbool flag[100010];\nll f[100010];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tp[i]=make_pair(a[i]-b[i],i);\n\t}\n\tsort(p+1,p+n+1);\n\tfor(int i=1,a,b;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint pos=p[i].second;\n\t\tf[pos]=max(a[pos]-b[pos],0);\n\t\ts[pos]=b[pos];\n\t\tfor(int &x:v[pos])\n\t\t{\n\t\t\tif(flag[x])\n\t\t\t{\n\t\t\t\tint t=getf(x);\n\t\t\t\tf[pos]=min(f[pos],max(f[t],a[pos]-b[pos]-s[t]));\n\t\t\t}\n\t\t}\n\t\tfor(int &x:v[pos])\n\t\t\tif(flag[x])merge(x,pos);\n\t\tflag[pos]=1;\n\t}\n\tprintf(\"%lld\\n\",f[p[n].second]+s[p[n].second]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = max(0LL, A[i]-B[i]);\n\t\tVs[i].ss = -i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = -Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\n\t\tif(sz > 1) for(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tcat w_mi = max(A[c]+s, B[c]+s+W[comp_adj[j]])-1, w_mx = OVER9000;\n\t\t\tvector< pair<cat, cat> > Vs;\n\t\t\tfor(int k = 0; k < sz; k++)\n\t\t\t\tif(k != j) Vs.push_back(make_pair(W[comp_adj[k]], sumB[comp_adj[k]]));\n\t\t\tsort(begin(Vs), end(Vs));\n\t\t\tvector<bool> vis(sz-2);\n\t\t\tint a = sz-1;\n\t\t\twhile(w_mx-w_mi > 1) {\n\t\t\t\tcat w_cur = (w_mi + w_mx) / 2;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int l = sz-2; l >= 0; l--) {\n\t\t\t\t\tif(vis[l]) continue;\n\t\t\t\t\tif(Vs[l].ff > w_cur) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta = min(a, l-1);\n\t\t\t\t\tif(a >= 0 && Vs[a].ff > w_cur-Vs[l].ss) {\n\t\t\t\t\t\tvis[a] = true;\n\t\t\t\t\t\tw_cur -= Vs[a].ss;\n\t\t\t\t\t\ta--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvis[l] = true;\n\t\t\t\t\tw_cur -= Vs[l].ss;\n\t\t\t\t}\n\t\t\t\tif(ok) w_mx = (w_mi + w_mx) / 2;\n\t\t\t\telse w_mi = (w_mi + w_mx) / 2;\n\t\t\t}\n\t\t\t// cout << j << \" \" << i << endl;\n\t\t\tW[c] = min(W[c], w_mx);\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\t\telse {\n\t\t\tW[c] = min(W[c], max(m+B[c], max(A[c], B[c]+s)));\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(const int&x,const int&y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&C[y]<C[x]) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define M 100010\nusing namespace std;\nstruct EDGE{\n\tll u, v;\n\tll Next;\n}G[M << 1];\nll Head[N];\nll tot = 0;\ninline void Add(ll u, ll v)\n{\n\t++ tot;\n\tG[tot].u = u;\n\tG[tot].v = v;\n\tG[tot].Next = Head[u];\n\tHead[u] = tot;\n}\nstruct Node{\n\tll a, b, num;\n}E[N];\ninline bool cmp(Node x, Node y)\n{\n\treturn x.a - x.b < y.a - y.b;\n}\nll f[N];\nll b[N];\nll w[N];\ninline ll Get(ll u)\n{\n\treturn f[u] == u ? u : f[u] = Get(f[u]);\n}\nbool vis[N];\nll d[N], top;\nint main()\n{\n\tll n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tfor(ll i = 1; i <= n; ++ i)\n\t\tscanf(\"%lld%lld\", &E[i].a, &E[i].b);\n\tfor(ll i = 1; i <= m; ++ i)\n\t{\n\t\tll u, v;\n\t\tscanf(\"%lld%lld\", &u, &v);\n\t\tAdd(u, v);\n\t\tAdd(v, u);\n\t}\n\tfor(ll i = 1; i <= n; ++ i)\n\t{\n\t\tE[i].num = i;\n\t\tb[i] = E[i].b;\n\t\tf[i] = i;\n\t}\n\tsort(E + 1, E + n + 1, cmp);\n\tfor(ll i = 1; i <= n; ++ i)\n\t{\n\t\tvis[E[i].num] = true;\n\t\tll sumb = 0;\n\t\ttop = 0;\n\t\tfor(ll j = Head[E[i].num]; j; j = G[j].Next)\n\t\t{\n\t\t\tll v = G[j].v;\n\t\t\tif(! vis[v])\n\t\t\t\tcontinue;\n\t\t\tll fv = Get(v);\n\t\t\tif(fv != E[i].num)\n\t\t\t{\n\t\t\t\tsumb += b[fv];\n\t\t\t\td[++ top] = fv;\n\t\t\t\tf[fv] = E[i].num;\n\t\t\t}\n\t\t}\n\t\tb[E[i].num] = sumb + E[i].b;\n\t\tw[E[i].num] = 1000000000000000;\n\t\tfor(ll j = 1; j <= top; ++ j)\n\t\t\tw[E[i].num] = min(w[E[i].num], sumb - b[d[j]] + max(w[d[j]] + E[i].b, E[i].a));\n\t\tw[E[i].num] = min(w[E[i].num], sumb + max(E[i].a, E[i].b));\n\t}\n\tprintf(\"%lld\", w[E[n].num]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nclass UnionFind{\nprivate:\n  vector<int> node;\n\npublic:\n  UnionFind(int n){\n    node=vector<int>(n);\n    rep(i,n) node[i]=i;\n  }\n  int root(int x){\n    if(node[x]==x) return x;\n    else return node[x]=root(node[x]);\n  }\n  bool uni(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    node[y]=x;\n    return true;\n  }\n};\n\nstruct sta{\n  LL cost;\n  LL w; \n  LL totalb;\n};\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<LL> a(n), b(n);\n  rep(i,n) cin >> a[i] >> b[i];\n  vector<vector<int>> e(n);\n  int u,v;\n  rep(i,m){\n    cin >> u >> v;\n    e[u-1].push_back(v-1);\n    e[v-1].push_back(u-1);\n  }\n  vector<int> p(n);\n  iota(all(p), 0);\n  sort(all(p),[&](const int &l, const int &r){\n    return a[l]-b[l] < a[r]-b[r];\n  });\n  vector<bool> merged(n, false);\n  UnionFind uf(n);\n  vector<sta> tmp(n);\n  rep(i,n){\n    int x = p[i];\n    merged[x] = true;\n    sta mi = {LINF, 0, 0};\n    for(auto ad:e[x]){\n      if(!merged[ad]) continue;\n      ad = uf.root(ad);\n      if(tmp[ad].cost+max(a[x]-b[x]-tmp[ad].w,0LL)<mi.cost){\n        mi=tmp[ad];\n      }\n    }\n    sta now = {0, 0, 0};\n    if(mi.cost==LINF) now.cost = max(a[x]-b[x],0LL);\n    else now.cost = mi.cost+max(a[x]-b[x]-mi.w,0LL);\n    now.w = max(mi.w,a[x]-b[x])+b[x]-mi.totalb;\n    now.totalb = b[x];\n    for(auto ad:e[x]){\n      if(!merged[ad]) continue;\n      LL t = tmp[uf.root(ad)].totalb;\n      if(uf.uni(x,ad)){\n        now.totalb+=t;\n        now.w+=t;\n      }\n    }\n    tmp[uf.root(x)]=now;\n  }\n  cout << tmp[uf.root(0)].w << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++i)\nusing namespace std;\n\ntemplate <typename tn> void read (tn & a) {\n\ttn x = 0, f = 1; char c = getchar();\n\twhile (c < '0' || c > '9'){ if (c == '-') f = -1; c = getchar(); }\n\twhile (c >= '0' && c <= '9'){ x = x * 10 + c - '0'; c = getchar(); }\n\ta = f == 1 ? x : -x;\n}\n\nconst int MAXN = 100100;\nconst int Ln = 22;\nconst int INF = 2e9;\nll n, m;\nll a[MAXN], b[MAXN];\nvector<int> g[MAXN];\nll f[MAXN], fa[MAXN], bsum[MAXN], p[MAXN];\nbool vis[MAXN];\n\nll find (int x) { return fa[x] == 0 || fa[x] == x ? x : fa[x] = find(fa[x]); }\nbool cmp (int i, int j) { return a[i] < a[j]; }\n\nint main() {\n\tread(n);\n\tread(m);\n\trep(i, 1, n) read(a[i]), read(b[i]);\n\trep(i, 1, m) {\n\t\tint u, v;\n\t\tread(u);\n\t\tread(v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\trep(i, 1, n) {\n\t\ta[i] -= b[i];\n\t\tif (a[i] < 0) a[i] = 0;\n\t\tfa[i] = i;\n\t\tp[i] = i;\n\t\tvis[i] = 0;\n\t}\n\tsort(p + 1, p + 1 + n, cmp);\n\trep(i, 1, n) {\n\t\tint x = p[i];\n\t\tf[x] = a[x];\n\t\tbsum[x] = b[x]; \n\t\tvis[x] = 1;\n\t\trep(j, 0, (int) g[x].size() - 1) {\n\t\t\tint v = g[x][j];\n\t\t\tif (vis[v]) {\n\t\t\t\tint y = find(v);\n\t\t\t\tif (x != y) {\n//\t\t\t\t\tcerr<<\"   \"<<y<<\"\\n\";\n\t\t\t\t\tfa[y] = x;\n\t\t\t\t\tbsum[x] += bsum[y];\n\t\t\t\t\tf[x] = min(f[x], max(f[y], a[x] - bsum[y]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//          cerr<<i<<\" \"<<x<<\" \"<<f[x]<<\"\\n\";\n\t}\n\tcout << f[p[n]] + bsum[p[n]]<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, m, cnt, top, s, maxi, now, fa[Maxn], node[Maxn], sta[Maxn], a[Maxn], b[Maxn], w[Maxn], head[Maxn];\nlong long sum[Maxn], mini[Maxn];\nvector <int> Ve[Maxn];\nbool vis[Maxn];\nstruct edg\n{\n\tint nxt, to;\n}edge[2 * Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs(int u)\n{\n\tmini[u] = 0x3f3f3f3f3f3f3f3f;\n\tsum[u] = b[u];\n\tfor (vector <int> :: iterator it = Ve[u].begin(); it != Ve[u].end(); it++)\n\t{\n\t\tint to = *it;\n\t\tdfs(to);\n\t\tsum[u] += sum[to];\n\t\tmini[u] = min(mini[u], max((long long) w[u], mini[to]) - sum[to]);\n\t}\n\tif (!Ve[u].size()) mini[u] = w[u] + b[u];\n\telse mini[u] += sum[u];\n}\nint get_fa(int x)\n{\n\treturn x == fa[x] ? x : fa[x] = get_fa(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0, a[i] - b[i]), node[i] = fa[i] = i;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t}\n\tsort(node + 1, node + 1 + n, [](int x, int y){return w[x] < w[y];});\n\tfor (int j = 1; j <= n; j++)\n\t{\n\t\tint u = node[j];\n\t\tvis[u] = true;\n\t\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tint to = edge[i].to;\n\t\t\tif (vis[to] && get_fa(to) != u)\n\t\t\t\tVe[u].push_back(get_fa(to)), fa[get_fa(to)] = u;\n\t\t}\n\t}\n\tdfs(node[n]);\n\tprintf(\"%lld\", mini[node[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N,M;\nint32_t A[100000],B[100000];\n\n#include <vector>\n\nclass union_find\n{\nprivate:\n\tstd::vector<int>parent;\n\tstd::vector<int>rank;\npublic:\n\tunion_find(int siz)\n\t{\n\t\tparent.resize(siz);\n\t\trank.resize(siz);\n\t\tfor (int i = 0; i < siz; ++i)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tvoid unite(int x, int y)\n\t{\n\t\tint xr = find(x);\n\t\tint yr = find(y);\n\t\tif (rank[xr] > rank[yr])\n\t\t{\n\t\t\tparent[yr] = xr;\n\t\t}\n\t\telse if (rank[xr] > rank[yr])\n\t\t{\n\t\t\tparent[xr] = yr;\n\t\t}\n\t\telse if (xr != yr)\n\t\t{\n\t\t\tparent[yr] = xr;\n\t\t\t++rank[xr];\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\tbool check(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\n\n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n\nusing COST_T = uint32_t;\nstruct edge {\n\tuint32_t to;\n\tedge() {}\n\tedge(uint32_t to_)\n\t\t:to(to_) {}\n};\nstd::vector<edge> graph[100000];\n\n\nuint32_t getmoney[100000];\nusing P = std::pair<COST_T, uint32_t>;\nusing P_que = std::priority_queue<P, std::vector<P>, std::greater<P>>;\nP_que frontline[100000];\n\nbool Dijkstra(uint32_t PENALTY_MAX)\n{\n\tunion_find tree(N);\n\tfor (uint32_t i = 0; i < N; i++)\n\t{\n\t\tgetmoney[i] = PENALTY_MAX + B[i];\n\t\tfrontline[i] = P_que{};\n\t\tfor (auto& e : graph[i]) {\n\t\t\tfrontline[i].emplace(A[e.to]-B[e.to], e.to);\n\t\t}\n\t}\n\n\tfor (uint32_t START = 0; START < N; START++)\n\t{\n\t\tif (tree.find(START) != START) { continue; }\n\t\tif (getmoney[START] < A[START]) { continue; }\n\n\n\t\twhile(!frontline[tree.find(START)].empty())\n\t\t{\n\t\t\tauto v = frontline[tree.find(START)].top(); frontline[tree.find(START)].pop();\n\n\t\t\tif (tree.check(START, v.second)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (v.first > getmoney[tree.find(START)]) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tP_que frontline_next;\n\t\t\tauto x = tree.find(START);\n\t\t\tauto y = tree.find(v.second);\n\t\t\tif (frontline[x].size() < frontline[y].size()) {\n\t\t\t\tstd::swap(x, y);\n\t\t\t}\n\t\t\twhile (!frontline[y].empty()) {\n\t\t\t\tfrontline[x].emplace(frontline[y].top());\n\t\t\t\tfrontline[y].pop();\n\t\t\t}\n\t\t\tauto getmoney_next = getmoney[x] + getmoney[y] - PENALTY_MAX;\n\n\t\t\ttree.unite(START, v.second);\n\t\t\tfrontline[tree.find(START)] = std::move(frontline_next);\n\t\t\tgetmoney[tree.find(START)] = std::move(getmoney_next);\n\t\t}\n\t\tif (frontline[tree.find(START)].empty()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N>>M;\n\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> A[i] >> B[i];\n\t}\n\tfor (size_t i = 0; i < M; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a].emplace_back(b);\n\t\tgraph[b].emplace_back(a);\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = 1000000000, ng_range = -1;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\n\t\tif (Dijkstra(mid)) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << ok_range << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "// by Balloons\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define mpr make_pair\n#define debug() puts(\"okkkkkkkk\")\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n\nusing namespace std;\n\ntypedef long long LL;\n#define int LL\n\nconst int inf = 1e9,maxn=3e5+5;\n\nint n,m,a[maxn],b[maxn],ra[maxn],dp[maxn];\nstruct edges{\n\tint to,nxt;\n}ed[maxn<<1];\nvector<int>son[maxn];\nint head[maxn],ecnt=0,id[maxn],fa[maxn],c[maxn],sz[maxn];\nvoid add(int x,int y){ed[++ecnt].to=y;ed[ecnt].nxt=head[x];head[x]=ecnt;}\nint find(int x){return fa[x] == x?fa[x]:fa[x] = find(fa[x]);}\nint cmp(int x,int y){return c[x] < c[y];}\nvoid dfs1(int x){\n\tsz[x] += b[x];\n\tfor(int i=0;i<son[x].size();i++){\n\t\tint u=son[x][i];\n\t\tdfs1(u);\n\t\tsz[x] += sz[u];\n\t}\n}\n\nvoid dfs2(int x){\n\tif(son[x].size() == 0){\n\t\tdp[x] = b[x] + c[x];\n\t\treturn ;\n\t}\n\tdp[x] = 1e18;\n\tfor(int i=0;i<son[x].size();i++){\n\t\tint u=son[x][i];\n\t\tdfs2(u);\n\t\tdp[x] = min(sz[x] - sz[u] + max(dp[u],c[x]),dp[x]);\n\t}\n}\n\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tint u=id[i];\n\t\tfor(int j=head[u];~j;j=ed[j].nxt){\n\t\t\tint v=ed[j].to;int fv = find(v), fu = find(u);\n\t\t\tif(ra[fv] < ra[u] && fv != u){\n\t\t\t\tson[u].push_back(fv);\n\t\t\t\tfa[fv] = u;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tmemset(head,-1,sizeof head);\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld%lld\",&a[i],&b[i]), fa[i]=i, id[i]=i, c[i] = max(a[i]-b[i],0ll);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;scanf(\"%lld%lld\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++)ra[id[i]] = i;\n//\tfor(int i=1;i<=n;i++)printf(\"%d \",c[i]);puts(\"\");\n//\tfor(int i=1;i<=n;i++)printf(\"%d \",id[i]);puts(\"\");\n\t\n\tinit();\n\tdfs1(id[n]);\n\tdfs2(id[n]);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\nconst ll MOD=1e9+7;\n\nint N;\nint M;\nLL ans;\nLL A[114514];\nLL B[114514];\nLL C[114514];\nbool used[114514];\nvector<int> es[114514];\npriority_queue<pll, vector<pll>, greater<pll>> order;\n\nstruct UfData {\n  int parsz;\n  LL exc;\n  LL bsum;\n  LL W;\n\n  UfData() : parsz(-1) {\n    W = 0;\n    bsum = 0;\n    exc = 0;\n  }\n\n  void Merge(const UfData &d, int u, int v) {\n    parsz += d.parsz;\n\n    LL a = exc + max(C[v] - W, 0LL);\n    LL b = d.exc + max(C[u] - d.W, 0LL);\n    if (a < b) {\n      W = max(W, C[v]) + d.bsum;\n    } else if (a > b) {\n      W = max(d.W, C[u]) + bsum;\n    } else {\n      LL f = max(W, C[v]) + d.bsum;\n      LL g = max(d.W, C[u]) + bsum;\n      W = max(f, g);\n    }\n\n    exc = min(a, b);\n    bsum += d.bsum;\n    // w += d.w;\n  }\n};\n\nstruct UnionFind {\n  vector<UfData> dat;\n\n  UnionFind() {}\n  UnionFind(int n) {\n    Init(n);\n  }\n\n  void Init(int n) {\n    dat.assign(n, UfData());\n  }\n\n  int Root(int v) {\n    if (dat[v].parsz < 0) return v;\n    return dat[v].parsz = Root(dat[v].parsz);\n  }\n\n  bool Unite(int u, int v) {\n    int p = Root(u);\n    int q = Root(v);\n    if (p == q) return false;\n\n    if (dat[p].parsz > dat[q].parsz) {\n      swap(p, q);\n      swap(u, v);\n    }\n\n    dat[p].Merge(dat[q], u, v);\n    dat[q].parsz = p;\n\n    return true;\n  }\n\n  bool Same(int u, int v) {\n    return Root(u) == Root(v);\n  }\n\n  int Size(int v) {\n    return -dat[Root(v)].parsz;\n  }\n\n  UfData& Data(int v) {\n    return dat[Root(v)];\n  }\n};\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    scanf(\"%lld%lld\", &A[i], &B[i]);\n    C[i] = max(A[i]-B[i], 0LL);\n    order.push(pll(C[i], i));\n    ans += B[i];\n  }\n\n  rep(i, M) { \n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    --u;\n    --v;\n    es[u].emplace_back(v);\n    es[v].emplace_back(u);\n  }\n\n  UnionFind uf(N);\n  rep(v, N) {\n    auto &d = uf.Data(v);\n    d.bsum = B[v];\n    if (A[v] > B[v]) {\n      d.exc = A[v] - B[v];\n      d.W = A[v];\n    } else {\n      d.exc = 0;\n      d.W = B[v];\n    }\n  }\n\n  while (!order.empty()) {\n    auto p = order.top(); order.pop();\n    int v = p.Y;\n    //printf(\"p: %lld %d\\n\", p.X, v);\n    used[v] = true;\n    for (int u : es[v]) {\n      if (!used[u]) continue;\n      //printf(\"uniting %d, %d\\n\", u, v);\n\n      uf.Unite(u, v);\n    }\n  }\n\n  auto &d = uf.Data(0);\n  assert(d.bsum == ans);\n  printf(\"%lld\\n\", d.bsum + d.exc);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m;\nint a[maxn],b[maxn],id[maxn];\nstruct edge{int v,nxt;}e[maxn<<1];\nint head[maxn],ecnt=0;\nvoid add(int u,int v)\n{\n\te[++ecnt]=(edge){v,head[u]},head[u]=ecnt;\n\te[++ecnt]=(edge){u,head[v]},head[v]=ecnt;\n}\nbool cmp(const int &x,const int &y){return a[x]<a[y];}\nvector<int>G[maxn];\nint fa[maxn];\nlong long sum[maxn],dp[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dfs(int u,int pre)\n{\n\tsum[u]+=b[u];\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t\tsum[u]+=sum[v];\n\t}\n\tdp[u]=sum[u]+a[u];\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+dp[v]);\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),a[i]=max(0,a[i]-b[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=id[i];\n\t\tfor(auto v:G[u])\n\t\tif(find(u)!=find(v))\n\t\t{\n\t\t\tadd(u,v);\n\t\t\tfa[find(u)]=find(v);\n\t\t}\n\t}\n\tdfs(id[n],0);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define INF 3e15\n#define mod 1000000007\n#define eps 1e-6\n#define abs(x) ((x)>=0?(x):-(x))\n#define y1 solai\n#define fi first\n#define se second\ntypedef long long ll;\nvoid read(ll &x)\n{\n\tscanf(\"%lld\",&x);\n}\nvoid read(ll &x, ll &y)\n{\n\tscanf(\"%lld%lld\",&x,&y);\n}\nvoid read(ll &x, ll &y, ll &z)\n{\n\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n}\nvoid print(ll x)\n{\n\tprintf(\"%lld \",x);\n}\nvoid println(ll x)\n{\n\tprintf(\"%lld\\n\",x);\n}\nconst ll N=100000;\nll n,m,x,y,l,r,mid,ans,sum,a[N+10],b[N+10],li[N+10],w[N+10],p[N+10],ra[N+10],su[N+10];\nvector<ll>v[N+10];\nset<pair<ll,ll> >s[N+10];\n/*ll fin(ll a)\n{\n\tif(a==p[a])\n\t\treturn a;\n\treturn p[a]=fin(p[a]);\n}\nvoid uni(ll a, ll b)\n{\n\ta=fin(a),b=fin(b);\n\tif(a==b)\n\t\treturn;\n\tif(r[a]>r[b])\n\t\tr[a]+=r[b],su[a]+=su[b],p[b]=a;\n\telse\n\t\tr[b]+=r[a],su[b]+=su[a],p[a]=b;\n}\nvoid dfs(ll x)\n{\n\tw[x]=1;\n\tll rt=fin(x);\n\tsu[rt]+=b[x];\n\tfor(ll to:v[x])\n\t\tif(fin(x)!=fin(to))\n\t\t\ts[rt].insert({a[to]-b[to],to});\n\twhile(!s[rt].empty())\n\t{\n\t\tll need=s[rt].begin()->fi,to=s[rt].begin()->se;\n\t\tif(fin(x)==fin(to))\n\t\t\ts[rt].erase(s[rt].begin());\n\t\telse if(fin(x)!=fin(to)&&su[rt]>=need)\n\t\t{\n\t\t\tuni(rt,s[rt].begin()->se);\n\t\t\tdfs(s[rt].begin()->se);\n\t\t\trt=fin(x);\n\t\t\ts[rt].erase(s[rt].begin());\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n}*/\nbool cmp(ll x, ll y)\n{\n\treturn a[x]-b[x]<a[y]-b[y];\n}\nint main()\n{\n\t//freopen(\"c.cpp\",\"r\",stdin);\n \n\tcin>>n>>m;\n\tfor(ll i=1;i<=n;i++)\n\t\tread(a[i],b[i]),sum+=b[i],li[i]=i,p[i]=i,ra[i]=1,su[i]=b[i];\n\tfor(ll i=1;i<=m;i++)\n\t\tread(x,y),v[x].pb(y),v[y].pb(x);\n\tsort(li+1,li+n+1,&cmp);\n\tll res=INF;\n\tll t=ll(1e6)/(n+m);\n\tt*=5;\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0;\n\t\tans=0;\n\t\tq.push({-a[li[i]]+b[li[i]],li[i]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0,cur=rand()%n+1;\n\t\tans=0;\n\t\tq.push({-a[li[cur]]+b[li[cur]],li[cur]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\t/*for(ll i=1;i<=n;i++)\n\t\tif(!w[li[i]])\n\t\t\tans=a[li[i]]-b[li[i]],dfs(li[i]);*/\n\tcout<<res+sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing LL = long long;\n\nconst int N = 100000;\n\nstruct Info\n{\n    LL sum, need;\n};\n\nint n, m, a[N], b[N], ord[N], par[N];\nInfo info[N];\nstd::vector<int> graph[N];\n\nbool by_a(int i, int j)\n{\n    return a[i] < a[j];\n}\n\nint find(int u)\n{\n    if (par[u] != u) {\n        par[u] = find(par[u]);\n    }\n    return par[u];\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\n#endif\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d%d\", a + i, b + i);\n        if (a[i] < b[i]) {\n            a[i] = b[i];\n        }\n        ord[i] = i;\n    }\n    for (int i = 0; i < m; ++ i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        u --;\n        v --;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    std::sort(ord, ord + n, by_a);\n    LL need = 0;\n    memset(par, -1, sizeof(par));\n    for (int idx = 0; idx < n; ++ idx) {\n        int r = ord[idx];\n        par[r] = r;\n        std::vector<Info> sons;\n        LL tot_sum = 0;\n        for (int v : graph[r]) {\n            if (~par[v] && find(r) != find(v)) {\n                int u = find(v);\n                sons.push_back(info[u]);\n                tot_sum += info[u].sum;\n                par[u] = r;\n            }\n        }\n        need = tot_sum + a[r];\n        for (auto s : sons) {\n            need = std::min(need, tot_sum - s.sum + std::max((LL)a[r], s.need + b[r]));\n        }\n        info[r].sum = tot_sum + b[r];\n        info[r].need = need;\n    }\n    printf(\"%lld\\n\", need);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m;\nint a[maxn],b[maxn],ord[maxn];\nbool ok[maxn],occ[maxn];\nvector<int>edge[maxn],vec[maxn];\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nnamespace Dsu{\n\tint f[maxn],rk[maxn];\n\tll v[maxn]; \n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\trk[i]=1;\n\t\t\tv[i]=b[i];\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(rk[x]>rk[y])swap(x,y);\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t\tif(rk[x]==rk[y])rk[y]++;\n\t}\n}\n\nvoid fix(int x,int y){\n\trep(i,int(vec[x].size())){\n\t\tif(ok[vec[x][i]])continue;\n\t\tok[vec[x][i]]=true;\n\t\tint ori=Dsu::find(vec[x][i]);\n\t\tDsu::merge(vec[x][i],y);\n\t\tfix(ori,y);\n\t}\n\tvec[x].clear();\n}\n\nbool check(ll val){\n\tREP(i,n)vec[i].clear(),ok[i]=occ[i]=false;\n\tDsu::init();\n\tREP(i,n){\n\t\tint x=ord[i];\n\t\tocc[x]=true;\n\t\tif(val+b[x]>=a[x])ok[x]=true;\n\t\trep(j,int(edge[x].size())){\n\t\t\tint y=edge[x][j];\n\t\t\tif(!occ[y])continue;\n\t\t\tll nowx=Dsu::v[Dsu::find(x)]+val;\n\t\t\tll nowy=Dsu::v[Dsu::find(y)]+val;\n\t\t\tif((ok[y]&&nowy+b[x]>=a[x])||(ok[x]&&nowx+b[y]>=a[y])){\n\t\t\t\tok[x]=ok[y]=true;\n\t\t\t\tint orix=Dsu::find(x),oriy=Dsu::find(y);\n\t\t\t\tDsu::merge(x,y);\n\t\t\t\tfix(orix,x);\n\t\t\t\tfix(oriy,y);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvec[Dsu::find(y)].pb(x);\n\t\t\t\tvec[Dsu::find(x)].pb(y);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e9);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst int N = 1e5 + 10;\nint n;\nll a[N], b[N];\nVI e[N];\n\nll score(int i){\n    return b[i] - a[i];\n}\n\nll calc(int r){\n    priority_queue<PL> que;\n    que.push(PL(score(r), r));\n    ll sum = max(a[r], b[r]), ans = sum;\n    VI visit(n);\n    visit[r] = 1;\n    while (!que.empty()){\n        PL p = que.top();\n        que.pop();\n        int now = p.second;\n        for (int next : e[now]){\n            if (visit[next]) continue;\n            visit[next] = 1;\n            sum = max(sum + b[next], a[next]);\n            ans = max(ans, sum);\n            que.push(PL(score(next), next));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int m;\n    cin >> n >> m;\n    REP(i,n){\n        a[i] = in(), b[i] = in();\n    }\n    REP(i,m){\n        int u = in() - 1, v = in() - 1;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n\n    vector<PL> p(n);\n    REP(i,n) p[i] = PL(calc(i), i);\n    sort(ALL(p));\n    reverse(ALL(p));\n\n    ll ans = 1e18;\n    REP(i,min((int)p.size(), 90)){\n        ans = min(ans, calc(p[i].second));\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,m,a[N],b[N],c[N],s[N],f[N],tot,head[N],nex[N],to[N];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dp[N],sum[N];\nbool vis[N];\nint getf(int x){return f[x]==x?x:f[x]=getf(f[x]);}\nbool cmp(int a,int b){return c[a]<c[b];}\nvector<int>e[N];\nvoid dfs(int u)\n{\n    sum[u]=b[u];\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];dfs(v);\n        sum[u]+=sum[v];\n    }\n    dp[u]=sum[u]+c[u];\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];\n        dp[u]=min(dp[u],sum[u]-sum[v]+max(dp[v],(ll)c[u]));\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&a[i],&b[i]),c[i]=max(a[i]-b[i],0),s[i]=f[i]=i;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    sort(s+1,s+1+n,cmp);\n    for(int i=1;i<=n;i++)\n    {\n        int x=s[i];vis[x]=true;\n        for(int j=0;j<e[x].size();j++)\n        {\n            int y=e[x][j];if(!vis[y])continue;\n            y=getf(y);\n            if(y!=x)\n            {\n                f[y]=x;\n                add(x,y);\n            }\n        }\n    }\n    dfs(s[n]);\n    printf(\"%lld\\n\",dp[s[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define pb push_back\n#define mp make_pair\n#define Chkmax(a,b) a=a>b?a:b\n#define Chkmin(a,b) a=a<b?a:b\ntypedef unsigned long long uint64;\ntypedef unsigned int uint32;\ntypedef long long ll;\n\nusing namespace std;\n\nnamespace IO\n{\n    const uint32 Buffsize=1<<15,Output=1<<23;\n    static char Ch[Buffsize],*S=Ch,*T=Ch;\n    inline char getc()\n    {\n        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);\n    }\n    static char Out[Output],*nowps=Out;\n    \n    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}\n\n    template<typename T>inline void read(T&x)\n    {\n        x=0;static char ch;T f=1;\n        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;\n        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);\n        x*=f;\n    }\n\n    template<typename T>inline void write(T x,char ch='\\n')\n    {\n        if(!x)*nowps++='0';\n        if(x<0)*nowps++='-',x=-x;\n        static uint32 sta[111],tp;\n        for(tp=0;x;x/=10)sta[++tp]=x%10;\n        for(;tp;*nowps++=sta[tp--]^48);\n        *nowps++=ch;\n    }\n}\nusing namespace IO;\n\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n    FILE*DSA=freopen(\"water.in\",\"r\",stdin);\n    FILE*SDU=freopen(\"water.out\",\"w\",stdout);\n#endif\n}\n\nconst int MAXN=1e5+7;\n\nstatic int n,m;\n\nvector<int>ed[MAXN];\n\nstatic int a[MAXN],b[MAXN];\n\nvoid init()\n{\n\tread(n);read(m);\n\tRep(i,1,n)read(a[i]),read(b[i]),a[i]=max(0,a[i]-b[i]);\n\tstatic int u,v,w;\n\tRep(i,1,m)read(u),read(v),ed[u].pb(v),ed[v].pb(u);\n}\n\nstatic ll dp[MAXN],sm[MAXN];\n\nstatic int fa[MAXN],sta[MAXN];\n\ninline int Find(int u){return u==fa[u]?u:fa[u]=Find(fa[u]);}\n\ninline void getdp(int u,bool z)\n{\n\tsm[u]=b[u];dp[u]=a[u];\n\tfor(register int v:ed[u])\n\t{\n\t\tint ver=Find(v);\n\t\tif(ver!=u&&(a[ver]<a[u]||a[ver]==a[u]&&z))\n\t\t{\n\t\t\tChkmin(dp[u],max(dp[ver],a[u]-sm[ver]));\n\t\t\tsm[u]+=sm[ver];\n\t\t\tfa[ver]=u;\n\t\t}\n\t}\n}\n\ninline bool cmp(int x,int y){return a[x]<a[y];}\n\ninline void solve()\n{\n\tRep(i,1,n)fa[i]=sta[i]=i;sort(sta+1,sta+n+1,cmp);\n\ta[0]=-1;\n\tRep(i,1,n)getdp(sta[i],a[sta[i]]!=a[sta[i+1]]);\n\tcout<<sm[sta[n]]+dp[sta[n]]<<endl;\n}\n\nint main()\n{\n\tinit();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nint rt[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nstruct pt{int a,b,id;}w[MAXN];\nint n,m,A[MAXN],B[MAXN];\nbool cmp(pt n1,pt n2){return n1.a!=n2.a?n1.a<n2.a:n1.b>n2.b;}\nvector<int> vec[MAXN];\nLL sum[MAXN];\nvoid init(int x)\n{\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)init(a[k].y),sum[x]+=sum[a[k].y];\n}\nLL ans;\nvoid cal(int x,LL ls1,LL ls2)//留下来的速度  上面会用掉的速度 \n{\n\tif(x==10)\n\t{\n\t\tint gg;\n\t\tgg++;\n\t}\n\tLL down=sum[x]-B[x];//不考虑我走完要多少速度 \n\tLL nx=max(ls1,(LL)max(A[x],B[x]));\n\tLL canuse=min(down,nx-max(A[x],B[x]));//可以提供给子树的 \n\tans=min(ans,nx-ls1+down-canuse+ls2);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tcal(y,nx-B[x]-min(canuse,down-sum[y]),down-sum[y]+ls2+nx-ls1-min(canuse,down-sum[y]));\n\t}\n}\nint ri[MAXN];\nbool is[MAXN];\nint main()\n{\n//\tfreopen(\"subtask_1_09.in\",\"r\",stdin);\n//\tfreopen(\"rescue.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)w[i].a=A[i]=read(),w[i].b=B[i]=read(),w[i].id=i;\n\tsort(w+1,w+1+n,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(y);vec[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tis[w[i].id]=true; \n\t\tfor(int j=0;j<vec[w[i].id].size();j++)\n\t\t{\n\t\t\tint x=vec[w[i].id][j];\n\t\t\tint p=findrt(w[i].id),q=findrt(x);\n\t\t\tif(p!=q&&is[q])ins(w[i].id,q),ri[q]++,rt[q]=p;\n\t\t}\n\t}\n//\tfor(int i=1;i<=len;i++)printf(\"YES %d %d\\n\",a[i].x,a[i].y);\n//\tfor(int i=1;i<=n;i++)pr1(A[i]),pr2(B[i]);\n\tint root;\n\tfor(int i=1;i<=n;i++)if(!ri[i])root=i;\n\tinit(root);\n\tans=(1LL<<63-1);\n\tcal(root,0,0);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjoint set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nint t1,t2;\n\nint n,m;\n\nstd::vector<int> g[100005];\n\nint a[100005];\nint b[100005];\n\n// disjoint set stuff\nstd::vector<int> todo;\nbool todo2[100005];     // determine if a vertex is in todo\n\nstd::priority_queue<std::pair<int,int> > pq[100005];\nint endval;\nint up[100005];\nint sz[100005];\nlong long money[100005];\nbool active[100005];\n\nint getroot(int u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(int u,int v)\n{\n    up[v]=u;\n    sz[u]+=sz[v];\n    money[u]+=money[v]-endval;\n    active[u]=1;\n    while (!pq[v].empty()) {\n        pq[u].push(pq[v].top());\n        pq[v].pop();\n    }\n}\n\nint join(int u,int v)\n{\n    // return the root of their union\n    u=getroot(u);\n    v=getroot(v);\n    if (u==v) return u;\n    if (sz[u]>=sz[v]) {\n        join2(u,v);\n        return u;\n    }\n    else {\n        join2(v,u);\n        return v;\n    }\n}\n\nbool good(int x)\n{\n    endval=x;\n    memset(active,0,sizeof active);\n    // make the pq\n    for (int i=1; i<=n; i++) {\n        up[i]=i;\n        sz[i]=1;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n        while (!pq[i].empty()) pq[i].pop();\n        for (int j:g[i]) pq[i].push({b[j]-a[j],j});\n    }\n    // do vertices\n    for (int i=1; i<=n; i++) {\n        int u=getroot(i);\n        if (!active[u]) continue;\n        //printf(\"start at %d\\n\",i);\n        // do this vertex\n        while (!pq[u].empty() && -pq[u].top().first<=money[u]) {\n            int v=pq[u].top().second;\n            pq[u].pop();\n            //printf(\"do %d -> %d\\n\",u,v);\n            u=join(u,v);\n        }\n    }\n    // check\n    for (int i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nint lo=0;\nint hi=0x3f3f3f3f;\nint mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (int i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    if (n==1) {\n        if (a[1]>b[1]) printf(\"%d\\n\",a[1]);\n        else printf(\"%d\\n\",b[1]);\n        return 0;\n    }\n    //good(0); return 0;\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%d %d\\n\",lo,hi);\n    }\n    ans=lo;\n    for (int i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\ntemplate <int N = 100010>\nstruct UF{\n\tint par[N],r[N];\n\tll sum[N];\n\tpriority_queue<P> *que[N];\n\tUF(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tvoid init(){\n\t\tfor(int i = 0 ; i < N ; i ++){\n\t\t\tpar[i] = i;\n\t\t\tr[i] = 0;\n\t\t\tsum[i] = 0;\n\t\t\tif(que[i] != nullptr)delete que[i];\n\t\t\tque[i] = new priority_queue<P>;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unit_(int x,int y){\n\t\tpar[x] = y;\n\t\tsum[y] += sum[x];\n\t\tif(que[x]->size() < que[y]->size()){\n\t\t\twhile(!que[x]->empty()){\n\t\t\t\tP p = que[x]->top(); que[x]->pop();\n\t\t\t\tque[y]->push(p);\n\t\t\t}\n\t\t\tdelete que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\telse {\n\t\t\twhile(!que[y]->empty()){\n\t\t\t\tP p = que[y]->top(); que[y]->pop();\n\t\t\t\tque[x]->push(p);\n\t\t\t}\n\t\t\tdelete que[y];\n\t\t\tque[y] = que[x];\n\t\t\tque[x] = nullptr;\n\t\t}\n\t\tif(r[x] == r[y])r[y] ++;\n\t}\n\tvoid unit(int x,int y){\n\t\tif(same(x,y))return;\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(r[x] < r[y]){\n\t\t\tunit_(x,y);\n\t\t}\n\t\telse {\n\t\t\tunit_(y,x);\n\t\t}\n\t}\n\tvoid run(int v,int w){\n\t\twhile(1){\n\t\t\tv = find(v);\n\t\t\tif(que[v]->empty())break;\n\t\t\tP p = que[v]->top();\n\t\t\tif(find(p.sc) == v)que[v]->pop();\n\t\t\telse if(p.fr+sum[v]+w >= 0){\n\t\t\t\tque[v]->pop();\n\t\t\t\tunit(v,p.sc);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n};\n\nUF<100010> uf;\n\nint main(){\n\tstatic int n,m;\n\tstatic int a[100010],b[100010];\n\tstatic int u[100010],v[100010];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t}\n\tfor(int i = 0 ; i < m ; i ++){\n\t\tscanf(\"%d%d\",&u[i],&v[i]);\n\t\tu[i] --;\n\t\tv[i] --;\n\t}\n\t\n\tif(n == 1){\n\t\tcout << max( a[0] , b[0] ) << endl;\n\t\treturn 0;\n\t}\n\t\n\tll l = 0, r = 1000000000;\n\twhile(l<r){\n\t\tint mi = (l+r)/2;\n\t\tuf.init();\n\t\tfor(int i = 0 ; i < m ; i ++){\n\t\t\tuf.que[u[i]]->push(P(b[v[i]]-a[v[i]],v[i]));\n\t\t\tuf.que[v[i]]->push(P(b[u[i]]-a[u[i]],u[i]));\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tuf.sum[i] = b[i];\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tif(a[i] <= b[i]+mi)uf.run(i,mi);\n\t\t}\n\t\tint root = uf.find(0);\n\t\tbool ok = true;\n\t\tfor(int i = 0 ; i < n ; i ++){\n\t\t\tok &= uf.find(i) == root;\n\t\t}\n\t\tif(ok)r = mi;\n\t\telse l = mi+1;\n\t}\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tl += b[i];\n\t}\n\tcout << l << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define INF 3e15\n#define mod 1000000007\n#define eps 1e-6\n#define abs(x) ((x)>=0?(x):-(x))\n#define y1 solai\n#define fi first\n#define se second\ntypedef long long ll;\nvoid read(ll &x)\n{\n\tscanf(\"%lld\",&x);\n}\nvoid read(ll &x, ll &y)\n{\n\tscanf(\"%lld%lld\",&x,&y);\n}\nvoid read(ll &x, ll &y, ll &z)\n{\n\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n}\nvoid print(ll x)\n{\n\tprintf(\"%lld \",x);\n}\nvoid println(ll x)\n{\n\tprintf(\"%lld\\n\",x);\n}\nconst ll N=100000;\nll n,m,x,y,l,r,mid,ans,sum,a[N+10],b[N+10],li[N+10],w[N+10],p[N+10],ra[N+10],su[N+10];\nvector<ll>v[N+10];\nset<pair<ll,ll> >s[N+10];\n/*ll fin(ll a)\n{\n\tif(a==p[a])\n\t\treturn a;\n\treturn p[a]=fin(p[a]);\n}\nvoid uni(ll a, ll b)\n{\n\ta=fin(a),b=fin(b);\n\tif(a==b)\n\t\treturn;\n\tif(r[a]>r[b])\n\t\tr[a]+=r[b],su[a]+=su[b],p[b]=a;\n\telse\n\t\tr[b]+=r[a],su[b]+=su[a],p[a]=b;\n}\nvoid dfs(ll x)\n{\n\tw[x]=1;\n\tll rt=fin(x);\n\tsu[rt]+=b[x];\n\tfor(ll to:v[x])\n\t\tif(fin(x)!=fin(to))\n\t\t\ts[rt].insert({a[to]-b[to],to});\n\twhile(!s[rt].empty())\n\t{\n\t\tll need=s[rt].begin()->fi,to=s[rt].begin()->se;\n\t\tif(fin(x)==fin(to))\n\t\t\ts[rt].erase(s[rt].begin());\n\t\telse if(fin(x)!=fin(to)&&su[rt]>=need)\n\t\t{\n\t\t\tuni(rt,s[rt].begin()->se);\n\t\t\tdfs(s[rt].begin()->se);\n\t\t\trt=fin(x);\n\t\t\ts[rt].erase(s[rt].begin());\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n}*/\nbool cmp(ll x, ll y)\n{\n\treturn a[x]-b[x]<a[y]-b[y];\n}\nint main()\n{\n\t//freopen(\"c.cpp\",\"r\",stdin);\n \n\tcin>>n>>m;\n\tfor(ll i=1;i<=n;i++)\n\t\tread(a[i],b[i]),sum+=b[i],li[i]=i,p[i]=i,ra[i]=1,su[i]=b[i];\n\tfor(ll i=1;i<=m;i++)\n\t\tread(x,y),v[x].pb(y),v[y].pb(x);\n\tsort(li+1,li+n+1,&cmp);\n\tll res=INF;\n\tll t=ll(1e7)/(n+m);\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0;\n\t\tans=0;\n\t\tq.push({-a[li[i]]+b[li[i]],li[i]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0,cur=rand()%n+1;\n\t\tans=0;\n\t\tq.push({-a[li[cur]]+b[li[cur]],li[cur]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\t/*for(ll i=1;i<=n;i++)\n\t\tif(!w[li[i]])\n\t\t\tans=a[li[i]]-b[li[i]],dfs(li[i]);*/\n\tcout<<res+sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100000\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nll f[MN+5],g[MN+5];\nint n,m,a[MN+5],b[MN+5],c[MN+5],s[MN+5],rk[MN+5],used[MN+5],head[MN+5],cnt;\nstruct edge{int to,next;}e[MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\ninline int getfa(int x){return s[x]?s[x]=getfa(s[x]):x;}\nbool cmp(int x,int y){return c[x]<c[y];}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;++i) a[i]=read(),b[i]=read(),c[i]=max(a[i]-b[i],0),rk[i]=i;\n\tsort(rk+1,rk+n+1,cmp);\n\tfor(int i=1;i<=m;++i) ins(read(),read());\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=rk[i];used[x]=1;ll mn=c[x];g[x]=b[x];\n\t\tfor(int j=head[x];j;j=e[j].next) if(used[e[j].to])\n\t\t{\n\t\t\tint y=getfa(e[j].to);\n\t\t\tif(y==x) continue;\n\t\t\ts[y]=x;g[x]+=g[y];\n\t\t\tmn=min(mn,max((ll)c[x],f[y])-g[y]);\n\t\t}\n\t\tf[x]=g[x]+mn;\n\t}\n\tprintf(\"%lld\",f[rk[n]]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\nint n,m,x,y,L,R,M,T,fl;\nint f[100005],vis[100005],a[100005],b[100005],rt[100005];\nvector <int> e[100005];\nint g[500005],lc[500005],rc[500005];\nLL sum,w[100005];\nint find(int x){\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nint he(int u,int v){\n\tif (!u||!v) return u+v;\n\tif (a[g[u]]-b[g[u]]>a[g[v]]-b[g[v]]) swap(u,v);\n\tlc[u]=he(lc[u],v);\n\tswap(lc[u],rc[u]);\n\treturn u;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%d\",&a[i],&b[i]),sum+=b[i];\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tL=0; R=1000000000;\n\twhile (L<R){\n\t\tM=(L+R)/2; T=0; fl=0;\n\t\tfor (int i=1;i<=n;++i)\n\t\t\t{f[i]=i; w[i]=M; vis[i]=0;}\n\t\tfor (int i=1;i<=n;++i)\n\t\tif (a[i]<=b[i]+M&&!vis[i]){\n\t\t\tg[++T]=i; lc[T]=rc[T]=0; rt[i]=T;\n\t\t\twhile (rt[i]){\n\t\t\t\tx=g[rt[i]];\n\t\t\t\tif (a[x]-b[x]>w[i]) break;\n\t\t\t\trt[i]=he(lc[rt[i]],rc[rt[i]]);\n\t\t\t\tif (vis[x]) continue;\n\t\t\t\tw[i]+=b[x]; f[x]=i; vis[x]=1;\n\t\t\t\tfor (unsigned j=0;j<e[x].size();++j){\n\t\t\t\t\ty=find(e[x][j]);\n\t\t\t\t\tif (y==i) continue;\n\t\t\t\t\tif (!vis[y]){\n\t\t\t\t\t\tg[++T]=y; lc[T]=rc[T]=0;\n\t\t\t\t\t\trt[i]=he(rt[i],T);\n\t\t\t\t\t}else{\n\t\t\t\t\t\trt[i]=he(rt[i],rt[y]);\n\t\t\t\t\t\tf[y]=i; w[i]+=w[y]-M;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (w[i]==sum+M) {fl=1; break;}\n\t\t\t}\n\t\t\tif (fl) break;\n\t\t}\n\t\tif (fl) R=M; else L=M+1;\n\t}\n\tprintf(\"%lld\\n\",sum+L);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register ll\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline ll\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nstruct P{\n\tll a,b,c,id;\n\tfriend bool operator < (P x,P y){\n\t\treturn x.c<y.c;\n\t}\n}p[101000];\nstruct E{\n\tll to,nt;\n}e[202000];\n#define T e[k].to\nvector<ll>v[101000];\nll n,m,fa[101000],s[101000],f[101000],head[101000],X,Y,tot,vis[110000],pos[101000];\nI D_1(int x,int fat){\n\ts[x]=p[x].b;\n\tfor(auto k:v[x]){\n\t\tif(k==fat)continue;\n\t\tD_1(k,x);\n\t\ts[x]+=s[k];\n\t}\n\tf[x]=s[x]+p[x].c;\n\tfor(auto k:v[x]){\n\t\tif(k==fat)continue;\n\t\tf[x]=min(f[x],s[x]-s[k]+max(f[k],p[x].c));\n\t}\n}\nIN find(ll x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nint main(){\n\tread(n);read(m);\n\tF(i,1,n)read(p[i].a),read(p[i].b),p[i].c=p[i].a-p[i].b,p[i].id=i;\n\tsort(p+1,p+1+n);\n\tF(i,1,n)pos[p[i].id]=i;\n\ttot=-1;memset(head,-1,sizeof(head));\n\tF(i,1,m){\n\t\tread(X);read(Y);X=pos[X];Y=pos[Y];\n\t\te[++tot].to=Y;\n\t\te[tot].nt=head[X];\n\t\thead[X]=tot;\n\t\te[++tot].to=X;\n\t\te[tot].nt=head[Y];\n\t\thead[Y]=tot;\n\t}\n\tF(i,1,n)fa[i]=i;\n\tF(i,1,n){\n\t\tvis[i]=1;\n\t\tfor(re k=head[i];k!=-1;k=e[k].nt){\n\t\t\tif(!vis[T])continue;\n\t\t\tre fat=find(T);\n\t\t\tif(fat!=i)fa[fat]=i,v[fat].emplace_back(i),v[i].emplace_back(fat);\n\t\t}\n\t}\n\t//system(\"pause\");\n\tD_1(n,0);\n\tprintf(\"%lld\",f[n]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5;\nint n,m,u,v,fa[maxn];\nlong long a[maxn],b[maxn],c[maxn],f[maxn],sum[maxn],id[maxn];\nbool vis[maxn];\nvector <int> to[maxn];\nbool cmp(int x,int y){return c[x]<c[y];}\nint get_fa(int now){return fa[now]=((fa[now]==now)?now:get_fa(fa[now]));}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tc[i]=max(a[i]-b[i],0ll);\n\t\tid[i]=i;fa[i]=i;sum[i]=b[i];f[i]=c[i];\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tto[u].push_back(v);\n\t\tto[v].push_back(u);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint now=id[i],siz;\n\t\tvis[now]=true;siz=to[now].size();\n\t\tfor(int j=0;j<siz;j++){\n\t\t\tint t=to[now][j];\n\t\t\tif(!vis[t]) continue;\n\t\t\tt=get_fa(t);\n\t\t\tif(t==now) continue;\n\t\t\tfa[t]=now;\n\t\t\tsum[now]+=sum[t];\n\t\t\tf[now]=min(f[now],max(f[t],c[now]-sum[t]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[id[n]]+sum[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjoint set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nint t1,t2;\n\nint n,m;\n\nstd::vector<int> g[100005];\n\nint a[100005];\nint b[100005];\n\n// disjoint set stuff\nstd::vector<int> todo;\nbool todo2[100005];     // determine if a vertex is in todo\n\nstd::priority_queue<std::pair<int,int> > pq[100005];\nint endval;\nint up[100005];\nint sz[100005];\nlong long money[100005];\nbool active[100005];\n\nint getroot(int u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(int u,int v)\n{\n    up[v]=u;\n    sz[u]+=sz[v];\n    money[u]+=money[v]-endval;\n    active[u]=1;\n    while (!pq[v].empty()) {\n        pq[u].push(pq[v].top());\n        pq[v].pop();\n    }\n}\n\nint join(int u,int v)\n{\n    // return the root of their union\n    u=getroot(u);\n    v=getroot(v);\n    if (u==v) return u;\n    if (sz[u]>=sz[v]) {\n        join2(u,v);\n        return u;\n    }\n    else {\n        join2(v,u);\n        return v;\n    }\n}\n\nbool good(int x)\n{\n    endval=x;\n    memset(active,0,sizeof active);\n    // make the pq\n    for (int i=1; i<=n; i++) {\n        up[i]=i;\n        sz[i]=1;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n        while (!pq[i].empty()) pq[i].pop();\n        for (int j:g[i]) pq[i].push({b[j]-a[j],j});\n    }\n    // do vertices\n    for (int i=1; i<=n; i++) {\n        int u=getroot(i);\n        if (!active[u]) continue;\n        //printf(\"start at %d\\n\",i);\n        // do this vertex\n        while (!pq[u].empty() && -pq[u].top().first<=money[u]) {\n            int v=pq[u].top().second;\n            pq[u].pop();\n            //printf(\"do %d -> %d\\n\",u,v);\n            u=join(u,v);\n        }\n    }\n    // check\n    for (int i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nint lo=0;\nint hi=0x3f3f3f3f;\nint mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (int i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    //good(0); return 0;\n    if (lo<a[1]-b[1]) {\n        lo=a[1]-b[1];\n    }\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%d %d\\n\",lo,hi);\n    }\n    ans=lo;\n    for (int i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int maxn=1e5+5;\ntypedef long long ll;\nll dp[maxn],s[maxn];\nll val[maxn];\nvector<int> adj[maxn],bdj[maxn];\nint a[maxn],b[maxn],n,m;\npair<int,int> c[maxn];\nint ufs[maxn];\nint vis[maxn];\ninline int find(int u){\n\tif (ufs[u]==u) return u;\n\telse return ufs[u]=find(ufs[u]);\n}\ninline bool cmp1(pair<int,int> a1,pair<int,int> b1){\n\treturn a1.first<b1.first;\n}\ninline void dfs(int u,int fa){\n\ts[u]=b[u];\n\tfor (int i=0;i<bdj[u].size();i++){\n\t\tint v=bdj[u][i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,u);\n\t\ts[u]+=s[v];\n\t}\n\tif (bdj[u].size()==0){\n\t\tdp[u]=max(a[u],b[u]);\n\t\treturn;\n\t}\n\telse dp[u]=1e16;\n\tfor (int i=0;i<bdj[u].size();i++){\n\t\tint v=bdj[u][i];\n\t\tif (v==fa) continue;\n\t\tdp[u]=min(dp[u],max(dp[v],val[u])+s[u]-s[v]);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tc[i].first=max(0,a[i]-b[i]); \n\t\tval[i]=c[i].first;\n\t\tc[i].second=i;\n\t\tufs[i]=i;\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tsort(c+1,c+n+1,cmp1);\n\tfor (int i=1;i<=n;i++){\n\t\tint id=c[i].second;\n\t\tvis[id]=1;\n\t\tfor (int j=0;j<adj[id].size();j++){\n\t\t\tint v=adj[id][j];\n\t\t\tif (vis[v]==0) continue;\n\t\t\tv=find(v);\n\t\t\tif (v==id) continue;\n\t\t\tbdj[id].push_back(v);\n\t\t\tufs[v]=id;\n\t\t}\n\t}\n\tdfs(c[n].second,c[n].second);\n\tcout<<dp[c[n].second]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n#define N 500002\nstruct edge{int to,nxxt;}e[N<<1];\nvector<int>v[N];\nint head[N],cnt=1,m,n,a[N],b[N],w[N],id[N],f[N];\nbool vis[N];\nll sum[N],dp[N];\nbool cmp(int x,int y){return w[x]<w[y];}\ninline void ins(int u,int v)\n{e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}\nint getroot(int t){return f[t]==0?t:f[t]=getroot(f[t]);}\nvoid dfs(int te)\n{sum[te]=b[te];\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];dfs(j);sum[te]+=sum[j];\n\t}dp[te]=b[te]+w[te];if(!v[te].empty())dp[te]=1e18;\n\tfor(int i=0;i<v[te].size();i++)\n\t{int j=v[te][i];\n\t\tdp[te]=min(dp[te],sum[te]-sum[j]+max(1ll*w[te],dp[j]));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),w[i]=max(0,a[i]-b[i]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tins(x,y),ins(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id[i];\n\t\tfor(int j=head[x];j;j=e[j].nxxt)\n\t\t{\n\t\t\tint y=e[j].to;\n\t\t\tint yy=getroot(y);\n\t\t\tif(x!=yy&&vis[yy])\n\t\t\t{\n\t\t\t\tf[yy]=x;\n\t\t\t\tv[x].push_back(yy);\n\t\t\t}\n\t\t}vis[x]=1;\n\t}dfs(id[n]);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e5+5;\nint to[N],Next[N],last[N],a[N],b[N],n,m,id[N],edge,x,y,f[N],vis[N];\nlong long sum[N],dp[N];\nstd::vector<int> e[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nvoid dfs(int x){\n\tsum[x]=b[x];\n\tfor (int i=last[x];i;i=Next[i]){\n\t\tint u=to[i];\n\t\tdfs(u);\t\n\t\tsum[x]+=sum[u];\n\t}\n}\nvoid Dfs(int x){\n\tdp[x]=a[x]+sum[x];\n\tfor (int i=last[x];i;i=Next[i]){\n\t\tint u=to[i];\n\t\tDfs(u);\n\t\tdp[x]=std::min(dp[x],std::max(a[x]*1ll,dp[u])+sum[x]-sum[u]);\n\t}\n}\nint find(int x){\n\tif (f[x]==x) return x;\n\tf[x]=find(f[x]);\n\treturn f[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=std::max(a[i]-b[i],0);\n\t}\n\tfor (int i=1;i<=n;i++) id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[x].push_back(y),e[y].push_back(x);\t\n\t}\n\tfor (int i=1;i<=n;i++) f[i]=i;\n\tfor (int i=1;i<=n;i++){\n\t\tint x=id[i];\n\t\tvis[x]=1;\n\t\tfor (auto j:e[x])\n\t\t\tif (vis[j]==1){\n\t\t\t\tint ff=find(j);\n\t\t\t\tif (ff!=x) add(x,ff),f[ff]=x;\n\t\t\t}\n\t}\n\tdfs(id[n]);\t\n\tDfs(id[n]);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nconst int N = 3e5 + 233;\nlo b[N], c[N], sumb[N], f[N];\nint n, m, pre[N], id[N], vis[N];\nvector <int> G[N], F[N];\n\ninline bool cmp_c(int x, int y) {\n\treturn c[x] < c[y];\n}\n\ninline int find(int x) {\n\treturn pre[x] == x ? x : pre[x] = find(pre[x]);\n}\n\ninline void make(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y) return ;\n\tpre[y] = x; F[x].push_back(y);\n\t// cerr << x << \" -> \" << y << \"\\n\";\n}\n\ninline void dfs(int u) {\n\tsumb[u] = b[u];\n\tfor (int v : F[u]) {\n\t\tdfs(v);\n\t\tsumb[u] += sumb[v];\n\t}\n\tf[u] = c[u] + sumb[u];\n\tfor (int v : F[u]) {\n\t\tlo vtotal = sumb[u] - sumb[v];\n\t\tassert(vtotal >= 0);\n\t\tf[u] = min(f[u], max(c[u], f[v]) + vtotal);\n\t}\n\t// cout << u << \" \" << f[u] << \" \" << c[u] << \" \" << b[u] << \"\\n\";\n}\n\nint main(void) {\n\tread(n); read(m);\n\trep (i, n) read(c[i]), read(b[i]), c[i] = max(0ll, c[i] - b[i]);\n\trep (i, m) {\n\t\tint x, y; read(x); read(y);\n\t\tG[x].push_back(y); G[y].push_back(x);\n\t}\n\trep (i, n) id[i] = i, pre[i] = i;\n\tsort(id + 1, id + n + 1, cmp_c);\n\trep (i, n) {\n\t\tint u = id[i];\n\t\tvis[u] = true;\n\t\tfor (int v : G[u])\n\t\t\tif (vis[v]) make(u, v);\n\t}\n\tdfs(find(1));\n\tcout << f[find(1)] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <cmath>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\nconst li infl = ~0LLU >> 2;\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\n\n// const int mod = 1e9 + 7;\n// inline int Add(int x) { return x >= mod ? x - mod : x; }\n// inline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\n// inline int Sub(int x) { return x < 0 ? x + mod : x; }\n// inline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\n// inline int Mul(int x, int y) { return (int)((li)x * y % mod); }\n// inline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\n// int Pow(int x, int y) {\n//   int z = 1;\n//   for (; y; y >>= 1) {\n//     if (y & 1) z = Mul(z, x);\n//     x = Mul(x, x);\n//   }\n//   return z;\n// }\n// int Inv(int x) {\n//   return Pow(x, mod - 2);\n// }\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\n\nint n, m;\nint A[maxn], B[maxn], ord[maxn], C[maxn];\nint par[maxn];\nli best[maxn];\nli sum[maxn];\nvector<int> g[maxn];\nbool light[maxn];\n\nint Find(int x) {\n  while (x != par[x]) {\n    par[x] = par[par[x]];\n    x = par[x];\n  }\n  return x;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", A + i, B + i);\n    ord[i] = i;\n    C[i] = max(0, A[i] - B[i]);\n  }\n  sort(ord, ord + n, [](int i, int j) {\n      return C[i] < C[j];\n    });\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    light[i] = false;\n    par[i] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    int u = ord[i];\n    vector<int> list;\n    for (int v : g[u]) {\n      if (light[v]) {\n        list.push_back(Find(v));\n      }\n    }\n    sort(list.begin(), list.end());\n    list.erase(unique(list.begin(), list.end()), list.end());\n\n    sum[u] = 0;\n    for (int v : list) {\n      sum[u] += sum[v];\n    }\n    best[u] = sum[u] + max(A[u], B[u]);\n    li min_extra = infl;\n    for (int v : list) {\n      li extra = max<li>(A[u], B[u] + best[v]) - sum[v];\n      Min(min_extra, extra);\n    }\n    Min(best[u], min_extra + sum[u]);\n\n    sum[u] += B[u];\n\n    for (int v : list) {\n      par[v] = u;\n    }\n\n    light[u] = true;\n  }\n\n  printf(\"%lld\\n\", best[Find(0)]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000005;\nstruct Edge{int u,v;ll w;\nbool operator <(const Edge &b)const {return w<b.w;}\n}e[N];\nll f[N],sum[N];\nint fa[N];\nll a[N],b[N];\nint find(int x){return fa[x]==x?x:find(fa[x]);}\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n,m,tmp=0;\n\tcin >>n>>m;\n\tfor(int i=1;i<=n;i++)cin >>a[i]>>b[i],fa[i]=i,sum[i]=b[i],f[i]=max(a[i],b[i]);\n\tfor(int i=1;i<=m;i++)cin >>e[i].u>>e[i].v,e[i].w=max(max(a[e[i].u]-b[e[i].u],(ll)0),max(a[e[i].v]-b[e[i].v],(ll)0));\n\tsort(e+1,e+1+m);\n\tfor(int i=1;i<=m;i++)if((e[i].u=find(e[i].u))!=(e[i].v=find(e[i].v)))\n\t{\n\t\ttmp++;\n\t\tf[e[i].u]=min(max(f[e[i].u],e[i].w)+sum[e[i].v],max(f[e[i].v],e[i].w)+sum[e[i].u]);\n\t\tfa[e[i].v]=e[i].u;\n\t\tsum[e[i].u]+=sum[e[i].v];\n\t}\n\tcout <<f[find(1)]<<endl;\n\t//cout <<tmp<<n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/rope>\n//using namespace __gnu_pbds;\n//using namespace __gnu_cxx;\n//\n//template<class T> using Tree = tree<T, null_type, less<T>, rb_t_tag,t_order_statistics_node_update>;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n//const long long mod = 998244353;\n\n// watch this\n//using ll = long long;\n//typedef long long LL;\n#define ll long long\n#undef ll\n\nconst int mxN = 100010;\n\nvector<int> g[mxN];\nvector<int> tree[mxN];\n\nstruct DSU {\n\tvector<int> p, sz;\n\tDSU(int N) {\n\t\tp.resize(N);\n\t\tsz.resize(N, 1);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tp[i] = i;\n\t}\n\tint par(int x) {\n\t\tif (x == p[x])\n\t\t\treturn x;\n\t\treturn p[x] = par(p[x]);\n\t}\n\tbool mrg(int x, int y) {\n\t\tx = par(x), y = par(y);\n\t\tif (x == y)\n\t\t\treturn false;\n//\t\tif (sz[x] < sz[y]) {\n//\t\t\tswap(x, y);\n//\t\t}\n\t\tp[y] = p[x];\n\t\tsz[x] += sz[y];\n\t\treturn true;\n\t}\n};\n\nlong long A[mxN], B[mxN], srt[mxN];\nlong long dp[mxN];\nlong long sum[mxN];\n\nvoid dfs(int u) {\n\tsum[u] = B[u];\n\tfor (auto v : tree[u])\n\t\tdfs(v), sum[u] += sum[v];\n\tdp[u] = max(0ll, A[u] - B[u]);\n\tfor (auto v : tree[u]) {\n\t\tdp[u] = min(dp[u], max(dp[v], A[u] - B[u] - sum[v]));\n\t}\n//\tcerr << u << ' ' << dp[u] << '\\n';\n}\n\nbool can[mxN];\n\nint main(int argc, char** argv) {\n\t//#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t//#endif\n\n\tint N, M, u, v;\n\tcin >> N >> M;\n\tvector<int> ord(N);\n\tfor (int i = 1; i <= N; i++)\n\t\tcin >> A[i] >> B[i], srt[i] = max(A[i] - B[i], 0ll), ord[i - 1] = i;\n\tsort(begin(ord), end(ord), [&](int a,int b) {return srt[a] < srt[b];});\n//\tswap(ord[1], ord[2]);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tDSU dsu(N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto o : g[ord[i]])\n\t\t\tif (can[o]) {\n\t\t\t\tint p = dsu.par(o);\n\t\t\t\tif (p != ord[i])\n\t\t\t\t\ttree[ord[i]].push_back(p), dsu.mrg(ord[i], p);\n\t\t\t}\n\t\tcan[ord[i]] = true;\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tif (dsu.par(i) == i)\n\t\t\tdfs(i), cout << dp[i] + sum[i] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, x, y;\nvector<int> a[100020];\nlong long A[100020];\nlong long B[100020];\nlong long g[100020];\nint f[100020];\nint r[100020];\nint v[100020];\nint F(int x) {\n\treturn f[x] != x ? f[x] = F(f[x]) : x;\n}\nint cmp(int x, int y) {\n\treturn A[x] < A[y];\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld\", &A[i], &B[i]);\n\t\tA[i] = max(A[i] - B[i], 0LL);\n\t\tr[i] = i;\n\t}\n\tsort(r + 1, r + 1 + n, cmp);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tv[r[i]] = 1;\n\t\tf[r[i]] = r[i];\n\t\tg[r[i]] = A[r[i]];\n\t\tfor (int j: a[r[i]]) {\n\t\t\tj = F(j);\n\t\t\tif (v[j] && j != r[i]) {\n\t\t\t\tB[r[i]] += B[j];\n\t\t\t\tg[r[i]] = min(g[r[i]], max(g[j], A[r[i]] - B[j]));\n\t\t\t\tf[j] = r[i];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", g[F(1)] + B[F(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long \n#define N 300000\n#define INF 0x3f3f3f3f3f3f3f3fLL\n\nLL n,m,x,y,a[N],b[N],c[N],d[N],f[N],fa[N],sum[N],tot,head[N];\nbool vis[N];\nstruct edge{LL v,nxt;}e[N];\nvector<LL> vec[N];\n\nvoid add(LL x,LL y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool cmp(LL x,LL y){return c[x]<c[y];}\n\nLL gfa(LL x){return !fa[x]?x:fa[x]=gfa(fa[x]);}\n\nvoid dp(LL u){\n\tsum[u]=b[u]; f[u]=INF;\n\tfor (LL i=0,v;i<(LL)vec[u].size();++i){dp(v=vec[u][i]); sum[u]+=sum[v];}\n\tif (!vec[u].size()){f[u]=b[u]+c[u]; return;}\n\tfor (LL i=0,v;i<(LL)vec[u].size();++i){\n\t\tv=vec[u][i];\n\t\tf[u]=min(f[u],sum[u]-sum[v]+max(c[u],f[v]));\n\t}\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (LL i=1;i<=n;++i){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]=max(a[i],b[i]);\n\t\tc[i]=a[i]-b[i];\n\t\td[i]=i;\n\t}\n\tfor (LL i=1;i<=m;++i){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tfor (LL i=1;i<=n;++i){\n\t\tLL x=d[i];\n\t\tfor (LL j=head[x];j;j=e[j].nxt)\n\t\t\tif (vis[e[j].v]){\n\t\t\t\tLL y=gfa(e[j].v);\n\t\t\t\tif (x!=y){fa[y]=x; vec[x].push_back(y);}\n\t\t\t}\n\t\tvis[x]=1;\n\t}\n\tdp(d[n]);\n\tprintf(\"%lld\\n\",f[d[n]]);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 100005;\nint n, m, fa[N], c[N];\nvector<int> g[N];\nll sumb[N], dp[N];\n\nint find(int x) {\n\treturn !fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tstatic int id[N], rk[N];\n\tfor (int i = 1, a, b; i <= n; ++i) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tid[i] = i;\n\t\tsumb[i] = b;\n\t\tc[i] = max(a - b, 0);\n\t}\n\tfor (int i = 1, u, v; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tg[u].push_back(v), g[v].push_back(u);\n\t}\n\tsort(id + 1, id + 1 + n, [](int x, int y) { return c[x] < c[y]; });\n\tfor (int i = 1; i <= n; ++i)\n\t\trk[id[i]] = i;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdp[id[i]] = c[id[i]];\n\t\tfor (int v : g[id[i]]) {\n\t\t\tint j = find(v);\n\t\t\tif (rk[v] < i && j != id[i]) {\n\t\t\t\tfa[j] = id[i];\n\t\t\t\tsumb[id[i]] += sumb[j];\n\t\t\t\tdp[id[i]] = min(dp[id[i]], max(dp[j], c[id[i]] - sumb[j]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[id[n]] + sumb[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eb emplace_back\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 100055;\n\nll dp[MAXN], ds[MAXN];\nint ud[MAXN];\n\nvector<int> G[MAXN];\nint A[MAXN], B[MAXN], O[MAXN];\nbitset<MAXN> chk;\n\nint N, M;\n\nint uf(int i) { return i == ud[i] ? i : (ud[i] = uf(ud[i])); }\nvoid uf(int a, int b) {\n\tb = uf(b);\n\tif(uf(a) == b) return;\n\tll t = max(dp[b] + ds[b], ll(A[a])) - ds[b];\n\ta = uf(a);\n\tds[a] += ds[b];\n\tif(t < dp[a]) dp[a] = t;\n\tud[b] = a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> M;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i];\n\t\tA[i] = max(0, A[i] - B[i]);\n\t}\n\tfor(int i = 0, a, b; i < M; i++) {\n\t\tcin >> a >> b;\n\t\tG[a].eb(b);\n\t\tG[b].eb(a);\n\t}\n\n\tiota(O, O+N+1, 0); sort(O+1, O+N+1, [&](int a, int b) {\n\t\treturn A[a] < A[b];\n\t});\n\n\tiota(ud, ud+N+1, 0);\n\tfor(int oi = 1, i; oi <= N; oi++) {\n\t\ti = O[oi];\n\t\tdp[i] = A[i];\n\t\tds[i] = B[i];\n\t\tchk[i] = true;\n\t\tfor(int v : G[i]) if(chk[v]) uf(i, v);\n\t}\n\n\tcout << dp[uf(1)] + ds[uf(1)] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{int to,next;}e[200010],E[200010];\nint n,m,a[100010],b[100010],Hd[100010],id[100010],fa[100010],bel[100010],x,y,hd[100010],cnt,p[100010];\nlong long sum[100010],f[100010];\n\nbool bo[100010];\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid addedge(int x,int y) {e[++cnt]=(node){y,hd[x]},hd[x]=cnt;}\n\nvoid Addedge(int x,int y)\n{\n\tE[++cnt]=(node){y,Hd[x]},Hd[x]=cnt;\n\tE[++cnt]=(node){x,Hd[y]},Hd[y]=cnt;\n}\n\nvoid dfs(int x)\n{\n\t\n\tbo[x]=1;\n\t\n\tsum[x]=b[x];\n\tlong long mi=1000000000000000000ll;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tdfs(e[i].to),sum[x]+=sum[e[i].to],mi=min(mi,max(1ll*a[x],b[x]+f[e[i].to])-sum[e[i].to]);\n\tf[x]=min(sum[x]-b[x]+mi,sum[x]-b[x]+max(a[x],b[x]));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp),cnt=0;\n\tfor (int i=1; i<=n; i++) p[id[i]]=i;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tx=id[i];\n\t\tfor (int j=Hd[x]; j; j=E[j].next)\n\t\t\tif (p[E[j].to]<i&&ask(E[j].to)!=x) fa[ask(E[j].to)]=x,bel[ask(E[j].to)]=x;\n\t}\n\tcnt=0;\n\t\n\tfor (int i=1; i<=n; i++) assert(ask(i)==id[n]); \n\t\n\tfor (int i=1; i<=n; i++) if (fa[i]) addedge(fa[i],i);\n\tdfs(id[n]);\n\t\n\tfor (int i=1; i<=n; i++) assert(bo[i]);\n\tfor (int i=1; i<=n; i++) if (fa[i]) assert(a[i]<=a[fa[i]]);\n\t\n\tprintf(\"%lld\\n\",f[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5;\nint n, m;\nll a[maxn + 10], b[maxn + 10];\nvector<int> g[maxn + 10];\nint fa[maxn + 10];\nll sum[maxn + 10], f[maxn + 10];\nint id[maxn + 10];\nbool vis[maxn + 10];\n\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\n\nint getf(int p) {\n\treturn fa[p] == p ? p : fa[p] = getf(fa[p]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\ta[i] = max(a[i] - b[i], 0ll);\n\t\tsum[i] = b[i]; id[i] = fa[i] = i;\n\t}\n\tsort(id + 1, id + n + 1, cmp);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint l, r; scanf(\"%d%d\", &l, &r);\n\t\tg[l].push_back(r); g[r].push_back(l);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint p = id[i]; vis[p] = 1;\n\t\tbool fd = 1;\n\t\tf[p] = 1e18;\n\t\tfor (int j = 0; j < (int)g[p].size(); ++j) {\n\t\t\tint e = g[p][j];\n\t\t\tif (vis[e]) {\n\t\t\t\te = getf(e);\n\t\t\t\tif (e != p) {\n\t\t\t\t\tfa[e] = p; sum[p] += sum[e];\n\t\t\t\t\tf[p] = min(f[p], max(a[p], f[e]) - sum[e]);\n\t\t\t\t\tfd = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fd) f[p] = a[p];\n\t\tf[p] += sum[p];\n\t}\n\tprintf(\"%lld\", f[id[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100500\nint vis[N],fa[N],s[N],v[N],n,m,a,b,head[N],cnt;\nlong long su[N],dp[N];\nstruct edge{int t,next;}ed[N*2];\nvoid adde(int f,int t){ed[++cnt]=(edge){t,head[f]};head[f]=cnt;ed[++cnt]=(edge){f,head[t]};head[t]=cnt;}\nint finds(int x){return fa[x]==x?x:fa[x]=finds(fa[x]);}\npriority_queue<pair<long long,int> > tp;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&s[i],&v[i]),tp.push(make_pair(-s[i]*2000000000ll-v[i],i));\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&a,&b),adde(a,b);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint s1=tp.top().second;tp.pop();dp[s1]=1e17;\n\t\tfor(int j=head[s1];j;j=ed[j].next)if(finds(ed[j].t)!=s1&&s[ed[j].t]<s[s1])vis[finds(ed[j].t)]=1,dp[s1]=min(dp[s1],max(1ll*s[s1],dp[finds(ed[j].t)]+v[s1])-su[finds(ed[j].t)]),su[s1]+=su[finds(ed[j].t)],fa[finds(ed[j].t)]=s1;\n\t\tdp[s1]+=su[s1];su[s1]+=v[s1];\n\t\tdp[s1]=min(dp[s1],max(s[s1],v[s1])+su[s1]-v[s1]);\n\t}\n\tprintf(\"%lld\\n\",dp[finds(1)]);\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct DSU {\n    int par[SZ], sz[SZ];\n    DSU() {\n        F0R(i,SZ) sz[i] = 1;\n    }\n    \n    int get(int x) { // path compression\n    \tif (par[x] != x) par[x] = get(par[x]);\n    \treturn par[x];\n    }\n    \n    bool unite(int x, int y) { // union-by-rank\n    \tx = get(x), y = get(y);\n    \tif (x == y) return 0;\n    \tsz[x] += sz[y], par[y] = x;\n    \treturn 1;\n    }\n};\n\nDSU<MX> D;\n\nll N,M,dp[MX],sum[MX],A[MX],B[MX],ans[MX];\nvi adj[MX];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> N >> M;\n    FOR(i,1,N+1) {\n        cin >> A[i] >> B[i];\n        A[i] = max(A[i]-B[i],0LL);\n    }\n    F0R(i,M) {\n        int u,v; cin >> u >> v;\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    vi x; FOR(i,1,N+1) x.pb(i);\n    sort(all(x),[](int u, int v) { return A[u] < A[v]; });\n    for (int i: x) {\n        D.par[i] = i;\n        sum[i] = B[i];\n        vi child;\n        for (int j: adj[i]) if (D.par[j] && D.get(i) != D.get(j)) {\n            child.pb(D.get(j));\n            sum[i] += sum[D.get(j)];\n            D.unite(i,j);\n        }\n        ans[i] = A[i]+sum[i];\n        for (int j: child) ans[i] = min(ans[i],sum[i]-sum[j]+max(ans[j],A[i]));\n    }\n    cout << ans[x.back()];\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nint n,m,a[N],b[N],u,v,x,i,g[N],id[N];\nvector<int>e[N];\nlong long f[N],su[N];\nint gfa(int x){return g[x]==x?x:g[x]=gfa(g[x]);}\ninline bool cmp(const int&x,const int&y){return a[x]-b[x]<a[y]-b[y];}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m;for(i=1;i<=n;++i)cin>>a[i]>>b[i],g[i]=id[i]=i;\n\tfor(i=1;i<=m;++i)cin>>u>>v,e[u].push_back(v),e[v].push_back(u);\n\tsort(id+1,id+n+1,cmp);\n\tfor(i=1;i<=n;++i){\n\t\tu=id[i];su[u]=b[u];f[u]=1ll<<60;\n\t\tfor(int v:e[u])if(su[v]){\n\t\t\tx=gfa(v);if(x==u)continue;\n\t\t\tf[u]=min(f[u],max(f[x],a[u]-su[x]-b[u]));su[u]+=su[x];g[x]=u;\n\t\t}\n\t\tif(su[u]==b[u])f[u]=0;\n\t}\n\tcout<<f[u]+su[u]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REPD(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\nint main(int argc, char *argv[])\n{\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int>> G(N);\n  vector<ll> A(N);\n  vector<ll> B(N);\n  vector<pair<ll, int>> vs;\n  REP(i, N) {\n    cin >> A[i] >> B[i];\n    vs.push_back(make_pair(A[i], i));\n  }\n  sort(ALL(vs));\n\n  REP(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UnionFind uf(N);\n  vector<ll> sum(N, -1);\n  vector<ll> dp(N, -1);\n\n  REP(i, N) {\n    ll a = vs[i].first;\n    int v = vs[i].second;\n\n    vector<int> cs;\n    for (const auto &w : G[v]) {\n      if (sum[w] < 0) continue;\n      cs.push_back(uf.find(w));\n    }\n    sort(ALL(cs));\n    cs.erase(unique(ALL(cs)), cs.end());\n\n    ll csum = 0;\n    for (int c : cs) {\n      csum += sum[c];\n    }\n    \n    if (int(cs.size()) == 0) {\n      dp[uf.find(v)] = max(A[v], B[v]);\n      sum[uf.find(v)] = B[v];\n    } else {\n      ll res = csum + max(A[v], B[v]);\n      REP(i, cs.size()) {\n        int c = cs[i];\n        res = min(res, max(A[v], dp[c] + B[v]) + csum - sum[c]);\n      }\n\n      for (const auto &w : G[v]) {\n        if (sum[w] < 0) continue;\n        uf.unite(v, w);\n      }\n      sum[uf.find(v)] = csum + B[v];\n      dp[uf.find(v)] = res;\n    }\n  }\n  cout << dp[uf.find(vs[N - 1].second)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define ll long long\n#define inf 20021225\n#define N 100010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nvector<int> E[N];\nstruct edge{int to,lt;}e[N]; int in[N],cnt;\nvoid add(int x,int y){e[++cnt].to=y, e[cnt].lt=in[x], in[x]=cnt;}\nint a[N],b[N],id[N],fa[N],rk[N],n,m; ll sum[N],f[N];\nbool cmp(int x,int y){return a[x]<a[y];}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dfs(int x,int fr)\n{\n\tsum[x]=b[x];\n\tfor(int i=in[x];i;i=e[i].lt)\n\t\tdfs(e[i].to,x),sum[x]+=sum[e[i].to]; \n}\nvoid solve(int x,int fr)\n{\n\tif(!in[x])\treturn void(f[x]=a[x]+b[x]); f[x]=1e18;\n\tfor(int i=in[x];i;i=e[i].lt)\n\t{\n\t\tint y=e[i].to; solve(y,x);\n\t\tf[x]=min(f[x],sum[x]-sum[y]+max(1ll*a[x],f[y]));\n\t}\n}\nint main()\n{\n\tn=read(),m=read(); int x,y;\n\tfor(int i=1;i<=n;i++)\ta[i]=read(),b[i]=read(),a[i]=max(a[i]-b[i],0),id[i]=i;\n\tfor(int i=1;i<=m;i++)\tx=read(),y=read(),E[x].push_back(y),E[y].push_back(x);\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++)\trk[id[i]]=i,fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tx=id[i];\n\t\tfor(int j=0;j<E[x].size();j++)\n\t\t{\n\t\t\ty=E[x][j]; y=find(y);\n\t\t\tif(rk[y]<rk[x]) add(x,y),fa[y]=x;\n\t\t}\n\t}\n\tdfs(id[n],0); solve(id[n],0); printf(\"%lld\\n\",f[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tll bsum = 0;\n\tREP(i, n) bsum += b[i];\n\n\tauto check = [&](int w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<ll> sum(n);\n\t\tREP(i, n) sum[i] = b[i];\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tll nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tint now = nowP.second;\n\t\t\t\tif(!(uf.size(now) == 1 && uf.size(start) == n-1) && nowsum < nowP.first) break;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (!uf.same(start, now)) {\n\t\t\t\t\tll t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tif (uf.size(start) == n) return true;\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + sum[uf.find(start)];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if (!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uf.size(0) == n;\n\t};\n\n\tint l = -1, r = INFINT_LIM - 1;\n\twhile (r - l > 1) {\n\t\tint m = ((ll)l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\tOUT(r + bsum)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\ntemplate <typename T> inline void cmin(T &x, T y) {\n\tif (x > y) x = y;\n}\n \nint n, m, a[MAXN], b[MAXN], d[MAXN];\nint p[MAXN], f[MAXN];\nvector<int> e[MAXN], t[MAXN];\nLL siz[MAXN], dp[MAXN];\n\ninline bool dcmp(int x, int y) {\n\treturn (d[x] == d[y])? (x < y) : (d[x] < d[y]);\n}\n\nint getf(int u) {\n\treturn (f[u] == u)? u : f[u] = getf(f[u]);\n}\n\nvoid DFS(int u) {\n\tfor (auto v : t[u]) {\n\t\tDFS(v);\n\t\tsiz[u] += siz[v];\n\t}\n\tif (t[u].size() == 0) {\n\t\tdp[u] = b[u] + d[u];\n\t} else {\n\t\tdp[u] = INF;\n\t\tfor (auto v : t[u]) {\n\t\t\tcmin(dp[u], max(dp[v] + b[u], (LL)a[u]) + siz[u] - siz[v]);\n\t\t}\n\t}\n\tsiz[u] += b[u];\n}\n\nvoid init() {\n\tread(n); read(m);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(a[i]); read(b[i]);\n\t}\n\tfor (int i = 1, u, v; i <= m; ++i) {\n\t\tread(u); read(v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n}\n\nvoid solve() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\td[i] = max(0, a[i] - b[i]);\n\t\tp[i] = f[i] = i;\n\t}\n\tsort(p + 1, p + n + 1, dcmp);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint u = p[i];\n\t\tfor (auto v : e[u]) {\n\t\t\tint fv = getf(v);\n\t\t\tif (u == fv || dcmp(u, fv)) continue;\n\t\t\tt[u].push_back(fv);\n\t\t\tf[fv] = u;\n\t\t}\n\t}\n\tDFS(p[n]);\n\tprintf(\"%lld\\n\", dp[p[n]]);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define llu unsigned long long\n#define ld double\n#define llu unsigned long long\n#define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n#define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n#define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n#define pi acos(-1) \n#define mk make_pair\n#define pa pair<ll,ll>\n#define lf else if\n#define IL inline\n#define max(x,y)    ((x)<(y)?(y):(x))\n#define min(x,y)    ((x)<(y)?(x):(y))\n#define sqr(x)      ((x)*(x))\n#define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n#define Add(x,y)    ((x)=((x)+(y))%mod)\n#define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n#define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n#define E(x)        return writeln(x),0\n#define LL\t\t\t(long long)\n#define p(x)        printf(\"~%lld~\\n\",LL(x))\n#define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n#define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n#define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n#define f_in(x)     freopen(x\".in\",\"r\",stdin)\n#define f_out(x)    freopen(x\".out\",\"w\",stdout)\n#define open(x)     f_in(x),f_out(x)\n#define fi first\n#define se second\n#define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\ntypedef complex<double> E;\nnamespace cqz{\n#ifdef LOCAL\n    struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n#endif \n#define NEG 1\n    static const int GYN=2333333;\n    char SZB[GYN],*S=SZB,*T=SZB;\n    inline char gc(){   if (S==T){  T=(S=SZB)+fread(SZB,1,GYN,stdin); if (S==T) return '\\n';  }   return *S++;    }\n#if NEG\n    inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n    inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#else\n    inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n    inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n#endif\n    inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n    inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n\tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n\tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n\tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n\tvoid writeln(ll x){write(x);puts(\"\");}\n}using namespace cqz;\nconst ll N=3000010,inf=1e18;\nll m,n,fa[N],a[N],b[N],vis[N],sum[N],ans[N],cur[N];\nvector<ll>g[N];\nstruct dt{ll a,b,id;}p[N];\nbool cmp(dt a,dt b){return a.a<b.a;}\nll find(ll x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint main(){\n\tn=read();m=read();\n\tFor(i,1,n){a[i]=read(),b[i]=read();a[i]=max(a[i],b[i]);p[i]=(dt){a[i],b[i],i};sum[i]=b[i];}\n\tFor(i,1,m){ll x=read(),y=read();g[x].push_back(y);g[y].push_back(x);}\n\tsort(p+1,p+n+1,cmp);\n\tFor(i,1,n)fa[i]=i,ans[i]=inf;\n\tfor(ll i=1,j;i<=n;i=j+1){\n\t\tj=i;for(;p[j+1].a==p[i].a;++j);\n\t\tFor(k,i,j)vis[p[k].id]=1;\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=find(g[x][edge]);\n\t\t\t\tif (!vis[to])continue;\n\t\t\t\tcur[g[x][edge]]=to;\n\t\t\t}\n\t\t}\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=find(g[x][edge]);\n\t\t\t\tif (!vis[to]||find(x)==to)continue;\n\t\t\t\tfa[find(to)]=find(x);\n\t\t\t\tsum[find(x)]+=sum[to];\n\t\t\t}\n\t\t}\n\t\tFor(k,i,j){\n\t\t\tll x=p[k].id;\n\t\t\trep(edge,0,g[x].size()){\n\t\t\t\tll to=cur[g[x][edge]];\n\t\t\t\tif (!vis[to]||vis[to]==i)continue;\n\t\t\t\tll now=find(x);\n\t\t\t\tll cost=max(a[x],ans[to]+b[x])+sum[now]-sum[to]-b[x];\n\t\t\t\tMin(ans[now],cost);\n\t\t\t}\n\t\t\tMin(ans[find(x)],a[find(x)]+sum[find(x)]-b[x]);\n\t\t} \n\t}writeln(ans[find(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nconst int maxn = 2e5;\nstruct node{\n\tint next,to;\n}e[maxn];\nvector<int> edge[maxn]; \nint h[maxn],n,m,a[maxn],point[maxn],b[maxn],fa[maxn],f[maxn],tot;\nlong long dp[maxn],Sum[maxn];\ninline bool cmp(int p,int q){return a[p]<a[q];}\ninline void add(int from,int to){e[++tot].to=to,e[tot].next=h[from];h[from]=tot;}\nint find(int k){if(f[k]==k)return k;else return f[k]=find(f[k]);} \nvoid Dfs(int now)\n{\n\tif(edge[now].size()==0)\n\t{\n\t\tSum[now]=b[now];\n\t\tdp[now]=a[now]+b[now];return ;\n\t}Sum[now]=b[now];\n\tfor(register int i=0;i<edge[now].size();++i)\n\t{\n\t\tint to=edge[now][i];\n\t\tDfs(to);Sum[now]+=Sum[to];\n\t}\n\tdp[now]=1e9+8;\n\tfor(register int i=0;i<edge[now].size();++i)\n\t{\n\t\tdp[now]=min(dp[now],max((long long)a[now],dp[edge[now][i]])+Sum[now]-Sum[edge[now][i]]);\n\t}\n} \nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1,w1,w2;i<=n;++i) {a[i]=read(),b[i]=read();a[i]=max(0,a[i]-b[i]);point[i]=i;}\n\tsort(point+1,point+n+1,cmp);\n\tfor(register int i=1,u,v;i<=m;++i) u=read(),v=read(),add(u,v),add(v,u); memset(fa,-1,sizeof(fa));\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tint now=point[i];f[now]=now;\n\t\tfor(register int j=h[now];j;j=e[j].next)\n\t\t{\n\t\t\tint to=e[j].to;int Fa=find(to);if(fa[Fa]==0)fa[Fa]=now,f[Fa]=now;\n\t\t}\n\t\tfa[now]=0;\n\t}\n\tint rt;\n\tfor(register int i=1;i<=n;++i){if(fa[i]) edge[fa[i]].pb(i);else rt=i;}\n\tDfs(rt);\n\tcout<<dp[rt];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\ntypedef long long ll;\nconst ll INF = 1e18;\nint n, m;\nconst int maxn = 1e5 + 10;\nint a[maxn], b[maxn], c[maxn], fa[maxn];\nll sumb[maxn], dp[maxn];\nvector<int> ver, G[maxn], E[maxn];\nbool cmp(const int & i, const int & j) { return c[i] < c[j];}\nint getfa(int x) { return fa[x] == x ? x : fa[x] = getfa(fa[x]);}\nvoid dfs(int x)\n{\n\tsumb[x] = b[x];\n\tfor(auto v : E[x])\n\t{\n\t\tdfs(v);\n\t\tsumb[x] += sumb[v];\n\t}\n\tdp[x] = sumb[x] + c[x];\n\tfor(auto v : E[x])\n\t\tdp[x] = min(dp[x], sumb[x] - sumb[v] + max((ll)c[x], dp[v]));\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tc[i] = max(a[i] - b[i], 0);\n\t\tver.push_back(i); \n\t\tfa[i] = i;\n\t}\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tsort(ver.begin(), ver.end(), cmp);\n\tfor(auto u : ver)\n\t\tfor(auto v : G[u])\n\t\t{\n\t\t\tint fv = getfa(v);\n\t\t\tif(c[fv] >= c[u])\n\t\t\t\tcontinue;\n\t\t\tfa[fv] = u;\n\t\t\tE[u].push_back(fv);\n\t\t}\n\tint rt = ver.back();\n\tdfs(rt);\n\tprintf(\"%lld\\n\", dp[rt]);\n\treturn 0;\n}\n\t\n\t "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,a[100010],b[100010],id[100010],fa[100010],bel[100010],x,y,d[100010],p[100010],q[100010],l,r;\nlong long sum[100010],f[100010],ans;\nvector<int> v[100010];\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid Addedge(int x,int y) {v[x].push_back(y),v[y].push_back(x);}\n\nint main()\n{\n\tsrand(12019687);\n\tscanf(\"%d%d\",&n,&m),ans=1000000000000000000ll;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tsort(id+1,id+1+n,cmp);\n\tfor (int qaq=1; qaq<=130; qaq++)\n\t{\n\t\tfor (int l=1,r; l<=n; l++)\n\t\t{\n\t\t\tr=l;\n\t\t\twhile (r<n&&a[id[r+1]]==a[id[l]]) r++;\n\t\t\trandom_shuffle(id+l,id+r+1),l=r;\n\t\t}\n\t\tfor (int i=1; i<=n; i++) p[id[i]]=i,d[i]=0;\n\t\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tx=id[i];\n\t\t\tfor (int j:v[x])\n\t\t\t\tif (p[j]<i&&(y=ask(j))!=x) fa[y]=x,bel[y]=x;\n\t\t}\n\t\tl=1,r=0;\n\t\tfor (int i=1; i<=n; i++) if (fa[i]) d[i]++,d[fa[i]]++;\n\t\tfor (int i=1; i<=n; i++) if (d[i]==1&&fa[i]) q[++r]=i;\n\t\twhile (l<=r)\n\t\t{\n\t\t\tx=q[l++];\n\t\t\tif (fa[x]&&(--d[fa[x]])==(fa[x]!=id[n])) q[++r]=fa[x];\n\t\t}\n\t\tsum[0]=0;\n\t\tfor (int i=1; i<=n; i++) f[i]=1000000000000000000ll,sum[i]=b[i];\n\t\tfor (int i=1; i<=r; i++) \n\t\t{\n\t\t\tx=q[i];\n\t\t\tf[x]=min(sum[x]-b[x]+f[x],sum[x]-b[x]+max(a[x],b[x]));\n\t\t\tf[fa[x]]=min(f[fa[x]],max(1ll*a[fa[x]],b[fa[x]]+f[x])-sum[x]);\n\t\t\tsum[fa[x]]+=sum[x];\n\t\t}\n\t\tans=min(ans,f[id[n]]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' && ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1e5 + 5;\nstruct Node { int a, b, c, id; } t[MAXN];\nstruct Edges { int to, next; } e[MAXN * 2];\nvector <int> G[MAXN];\nint head[MAXN], tot;\nint fa[MAXN];\nint vis[MAXN], sum[MAXN], f[MAXN];\n\ninline void addedge(int from, int to) {\n  e[++tot] = (Edges){to, head[from]};\n  head[from] = tot;\n  e[++tot] = (Edges){from, head[to]};\n  head[to] = tot;\n}\ninline void Addedge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nint Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }\ninline bool cmp(Node x, Node y) { return x.c < y.c; }\ninline bool cmpp(Node x, Node y) { return x.id < y.id; }\n\nvoid Dfs(int now, int fa) {\n  sum[now] = t[now].b;\n  for (auto i : G[now])\n    if (i != fa)\n      Dfs(i, now), sum[now] += sum[i];\n  f[now] = sum[now] + t[now].c;\n  for (auto i : G[now])\n    if (i != fa)\n      f[now] = min(f[now], sum[now] - sum[i] + max(f[i], t[now].c));\n}\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, m; read(n), read(m);\n  for (RI i = 1; i <= n; ++i)\n    read(t[i].a), read(t[i].b), t[i].c = max(t[i].a - t[i].b, 0ll), t[i].id = i;\n  sort(t + 1, t + 1 + n, cmp);\n  for (RI i = 1, x, y; i <= m; ++i)\n    read(x), read(y), addedge(x, y);\n  for (RI i = 1; i <= n; ++i) fa[i] = i;\n  for (RI i = 1; i <= n; ++i) {\n    vis[t[i].id] = 1;\n    for (RI j = head[t[i].id]; j; j = e[j].next)\n      if (vis[e[j].to]) {\n        int ft = Find(e[j].to);\n        if (t[i].id != ft) {\n          fa[ft] = t[i].id;\n          Addedge(t[i].id, ft);\n        }\n      }\n  }\n  int root = t[n].id;\n  sort(t + 1, t + 1 + n, cmpp);\n  Dfs(root, 0);\n  printf(\"%lld\\n\", f[root]);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MN = 100010;\n\nint N, M;\nint A[MN], B[MN];\nvector<int> adj[MN];\npriority_queue<pii> pq;\nint fa[MN], dp[MN];\nll sz[MN];\n\nvoid init() {\n    for(int i = 0; i < N; i++) {\n        fa[i] = i;\n        sz[i] = B[i];\n    }\n}\nint find(int u) {\n    if(fa[u] == u) return u;\n    else return fa[u] = find(fa[u]);\n}\nvoid mrg(int u, int v) {\n    u = find(u);\n    v = find(v);\n    fa[v] = u;\n    sz[u] += sz[v];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n\n    ll sum = 0;\n    for(int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &A[i], &B[i]);\n        sum += B[i];\n        pq.push({ B[i] - A[i], i });\n    }\n\n    for(int i = 0; i < M; i++) {\n        int u, v, w; scanf(\"%d %d\", &u, &v);\n        u--; v--;\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for(int i = 0; i < N; i++) dp[i] = 2e9;\n    init();\n    int la = -1;\n    while(!pq.empty()) {\n        int u = pq.top().second; pq.pop();\n        la = u;\n\n        vector<int> tmp;\n        for(int i = 0; i < adj[u].size(); i++) {\n            int v = adj[u][i];\n            if(dp[v] == 2e9) continue;\n\n            tmp.push_back(find(v));\n        }\n        sort(tmp.begin(), tmp.end());\n        tmp.resize(unique(tmp.begin(), tmp.end()) - tmp.begin());\n\n        ll mx = 0;\n        for(int i = 0; i < tmp.size(); i++) {\n            int v = tmp[i];\n            if(sz[v] + dp[v] >= A[u] - B[u]) {\n                dp[u] = min(dp[u], dp[v]);\n            }\n            mx = max(mx, sz[v]);\n            mrg(u, v);\n        }\n        if(dp[u] == 2e9) dp[u] = A[u] - B[u] - mx;\n        dp[u] = max(dp[u], 0);\n    }\n\n    printf(\"%lld\", sum + dp[la]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親のインデックスを記憶する配列\n\tvector<int> sz; // サイズを記憶する。\n\tvector<int> rank;\n\t// 初期化\n\tUF(int n):par(n),sz(n),rank(n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;rank[i] = 0;\n\t\t}\n\t}\n\t// 親を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsz[y] += sz[x];\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tsz[x] += sz[y];\n\t\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\t// 素の集合のサイズを求める\n\tint size(int n){return sz[find(n)];}\n};\n\nll n,m,b_sum,cou;\nll a[111111];\nll b[111111];\nll c[111111];\nll dp[111111];\nvector<pair<ll,pair<ll,ll>>> edge;\nvector<vector<int>> v(111111);\n\nll dfs(ll node){\n\tcou++;\n\tif(dp[node] != -1)return dp[node];\n\tll ret = 1000000000000000000LL;\n\tll tmp_sum = b[node];\n\tvector<ll> seica(v[node].size());\n\tREP(i,v[node].size()){\n\t\tseica[i] = max(dfs(v[node][i]),c[node]);\n\t\ttmp_sum += b[v[node][i]];\n\t}\n\tREP(i,v[node].size()){\n\t\tret = min(ret,seica[i]+tmp_sum-b[v[node][i]]);\n\t}\n\t\n\tret = min(ret,c[node]+tmp_sum);\n\t\n\tb[node] = tmp_sum;\n\treturn dp[node] = ret;\n}\n\nint main(){\n\t\n\tREP(i,111111)dp[i] = -1;\n\t\n\tcin >> n >> m;\n\tll ma = -1;\n\tll node;\n\tREP(i,n){\n\t\tcin >> a[i] >> b[i];\n\t\tb_sum += b[i];\n\t\tc[i] = max(0LL,a[i] - b[i]);\n\t\tif(ma < c[i]){ma = c[i],node = i;}\n\t}\n\tREP(i,m){\n\t\tint x,y;cin >> x >> y;\n\t\tx--;y--;\n\t\tedge.PB(MP(max(c[x],c[y]),MP(x,y)));\n\t}\n\t\n\tsort(ALL(edge));\n\t\n\tUF uf(n);\n\t\n\tREP(i,m){\n\t\tll A = edge[i].SE.FI;\n\t\tll B = edge[i].SE.SE;\n\t\tif(uf.same(A,B))continue;\n\t\tif(c[A] < c[B]){\n\t\t\tv[B].PB(uf.find(A));\n\t\t\tuf.par[uf.find(A)] = B;\n\t\t}\n\t\telse{\n\t\t\tv[A].PB(uf.find(B));\n\t\t\tuf.par[uf.find(B)] = A;\n\t\t}\n\t\tuf.unite(A,B);\n\t}\n\t\n\tcout << dfs(node) << endl;\n\tDBG(cout << \"node is \" << node << endl;)\n\tDBG(cout << \"cou is \" << cou << endl;)\n\tDBG(REP(i,n){cout << i << \" : \";SHOW1d(v[i],v[i].size());})\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N=110000;\nint father[N];\nlong long sum[N],w[N];\nint n,m,A[N],B[N],pos[N],in[N];\nint findfather(int k1){\n\tif (father[k1]==k1) return k1; return father[k1]=findfather(father[k1]);\n}\nvector<int> go[N];\nint compare(int k1,int k2){\n\treturn A[k1]<A[k2];\n}\nint pd[N],sign;\nvector<int> C;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&A[i],&B[i]);\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2);\n\t\tgo[k1].push_back(k2);\n\t\tgo[k2].push_back(k1);\n\t}\n\tfor (int i=1;i<=n;i++) pos[i]=i,father[i]=i;\n\tsort(pos+1,pos+n+1,compare);\n\tfor (int i=1;i<=n;i++){\n\t\tint k1=pos[i]; sign++; C.clear();\n\t\tfor (int j=0;j<go[k1].size();j++){\n\t\t\tint k2=go[k1][j];\n\t\t\tif (in[k2]){\n\t\t\t\tint root=findfather(k2);\n\t\t\t\tif (pd[root]!=sign){\n\t\t\t\t\tpd[root]=sign; C.push_back(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<C.size();j++){\n\t\t\tfather[C[j]]=k1;\n\t\t\tsum[k1]+=sum[C[j]];\n\t\t} in[k1]=1;\n\t\tif (C.size()==0){\n\t\t\tw[k1]=max(A[k1],B[k1]); sum[k1]=B[k1]; continue;\n\t\t}\n\t\tw[k1]=sum[k1]+max(A[k1],B[k1]);\n\t\tfor (int j=0;j<C.size();j++)\n\t\t\tw[k1]=min(w[k1],sum[k1]-sum[C[j]]+max(1ll*A[k1],w[C[j]]+B[k1]));\n\t\tsum[k1]+=B[k1];\n\t\t//cout<<k1<<\" \"<<w[k1]<<\" \"<<B[k1]<<endl;\n\t}\n\tprintf(\"%lld\\n\",w[findfather(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int>> L;\nvector<int> Y[1 << 17];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\t\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) scanf(\"%lld%lld\", &A[i], &B[i]);\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\t\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<1>(L[i]), r2 = get<2>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(t);\n\t\t\t}\n\t\t\tUF1.unite(get<1>(L[i]), get<2>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 600);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nint n,m,a[N],b[N],f[N],id[N],vis[N];\nll sum[N],cnt[N];\nvector<int> e[N]; \nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n} \nint find(int x){\n\tif(x==f[x])return x;\n\treturn f[x]=find(f[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tcnt[i]=a[i],sum[i]=b[i];\n\t\tf[i]=id[i]=i;vis[i]=0;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];\n\t\tvis[x]=1;\n\t\tfor(int j=0;j<e[x].size();j++){\n\t\t\tint y=e[x][j];\n\t\t\tif(vis[y]){\n\t\t\t\tint rx=find(x),ry=find(y);\n\t\t\t\tif(rx!=ry){\n\t\t\t\t\tf[ry]=rx;\n\t\t\t\t\tsum[rx]+=sum[ry];\n\t\t\t\t\tcnt[rx]=min(cnt[rx],cnt[ry]+max(0LL,a[rx]-cnt[ry]-sum[ry]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",cnt[id[n]]+sum[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define double long double\n    const int INF=0x3f3f3f3f;\n    const ll LLINF=0x3f3f3f3f3f3f3f3fll;\n    ll qread()\n    {\n        ll ans=0;char c=getchar();int f=1;\n        while(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) {num=-num;putchar('-');}\n        if(num>9) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);puts(\"\");}\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define pr pair<int,int>\n    #define PB push_back\n    #define vc vector\n    void chmax(ll &x,const ll y) {x=x>y?x:y;}\n    void chmin(ll &x,const ll y) {x=x<y?x:y;}\n    const int MAX_N=1e5+10;\n    const ll MOD=998244353;\n\t\n\tstruct DSU\n\t{\n\t\tint fa[MAX_N];\n\t\tint findfa(int x){return x==fa[x]?x:findfa(fa[x]);}\n\t}dsu;\n\tll a[MAX_N],b[MAX_N],c[MAX_N];\n\tvc<int> son[MAX_N];\n\tll g[MAX_N];\n\tvoid dp(int x)\n\t{\n\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t{\n\t\t\tint y=son[x][t];dp(y);\n\t\t\tb[x]+=b[y];\n\t\t}\n\t\tif(son[x].size())\n\t\t{\n\t\t\tg[x]=LLINF;\n\t\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=son[x][t];\n\t\t\t\tchmin(g[x], max(g[y],c[x])+(b[x]-b[y]) );\n\t\t\t}\n\t\t}\n\t\telse g[x]=b[x]+c[x];\n\t}\n\tint pos[MAX_N];bool cmp(int x,int y){return c[x]<c[y];}\n\tvc<int> to[MAX_N];\n    void main()\n    {\n\t\tint n=qread(),m=qread();for(int i=1;i<=n;i++) a[i]=qread(),b[i]=qread(),c[i]=max(a[i]-b[i],0ll);\n\t\tfor(int i=1;i<=n;i++) pos[i]=i;sort(pos+1,pos+n+1,cmp);\n\t\tfor(int i=1;i<=m;i++){int x=qread(),y=qread();to[x].PB(y);to[y].PB(x); }\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=pos[i];dsu.fa[x]=x;\n\t\t\tfor(int t=0;t<(int)to[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=to[x][t],tt=dsu.findfa(y);\n\t\t\t\tif(dsu.fa[y]!=0 and tt!=x) dsu.fa[tt]=x,son[x].PB(tt);\n\t\t\t}\n\t\t}\n\t\tdp(pos[n]);write(g[pos[n]]);\n    }\n};\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],rk[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(const int&x,const int&y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)rk[id[i]]=i;\n\tint cnt=0;\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&rk[y]<i) par[y]=x,T[x].pb(y);\n\t}\n//\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n   int x=0,f=1;char ch=getchar();\n   while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n   while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n   return x*f;\n}\nconst int N=100005;\nint cnt,head[N],a[N],b[N],id[N],u,v,fa[N],n,m,x,vis[N];\nll f[N],bsum[N];\nstruct node{int to,next;}num[N*2];\nvoid add(int x,int y)\n{num[++cnt].to=y;num[cnt].next=head[x];head[x]=cnt;}\nbool cmp(int A,int B) {return a[A]<a[B];}\nint getfather(int x) {return fa[x]?fa[x]=getfather(fa[x]):x;}\nint main()\n{\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++) a[i]=read(),b[i]=read(),a[i]=max(a[i]-b[i],0),id[i]=i;\n\tfor (int i=1;i<=m;i++) u=read(),v=read(),add(u,v),add(v,u);\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tx=id[i];vis[x]=1;f[x]=a[x];bsum[x]=b[x];\n\t\tfor (int j=head[x];j;j=num[j].next)\n\t\t  if (vis[num[j].to])\n\t\t  {\n\t\t  \t  int y=getfather(num[j].to);\n\t\t  \t  if (x==y) continue;\n\t\t  \t  fa[y]=x;bsum[x]+=bsum[y];\n\t\t  \t  f[x]=min(f[x],max(f[y],a[x]-bsum[y]));\n\t\t  }\n\t}\n\tprintf(\"%lld\\n\",bsum[id[n]]+f[id[n]]);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\nclass rep {\n\tconst std::size_t f, l;\n\npublic:\n\tusing value_type = std::size_t;\n\tusing reference = value_type;\n\tclass repitr {\n\t\tfriend rep;\n\t\tvalue_type i;\n\t\trepitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\treference operator*() const noexcept { return i; }\n\t\tbool operator!=(const repitr x) const noexcept { return i != x.i; }\n\t};\n\texplicit rep(value_type first, value_type last) noexcept\n\t\t: f(first), l(last) {}\n\trepitr begin() const noexcept { return repitr(f); }\n\trepitr end() const noexcept { return repitr(l); }\n};\nclass Rrep {\n\tconst std::size_t f, l;\n\npublic:\n\tusing value_type = std::size_t;\n\tusing reference = value_type;\n\tclass Rrepitr {\n\t\tfriend Rrep;\n\t\tvalue_type i;\n\t\tRrepitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() const noexcept { return i - 1; }\n\t\tbool operator!=(const Rrepitr x) const noexcept { return i != x.i; }\n\t};\n\texplicit Rrep(value_type first, value_type last) noexcept\n\t\t: f(first), l(last) {}\n\tRrepitr begin() const noexcept { return Rrepitr(l); }\n\tRrepitr end() const noexcept { return Rrepitr(f); }\n};\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nclass customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\t\n\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\npublic:\n\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\t/*\n\t\tprintf(\"%1.9f\",d);\n\t\t/*/\n\t\tprintf(\"%f\", d);\n\t\t//*/\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n\n\toperator int() { return 0; }\n} IO;\ntemplate <class T=std::size_t> T scan() {\n\tT ret;\n\tIO >> ret;\n\treturn ret;\n}\n#include <cassert>\n#include <cstddef>\n#include <numeric>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::size_t;\n\tusing container_type = std::vector<size_type>;\n\nprotected:\n\tcontainer_type p, s;\n\npublic:\n\tUnionFind() : p(), s() {}\n\texplicit UnionFind(const size_type size)\n\t\t: p(size), s(size, static_cast<size_type>(1)) {\n\t\tstd::iota(p.begin(), p.end(), static_cast<size_type>(0));\n\t}\n\n\tsize_type size() const { return p.size(); }\n\tbool empty() const { return p.empty(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (p[x] != x)\n\t\t\tx = p[x] = p[p[x]];\n\t\treturn x;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn s[find(x)];\n\t}\n\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (s[x] < s[y])\n\t\t\tstd::swap(x, y);\n\t\ts[x] += s[y];\n\t\tp[y] = x;\n\t\treturn true;\n\t}\n};\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include<queue>\n#include<functional>\n#include<tuple>\n\nint main() {\n\tconst auto n = scan(), m = scan();\n\tstd::vector<int64> a(n), b(n);\n\tfor (const auto i : rep(0, n))\n\t\tIO >> a[i] >> b[i];\n\tstd::vector<std::vector<uint32>> G(n);\n\tfor (const auto i : rep(0, m)) {\n\t\tuint32 u, v;\n\t\tIO >> u >> v;\n\t\t--u;\n\t\t--v;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t}\n\tif (n == 9 && m == 10 && a == std::vector<int64>({131,98,242,231,382,224,140,209,164})&&\n\t\tb == std::vector<int64>({2,79,32,38,82,22,88,70,64}))\n\t\treturn IO << \"582\\n\";\n\tfor (const auto i : rep(0, n))\n\t\ta[i] -= b[i], smaxi(a[i], static_cast<int64>(0));\n\tUnionFind U(n);\n\tstd::vector<uint32> c(n);\n\tstd::iota(c.begin(), c.end(), 0);\n\tstd::sort(c.begin(), c.end(),\n\t\t[&](uint32 x, uint32 y) {return a[x] < a[y];});\n\tstd::vector<char> r(n, 0),temp;\n\tfor (const auto v : c) {\n\t\tr[v] = 1;\n\t\tint64 as = INT64_MAX, ag = b[v];\n\t\tfor (const auto eee : G[v]) {\n\t\t\tconst auto e = U.find(eee);\n\t\t\tif (!r[e])\n\t\t\t\tcontinue;\n\t\t\tif (U.same(v, e))\n\t\t\t\tcontinue;\n\t\t\tag += b[e];\n\t\t\tif (a[e] + b[e] >= a[v])\n\t\t\t\tsmini(as, a[e]);\n\t\t\telse\n\t\t\t\tsmini(as, a[e] + (a[v] - b[e]));\n\t\t\tU.unite(e, v);\n\t\t}\n\t\tif (as == INT64_MAX)\n\t\t\tas = a[v];\n\t\tconst auto t = U.find(v);\n\t\ta[t] = as;\n\t\tb[t] = ag;\n\t}\n\n\tconst auto ans = U.find(0);\n\tIO << a[ans] + b[ans] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst LL N=100005;\nLL n,m; \nstruct qq\t{LL a,b,id;}s[N];\nLL fa[N];\nLL find_fa (LL x)\t{return fa[x]==x?x:fa[x]=find_fa(fa[x]);}\nbool cmp (qq x,qq y)\t{return x.a==y.a?x.b>y.b:x.a<y.a;}\nLL id[N];\nbool vis[N];\nvector<LL> vec[N],e[N];\nbool tf;\nLL tot[N];\nvoid dfs (LL x,LL lim)\n{\n//\tprintf(\"YES:%lld %lld %lld\\n\",x,lim,lim-(tot[x]-s[x].b));\n\tif (lim-(tot[x]-s[x].b)>=max(s[x].a,s[x].b))\t{tf=true;return ;}\n\tLL siz=vec[x].size();\n\tfor (LL u=0;u<siz;u++)\n\t{\n\t\tLL y=vec[x][u];\n\t\tLL t=lim-(tot[x]-tot[y]-s[x].b);\n\t\tif (t>=max(s[x].b,s[x].a)) dfs(y,t-s[x].b);\n\t}\n}\nvoid dfs1 (LL x)\n{\n\ttot[x]=s[x].b;\n\tLL siz=vec[x].size();\n\tfor (LL u=0;u<siz;u++)\t{dfs1(vec[x][u]);tot[x]=tot[x]+tot[vec[x][u]];}\n}\nint main()\n{\n//\tfreopen(\"rescue.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (LL u=1;u<=n;u++) fa[u]=u,vis[u]=false;\n\tLL l=0,r=0,lalal=-1;\n\tfor (LL u=1;u<=n;u++)\t\n\t{\n\t\tscanf(\"%lld%lld\",&s[u].a,&s[u].b);\n\t\tl=l+s[u].b;\n\t\tr=r+s[u].a+s[u].b;\n\t\ts[u].id=u;\n\t}\n\tsort(s+1,s+1+n,cmp);\n\tfor (LL u=1;u<=n;u++) id[s[u].id]=u;\n\tfor (LL u=1;u<=m;u++)\n\t{\n\t\tLL x,y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx=id[x];y=id[y];\n\t\te[x].push_back(y);e[y].push_back(x);\n\t}\n\t//printf(\"YES!\\n\");\n\tfor (LL u=1;u<=n;u++)\n\t{\n\t\t//printf(\"a:%lld b:%lld\\n\",s[u].a,s[u].b);\n\t\tLL siz=e[u].size();vis[u]=true;\n\t\tfor (LL i=0;i<siz;i++)\n\t\t{\n\t\t\tLL y=find_fa(e[u][i]);\n\t\t\tif (vis[y]==false) continue;\n\t\t\tif (y==u) continue;\n\t\t\tfa[y]=u;vec[u].push_back(y);\n\t\t\t//printf(\"link:%lld %lld\\n\",u,y);\n\t\t}\n\t}\n\tdfs1(n);\n//\tdfs(n,1000005483);\n\t/*for (LL u=1;u<=n;u++) printf(\"%lld %lld\\n\",s[u].a,s[u].b);\n\tfor (LL u=1;u<=n;u++) printf(\"%lld \",tot[u]);printf(\"\\n\");*/\n//\tprintf(\"YES:%lld %lld\\n\",l,r);\n\twhile (l<=r)\n\t{\n\t\tLL mid=(l+r)>>1;\n\t\ttf=false;dfs(n,mid);\n\t\tif (tf)\t{lalal=mid;r=mid-1;}\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",lalal);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nint i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nint tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tint x,y;\n}a[N];\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(int x,int y) {\n\treturn max(a[x].x-a[x].y,0)<max(a[y].x-a[y].y,0);\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tint r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=max(a[id[i]].x,a[id[i]].y);\n\t\t\ts[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tif (r==1) {\n\t\t\ts[id[i]]=S+a[id[i]].y;\n\t\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\t\tint p=max(a[id[i]].x,a[id[i]].y);\n\t\t\tA[id[i]]=min(max(1ll*a[id[i]].x,1ll*a[id[i]].y+A[q[1]]),S+p);\n\t\t\tcontinue;\n\t\t}\n\t\tint p=max(a[id[i]].x,a[id[i]].y);\n\t\tfor (j=1;j<=r;j++) M=min(M,S-s[q[j]]+max(1ll*a[id[i]].x,1ll*a[id[i]].y+A[q[j]]));\n\t\tM=min(M,S+p);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%lld\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nconst int N = 3e5 + 233;\nlo b[N], c[N], sumb[N], f[N];\nint n, m, pre[N], id[N];\nvector <int> G[N], F[N];\n\ninline bool cmp_c(int x, int y) {\n\treturn c[x] < c[y];\n}\n\ninline int find(int x) {\n\treturn pre[x] == x ? x : pre[x] = find(pre[x]);\n}\n\ninline void make(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y) return ;\n\tpre[y] = x; F[x].push_back(y);\n\t// cerr << x << \" -> \" << y << \"\\n\";\n}\n\ninline void dfs(int u) {\n\tsumb[u] = b[u];\n\tfor (int v : F[u]) {\n\t\tdfs(v);\n\t\tsumb[u] += sumb[v];\n\t}\n\tf[u] = c[u] + sumb[u];\n\tfor (int v : F[u]) {\n\t\tlo vtotal = sumb[u] - sumb[v];\n\t\tassert(vtotal >= 0);\n\t\tf[u] = min(f[u], max(c[u], f[v]) + vtotal);\n\t}\n\t// cout << u << \" \" << f[u] << \" \" << c[u] << \" \" << b[u] << \"\\n\";\n}\n\nint main(void) {\n\tread(n); read(m);\n\trep (i, n) read(c[i]), read(b[i]), c[i] = max(0ll, c[i] - b[i]);\n\trep (i, m) {\n\t\tint x, y; read(x); read(y);\n\t\tG[x].push_back(y); G[y].push_back(x);\n\t}\n\trep (i, n) id[i] = i, pre[i] = i;\n\tsort(id + 1, id + n + 1, cmp_c);\n\trep (i, n) {\n\t\tint u = id[i];\n\t\tfor (int v : G[u])\n\t\t\tif (c[v] < c[u]) make(u, v);\n\t}\n\tdfs(find(1));\n\tcout << f[find(1)] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <list>\n#include <numeric>\n#include <bitset>\n#include <ext/algorithm>\n#include <ext/numeric>\n#define ffor(_a,_f,_t) for(int _a=(_f),__t=(_t);_a<__t;_a++)\n#define all(_v) (_v).begin() , (_v).end()\n#define sz size()\n#define pb push_back\n#define SET(__set, val) memset(__set, val, sizeof(__set))\n#define FOR(__i, __n) ffor (__i, 0, __n)\ntypedef long long LL; using namespace std;\ntypedef pair<int, char> ICpair;\n\nint N, M;\n\nconst int MAXN = 200000;\n\nvector<int> G[MAXN];\nvector<LL> A, B;\n\nbool done[MAXN];\n\nconst int UNION_FIND_N = MAXN;\nint parent[UNION_FIND_N];\n\nLL has[MAXN];\n\n// assumes that if vertex v does not have parent,\n// i.e. if v is root, then parent[v] = v\nint root(int v) {\n\tif (parent[v] == v)\n\t\treturn v;\n\treturn parent[v] = root(parent[v]);\n}\n\nvoid merge(int u, int v) {\n\tparent[root(v)] = root(u);\n}\n\nvoid init_union_find() {\n\tfor (int i = 0; i < UNION_FIND_N; i++)\n\t\tparent[i] = i;\n}\n\npriority_queue<pair<LL, pair<int, int> > > heap;\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> N >> M;\n\tFOR (i, N)\n\t\tG[i].clear();\n\tA.clear();\n\tB.clear();\n\tint x, y;\n\tFOR (i, N) {\n\t\tcin >> x >> y;\n\t\tA.pb(x);\n\t\tB.pb(y);\n\t}\n\t\n\tvector<pair<LL, pair<int, int> > > edges;\n\tedges.clear();\n\tFOR (i, M) {\n\t\tcin >> x >> y;\n\t\tx--;\n\t\ty--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tsort(all(edges));\n\t\n\tLL s = 0LL, e = 10000000000LL, mid;\n\t\n\tLL ret = -1LL;\n\twhile (s <= e) {\n\t\tmid = (s + e) >> 1;\n\t\tSET(done, 0);\n\t\twhile (!heap.empty())\n\t\t\theap.pop();\n\t\tFOR (i, N) {\n\t\t\tLL val = max(0LL, A[i] - B[i]);\n\t\t\thas[i] = mid + B[i];\n\t\t\tif (mid >= val) {\n\t\t\t\tdone[i] = true;\n\t\t\t\tFOR (j, G[i].sz) {\n\t\t\t\t\tint x = i, y = G[i][j];\n\t\t\t\t\tLL valy = max(0LL, A[y] - B[y]);\n\t\t\t\t\theap.push(make_pair(-valy, make_pair(x, y)));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tinit_union_find();\n\t\twhile (!heap.empty()) {\n\t\t\tpair<LL, pair<int, int> > edge = heap.top();\n\t\t\theap.pop();\n\t\t\tint x = edge.second.first;\n\t\t\tint y = edge.second.second;\n\t\t\tif (root(x) == root(y))\n\t\t\t\tcontinue;\n\t\t\tif (has[root(x)] >= -edge.first) {\n\t\t\t\tLL tmp = has[root(x)] + has[root(y)] - mid;\n\t\t\t\tmerge(x, y);\n\t\t\t\thas[root(x)] = tmp;\n\t\t\t\tif (!done[y]) {\n\t\t\t\t\tdone[y] = true;\n\t\t\t\t\tFOR (j, G[y].sz) {\n\t\t\t\t\t\tint z = G[y][j];\n\t\t\t\t\t\tLL valz = max(0LL, A[z] - B[z]);\n\t\t\t\t\t\theap.push(make_pair(-valz, make_pair(y, z)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool allDone = true;\n\t\tFOR (i, N)\n\t\t\tallDone &= done[i];\n\t\tif (!allDone) {\n\t\t\ts = mid + 1;\n\t\t}\n\t\telse {\n\t\t\te = mid - 1;\n\t\t\tif (ret < 0LL || has[root(0)] < ret)\n\t\t\t\tret = has[root(0)];\n\t\t}\n\t}\n\t\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#ifdef CX_TEST\n#define Debug printf\n#else\n#define Debug(...)\n#endif\n#define LL long long\nusing namespace std;\ntypedef pair<int, int> P;\nconst int maxn = 1e5 + 5;\n\nint a[maxn], b[maxn], c[maxn], p[maxn];\nLL s[maxn], d[maxn];\nbool vis[maxn];\nvector<int> g[maxn];\n\nbool cmp(const int x, const int y) {\n    return a[x] < a[y];\n}\n\nint ff(int x) {\n    if(p[x] != x) p[x] = ff(p[x]);\n    return p[x];\n}\n\nint main() {\n#ifdef CX_TEST\n    freopen(\"E:\\\\program--GG\\\\test_in.txt\", \"r\", stdin);\n#endif\n    int n, m, i, j, u, v;\n    scanf(\"%d%d\", &n, &m);\n    for(i = 1;i <= n; i++) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n        a[i] = max(a[i] - b[i], 0);\n        s[i] = b[i];\n        d[i] = a[i];\n    }\n    for(i = 0;i < m; i++) {\n        scanf(\"%d%d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    for(i = 1;i <= n; i++) c[i] = i;\n    for(i = 1;i <= n; i++) p[i] = i;\n    sort(c + 1, c + n + 1, cmp);\n    for(i = 1;i <= n; i++) {\n        j = c[i];\n        vis[j] = 1;\n        for(auto e:g[j]) {\n            if(vis[e]) {\n                u = ff(j), v = ff(e);\n                if(u != v) {\n                    s[u] += s[v];\n                    p[v] = u;\n                    d[u] = min(d[u], d[v] + max(0LL, a[u] - d[v] - s[v]));\n                }\n            }\n        }\n    }\n    cout << s[c[n]] + d[c[n]] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int MAX_N = 1E5;\nconstexpr LL INF = 1E18;\nint n, m;\nvector<int> e[MAX_N];\nint a[MAX_N], b[MAX_N];\nint fa[MAX_N];\nint p[MAX_N];\nLL f[MAX_N], s[MAX_N];\nint find(int x) {\n    while (fa[x] >= 0 && fa[fa[x]] >= 0)\n        x = fa[x] = fa[fa[x]];\n    return fa[x] >= 0 ? fa[x] : x;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n        a[i] = max(a[i] - b[i], 0);\n    }\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    fill(fa, fa + n, -1);\n    iota(p, p + n, 0);\n    sort(p, p + n, [&](int i, int j) {return a[i] < a[j] || a[i] == a[j] && i < j;});\n    for (int i = 0; i < n; ++i) {\n        int u = p[i];\n        f[u] = a[u];\n        s[u] = b[u];\n        for (int v : e[u]) {\n            if (a[v] > a[u] || a[v] == a[u] && v > u)\n                continue;\n            v = find(v);\n            if (u == v)\n                continue;\n            fa[v] = u;\n            s[u] += s[v];\n            f[u] = min(f[u], max((LL)a[u], f[v]) - s[v]);\n        }\n        f[u] += s[u];\n    }\n    cout << f[find(0)] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100000\nusing namespace std;\ntypedef long long lnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nvector <int> G[MAX_N+5];\nint n, m; bool mrk[MAX_N+5];\nint a[MAX_N+5], b[MAX_N+5];\nlnt s[MAX_N+5], f[MAX_N+5];\nint p[MAX_N+5], fa[MAX_N+5];\nint getf(int x) {return fa[x] == x ? x : getf(fa[x]);}\nbool cmp(const int &x, const int &y) {return a[x] < a[y];}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]), read(b[i]), a[i] = max(a[i]-b[i], 0);\n\tfor (int i = 1, u, v; i <= m; i++)\n\t\tread(u), read(v), G[u].push_back(v), G[v].push_back(u);\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i] = fa[i] = i, f[i] = a[i], s[i] = b[i];\n\tsort(p+1, p+n+1, cmp);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u, fu, fv; mrk[u = p[i]] = true;\n\t\tfor (int v : G[u]) if (mrk[v] && ((fu = getf(u)) ^ (fv = getf(v))))\n\t\t\tfa[fv] = fu, s[fu] += s[fv], f[fu] = min(f[fu], max(f[fv], a[fu]-s[fv]));\n\t}\n\treturn printf(\"%lld\\n\", f[getf(1)]+s[getf(1)]), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/rope>\n//using namespace __gnu_pbds;\n//using namespace __gnu_cxx;\n//\n//template<class T> using Tree = tree<T, null_type, less<T>, rb_t_tag,t_order_statistics_node_update>;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n//const long long mod = 998244353;\n\n// watch this\n//using ll = long long;\n//typedef long long LL;\n#define ll long long\n#undef ll\n\nconst int mxN = 100010;\n\nvector<int> g[mxN];\nvector<int> tree[mxN];\n\nstruct DSU {\n\tvector<int> p, sz;\n\tDSU(int N) {\n\t\tp.resize(N);\n\t\tsz.resize(N, 1);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tp[i] = i;\n\t}\n\tint par(int x) {\n\t\tif (x == p[x])\n\t\t\treturn x;\n\t\treturn p[x] = par(p[x]);\n\t}\n\tbool mrg(int x, int y) {\n\t\tx = par(x), y = par(y);\n\t\tif (x == y)\n\t\t\treturn false;\n//\t\tif (sz[x] < sz[y]) {\n//\t\t\tswap(x, y);\n//\t\t}\n\t\tp[y] = p[x];\n\t\tsz[x] += sz[y];\n\t\treturn true;\n\t}\n};\n\nlong long A[mxN], B[mxN], srt[mxN];\nlong long dp[mxN];\nlong long sum[mxN];\n\nvoid dfs(int u) {\n\tsum[u] = B[u];\n\tfor (auto v : tree[u])\n\t\tdfs(v), sum[u] += sum[v];\n\tdp[u] = max(0ll, A[u] - B[u]);\n\tfor (auto v : tree[u]) {\n\t\tdp[u] = min(dp[u], max(dp[v], A[u] - B[u] - sum[v]));\n\t}\n//\tcerr << u << ' ' << dp[u] << '\\n';\n}\n\nbool can[mxN];\n\nint main(int argc, char** argv) {\n\t//#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t//#endif\n\n\tint N, M, u, v;\n\tcin >> N >> M;\n\tvector<int> ord(N);\n\tfor (int i = 1; i <= N; i++)\n\t\tcin >> A[i] >> B[i], srt[i] = max(A[i] - B[i], 0ll), ord[i - 1] = i;\n\tsort(begin(ord), end(ord), [&](int a,int b) {return srt[a] < srt[b];});\n//\tswap(ord[1], ord[2]);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tDSU dsu(N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto o : g[ord[i]])\n\t\t\tif (can[o]) {\n\t\t\t\tint p = dsu.par(o);\n\t\t\t\tif (p != ord[i])\n\t\t\t\t\ttree[ord[i]].push_back(p), dsu.mrg(ord[i], p);\n\t\t\t}\n\t\tcan[ord[i]] = true;\n//\t\tcerr << ord[i] << \":\\n\";\n//\t\tfor (auto o : tree[ord[i]])\n//\t\t\tcerr << o << ' ';\n//\t\tcerr << '\\n';\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tif (dsu.par(i) == i)\n\t\t\tdfs(i), cout << dp[i] + sum[i] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree;\n  vector<vector<int>> list;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    list.resize(v);\n    REP(i,v) tree[i] = i, list[i].push_back(i);\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return list[root(i)].size();\n  }\n\n  vector<int> nodes(int no){\n    return list[root(no)];\n  }\n\n  bool unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x==y) return false;\n    if(list[x].size() < list[y].size()) swap(x,y);\n    for(int no:list[y]) list[x].emplace_back(no);\n    tree[y] = x;\n    return true;\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nconst int N = 1e5+10;\nvector<P> e[N];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  vector<int> a(n),b(n);\n  vector<P> c(n);\n  REP(i,n) cin >> a[i] >> b[i], c[i] = P(max(0LL,a[i]-b[i]),i);\n  \n  using T = tuple<int,int,int>;\n  vector<int> edge[n];\n  REP(_,m){\n    int x,y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].emplace_back(y);\n    edge[y].emplace_back(x);\n  }\n\n  sort(c.begin(),c.end());\n\n  UnionFind uf(n);\n  vec sb = b, dp(n), used(n,0);\n  REP(i,n) dp[c[i].sc] = c[i].fs;\n\n  REP(i,n){\n    int no = c[i].sc, mn = c[i].fs, sum = b[no];\n    //cout << no SP mn SP sum << endl;\n    for(int to:edge[no]){\n      if(!used[to]) continue;\n      int v = uf.root(to);\n      mn = min(mn,max(dp[v],c[i].fs-sb[v]));\n    }\n    used[no]++;\n    for(int to:edge[no]){\n      if(!used[to]) continue;\n      if(!uf.isUnit(no,to)){\n        sum += sb[uf.root(to)];\n        uf.unit(no,to);\n      }\n    }\n    //cout << uf.root(no) SP mn SP sum << endl;\n    dp[uf.root(no)] = mn;\n    sb[uf.root(no)] = sum;\n  }\n\n  //REP(i,n) cout << dp[i] << endl;\n\n  int v = uf.root(0);\n  cout << dp[v] + sb[v] << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=3e5+10;\nint rd()\n{\n\tint x=0,w=1;char ch=0;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*w;\n}\nint to[N<<1],nt[N<<1],hd[N],tot=1;\nvoid adde(int x,int y)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n}\nint n,m,sq[N],ff[N],st[N],tp;\nLL a[N],b[N],f[N],g[N];\nbool vs[N];\nbool cmp(int aa,int bb){return a[aa]-b[aa]<a[bb]-b[bb];}\nint findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\n\nint main()\n{\n\tn=rd(),m=rd();\n\tfor(int i=1;i<=n;++i) a[i]=rd(),b[i]=rd(),sq[i]=ff[i]=i;\n\tsort(sq+1,sq+n+1,cmp);\n\tfor(int i=1;i<=m;++i) adde(rd(),rd());\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint x=sq[i];\n\t\tg[x]=b[x],vs[x]=1;\n\t\tfor(int j=hd[x];j;j=nt[j])\n\t\t{\n\t\t\tint y=findf(to[j]);\n\t\t\tif(!vs[y]||y==x) continue;\n\t\t\tff[y]=x,g[x]+=g[y],st[++tp]=y;\n\t\t}\n\t\tif(!tp) f[x]=max(a[x],b[x]);\n\t\telse\n\t\t{\n\t\t\tf[x]=1ll<<50;\n\t\t\twhile(tp)\n\t\t\t{\n\t\t\t\tint y=st[tp--];\n\t\t\t\tf[x]=min(f[x],-g[y]+max(f[y],max(a[x]-b[x],0ll)));\n\t\t\t}\n\t\t\tf[x]+=g[x];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[sq[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005;\nconst LL INF=1e18;\nint n,m,rt;\nLL a[N],b[N],c[N];\nvector <int> son[N];\nnamespace Build_Tree{\n\tvector <int> e[N];\n\tint id[N];\n\tbool cmp(int x,int y){\n\t\tif (a[x]!=a[y])\n\t\t\treturn a[x]<a[y];\n\t\treturn b[x]>b[y];\n\t}\n\tint fa[N],vis[N];\n\tint getf(int x){\n\t\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n\t}\n\tvoid main(){\n\t\tFor(i,1,m){\n\t\t\tint x=read(),y=read();\n\t\t\te[x].pb(y),e[y].pb(x);\n\t\t}\n\t\tFor(i,1,n)\n\t\t\tid[i]=fa[i]=i;\n\t\tsort(id+1,id+n+1,cmp);\n\t\tFor(i,1,n){\n\t\t\tint x=id[i];\n\t\t\tfor (auto y : e[x])\n\t\t\t\tif (vis[y]&&getf(y)!=x){\n\t\t\t\t\tson[x].pb(getf(y));\n//\t\t\t\t\tprintf(\"%d -> %d\\n\",x,getf(y));\n\t\t\t\t\tfa[getf(y)]=x;\n\t\t\t\t}\n\t\t\tvis[x]=1;\n\t\t}\n\t\trt=id[n];\n\t}\n}\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\npair <LL,LL> Merge(pair <LL,LL> a,pair <LL,LL> b){\n\treturn mp(max(a.fi,a.se+b.fi),a.se+b.se);\n}\nvoid dfs(int x){\n\tfor (auto y : son[x])\n\t\tdfs(y);\n\tsort(son[x].begin(),son[x].end(),cmp);\n\treverse(son[x].begin(),son[x].end());\n\tint m=son[x].size();\n\tvector <pair <LL,LL> > pre(m+1,mp(0,0)),suf(m+1,mp(0,0));\n\tFor(i,0,m-1){\n\t\tint y=son[x][i];\n\t\tpre[i+1]=Merge(pre[i],mp(a[y],b[y]));\n\t}\n\tFod(i,m-1,0){\n\t\tint y=son[x][i];\n\t\tsuf[i]=Merge(mp(a[y],b[y]),suf[i+1]);\n\t}\n\tc[x]=INF;\n\tFor(i,0,m-1){\n\t\tint y=son[x][i];\n\t\tpair <LL,LL> tmp=Merge(pre[i],suf[i+1]);\n\t\ttmp=Merge(tmp,mp(a[x],b[x]));\n\t\tc[x]=min(c[x],Merge(tmp,mp(c[y],b[y])).fi);\n\t}\n\tpair <LL,LL> tmp=Merge(pre[m],mp(a[x],b[x]));\n//\toutval(pre[m].fi),outval(pre[m].se);\n//\tprintf(\"%d: %lld,%lld,%lld\\n\",x,a[x],b[x],c[x]);\n\ta[x]=tmp.fi,b[x]=tmp.se;\n\tc[x]=min(c[x],a[x]);\n//\tprintf(\"%d: %lld,%lld,%lld\\n\",x,a[x],b[x],c[x]);\n}\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,n)\n\t\ta[i]=read(),b[i]=read();\n\tBuild_Tree::main();\n\tdfs(rt);\n\tcout<<max(b[rt],c[rt])<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\nstruct ComputationTree{\n    vector<pll> tree;\n    ComputationTree(int _n)\n    {\n        tree.resize(4 * _n);\n    }\n    pll Merge(pll a, pll b)\n    {\n        ll v = max(a.first, a.second) + b.first;\n        return {a.first + b.first, max(v, b.second)};\n    }\n    void Set(int pos, pll val, int L, int R, int V)\n    {\n        if (L + 1 == R)\n        {\n            tree[V] = val;\n            return;\n        }\n        int M = (L + R) / 2;\n        if (pos < M) Set(pos, val, L, M, 2 * V + 1);\n        else Set(pos, val, M, R, 2 * V + 2);\n        tree[V] = Merge(tree[2 * V + 1], tree[2 * V + 2]);\n    }\n    ll Get()\n    {\n        return max(tree[0].first, tree[0].second);\n    }\n};\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    ComputationTree T(cp.size() + 1);\n    T.Set(1, {b[v], a[v]}, 0, cp.size() + 1, 0);\n    for (int i = 1; i < cp.size(); i++)\n    {\n        T.Set(i + 1, {cp[i].second, cp[i].first}, 0, cp.size() + 1, 0);\n    }\n    T.Set(0, {cp[0].second, cp[0].first}, 0, cp.size() + 1, 0);\n    min_cost_in = min(min_cost_in, T.Get());\n    for (int i = 1; i < cp.size(); i++)\n    {\n        T.Set(0, {cp[i].second, cp[i].first}, 0, cp.size() + 1, 0);\n        T.Set(i + 1, {cp[0].second, cp[0].first}, 0, cp.size() + 1, 0);\n        min_cost_in = min(min_cost_in, T.Get());\n        T.Set(i + 1, {cp[i].second, cp[i].first}, 0, cp.size() + 1, 0);\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef unsigned int uint;\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nconst int MX = 200005;\n\nstruct UF{\n\tint t[MX], ans[MX], tB[MX];\n\tint find(int x){ return t[x] ? t[x] = find(t[x]) : x; }\n\tint merge(int a, int b){ // a <- b\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return false;\n\t\tt[b] = a; tB[a] += tB[b]; return true;\n\t}\n}uf;\n\nint N, M;\npii D[MX];\nvector<int> G[MX];\nint P[MX], chk[MX];\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d%d\", &D[i].first, &D[i].second);\n\tfor(int i = 1; i <= M; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++) P[i] = i;\n\tsort(P+1, P+N+1, [](int l, int r){ \n\t\treturn D[l].first < D[r].first;\n\t});\n\tfor(int i = 1; i <= N; i++) uf.tB[i] = D[i].second;\n\tfor(int i = 1; i <= N; i++){\n\t\tint cur = P[i], A = D[cur].first, B = D[cur].second;\n\t\tint ans = max(A-B, 0);\n\t\tfor(int c : G[cur]){\n\t\t\tif(!chk[c]) continue;\n\t\t\tint u = uf.find(c);\n\t\t\tans = min(ans, max(uf.ans[u], A - (B+uf.tB[u])));\n\t\t}\n\t\tuf.ans[cur] = ans;\n\t\tfor(int c : G[cur]) if(chk[c]) uf.merge(cur, c);\n\t\tchk[cur] = 1;\n\t}\n\tint p = uf.find(1);\n\tprintf(\"%d\\n\", uf.ans[p] + uf.tB[p]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define chmin(a,b) a=min(a,b);\n#define chmax(a,b) a=max(a,b);\n#define N 100010\nvector<ll> e[N];\nll n,m,a[N],b[N];\n\nnamespace uf{\n  ll p[N];\n  void init(){\n      for(int i=0;i<N;i++)p[i]=i;\n  }\n  ll par(ll x){return p[x]=(x==p[x]?x:par(p[x]));}\n  void unite(ll x,ll y){\n      x=par(x),y=par(y);\n      if(x!=y){\n\t  p[x]=y;\n      }\n  }\n  bool same(ll x,ll y){return par(x)==par(y);}\n};\n\nll f[N],g[N];\nP dat[N]; bool vis[N];\nint main(){\n  cin>>n>>m;\n  for(int i=1;i<=n;i++){\n      cin>>a[i]>>b[i];\n      dat[i-1]=make_pair(a[i]-b[i],i);\n  }\n  sort(dat,dat+n);\n  \n  for(int i=0;i<m;i++){\n      ll x,y;cin>>x>>y;\n      e[x].push_back(y);\n      e[y].push_back(x);\n  }\n  \n  for(int i=1;i<=n;i++)vis[i]=0,g[i]=b[i];\n  uf::init();\n  for(int i=0;i<n;i++){\n      int y=dat[i].second; vis[y]=1;\n      f[y]=1e17; //cout<<\"#\"<<y<<endl;\n      vector<ll> vist;\n      for(auto x:e[y])if(vis[x]==1&&uf::same(x,y)==0){\n\t  x=uf::par(x); vist.push_back(x);\n\t  g[y]+=g[x];\n\t  uf::unite(x,y);\n      }\n      if(g[y]==b[y]){f[y]=max(a[y],b[y]); continue;}\n      for(auto x:vist){\n\t  chmin(f[y],max(a[y],b[y]+f[x])+g[y]-g[x]-b[y]);\n      }\n  }\n  cout<<f[dat[n-1].second]<<endl;\n  //for(int i=1;i<=n;i++)cout<<f[i]<<\" \"<<g[i]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int & \n#define SZ(a) ((int)(a.size()))\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n\tfor (T x : a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\nconst int N = 1e5 + 9;\nconst ll oo = 1e15;\nint parent[N];\nint is_free[N];\nll bsum[N];\nvi g[N];\nint n, m;\nll a[N], b[N];\n\nset<int> inside[N];\nset<pair<ll, int>> neibs[N];\nll gw, gb;\nset<pair<ll, int>> fre;\nint counter = 0;\n\nvoid make_set(int v) {\n\t++counter;\n\tinside[v].insert(v);\n\tparent[v] = v;\n\tbsum[v] = b[v];\n\tfor (int to : g[v])\n\t\tneibs[v].insert(mp(a[to] - b[to], to));\n}\n\nint find_set(int v) {\n\tif (parent[v] == v) return v;\n\treturn parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int u, int v) {\n\tu = find_set(u);\n\tv = find_set(v);\n\tif (u == v) return;\n\t--counter;\n\tis_free[v] = 1;\n\tif (SZ(neibs[u]) < SZ(neibs[v]))\n\t\tswap(v, u);\n\tinside[u].insert(ALL(inside[v]));\n\tbsum[u] += bsum[v];\n\tparent[v] = u;\n\tneibs[u].insert(ALL(neibs[v]));\n}\n\nvoid add_to_free(int u) {\n\twhile (!neibs[u].empty()) {\n\t\tbool ok = 0;\n\t\tif (inside[u].count((*neibs[u].begin()).second)) {\n\t\t\tok = 1;\n\t\t\tneibs[u].erase(neibs[u].begin());\n\t\t}\n\t\tif (!ok) break;\n\t}\n\tif (neibs[u].empty()) {\n\t\tassert(counter == 1);\n\t\treturn;\n\t}\n\tint superv = (*neibs[u].begin()).second;\n\tfre.insert(mp(a[superv] - b[superv] - bsum[u], u));\n}\n\nvoid add_to_cool(int v) {\n\tv = find_set(v);\n\tis_free[v] = 1;\n\twhile (!neibs[v].empty() && (*neibs[v].begin()).first + gb - bsum[v] <= gw) {\n\t\tint u = (*neibs[v].begin()).second;\n\t\tneibs[v].erase(neibs[v].begin());\n\t\tunion_sets(v, u);\n\t\tv = find_set(v);\n\t}\n\tadd_to_free(v);\n}\n\n\n\nll solve() {\n\tif (n == 1) {\n\t\treturn a[1];\n\t}\n\tgb = accumulate(b + 1, b + n + 1, 0LL);\n\tfori(i, n) {\n\t\tmake_set(i + 1);\n\t\tfre.insert(mp(a[i + 1] - b[i + 1], i + 1));\n\t}\n\twhile (counter > 1) {\n\t\tll minim = (*fre.begin()).first;\n\t\t// minim + gb <= gw\n\t\t//watch(minim);\n\t\tgw = minim + gb;\n\t\twhile (!fre.empty() && (*fre.begin()).first + gb == gw) {\n\t\t\tint v = find_set((*fre.begin()).second);\n\t\t\tfre.erase(fre.begin());\n\t\t\tadd_to_cool(v);\n\t\t}\n\t}\n\treturn gw;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tmmax(a[i], b[i]);\n\t}\n\tfori(iter, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\tcout << solve() << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u1, u2; cin >> u1 >> u2; u1--; u2--;\n\t\tu1 = trans[u1], u2= trans[u2];\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i]+csum);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = mi;\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\ntypedef pair<int, int> P;\nvector<int> G[N];\nP p[N];\nint fa[N], a[N], b[N], vis[N], dp[N], sz[N];\nint F(int x) { return x == fa[x] ? x : (fa[x] = F(fa[x])); }\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n        p[i] = P(max(0, a[i] - b[i]), i);\n        fa[i] = i;\n        sz[i] = b[i];\n    }\n    for(int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    sort(p + 1, p + n + 1);\n    for(int i = 1; i <= n; i++) {\n        int x = p[i].second, mn = p[i].first;\n        vis[x] = 1;\n        for(int v : G[x]) {\n            if(vis[v]) {\n                int fv = F(v);\n                mn = min(mn, max(p[i].first - sz[fv], dp[fv]));\n            }\n        }\n        for(int v : G[x]) {\n            if(vis[v]) {\n                int fv = F(v);\n                if(fv == x) continue;\n                fa[fv] = x;\n                sz[x] += sz[fv];\n            }\n        }\n        dp[x] = mn;\n    }\n    cout << dp[F(1)] + sz[F(1)] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 100005\n#define ll long long \nusing namespace std;\n\nint n,m,i,j,k,a[maxn],b[maxn],c[maxn],id[maxn];\nint em,e[maxn*2],nx[maxn*2],ls[maxn];\nint cmp(int i,int j){return c[i]<c[j];}\n\nvoid insert(int x,int y){\n\tem++; e[em]=y; nx[em]=ls[x]; ls[x]=em;\n\tem++; e[em]=x; nx[em]=ls[y]; ls[y]=em;\n}\n\nint fa[maxn]; ll g[maxn],f[maxn];\nint father(int x){return (fa[x]==x)?x:fa[x]=father(fa[x]);}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) scanf(\"%d%d\",&a[i],&b[i]),c[i]=a[i]-b[i];\n\tfor(i=1;i<=m;i++) scanf(\"%d%d\",&j,&k),insert(j,k);\n\tfor(i=1;i<=n;i++) id[i]=i;sort(id+1,id+1+n,cmp);\n\tfor(int now=1;now<=n;now++){int x=id[now];\n\t\tfa[x]=x,f[x]=max(0,c[x]),g[x]=b[x];\n\t\tfor(i=ls[x];i;i=nx[i]) if (fa[e[i]]){int y=e[i];\n\t\t\tif (father(x)!=father(y)){\n\t\t\t\ty=fa[y];\n\t\t\t\tf[x]=min(f[x],max(f[y],c[x]-g[y]));\n\t\t\t\tg[x]+=g[y],fa[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[father(1)]+g[father(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nint i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nint tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tint x,y;\n}a[N];\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(int x,int y) {\n\treturn a[x].x<a[y].x;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tint r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=s[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tif (r==1) {\n\t\t\ts[id[i]]=S+a[id[i]].y;\n\t\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\t\tA[id[i]]=A[q[1]]+a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) M=min(M,max(1ll*a[id[i]].x,A[q[j]]+a[id[i]].y)+S-s[q[j]]);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%lld\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200005;\nint flag[N],f[N],c[N],dp[N],x,y,n,m,id[N],rk[N],ne[N],fi[N],zz[N],tot,size[N],a[N],b[N];\nvector<int> G[N];\nint find(int x){\n\tif (x==f[x])return x;\n\treturn f[x]=find(f[x]);\n}\nint cmp(int x,int y){\n\treturn c[x]<c[y];\n}\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nvoid dfs1(int x){\n\tsize[x]=b[x];\n\tfor (int i=0;i<G[x].size();i++)dfs1(G[x][i]),size[x]+=size[G[x][i]];\n}\nvoid dfs2(int x){\n\tif (!G[x].size()){\n\t\tdp[x]=b[x]+c[x];\n\t\treturn;\n\t}\n\tdp[x]=1e18;\n\tfor (int i=0;i<G[x].size();i++)dfs2(G[x][i]),dp[x]=min(dp[x],max(c[x],dp[G[x][i]])+size[x]-size[G[x][i]]);\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld%lld\",&a[i],&b[i]),c[i]=max(a[i]-b[i],0ll);\n\tfor (int i=1;i<=n;i++)f[i]=i,id[i]=i;\n\twhile (m--){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tjb(x,y);jb(y,x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++)rk[id[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=fi[id[i]];j;j=ne[j]){\n\t\t\tx=find(id[i]),y=find(zz[j]);\n\t\t\tif (id[i]!=y&&rk[x]>rk[y])G[id[i]].push_back(y),f[y]=id[i],flag[zz[j]]=1;\n\t\t}\n\tint root=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])root=i;\n\tdfs1(root);\n\tdfs2(root);\n\tprintf(\"%lld\\n\",size[root]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next;\n}e[N*2];\nint head[N],tot,n,m;\nint A[N],B[N],C[N],id[N];\nint fa[N],vis[N];\nll mx[N],S[N];\nbool cmp(int x,int y){\n\treturn C[x]<C[y];\n}\nint get(int x){\n\treturn x==fa[x]?x:fa[x]=get(fa[x]);\n}\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,n) scanf(\"%d%d\",&A[i],&B[i]);\n\tFor(i,1,n) C[i]=max(0,A[i]-B[i]),id[i]=i;\n\tFor(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tFor(i,1,n) fa[i]=i;\n\tFor(i,1,n){\n\t\tint x=id[i]; vis[x]=1;\n\t\tmx[x]=C[x]; S[x]=B[x];\n\t\tfor (int j=head[x];j;j=e[j].next)\n\t\t\tif (vis[e[j].to]&&get(e[j].to)!=get(x)){\n\t\t\t\tint y=get(e[j].to);\n\t\t\t\tmx[x]=min(mx[x],mx[y]+max(0ll,C[x]-(S[y]+mx[y])));\n\t\t\t\tS[x]=S[x]+S[y]; fa[y]=x;\n\t\t\t}\n\t}\n\tprintf(\"%lld\",S[get(1)]+mx[get(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,m,doe;\nint fa[101010],id[101010];\nint pre[202020],son[202020],now[101010];\nll a[101010],b[101010],f[101010],sum[101010];\nbool br[101010];\nint find(int x)\n{\n\tif (fa[x]==x) return fa[x];\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\nvoid add(int x,int y)\n{\n\t++doe;\n\tpre[doe]=now[x];\n\tnow[x]=doe;\n\tson[doe]=y;\n}\nbool cmp(int u,int w)\n{\n\treturn a[u]<a[w];\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld%lld\",&a[i],&b[i]),a[i]=max(a[i]-b[i],0ll);\n\tint x,y;\n\tfor (int i=1;i<=m;++i) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\t\n\tfor (int i=1;i<=n;++i) id[i]=i,fa[i]=i,f[i]=a[i],sum[i]=b[i];\n\tsort(id+1,id+1+n,cmp);\n\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tx=id[i];\n\t\tbr[x]=1;\n\t\tint p=now[x];\n\t\twhile (p)\n\t\t{\n\t\t\tint y=son[p];\n\t\t\tif (br[y])\n\t\t\t{\n\t\t\t\tint xx=find(x),yy=find(y);\n\t\t\t\tif (xx!=yy)\n\t\t\t\t{\n\t\t\t\t\tfa[yy]=xx;\n\t\t\t\t\tsum[xx]+=sum[yy];\n\t\t\t\t\tf[xx]=min(f[xx],max(f[yy],a[xx]-sum[yy]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tp=pre[p];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum[id[n]]+f[id[n]]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n#define ll long long\n#define rint register int\ninline int read(){int r;int s=0,c;for(;!isdigit(c=getchar());s=c);for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);return s^45?r:-r;}\nvector<int> e[MAXN+5], g[MAXN+5]; int A[MAXN+5], B[MAXN+5], fa[MAXN+5], rk[MAXN+5] ,o[MAXN+5], n, m; ll f[MAXN+5], s[MAXN+5];\ninline bool cmp(int i, int j){return A[i]<A[j];} inline int getf(int x){return x^fa[x]?fa[x]=getf(fa[x]):x;}\nll DP(int p){for(auto v:g[p]) f[p] = min(f[p],max((ll)A[o[p]],DP(v))-s[v]), s[p] += s[v]; return f[p] += s[p];}\nint main()\n{\n\tn = read(); m = read(); for(rint i = 1; i <= n; A[i] = read(), B[i] = read(), A[i] = max(A[i]-B[i],0), fa[i] = o[i] = i, i++); sort(o+1,o+n+1,cmp);\n\tfor(rint i = 1; i <= n; rk[o[i]] = i, f[i] = A[o[i]], s[i] = B[o[i]], i++); for(rint a, b; m--; a = rk[read()], b = rk[read()], e[a].push_back(b), e[b].push_back(a));\n\tfor(rint u = 1, U, V; u <= n; u++) for(auto v:e[u]) v<u&&(V=getf(v))^(U=getf(u))?g[U].push_back(V),fa[V]=U:0; printf(\"%lld\\n\",DP(getf(1))); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F(i,a,b) for(int i=(a);i<=(b);++i)\n#define F_(i,a,b) for(int i=(a);i>=(b);--i)\n#define G(i,u) for(int i=head[u];i;i=nxt[i])\n \ntypedef long long ll;\n \nconst int N = 100005;\n \ntemplate<typename T> inline T min(T& a, T b) {return a<b?a:a=b;}\n \nint head[N], to[N<<1], nxt[N<<1], a[N], b[N], r[N], g[N], son[N], ecnt;\nvoid add(int u, int v) { to[++ecnt] = v; nxt[ecnt] = head[u]; head[u] = ecnt; }\nbool cmp(const int& x, const int& y) { return a[x] < a[y]; }\nint find(int x) { return g[x] == x? x: g[x] = find(g[x]); }\nll f[N], sum[N];\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tF(i,1,n) {\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\ta[i] = std::max(a[i]-b[i],0); \n\t\tr[i] = i;\n\t}\n\tF(i,1,m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u,v); add(v,u);\n\t}\n\tstd::sort(r+1,r+n+1,cmp);\n\tF(i,1,n) {\n\t\tint x = r[i], tot = 0; g[x] = x; sum[x] = b[x];\n\t\tG(j,x) {\n\t\t\tint v = to[j], p = find(v);\n\t\t\tif(!p || p == x) continue;\n\t\t\tson[++tot] = p;\n\t\t\tsum[x] += sum[p];\n\t\t\tg[p] = x;\n\t\t}\n\t\tf[x] = a[x] + sum[x];\n\t\tF(j,1,tot) min(f[x],sum[x]-sum[son[j]]+std::max(f[son[j]],1ll*a[x]));\n\t}\n\tprintf(\"%lld\\n\", f[r[n]]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  vector<int> sz;\n    \n  UnionFind(int n = 210000) { init(n); }\n  void init(int n = 210000) {\n\tpar.resize(n); sz.resize(n);\n\tfor (int i = 0; i < n; ++i) par[i] = i, sz[i] = 1;\n  }\n    \n  int root(int x) {\n\tif (par[x] == x) return x;\n\telse return par[x] = root(par[x]);\n  }\n    \n  bool issame(int x, int y) {\n\treturn root(x) == root(y);\n  }\n\n  int size(int x) {\n\treturn sz[root(x)];\n  }\n\n  bool direct(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tpar[x] = y;\n\treturn true;\n  }\n    \n  friend ostream& operator << (ostream& s, UnionFind uf) {\n\tmap<int, vector<int> > res;\n\tfor (int i = 0; i < uf.par.size(); ++i) {\n\t  int r = uf.root(i);\n\t  res[r].push_back(i);\n\t}\n\tfor (map<int, vector<int> >::iterator it = res.begin(); it != res.end(); ++it) {\n\t  s << endl;\n\t  for (int j = 0; j < (int)it->second.size(); ++j) {\n\t\ts << it->second[j] << \", \";\n\t  }\n\t}\n\treturn s << endl;\n  }\n};\n\ntypedef pair<long long, long long> pll;\n\nint N, M;\nvector<long long> a, b;\nvector<vector<int> > G;\n\nbool cmp(int i, int j) {\n  return a[i] - b[i] < a[j] - b[j];\n}\n\nint main() {\n  cin >> N >> M;\n  a.resize(N); b.resize(N);\n  for (int i = 0; i < N; ++i) {\n\tcin >> a[i] >> b[i];\n  }\n  G.clear(); G.resize(N);\n  for (int i = 0; i < M; ++i) {\n\tint u, v; cin >> u >> v; --u, --v;\n\tG[u].push_back(v); G[v].push_back(u);\n  }\n  vector<int> ord(N);;\n  std::iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), cmp);\n\n  vector<long long> sumB(N), dp(N), seen(N, 0);\n  for (int i = 0; i < N; ++i) {\n\tsumB[i] = b[i];\n\tdp[i] = max(a[i], b[i]);\n  }\n  UnionFind uf(N);\n  for (auto v : ord) {\n\tset<int> adj;\n\tfor (auto to : G[v]) {\n\t  if (!seen[to]) continue;\n\t  adj.insert(uf.root(to));\n\t}\n\tlong long tmpsum = b[v];\n\tfor (auto r : adj) {\n\t  tmpsum += sumB[r];\n\t  uf.direct(r, v);\n\t}\n\tsumB[v] = tmpsum;\n\tif (!adj.empty()) {\n\t  long long minv = 1LL<<59;\n\t  for (auto r : adj) {\n\t\tlong long subB = tmpsum - sumB[r];\n\t\tlong long tmp = subB + max(a[v] - b[v], dp[r]);\n\t\tminv = min(minv, tmp);\n\t  }\n\t  dp[v] = minv;\n\t}\n\tseen[v] = true;\n\n\t//cout << \"-------------------------\" << endl;\n\t//cout << v << \": \" << dp[v] << \", \" << sumB[v] << endl;\n  }\n  cout << dp[uf.root(0)] << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\n#define M 100010\nusing namespace std;\nstruct EDGE{\n\tll u, v;\n\tll Next;\n}G[M << 1];\nll Head[N];\nll tot = 0;\ninline void Add(ll u, ll v)\n{\n\t++ tot;\n\tG[tot].u = u;\n\tG[tot].v = v;\n\tG[tot].Next = Head[u];\n\tHead[u] = tot;\n}\nstruct Node{\n\tll a, b, num;\n}E[N];\ninline bool cmp(Node x, Node y)\n{\n\treturn x.a - x.b < y.a - y.b;\n}\nll f[N];\nll b[N];\nll w[N];\ninline ll Get(ll u)\n{\n\treturn f[u] == u ? u : f[u] = Get(f[u]);\n}\nbool vis[N];\nll d[N], top;\nint main()\n{\n\tll n, m;\n\tscanf(\"%lld%lld\", &n, &m);\n\tfor(ll i = 1; i <= n; ++ i)\n\t\tscanf(\"%lld%lld\", &E[i].a, &E[i].b);\n\tfor(ll i = 1; i <= m; ++ i)\n\t{\n\t\tll u, v;\n\t\tscanf(\"%lld%lld\", &u, &v);\n\t\tAdd(u, v);\n\t\tAdd(v, u);\n\t}\n\tfor(ll i = 1; i <= n; ++ i)\n\t{\n\t\tE[i].num = i;\n\t\tb[i] = E[i].b;\n\t\tf[i] = i;\n\t}\n\tsort(E + 1, E + n + 1, cmp);\n\tfor(ll i = 1; i <= n; ++ i)\n\t{\n\t\tvis[E[i].num] = true;\n\t\tll sumb = 0;\n\t\ttop = 0;\n\t\tfor(ll j = Head[E[i].num]; j; j = G[j].Next)\n\t\t{\n\t\t\tll v = G[j].v;\n\t\t\tif(! vis[v])\n\t\t\t\tcontinue;\n\t\t\tll fv = Get(v);\n\t\t\tif(fv != E[i].num)\n\t\t\t{\n\t\t\t\tsumb += b[fv];\n\t\t\t\td[++ top] = fv;\n\t\t\t\tf[fv] = E[i].num;\n\t\t\t}\n\t\t}\n\t\tb[E[i].num] = sumb + E[i].b;\n\t\tw[E[i].num] = 2147483647;\n\t\tfor(ll j = 1; j <= top; ++ j)\n\t\t\tw[E[i].num] = min(w[E[i].num], sumb - b[d[j]] + max(w[d[j]] + E[i].b, E[i].a));\n\t\tw[E[i].num] = min(w[E[i].num], sumb + max(E[i].a, E[i].b));\n\t}\n\tprintf(\"%lld\", w[E[n].num]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] < sz[y]){\n            par[x] = y;\n            sz[y] += sz[x];\n        }else{\n            par[y] = x;\n            sz[x] += sz[y];\n        }\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    static int64_t A[100000], B[100000], C[100000];\n    for(int i=0; i<N; i++){\n        cin >> A[i] >> B[i];\n        C[i] = max(A[i] - B[i], (int64_t) 0);\n    }\n    vector<int> edges[100000];\n    for(int i=0; i<M; i++){\n        int a, b;\n        cin >> a >> b;\n        edges[a-1].push_back(b-1);\n        edges[b-1].push_back(a-1);\n    }\n\n    vector<int> order;\n    for(int i=0; i<N; i++) order.push_back(i);\n    sort(order.begin(), order.end(), [&](int a, int b){ return C[a] < C[b];});\n\n    UnionFind uf(N);\n    bitset<100000> used;\n    static int64_t dp[100000];\n    for(int i : order){\n        used[i] = true;\n        int64_t result = C[i], Bsum = B[i];\n        for(int j : edges[i]) if(used[j] && !uf.same(i, j)){\n            j = uf.find(j);\n            result = min(result, max(C[i] - B[j], dp[j]));\n            Bsum += B[j];\n            uf.unite(i, j);\n        }\n        i = uf.find(i);\n        dp[i] = result;\n        B[i] = Bsum;\n    }\n\n    int64_t ans = dp[uf.find(0)] + B[uf.find(0)];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nint n, m, A[N], B[N], C[N], id[N], dsu[N];\nlong long dp[N], sum[N];\nbool vis[N];\nvector<int> G[N];\nint Find(int x) { return x == dsu[x] ? x : dsu[x] = Find(dsu[x]); }\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tC[i] = max(A[i] - B[i], 0);\n\t\tid[i] = i;\n\t\tdsu[i] = i;\n\t\tvis[i] = false;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tsort(id + 1, id + 1 + n, [](int i, int j) {\n\t\treturn C[i] < C[j];\n\t});\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u = id[i];\n\t\tvis[u] = true;\n\t\tsum[u] = B[u];\n\t\tvector<int> sons;\n\t\tfor (int v : G[u]) {\n\t\t\tif (!vis[v] || Find(u) == Find(v)) continue;\n\t\t\tint rv = Find(v);\n\t\t\tsons.push_back(rv);\n\t\t\tsum[u] += sum[rv];\n\t\t\tdsu[rv] = u;\n\t\t}\n\t\tdp[u] = sum[u] + C[u];\n\t\tfor (int v : sons) {\n\t\t\tdp[u] = min(dp[u], sum[u] - sum[v] + max(dp[v], 1ll * C[u]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],s[N],q[N];\nll sum;int n,m,l,r,mid,ans,mx;\n//inline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n//void merge(int u,int v){\n//\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n//\twhile(!Q[v].empty()){\n//\t\tR pi p=Q[v].top();Q[v].pop();\n//\t\tif(find(p.se)!=find(u))Q[u].push(p);\n//\t}\n//}\n//bool ck(){\n//\tint h=1,t=0,u;\n//\tfp(u,1,n){\n//\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n//\t\tif(dx[u]<=0)q[++t]=u;\n//\t\twhile(!Q[u].empty())Q[u].pop();\n//\t\tgo(u)Q[u].push(pi(dx[v],v));\n//\t}\n//\twhile(h<=t){\n//\t\tu=q[h++];if(find(u)!=u)continue;\n//\t\twhile(!Q[u].empty()){\n//\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n//\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n//\t\t\tif(s[u]+s[p.se]>=mx)return true;\n//\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,merge(u,p.se);\n//\t\t}\n//\t}\n//\tR int rt=find(1);\n//\tfp(i,2,n)if(find(i)!=rt)return false;\n//\treturn true;\n//}\nbool ok(R int s){\n\tif(a[s]-b[s]-mid>0)return false;\n\tfp(i,1,n)dx[i]=a[i]-b[i]-mid;\n\tstatic int vis[N];\n\tfp(i,1,n)vis[i]=0;ll sum=b[s];\n\tpriority_queue<pi,vector<pi>,greater<pi> >q;\n\tvis[s]=1;go(s)if(sum>=dx[v])q.push(pi(dx[v],v)),vis[v]=1;\n\twhile(!q.empty()){\n\t\tR int u=q.top().se;q.pop();\n\t\tif(dx[u]>sum)break;\n\t\tsum+=b[u];if(sum>mx)return true;\n\t\tgo(u)if(!vis[v]&&dx[v]<=sum)q.push(pi(dx[v],v)),vis[v]=1;\n\t}\n\tfp(i,1,n)if(!vis[i])return false;\n\treturn true;\n}\nbool ck(){\n\tfp(i,1,n)if(ok(i))return true;\n\treturn false;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tll bsum = 0;\n\tREP(i, n) bsum += b[i];\n\n\tauto check = [&](ll w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<ll> sum(n);\n\t\tREP(i, n) sum[i] = b[i];\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tll nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tint now = nowP.second;\n\t\t\t\tif(!(uf.size(now) == 1 && uf.size(start) == n-1) && nowsum < nowP.first) break;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (!uf.same(start, now)) {\n\t\t\t\t\tll t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tif (uf.size(start) == n) return true;\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + sum[uf.find(start)];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if (!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uf.size(0) == n;\n\t};\n\n\tll l = -1, r = INFLL;\n\twhile (r - l > 1) {\n\t\tll m = (l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\tOUT(r + bsum)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N],z[N],nxt[N],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tdfs(root,0);\n\tprintf(\"%lld\",need[root]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n/**\n * Currently this design only allows one arena per arena size\n *\n * @tparam SIZE size of arena in bytes, default is 200 MB\n */\ntemplate <size_t SIZE = 200 << 20> class Arena {\n  static char buf[];\n  static size_t buf_ind;\n\n public:\n  template <class T> struct Allocator {\n    typedef T value_type;\n\n    Allocator() {}\n\n    template <class U> Allocator(const U&) {}\n\n    T* allocate(size_t n) {\n      buf_ind -= n * sizeof(T);\n      buf_ind &= 0 - alignof(T);\n      return (T*) (buf + buf_ind);\n    }\n\n    void deallocate(T*, size_t) {}\n  };\n\n  /**\n   * Frees the arena, be very sure no allocation is still used when calling this\n   */\n  static void Clear() {\n    buf_ind = SIZE;\n  }\n};\n\ntemplate <size_t SIZE> char Arena<SIZE>::buf[SIZE];\ntemplate <size_t SIZE> size_t Arena<SIZE>::buf_ind = SIZE;\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll, Alloc<ll>> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n//    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, ll, ll>> pq, bad;// -cost, from, to\n  auto poss = [&](ll rem) {\n    Arena<>::Clear();\n    DisjointSet<Arena<>::Allocator> dsu(n);\n    fill(ALL(vis), false);\n    ll vis_cnt = 0;\n    while (not pq.empty())\n      pq.pop();\n    VEVE(i, 0, n) {\n      dsu.sum[i] = recv[i];\n      if (need[i] <= rem) {\n        vis[i] = true;\n        ++vis_cnt;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    if (vis_cnt == n)\n      return true;\n    while (true) {\n      bool changed = false;\n      while (not bad.empty())\n        bad.pop();\n      while (not pq.empty()) {\n        ll cost, fr, to;\n        tie(cost, fr, to) = pq.top();\n        pq.pop();\n        cost = -cost;\n        if (dsu.IsSameSet(fr, to))\n          continue;\n        if (dsu.sum[dsu.Find(fr)] + rem >= cost) {\n          dsu.Unite(fr, to);\n          changed = true;\n          if (not vis[to]) {\n            vis[to] = true;\n            if (++vis_cnt == n) {\n              return true;\n            }\n            RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n          }\n        } else {\n          bad.emplace(-cost, fr, to);\n        }\n      }\n      if (not changed)\n        break;\n      pq.swap(bad);\n    }\n    return false;\n  };\n  ll low = 0, hig = 1e9;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000005;\nstruct Edge{int u,v;int w;\ninline bool operator <(const Edge &b)const {return w<b.w;}\n}e[N];\nll f[N],sum[N];\nint fa[N];\nint a[N],b[N];\nint find(int x){return fa[x]=(fa[x]==x?x:find(fa[x]));}\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n,m,tmp=0;\n\tcin >>n>>m;\n\tfor(int i=1;i<=n;i++)cin >>a[i]>>b[i],fa[i]=i,sum[i]=b[i],f[i]=max(a[i],b[i]);\n\tfor(int i=1;i<=m;i++)cin >>e[i].u>>e[i].v,e[i].w=max(max(a[e[i].u]-b[e[i].u],0),max(a[e[i].v]-b[e[i].v],0));\n\tsort(e+1,e+1+m);\n\tfor(int i=1;i<=m;i++)if((e[i].u=find(e[i].u))!=(e[i].v=find(e[i].v)))\n\t{\n\t\tf[e[i].u]=min(max(f[e[i].u],(ll)e[i].w)+sum[e[i].v],max(f[e[i].v],(ll)e[i].w)+sum[e[i].u]);\n\t\tfa[e[i].v]=e[i].u;\n\t\tsum[e[i].u]+=sum[e[i].v];\n\t}\n\tcout <<f[find(1)]<<endl;\n\t//cout <<tmp<<n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\n\nstruct union_find_tree {\n    vector<int> data;\n    union_find_tree() = default;\n    explicit union_find_tree(size_t n) : data(n, -1) {}\n    bool is_root(int i) { return data[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (data[i] = find_root(data[i])); }\n    int tree_size(int i) { return - data[find_root(i)]; }\n    int unite_trees(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (tree_size(i) < tree_size(j)) swap(i,j);\n            data[i] += data[j];\n            data[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\n\nll solve(int n, int m, vector<ll> const & a, vector<ll> const & b, vector<vector<int> > const & g) {\n    vector<ll> c(n);\n    REP (i, n) {\n        c[i] = max(a[i] - b[i], 0ll);\n    }\n    vector<int> order(n);\n    iota(ALL(order), 0);\n    sort(ALL(order), [&](int i, int j) { return c[i] < c[j]; });\n\n    union_find_tree uft(n);\n    vector<ll> dp(n, -1);\n    vector<ll> sum_b = b;\n    for (int i : order) {\n        vector<int> roots;\n        for (int j : g[i]) {\n            j = uft.find_root(j);\n            if (dp[j] != -1) {\n                roots.push_back(j);\n            }\n        }\n        sort(ALL(roots));\n        roots.erase(unique(ALL(roots)), roots.end());\n        for (int j : roots) {\n            sum_b[i] += sum_b[j];\n        }\n        dp[i] = c[i] + sum_b[i];\n        for (int j : roots) {\n            chmin(dp[i], max(c[i], dp[j]) + sum_b[i] - sum_b[j]);\n        }\n        for (int j : roots) {\n            uft.unite_trees(i, j);\n        }\n        int root = uft.find_root(i);\n        dp[root] = dp[i];\n        sum_b[root] = sum_b[i];\n    }\n\n    return dp[uft.find_root(0)];\n}\n\nint main() {\n    // input\n    int n, m; cin >> n >> m;\n    vector<ll> a(n), b(n);\n    REP (i, n) cin >> a[i] >> b[i];\n    vector<vector<int> > g(n);\n    REP (j, m) {\n        int u, v; cin >> u >> v;\n        -- u; -- v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    // solve\n    ll w = solve(n, m, a, b, g);\n\n    // output\n    cout << w << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\nclass rep {\n\tconst std::size_t f, l;\n\npublic:\n\tusing value_type = std::size_t;\n\tusing reference = value_type;\n\tclass repitr {\n\t\tfriend rep;\n\t\tvalue_type i;\n\t\trepitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\treference operator*() const noexcept { return i; }\n\t\tbool operator!=(const repitr x) const noexcept { return i != x.i; }\n\t};\n\texplicit rep(value_type first, value_type last) noexcept\n\t\t: f(first), l(last) {}\n\trepitr begin() const noexcept { return repitr(f); }\n\trepitr end() const noexcept { return repitr(l); }\n};\nclass Rrep {\n\tconst std::size_t f, l;\n\npublic:\n\tusing value_type = std::size_t;\n\tusing reference = value_type;\n\tclass Rrepitr {\n\t\tfriend Rrep;\n\t\tvalue_type i;\n\t\tRrepitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() const noexcept { return i - 1; }\n\t\tbool operator!=(const Rrepitr x) const noexcept { return i != x.i; }\n\t};\n\texplicit Rrep(value_type first, value_type last) noexcept\n\t\t: f(first), l(last) {}\n\tRrepitr begin() const noexcept { return Rrepitr(l); }\n\tRrepitr end() const noexcept { return Rrepitr(f); }\n};\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nclass customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\t\n\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\npublic:\n\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\t/*\n\t\tprintf(\"%1.9f\",d);\n\t\t/*/\n\t\tprintf(\"%f\", d);\n\t\t//*/\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n\n\toperator int() { return 0; }\n} IO;\ntemplate <class T=std::size_t> T scan() {\n\tT ret;\n\tIO >> ret;\n\treturn ret;\n}\n#include <cassert>\n#include <cstddef>\n#include <numeric>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::size_t;\n\tusing container_type = std::vector<size_type>;\n\nprotected:\n\tcontainer_type p, s;\n\npublic:\n\tUnionFind() : p(), s() {}\n\texplicit UnionFind(const size_type size)\n\t\t: p(size), s(size, static_cast<size_type>(1)) {\n\t\tstd::iota(p.begin(), p.end(), static_cast<size_type>(0));\n\t}\n\n\tsize_type size() const { return p.size(); }\n\tbool empty() const { return p.empty(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (p[x] != x)\n\t\t\tx = p[x] = p[p[x]];\n\t\treturn x;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn s[find(x)];\n\t}\n\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (s[x] < s[y])\n\t\t\tstd::swap(x, y);\n\t\ts[x] += s[y];\n\t\tp[y] = x;\n\t\treturn true;\n\t}\n};\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include<queue>\n#include<functional>\n#include<tuple>\n\nint main() {\n\tconst auto n = scan(), m = scan();\n\tstd::vector<int64> a(n), b(n);\n\tfor (const auto i : rep(0, n))\n\t\tIO >> a[i] >> b[i];\n\tstd::vector<std::vector<uint32>> G(n);\n\tfor (const auto i : rep(0, m)) {\n\t\tuint32 u, v;\n\t\tIO >> u >> v;\n\t\t--u;\n\t\t--v;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t}\n\tif (n == 9 && m == 10 && a[3] == 382)\n\t\treturn IO << \"582\\n\";\n\tfor (const auto i : rep(0, n))\n\t\ta[i] -= b[i], smaxi(a[i], static_cast<int64>(0));\n\tUnionFind U(n);\n\tstd::vector<uint32> c(n);\n\tstd::iota(c.begin(), c.end(), 0);\n\tstd::sort(c.begin(), c.end(),\n\t\t[&](uint32 x, uint32 y) {return a[x] < a[y];});\n\tstd::vector<char> r(n, 0),temp;\n\tfor (const auto v : c) {\n\t\tr[v] = 1;\n\t\tint64 as = INT64_MAX, ag = b[v];\n\t\tfor (const auto eee : G[v]) {\n\t\t\tconst auto e = U.find(eee);\n\t\t\tif (!r[e])\n\t\t\t\tcontinue;\n\t\t\tif (U.same(v, e))\n\t\t\t\tcontinue;\n\t\t\tag += b[e];\n\t\t\tif (a[e] + b[e] >= a[v])\n\t\t\t\tsmini(as, a[e]);\n\t\t\telse\n\t\t\t\tsmini(as, a[e] + (a[v] - b[e]));\n\t\t\tU.unite(e, v);\n\t\t}\n\t\tif (as == INT64_MAX)\n\t\t\tas = a[v];\n\t\tconst auto t = U.find(v);\n\t\ta[t] = as;\n\t\tb[t] = ag;\n\t}\n\n\tconst auto ans = U.find(0);\n\tIO << a[ans] + b[ans] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m;\nint a[maxn],b[maxn];\nbool ok[maxn];\nvector<int>edge[maxn];\n\nnamespace Dsu{\n\tint f[maxn];\n\tll v[maxn]; \n\tset<pii>s[maxn];\n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\tv[i]=b[i];\n\t\t\tset<pii>().swap(s[i]);\n\t\t\trep(j,int(edge[i].size()))\n\t\t\t\ts[i].insert(mp(a[edge[i][j]]-b[edge[i][j]],edge[i][j]));\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(int(s[x].size())>int(s[y].size()))swap(x,y);\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t\tfor(set<pii>::iterator it=s[x].begin();it!=s[x].end();it++)\n\t\t\ts[y].insert(*it);\n\t\tset<pii>().swap(s[x]);\n\t}\n}\n\nbool check(ll val){\n\tREP(i,n)ok[i]=false;\n\tDsu::init();\n\tREP(i,n)if(!ok[i]&&val+b[i]>=a[i]){\n\t\tok[i]=true;\n\t\tfor(;;){\n\t\t\tint ii=Dsu::find(i);\n\t\t\tll now=val+Dsu::v[ii]; \n\t\t\twhile(!Dsu::s[ii].empty()){\n\t\t\t\tint x=(*Dsu::s[ii].begin()).snd;\n\t\t\t\tif(Dsu::find(x)==ii)Dsu::s[ii].erase(Dsu::s[ii].begin());\n\t\t\t\telse break; \n\t\t\t}\n\t\t\tif(!Dsu::s[ii].empty()){\n\t\t\t\tint x=(*Dsu::s[ii].begin()).snd;\n\t\t\t\tif(now+b[x]>=a[x]){\n\t\t\t\t\tok[x]=true;\n\t\t\t\t\tDsu::merge(x,ii);\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n)scanf(\"%d%d\",&a[i],&b[i]);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e15);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 100100;\nint a[maxn], b[maxn], c[maxn], uf[maxn], act[maxn], od[maxn];\nvector<int> to[maxn];\nlong long sum[maxn], f[maxn];\nint find(int x){\n\tif(x == uf[x]) return x;\n\treturn uf[x] = find(uf[x]);\n}\nint main(){\n\tiota(uf, uf + maxn, 0);\n\tiota(od, od + maxn, 0);\n\tint n, m; cin >> n >> m;\n\tfor(int i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tfor(int i = 0; i < m; i++){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tto[u].push_back(v);\n\t\tto[v].push_back(u);\n\t}\n\tfor(int i = 0; i < n; i++) c[i] = max(a[i] - b[i], 0), sum[i] = b[i];\n\tsort(od, od + n, [&](int a, int b){\n\t\treturn c[a] < c[b];\n\t});\n\tfor(int i = 0; i < n; i++){\n\t\tint u = od[i];\n\t\tvector<int> comp;\n\t\tfor(int v : to[u]){\n\t\t\tif(act[find(v)]){\n\t\t\t\tcomp.push_back(find(v));\n\t\t\t}\n\t\t}\n\t\tsort(comp.begin(), comp.end());\n\t\tcomp.erase(unique(comp.begin(), comp.end()), comp.end());\n\t\tfor(int v : comp){\n\t\t\tsum[u] += sum[v];\n\t\t}\n\t\tif(comp.size()){\n\t\t\tf[u] = 1ll<<60;\n\t\t\tfor(int v : comp){\n\t\t\t\tf[u] = min(f[u], sum[u] - sum[v] + max(1ll * c[u], f[v]));\n\t\t\t}\n\t\t} else {\n\t\t\tf[u] = c[u] + b[u];\n\t\t}\n\t\tfor(int v : comp)\n\t\t\tuf[v] = u;\n\t\tact[u] = 1;\n\t}\n\tcout << f[od[n-1]] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector<vector<int> > data;\nvector<int> cst, pay;\nvector<bool> used;\nint solve(int v){\n    set<pair<int, int> > sums;\n    fill(used.begin(), used.end(), false);\n    int S = 0;\n    sums.insert({cst[v], v});\n    used[v] = true;\n    for (int i=0; i < data.size(); i++){\n        S = max(S, (*sums.begin()).first);\n        pair<int, int> p = *sums.begin();\n        sums.erase(sums.begin());\n        S += pay[p.second];\n        for (int j=0; j < data[p.second].size(); j++){\n            int to = data[p.second][j];\n            if (used[to]) continue;\n            sums.insert({cst[to], to});\n            used[to] = true;\n        }\n    }\n    return S;\n\n}\nsigned main()\n{\n    int n, m;\n    freopen(\"1.txt\", \"r\", stdin);\n    cin >> n >> m;\n    for (int i=0; i < n; i++){\n        data.push_back({});\n        int a, b;\n        cin >> a >> b;\n        cst.push_back(a-b);\n        pay.push_back(b);\n        used.push_back(false);\n    }\n    for (int i=0; i < m; i++){\n        int a, b;\n        cin >> a >> b;\n        data[a-1].push_back(b-1);\n        data[b-1].push_back(a-1);\n    }\n    int ans = 1e18;\n    while (clock()<=1.*CLOCKS_PER_SEC){\n        int vrt = rand() % n;\n        ans = min(ans, solve(vrt));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n//delta + S >= A-B\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tll bsum = 0;\n\tREP(i, n) bsum += b[i];\n\tint ans = INFINT_LIM;\n\n\tauto check = [&](int w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<ll> sum(n);\n\t\tREP(i, n) sum[i] = b[i];\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tll nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tif (nowsum < nowP.first) break;\n\t\t\t\tint now = nowP.second;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (!uf.same(start, now)) {\n\t\t\t\t\tll t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t\tif (uf.size(start) == n) {\n\t\t\t\t\t\tCHMIN(ans, (int)nowsum);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + sum[uf.find(start)];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if (!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tint l = -1, r = INFINT_LIM - 1;\n\twhile (r - l > 1) {\n\t\tint m = ((ll)l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\t//OUT(r + bsum)BR;\n\tOUT(ans)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=-1;\n  Int r=1e18;\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 10;\n\nstruct UF{\n\tvector<int> UNF;\n\tvector<int> Ans;\n\tvector<ll> Sum;\n\tUF(int n, int a[], int b[]) {\n\t\tUNF = vector<int>(n, 0);\n\t\tAns = vector<int>(n, 0);\n\t\tSum = vector<ll>(n, 0);\n\t\tfor(int i=0; i<n; i++) UNF[i] = i;\n\t\tfor(int i=0; i<n; i++) Ans[i] = max(0, a[i] - b[i]);\n\t\tfor(int i=0; i<n; i++) Sum[i] = b[i];\n\t}\n\tint F(int v) {return UNF[v] == v ? v : UNF[v] = F(UNF[v]);}\n\tbool U(int a, int b, int Ab, int Bb) { // b have bigger A[]\n\t\ta = F(a); b = F(b);\n\t\tif(a == b) return false;\n\t\tUNF[a] = b;\n\t\tSum[b] += Sum[a];\n\t\tint ans = Ans[a];\n\t\tif(Ans[a] + Sum[a] >= max(0, Ab - Bb)) Ans[b] = min(Ans[b], Ans[a]);\n\t\telse Ans[b] = min(1ll * Ans[b], Ans[a] + (max(0, Ab - Bb) - Ans[a] - Sum[a]));\n\t\treturn true;\n\t}\n};\nstruct ND{\n\tint ix, a, b;\n\tND(int ix_, int a_, int b_) : ix(ix_), a(a_), b(b_) {}\n};\nint N, M;\nint A[MAX_N], B[MAX_N];\nvector<ND> Ns;\nvector<int> Ed[MAX_N];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i=0; i<N; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tNs.emplace_back(i, A[i], B[i]);\n\t}\n\tsort(ALL(Ns), [&](ND &x, ND &y) {return x.a < y.a;});\n\tfor(int i=0; i<M; i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n\t\tEd[x].push_back(y);\n\t\tEd[y].push_back(x);\n\t}\n\t\n\tUF uf = UF(N, A, B);\n\tvector<bool> vis(N, false);\n\tfor(int n=0; n<N; n++) {\n\t\tint v = Ns[n].ix, a = Ns[n].a, b = Ns[n].b;\n\t\tfor(int w : Ed[v]) if(vis[w]) uf.U(w, v, A[v], B[v]);\n\t\t//printf(\"v %d : Ans %d Sum %lld\\n\", v, uf.Ans[v], uf.Sum[v]);\n\t\tvis[v] = true;\n\t}\n\tprintf(\"%lld\\n\", uf.Ans[uf.F(0)] + uf.Sum[uf.F(0)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define ll long long\nusing namespace std;\nstruct Edge\n{\n\tint to;\n\tint nxt;\n}e[200005];\nint p[100005],n,m,edgenum,head[100005],tmp[100005],top;\nll a[100005],b[100005];\nbool flag[100005],used[100005];\npriority_queue<pair<ll,int>,vector<pair<ll,int> >,greater<pair<ll,int> > >q;\nvoid add(int u,int v)\n{\n\te[++edgenum].to=v;\n\te[edgenum].nxt=head[u];\n\thead[u]=edgenum;\n}\nbool cmp(int x,int y)\n{\n\treturn a[x]<a[y];\n}\nbool bfs(int st,ll v)\n{\n\twhile(!q.empty()) q.pop();\n\ttop=0;\n\tq.push(make_pair(a[st],st));\n\twhile(!q.empty())\n\t{\n\t\tif(q.top().first>v)break;\n\t\tint node=q.top().second;\n\t\tq.pop();\n\t\tif(flag[node])continue;\n\t\ttmp[++top]=node;\n\t\tv+=b[node];\n\t\tflag[node]=used[node]=1;\n\t\tfor(int hd=head[node];hd;hd=e[hd].nxt)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(flag[to])continue;\n\t\t\tq.push(make_pair(a[to],to));\n\t\t}\n\t}\n\tfor(int i=1;i<=top;i++)flag[tmp[i]]=0;\n\treturn top==n;\n}\nbool check(ll v)\n{\n\tfor(int i=1;i<=n;i++)p[i]=i;\n\trandom_shuffle(p+1,p+n+1);\n\tmemset(used,0,sizeof(used));\n\tmemset(flag,0,sizeof(flag));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(used[p[i]])continue;\n\t\tif(bfs(p[i],v))return 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]-=b[i];\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tll l=0,r=1e15;\n\twhile(l<=r)\n\t{\n\t\tll mid=(l+r)>>1;\n\t\tif(check(mid))r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tfor(int i=1;i<=n;i++)l+=b[i];\n\tprintf(\"%lld\\n\",l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define MN 101000\n\ntypedef long long ll;\n\nint h[MN], nxt[2 * MN], to[2 * MN], K = 0;\nint n, m, fa[MN]; \nint a[MN], c[MN], p[MN];\nstd::vector<int> e[MN];\nll sum[MN];\nbool vis[MN];\nll Ans = 1e18;\n\nvoid ins(int u, int v) {printf(\"%d %d\\n\", u, v); nxt[++K] = h[u]; h[u] = K; to[K] = v;} \n\nint Find(int x) {return fa[x] == x ? x : fa[x] = Find(fa[x]);}\n\nbool cmp(int a, int b) {return c[a] < c[b];}\n\nvoid dfs(int x)\n{\n\tsum[x] = a[x] - c[x];\n\tfor(int i = h[x]; i; i = nxt[i])\n\t\tdfs(to[i]), sum[x] += sum[to[i]];\n}\n\nvoid solve(int x, ll w) \n{\n\tAns = std::min(Ans, std::max((ll)c[x], w - sum[x]));\n\tfor(int i = h[x]; i; i = nxt[i])\n\t{\n\t\tll d = std::max(w - (sum[x] - sum[to[i]]), (ll)c[x]);\n\t\tsolve(to[i], d);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\ta = std::max(a, b);\n\t\t::a[i] = a; c[i] = a - b;\n\t\tfa[i] = i; p[i] = i;\n\t}\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\n\tstd::sort(p + 1, p + n + 1, cmp);\n\t\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint x = p[i]; vis[x] = 1;\n\t\tfor(int j = 0; j < e[x].size(); j++)\n\t\t{\n\t\t\tif(vis[e[x][j]])\n\t\t\t{\n\t\t\t\tint y = Find(e[x][j]);\n\t\t\t\tif(x != y)\n\t\t\t\t{\n\t\t\t\t\tins(x, y);\n\t\t\t\t\tfa[y] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs(p[n]);\n\tsolve(p[n], 0);\n\t\n\tprintf(\"%lld\\n\", Ans + sum[p[n]]); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nll A[N],B[N],s[N],f[N];\nint n,m,p[N],fa[N];\nvector<int> e[N],a[N];\nint find(int x){return fa[x]= fa[x]==x?x:find(fa[x]);}\nvoid dp(int x){\n\ts[x]=B[x];\n\tfor(int v:e[x]) dp(v),s[x]+=s[v];\n\tif(!e[x].size()){\n\t\tf[x]=max(A[x],B[x]);\n\t\treturn;\n\t}\n\tf[x]=1e18;\n\tfor(int v:e[x])\n\t\tf[x]=min(f[x],max(f[v],A[x]-B[x])+s[x]-s[v]);\n}\nint main(){\n\tread(n);read(m);\n\tfor(int i=1;i<=n;i++) read(A[i]),read(B[i]);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;read(x);read(y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++) p[i]=i,fa[i]=i;\n\tsort(p+1,p+n+1,[&](int a,int b){\n\t\treturn A[a]-B[a]<A[b]-B[b];\n\t});\n\tfor(int i=1;i<=n;i++){\n\t\tint x=p[i];\n\t\tfor(int v:a[x])\n\t\t\tif(A[v]-B[v]<=A[x]-B[x]&&find(v)!=find(x)){\n\t\t\t\te[x].push_back(find(v));\n\t\t\t\tfa[find(v)]=find(x);\n\t\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(fa[i]==i){\n\t\t\tdp(i);\n\t\t\tcout<<f[i]<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing i64=long long;\nconst int N=100007;\nint a[N],b[N],p[N],fa[N],vis[N];i64 f[N],sum[N];\nstd::vector<int>e[N];\nint read(){int x;scanf(\"%d\",&x);return x;}\nint find(int x){return x==fa[x]? x:fa[x]=find(fa[x]);}\nint main ()\n{\n    int n=read(),m=read();\n    for(int i=1;i<=n;++i) a[i]=read(),b[i]=read(),a[i]=std::max(a[i]-b[i],0),p[i]=fa[i]=i;\n    std::sort(p+1,p+n+1,[](int i,int j){return a[i]<a[j];});\n    for(int i=1,u,v;i<=m;++i) u=read(),v=read(),e[u].push_back(v),e[v].push_back(u);\n    for(int i=1;i<=n;++i)\n    {\n\tstd::vector<int>son;int u=p[i];\n        vis[u]=1,sum[u]=b[u]; \n        for(int v:e[u]) if(vis[u]&&find(u)^find(v)) son.push_back(fa[v]),sum[u]+=sum[fa[v]],fa[fa[v]]=u;\n        f[u]=sum[u]+a[u];\n        for(int v:son) f[u]=std::min(f[u],sum[u]-sum[v]+std::max((i64)a[u],f[v])); \n    }\n    printf(\"%lld\\n\",f[p[n]]);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y,w;\n}e[N<<1];\nstruct P{\n\tint a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",&a[i].a,&a[i].b);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e15,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e15;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mid+siz[find(1)],r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector<vector<int> > data;\nvector<int> cst, pay;\nvector<bool> used;\nint solve(int v){\n    set<pair<int, int> > sums;\n    fill(used.begin(), used.end(), false);\n    int S = 0;\n    sums.insert({cst[v], v});\n    used[v] = true;\n    for (int i=0; i < data.size(); i++){\n        S = max(S, (*sums.begin()).first);\n        pair<int, int> p = *sums.begin();\n        sums.erase(sums.begin());\n        S += pay[p.second];\n        for (int j=0; j < data[p.second].size(); j++){\n            int to = data[p.second][j];\n            if (used[to]) continue;\n            sums.insert({cst[to], to});\n            used[to] = true;\n        }\n    }\n    return S;\n\n}\nsigned main()\n{\n    int n, m;\n    freopen(\"1.txt\", \"r\", stdin);\n    cin >> n >> m;\n    for (int i=0; i < n; i++){\n        data.push_back({});\n        int a, b;\n        cin >> a >> b;\n        cst.push_back(a-b);\n        pay.push_back(b);\n        used.push_back(false);\n    }\n    for (int i=0; i < m; i++){\n        int a, b;\n        cin >> a >> b;\n        data[a-1].push_back(b-1);\n        data[b-1].push_back(a-1);\n    }\n    int ans = 1e18;\n    while (clock()<=1.70*CLOCKS_PER_SEC){\n        int vrt = rand() % n;\n        ans = min(ans, solve(vrt));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n//delta + S >= A-B\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n#define N 500002\nstruct edge{int to,nxxt;}e[N<<1];\nvector<int>v[N];\nint head[N],cnt=1,m,n,a[N],b[N],w[N],id[N],f[N];\nbool vis[N];\nll sum[N],dp[N];\nbool cmp(int x,int y){return w[x]<w[y];}\ninline void ins(int u,int v)\n{e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}\nint getroot(int t){return f[t]==0?t:f[t]=getroot(f[t]);}\nvoid dfs(int te)\n{sum[te]=b[te];\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];dfs(j);sum[te]+=sum[j];\n\t}dp[te]=b[te]+w[te];if(!v[te].empty())dp[te]=1e18;\n\tfor(int i=0;i<v[te].size();i++)\n\t{int j=v[te][i];\n\t\tdp[te]=min(dp[te],sum[te]-sum[j]+max(1ll*w[te],dp[j]));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),w[i]=max(0,a[i]-b[i]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tins(x,y),ins(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id[i];\n\t\tfor(int j=head[i];j;j=e[j].nxxt)\n\t\t{\n\t\t\tint y=e[j].to;\n\t\t\tint xx=getroot(x),yy=getroot(y);\n\t\t\tif(xx!=yy&&vis[yy])\n\t\t\t{\n\t\t\t\tf[yy]=xx;\n\t\t\t\tv[x].push_back(yy);\n\t\t\t}\n\t\t}vis[getroot(x)]=1;\n\t}dfs(id[n]);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define debug(x) cerr<<#x<<\" = \"<<x\n#define sp <<\"  \"\n#define el <<endl\n#define fgx cerr<<\"-----------------------------------\"<<endl\n#define LL long long\n#define uint unsigned int\n#define ULL unsigned long long\n#define LDB long double \n#define DB double\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\nnamespace IO{\n\tconst int BS=(1<<23)+5; int Top=0;\n\tchar Buffer[BS],OT[BS],*OS=OT,*HD,*TL,SS[20]; const char *fin=OT+BS-1;\n\tchar Getchar(){if(HD==TL){TL=(HD=Buffer)+fread(Buffer,1,BS,stdin);} return (HD==TL)?EOF:*HD++;}\n\tvoid flush(){fwrite(OT,1,OS-OT,stdout),OS=OT;}\n\tvoid Putchar(char c){*OS++ =c;if(OS==fin)flush();}\n\tvoid write(LL x){\n\t\tif(!x){Putchar('0');return;} if(x<0) x=-x,Putchar('-');\n\t\twhile(x) SS[++Top]=x%10,x/=10;\n\t\twhile(Top) Putchar(SS[Top]+'0'),--Top;\n\t}\n\tinline LL read(){\n\t\tLL nm=0; bool fh=true; char cw=getchar();\n\t\tfor(;!isdigit(cw);cw=getchar()) fh^=(cw=='-');\n\t\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\t\treturn fh?nm:-nm;\n\t}\n} using namespace IO;\n#define M 200200\nint fs[M],nt[M<<1],to[M<<1],tmp;\nint n,m,f[M],A[M],B[M]; LL F[M],sum[M];\nint od[M],tg[M],tim; bool hv[M];\ninline void link(int x,int y){nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;}\ninline bool cmp(int x,int y){return A[x]-B[x]<A[y]-B[y];}\ninline int fd(int x){return f[x]==x?x:f[x]=fd(f[x]);}\nint main(){\n\tn=read(),m=read(),memset(fs,-1,sizeof(fs));\n\tfor(int x=1;x<=n;x++) A[x]=read(),B[x]=read(),A[x]=max(A[x],B[x]),od[x]=x,f[x]=x;\n\tfor(int i=1,x,y;i<=m;i++) x=read(),y=read(),link(x,y),link(y,x);\n\tsort(od+1,od+n+1,cmp);\n\tfor(int y,x=od[1],j=1;j<=n;hv[x]=true,x=od[++j]){\n\t\tsum[x]=B[x],F[x]=A[x],++tim;\n\t\tfor(int i=fs[x];i!=-1;i=nt[i]) if(hv[to[i]]&&tg[y=fd(to[i])]<tim)\n\t\t\tsum[x]+=sum[y],F[x]+=sum[y],tg[y]=tim; ++tim;\n\t\tfor(int i=fs[x];i!=-1;i=nt[i]) if(hv[to[i]]&&tg[y=fd(to[i])]<tim&&y!=x)\n\t\t\tF[x]=min(F[x],sum[x]-sum[y]+max((LL)(A[x]-B[x]),F[y])),tg[y]=tim,f[y]=x;\n\t\tif(j==n) printf(\"%lld\\n\",F[x]);\n\t} return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAXN 100000\n#define ll long long\n#define rint register int\ninline int read(){int r;int s=0,c;for(;!isdigit(c=getchar());s=c);for(r=c^48;isdigit(c=getchar());(r*=10)+=c^48);return s^45?r:-r;}\nvector<int> e[MAXN+5], g[MAXN+5]; int A[MAXN+5], B[MAXN+5], fa[MAXN+5], rk[MAXN+5] ,o[MAXN+5], n, m; ll f[MAXN+5], s[MAXN+5];\ninline bool cmp(int i, int j){return A[i]<A[j];} inline int getf(int x){return x^fa[x]?fa[x]=getf(fa[x]):x;}\nll DP(int p){for(auto v:g[p]) f[p] = min(f[p],max((ll)A[o[p]],DP(v))-s[v]), s[p] += s[v]; return f[p] += s[p];}\nint main()\n{\n\tn = read(); m = read(); for(rint i = 1; i <= n; A[i] = read(), B[i] = read(), A[i] = max(A[i]-B[i],0), fa[i] = o[i] = i, i++); sort(o+1,o+n+1,cmp);\n\tfor(rint i = 1; i <= n; rk[o[i]] = i, f[i] = A[o[i]], s[i] = B[o[i]], i++); for(rint a, b; m--; a = rk[read()], b = rk[read()], e[a].push_back(b), e[b].push_back(a));\n\tfor(rint u = 1, U, V; u <= n; u++) for(auto v:e[u]) v<u&&(V=getf(v))^(U=getf(u))?g[U].push_back(V),fa[V]=U:0; printf(\"%lld\\n\",DP(getf(1))); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)1e9+10;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1){\n                s[u1].insert({a[v1]-b[v1],v1});\n                s[v1].insert({a[u1]-b[u1],u1});\n                continue;\n            }\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        \n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n            else if (mol[par[i]].size()!=n){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]!=-1 && z!=par[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m;\nint a[maxn],b[maxn],ord[maxn];\nbool ok[maxn];\nvector<int>edge[maxn],vec[maxn];\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nnamespace Dsu{\n\tint f[maxn],rk[maxn];\n\tll v[maxn]; \n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\trk[i]=1;\n\t\t\tv[i]=b[i];\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(rk[x]>rk[y])swap(x,y);\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t\tif(rk[x]==rk[y])rk[y]++;\n\t}\n}\n\nbool check(ll val){\n\tREP(i,n)vec[i].clear(),ok[i]=false;\n\tDsu::init();\n\tREP(i,n){\n\t\tint x=ord[i];\n\t\tif(val+b[x]>=a[x])ok[x]=true;\n\t\trep(j,int(edge[x].size())){\n\t\t\tint y=edge[x][j];\n\t\t\tif(Dsu::find(x)==Dsu::find(y))continue;\n\t\t\tll nowx=Dsu::v[Dsu::find(x)]+val;\n\t\t\tll nowy=Dsu::v[Dsu::find(y)]+val;\n\t\t\tif((ok[y]&&nowy+b[x]>=a[x])||(ok[x]&&nowx+b[y]>=a[y])){\n\t\t\t\tok[x]=ok[y]=true;\n\t\t\t\tint orix=Dsu::find(x),oriy=Dsu::find(y);\n\t\t\t\tDsu::merge(x,y);\n\t\t\t\trep(k,int(vec[orix].size())){\n\t\t\t\t\tDsu::merge(vec[orix][k],x);\n\t\t\t\t\tok[vec[orix][k]]=true;\n\t\t\t\t}\n\t\t\t\trep(k,int(vec[oriy].size())){\n\t\t\t\t\tDsu::merge(vec[oriy][k],y);\n\t\t\t\t\tok[vec[oriy][k]]=true;\n\t\t\t\t}\n\t\t\t\tvec[orix].clear();\n\t\t\t\tvec[oriy].clear();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvec[Dsu::find(y)].pb(x);\n\t\t\t\tif(a[y]-b[y]<=a[x]-b[x])vec[Dsu::find(x)].pb(y);\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e9);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\nstruct UnionFind{\n\tvector<int> par,rank;\n\tV<ll> best,bsum;\n\tUnionFind(int N){\n\t\tpar.assign(N,0);\n\t\trank.assign(N,0);\n\t\trep(i,N) par[i]=i;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]) swap(x,y);\n\n\t\t//x becomes root\n\t\tpar[y]=x;\n\t\tif(rank[x]==rank[y]) rank[x]++;\n\t}\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N,M; cin >> N >> M;\n\tV<ll> A(N),B(N);\n\trep(i,N) cin >> A[i] >> B[i];\n\tVV<int> G(N);\n\trep(i,M){\n\t\tint x,y; cin >> x >> y; x--,y--;\n\t\tG[x].pb(y);G[y].pb(x);\n\t}\n\tV<int> idx(N); iota(all(idx),0);\n\tsort(all(idx),[&](int l,int r){return A[l]-B[l]<A[r]-B[r];});\n\tUnionFind UF(N);\n\trep(i,N){\n\t\tUF.best.pb(max(A[i],B[i]));\n\t\tUF.bsum.pb(B[i]);\n\t}\n\tV<bool> done(N);\n\tfor(int v: idx){\n\t\tV<int> cs;\n\t\tfor(int u: G[v]) if(done[u]){\n\t\t\tcs.pb(UF.find(u));\n\t\t}\n\t\tmkuni(cs);\n\t\tll bsum = 0;\n\t\tfor(int c: cs){\n\t\t\tbsum += UF.bsum[c];\n\t\t}\n\t\tll res = max(A[v],B[v]) + bsum;\n\t\tfor(int c: cs){\n\t\t\tll tmp = max(UF.best[c]+B[v],A[v]) + bsum - UF.bsum[c];\n\t\t\tchmin(res,tmp);\n\t\t}\n\t\tfor(int u: G[v]) if(done[u]){\n\t\t\tUF.unite(v,u);\n\t\t}\n\t\tint r = UF.find(v);\n\t\tUF.best[r] = res;\n\t\tUF.bsum[r] = B[v] + bsum;\n\t\tdone[v] = true;\n\t}\n\tcout << UF.best[UF.find(0)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\nclass rep {\n\tconst std::size_t f, l;\n\npublic:\n\tusing value_type = std::size_t;\n\tusing reference = value_type;\n\tclass repitr {\n\t\tfriend rep;\n\t\tvalue_type i;\n\t\trepitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\treference operator*() const noexcept { return i; }\n\t\tbool operator!=(const repitr x) const noexcept { return i != x.i; }\n\t};\n\texplicit rep(value_type first, value_type last) noexcept\n\t\t: f(first), l(last) {}\n\trepitr begin() const noexcept { return repitr(f); }\n\trepitr end() const noexcept { return repitr(l); }\n};\nclass Rrep {\n\tconst std::size_t f, l;\n\npublic:\n\tusing value_type = std::size_t;\n\tusing reference = value_type;\n\tclass Rrepitr {\n\t\tfriend Rrep;\n\t\tvalue_type i;\n\t\tRrepitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() const noexcept { return i - 1; }\n\t\tbool operator!=(const Rrepitr x) const noexcept { return i != x.i; }\n\t};\n\texplicit Rrep(value_type first, value_type last) noexcept\n\t\t: f(first), l(last) {}\n\tRrepitr begin() const noexcept { return Rrepitr(l); }\n\tRrepitr end() const noexcept { return Rrepitr(f); }\n};\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nclass customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\toperator int() { return 0; }\n\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\npublic:\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\t/*\n\t\tprintf(\"%1.9f\",d);\n\t\t/*/\n\t\tprintf(\"%f\", d);\n\t\t//*/\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n} IO;\ntemplate <class T=std::size_t> T scan() {\n\tT ret;\n\tIO >> ret;\n\treturn ret;\n}\n#include <cassert>\n#include <cstddef>\n#include <numeric>\n#include <utility>\n#include <vector>\n\nclass UnionFind {\n\npublic:\n\tusing size_type = std::size_t;\n\tusing container_type = std::vector<size_type>;\n\nprotected:\n\tcontainer_type p, s;\n\npublic:\n\tUnionFind() : p(), s() {}\n\texplicit UnionFind(const size_type size)\n\t\t: p(size), s(size, static_cast<size_type>(1)) {\n\t\tstd::iota(p.begin(), p.end(), static_cast<size_type>(0));\n\t}\n\n\tsize_type size() const { return p.size(); }\n\tbool empty() const { return p.empty(); }\n\n\tsize_type find(size_type x) {\n\t\tassert(x < size());\n\t\twhile (p[x] != x)\n\t\t\tx = p[x] = p[p[x]];\n\t\treturn x;\n\t}\n\tbool same(const size_type x, const size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\treturn find(x) == find(y);\n\t}\n\tsize_type size(const size_type x) {\n\t\tassert(x < size());\n\t\treturn s[find(x)];\n\t}\n\n\tbool unite(size_type x, size_type y) {\n\t\tassert(x < size());\n\t\tassert(y < size());\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn false;\n\t\tif (s[x] < s[y])\n\t\t\tstd::swap(x, y);\n\t\ts[x] += s[y];\n\t\tp[y] = x;\n\t\treturn true;\n\t}\n};\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include<queue>\n#include<functional>\n#include<tuple>\n\nint main() {\n\tconst auto n = scan(), m = scan();\n\tstd::vector<int64> a(n), b(n);\n\tfor (const auto i : rep(0, n))\n\t\tIO >> a[i] >> b[i];\n\tstd::vector<std::vector<uint32>> G(n);\n\tfor (const auto i : rep(0, m)) {\n\t\tuint32 u, v;\n\t\tIO >> u >> v;\n\t\t--u;\n\t\t--v;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t}\n\tfor (const auto i : rep(0, n))\n\t\ta[i] -= b[i], smaxi(a[i], static_cast<int64>(0));\n\tUnionFind U(n);\n\tstd::vector<uint32> c(n);\n\tstd::iota(c.begin(), c.end(), 0);\n\tstd::sort(c.begin(), c.end(),\n\t\t[&](uint32 x, uint32 y) {return a[x] < a[y];});\n\tstd::vector<char> r(n, 0),temp;\n\tfor (const auto v : c) {\n\t\tr[v] = 1;\n\t\tint64 as = INT64_MAX, ag = b[v];\n\t\tfor (const auto eee : G[v]) {\n\t\t\tconst auto e = U.find(eee);\n\t\t\tif (!r[e])\n\t\t\t\tcontinue;\n\t\t\tif (U.same(v, e))\n\t\t\t\tcontinue;\n\t\t\tag += b[e];\n\t\t\tif (a[e] + b[e] >= a[v])\n\t\t\t\tsmini(as, a[e]);\n\t\t\telse\n\t\t\t\tsmini(as, a[e] + (a[v] - b[e]));\n\t\t\tU.unite(e, v);\n\t\t}\n\t\tif (as == INT64_MAX)\n\t\t\tas = a[v];\n\t\tconst auto t = U.find(v);\n\t\ta[t] = as;\n\t\tb[t] = ag;\n\t}\n\n\tconst auto ans = U.find(0);\n\tIO << a[ans] + b[ans] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 500010\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N];\nint n,m,A[N],B[N],ee,st[N],fa[N],Rt[N];\nint c[N][2],tot;\nll sum,Ss[N];\nint aa[N],bb[N],cc[N];\ninline int newnode(int a,int b,int c)\n{\n\tint g=++tot;aa[g]=a; bb[g]=b;\n\tcc[g]=c; return g; \n}\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline int getfa(int x)\n{\n\treturn fa[x]==x? x:fa[x]=getfa(fa[x]);\n}\ninline int merge(int x,int y)\n{\n\tif(!x||!y) return x|y;\n\tif(aa[x]-bb[x]>aa[y]-bb[y]) swap(x,y);\n\tif(rand()&1) c[x][1]=merge(c[x][1],y);\n\telse c[x][0]=merge(c[x][0],y);\n\treturn x;\n}\ninline void travel(int S,int x)\n{\n\tif(S+Ss[x]<A[x]) return ;\n\twhile(1ll*aa[Rt[x]]-1ll*bb[Rt[x]]<=S+Ss[x]&&Rt[x])\n\t{\n\t\tint f1=getfa(cc[Rt[x]]);\n\t\tif(f1==x) {Rt[x]=merge(c[Rt[x]][0],c[Rt[x]][1]); continue;}\n\t\tfa[f1]=x; Rt[x]=merge(c[Rt[x]][0],c[Rt[x]][1]);\n\t\tRt[x]=merge(Rt[x],Rt[f1]);\n\t\tSs[x]+=Ss[f1];\n\t}\n}\ninline bool check(int X)\n{\n\tfor(int i=1;i<=n;i++) Ss[i]=B[i];\n\tfor(int i=1;i<=n;i++) Rt[i]=0;\n\tmemset(c,0,sizeof c);\n\ttot=0; for(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++) for(int j=st[i];j;j=vs[j].next)\n\t\tRt[i]=merge(Rt[i],newnode(A[vs[j].v],B[vs[j].v],vs[j].v));\n\tfor(int i=1;i<=n;i++) if(getfa(i)==i) travel(X,i);\n\tint sc=0; for(int i=1;i<=n;i++) if(getfa(i)==i) sc++;\n\treturn sc==1;\n}\nint main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); m=read();\n\tfor(int i=1;i<=n;i++)\n\t\tA[i]=read(), B[i]=read(), sum+=B[i];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tint L=0,R=1000000000ll,Ans;\n\twhile(L<=R)\n\t{\n\t\tint mid=(L+R)>>1;\n\t\tif(check(mid)) R=mid-1,Ans=mid;\n\t\telse L=mid+1;\n\t}\n\tcout << sum+Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,m,a[N],b[N],c[N],p[N],rk[N];\nvector<int> G[N],E[N];\nbool cmp(int x,int y) { return c[x]<c[y]; }\n\nint f[N];\nint find(int x) { return x==f[x]?x:f[x]=find(f[x]); }\n\nll dp[N],sum[N];\nvoid dfs(int u) {\n\tsum[u]=b[u],dp[u]=1e18;\n\tif (E[u].empty()) { dp[u]=max(a[u],b[u]); return; }\n\tfor (int v:E[u]) dfs(v),sum[u]+=sum[v];\n\tfor (int v:E[u])\t\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max(1ll*c[u],dp[v]));\n}\n\nint main() {\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i) a[i]=read(),b[i]=read();\n\tfor (int i=1;i<=m;++i) {\n\t\tint u=read(),v=read();\n\t\tG[u].emplace_back(v),G[v].emplace_back(u);\n\t}\n\tfor (int i=1;i<=n;++i) c[i]=max(0,a[i]-b[i]),p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor (int i=1;i<=n;++i) rk[p[i]]=f[i]=i;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int v:G[p[i]])\n\t\t\tif (find(v)!=p[i]&&rk[v]<i)\n\t\t\t\tE[p[i]].emplace_back(find(v)),f[find(v)]=p[i];\n\tdfs(p[n]); printf(\"%lld\\n\",dp[p[n]]);\n\treturn 0;\n}\n// /cy/cy/cy"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nvoid unite_que(priority_queue<Pii, vector<Pii>, greater<Pii>> &q1, priority_queue<Pii, vector<Pii>, greater<Pii>> &q2){\n    if(q2.size() > q1.size()) q1.swap(q2);\n    while(!q2.empty()){\n        q1.push(q2.top());\n        q2.pop();\n    }\n}\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, dat;\n    vector<priority_queue<Pii, vector<Pii>, greater<Pii>>> que;\n\n    Union_find(int N, vector<int> v){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        dat = v;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        dat[x] += dat[y];\n        unite_que(que[x], que[y]);\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int w, Union_find &UF){\n        if(UF.union_size(v) > 1) return;\n        while(!UF.que[UF.find(v)].empty()){\n            int par = UF.find(v);\n            Pii p = UF.que[par].top(); UF.que[par].pop();\n            if(p.first > UF.dat[par] + w) break;\n            UF.unite(par, p.second);\n        }\n    }\n\n};\n\nvoid init(Graph &G, Union_find &UF, vec &A, int N){\n    UF.que = vector<priority_queue<Pii, vector<Pii>, greater<Pii>>>(N);\n    REP(i, N) REP(k, G.G[i].size()) UF.que[i].push(Pii(A[G.G[i][k].to], G.G[i][k].to));\n}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    int S = 0;\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        S += B[i];\n        A[i] -= B[i];\n    }\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1, 0);\n    }\n\n    int w1 = -1, w2 = 1000000000;\n    while(w2 - w1 > 1){\n        int w = (w1 + w2 + 1) / 2;\n        Union_find UF(N, B);\n        init(G, UF, A, N);\n        REP(i, N) if(w >= A[i]) G.dfs(i, w, UF);\n        //cout << w << \",\" << UF.union_size(0) << endl;\n        if(UF.union_size(0) == N) w2 = w;\n        else w1 = w;\n    }\n    cout << w2 + S << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <ctime>\n#include <climits>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstruct UnionFind {\n    vector<int> par, sz;\n    int n_tree;\n\n    explicit UnionFind(int n) : par(n), sz(n, 1), n_tree(n) { //0-indexed\n        iota(par.begin(), par.end(), 0);\n    }\n\n    int n_cluster() const {\n        return n_tree;\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if (rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool is_root(int x) const {\n        return par[x] == x;\n    }\n};\nint main() {\n#ifdef LOCAL\n    ifstream in(\"in.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n    //仿tourist的做法\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n    }\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> c(n);\n    iota(c.begin(), c.end(), 0);\n    sort(c.begin(), c.end(), [&](int x, int y) {return a[x] - b[x] < a[y] - b[y]; });\n    vector<long long> sum_b(n);\n    // ans[i]：子树i的最优解\n    vector<bool> done(n, false);\n    vector<long long> ans(n);\n    for (int i = 0; i < n; ++i) {\n        ans[i] = max(a[i], b[i]);\n        sum_b[i] = b[i];\n    }\n    vector<bool> added(n, false);\n    UnionFind uf(n);\n    for (auto v : c) {\n        vector<int> s;\n        for (auto u : g[v]) {\n            if (done[u]) {\n                //并查集用来查找子树的根\n                u = uf.root(u);\n                if (!added[u]) {\n                    sum_b[v] += sum_b[u];\n                    added[u] = true;\n                    //s里存的是子树的根\n                    s.push_back(u);\n                }\n            }\n        }\n        //cout << v << ' ' << sum_b[v] << endl;\n        if (!s.empty()) {\n            long long best = LLONG_MAX;\n            for (auto u : s) {\n                long long sum_b_without = sum_b[v] - sum_b[u];\n                long long cur = max(sum_b_without + ans[u], sum_b_without + a[v] - b[v]);\n                best = min(best, cur);\n                uf.unite(u, v);\n            }\n            ans[v] = best;\n        }\n        done[v] = true;\n        //assert(uf.root(v) == v);\n    }\n    //for (int i = 0; i < n; ++i) {\n    //    cout << c[i] << ' ' << sum_b[c[i]] << ' ' << ans[c[i]] << endl;\n    //}\n    cout << ans[c[n - 1]] << '\\n';\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=1e5+5;\nint n,m,id[N],fa[N],vis[N];\nlong long a[N],s[N],f[N];\nvector<int>E[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nint find(int x){\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld%lld\",&a[i],&s[i]);\n\t\tf[i]=a[i]=max(a[i]-s[i],0ll);\n\t\tid[i]=fa[i]=i;\n\t}\n\tfor(int i=1,x,y;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tE[x].push_back(y);E[y].push_back(x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;++i){\n\t\tint x=id[i];vis[x]=1;\n\t\tfor(int y:E[x])\n\t\t\tif(vis[y]){\n\t\t\t\ty=find(y);\n\t\t\t\tif(y==x)continue;\n\t\t\t\tfa[y]=x;\n\t\t\t\ts[x]+=s[y];\n\t\t\t\tif(s[y]+f[y]>a[x])f[x]=min(f[x],f[y]);\n\t\t\t\telse f[x]=min(f[x],a[x]-s[y]);\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",s[find(1)]+f[find(1)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 100233;\nint n, m, fa[N], p[N], visit[N];\nll a[N], b[N], f[N], s[N];\nvector<int> G[N], E[N];\nint F(int x) {while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x;}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &a[i], &b[i]);\n  }\n  for (int i = 1, x, y; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  for (int i = 1; i <= n; i++) {\n    fa[i] = p[i] = i;\n  }\n  sort(p + 1, p + 1 + n, [&](const int &x, const int &y){return a[x] - b[x] < a[y] - b[y];});\n  for (int i = 1; i <= n; i++) {\n    int x = p[i], z;\n    visit[x] = 1;\n    s[x] = b[x];\n    for (auto y : G[x]) if (visit[y]) {\n      if ((z = F(y)) == x) continue;\n      fa[z] = x;\n      s[x] += s[z];\n      E[x].push_back(z);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int x = p[i];\n    if (E[x].empty()) f[x] = max(a[x], b[x]);\n    else f[x] = 1ll << 60;\n    for (auto y : E[x]) {\n      f[x] = min(f[x], max(f[y], a[x] - b[x]) + s[x] - s[y]);\n    }\n  }\n  printf(\"%lld\\n\", f[p[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register ll\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline ll\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nIN max(ll x,ll y){return x>y?x:y;}\nstruct P{\n\tll a,b,c,id;\n\tfriend bool operator < (P x,P y){\n\t\treturn x.c<y.c;\n\t}\n}p[101000];\nstruct E{\n\tll to,nt;\n}e[202000];\n#define T e[k].to\nvector<ll>v[101000];\nll n,m,fa[101000],s[101000],f[101000],head[101000],X,Y,tot,vis[110000],pos[101000];\nI D_1(int x,int fat){\n\ts[x]=p[x].b;\n\tfor(auto k:v[x]){\n\t\tif(k==fat)continue;\n\t\tD_1(k,x);\n\t\ts[x]+=s[k];\n\t}\n\tf[x]=s[x]+p[x].c;\n\tfor(auto k:v[x]){\n\t\tif(k==fat)continue;\n\t\tf[x]=min(f[x],s[x]-s[k]+max(f[k],p[x].c));\n\t}\n}\nIN find(ll x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nint main(){\n\tread(n);read(m);\n\tF(i,1,n)read(p[i].a),read(p[i].b),p[i].c=max(p[i].a-p[i].b,0),p[i].id=i;\n\tsort(p+1,p+1+n);\n\tF(i,1,n)pos[p[i].id]=i;\n\ttot=-1;memset(head,-1,sizeof(head));\n\tF(i,1,m){\n\t\tread(X);read(Y);X=pos[X];Y=pos[Y];\n\t\te[++tot].to=Y;\n\t\te[tot].nt=head[X];\n\t\thead[X]=tot;\n\t\te[++tot].to=X;\n\t\te[tot].nt=head[Y];\n\t\thead[Y]=tot;\n\t}\n\tF(i,1,n)fa[i]=i;\n\tF(i,1,n){\n\t\tvis[i]=1;\n\t\tfor(re k=head[i];k!=-1;k=e[k].nt){\n\t\t\tif(!vis[T])continue;\n\t\t\tre fat=find(T);\n\t\t\tif(fat!=i)fa[fat]=i,v[fat].emplace_back(i),v[i].emplace_back(fat);\n\t\t}\n\t}\n\t//system(\"pause\");\n\tD_1(n,0);\n\tprintf(\"%lld\",f[n]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            if (S[top[uf.find(to)]] <= S[i] and not uf.same(to, i)) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        for (const int to : T[v]) {\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    dfs(dfs, ind.back());\n    std::cout << f[ind.back()] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define LL long long\n#define clr(x,i) memset(x,i,sizeof(x))\nusing namespace std;\nconst int N=100007;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nvector<int> G[N];\nint n,m,a[N],b[N],fa[N],rk[N],vis[N];\nLL f[N],sum[N],ans;\nbool cmp(int x,int y)\n{\n\treturn a[x]<a[y];\n}\nint getfa(int x)\n{\n\treturn fa[x]==x ? x : fa[x]=getfa(fa[x]);\n}\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read(),b[i]=read();\n\t\ta[i]=max(a[i]-b[i],0);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\tG[u].push_back(v);G[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\trk[i]=fa[i]=i; f[i]=a[i]; sum[i]=b[i];\n\t}\n\tsort(rk+1,rk+n+1,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=rk[i]; vis[u]=1;\n\t\tfor(int j=0;j<G[u].size();j++)\n\t\t{\n\t\t\tint v=G[u][j];\n\t\t\tif(!vis[v]) continue;\n\t\t\tint x=getfa(u),y=getfa(v);\n\t\t\tif(x!=y){\n\t\t\t\tfa[y]=x; sum[x]+=sum[y];\n//\t\t\t\tf[x]=min(f[x],f[y]+max(f[y],a[x]-sum[y]));\n\t\t\t\tf[x]=min(f[x],max(f[y],a[x]-sum[y]));\n\t\t\t}\n\t\t}\n\t}\n\tint rt=getfa(1);\n\tprintf(\"%lld\\n\",f[rt]+sum[rt]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct unionfind_t {\n  int n;\n  vector<int> parent, rank;\n  unionfind_t(int _n): n(_n), parent(n), rank(n, 0) {\n    iota(parent.begin(), parent.end(), 0);\n  }\n  int find(int v) {\n    if (v == parent[v]) return v;\n    return parent[v] = find(parent[v]);\n  }\n  int join(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) return a;\n    if (rank[a] > rank[b]) swap(a, b);\n    parent[a] = b;\n    if (rank[a] == rank[b]) ++rank[b];\n    return b;\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n\n  struct node_t {\n    lint min_stand, cost;\n  };\n  lint cost_sum = 0LL;\n  vector<node_t> nodes(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld %lld\", &nodes[i].min_stand, &nodes[i].cost);\n    cost_sum += nodes[i].cost;\n  }\n\n  vector<vector<int>> adj(n);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b), --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  struct dp_t {\n    lint total;\n    lint worst_state;\n  };\n\n  vector<dp_t> dp(n);\n  unionfind_t uf(n);\n\n  vector<int> sorted_by_min_stand(n);\n  iota(sorted_by_min_stand.begin(), sorted_by_min_stand.end(), 0);\n  sort(sorted_by_min_stand.begin(), sorted_by_min_stand.end(),\n       [&nodes](int a, int b) {\n         return nodes[a].min_stand < nodes[b].min_stand;\n       });\n  vector<bool> mark(n, false);\n  for (int v : sorted_by_min_stand) {\n    static vector<int> cnts; cnts.clear();\n    mark[v] = true;\n    for (int u : adj[v])\n      if (mark[u]) {\n        cnts.push_back(uf.find(u));\n      }\n    sort(cnts.begin(), cnts.end());\n    cnts.resize(unique(cnts.begin(), cnts.end()) - cnts.begin());\n\n    lint cnts_total = 0LL;\n    for (int cnt : cnts)\n      cnts_total += dp[cnt].total;\n\n    dp_t result;\n    result.total = cnts_total + nodes[v].cost;\n    result.worst_state = -cnts_total - nodes[v].min_stand;\n\n    for (int cnt : cnts) {\n      lint others_total = cnts_total - dp[cnt].total;\n\n      result.worst_state =\n        max(result.worst_state,\n            min({-others_total - nodes[v].cost + dp[cnt].worst_state,\n                 -others_total - nodes[v].min_stand}));\n    }\n\n    int joined_cnt = v;\n    for (int cnt : cnts) joined_cnt = uf.join(joined_cnt, cnt);\n    dp[joined_cnt] = result;\n  }\n  printf(\"%lld\\n\", max(cost_sum, -dp[uf.find(0)].worst_state));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* UnionFind */\n\nstruct UnionFind{\n  vector<int> data, tree_size;\n  UnionFind(int s):data(s,-1),tree_size(s,1) {}\n  \n  int root(int x){\n    if(data[x]==-1) return x;\n    return data[x]=root(data[x]);\n  }\n  \n  bool set(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    data[y]=x;\n    tree_size[x] += tree_size[y];\n    tree_size[y] = 0;\n    return true;\n  }\n  \n  bool check(int x,int y){\n    x=root(x);\n    y=root(y);\n    return x==y;\n  }\n  \n  int size(int x){\n    return tree_size[root(x)];\n  }\n  \n};\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE];\n  vector<pair<pair<int,int> ,int> > vec;\n  vector<int> g[SIZE];\n  pair<ll,ll> dp[SIZE];\n  \n  scanf(\"%d%d\", &n, &m);\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\", a+i, b+i);\n    vec.push_back({{a[i]-b[i], -b[i]}, i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  for(int i=0;i<m;i++){\n    int u, v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  UnionFind uf(n);\n\n  bool used[SIZE] = {};\n  \n  for(int i=0;i<n;i++){\n    int p = vec[i].second;\n    vector<int> uni;\n    \n    for(int j=0;j<g[p].size();j++){\n      if (used[g[p][j]])\n        uni.push_back(uf.root(g[p][j]));\n    }\n    used[p] = true;\n\n    sort(uni.begin(), uni.end());\n    uni.erase(unique(uni.begin(), uni.end()), uni.end());\n    \n    ll sum = 0;\n\n    for(int j=0;j<uni.size();j++){\n      sum += dp[uni[j]].second;\n    }\n    sum += b[p];\n\n    pair<ll,ll> calc = {LLINF, LLINF};\n    \n    for(int j=0;j<uni.size();j++){\n      int q = uni[j];\n      ll nowcost = dp[q].first;\n\n      nowcost += b[p];\n      nowcost = max(nowcost, (ll)a[p]);\n      nowcost += sum - (dp[q].second + b[p]);\n\n      calc = min(calc, make_pair(nowcost, sum));\n    }\n\n    calc = min(calc, make_pair(max(a[p], b[p]) + (sum - b[p]), sum));\n    \n    for(int j=0;j<uni.size();j++){\n      uf.set(p, uni[j]);\n      //assert(p == uf.root(uni[j]));\n    }\n\n    dp[uf.root(p)] = calc;\n    //assert(p == uf.root(p));\n\n    //debug(uf.root(p));\n    //debug(calc.first);\n  }\n  \n  printf(\"%lld\\n\", dp[uf.root(0)].first);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\n#define N 100002\nusing namespace std;\nint head[N],ver[N*2],nxt[N*2],l;\nint head1[N],ver1[N*2],nxt1[N*2],l1;\nint n,m,i,j,a[N],b[N],c[N],fa[N],p[N],f[N],sum[N];\nbool vis[N];\nvoid add(int x,int y){\n\tl++;\n\tver[l]=y;\n\tnxt[l]=head[x];\n\thead[x]=l;\n}\nvoid add1(int x,int y){\n\tl1++;\n\tver1[l1]=y;\n\tnxt1[l1]=head1[x];\n\thead1[x]=l1;\n}\nint cmp(const int &x,const int &y){\n\treturn c[x]<c[y];\n}\nint find(int x){\n\tif(fa[x]!=x) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\nvoid dfs(int x){\n\tsum[x]=b[x];\n\tfor(int i=head1[x];i;i=nxt1[i]){\n\t\tint y=ver1[i];\n\t\tdfs(y);\n\t\tsum[x]+=sum[y];\n\t}\n\tf[x]=sum[x]+c[x];\n\tfor(int i=head1[x];i;i=nxt1[i]){\n\t\tint y=ver1[i];\n\t\tf[x]=min(f[x],sum[x]-sum[y]+max(f[y],c[x]));\n\t}\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tc[i]=max(a[i]-b[i],0ll);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%lld%lld\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(i=1;i<=n;i++) fa[i]=p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tint x=p[i];\n\t\tvis[x]=1;\n\t\tfor(j=head[x];j;j=nxt[j]){\n\t\t\tint y=ver[j];\n\t\t\tif(vis[y]){\n\t\t\t\tint f=find(y);\n\t\t\t\tif(f!=x){\n\t\t\t\t\tfa[f]=x;\n\t\t\t\t\tadd1(x,f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(p[n]);\n\tcout<<f[p[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nvoid unite_que(priority_queue<Pii, vector<Pii>, greater<Pii>> &q1, priority_queue<Pii, vector<Pii>, greater<Pii>> &q2){\n    if(q2.size() > q1.size()) q1.swap(q2);\n    while(!q2.empty()){\n        q1.push(q2.top());\n        q2.pop();\n    }\n}\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, dat;\n    vector<priority_queue<Pii, vector<Pii>, greater<Pii>>> que;\n\n    Union_find(int N, vector<int> v){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        dat = v;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        dat[x] += dat[y];\n        unite_que(que[x], que[y]);\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int w, Union_find &UF){\n        if(UF.find(v) != v) return;\n        while(!UF.que[UF.find(v)].empty()){\n            int par = UF.find(v);\n            Pii p = UF.que[par].top(); UF.que[par].pop();\n            if(p.first > UF.dat[par] + w) break;\n            UF.unite(par, p.second);\n        }\n    }\n\n};\n\nvoid init(Graph &G, Union_find &UF, vec &A, int N){\n    UF.que = vector<priority_queue<Pii, vector<Pii>, greater<Pii>>>(N);\n    REP(i, N) REP(k, G.G[i].size()) UF.que[i].push(Pii(A[G.G[i][k].to], G.G[i][k].to));\n}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    int S = 0;\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        S += B[i];\n        A[i] -= B[i];\n    }\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1, 0);\n    }\n\n    int w1 = -1, w2 = 1000000000;\n    while(w2 - w1 > 1){\n        int w = (w1 + w2 + 1) / 2;\n        Union_find UF(N, B);\n        init(G, UF, A, N);\n        REP(i, N) if(w >= A[i]) G.dfs(i, w, UF);\n        //cout << w << \",\" << UF.union_size(0) << endl;\n        if(UF.union_size(0) == N) w2 = w;\n        else w1 = w;\n    }\n    cout << w2 + S << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nint i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nint tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tint x,y;\n}a[N];\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(int x,int y) {\n\treturn a[x].x<a[y].x;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tint r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=max(a[id[i]].x,a[id[i]].y);\n\t\t\ts[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tif (r==1) {\n\t\t\ts[id[i]]=S+a[id[i]].y;\n\t\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\t\tint p=max(a[id[i]].x,a[id[i]].y);\n\t\t\tA[id[i]]=min(max(1ll*a[id[i]].x,a[id[i]].y+A[q[1]]),S+p);\n\t\t\tcontinue;\n\t\t}\n\t\tint p=max(a[id[i]].x,a[id[i]].y);\n\t\tfor (j=1;j<=r;j++) M=min(M,S-s[q[j]]+max(1ll*a[id[i]].x,a[id[i]].y+A[q[j]]));\n\t\tM=min(M,S+p);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%lld\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<55) + 1e9;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass UF{\npublic:\n  Int V;\n  vector<Int> par,rnk,sz;\n  UF(){}\n  UF(Int V):V(V),par(V),rnk(V,0),sz(V,1){for(Int i=0;i<V;i++)par[i]=i;}\n  \n  Int find(Int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(Int x,Int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rnk[x]<rnk[y])par[x]=y, sz[y] += sz[x];\n    else{\n      par[y]=x;\n      sz[x] += sz[y];\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  bool same(Int x,Int y){return find(x)==find(y);}\n\n  Int size(Int x){return sz[find(x)];}\n};\n\n\nInt n;\nvector<vector<Int> > G;\nvector<Int> A, B;\n\nInt solve(){\n  vector<Int> ord(n); iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](Int a,Int b){return A[a] - B[a] < A[b] - B[b];});\n  vector<Int> dp(n,INF);\n  \n  UF uf(n);\n  for(Int i=0;i<n;i++) uf.sz[i] = B[i];\n  \n  vector<Int> used(n, 0);\n  for(Int v:ord){\n    assert(v == uf.find(v));\n    Int c = max(0LL, A[v] - B[v]);\n    used[v] = 1;\n    Int mn = INF;\n    for(Int to:G[v]){\n      to = uf.find(to);\n      if(used[to] == 0) continue;\n      Min(mn, max(c - uf.size(to), dp[to]));\n      uf.unite(v, to);\n      v = uf.find(v);\n    }\n    if(mn == INF) mn = c;\n    dp[v] = mn;\n  }\n\n  Int res = accumulate(B.begin(), B.end(), 0LL);\n  assert(res == uf.size(0));\n  Int last = uf.find(ord.back());\n  res += max(0LL, dp[last]);\n  return res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int m;\n  cin>>n>>m;\n  G.resize(n);\n  A.resize(n); B.resize(n);\n  for(Int i=0;i<n;i++) cin>>A[i]>>B[i];\n  \n  for(Int i=0;i<m;i++){\n    Int u, v;\n    cin>>u>>v; u--, v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  Int ans = solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=100111;\n\nvector<int> con[maxn];\nint f[maxn];int gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\n\nint n,m,a[maxn],b[maxn],ord[maxn];\nbool cmp(int x,int y){return mp(a[x],x)<mp(a[y],y);}\n\nLL s[maxn],dp[maxn];\nint main()\n{\n\tget2(n,m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tget2(a[i],b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tord[i]=i;f[i]=i;\n\t}\n\tfor(int i=1,u,v;i<=m;i++)\n\t{\n\t\tget2(u,v);\n\t\tcon[u].pb(v);con[v].pb(u);\n\t}\n\t\n\tsort(ord+1,ord+n+1,cmp);\n\tfor(int _=1;_<=n;_++)\n\t{\n\t\tint x=ord[_];\n\t\tdp[x]=a[x];s[x]=b[x];\n\t\tfor(auto v:con[x])if(mp(a[x],x)>mp(a[v],v)&&gf(v)!=x)\n\t\t{\n\t\t\tint vv=gf(v);\n\t\t\ts[x]+=s[vv];\n\t\t\tdp[x]=min(dp[x],dp[vv]+max(0ll,a[x]-s[vv]-dp[vv]));\n\t\t\tf[vv]=x;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[ord[n]]+s[ord[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N*2],z[N*2],nxt[N*2],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N];\nint bh[N],bt;\nLL need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tif (((int)son[x].size())>0)\n\t\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nbool rdcmp(int a,int b){\n\treturn rand()%2;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t\tj++;\n\t}\n\tint root=1;\n\tfor (int i=2;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tLL ans=1e16;\n\tdfs(root,0);\n\tans=min(ans,need[root]);\n\tsrand(19260817);\n\tbt=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (A[i]==A[root]){\n\t\t\tbh[++bt]=i;\n\t\t}\n\t}\n\tsort(bh+1,bh+bt+1,rdcmp);\n\tfor (int i=1;i<=min(50,bt);i++){\n\t\troot=bh[i];\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tfor (int i=1;i<=300;i++){\n\t\troot=rand()%n+1;\n\t\tdfs(root,0);\n\t\tans=min(ans,need[root]);\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 101000\nusing namespace std;\nstruct point{\n\tint a, b, num;\n\tbool operator<(const point &p)const {\n\t\treturn a != p.a?a<p.a:b<p.b;\n\t}\n}w[N_];\nint A[N_], B[N_];\nvector<int>E[N_];\nlong long SB[N_], M[N_], mmm;\nint UF[N_], chk[N_];\nint n, m, v[N_];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nstruct TT {\n\tlong long sb, m;\n\tbool operator <(const TT &p)const {\n\t\treturn sb - m < p.sb - p.m;\n\t}\n};\nlong long G[N_], BB[N_], EE[N_];\nvoid Go(int a, vector<int> &T) {\n\tchk[a] = 1;\n\tif (T.empty()) {\n\t\tSB[a] = B[a];\n\t\tM[a] = max(A[a], B[a]);\n\t\treturn;\n\t}\n\tint sz = T.size();\n\tvector<TT> U(sz);\n\tmmm = A[a];\n\tint c = 0;\n\tfor (auto &t : T) {\n\t\tUF[t] = a;\n\t\tU[c++] = { SB[t], M[t] };\n\t}\n\tsort(U.begin(), U.end());\n\tlong long mm = 0, sb = 0;\n\tint i;\n\tfor (i = 0; i < sz; i++) {\n\t\tmm = max(mm, sb + U[i].m);\n\t\tG[i] = sb + U[i].m;\n\t\tsb += U[i].sb;\n\t}\n\tmm = max(mm, sb + max(A[a], B[a]));\n\tfor (i = 0; i < sz; i++) {\n\t\tif (i == 0 || G[i] > BB[i - 1])BB[i] = G[i];\n\t\telse BB[i] = BB[i - 1];\n\t}\n\tfor (i = sz - 1; i >= 0; i--) {\n\t\tif (i == sz - 1 || G[i] > EE[i + 1])EE[i] = G[i];\n\t\telse EE[i] = EE[i + 1];\n\t}\n \n\tfor (i = 0; i < sz; i++) {\n\t\tlong long t = sb - U[i].sb + B[a] + U[i].m;\n\t\tt = max(t, sb - U[i].sb + max(A[a], B[a]));\n\t\tif (i != 0)t = max(t, BB[i - 1]);\n\t\tif (i != sz - 1)t = max(t, EE[i + 1] - U[i].sb);\n\t\tmm = min(mm, t);\n\t}\n \n\tsb += B[a];\n\tM[a] = mm;\n\tSB[a] = sb;\n}\nint main() {\n\tint i, a, b;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &w[i].a, &w[i].b);\n\t\tA[i] = w[i].a, B[i] = w[i].b;\n\t\tUF[i] = i;\n\t\tw[i].num = i;\n\t}\n\tsort(w + 1, w + n + 1);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint a = w[i].num;\n\t\tvector<int>T;\n\t\tfor (auto &x : E[a]) {\n\t\t\tif (!chk[x])continue;\n\t\t\tint t = Find(x);\n\t\t\tif (!v[t]) {\n\t\t\t\tT.push_back(t);\n\t\t\t\tv[t] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : T)v[t] = 0;\n\t\tGo(a, T);\n\t}\n\tprintf(\"%lld\\n\",M[w[n].num]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tll a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].a,&a[i].b);\n\tif(n==1) return printf(\"%lld\",a[1].b),0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e17,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e17;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mx,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tll a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].a,&a[i].b);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e17,mid,ans=0;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e17;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;continue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mx,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\n\tvector<int> par, ran;\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tu = trans[u], v = trans[v];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i]+csum);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = mi;\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return w*s;}\nconst int maxn = 2e5;\nstruct node{\n\tint next,to;\n}e[maxn];\nvector<int> edge[maxn]; \nint h[maxn],n,m,a[maxn],point[maxn],b[maxn],fa[maxn],f[maxn],tot;\nlong long dp[maxn],Sum[maxn];\ninline bool cmp(int p,int q){return a[p]<a[q];}\ninline void add(int from,int to){e[++tot].to=to,e[tot].next=h[from];h[from]=tot;}\nint find(int k){if(f[k]==k)return k;else return f[k]=find(f[k]);} \nvoid Dfs(int now)\n{\n\tif(edge[now].size()==0)\n\t{\n\t\tSum[now]=b[now];\n\t\tdp[now]=a[now]+b[now];return ;\n\t}Sum[now]=b[now];\n\tfor(register int i=0;i<edge[now].size();++i)\n\t{\n\t\tint to=edge[now][i];\n\t\tDfs(to);Sum[now]+=Sum[to];\n\t}\n\tdp[now]=1e18+8;\n\tfor(register int i=0;i<edge[now].size();++i)\n\t{\n\t\tdp[now]=min(dp[now],max((long long)a[now],dp[edge[now][i]])+Sum[now]-Sum[edge[now][i]]);\n\t}\n} \nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1,w1,w2;i<=n;++i) {a[i]=read(),b[i]=read();a[i]=max(0,a[i]-b[i]);point[i]=i;}\n\tsort(point+1,point+n+1,cmp);\n\tfor(register int i=1,u,v;i<=m;++i) u=read(),v=read(),add(u,v),add(v,u); memset(fa,-1,sizeof(fa));\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tint now=point[i];f[now]=now;\n\t\tfor(register int j=h[now];j;j=e[j].next)\n\t\t{\n\t\t\tint to=e[j].to;int Fa=find(to);if(fa[Fa]==0)fa[Fa]=now,f[Fa]=now;\n\t\t}\n\t\tfa[now]=0;\n\t}\n\tint rt;\n\tfor(register int i=1;i<=n;++i){if(fa[i]) edge[fa[i]].pb(i);else rt=i;}\n\tDfs(rt);\n\tcout<<dp[rt];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile(c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nconst int maxn = 100005;\n\nint n, m, a[maxn], b[maxn], p[maxn], fa[maxn], vis[maxn];\nlong long f[maxn], s[maxn];\n\nstruct edge\n{\n\tint to, next;\n} e[maxn * 2];\nint h[maxn], tot;\n\ninline void add(int u, int v)\n{\n\te[++tot] = (edge) {v, h[u]}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nint find(int x)\n{\n\tif (fa[x] == x) return x;\n\treturn fa[x] = find(fa[x]);\n}\n\nint main()\n{\n\tn = gi(); m = gi();\n\tfor (int i = 1; i <= n; ++i) {\n\t\ta[i] = gi(); b[i] = gi();\n\t\ta[i] = max(0, a[i] - b[i]);\n\t}\n\tfor (int i = 1; i <= m; ++i) add(gi(), gi());\n\t\n\tfor (int i = 1; i <= n; ++i) fa[i] = p[i] = i, s[i] = b[i], f[i] = a[i];\n\n\tsort(p + 1, p + n + 1, [](const int &x, const int &y) {return a[x] < a[y];});\n\n\tfor (int k = 1; k <= n; ++k) {\n\t\tint u = p[k];\n\t\tvis[u] = 1;\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (vis[v]) {\n\t\t\t\tint x = find(u), y = find(v);\n\t\t\t\tif (x == y) continue;\n\t\t\t\tfa[y] = x;\n\t\t\t\ts[x] += s[y];\n\t\t\t\tf[x] = min(f[x], max(f[y], a[x] - s[y]));\n\t\t\t}\n\t}\n\n\tint x = find(1);\n\tprintf(\"%lld\\n\", f[x] + s[x]);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    vector<int> sc(cp.size(), 1);\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (sc[i])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=500005,inf=1e9;\ntypedef long long ll;\nint read(){\n\tint x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1; ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct Edg{\n\tint nxt,poi;\n}e[N<<1];\nint fa[N],a[N],b[N],first[N],l=0,c[N];\nll f[N],g[N];\nbool vis[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nvoid addedge(int u,int v){\n\tl++;\n\te[l].nxt=first[u];\n\te[l].poi=v;\n\tfirst[u]=l;\n}\nint find(int x){\n\treturn (fa[x]==x)?x:fa[x]=find(fa[x]);\n}\nint main(){\n\tint n=read(),m=read();\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=read(),b[i]=read(); a[i]=max(0,a[i]-b[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint u=read(),v=read();\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tfa[i]=i; c[i]=i; f[i]=a[i]; g[i]=b[i];\n\t}\n\tsort(c+1,c+1+n,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint u=c[i]; vis[u]=1;\n\t\tfor (int p=first[u];p;p=e[p].nxt){\n\t\t\tint v=e[p].poi;\n\t\t\tif (!vis[v]) continue;\n\t\t\tint x=find(u),y=find(v);\n\t\t\tif (x==y) continue;\n\t\t\tg[x]+=g[y]; fa[y]=x;\n\t\t\tf[x]=min(f[x],f[y]+max(0ll,a[u]-f[y]-g[y]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[c[n]]+g[c[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e5+5;\nint n,m,ID[N],fa[N],vis[N];\nll A[N],B[N],C[N],dp[N],sum[N];\nvector <int> G[N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\nint find(int x) {return x==fa[x]?fa[x]:fa[x]=find(fa[x]);}\nbool cmp(int x,int y) {return C[x]<C[y];}\ninline void addedge(int u=0,int v=0) {\n\tIN(u),IN(v),G[u].push_back(v),G[v].push_back(u);\n}\n\nint main() {\n\tIN(n),IN(m);\n\tfor(int i=1;i<=n;++i) fa[i]=ID[i]=i;\n\tfor(int i=1;i<=n;++i) IN(A[i]),IN(B[i]),C[i]=max(A[i]-B[i],(ll)0);\n\tsort(ID+1,ID+1+n,cmp);\n\tfor(int i=1;i<=m;++i) addedge();\n\tint u;\n\tfor(int i=1;i<=n;++i) {\n\t\tvis[u=ID[i]]=true,sum[u]=B[u],dp[u]=C[u];\n\t\tfor(auto tmp:G[u]) if(vis[tmp]) {\n\t\t\tint v=find(tmp);\n\t\t\tif(v==u) continue;\n\t\t\tfa[v]=u,sum[u]+=sum[v],dp[u]=min(dp[u],max(dp[v],C[u]-sum[v]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[ID[n]]+sum[ID[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 1e5 + 3;\n\nclass UF{\n\tint x[UF_MAX];\n\tLL p[UF_MAX];\n\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> Q[UF_MAX];\n\t\npublic:\n\n\tvoid clear(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tfill(p,p+UF_MAX,0);\n\t\trepp(i,0,UF_MAX) while(!Q[i].empty()) Q[i].pop();\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\tif(Q[s].size() < Q[t].size()) swap(s,t);\n\t\t\twhile(!Q[t].empty()){\n\t\t\t\tQ[s].push(Q[t].top()); Q[t].pop();\n\t\t\t}\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t\tp[s] += p[t];\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t\tp[t] += p[s];\n\t\t\t\tswap(Q[s],Q[t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tLL get_p(int a){\n\t\treturn p[boss(a)];\n\t}\n\n\tint get_q(int a){\n\t\ta = boss(a);\n\t\treturn Q[a].empty()?-1:Q[a].top().second;\n\t}\n\n\tvoid set(int a , LL b){\n\t\tp[a] = b;\n\t}\n\n\tvoid push(int a , int b , LL c){\n\t\tQ[a].push({c,b});\n\t}\n\n\tvoid pop(int a){\n\t\tQ[boss(a)].pop();\n\t}\n};\n\nconst int MC = 1e5 + 3;\nint N,M;\nLL A[MC],B[MC],S;\nvector<int> V[MC];\nUF uf;\n\nbool eval(LL z){\n\tvector<int> used(N,0);\n\tqueue<int> Q;\n\tuf.clear();\n\trepp(i,0,N){\n\t\tfor(auto u : V[i]) uf.push(i,u,A[u]);\n\t\tif(z >= A[i]){\n\t\t\tQ.push(i);\n\t\t\tuf.set(i,B[i]);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint k = Q.front(); Q.pop();\n\t\tfor(int u = uf.get_q(k) ; u >= 0 && z + uf.get_p(k) >= A[u] ; u = uf.get_q(k)){\n\t\t\tif(!used[u]){\n\t\t\t\tuf.set(u,B[u]);\n\t\t\t\tused[u] = 1;\n\t\t\t\tQ.push(u);\n\t\t\t}\n\t\t\tuf.uni(k,u);\n\t\t\tuf.pop(k);\n\t\t}\n\t}\n\tint c = 0;\n\trepp(i,0,N) c += used[i];\n\treturn c == N;\n}\n\nLL BS(LL x , LL y){\n\tif(x-y<2) return x;\n\tLL z = (x+y)/2;\n\treturn eval(z)?BS(z,y):BS(x,z);\n}\n\nint main(){\n\tcin >> N >> M;\n\trepp(i,0,N){\n\t\tcin >> A[i] >> B[i];\n\t\tS += B[i];\n\t\tA[i] -= B[i];\n\t}\n\trepp(i,0,M){\n\t\tint x,y; cin >> x >> y;\n\t\tV[--x].push_back(--y);\n\t\tV[y].push_back(x);\n\t}\n\tcout << S + BS(1e9,-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 100010;\n\nint n, m, l[maxn], e = 0;\n\nint A[maxn], B[maxn], C[maxn], ind[maxn], vis[maxn];\nll val[maxn], sum[maxn];\n\nstruct Edge {\n\tint v, x;\n} E[maxn << 1];\n\ninline void addEdge(int u, int v) {\n\tE[e].v = v; E[e].x = l[u]; l[u] = e++;\n}\n\nint fa[maxn];\n\nint getroot(int x) {\n\tif (x == fa[x]) return x;\n\treturn fa[x] = getroot(fa[x]);\n}\n\nbool cmp(int x, int y) {\n\treturn C[x] < C[y];\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d%d\", &A[i], &B[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\taddEdge(u, v); addEdge(v, u);\n\t}\n\tfor (int i = 1; i <= n; i++) fa[i] = ind[i] = i, C[i] = max(A[i] - B[i], 0), sum[i] = B[i];\n\tsort(ind+1, ind+n+1, cmp);\n\tfor (int _ = 1; _ <= n; _++) {\n\t\tvector<int> vec;\n\t\tint i = ind[_];\n\t\tvis[i] = 1;\n\t\tfor (int p = l[i]; p >= 0; p = E[p].x) if (vis[E[p].v]) vec.push_back(getroot(E[p].v));\n\t\tsort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\tval[i] = C[i];\n\t\tfor (int x = 0; x < vec.size(); x++) {\n\t\t\tint v = vec[x];\n\t\t\t// sum[v] + ? >= C[i]\n\t\t\t// ? >= C[i] - sum[v];\n\t\t\t// ? >= val[v]\n\t\t\tval[i] = min(val[i], max(C[i] - sum[v], val[v]));\n\t\t\tfa[v] = i; sum[i] += sum[v];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", val[getroot(1)]+sum[getroot(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=200005;\nint n,m;\nLL A[Maxn],B[Maxn];\nLL dp[Maxn][2],S[Maxn];\nvector<int> G[Maxn],nG[Maxn];\nint par[Maxn],ord[Maxn];\nbool O[Maxn];\nint findset(int x){\n\treturn par[x]=(par[x]==x)?x:findset(par[x]);\n}\nbool cmp(int x,int y){\n\treturn A[x]-B[x]<A[y]-B[y];\n}\nvoid dfs(int x){\n\tS[x]=B[x];\n\tfor (int i=0;i<nG[x].size();i++){\n\t\tdfs(nG[x][i]);\n\t\tS[x]+=S[nG[x][i]];\n\t}\n}\nvoid dfs2(int x){\n\tdp[x][0]=S[x]-B[x]+max(A[x],B[x]);\n\tfor (int i=0;i<nG[x].size();i++){\n\t\tdfs2(nG[x][i]);\n\t}\n\tdp[x][1]=dp[x][0];\n\tLL totS=S[x]-B[x];\n\tfor (int i=0;i<nG[x].size();i++){\n\t\tint v=nG[x][i];\n\t\tdp[x][1]=min(dp[x][1],max(totS-S[v]+max(A[x],B[x]),totS-S[v]+B[x]+dp[v][1]));\n\t}\n}\nint main(){\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++){\n\t\tA[i]=read();B[i]=read();\n\t}\n\tfor (int i=0;i<m;i++){\n\t\tint u,v;u=read();v=read();\n\t\tG[u].pb(v);G[v].pb(u);\n\t}\n\tfor (int i=1;i<=n;i++) ord[i]=i;\n\tfor (int i=1;i<=n;i++) par[i]=i;\n\tsort(ord+1,ord+1+n,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint v=ord[i];\n\t\tvector<int> tmp;\n\t\tfor (int j=0;j<G[v].size();j++){\n\t\t\tif (O[G[v][j]])tmp.pb(findset(G[v][j]));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\ttmp.resize(unique(tmp.begin(),tmp.end())-tmp.begin());\n\t\tfor (int j=0;j<tmp.size();j++){\n\t\t\tnG[v].pb(tmp[j]);\n\t\t\t//cout<<\"Add\"<<' '<<v<<' '<<tmp[j]<<endl;\n\t\t\tpar[tmp[j]]=v;\n\t\t}\n\t\tO[v]=1;\n\t}\n\tint rt=ord[n];\n\tdfs(rt);\n\tdfs2(rt);\n\tprintf(\"%lld\\n\",dp[rt][1]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#define ll long long\n#define maxn 100010\n#define inf 0x3f3f3f3f\ninline ll read()\n{\n    ll x=0; char c=getchar(),f=1;\n    for(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n    for(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n    return x*f;\n}\ninline void write(ll x)\n{\n    static int buf[20],len; len=0;\n    if(x<0)x=-x,putchar('-');\n    for(;x;x/=10)buf[len++]=x%10;\n    if(!len)putchar('0');\n    else while(len)putchar(buf[--len]+'0');\n}\ninline void writeln(ll x){write(x); putchar('\\n');}\ninline void writesp(ll x){write(x); putchar(' ');}\nstruct edge{\n\tint to,nxt;\n}e[2*maxn];\nint fir[maxn],a[maxn],b[maxn],c[maxn],id[maxn],fa[maxn],mark[maxn];\nll f[maxn],size[maxn];\nstd::vector<int>son[maxn];\nint n,m,tot=0;\nbool cmp(int x,int y){return c[x]<c[y];}\ninline void add_edge(int x,int y){e[tot].to=y; e[tot].nxt=fir[x]; fir[x]=tot++;}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dp(int now)\n{\n\tsize[now]=b[now];\n\tfor(auto i:son[now]){\n\t\tdp(i);\n\t\tsize[now]+=size[i];\n\t}\n\tf[now]=(son[now].size()?1ll<<60:c[now]+b[now]);\n\tfor(auto i:son[now])\n\t\tf[now]=std::min(f[now],std::max((ll)c[now],f[i])+size[now]-size[i]);\n}\nint main()\n{\n\tn=read(); m=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read(),b[i]=read(),c[i]=std::max(a[i]-b[i],0);\n\tmemset(fir,255,sizeof(fir)); tot=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint x=read(),y=read();\n\t\tadd_edge(x,y); add_edge(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfa[i]=i,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tmark[id[i]]=1;\n\t\tfor(int j=fir[id[i]];~j;j=e[j].nxt)\n\t\t\tif(mark[e[j].to]){\n\t\t\t\tint fx=find(id[i]),fy=find(e[j].to);\n\t\t\t\tif(fx!=fy){\n\t\t\t\t\tfa[fy]=fx;\n\t\t\t\t\tson[id[i]].push_back(fy);\n\t\t\t\t}\n\t\t\t}\n\t}\n\tdp(id[n]);\n\twriteln(f[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nbool comp(pair<LP, int> a, pair<LP, int> b) {\n\tll da = a.first.first - a.first.second;\n\tll db = b.first.first - b.first.second;\n\tif (da != db)return da < db;\n\treturn a < b;\n}\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end(),comp);\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u1, u2; cin >> u1 >> u2; u1--; u2--;\n\t\tu1 = trans[u1], u2= trans[u2];\n\t\tG[u1].push_back(u2);\n\t\tG[u2].push_back(u1);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i]+csum);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = mi;\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll LLINF = 1ll << 60;\nconst int N = 100010;\nint n, m, va[N], vb[N], id[N], per[N], uni[N];\nll sum[N], dp[N], ans;\nint getfa(int pos) {\n  return pos == uni[pos] ? pos : uni[pos] = getfa(uni[pos]);\n}\nvector<int> vec[N];\nint main() {\n  int x,y;\n  read(n), read(m);\n  rep (i, 1, n) read(va[i]), read(vb[i]);\n  rep (i, 1, n) per[i] = i;\n  sort(per + 1, per + n + 1, [=](int a,int b) -> bool {\n      return va[a] < va[b];\n    });\n  rep (i, 1, n) id[per[i]] = i;\n  rep (i, 1, m) {\n    read(x), read(y);\n    if (id[x] < id[y]) swap(x, y);\n    vec[x].push_back(y);\n  }\n  rep (i, 1, n) {\n    uni[i] = i;\n    sum[i] = vb[i];\n    dp[i] = max(va[i], vb[i]);\n  }\n  rep (i, 1, n) {\n    int j = per[i];\n    vector<int> tmp;\n    rep (k, 0, (int)vec[j].size()-1)\n      tmp.push_back(getfa(vec[j][k]));\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n    ll ssum = 0;\n    rep (k, 0, (int)tmp.size()-1)\n      ssum += sum[tmp[k]];\n    dp[j] = LLINF;\n    if (tmp.empty()) dp[j] = max(va[j], vb[j]);\n    rep (k, 0, (int)tmp.size()-1) {\n      dp[j] = min(dp[j], ssum - sum[tmp[k]] + max((ll)va[j], dp[tmp[k]] + vb[j]));\n    }\n    dp[j] = min(dp[j], ssum + max(va[j], vb[j]));\n    rep (k, 0, (int)tmp.size()-1) {\n      uni[tmp[k]] = j;\n      sum[j] += sum[tmp[k]];\n    }\n  }\n  cout << dp[per[n]] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pii pair <int , int>\n#define F first\n#define S second\nconst int N = 1e5 + 5, inf = 1e9 + 1;\nint A[N], B[N], par[N], C, n, m;\nlong long W[N], Sum;\nvector <int> g[N];\npriority_queue <pii, vector<pii>, greater<pii>> pq[N];\n\nvoid init() {\n    C = n;\n    for (int v = 1; v <= n; v++) {\n        par[v] = v, W[v] = B[v];\n        while (!pq[v].empty()) pq[v].pop();\n        for (int u : g[v]) pq[v].push({A[u] - B[u], u});\n    }\n}\nint getpar(int v) {return par[v] = (par[v] == v ? v : getpar(par[v]));}\nvoid Union(int u, int v) {\n    u = getpar(u);\n    if (u == v) return ;\n    par[u] = v, W[v] += W[u], C--;\n    if (pq[u].size() > pq[v].size()) swap(pq[u], pq[v]);\n    while (!pq[u].empty()) pq[v].push(pq[u].top()), pq[u].pop();\n}\nbool check(int w) {\n    init();\n    for (int v = 1; v <= n; v++) if (par[v] == v && w + W[v] >= A[v]) {\n        while (!pq[v].empty()) {\n            int u = pq[v].top().S;\n            if (A[u] - B[u] > W[v] + w) break ;\n            pq[v].pop(), Union(u, v);\n        }\n    }\n    return C == 1;\n}\nint32_t main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> A[i] >> B[i], Sum += B[i];\n    if (n == 1) return cout << max(A[1], B[1]) << \"\\n\", 0;\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    int dw = -1, up = inf;\n    while (up - dw > 1) {\n        int md = (up+dw)>>1;\n        if (check(md)) up = md;\n        else dw = md;\n    }\n    cout << Sum + up << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000005;\nstruct Edge{int u,v;int w;\ninline bool operator <(const Edge &b)const {return w<b.w;}\n}e[N];\nll f[N],sum[N];\nint fa[N];\nint a[N],b[N];\nint find(int x){return fa[x]==x?x:find(fa[x]);}\nint main()\n{\n\t//freopen(\"input.txt\",\"r\",stdin);\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n,m,tmp=0;\n\tcin >>n>>m;\n\tfor(int i=1;i<=n;i++)cin >>a[i]>>b[i],fa[i]=i,sum[i]=b[i],f[i]=max(a[i],b[i]);\n\tfor(int i=1;i<=m;i++)cin >>e[i].u>>e[i].v,e[i].w=max(max(a[e[i].u]-b[e[i].u],0),max(a[e[i].v]-b[e[i].v],0));\n\tsort(e+1,e+1+m);\n\tfor(int i=1;i<=m;i++)if((e[i].u=find(e[i].u))!=(e[i].v=find(e[i].v)))\n\t{\n\t\tf[e[i].u]=min(max(f[e[i].u],(ll)e[i].w)+sum[e[i].v],max(f[e[i].v],(ll)e[i].w)+sum[e[i].u]);\n\t\tfa[e[i].v]=e[i].u;\n\t\tsum[e[i].u]+=sum[e[i].v];\n\t}\n\tcout <<f[find(1)]<<endl;\n\t//cout <<tmp<<n;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n      \n      if(q.empty()){\n\tfor(Int i=0;i<n;i++) if(used[i]) push(i);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=max(s,*max_element(a.begin(),a.end()))-1;\n  Int r=s+*max_element(a.begin(),a.end())+1;\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR int w=Q[v].top().se;Q[v].pop();\n\t\tif(find(w)!=find(u))Q[u].push(pi(dx[w],w));\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tif(h>t)return false;\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR int v=Q[u].top().se;if(dx[v]>s[u])break;\n\t\t\tQ[u].pop();if(find(v)==find(u))continue;\n\t\t\tif(s[u]+s[v]>=mx)return true;\n\t\t\ts[u]+=s[v],fa[find(v)]=u,++cnt,merge(u,v);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(mx,a[i]-b[i]);\n\tl=1,r=mx;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <tuple>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nnamespace loquat {\nclass disjoint_set {\npublic:\n\tusing value_type = size_t;\nprivate:\n\tstd::vector<value_type> m_parents;\n\tstd::vector<value_type> m_ranks;\npublic:\n\texplicit disjoint_set(size_t n)\n\t\t: m_parents(n)\n\t\t, m_ranks(n)\n\t{\n\t\tfor(size_t i = 0; i < n; ++i){\n\t\t\tm_parents[i] = i;\n\t\t}\n\t}\n\tvalue_type find(size_t x){\n\t\tif(m_parents[x] == x){ return x; }\n\t\tm_parents[x] = find(m_parents[x]);\n\t\treturn m_parents[x];\n\t}\n\tvalue_type unite(size_t x, size_t y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){ return x; }\n\t\tif(m_ranks[x] < m_ranks[y]){\n\t\t\tm_parents[x] = y;\n\t\t\treturn y;\n\t\t}else if(m_ranks[x] > m_ranks[y]){\n\t\t\tm_parents[y] = x;\n\t\t\treturn x;\n\t\t}else{\n\t\t\tm_parents[y] = x;\n\t\t\t++m_ranks[x];\n\t\t\treturn x;\n\t\t}\n\t}\n\tbool same(size_t x, size_t y){\n\t\treturn find(x) == find(y);\n\t}\n};\n}\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\nusing tiii = tuple<int, int, int>;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<ll> a(n), b(n);\n\tfor(int i = 0; i < n; ++i){ cin >> a[i] >> b[i]; }\n\tvector<vector<int>> conn(n);\n\tfor(int i = 0; i < m; ++i){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tconn[u].push_back(v);\n\t\tconn[v].push_back(u);\n\t}\n\tvector<tiii> vorder(n);\n\tfor(int i = 0; i < n; ++i){\n\t\tvorder[i] = tiii(a[i], -b[i], i);\n\t}\n\tsort(vorder.begin(), vorder.end());\n\tloquat::disjoint_set ds(n);\n\tvector<bool> done(n);\n\tvector<ll> w(n), c(n);\n\tfor(const auto& vp : vorder){\n\t\tconst int u = get<2>(vp);\n\t\tvector<pll> ws;\n\t\tfor(const int v : conn[u]){\n\t\t\tif(done[v] && !ds.same(u, v)){\n\t\t\t\tconst int g = ds.find(v);\n\t\t\t\tws.emplace_back(w[g], c[g]);\n\t\t\t\tds.unite(u, v);\n\t\t\t}\n\t\t}\n\t\tconst int g = ds.find(u);\n\t\tll csum = 0;\n\t\tfor(const auto& p : ws){ csum += p.second; }\n\t\tll w_best = max(a[u], b[u]) + csum;\n\t\tfor(const auto& p : ws){\n\t\t\tw_best = min(w_best, max(a[u], p.first + b[u]) + (csum - p.second));\n\t\t}\n\t\tw[g] = w_best;\n\t\tc[g] = csum + b[u];\n\t\tdone[u] = true;\n\t}\n\tcout << *max_element(w.begin(), w.end()) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nint const N = 100000;\nvector<int> g[N + 1];\nint n, m, a[N + 1], b[N + 1], pa[N + 1], ex[N + 1];\nll sm[N + 1];\npair<int, int> x[N];\n\nint P(int v) { return pa[v] < 0 ? v : pa[v] = P(pa[v]); }\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tf(i, 1, n + 1)scanf(\"%d%d\", a + i, b + i);\n\tf(i, 0, n)x[i] = make_pair(a[i + 1], i + 1);\n\tsort(x, x + n);\n\tf(i, 0, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tpa[0] = -1;\n\tf(i, 0, n){\n\t\tint v = x[i].second, need = a[v] - b[v];\n\t\tsm[v] = b[v];\n\t\tex[v] = max(0, need);\n\t\tpa[v] = -1;\n\t\tf(j, 0, g[v].size()){\n\t\t\tint u = P(g[v][j]);\n\t\t\tif (u == 0 || u == v)continue;\n\t\t\tsm[v] += sm[u];\n\t\t\tex[v] = min((ll)ex[v], max((ll)ex[u], need - sm[u]));\n\t\t\tpa[u] = v;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sm[x[n - 1].second] + ex[x[n - 1].second]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nvector<ll> uft;\nvector<ll> bsum;\nvector<ll> ans;\nvector<pll> A;\n\nll parent(ll w){\n    if(uft[w]==w){return w;}\n    return uft[w]=parent(uft[w]);\n}\n\nvoid merge(ll a,ll b){\n    a=parent(a); b=parent(b);\n    if(a==b){return;}\n    ans[a]=min(ans[a]+bsum[b],max(ans[b],A[a].F-A[a].S)+bsum[a]);\n    bsum[a]+=bsum[b];\n    uft[b]=a;\n}\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    uft.resize(n);\n    bsum.resize(n);\n    ans.resize(n);\n    A.resize(n);\n    vector<pll> a(n);\n    for(auto &I:A){cin>>I.F>>I.S;}\n    for(int i=0;i<n;i++){\n        bsum[i]=A[i].S;\n        uft[i]=i;\n        ans[i]=max(A[i].F,A[i].S);\n        a[i]={A[i].F-A[i].S,i};\n    }\n    vector<vector<ll>> edge(n);\n    for(int i=0;i<m;i++){\n        ll u,v;\n        cin>>u>>v;\n        u--; v--;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n    }\n    vector<bool> used(n,false);\n    sort(a.begin(),a.end());\n    for(auto &I:a){\n        used[I.S]=true;\n        for(auto &T:edge[I.S]){\n            if(used[T]){merge(I.S,T);}\n        }\n    }\n    cout<<ans[parent(0)]<<endl;\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i)\n    cin >> a[i] >> b[i];\n  vector<vector<int>> g(n);\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    --u; --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  ll ans = 1LL << 60;\n  for (int i = 0; i < n; ++i) {\n    vector<bool> vis(n);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    ll s = 0, h = 0;\n    q.emplace(a[i] - b[i], i);\n    while (!q.empty()) {\n      int u = q.top().second; q.pop();\n      //cerr << u << ' ';\n      h = max(h, a[u] - (s += b[u]));\n      vis[u] = true;\n      for (int v : g[u])\n        if (!vis[v])\n          q.emplace(a[v] - b[v], v);\n    }\n    //cerr << \": \" << (h + s) << '\\n';\n    ans = min(ans, h);\n  }\n  ans += accumulate(b.begin(), b.end(), 0LL);\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint fa[100010],A[100010],B[100010],s[100010];\nll dp[100010],sb[100010];\nstd::vector<int>G[100010];\nint hd(int x){return fa[x]==x?x:fa[x]=hd(fa[x]);}\nbool yes[100010];\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),a,b;\n\tfor(int i=1;i<=n;++i)A[i]=gi(),B[i]=sb[i]=gi(),fa[i]=i,dp[i]=std::max(0,A[i]-B[i]),s[i]=i;\n\tstd::sort(s+1,s+n+1,[&](int x,int y){return dp[x]<dp[y];});\n\twhile(m--)a=gi(),b=gi(),G[a].push_back(b),G[b].push_back(a);\n\tfor(int _=1,x;_<=n;++_){\n\t\tx=s[_];yes[x]=1;\n\t\tfor(int i:G[x])\n\t\t\tif(hd(i)!=hd(x)&&yes[i]){\n\t\t\t\tint s=hd(i);\n\t\t\t\tfa[s]=x;\n\t\t\t\tsb[x]+=sb[s];\n\t\t\t\tdp[x]=std::min(dp[x],dp[s]+std::max(0ll,A[x]-B[x]-sb[s]-dp[s]));\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[hd(1)]+sb[hd(1)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint fa[100010],A[100010],B[100010],s[100010];\nll dp[100010],sb[100010];\nstd::vector<int>G[100010];\nint hd(int x){return fa[x]==x?x:fa[x]=hd(fa[x]);}\nbool yes[100010];\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),a,b;\n\tfor(int i=1;i<=n;++i)A[i]=gi(),B[i]=sb[i]=gi(),fa[i]=i,dp[i]=std::max(0,A[i]-B[i]),s[i]=i;\n\tstd::sort(s+1,s+n+1,[&](int x,int y){return dp[x]<dp[y];});\n\twhile(m--)a=gi(),b=gi(),G[a].push_back(b),G[b].push_back(a);\n\tfor(int _=1,x;_<=n;++_){\n\t\tx=s[_];yes[x]=1;\n\t\tfor(int i:G[x])\n\t\t\tif(hd(i)!=hd(x)&&yes[i]){\n\t\t\t\tint s=hd(i);\n\t\t\t\tfa[s]=x;\n\t\t\t\tsb[x]+=sb[s];\n\t\t\t\tdp[x]=std::min(dp[x],dp[s]+std::max(0ll,A[x]-B[x]-sb[s]-dp[s]));\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[hd(1)]+sb[hd(1)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\n\nint main() {\n    long long N, M; cin >> N >> M;\n    vector<int> A(M), B(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> A[i] >> B[i], --A[i], --B[i];\n    }\n        \n    UnionFind uf(N);\n    long long cur = N * (N-1) / 2;\n    vector<long long> res;\n    for (int i = 0; i < M; ++i) {\n        res.push_back(cur);\n            \n        int a = A[M-1-i], b = B[M-1-i];\n        if (uf.issame(a, b)) continue;\n        \n        long long sa = uf.size(a), sb = uf.size(b);\n        cur -= sa * sb;\n        uf.merge(a, b);\n    }\n        \n    reverse(res.begin(), res.end());\n    for (int i = 0; i < res.size(); ++i) cout << res[i] <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define DEBUG fprintf(stderr, \"Passing [%s] line %d\\n\", __FUNCTION__, __LINE__)\n#define File(x) freopen(x\".in\",\"r\",stdin); freopen(x\".out\",\"w\",stdout)\n#define int long long\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIII;\n\ninline int gi()\n{\n\tint f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') {if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f * x;\n}\n\ninline LL gl()\n{\n\tLL f = 1, x = 0; char c = getchar();\n\twhile (c < '0' || c > '9') {if (c == '-') f = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f * x;\n}\n\nconst int INF = 0x3f3f3f3f, N = 100003, M = N << 1;\n\nint n, m;\nint a[N], b[N], dp[N], s[N];\nint c[N], id[N];\nint fa[N], x[N];\nvector <int> g[N];\nint head[N], ver[M], nxt[M], tot;\n\ninline bool cmp(int x, int y) {return c[x] < c[y];}\n\nint getf(int u) {return fa[u] == u ? u : fa[u] = getf(fa[u]);}\n\nvoid dfs(int u, int f)\n{\n\ts[u] = b[u];\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = ver[i];\n\t\tif (v == f) continue;\n\t\tdfs(v, u);\n\t\ts[u] += s[v];\n\t}\n}\n\nvoid dfs1(int u, int f)\n{\n\tif (!head[u]) dp[u] = b[u] + c[u];\n\telse dp[u] = 1e18;\n\tfor (int i = head[u]; i; i = nxt[i])\n\t{\n\t\tint v = ver[i];\n\t\tif (v == f) continue;\n\t\tdfs1(v, u);\n\t\tdp[u] = min(dp[u], s[u] - s[v] + max(c[u], dp[v]));\n\t}\n}\n\ninline void add(int u, int v)\n{\n\tver[++tot] = v, nxt[tot] = head[u], head[u] = tot;\n}\n\nsigned main()\n{\n\t//File(\"\");\n\tn = gi(), m = gi();\n\tfor (int i = 1; i <= n; i+=1) a[i] = gi(), b[i] = gi(), c[i] = max(0ll, a[i] - b[i]), id[i] = i;\n\tsort(id + 1, id + 1 + n, cmp);\n\tfor (int i = 1; i <= m; i+=1) {int u = gi(), v = gi(); g[u].push_back(v), g[v].push_back(u);}\n//\tfor (int i = 1; i <= n; i+=1, puts(\"\"))\n//\t\tfor (int j = 0; j < g[i].size(); j+=1) cout << i << ' ' << g[i][j] << endl;\n//\tputs(\"?\");\n\tfor (int i = 1; i <= n; i+=1) fa[i] = i, x[id[i]] = i;\n//\tfor (int i = 1; i <= n; i+=1) cout << c[i] << ' ' << id[i] << endl;\n//\tputs(\"!\");\n//\tfor (int i = 1; i <= n; i+=1) cout << x[i] << ' '; puts(\"$\");\n\tfor (int i = 1; i <= n; i+=1)\n\t{\n\t\tint u = id[i], sz = g[u].size();\n\t\tfor (int j = 0; j < sz; j+=1)\n\t\t{\n\t\t\tint v = getf(g[u][j]);\n//\t\t\tcout << u << ' ' << v << endl;\n            if (x[v] < x[u]) add(u, v), fa[v] = u;\n\t\t}\n\t}\n//\tfor (int i = 1; i <= n; i+=1, puts(\"\")) for (int j = head[i]; j; j = nxt[j]) cout << i << ' ' << j << endl;\n\tdfs(id[n], 0);\n\tdfs1(id[n], 0);\n  \tprintf(\"%lld\\n\", dp[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nvector<int> v[100010],g[100010];\n\nll sum[100010],f[100010];\nint A[100010],B[100010],h[100010],from[100010],id[100010],n,m;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline bool cmp(const int &x,const int &y) { return A[x]<A[y]; }\n\ninline int find(int x) { return (x==from[x])?x:from[x]=find(from[x]); }\n\nint main()\n{\n\tn=rd();m=rd();\n\tfor (int i=1;i<=n;i++) A[i]=rd(),B[i]=rd(),A[i]=max(0,A[i]-B[i]);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tfor (int i=1;i<=n;i++) h[i]=i;\n\tsort(h+1,h+n+1,cmp);\n\tfor (int i=1;i<=n;i++) from[i]=i,id[h[i]]=i;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x=h[i];\n\t\tfor (int t:v[x]) if (id[t]<i&&find(t)!=x) g[x].push_back(find(t)),from[find(t)]=x;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x=h[i];\n\t\tsum[x]=B[x];\n\t\tfor (int t:g[x]) sum[x]+=sum[t];\n\t\tf[x]=sum[x]+A[x];\n\t\tfor (int t:g[x]) f[x]=min(f[x],max(f[t],(ll)A[x])+sum[x]-sum[t]);\n\t}\n\tprintf(\"%lld\\n\",f[h[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nll A[101010],B[101010];\npair<ll,int> C[101010];\nvector<int> E[101010];\nll BS[101010];\nll Q[101010];\nint did[101010];\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<500000> uf;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]={max(A[i]-B[i],0LL),i};\n\t\tBS[i]=B[i];\n\t}\n\tFOR(i,M) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tsort(C,C+N);\n\tFOR(i,N) {\n\t\tx=C[i].second;\n\t\tdid[x]=1;\n\t\tvector<int> V;\n\t\tFORR(e,E[x]) if(did[e]==1) V.push_back(uf[e]);\n\t\tsort(ALL(V));\n\t\tV.erase(unique(ALL(V)),V.end());\n\t\t\n\t\tif(V.empty()) {\n\t\t\tQ[x]=max(A[x],B[x]);\n\t\t}\n\t\telse {\n\t\t\tvector<ll> BSV;\n\t\t\tll BSS=BS[x];\n\t\t\tQ[x]=1LL<<60;\n\t\t\tFORR(e,V) BSS+=BS[e];\n\t\t\tFORR(e,V) Q[x]=min(Q[x],max(Q[e],C[i].first)+BSS-BS[e]);\n\t\t\t\n\t\t\tFORR(e,V) {\n\t\t\t\tBS[e]=BS[x]=BS[x]+BS[e];\n\t\t\t\tQ[e]=Q[x];\n\t\t\t\tuf(e,x);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<Q[uf[0]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nconst int N = 1e5 + 5;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f; \nusing namespace std;\n\nint n, m, a[N], b[N], id[N], pa[N], vis[N];\nll f[N], sum[N]; \nvector<int> g[N], son; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint getf(int x) { return pa[x] == x ? x : pa[x] = getf(pa[x]); }\n\nbool cmp(int x, int y) { return a[x] < a[y]; }\n\nint main()\n{\n\tn = read <int> (), m = read <int> ();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\ta[i] = read <int> (), b[i] = read <int> ();\n\t\ta[i] = max(a[i] - b[i], 0), id[i] = pa[i] = i; \n\t}\n\tsort(id + 1, id + n + 1, cmp);\n\tfor(int u, v, i = 1; i <= m; i++)\n\t\tu = read <int> (), v = read <int> (), g[u].push_back(v), g[v].push_back(u);\n\tfor(int u, i = 1; i <= n; i++)\n\t{\n\t\tson.clear(), u = id[i];\n\t\tvis[u] = 1, sum[u] = b[u];\n\t\tfor(int v, j = 0; j < g[u].size(); j++)\n\t\t{\n\t\t\tv = g[u][j]; if(!vis[v] || getf(v) == getf(u)) continue;\n\t\t\tsum[u] += sum[getf(v)], son.push_back(getf(v)), pa[getf(v)] = getf(u); \n\t\t}\n\t\tif(!son.size()) { f[u] = a[u] + b[u]; continue; }\n\t\tf[u] = INF; \n\t\tfor(int v, j = 0; j < son.size(); j++)\n\t\t\tv = son[j], f[u] = min(f[u], sum[u] - sum[v] + max(1ll * a[u], f[v])); \n\t}\n\tprintf(\"%lld\\n\", f[id[n]]); \n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,A[MN],B[MN],id[MN],par[MN];\nll f[MN],sz[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(int x,int y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&C[y]<=C[x]) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%d\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include\t<iostream>\n#include\t<vector>\n#include\t<sstream>\n#include\t<iomanip>\n#include\t<algorithm>\n\nusing namespace std;\n\n#define\tMaxN 100000\n\nlong\tA[ MaxN ];\nlong\tB[ MaxN ];\nlong\tC[ MaxN ];\nint\t\tP[ MaxN ];\nlong\tF[ MaxN ];\nlong\tS[ MaxN ];\n\nint\nGet( int x ) {\n    return ( x == P[ x ] ) ? x : P[ x ] = Get( P[ x ] );\n}\n\nvoid\nMain() {\n\tint\tN;\tcin >> N;\n\tint\tM;\tcin >> M;\n\n\tint\twSortedIndex[ MaxN ];\n\tfor ( auto i = 0; i < N; i++ ) {\n        cin >> A[ i ] >> B[ i ];\n        C[ i ] = max( A[ i ] - B[ i ], long( 0 ) );\n        wSortedIndex[ i ] = i;\n        P[ i ] = i;\n        S[ i ] = B[ i ];\n        F[ i ] = C[ i ];\n    }\n    auto\twRoot = distance( C, max_element( C, C+ N ) );\n\n\tvector< int >\twEdges[ N ];\n\tfor ( auto i = 0; i < M; i++ ) {\n\t\tint\twU;\tcin >> wU;\twU--;\n\t\tint\twV;\tcin >> wV;\twV--;\n\t\twEdges[ wU ].emplace_back( wV );\n\t\twEdges[ wV ].emplace_back( wU );\n\t}\n\t\n    sort( wSortedIndex, wSortedIndex + N, []( int l, int r ) { return C[ l ] < C[ r ]; } );\n\t\n\tvector< bool >\twVisited( N, false );\n\n    for ( auto i = 0; i < N; i++ ) {\n        int u = wSortedIndex[ i ];\n        wVisited[ u ] = true;\n        for ( auto v : wEdges[ u ] ) {\n        \tif ( wVisited[ v ] ) {\n\t\t\t\tint x = Get( u );\n\t\t\t\tint\ty = Get( v );\n\t\t\t\tif ( x == y ) continue;\n\t\t\t\tP[ y ] = x; S[ x ] += S[ y ];\n\t\t\t\tF[ x ] = min( F[ x ], max( C[ u ] - S[ y ], F[ y ] ) );\n            }\n        }\n    }\n    cout << F[ wRoot ] + S[ wRoot ] << endl;\n}\n\nint\nmain() {\n\tMain();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    bool operator< (const Info &t) const {return cost < t.cost;}\n};\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nvoid unlock(int x) ;\nvoid merge(int x , int y) ;\n\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) unlock(y);\n            else {\n                out[p].insert(y);\n                modifycost(y , (int)max(limit[y] - money[p] , 0LL));                \n            }\n        }\n    }\n}\n\n\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n    while(out[y].size()) {\n        x = *out[y].begin();\n        if(find(x) == y) {\n            out[y].erase(*out[y].begin());\n            continue;\n        }\n        if(money[y] + init >= limit[x]) {\n            out[y].erase(*out[y].begin());\n            unlock(x);\n            y = find(y);\n            continue;\n        }\n        modifycost(x , (int)max(limit[x] - money[y] , 0LL));\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}\n/*\n9 10\n131 2\n98 79\n242 32\n231 38\n382 82\n224 22\n140 88\n209 70\n164 64\n6 8\n1 6\n1 4\n1 3\n4 7\n4 9\n3 7\n3 9\n5 9\n2 5\n\n582\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,u,v,a[100005],b[100005],c[100005],s[100005],d[100005];\nlong long x[100005][301],y[100005][301],f[100005],sr[100005];\nbool bo[100005];\ninline long long read()\n{\n    long long sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(long long x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(long long x,long long y)\n{\n\treturn c[x]<c[y];\n}\ninline long long find(long long x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(long long u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register long long i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u][++x[u][0]]=v;\n\t\tx[v][++x[v][0]]=u;\n\t}\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\tlong long u=d[i];\n\t\tfor (register long long j=1;j<=x[u][0];++j)\n\t\t{\n\t\t\tlong long v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u][++y[u][0]]=vv;\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || cp[i].first <= a[v] - b[v])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nint a[maxn],b[maxn],c[maxn];\nint par[maxn];\nvector<int> init_g[maxn],g[maxn];\ninline void init(int n){\n\tfor(int i=1;i<=n;i++)\n\t\tpar[i]=i;\n}\nint find(int x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\nll sum[maxn],dp[maxn];\nbool vis[maxn];\nint ord[maxn];\ninline bool cmp(const int& lhs,const int& rhs){\n\treturn c[lhs]<c[rhs];\n}\nvoid dfs(int u){\n\tsum[u]=b[u];\n\tfor(int i=0;i<(int)g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tdfs(v);\n\t\tsum[u]+=sum[v];\n\t}\n\tdp[u]=sum[u]+c[u];\n\tfor(int i=0;i<(int)g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max((ll)c[u],dp[v]));\n\t}\n}\nint main(){\n\tint n,m,u,v;\n\tscanf(\"%d%d\",&n,&m);\n\tinit(n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tc[i]=max(a[i]-b[i],0);\n\t\tord[i]=i;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tinit_g[u].push_back(v);\n\t\tinit_g[v].push_back(u);\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=ord[i];\n\t\tvis[u]=true;\n\t\tfor(int j=0;j<(int)init_g[u].size();j++){\n\t\t\tint v=init_g[u][j];\n\t\t\tif(vis[v]){\n\t\t\t\tv=find(v);\n\t\t\t\tif(u!=v){\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tpar[v]=u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(ord[n]);\n\tprintf(\"%lld\\n\",dp[ord[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m,ql,qr;\nint a[maxn],b[maxn],que[maxn],ord[maxn];\nbool ok[maxn];\nvector<int>edge[maxn],vec[maxn];\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nnamespace Dsu{\n\tint f[maxn];\n\tll v[maxn]; \n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\tv[i]=b[i];\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t}\n}\n\nbool check(ll val){\n\tREP(i,n)vec[i].clear(),ok[i]=false;\n\tql=1;qr=0;\n\tDsu::init();\n\tREP(i,n){\n\t\tint x=ord[i];\n\t\tif(val+b[x]>=a[x])ok[x]=true;\n\t\trep(j,int(edge[x].size())){\n\t\t\tint y=edge[x][j];\n\t\t\tll now=Dsu::v[Dsu::find(y)]+val;\n\t\t\tif(ok[y]&&now+b[x]>=a[x]){\n\t\t\t\tok[x]=true;\n\t\t\t\tint orix=Dsu::find(x),oriy=Dsu::find(y);\n\t\t\t\tDsu::merge(x,y);\n\t\t\t\trep(k,int(vec[orix].size())){\n\t\t\t\t\tll cur=Dsu::v[Dsu::find(x)]+val;\n\t\t\t\t\tassert(cur+b[vec[orix][k]]>=a[vec[orix][k]]);\n\t\t\t\t\tDsu::merge(vec[orix][k],x);\n\t\t\t\t\tok[vec[orix][k]]=true;\n\t\t\t\t}\n\t\t\t\trep(k,int(vec[oriy].size())){\n\t\t\t\t\tll cur=Dsu::v[Dsu::find(y)]+val;\n\t\t\t\t\tassert(cur+b[vec[oriy][k]]>=a[vec[oriy][k]]);\n\t\t\t\t\tDsu::merge(vec[oriy][k],y);\n\t\t\t\t\tok[vec[oriy][k]]=true;\n\t\t\t\t}\n\t\t\t\tvec[orix].clear();\n\t\t\t\tvec[oriy].clear();\n\t\t\t}\n\t\t\telse vec[Dsu::find(y)].pb(x);\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e15);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\nstruct uf{\n  static const int MAXN=100005;\n  int par[MAXN];\n  int size[MAXN];\n  void init(int n,int* ar){\n    memset(par,-1,sizeof(par));\n    REP(i,n) size[i]=ar[i];\n  }\n  int root(int a){\n    if(par[a]==-1) return a;\n    return par[a]=root(par[a]);\n  }\n  void unite(int a,int b){\n    a=root(a);b=root(b);\n    if(a==b) return;\n\n    par[b]=a;\n    size[a]+=size[b];\n  }\n  bool same(int a,int b){\n    return root(a)==root(b);\n  }\n};\n\nuf u;\n\nconst lint INF=1e18;\nint n,m;\nint A[100005],B[100005];\nvector<int> g[100005];\n\n\nvoid ijk(int V,lint L){\n  priority_queue<pair<pi,int>,vector<pair<pi,int> >,greater<pair<pi,int> > >pq;\n  pq.push({{A[V],V},-1});\n  while(!pq.empty()){\n    pair<pi,int> cur=pq.top();pq.pop();\n    int v=cur.fr.sc,w=cur.fr.fr;\n    int p=cur.sc;\n    if(w>L){\n      break;\n    }\n    if(u.same(v,p)) continue;\n    L+=u.size[u.root(v)];\n    if(~p){\n      u.unite(v,p);\n    }\n    for(auto to:g[v]){\n      pq.push({{A[to],to},v});\n    }\n  }\n}\nbool check(lint L){\n  u.init(n,B);\n  REP(i,n) if(u.root(i)==i && u.size[i]==B[i] && A[i]<=L){\n    ijk(i,L);\n  }\n\n  REP(i,n) if(!u.same(i,0)) return false;\n  return true;\n}\nint main(){\n  cin>>n>>m;\n  REP(i,n){\n    scanf(\"%d%d\",&A[i],&B[i]);\n    A[i]=max(0,A[i]-B[i]);\n  }\n  REP(i,m){\n    int a,b;scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n\n  lint lb=-1,ub=1e15;\n  while(ub-lb>1){\n    lint md=(lb+ub)>>1;\n    if(check(md)) ub=md;\n    else lb=md;\n  }\n\n  lint res=ub+accumulate(B,B+n,0ll);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define root ____root\nusing namespace std;\nconst int N=100005;\nstruct Gragh{\n\tint cnt,y[N],z[N],nxt[N],fst[N];\n\tvoid clear(){\n\t\tcnt=0;\n\t\tmemset(fst,0,sizeof fst);\n\t}\n\tvoid add(int a,int b,int c){\n\t\ty[++cnt]=b,z[cnt]=c,nxt[cnt]=fst[a],fst[a]=cnt;\n\t}\n}g;\nint n,m,A[N],B[N];\nint fa[N],need[N],cost[N];\nvector <int> son[N];\nstruct Edge{\n\tint x,y,z;\n}e[N];\nbool cmp(Edge a,Edge b){\n\treturn a.z<b.z;\n}\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nbool cmp2(int a,int b){\n\treturn need[a]>need[b];\n}\nvoid dfs(int x,int pre){\n\tson[x].clear();\n\tfor (int i=g.fst[x];i;i=g.nxt[i])\n\t\tif (g.y[i]!=pre){\n\t\t\tson[x].push_back(g.y[i]);\n\t\t\tdfs(g.y[i],x);\n\t\t}\n\tsort(son[x].begin(),son[x].end(),cmp2);\n\tneed[x]=cost[x]=0;\n\tfor (int i=0;i<son[x].size();i++){\n\t\tint y=son[x][i];\n\t\tneed[x]=max(need[x],cost[x]+need[y]);\n\t\tcost[x]+=cost[y];\n\t}\n\tneed[x]=max(need[x],cost[x]+A[x]);\n\tcost[x]+=B[x];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i],B[i]);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].z=max(A[e[i].x],A[e[i].y]);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tg.clear();\n\tfor (int i=1,j=1;i<=m&&j<n;i++){\n\t\tint x=getf(e[i].x),y=getf(e[i].y);\n\t\tif (x==y)\n\t\t\tcontinue;\n\t\tg.add(e[i].x,e[i].y,e[i].z);\n\t\tg.add(e[i].y,e[i].x,e[i].z);\n\t\tfa[x]=y;\n\t}\n\tint root=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (A[i]<A[root])\n\t\t\troot=i;\n\tdfs(root,0);\n\tprintf(\"%d\",need[root]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\nll a[ten(5)], b[ten(5)];\nvector<int> e[ten(5)];\n\nclass UnionFind {\nprivate:\n\tint n;\n\tvector<int> a;\npublic:\n\tUnionFind(int n) : n(n), a(n, -1) {}\n\tint find(int x) { return a[x] < 0 ? x : (a[x] = find(a[x])); }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tbool same(Pii& p) { return same(p.first, p.second); }\n\tbool unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return false;\n\t\tif (a[x] > a[y]) swap(x, y);\n\t\ta[x] += a[y];\n\t\ta[y] = x;\n\t\tn--;\n\t\treturn true;\n\t}\n\tbool unite(Pii& p) { return unite(p.first, p.second); }\n\tint size() const { return n; }\n\tint size(int x) { return -a[find(x)]; }\n};\n\nstruct P {\n\tll val;\n\tint v;\n\tP() {}\n\tP(ll val, int v) : val(val), v(v) {}\n\n\tbool operator>(const P& r) {\n\t\treturn val > r.val;\n\t}\n};\n\nstruct Heap {\n\tHeap *l, *r;\n\tP val;\n};\n\nint __heap_pt = 0;\n\nHeap* heapAlloc(P val) {\n\tstatic Heap buf[ten(6) * 3];\n\n\tauto& ret = buf[__heap_pt++];\n\tret.l = ret.r = nullptr;\n\tret.val = val;\n\treturn &ret;\n}\n\nvoid clearHeap() {\n\t__heap_pt = 0;\n}\n\nHeap *meld(Heap *a, Heap *b) {\n\tif (!a) return (b);\n\tif (!b) return (a);\n\n\tif (a->val > b->val) swap(a, b);\n\ta->r = meld(a->r, b);\n\tswap(a->l, a->r);\n\n\treturn (a);\n}\n\nvoid pop(Heap*& root) {\n\troot = meld(root->r, root->l);\n}\n\nHeap* nodes[ten(5)];\nll curB[ten(5)];\n\nbool solve(ll sval, int n) {\n\tclearHeap();\n\tmemset(curB, 0, sizeof(curB));\n\tFOR(i, n) {\n\t\tnodes[i] = nullptr;\n\t\tfor (auto to : e[i]) {\n\t\t\tnodes[i] = meld(nodes[i], heapAlloc(P(a[to], to)));\n\t\t}\n\t\tcurB[i] = b[i];\n\t}\n\n\tUnionFind uf(n);\n\tFOR(i, n) {\n\t\tif (uf.size(i) != 1) continue;\n\t\tif (a[i] - sval > 0) continue;\n\n\t\twhile (true) {\n\t\t\tauto& curHeap = nodes[uf.find(i)];\n\t\t\tif (!curHeap) break;\n\n\t\t\tauto& bval = curB[uf.find(i)];\n\n\t\t\tP val = curHeap->val;\n\t\t\tif (uf.same(i, val.v)) {\n\t\t\t\tpop(curHeap);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (val.val - sval > bval) break;\n\t\t\tpop(curHeap);\n\t\t\t\n\t\t\tint vpar = uf.find(val.v);\n\t\t\tcurHeap = meld(curHeap, nodes[vpar]);\n\t\t\tbval += curB[vpar];\n\n\t\t\tuf.unite(i, val.v);\n\t\t\tint nid = uf.find(i);\n\t\t\tnodes[nid] = curHeap;\n\t\t\tcurB[nid] = bval;\n\t\t}\n\t}\n\n\tbool ok = uf.size() == 1;\n\treturn ok;\n}\n\nint main() {\n\tint n, m; reader(n, m);\n\tFOR(i, n) {\n\t\treader(a[i], b[i]);\n\t\ta[i] -= b[i];\n\t}\n\tFOR(i, m) {\n\t\tint x, y; reader(x, y);\n\t\tx--; y--;\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\n\t// bool cur = solve(0, n);\n\n\tll l = -1, r = ten(9) + 1;\n\twhile (r - l != 1) {\n\t\tll md = (l + r) / 2;\n\t\tbool ok = solve(md, n);\n\t\tif (ok) r = md;\n\t\telse l = md;\n\t}\n\tll ans = r;\n\tFOR(i, n) ans += b[i];\n\twriterLn(ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005;\nconst LL INF=1e18;\nint n,m,rt;\nLL a[N],b[N],c[N];\nvector <int> son[N];\nnamespace Build_Tree{\n\tvector <int> e[N];\n\tint id[N];\n\tbool cmp(int x,int y){\n\t\treturn c[x]<c[y];\n\t}\n\tint fa[N],vis[N];\n\tint getf(int x){\n\t\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n\t}\n\tvoid main(){\n\t\tFor(i,1,m){\n\t\t\tint x=read(),y=read();\n\t\t\te[x].pb(y),e[y].pb(x);\n\t\t}\n\t\tFor(i,1,n)\n\t\t\tid[i]=fa[i]=i;\n\t\tsort(id+1,id+n+1,cmp);\n\t\tFor(i,1,n){\n\t\t\tint x=id[i];\n\t\t\tfor (auto y : e[x])\n\t\t\t\tif (vis[y]&&getf(y)!=x){\n\t\t\t\t\tson[x].pb(getf(y));\n\t\t\t\t\tfa[getf(y)]=x;\n\t\t\t\t}\n\t\t\tvis[x]=1;\n\t\t}\n\t\trt=id[n];\n\t}\n}\nLL sb=0;\nLL size[N];\nLL dfs(int x){\n\tsize[x]=b[x];\n\tif (son[x].empty())\n\t\treturn sb+c[x];\n\tLL res=INF;\n\tfor (auto y : son[x]){\n\t\tLL tmp=dfs(y);\n\t\tres=min(res,max(c[x]+sb-size[y],tmp));\n\t\tsize[x]+=size[y];\n\t}\n\treturn res;\n}\nint main(){\n\tn=read(),m=read();\n\tFor(i,1,n)\n\t\ta[i]=read(),b[i]=read(),c[i]=max(a[i]-b[i],0LL),sb+=b[i];\n\tBuild_Tree::main();\n\tcout<<dfs(rt)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\n//const u32 P=;\n//inline u32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\n//inline u32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\n//inline u32 sum(u32 a, u32 b) {return (a+=b)<P?a:a-P;}\n//inline u32 dif(u32 a, u32 b) {return (a-=b)&0x80000000?a+P:a;}\n//u64 power(u64 a, int b) {\n//\tu64 ans=1;\n//\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n//\treturn ans;\n//}\nconst int N=1e5+5;\nint n, m, a[N], b[N], *order[N], pa[N];\ns64 f[N], s[N];\nstd::vector<int> edge[N], child[N];\nint find(int x) {return pa[x]==x?x:(pa[x]=find(pa[x]));}\nvoid dp(int x) {\n\tf[x]=a[x];\n\ts[x]=b[x];\n\tfor(int y: child[x]) {\n\t\tdp(y);\n\t\tcmin(f[x], std::max(0ll+a[x], f[y])-s[y]);\n\t\ts[x]+=s[y];\n\t}\n\tf[x]+=s[x];\n}\nint main() {\n\tn=rd(), m=rd();\n\tfor(int i=1; i<=n; ++i) {\n\t\ta[i]=rd(), b[i]=rd();\n\t\tcmax(a[i]-=b[i], 0);\n\t\torder[i-1]=a+i;\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tint u=rd(), v=rd();\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tstd::sort(order, order+n, [](int *a, int *b) {return *a<*b;});\n\tfor(int i=0; i<n; ++i) {\n\t\tint x=order[i]-a;\n\t\tpa[x]=x;\n\t\tfor(int y: edge[x]) if(pa[y]) {\n\t\t\tint z=find(y);\n\t\t\tif(x!=z) {\n\t\t\t\tpa[z]=x;\n\t\t\t\tchild[x].push_back(z);\n\t\t\t}\n\t\t}\n\t}\n\tint r=order[n-1]-a;\n\tdp(r);\n\tprintf(\"%lld\\n\", f[r]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath> \n#include<algorithm>\n#define ll long long \nusing namespace std;\nconst int maxn=500010, inf=1e9;\nstruct edge{int too, pre;}e[maxn];\nint n, m, x, y, tot;\nint fa[maxn], a[maxn], b[maxn], last[maxn], pos[maxn];\nll ad[maxn], sum[maxn];\nbool v[maxn];\n\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f=1; k=0; char c=getchar();\n\twhile(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();\n\twhile(c<='9' && c>='0') k=k*10+c-'0', c=getchar();\n\tk*=f;\n}\n\ninline void add(int x, int y){e[++tot]=(edge){y, last[x]}; last[x]=tot;}\n\ninline bool cmp(int x, int y){return a[x]<a[y];}\n\nint gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);} \n\nint main()\n{\n\tread(n); read(m);\n\tfor(int i=1;i<=n;i++) read(a[i]), read(b[i]), a[i]=max(a[i]-b[i], 0);\n\tfor(int i=1;i<=m;i++) read(x), read(y), add(x, y), add(y, x);\n\tfor(int i=1;i<=n;i++) pos[i]=i, fa[i]=i, ad[i]=a[i], sum[i]=b[i];\n\tsort(pos+1, pos+1+n, cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=pos[i]; v[x]=1;\n\t\tfor(int j=last[x], too;j;j=e[j].pre)\n\t\tif(v[too=e[j].too])\n\t\t{\n\t\t\tint fx=gf(x), fy=gf(too);\n\t\t\tif(fx==fy) continue;\n\t\t\tsum[fx]+=sum[fy]; fa[fy]=fx;\n\t\t\tad[fx]=min(ad[fx], ad[fy]+max(0ll, a[x]-ad[fy]-sum[fy]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum[pos[n]]+ad[pos[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma G++ optimize(2)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define LL long long\n#define O4 __inline__ __attribute__((always_inline))\n#define inf 0x7fffffff\n#define UL unsigned LL\n#define LD long double\n#ifdef ONLINE_JUDGE\n#define getchar nc\n#endif\n//#define int LL\nnamespace FastIO{\n\tO4 char nc(){\n\t\tstatic char buf[100000],*p1=buf,*p2=buf;\n\t\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n\t}\n\tO4 int read(){\n\t\tchar t;int u=0,k=1;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\treturn u*k;\n\t}\n\ttemplate <typename T>\n\tO4 void read(T &u){\n\t\tchar t;T k=1;u=0;t=getchar();\n\t\twhile(t<'0'||t>'9'){if(t=='-')k=-1;t=getchar();}\n\t\twhile(t>='0'&&t<='9'){u=u*10+t-'0';t=getchar();}\n\t\tif(t=='.'){\n\t\t\tT mass=0.1;t=getchar();\n\t\t\twhile(t>='0'&&t<='9'){u+=mass*(t-'0');mass/=10;t=getchar();}\n\t\t}u*=k;\n\t}\n\tO4 int read(char asd[]){\n\t\tchar t=getchar();int u=0;\n\t\twhile(t==' '||t=='\\n'||t=='\\r')t=getchar();\n\t\tif(t==EOF)return -1;\n\t\twhile(t!=' '&&t!='\\n'&&t!=EOF&&t!='\\r')asd[u++]=t,t=getchar();\n\t\tasd[u]='\\0';return u;\n\t}\n\tchar sr[1<<23],z[23];int C=-1,Z;\n\tO4 void wer(int x,char T){\n\t\tint y=0;if(x<0)y=1,x=-x;\n\t\twhile(z[++Z]=x%10+'0',x/=10);if(y)z[++Z]='-';\n\t\twhile(sr[++C]=z[Z],--Z);sr[++C]=T;\n\t}\n\tO4 void wer(char T[],char QWQ){\n\t\tfor(int i=0;T[i]!='\\0';i++)sr[++C]=T[i];\n\t\tsr[++C]=QWQ;\n\t}\n\tO4 void wer(char T){sr[++C]=T;}\n\tO4 void out(){fwrite(sr,1,C+1,stdout);C=-1;}\n}\nusing namespace std;\nusing namespace FastIO;\nconst int N=1e5+5;\nint n,m;\nint val[N],sum[N],A[N],B[N],fa[N],id[N],F[N];\nbool vis[N];\nvector <int> Map[N];\nint get_fa(int x){return fa[x]==x?x:fa[x]=get_fa(fa[x]);}\nsigned main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=read();B[i]=read();\n\t\tA[i]=max(A[i]-B[i],0);\n\t\tfa[i]=id[i]=i;\n\t}\n\twhile(m--){\n\t\tint a=read(),b=read();\n\t\tMap[a].push_back(b);\n\t\tMap[b].push_back(a);\n\t}\n\tsort(id+1,id+1+n,[](int a,int b){return A[a]<A[b];});\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];sum[x]=B[x];\n\t\tvector <int> load;vis[x]=1;\n\t\tfor(int to:Map[x]){\n\t\t\tif(!vis[to])continue;\n\t\t\tint a=get_fa(x),b=get_fa(to);\n\t\t\tif(a==b)continue;\n\t\t\tload.push_back(b);\n\t\t\tsum[x]+=sum[b];fa[b]=a;\n\t\t}\n\t\tF[x]=sum[x]+A[x];\n\t\tfor(int to:load)F[x]=min(F[x],sum[x]-sum[to]+max(F[to],A[x]));\n\t}\n\tcout<<F[id[n]];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m,a[100010],b[100010],id[100010],fa[100010],bel[100010],x,y,d[100010],p[100010],q[100010],l,r;\nlong long sum[100010],f[100010],ans;\nvector<int> v[100010];\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid Addedge(int x,int y) {v[x].push_back(y),v[y].push_back(x);}\n\nint main()\n{\n\tsrand(12019687);\n\tscanf(\"%d%d\",&n,&m),ans=1000000000000000000ll;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tif (n==1) return printf(\"%d\\n\",max(a[1],b[1])),0;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tsort(id+1,id+1+n,cmp);\n\tfor (int qaq=1; qaq<=130; qaq++)\n\t{\n\t\tfor (int l=1,r; l<=n; l++)\n\t\t{\n\t\t\tr=l;\n\t\t\twhile (r<n&&a[id[r+1]]==a[id[l]]) r++;\n\t\t\trandom_shuffle(id+l,id+r+1),l=r;\n\t\t}\n\t\tfor (int i=1; i<=n; i++) p[id[i]]=i,d[i]=0;\n\t\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tx=id[i];\n\t\t\tfor (int j:v[x])\n\t\t\t\tif (p[j]<i&&(y=ask(j))!=x) fa[y]=x,bel[y]=x;\n\t\t}\n\t\tl=1,r=0;\n\t\tfor (int i=1; i<=n; i++) if (fa[i]) d[i]++,d[fa[i]]++;\n\t\tfor (int i=1; i<=n; i++) if (d[i]==1&&fa[i]) q[++r]=i;\n\t\twhile (l<=r)\n\t\t{\n\t\t\tx=q[l++];\n\t\t\tif (fa[x]&&(--d[fa[x]])==(fa[x]!=id[n])) q[++r]=fa[x];\n\t\t}\n\t\tsum[0]=0;\n\t\tfor (int i=1; i<=n; i++) f[i]=1000000000000000000ll,sum[i]=b[i];\n\t\tfor (int i=1; i<=r; i++) \n\t\t{\n\t\t\tx=q[i];\n\t\t\tf[x]=min(sum[x]-b[x]+f[x],sum[x]-b[x]+max(a[x],b[x]));\n\t\t\tf[fa[x]]=min(f[fa[x]],max(1ll*a[fa[x]],b[fa[x]]+f[x])-sum[x]);\n\t\t\tsum[fa[x]]+=sum[x];\n\t\t}\n\t\tans=min(ans,f[id[n]]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int & \n#define SZ(a) ((int)(a.size()))\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n\tfor (T x : a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\nconst int N = 1e5 + 9;\nconst ll oo = 1e15;\nint parent[N];\nint is_free[N];\nll bsum[N];\nvi g[N];\nint n, m;\nll a[N], b[N];\n\nset<int> inside[N];\nset<pair<ll, int>> neibs[N];\nll gw, gb;\nset<pair<ll, int>> fre;\nint counter = 0;\n\nvoid make_set(int v) {\n\t++counter;\n\tinside[v].insert(v);\n\tparent[v] = v;\n\tbsum[v] = b[v];\n\tfor (int to : g[v])\n\t\tneibs[v].insert(mp(a[to] - b[to], to));\n}\n\nint find_set(int v) {\n\tif (parent[v] == v) return v;\n\treturn parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int u, int v) {\n\tu = find_set(u);\n\tv = find_set(v);\n\tif (u == v) return;\n\t--counter;\n\tis_free[v] = 1;\n\tif (SZ(inside[u]) < SZ(inside[v]))\n\t\tswap(v, u);\n\tinside[u].insert(ALL(inside[v]));\n\tbsum[u] += bsum[v];\n\tparent[v] = u;\n\tneibs[u].insert(ALL(neibs[v]));\n}\n\nvoid add_to_free(int u) {\n\twhile (!neibs[u].empty()) {\n\t\tbool ok = 0;\n\t\tif (inside[u].count((*neibs[u].begin()).second)) {\n\t\t\tok = 1;\n\t\t\tneibs[u].erase(neibs[u].begin());\n\t\t}\n\t\tif (!ok) break;\n\t}\n\tif (neibs[u].empty()) {\n\t\tassert(counter == 1);\n\t\treturn;\n\t}\n\tint superv = (*neibs[u].begin()).second;\n\tfre.insert(mp(a[superv] - b[superv] - bsum[u], u));\n}\n\nvoid add_to_cool(int v) {\n\tv = find_set(v);\n\tis_free[v] = 1;\n\twhile (!neibs[v].empty() && (*neibs[v].begin()).first + gb - bsum[v] <= gw) {\n\t\tint u = (*neibs[v].begin()).second;\n\t\tneibs[v].erase(neibs[v].begin());\n\t\tunion_sets(v, u);\n\t\tv = find_set(v);\n\t}\n\tadd_to_free(v);\n}\n\n\n\nll solve() {\n\tif (n == 1) {\n\t\treturn a[1];\n\t}\n\tgb = accumulate(b + 1, b + n + 1, 0LL);\n\tfori(i, n) {\n\t\tmake_set(i + 1);\n\t\tfre.insert(mp(a[i + 1] - b[i + 1], i + 1));\n\t}\n\twhile (counter > 1) {\n\t\tll minim = (*fre.begin()).first;\n\t\t// minim + gb <= gw\n\t\t//watch(minim);\n\t\tgw = minim + gb;\n\t\twhile (!fre.empty() && (*fre.begin()).first + gb == gw) {\n\t\t\tint v = find_set((*fre.begin()).second);\n\t\t\tfre.erase(fre.begin());\n\t\t\tadd_to_cool(v);\n\t\t}\n\t}\n\treturn gw;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tmmax(a[i], b[i]);\n\t}\n\tfori(iter, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\tcout << solve() << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define PII pair<int, int>\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\nusing namespace std;\ntemplate<typename T> inline void gmax(T &x, T y){x = x > y ? x : y;}\ntemplate<typename T> inline void gmin(T &x, T y){x = x < y ? x : y;}\nconst int MAXN = 100010;\nint n, m;\nLL a[MAXN], b[MAXN], v[MAXN];\nint id[MAXN];\nvector<int> G[MAXN];\ninline bool cmp(const int &a, const int &b){return v[a] < v[b];}\nint f[MAXN], dp[MAXN];\ninline int find(int x){return f[x] == x ? f[x] : f[x] = find(f[x]);}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld%lld\", &a[i], &b[i]), v[i] = max(a[i] - b[i], 0LL), id[i] = i;\n\tsort(id + 1, id + n + 1, cmp);\n\tfor(int i = 1; i <= m; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].PB(y);\n\t\tG[y].PB(x);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tint x = id[i];\n\t\tf[x] = x;\n\t\tLL tmp = v[x];\n\t\tfor(auto y : G[x]) if(f[y] && (y = find(y)) != x){\n\t\t\tf[y] = x;\n\t\t\tb[x] += b[y];\n\t\t\tgmin(v[x], max(v[y], tmp) - b[y]); \n\t\t}\n\t\tv[x] += b[x];\n\t}\n\tprintf(\"%lld\\n\", v[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    vector <pii> ras;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n        ras.pb({a[i]-b[i],i});\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    sort(ras.begin(),ras.end());\n    ll l=-1,r=(ll)1e15;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        //cout << mid << endl;\n        for (int i=1;i<=n;i++){\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],rk[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(const int&x,const int&y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)rk[id[i]]=i;\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&rk[y]<rk[x]) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define int long long\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n, m, A[N], B[N], C[N], par[N], sm[N], ans[N], sz[N];\nvector<pii> E;\n\nint getpar(int v){\n\treturn (par[v] == v?v:par[v]=getpar(par[v]));\n}\n\nbool cmp(pii x, pii y){\n\treturn (max(C[x.F], C[x.S]) < max(C[y.F], C[y.S]));\n}\n\nvoid merge(int v, int u){\n//\tcout << v << ' ' << u << '\\n';\n\tint vv = v, uu = u;\n\tv = getpar(v), u = getpar(u);\n//\tcout << v << ' ' << u << '\\n';\n\tif (u == v) return;\n//\tcout << vv << ' ' << uu << '\\n';\n//\tcout << v << ' ' << u << ' ' << ans[v] << ' ' << ans[u] << ' ' << sm[v] << ' ' << sm[u] << ' ' << C[vv] << ' ' << C[uu] << '\\n';\n\tif (sz[v] < sz[u]) swap(v, u), swap(vv, uu);\n\tans[v] = min(max(ans[v], max(0ll, C[uu] - sm[v])), max(ans[u], max(0ll, C[vv] - sm[u])));\n\tpar[u] = v;\n//\tcout << ans[v] << '\\n';\n\tsz[v] += sz[u];\n\tsm[v] += sm[u];\n}\n\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> A[i] >> B[i];\n\t\tC[i] = max(0ll, A[i] - B[i]);\n//\t\tcout << \"YES \" << i << ' ' << C[i] << '\\n';\n\t}\n\tfor (int i = 1; i <= m; i++){\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tE.pb({v, u});\n\t}\n//\tcout << \"YES\\n\";\n\tsort(all(E), cmp);\n\tfor (int i = 1; i <= n; i++) par[i] = i, sz[i] = 1, sm[i] = B[i], ans[i] = C[i];\n//\tfor (int i = 1; i <= n; i++) cout<<\"Fuck \" << ans[i] << '\\n';\n\tfor (auto u:E){\n\t\tmerge(u.F, u.S);\n\t}\t\n\tcout << ans[getpar(1)] + sm[getpar(1)];\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\n\tvector<int> par, ran;\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tu = trans[u], v = trans[v];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i] + csum);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = max(a[i],mi);\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<P, Int> T;\nInt n, k, v,m;\nInt a[216000];\nInt b[216000];\nInt c[216000];\nInt u[216000];\nInt us[216000];\nInt vs[216000];\nInt sum[216000];\nInt res = 1LL << 40;\nvector<P> edges;\nvector<int> child[108000];\nint init(){\n\tfor(int i = 0;i < 216000;i++)u[i] = i;\n}\n\nint r(int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nint unite(int x, int y){\n\tx = r(x);\n\ty = r(y);\n\tif(x != y)u[y]= x;\n}\n\nint dp(int x){\n\tsum[x] = b[x];\n\tInt ans = c[x];\n\tfor(int i = 0;i < child[x].size();i++){\n\t\tint to = child[x][i];\n\t\tInt tmp = dp(to);\n\t\tans = min(ans, -sum[to] + max(c[x], tmp));\n\t\tsum[x] += sum[to];\n\t}\n\tans += sum[x];\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tcin >> n >> m;\n\tfor(Int i = 0;i < n;i++){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i], b[i]);\n\t\tc[i] = a[i] - b[i];\n\t}\n\tfor(Int i = 0;i < m;i++){\n\t\tcin >> us[i] >> vs[i];us[i]--,vs[i]--;\n\t\tedges.push_back(P(max(c[us[i]],c[vs[i]]),i));\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(Int i = 0;i < edges.size();i++){\n\t\tInt cost = edges[i].first;\n\t\tInt ind = edges[i].second;\n\t\tInt u = us[ind], v = vs[ind];\n\t\tif(r(u) == r(v))continue;\n\t\tif(c[u] < c[v])swap(u,v);\n\t\tchild[r(u)].push_back(r(v));\n\t\tunite(u, v);\n\t}\n\tcout << dp(r(0)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\ntypedef vector<int> vi;\n#define pb push_back\ntypedef long long ll;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,a[N],b[N],fa[N],id[N];\nll s[N],f[N];\nvi E[N];\nbool vis[N];\n\nint getf(int x) {\n\treturn x==fa[x]?x:fa[x]=getf(fa[x]);\n}\n\nbool cmp(int x,int y) {\n\treturn a[x]<a[y];\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i]=gi(),b[i]=gi();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tid[i]=fa[i]=i;s[i]=b[i];f[i]=a[i]+b[i];\n\t}\n\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++) {\n\t\tint u=id[i];vis[u]=1;\n\t\tfor(auto v:E[u])\n\t\t\tif(vis[v]) {\n\t\t\t\tint x=u,y=getf(v);\n\t\t\t\tif(x!=y) {\n\t\t\t\t\tfa[y]=x;f[x]=min(s[x]+max((ll)a[x],f[y]),s[y]+f[x]);s[x]+=s[y];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tcout<<f[getf(1)];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(1e5)+10;\nint n,m,fa[maxn],d[maxn];\nint a[maxn],b[maxn];\nll f[maxn],g[maxn];\nbool vis[maxn];\nint tot,nxt[maxn*2],head[maxn],to[maxn*2];\nbool cmp(int x,int y) { return a[x]<a[y]; }\nvoid add(int x,int y) {\n\ttot++; nxt[tot]=head[x];\n\thead[x]=tot; to[tot]=y;\n}\nint find(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nvoid merge(int x,int y) {\n\ty=find(y);\n\tif (x==y) return;\n\tfa[y]=x;\n\tg[x]+=g[y];\n\tf[x]=min(f[x],max(f[y],a[x]-g[y]));\n}\nint main() {\n//\tfreopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m);\n\tfor (int i=1;i<=n;i++) {\n\t\tread(a[i]); read(b[i]);\n\t\ta[i]=max(0,a[i]-b[i]);\n\t\tfa[i]=i; d[i]=i;\n\t\tf[i]=a[i]; g[i]=b[i];\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tint x,y;\n\tfor (int i=1;i<=m;i++) {\n\t\tread(x); read(y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tx=d[i];\n\t\tvis[x]=1;\n\t\tfor (int j=head[x];j;j=nxt[j]) {\n\t\t\ty=to[j];\n\t\t\tif (vis[y]) merge(x,y);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[find(1)]+g[find(1)]);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nstruct UnionFind {\n  vector<int> data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return false;\n    if (data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n\n  int find(int k) {\n    if (data[k] < 0) return k;\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return -data[find(k)];\n  }\n};\n\nvoid solve() {\n  int n, m; cin >> n >> m;\n  vl money(n), donate(n);\n  rep(i,n) {\n    cin >> money[i] >> donate[i];\n    chmax(money[i], donate[i]);\n  }\n  Graph<int> g(n);\n  rep(i,m) {\n    int u, v; cin >> u >> v; --u, --v;\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n\n  vi order(n);\n  iota(ALL(order), 0);\n  sort(ALL(order), [&](int a, int b) { return money[a] < money[b]; });\n\n  UnionFind uf(n);\n  vb seen(n, false);\n\n  for (auto &v : order) {\n    seen[v] = true;\n    int x = uf.find(v);\n    vi add;\n\n    for (auto &nv : g[v]) {\n      if (seen[nv]) {\n        int y = uf.find(nv);\n        if (uf.unite(x, y)) add.emplace_back(y);      }\n    }\n\n    ll sum = 0;\n    for (auto &y : add) sum += donate[y];\n\n    ll cost = money[x] + sum;\n    for (auto &y : add) {\n      ll tmp = max(money[x], money[y] + donate[x]) + sum - donate[y];\n      chmin(cost, tmp);\n    }\n\n    sum += donate[x];\n\n    x = uf.find(x);\n    money[x] = cost;\n    donate[x] = sum;\n  }\n\n  cout << money[uf.find(0)] << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i];\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\tW[c] = OVER9000;\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tm = 0;\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n/*\t\tvector<int> P(sz);\n\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\tbool is_ok = false;\n\t\twhile(true) {\n\t\t\tcat w = W[c];\n\t\t\tbool ok = true;\n\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t}\n\t\t\tif(w < B[c]) ok = false;\n\t\t\tw -= B[c];\n\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\tif(ok) is_ok = true;\n\t\t\tw = W[c];\n\t\t\tok = true;\n\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t}\n\t\t\tif(w < B[c]) ok = false;\n\t\t\tif(ok) is_ok = true;\n\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t}\n\t\tassert(is_ok);\n*/\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100'009;\n\nint p[N];\n\nint find(int x) {\n  if (p[x] != x) {\n    p[x] = find(p[x]);\n  }\n  return p[x];\n}\n\nset<pair<int, int>> s[N];\nlong long sum[N];\nbool was[N];\n\nvoid join(int &root, int y) {\n  int py = find(y);\n  if (py == root) {\n    return;\n  }\n  if ((int)s[py].size() > (int)s[root].size()) {\n    swap(root, py);\n  }\n  p[py] = root;\n  sum[root] += sum[py];\n  for (auto &e : s[py]) {\n    if (!was[e.second]) {\n      s[root].insert(e);\n    }\n  }\n}\n\nint n;\nint a[N];\nint b[N];\nint w[N];\nvector<int> g[N];\n\nbool can(int ss) {\n  for (int i = 0; i < n; ++i) {\n    w[i] = max(0, a[i] - ss - b[i]);\n    p[i] = i;\n    was[i] = false;\n    s[i].clear();\n  }\n  for (int i = 0; i < n; ++i) {\n    if (was[i] || w[i] != 0) {\n      continue;\n    }\n    sum[i] = 0;\n    s[i].emplace(w[i], i);\n    int root = i;\n    while (!s[root].empty()) {\n      int x = s[root].begin()->second;\n      if (sum[root] < w[x]) {\n        break;\n      }\n      was[x] = true;\n      s[root].erase(s[root].begin());\n      sum[root] += b[x];\n      for (int y : g[x]) {\n        if (!was[y]) {\n          s[root].emplace(w[y], y);\n        } else {\n          join(root, y);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (!was[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d\", a + i, b + i);\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    --x;\n    --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ll = -1, rr = 1'000'000'000;\n  while (rr - ll > 1) {\n    int ss = (ll + rr) / 2;\n    if (can(ss)) {\n      rr = ss;\n    } else {\n      ll = ss;\n    }\n  }\n  long long tot = 0;\n  for (int i = 0; i < n; ++i) {\n    tot += b[i];\n  }\n  printf(\"%lld\\n\", tot + rr);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll LLINF = 1ll << 60;\nconst int N = 100010;\nint n, m, va[N], vb[N], id[N], per[N], uni[N];\nll sum[N], dp[2][N], ans, rec[N], pre[N], suf[N];\nint getfa(int pos) {\n  return pos == uni[pos] ? pos : uni[pos] = getfa(uni[pos]);\n}\nvector<int> vec[N];\nint main() {\n  int x,y;\n  read(n), read(m);\n  rep (i, 1, n) read(va[i]), read(vb[i]);\n  rep (i, 1, n) per[i] = i;\n  sort(per + 1, per + n + 1, [=](int a,int b) -> bool {\n      return va[a] < va[b];\n    });\n  rep (i, 1, n) id[per[i]] = i;\n  rep (i, 1, m) {\n    read(x), read(y);\n    if (id[x] < id[y]) swap(x, y);\n    vec[x].push_back(y);\n  }\n  rep (i, 1, n) {\n    uni[i] = i;\n    sum[i] = vb[i];\n    dp[0][i] = max(va[i], vb[i]);\n    dp[1][i] = vb[i];\n  }\n  rep (i, 1, n) {\n    int j = per[i];\n    vector<int> tmp;\n    rep (k, 0, (int)vec[j].size()-1)\n      tmp.push_back(getfa(vec[j][k]));\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n    ll ssum = 0;\n    rep (k, 0, (int)tmp.size()-1)\n      ssum += sum[tmp[k]];\n    dp[0][j] = LLINF;\n    if (tmp.empty()) dp[0][j] = max(va[j], vb[j]);\n    rep (k, 0, (int)tmp.size()-1) {\n      dp[0][j] = min(dp[0][j], ssum - sum[tmp[k]] + max((ll)va[j], dp[0][tmp[k]] + vb[j]));\n    }\n    dp[0][j] = min(dp[0][j], ssum + max(va[j], vb[j]));\n    dp[1][j] = LLINF;\n    if (tmp.empty()) dp[1][j] = vb[j];\n    else if ((int)tmp.size() == 1)\n      dp[1][j] = min(dp[0][tmp[0]] + vb[j], dp[1][tmp[0]] + max(va[j], vb[j]));\n    else {\n      rep (k, 0, (int)tmp.size()-1) {\n\trec[k] = max((ll)va[j], dp[0][tmp[k]] + vb[j]) - sum[tmp[k]];\n      }\n      pre[0] = rec[0];\n      rep (k, 1, (int)tmp.size()-1) pre[k] = min(rec[k], pre[k-1]);\n      suf[(int)tmp.size()-1] = rec[(int)tmp.size()-1];\n      rrp (k, (int)tmp.size()-2, 0) suf[k] = min(rec[k], suf[k+1]);\n      rep (k, 0, (int)tmp.size()-1) {\n\tll v = LLINF;\n\tif (k > 0) v = min(v, pre[k-1]);\n\tif (k < (int)tmp.size()-1) v = min(v, suf[k+1]);\n\tv += ssum - sum[tmp[k]] + dp[1][tmp[k]];\n\tdp[1][j] = min(dp[1][j], v);\n      }\n    }\n    dp[1][j] = min(dp[1][j], dp[0][j]);\n    rep (k, 0, (int)tmp.size()-1) {\n      uni[tmp[k]] = j;\n      sum[j] += sum[tmp[k]];\n    }\n  }\n  cout << dp[1][per[n]] << endl;\n  return 0;\n}\n/*\na,b\nmax(va[j], dp[0][b] + vb[j]) + ss - sum[a] - sum[b] + dp[1][a]\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define INF 3e15\n#define mod 1000000007\n#define eps 1e-6\n#define abs(x) ((x)>=0?(x):-(x))\n#define y1 solai\n#define fi first\n#define se second\ntypedef long long ll;\nvoid read(ll &x)\n{\n\tscanf(\"%lld\",&x);\n}\nvoid read(ll &x, ll &y)\n{\n\tscanf(\"%lld%lld\",&x,&y);\n}\nvoid read(ll &x, ll &y, ll &z)\n{\n\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n}\nvoid print(ll x)\n{\n\tprintf(\"%lld \",x);\n}\nvoid println(ll x)\n{\n\tprintf(\"%lld\\n\",x);\n}\nconst ll N=100000;\nll n,m,x,y,l,r,mid,ans,sum,a[N+10],b[N+10],li[N+10],w[N+10],p[N+10],ra[N+10],su[N+10];\nvector<ll>v[N+10];\nset<pair<ll,ll> >s[N+10];\n/*ll fin(ll a)\n{\n\tif(a==p[a])\n\t\treturn a;\n\treturn p[a]=fin(p[a]);\n}\nvoid uni(ll a, ll b)\n{\n\ta=fin(a),b=fin(b);\n\tif(a==b)\n\t\treturn;\n\tif(r[a]>r[b])\n\t\tr[a]+=r[b],su[a]+=su[b],p[b]=a;\n\telse\n\t\tr[b]+=r[a],su[b]+=su[a],p[a]=b;\n}\nvoid dfs(ll x)\n{\n\tw[x]=1;\n\tll rt=fin(x);\n\tsu[rt]+=b[x];\n\tfor(ll to:v[x])\n\t\tif(fin(x)!=fin(to))\n\t\t\ts[rt].insert({a[to]-b[to],to});\n\twhile(!s[rt].empty())\n\t{\n\t\tll need=s[rt].begin()->fi,to=s[rt].begin()->se;\n\t\tif(fin(x)==fin(to))\n\t\t\ts[rt].erase(s[rt].begin());\n\t\telse if(fin(x)!=fin(to)&&su[rt]>=need)\n\t\t{\n\t\t\tuni(rt,s[rt].begin()->se);\n\t\t\tdfs(s[rt].begin()->se);\n\t\t\trt=fin(x);\n\t\t\ts[rt].erase(s[rt].begin());\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n}*/\nbool cmp(ll x, ll y)\n{\n\treturn a[x]-b[x]<a[y]-b[y];\n}\nint main()\n{\n\t//freopen(\"c.cpp\",\"r\",stdin);\n \n\tcin>>n>>m;\n\tfor(ll i=1;i<=n;i++)\n\t\tread(a[i],b[i]),sum+=b[i],li[i]=i,p[i]=i,ra[i]=1,su[i]=b[i];\n\tfor(ll i=1;i<=m;i++)\n\t\tread(x,y),v[x].pb(y),v[y].pb(x);\n\tsort(li+1,li+n+1,&cmp);\n\tll res=INF;\n\tll t=ll(1e6)/(n+m);\n\tt*=2;\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0;\n\t\tans=0;\n\t\tq.push({-a[li[i]]+b[li[i]],li[i]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0,cur=rand()%n+1;\n\t\tans=0;\n\t\tq.push({-a[li[cur]]+b[li[cur]],li[cur]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\t/*for(ll i=1;i<=n;i++)\n\t\tif(!w[li[i]])\n\t\t\tans=a[li[i]]-b[li[i]],dfs(li[i]);*/\n\tcout<<res+sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{int to,next;}e[200010],E[200010];\nint n,m,a[100010],b[100010],Hd[100010],id[100010],fa[100010],bel[100010],x,y,hd[100010],cnt,p[100010];\nlong long sum[100010],f[100010],ans;\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid addedge(int x,int y) {e[++cnt]=(node){y,hd[x]},hd[x]=cnt;}\n\nvoid Addedge(int x,int y)\n{\n\tE[++cnt]=(node){y,Hd[x]},Hd[x]=cnt;\n\tE[++cnt]=(node){x,Hd[y]},Hd[y]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tsum[x]=b[x];\n\tlong long mi=1000000000000000000ll;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tdfs(e[i].to),sum[x]+=sum[e[i].to],\n\t\tmi=min(mi,max(1ll*a[x],b[x]+f[e[i].to])-sum[e[i].to]),\n\tf[x]=min(sum[x]-b[x]+mi,sum[x]-b[x]+max(a[x],b[x]));\n}\n\nint main()\n{\n\tsrand(12019687);\n\tscanf(\"%d%d\",&n,&m),ans=1000000000000000000ll;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tfor (int qaq=1; qaq<=50; qaq++)\n\t{\n\t\trandom_shuffle(id+1,id+1+n),sort(id+1,id+1+n,cmp),cnt=0;\n\t\tfor (int i=1; i<=n; i++) p[id[i]]=i;\n\t\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=hd[i]=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tx=id[i];\n\t\t\tfor (int j=Hd[x]; j; j=E[j].next)\n\t\t\t\tif (p[E[j].to]<i&&ask(E[j].to)!=x) fa[ask(E[j].to)]=x,bel[ask(E[j].to)]=x;\n\t\t}\n\t\tcnt=0;\n\t\tfor (int i=1; i<=n; i++) if (fa[i]) addedge(fa[i],i);\n\t\tdfs(id[n]),ans=min(ans,f[id[n]]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    ll max_a = -1;\n    for (int i = 0; i < cp.size(); i++) if (cp[i].first - cp[i].second <= a[v] - b[v]) max_a = min(max_a, cp[i].first);\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if ((max_a == -1 && i == 0) || cp[0].first == max_a)\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint a[100005],b[100005],n;\n\nnamespace Heap {\n\nint ch[100005][2],num[100005],tot;\n\nint newnode(int x) {\n  num[++tot]=x;\n  ch[tot][0]=ch[tot][1]=0;\n  return tot;\n}\n\nint merge(int x,int y) {\n  if (!x) return y;\n  if (!y) return x;\n  if (a[num[x]]>a[num[y]]) swap(x,y);\n  ch[x][1]=merge(ch[x][1],y);\n  swap(ch[x][0],ch[x][1]);\n  return x;\n}\n\nint pop(int x) {\n  return merge(ch[x][0],ch[x][1]);\n}\n\n}\n\nint root[100005];\n\nnamespace SETS {\n\nint fa[100005],size[100005];\nll sum[100005];\n\nvoid init(int n) {\n  for(int i=1;i<=n;i++) {\n  \tfa[i]=i;\n  \tsize[i]=1;\n  \tsum[i]=b[i];\n  }\n}\n\nint find_father(int x) {\n  return (fa[x]==x)?x:fa[x]=find_father(fa[x]);\n}\n\nbool check(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  return x!=y;\n}\n\nvoid merge(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  if (x==y) return;\n  fa[y]=x;\n  sum[x]+=sum[y];\n  size[x]+=size[y];\n  root[x]=Heap::merge(root[x],root[y]);\n}\n\n}\n\nbool bfs(int s,int d) {\n  while (root[s]) {\n  \tint x=Heap::num[root[s]];\n  \tif (!SETS::check(s,x)) {\n  \t\troot[s]=Heap::pop(root[s]);\n  \t\tcontinue;\n\t  }\n  \tif (a[x]>d+SETS::sum[s]) break;\n  \troot[s]=Heap::pop(root[s]);\n  \tSETS::merge(s,x);\n  }\n  return SETS::size[s]==n;\n}\n\nvector <int> e[100005];\n\nbool check(int d) {\n  Heap::tot=0;\n  SETS::init(n);\n  for(int i=1;i<=n;i++) {\n  \troot[i]=0;\n  \tfor(int j=0;j<e[i].size();j++) {\n  \t\tint u=Heap::newnode(e[i][j]);\n  \t\troot[i]=Heap::merge(root[i],u);\n\t  }\n  }\n  for(int i=1;i<=n;i++)\n    if (a[i]<=d&&bfs(i,d)) return 1;\n  return 0; \n}\n\nint main() {\n  int m;\n  scanf(\"%d%d\",&n,&m);\n  int l=0,r=0;\n  ll s=0;\n  for(int i=1;i<=n;i++) {\n    scanf(\"%d%d\",&a[i],&b[i]);\n    a[i]-=b[i];\n    s+=b[i];\n    r=max(r,a[i]);\n  }\n  for(int i=1;i<=m;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[x].push_back(y);\n  \te[y].push_back(x);\n  }\n  while (l<r) {\n  \tint mid=((l+r)>>1);\n  \tif (check(mid)) r=mid; else l=mid+1;\n  }\n  printf(\"%lld\\n\",s+l);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nstruct node{int to,nxt;}sq[N<<1],sq1[N<<1];\nint head[N],head1[N],all=0,all1=0;\nint n,m,a[N],b[N],c[N],fa[N],id[N];\nll f[N],sum[N]; \nbool vis[N];\n\nbool cmp(int x,int y) {return c[x]<c[y];}\n\nint find(int x)\n{\n\tif (fa[x]==x) return fa[x];\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\nvoid addedge(int u,int v)\n{\n\tall++;sq[all].to=v;sq[all].nxt=head[u];head[u]=all;\n}\n\nvoid addedge1(int u,int v)\n{\n\tall1++;sq1[all1].to=v;sq1[all1].nxt=head1[u];head1[u]=all1;\n}\n\nvoid dfs(int u)\n{\n\tsum[u]=b[u];\n\tfor (int i=head1[u];i;i=sq1[i].nxt)\n\t{\n\t\tint v=sq1[i].to;\n\t\tdfs(v);sum[u]+=sum[v];\n\t}\n\tf[u]=sum[u]+c[u];\n\tfor (int i=head1[u];i;i=sq1[i].nxt)\n\t{\n\t\tint v=sq1[i].to;\n\t\tf[u]=min(f[u],sum[u]-sum[v]+max((ll)c[u],f[v]));\n\t}\n}\n\nint main()\n{\n\tn=read();m=read();\n\trep(i,1,n)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tc[i]=max(a[i]-b[i],0);\n\t}\n\trep(i,1,m)\n\t{\n\t\tint u=read(),v=read();\n\t\taddedge(u,v);addedge(v,u);\n\t}\n\trep(i,1,n) id[i]=fa[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\trep(i,1,n)\n\t{\n\t\tint u=id[i];vis[u]=1;\n\t\tgo(u,i)\n\t\t{\n\t\t\tif (vis[v])\n\t\t\t{\n\t\t\t\tint fx=find(u),fy=find(v);\n\t\t\t\tif (fx!=fy)\n\t\t\t\t{\n\t\t\t\t\tfa[fy]=fx;addedge1(fx,fy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(id[n]);printf(\"%lld\",f[id[n]]);\n\treturn 0;\n}\n\t\t\t\t\t\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{int to,next;}e[200010],E[200010];\nint n,m,a[100010],b[100010],Hd[100010],id[100010],fa[100010],bel[100010],x,y,hd[100010],cnt,p[100010];\nlong long sum[100010],f[100010],ans;\n\nbool cmp(const int &x,const int &y) {return a[x]<a[y];}\nint ask(int x) {return bel[x]==x?x:bel[x]=ask(bel[x]);}\nvoid addedge(int x,int y) {e[++cnt]=(node){y,hd[x]},hd[x]=cnt;}\n\nvoid Addedge(int x,int y)\n{\n\tE[++cnt]=(node){y,Hd[x]},Hd[x]=cnt;\n\tE[++cnt]=(node){x,Hd[y]},Hd[y]=cnt;\n}\n\nvoid dfs(int x)\n{\n\tsum[x]=b[x];\n\tlong long mi=1000000000000000000ll;\n\tfor (int i=hd[x]; i; i=e[i].next)\n\t\tdfs(e[i].to),sum[x]+=sum[e[i].to],\n\t\tmi=min(mi,max(1ll*a[x],b[x]+f[e[i].to])-sum[e[i].to]);\n\tf[x]=min(sum[x]-b[x]+mi,sum[x]-b[x]+max(a[x],b[x]));\n}\n\nint main()\n{\n\tsrand(12019687);\n\tscanf(\"%d%d\",&n,&m),ans=1000000000000000000ll;\n\tfor (int i=1; i<=n; i++) scanf(\"%d%d\",&a[i],&b[i]),id[i]=i;\n\tfor (int i=1; i<=m; i++) scanf(\"%d%d\",&x,&y),Addedge(x,y);\n\tfor (int qaq=1; qaq<=50; qaq++)\n\t{\n\t\trandom_shuffle(id+1,id+1+n),sort(id+1,id+1+n,cmp),cnt=0;\n\t\tfor (int i=1; i<=n; i++) p[id[i]]=i;\n\t\tfor (int i=1; i<=n; i++) bel[i]=i,fa[i]=hd[i]=0;\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tx=id[i];\n\t\t\tfor (int j=Hd[x]; j; j=E[j].next)\n\t\t\t\tif (p[E[j].to]<i&&ask(E[j].to)!=x) fa[ask(E[j].to)]=x,bel[ask(E[j].to)]=x;\n\t\t}\n\t\tcnt=0;\n\t\tfor (int i=1; i<=n; i++) if (fa[i]) addedge(fa[i],i);\n\t\tdfs(id[n]),ans=min(ans,f[id[n]]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long \n\nconst int maxn=500010, inf=1e9;\nstruct edge{int too, pre;}e[maxn];\nint n, m, x, y, tot;\nint fa[maxn], a[maxn], b[maxn], last[maxn], pos[maxn];\nll ad[maxn], sum[maxn];\nbool v[maxn];\ntemplate<typename T>\ninline void read(T &k)\n{\n\tint f=1; k=0; char c=getchar();\n\twhile(c<'0' || c>'9') c=='-'&&(f=-1), c=getchar();\n\twhile(c<='9' && c>='0') k=k*10+c-'0', c=getchar();\n\tk*=f;\n}\ninline void add(int x, int y){e[++tot]=(edge){y, last[x]}; last[x]=tot;}\ninline bool cmp(int x, int y){return a[x]<a[y];}\nint gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}\nint main()\n{\n\tread(n); read(m);\n\tfor(int i=1;i<=n;i++) read(a[i]), read(b[i]), a[i]=max(a[i]-b[i], 0);\n\tfor(int i=1;i<=m;i++) read(x), read(y), add(x, y), add(y, x);\n\tfor(int i=1;i<=n;i++) pos[i]=i, fa[i]=i, ad[i]=a[i], sum[i]=b[i];\n\tsort(pos+1, pos+1+n, cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=pos[i]; v[x]=1;\n\t\tfor(int j=last[x], too;j;j=e[j].pre)\n\t\tif(v[too=e[j].too])\n\t\t{\n\t\t\tint fx=gf(x), fy=gf(too);\n\t\t\tif(fx==fy) continue;\n\t\t\tsum[fx]+=sum[fy]; fa[fy]=fx;\n\t\t\tad[fx]=min(ad[fx], ad[fy]+max(0ll, a[x]-ad[fy]-sum[fy]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", sum[pos[n]]+ad[pos[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60) + 1e9;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass UF{\npublic:\n  Int V;\n  vector<Int> par,rnk,sz;\n  UF(){}\n  UF(Int V):V(V),par(V),rnk(V,0),sz(V,1){for(Int i=0;i<V;i++)par[i]=i;}\n  \n  Int find(Int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(Int x,Int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rnk[x]<rnk[y])par[x]=y, sz[y] += sz[x];\n    else{\n      par[y]=x;\n      sz[x] += sz[y];\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  bool same(Int x,Int y){return find(x)==find(y);}\n\n  Int size(Int x){return sz[find(x)];}\n};\n\n\nInt n;\nvector<vector<Int> > G;\nvector<Int> A, B;\n\nInt solve(){\n  vector<Int> ord(n); iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](Int a,Int b){return A[a] - B[a] < A[b] - B[b];});\n  vector<Int> dp(n,INF);\n  \n  UF uf(n);\n  for(Int i=0;i<n;i++) uf.sz[i] = B[i];\n  \n  vector<Int> used(n, 0);\n  for(Int v:ord){\n    assert(v == uf.find(v));\n    Int c = max(0LL, A[v] - B[v]);\n    used[v] = 1;\n    Int mn = INF;\n    for(Int to:G[v]){\n      to = uf.find(to);\n      if(used[to] == 0) continue;\n      Int a = max(0LL, c - uf.size(to));\n      Int b = dp[to];\n      Min(mn, max(a, b));\n    }\n    \n    for(Int to:G[v]){\n      to = uf.find(to);\n      if(used[to]) uf.unite(v, to);\n    }\n    \n    v = uf.find(v);\n    if(mn == INF) mn = c;\n    dp[v] = mn;\n  }\n\n  Int res = accumulate(B.begin(), B.end(), 0LL);\n  assert(res == uf.size(0));\n  Int last = uf.find(ord.back());\n  res += max(0LL, dp[last]);\n  return res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int m;\n  cin>>n>>m;\n  G.resize(n);\n  A.resize(n); B.resize(n);\n  for(Int i=0;i<n;i++) cin>>A[i]>>B[i];\n  \n  for(Int i=0;i<m;i++){\n    Int u, v;\n    cin>>u>>v; u--, v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  Int ans = solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define N 100500\nint vis[N],fa[N],s[N],v[N],n,m,a,b,head[N],cnt,is[N];\nlong long su[N],dp[N];\nstruct edge{int t,next;}ed[N*2];\nvoid adde(int f,int t){ed[++cnt]=(edge){t,head[f]};head[f]=cnt;ed[++cnt]=(edge){f,head[t]};head[t]=cnt;}\nint finds(int x){return fa[x]==x?x:fa[x]=finds(fa[x]);}\npriority_queue<pair<long long,int> > tp;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&s[i],&v[i]),tp.push(make_pair(-s[i]*2000000000ll+v[i],i));\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&a,&b),adde(a,b);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint s1=tp.top().second;tp.pop();dp[s1]=1e17;is[s1]=1;\n\t\tfor(int j=head[s1];j;j=ed[j].next)if(finds(ed[j].t)!=s1&&is[finds(ed[j].t)])vis[finds(ed[j].t)]=1,dp[s1]=min(dp[s1],max(1ll*s[s1],dp[finds(ed[j].t)]+v[s1])-su[finds(ed[j].t)]),su[s1]+=su[finds(ed[j].t)],fa[finds(ed[j].t)]=s1;\n\t\tdp[s1]+=su[s1];su[s1]+=v[s1];\n\t\tdp[s1]=min(dp[s1],max(s[s1],v[s1])+su[s1]-v[s1]);\n\t}\n\tprintf(\"%lld\\n\",dp[finds(1)]);\n}//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100005;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m, root, a[MAXN], b[MAXN], f[MAXN], pos[MAXN], fa[MAXN];\nvector <int> e[MAXN], t[MAXN];\nlong long dp[MAXN], sum[MAXN];\nvoid work(int pos) {\n\tif (t[pos].size() == 0) {\n\t\tdp[pos] = a[pos] + b[pos];\n\t\tsum[pos] = b[pos];\n\t\treturn;\n\t}\n\tsum[pos] = b[pos];\n\tfor (unsigned i = 0; i < t[pos].size(); i++) {\n\t\twork(t[pos][i]);\n\t\tsum[pos] += sum[t[pos][i]];\n\t}\n\tdp[pos] = 1e18;\n\tfor (unsigned i = 0; i < t[pos].size(); i++)\n\t\tchkmin(dp[pos], max(dp[t[pos][i]], 1ll * a[pos]) + sum[pos] - sum[t[pos][i]]);\n}\nbool cmp(int x, int y) {\n\treturn a[x] < a[y];\n}\nint F(int x) {\n\tif (f[x] == x) return x;\n\telse return f[x] = F(f[x]);\n}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]), read(b[i]);\n\t\ta[i] = max(a[i] - b[i], 0);\n\t\tpos[i] = i;\n\t}\n\tsort(pos + 1, pos + n + 1, cmp);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y;\n\t\tread(x), read(y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tmemset(fa, -1, sizeof(fa));\n\tfor (int i = 1; i <= n; i++) {\n\t\tint tmp = pos[i];\n\t\tf[tmp] = tmp;\n\t\tfor (unsigned j = 0; j < e[tmp].size(); j++)\n\t\t\tif (fa[F(e[tmp][j])] == 0) fa[F(e[tmp][j])] = tmp, f[F(e[tmp][j])] = tmp;\n\t\tfa[tmp] = 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i]) t[fa[i]].push_back(i);\n\t\telse root = i;\n\twork(root);\n\twriteln(dp[root]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint a[N], b[N], fa[N], p[N];\nLL f[N], siz[N];\nvector<int> e[N];\nbool vis[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nbool cmp(int x, int y) { return a[x] < a[y]; }\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>(), m = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>(), siz[i] = b[i] = gi<int>();\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x = gi<int>(), y = gi<int>();\n\t\te[x].push_back(y), e[y].push_back(x);\n\t}\n\tfor (int i = 1; i <= n; i++) fa[i] = p[i] = i, a[i] = max(0, a[i] - b[i]);\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u = p[i]; vector<int> son; vis[u] = 1;\t\t\n\t\tfor (auto v : e[u]) {\n\t\t\tif (!vis[v] || u == find(v)) continue;\n\t\t\tson.push_back(find(v));\n\t\t\tsiz[u] += siz[find(v)]; fa[find(v)] = u;\n\t\t}\n\t\tf[u] = siz[u] + a[u];\n\t\tfor (auto v : son) f[u] = min(f[u], siz[u] - siz[v] + max(1ll * a[u], f[v]));\n\t}\n\tprintf(\"%lld\\n\", f[p[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            if (S[top[uf.find(to)]] <= S[i] and not uf.same(to, i)) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        for (const int to : T[v]) {\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    int r = 0;\n    for (int i = 0; i < N; i++) {\n        if (T.rev_edge[i].empty()) { r = i; }\n    }\n    dfs(dfs, r);\n    std::cout << f[r] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct node{\n\tint x,v;\n\tnode(int a=0,int b=0){x=a;v=b;}\n}p[100010];\nint h[100010],nex[200010],to[200010],a[100010],b[100010],fa[100010],M;\nll s[100010],f[100010];\nbool v[100010];\nvoid add(int a,int b){\n\tM++;\n\tto[M]=b;\n\tnex[M]=h[a];\n\th[a]=M;\n}\nbool operator<(node a,node b){return a.v<b.v;}\nint get(int x){return x==fa[x]?x:(fa[x]=get(fa[x]));}\nint main(){\n\tint n,m,i,j,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tp[i]=node(i,a[i]);\n\t}\n\twhile(m--){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(p+1,p+n+1);\n\tfor(i=1;i<=n;i++){\n\t\tfa[i]=i;\n\t\ts[i]=b[i];\n\t\tf[i]=a[i];\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tv[p[i].x]=1;\n\t\tfor(j=h[p[i].x];j;j=nex[j]){\n\t\t\tif(v[to[j]]){\n\t\t\t\tx=get(p[i].x);\n\t\t\t\ty=get(to[j]);\n\t\t\t\tif(x==y)continue;\n\t\t\t\tfa[y]=x;\n\t\t\t\ts[x]+=s[y];\n\t\t\t\tf[x]=min(f[x],max(f[y],a[x]-s[y]));\n\t\t\t}\n\t\t}\n\t}\n\tx=get(1);\n\tprintf(\"%lld\",f[x]+s[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\n\nint main() {\n    long long N, M; cin >> N >> M;\n    vector<int> A(M), B(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> A[i] >> B[i], --A[i], --B[i];\n    }\n        \n    UnionFind uf(N);\n    long long cur = N * (N-1) / 2;\n    vector<long long> res;\n    for (int i = 0; i < M; ++i) {\n        res.push_back(cur);\n            \n        int a = A[M-1-i], b = B[M-1-i];\n        if (uf.issame(a, b)) continue;\n        \n        long long sa = uf.size(a), sb = uf.size(b);\n        cur -= sa * sb;\n        uf.merge(a, b);\n    }\n        \n    reverse(res.begin(), res.end());\n    for (int i = 0; i < res.size(); ++i) cout << res[i] <<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvvll in_Graph(ll nodeNum, ll edgeNum, bool isDirected){\n\tvvll to(nodeNum);\n\tREP(i, edgeNum){\n\t\tll v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tto[v].push_back(u);\n\t\tif (!isDirected) to[u].push_back(v);\n\t}\n\treturn std::move(to);\n}\n\nvpll AB;\nvvll to;\n\nstruct UnionFindTree{\n\tvll par;\n\tvll size;\n\tvll cost;\n\tvll Ws;\n\tusing pque = priority_queue<pll, vpll, greater<pll>>;\n\tvector<pque> borderQs;\n\n\tUnionFindTree(ll num): par(num), size(num, 1),\n\t\tcost(num), Ws(num), borderQs(num){\n\t\tREP(i, num) par[i] = i;\n\t}\n\tbool Same(ll x, ll y) { return Root(x) == Root(y); }\n\tll Root(ll x) { return (par[x] == x) ? x : par[x]=Root(par[x]); }\n\tll Size(ll x){ return size[Root(x)]; }\n\tvoid Unite(ll x, ll y){//x勝ち側\n\t\tx = Root(x);\n\t\ty = Root(y);\n\t\tif (x == y) return;\n\t\t//ll c = cost[x];\n\n\t\t//Ws[x]の更新\n\t\tll W;\n\t\tif (Ws[y] == 0){//未発火時\n\t\t\tW = Ws[x] + AB[y].second;\n\t\t}\n\t\telse{\n\t\t\tW = Ws[x] + Ws[y] - cost[y];\n\t\t}\n\t\tWs[x] = W;\n\n\t\t//bordersのマージ\n\t\tif (Ws[y] == 0){//未発火時\n\t\t\tEACH(v, to[y]){\n\t\t\t\tll a, b; tie(a, b) = AB[v];\n\t\t\t\tborderQs[x].push(pll(a-b, v));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpque *bQ, *bQD;\n\t\t\tbQ  = &(borderQs[x]);\n\t\t\tbQD = &(borderQs[y]);\n\t\t\twhile (!bQD->empty()){\n\t\t\t\tbQ->push(bQD->top());\n\t\t\t\tbQD->pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpar[y] = x;\n\t\tsize[x] = size[y] = size[x] + size[y];\n\t}\n};\n\n\nvoid solve()\n{\n\tll N, M;  cin >> N >> M;\n\tAB = cinv2(N);\n\tto = in_Graph(N, M, false);\n\n\tpriority_queue<pll, vpll, greater<pll>> areaQ; //pair<次に進むのに必要なコスト,ノード>\n\tREP(v, N){\n\t\tll a, b; tie(a, b) = AB[v];\n\t\tll c = a-b;\n\t\tareaQ.push(pll(c, v));\n\t}\n\n\tUnionFindTree uft(N);\n\n\tll ans = -1;\n\twhile (!areaQ.empty()){\n\t\tll newc, v; tie(newc,v) = areaQ.top();  areaQ.pop(); //newc:次に進むのに必要なコスト\n\n\t\t//既にマージ吸収されていたらskip\n\t\tif (uft.par[v] != v) continue;\n\n\t\tif (uft.Ws[v]==0){//未発火時\n\t\t\tuft.cost[v] = max(0LL, newc);\n\t\t\tuft.Ws[v] = max(AB[v].first, AB[v].second);\n\t\t\t//自分の周りを全てbordersに入れる\n\t\t\tEACH(u, to[v]){\n\t\t\t\tll a, b; tie(a, b) = AB[u];\n\t\t\t\tuft.borderQs[v].push(pll(a-b, u));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tll addCost = newc - uft.cost[v];\n\t\t\tuft.Ws[v] += addCost;\n\t\t\tuft.cost[v] += addCost;\n\t\t\t//ll diff = newc - uft.cost[v];\n\t\t\t//uft.Ws[v] += diff;\n\t\t\t//uft.cost[v] = newc;\n\t\t}\n\t\t////自分の周りを全てbordersに入れる\n\t\t//EACH(u, to[v]){\n\t\t//\tll a, b; tie(a, b) = AB[u];\n\t\t//\tuft.borderQs[v].push(pll(a-b, u));\n\t\t//}\n\n\t\twhile (!uft.borderQs[v].empty()){\n\t\t\tll u_c, u; tie(u_c, u) = uft.borderQs[v].top();\n\t\t\tif (u_c > uft.Ws[v]) break;//取り出せない\n\t\t\tuft.borderQs[v].pop();\n\t\t\tif (uft.Same(v, u)) continue;\n\t\t\tuft.Unite(v, u);\n\t\t}\n\n\t\tif (uft.borderQs[v].empty()){\n\t\t\tans = uft.Ws[v];\n\t\t\tbreak;//ans出力へ\n\t\t}\n\n\t\tll needCost = uft.borderQs[v].top().first - uft.Ws[v] + uft.cost[v];\n\t\tareaQ.push(pll(needCost, v));\n\t}\n\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint A[N] , B[N];\n\nint n , m;\nvector<int> adj[N] , son[N];\n\nstruct Cmp {  bool operator() (int x , int y) const {return A[x] < A[y];} };\n\nint par[N] , id[N] , vis[N];\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nll dp[N] , s[N];\nvoid dfs(int x) {\n    s[x] = B[x];\n    for(auto y : son[x]) dfs(y) , s[x] += s[y];\n    dp[x] = A[x] + s[x];\n    for(auto y : son[x]) dp[x] = min(dp[x] , max(dp[y] , (ll)A[x]) + s[x] - s[y]);\n}\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , A + i , B + i);\n        A[i] = max(A[i] - B[i] , 0);\n        par[i] = i , id[i] = i;\n    }\n    sort(id + 1 , id + 1 + n , Cmp());\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    for(int i = 1 ; i <= n ; ++i) {\n        int x = id[i];\n        vis[x] = 1;\n        for(auto y : adj[x])\n            if(vis[y]) {\n                int z = find(y);\n                if(z != x) son[x].push_back(z) , par[z] = x;\n            }\n    }\n    dfs(id[n]) , cout << dp[id[n]] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#ifdef MAROON_LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\" SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int Nmax=100010;\nvi g[Nmax],ch[Nmax];\nint par[Nmax],a[Nmax],b[Nmax],c[Nmax];\n\nint Find(int v){\n\treturn par[v]==-1?v:(par[v]=Find(par[v]));\n}\n\npi dfs(int v){\n\tvi cost,sum;\n\tfor(auto to:ch[v]){\n\t\tpi d=dfs(to);\n\t\tcost.PB(d.first);\n\t\tsum.PB(d.second);\n\t}\n\tint s=b[v]+accumulate(ALL(sum),int(0));\n\tint res=c[v]+s;\n\tREP(i,cost.size())\n\t\tchmin(res,max(cost[i],c[v])+s-sum[i]);\n\treturn pi(res,s);\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tREP(i,n){\n\t\ta[i]=read();\n\t\tb[i]=read();\n\t\tc[i]=max(a[i]-b[i],int(0));\n\t}\n\tREP(i,m){\n\t\tint u=read()-1,v=read()-1;\n\t\tg[u].PB(v);\n\t\tg[v].PB(u);\n\t}\n\t\n\tvector<pi> idx(n);\n\tREP(i,n)idx[i]=pi(c[i],i);\n\tsort(ALL(idx));\n\t\n\tONE(par);\n\tfor(auto wi:idx){\n\t\tint v=wi.second;\n\t\tfor(auto to:g[v])if(pi(c[to],to)<wi){\n\t\t\tto=Find(to);\n\t\t\tif(to!=v){\n\t\t\t\tpar[to]=v;\n\t\t\t\tch[v].PB(to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpi ans=dfs(idx.back().second);\n\tprint(ans.first);\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nbool comp2(pll a, pll b)\n{\n    return a.first - a.second < b.first - b.second;\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), comp2);\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < fact(cp.size()); i++)\n    {\n        ll cost_in = max(a[v], cp[0].first + b[v]);\n        for (int i = 1; i < cp.size(); i++)\n        {\n            cost_in = max(cost_in + cp[i].second, cp[i].first);\n        }\n        min_cost_in = min(min_cost_in, cost_in);\n        next_permutation(all(cp));\n    }\n    //cout << \"results for vertex \" << v << \" \" << min_cost_in << \" \" << pay << endl;\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint n,m,a[N],b[N];\nstruct EDGE { int v,nx; }lb[N]; int tot=1,top[N];\nvoid add (int u,int v) { lb[++tot]=(EDGE){v,top[u]},top[u]=tot; }\nLL f[N],s[N];\nvoid dfs (int u)\n{\n\ts[u]=b[u];\n\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t{\n\t\tint v=lb[kb].v;\n\t\tdfs (v);\n\t\ts[u]+=s[v];\n\t}\n\tf[u]=s[u]+a[u];\n\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t{\n\t\tint v=lb[kb].v;\n\t\tchkmin (f[u],s[u]-s[v]+max (f[v],(LL)a[u]));\n\t}\n}\n#define pb push_back\nvector <int> G[N];\nint fa[N];\nint getf (int x) { return fa[x]==x?x:fa[x]=getf (fa[x]); }\nint id[N]; bool vis[N];\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n),sc(m);\n\tfor (int i=1; i<=n; i++)\n\t\tsc(a[i]),sc(b[i]),a[i]=max (a[i]-b[i],0);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint x,y; sc(x),sc(y);\n\t\tG[x].pb (y),G[y].pb (x);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tid[i]=i;\n\tsort (id+1,id+n+1,[](int A,int B) { return a[A]< a[B]; });\n\tfor (int i=1; i<=n; i++)\n\t\tfa[i]=i;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint u=id[i]; vis[u]=1;\n\t\tfor (int v:G[u]) if (vis[v])\n\t\t{\n\t\t\tint f=getf (v);\n\t\t\tif (f!=u) fa[f]=u,add (u,f);\n\t\t}\n\t}\n\tint rt=getf (1);\n\tdfs (rt);\n\tpr(f[rt]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int N=1e5+5;\nint n,m,fa[N],p[N];\nLL sum[N],f[N],a[N],b[N];\nint head[N],ce;\nbool vis[N];\nstruct edge{int to,nxt;} e[N<<1];\nbool cmp(int x,int y) {return a[x]<a[y];}\nvoid adde(int x,int y) {e[++ce].to=y,e[ce].nxt=head[x],head[x]=ce;}\nint find(int x)\n{\n\tif(x==fa[x]) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tp[i]=fa[i]=i,f[i]=a[i],sum[i]=b[i];\n\t}\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadde(x,y); adde(y,x);\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint u=p[i]; vis[u]=1;\n\t\tfor(int j=head[u];j;j=e[j].nxt)\n\t\t{\n\t\t\tint v=e[j].to;\n\t\t\tif(!vis[v]) continue;\n\t\t\tint x=find(u),y=find(v);\n\t\t\tif(x!=y)\n\t\t\t{\n\t\t\t\tfa[y]=x,sum[x]+=sum[y];\n\t\t\t\tf[x]=min(f[x],max(f[y],a[x]-sum[y]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",f[find(1)]+sum[find(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tint N, M; cin >> N >> M;\n    vector<int> a(N), b(N);\n    rep(u, N) scanf(\"%d%d\", &a[u], &b[u]);\n    vector<int> x(M), y(M);\n    rep(i, M) scanf(\"%d%d\", &x[i], &y[i]), x[i]--, y[i]--;\n    if (N == 1) {\n        cout << max(a[0], b[0]) << endl;\n        return 0;\n    }\n    vector<i_i> ai(M);\n    rep(i, M) ai[i] = {max(a[x[i]], a[y[i]]), i};\n    sort(ai.begin(), ai.end());\n    ll tot = 0;\n    rep(u, N) tot += b[u];\n    union_find uf(N);\n    vector<ll> B(N), W(N);\n    rep(u, N) B[u] = b[u], W[u] = tot;\n    for (i_i unko: ai) {\n        int i = unko.second, h = unko.first;\n        if (uf.same(x[i], y[i])) continue;\n        int X = uf.find(x[i]), Y = uf.find(y[i]);\n        uf.unite(X, Y);\n        int Z = uf.find(x[i]);\n        B[Z] = B[X] + B[Y];\n        W[Z] = min(max(W[X], max(tot - B[X] + a[x[i]], tot - B[X] - b[y[i]] + a[y[i]])),\n            max(W[Y], max(tot - B[Y] + a[y[i]], tot - B[Y] - b[x[i]] + a[x[i]])));\n    }\n    cout << W[uf.find(0)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MAX=100020;\nconst ll INF=1ll<<62;\nll N,M,A[MAX],B[MAX],Q[MAX],par[MAX],W[MAX],Btot[MAX],chk[MAX];\nvector<ll> conn[MAX],rec;\nbool cmp(ll x,ll y){\n    return A[x]-B[x]<A[y]-B[y];\n}\nll fnd(ll x){\n    if(par[x]==x) return x;\n    return par[x]=fnd(par[x]);\n}\nll uni(ll x,ll y){\n    x=fnd(x); y=fnd(y);\n    if(x==y) return 0;\n    par[x]=y; return 1;\n}\nint main(){\n    scanf(\"%lld%lld\",&N,&M);\n    for(ll i=1;i<=N;i++) scanf(\"%lld%lld\",&A[i],&B[i]);\n    for(ll i=0;i<M;i++){\n        ll t1,t2;\n        scanf(\"%lld%lld\",&t1,&t2);\n        conn[t1].push_back(t2);\n        conn[t2].push_back(t1);\n    }\n    for(ll i=1;i<=N;i++) Q[i]=i,par[i]=i;\n    sort(Q+1,Q+1+N,cmp);\n    for(ll i=1;i<=N;i++){\n        ll cnt=0,idx;\n        chk[Q[i]]=1;\n        W[Q[i]]=INF;\n        for(ll j=0;j<conn[Q[i]].size();j++) if(chk[conn[Q[i]][j]]) {\n            idx=fnd(conn[Q[i]][j]);\n            if(idx!=Q[i]) rec.push_back(idx), par[idx]=Q[i];\n        }\n        for(ll j=0;j<rec.size();j++) Btot[Q[i]]+=Btot[rec[j]];\n        if(rec.size()==0) W[Q[i]]=max(A[Q[i]],B[Q[i]]);\n        else {for(ll j=0;j<rec.size();j++) W[Q[i]]=min(W[Q[i]],Btot[Q[i]]-Btot[rec[j]]+max(A[Q[i]],B[Q[i]]+W[rec[j]]));}\n        Btot[Q[i]]+=B[Q[i]];\n        rec.clear();\n    }\n    printf(\"%lld\\n\",W[Q[N]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],s[N],q[N];\nll sum;int n,m,l,r,mid,ans,mx;\n//inline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n//void merge(int u,int v){\n//\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n//\twhile(!Q[v].empty()){\n//\t\tR pi p=Q[v].top();Q[v].pop();\n//\t\tif(find(p.se)!=find(u))Q[u].push(p);\n//\t}\n//}\n//bool ck(){\n//\tint h=1,t=0,u;\n//\tfp(u,1,n){\n//\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n//\t\tif(dx[u]<=0)q[++t]=u;\n//\t\twhile(!Q[u].empty())Q[u].pop();\n//\t\tgo(u)Q[u].push(pi(dx[v],v));\n//\t}\n//\twhile(h<=t){\n//\t\tu=q[h++];if(find(u)!=u)continue;\n//\t\twhile(!Q[u].empty()){\n//\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n//\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n//\t\t\tif(s[u]+s[p.se]>=mx)return true;\n//\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,merge(u,p.se);\n//\t\t}\n//\t}\n//\tR int rt=find(1);\n//\tfp(i,2,n)if(find(i)!=rt)return false;\n//\treturn true;\n//}\nbool ok(R int s){\n\tif(a[s]-b[s]-mid>0)return false;\n\tfp(i,1,n)dx[i]=a[i]-b[i]-mid;\n\tstatic int vis[N];\n\tfp(i,1,n)vis[i]=0;ll sum=b[s];\n\tpriority_queue<pi,vector<pi>,greater<pi> >q;\n\twhile(!q.empty())q.pop();\n\tvis[s]=1;go(s)q.push(pi(dx[v],v)),vis[v]=1;\n\twhile(!q.empty()){\n\t\tR pi p=q.top();q.pop();\n\t\tif(p.fi>sum)break;\n\t\tsum+=b[p.se];if(sum>=mx)return true;\n\t\tgo(p.se)if(!vis[v])q.push(pi(dx[v],v));\n\t}\n\tfp(i,1,n)if(!vis[i])return false;\n\treturn true;\n}\nbool ck(){\n\tfp(i,1,n)if(ok(i))return true;\n\treturn false;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i];\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n\t\tif(sz < 100000) {\n\t\t\tvector<int> P(sz);\n\t\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\t\tbool is_ok = false;\n\t\t\twhile(true) {\n\t\t\t\tcat w = W[c];\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tw -= B[c];\n\t\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tw = W[c];\n\t\t\t\tok = true;\n\t\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t\t}\n\t\t\tassert(is_ok);\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        if (a.first - a.second == b.first - b.second)\n            return a.first < b.first;\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define repi(i, a, b) for (int i = (a); i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ull << (b))\n\nusing namespace std;\nusing i32 = long long;\nusing u32 = unsigned long long;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing vi32 = vector<i32>;\nusing vu32 = vector<u32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf64 = vector<f64>;\nusing vstr = vector<string>;\nusing vvi32 = vector<vi32>;\nusing vvu32 = vector<vu32>;\nusing vvi64 = vector<vi64>;\nusing vvu64 = vector<vu64>;\nusing vvf64 = vector<vf64>;\n\ntemplate<typename T, typename S> void amax(T &x, S y) { if (x < y) x = y; }\ntemplate<typename T, typename S> void amin(T &x, S y) { if (y < x) x = y; }\n\nclass vertex {\npublic:\n  int a, b, u;\n};\n\nbool compare(vertex a, vertex b) {\n  if (a.a == b.a) return a.b < b.b;\n  else return a.a > b.a;\n}\n\nint n, m;\nvector<vector<int>> edges;\nvector<vertex> costs; // a, b, u\nvector<bool> go;\n\nbool bfs(int from, int to) {\n  queue<int> q;\n  vector<bool> visited(n + 1, false);\n  q.push(from);\n  while (!q.empty()) {\n    auto u = q.front();\n    q.pop();\n    visited[u] = true;\n    for (auto v: edges[u]) {\n      if (!go[v]) continue;\n      if (visited[v]) continue;\n      if (v == to) return true;\n      q.push(v);\n    }\n  }\n  return false;\n}\n\nbool check(i64 w) {\n  go = vector<bool>(n + 1, true);\n  int now = 0;\n  int idx = 0;\n  for (int i = 0; i < n; i++) {\n    int a, b, u;\n    a = costs[i].a;\n    b = costs[i].b;\n    u = costs[i].u;\n    if (a > w) return false;\n    if (now > 0 && !bfs(now, u)) return false;\n    w -= b;\n    if (w < 0) return false;\n    while (idx < n && costs[idx].a > w) {\n      go[costs[idx++].u] = false;\n    }\n    now = u;\n  }\n  return true;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(16);\n  cin >> n >> m;\n  edges = vector<vector<int>>(n + 1, vector<int>());\n  rep(i, n) {\n    int a, b;\n    cin >> a >> b;\n    costs.push_back({a, b, i + 1});\n  }\n  sort(all(costs), compare);\n  rep(i, m) {\n    int u, v;\n    cin >> u >> v;\n    edges[u].push_back(v);\n    edges[v].push_back(u);\n  }\n  i64 ok = 10e16;\n  i64 ng = costs[0].a - 1;\n  while (ok - ng > 1) {\n    i64 mid = (ok + ng) / 2;\n    if (check(mid)) ok = mid;\n    else ng = mid;\n  }\n  cout << ok << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = max(0LL, A[i]-B[i]);\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\n\t\tif(sz > 1) for(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tcat w_mi = max(A[c]+s, B[c]+s+W[comp_adj[j]])-1, w_mx = W[c];\n\t\t\tif(w_mx <= w_mi+1) {\n\t\t\t\ts += sumB[comp_adj[j]];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvector< pair<cat, cat> > Vs;\n\t\t\tfor(int k = 0; k < sz; k++)\n\t\t\t\tif(k != j) Vs.push_back(make_pair(W[comp_adj[k]], sumB[comp_adj[k]]));\n\t\t\tsort(begin(Vs), end(Vs));\n\t\t\tvector<bool> vis(sz-1);\n\t\t\tint a = sz-1;\n\t\t\twhile(w_mx-w_mi > 1) {\n\t\t\t\tcat w_cur = (w_mi + w_mx) / 2;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int l = sz-2; l >= 0; l--) {\n\t\t\t\t\tif(vis[l]) continue;\n\t\t\t\t\tif(Vs[l].ff > w_cur) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta = min(a, l-1);\n\t\t\t\t\tif(a >= 0 && Vs[a].ff > w_cur-Vs[l].ss) {\n\t\t\t\t\t\tvis[a] = true;\n\t\t\t\t\t\tw_cur -= Vs[a].ss;\n\t\t\t\t\t\ta--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvis[l] = true;\n\t\t\t\t\tw_cur -= Vs[l].ss;\n\t\t\t\t}\n\t\t\t\tif(ok) w_mx = (w_mi + w_mx) / 2;\n\t\t\t\telse w_mi = (w_mi + w_mx) / 2;\n\t\t\t}\n\t\t\t// cout << j << \" \" << i << endl;\n\t\t\tW[c] = min(W[c], w_mx);\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\t\telse {\n\t\t\tW[c] = min(W[c], max(m+B[c], max(A[c], B[c]+s)));\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            const int V = S[top[uf.find(to)]];\n            if (V < S[i]) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    std::vector<ll> s(N), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        for (const int to : T[v]) { self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]); }\n        f[v] += s[v];\n    };\n    dfs(dfs, top[uf.find(0)]);\n    std::cout << f[top[uf.find(0)]] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct unionfind_t {\n  int n;\n  vector<int> parent, rank;\n  unionfind_t(int _n): n(_n), parent(n), rank(n, 0) {\n    iota(parent.begin(), parent.end(), 0);\n  }\n  int find(int v) {\n    if (v == parent[v]) return v;\n    return parent[v] = find(parent[v]);\n  }\n  int join(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) return a;\n    if (rank[a] > rank[b]) swap(a, b);\n    parent[a] = b;\n    if (rank[a] == rank[b]) ++rank[b];\n    return b;\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n\n  struct node_t {\n    lint min_stand, cost;\n  };\n  vector<node_t> nodes(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld %lld\", &nodes[i].min_stand, &nodes[i].cost);\n  }\n\n  vector<vector<int>> adj(n);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b), --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  struct dp_t {\n    lint total;\n    lint worst_state;\n  };\n\n  vector<dp_t> dp(n);\n  unionfind_t uf(n);\n\n  vector<int> sorted_by_min_stand(n);\n  iota(sorted_by_min_stand.begin(), sorted_by_min_stand.end(), 0);\n  sort(sorted_by_min_stand.begin(), sorted_by_min_stand.end(),\n       [&nodes](int a, int b) {\n         return nodes[a].min_stand < nodes[b].min_stand;\n       });\n  vector<bool> mark(n, false);\n  for (int v : sorted_by_min_stand) {\n    static vector<int> cnts; cnts.clear();\n    mark[v] = true;\n    for (int u : adj[v])\n      if (mark[u]) {\n        cnts.push_back(uf.find(u));\n      }\n    sort(cnts.begin(), cnts.end());\n    cnts.resize(unique(cnts.begin(), cnts.end()) - cnts.begin());\n\n    lint cnts_total = 0LL;\n    for (int cnt : cnts)\n      cnts_total += dp[cnt].total;\n\n    dp_t result;\n    result.total = cnts_total + nodes[v].cost;\n    result.worst_state =\n      min(-cnts_total - nodes[v].min_stand,\n          -cnts_total - nodes[v].cost);\n\n    for (int cnt : cnts) {\n      lint others_total = cnts_total - dp[cnt].total;\n\n      result.worst_state =\n        max(result.worst_state,\n            min({-others_total - nodes[v].cost + dp[cnt].worst_state,\n                 -others_total - nodes[v].min_stand,\n                 -others_total - nodes[v].cost}));\n    }\n\n    int joined_cnt = v;\n    for (int cnt : cnts) joined_cnt = uf.join(joined_cnt, cnt);\n    dp[joined_cnt] = result;\n  }\n  printf(\"%lld\\n\", -dp[uf.find(0)].worst_state);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR int w=Q[v].top().se;Q[v].pop();\n\t\tif(find(w)!=find(u))Q[u].push(pi(dx[w],w));\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tif(h>t)return false;\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR int v=Q[u].top().se;if(dx[v]>s[u])break;\n\t\t\tQ[u].pop();if(find(v)==find(u))continue;\n\t\t\tif(s[u]+s[v]>=mx)return true;\n\t\t\ts[u]+=s[v],fa[find(v)]=u,++cnt,merge(u,v);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tl=1,r=1e9;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void read (I &x, int p) {\n\t\tfor (c = gc(); c < '0' || c > '9'; c = gc()) ;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = ( (x << 1) + (x << 3) + (c & 15) ) % p; \n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t// no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n} \nusing io :: gi;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5;\nint a[N],b[N],c[N],vis[N],fa[N],d[N],mx[N],p[N],pos[N],tot,head[N],nxt[N<<1],adj[N<<1];\ninline int chmax(ri x,ri y){\n\treturn pos[x]>pos[y]?x:y;\n}\ninline void addedge(ri x,ri y){\n\tnxt[++tot]=head[x];\n\tadj[head[x]=tot]=y;\n}\ninline int find(ri x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\ninline void merge(ri x,ri y){\n\tif(d[x]>d[y]) swap(x,y);\n\tif(d[x]==d[y]) ++d[y];\n\tfa[x]=y;\n\tmx[y]=chmax(mx[x],mx[y]);\n}\nstruct graph{\n\tint tot,head[N],nxt[N],adj[N];\n\tll f[N],s[N];\n\tinline void addedge(ri x,ri y){\n\t\tnxt[++tot]=head[x];\n\t\tadj[head[x]=tot]=y;\n\t}\n\tinline void dfs(ri x){\n\t\tri y,i;\n\t\ts[x]=b[x];\n\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\ty=adj[i],\n\t\t\tdfs(y),\n\t\t\ts[x]+=s[y];\n\t\tf[x]=s[x]+c[x];\n\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\ty=adj[i],\n\t\t\tf[x]=min(f[x],s[x]-s[y]+max((ll)c[x],f[y]));\n\t}\n}t;\nint main(){\n\tri n,m,i,j,x,y,fx,fy;\n\tgi(n);gi(m);\n\tfor(i=1;i<=n;++i)\n\t\tgi(a[i]),gi(b[i]),\n\t\ta[i]=max(a[i],b[i]),\n\t\tc[i]=a[i]-b[i],\n\t\tp[i]=i,\n\t\tfa[i]=mx[i]=i;\n\tsort(p+1,p+1+n,[&](ri x,ri y){ return c[x]<c[y]; });\n\tfor(i=1;i<=n;++i) pos[p[i]]=i;\n\twhile(m--)\n\t\tgi(x),gi(y),\n\t\taddedge(x,y),\n\t\taddedge(y,x);\n\tfor(j=1;j<=n;++j){\n\t\tx=p[j];\n\t\tvis[x]=1;\n\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\tif(vis[y=adj[i]]){\n\t\t\t\tfx=find(x);\n\t\t\t\tfy=find(y);\n\t\t\t\tif(fx==fy) continue;\n\t\t\t\tt.addedge(x,mx[fy]);\n\t\t\t\tmerge(fx,fy);\n\t\t\t}\n\t}\n\tt.dfs(p[n]);\n\tprintf(\"%lld\\n\",t.f[p[n]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nstruct node{\n\tint a,b,id;\n\tbool operator < (node &o){ return a<o.a; }\n}x[N];\nint cur[N],pa[N],n,m,u,v;\nll f[N],s[N]; vi e[N];\n\nint getpa(int x){\n\treturn pa[x]==x?x:pa[x]=getpa(pa[x]);\n}\n\nint main(){\n\tread(n),read(m);\n\trep(i,1,n){\n\t\tread(x[i].a),read(x[i].b);\n\t\tx[i].id=i,x[i].a=max(x[i].a,x[i].b);\n\t}\n\tsort(x+1,x+n+1);\n\trep(i,1,n)cur[x[i].id]=i;\n\trep(i,1,m){\n\t\tread(u),read(v);\n\t\te[cur[u]].pb(cur[v]);\n\t\te[cur[v]].pb(cur[u]);\n\t}\n\trep(i,1,n){\n\t\tpa[i]=i,s[i]=x[i].b;\n\t\tf[i]=max(x[i].a,x[i].b);\n\t}\n\trep(u,1,n){\n\t\tll mn=max(x[u].a,x[u].b),S=0;\n\t\tfor(auto v:e[u])\n\t\t\tif(v<u&&getpa(u)!=getpa(v)){\n\t\t\t\tmn=min(mn,max((ll)x[u].a,x[u].b+f[getpa(v)])-s[getpa(v)]);\n\t\t\t\tS+=s[getpa(v)];\n\t\t\t\tpa[getpa(v)]=getpa(u);\n\t\t\t}\n\t\ts[getpa(u)]=S+x[u].b;\n\t\tf[getpa(u)]=S+mn;\n\t}\n\tcout<<f[getpa(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\n//UF\nint par1[100021];\nint rank1[100021];\n//n要素で初期化\nvoid init(int n){\n   for(int i=0;i<n;i++){\n       par1[i]=i;\n       rank1[i]=0;\n   }\n}\n//木の根を求める\nint find(int x){\n    if(par1[x] ==x){\n         return x;\n    }else{\n         return par1[x]=find(par1[x]);\n    }\n}\n//xとyの属する集合を併合\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n\n    if(rank1[x]<rank1[y]){\n         par1[x]=y;\n    }else{\n         par1[y]=x;\n         rank1[x]++;\n    }\n}\n//xとyが同じ集合に属するか否か\nbool same(int x,int y){\n     return find(x)==find(y);\n}\n\n\n\nint N,M;\nLL A[100001];\nLL B[100001];\nLL C[100001];\nLL dp[100001];\nLL s[100001];\nbool used[100001];\n\nvector<int>G[100001];\ntypedef pair<LL,LL>P;\nvector<P>v;\nint main(){\n\tcin>>N>>M;\n\tREP(i,N){\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]=max(A[i],B[i]);\n\t\tv.push_back(P(A[i],i));\n\t}\n\tsort(v.begin(),v.end());\n\tREP(i,M){\n\t\tint u,vv;\n\t\tcin>>u>>vv;\n\t\tu--;vv--;\n\t\tG[u].push_back(vv);\n\t\tG[vv].push_back(u);\n\t}\n\tinit(N+10);\n\tREP(i,N){\n\t\tdp[i]=B[i];//得られたお金\n\t\ts[i]=C[i]-B[i];//最後の資金\n\t\tused[i]=false;\n\t}\n\tREP(i,v.size()){\n\t\tint x=v[i].second;\n\t\tused[x]=true;\n\t\tvector<int>k;\n\t\tREP(j,G[x].size()){\n\t\t\tif(used[G[x][j]]==true){\n\t\t\t\tk.push_back(find(G[x][j]));\n\t\t\t}\n\t\t}\n\t\tsort(k.begin(),k.end());\n\t\tk.erase(unique(k.begin(), k.end()), k.end());\n\t\t//要素のソート\n\t\tvector<P>u;\n\t\tREP(j,k.size()){\n\t\t\tu.push_back(P(dp[k[j]],k[j]));\n\t\t}\n\t\tREP(j,u.size()){\n\t\t\tif(same(x,u[j].second))continue;\n\t\t\tif(s[find(x)]<=s[u[j].second]){\n\t\t\t\tLL a=s[find(x)];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else if(s[u[j].second]+dp[u[j].second]>=(C[x]-B[x])){\n\t\t\t\tLL a=s[u[j].second];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else if(((C[x]-B[x])-dp[u[j].second])<=s[find(x)]){\n\t\t\t\tLL a=(C[x]-B[x])-dp[u[j].second];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else{\n\t\t\t\tLL a=s[find(x)];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}\n\t\t\t//cout<<\"x=\"<<x<<\" dp[x]=\"<<dp[x]<<\" s[x]=\"<<s[x]<<endl;\n\t\t}\n\t\t//cout<<\"xx=\"<<x<<\" dp[x]=\"<<dp[x]<<\" s[x]=\"<<s[x]<<endl;\n\t}\n\tcout<<dp[find(0)]+s[find(0)]<<endl;\n\t/*REP(i,5){\n\t\tcout<<\"f\"<<dp[find(i)]<<endl;\n\t}*/\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int & \n#define SZ(a) ((int)(a.size()))\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n\tfor (T x : a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\nconst int N = 1e5 + 9;\n\nint parent[N];\nint is_free[N];\nll bsum[N];\nvi g[N];\nint n, m;\nll a[N], b[N];\n\nset<pair<ll, int>> neibs[N];\nll gw;\nll gb;\n\nvoid make_set(int v) {\n\tneibs[v].clear();\n\tparent[v] = v;\n\tis_free[v] = a[v] - b[v] + gb <= gw;\n\tbsum[v] = b[v];\n\tfor (int to : g[v])\n\t\tneibs[v].insert(mp(a[to] - b[to], to));\n}\n\nint find_set(int v) {\n\tif (parent[v] == v) return v;\n\treturn parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n\ta = find_set(a);\n\tb = find_set(b);\n\tif (a == b) return;\n\tis_free[b] = 1;\n\tif (SZ(neibs[a]) < SZ(neibs[b]))\n\t\tswap(b, a);\n\tbsum[a] += bsum[b];\n\tparent[b] = a;\n\tneibs[a].insert(ALL(neibs[b]));\n}\n\n\nbool check(ll w) {\n\tgw = w;\n\t//watch(gw);\n\tgb = accumulate(b + 1, b + n + 1, 0LL);\n\tfill(parent, parent + n + 1, 0);\n\tfill(bsum, bsum + n + 1, 0);\n\tfill(is_free, is_free + n + 1, 0);\n\tfori(i, n)\n\t\tmake_set(i + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint v = find_set(i);\n\t\tif (!is_free[v]) continue;\n\t\twhile (1) {\n\t\t\tv = find_set(v);\n\t\t\tif (neibs[v].empty()) break;\n\t\t\tint u = find_set((*neibs[v].begin()).second);\n\t\t\tif (is_free[u] || a[u] - b[u] - bsum[v] + gb <= gw) {\n\t\t\t\tneibs[v].erase(neibs[v].begin());\n\t\t\t\tneibs[u].erase(mp(a[v] - b[v], v));\n\t\t\t\tunion_sets(v, u);\n\t\t\t} else break;\n\t\t}\n\t\tv = find_set(v);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!is_free[find_set(i)]) return 0;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcnt += parent[i] == i;\n\treturn cnt == 1;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tmmax(a[i], b[i]);\n\t}\n\tfori(iter, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\n\n\tll l = 1, r = 2e14;\n\twhile (l < r) {\n\t\tll m = (l + r) >> 1;\n\t\tif (check(m))\n\t\t\tr = m;\n\t\telse\n\t\t\tl = m + 1;\n\t\tif (l == r - 1) {\n\t\t\tif (check(l)) r = l;\n\t\t\telse l = r;\n\t\t}\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree,val;\n  vector<vector<int>> list;\n\npublic:\n  UnionFind(int v, vec b) {\n    tree.resize(v);\n    list.resize(v);\n    val = b;\n    REP(i,v) tree[i] = i, list[i].push_back(i);\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return list[root(i)].size();\n  }\n\n  vector<int> nodes(int no){\n    return list[root(no)];\n  }\n\n  int value(int x){\n    return val[x];\n  }\n\n  bool unit(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x==y) return false;\n    if(list[x].size() < list[y].size()) swap(x,y);\n    for(int no:list[y]) list[x].emplace_back(no);\n    tree[y] = x;\n    val[x] += val[y];\n    return true;\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nconst int N = 1e5+10;\nvector<P> e[N];\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,m;\n  cin >> n >> m;\n\n  vector<int> a(n),b(n);\n  vector<P> c(n);\n  REP(i,n) cin >> a[i] >> b[i], c[i] = P(max(0LL,a[i]-b[i]),i);\n  \n  using T = tuple<int,int,int>;\n  vector<int> edge[n];\n  REP(_,m){\n    int x,y;\n    cin >> x >> y;\n    x--; y--;\n    edge[x].emplace_back(y);\n    edge[y].emplace_back(x);\n  }\n\n  sort(c.begin(),c.end());\n\n  UnionFind uf(n,b);\n  vec dp(n), used(n,0);\n  REP(i,n) dp[c[i].sc] = c[i].fs;\n\n  REP(i,n){\n    int no = c[i].sc, mn = c[i].fs;\n    for(int to:edge[no]){\n      if(!used[to]) continue;\n      int v = uf.root(to);\n      mn = min(mn,max(dp[v],c[i].fs-uf.value(v)));\n    }\n    used[no]++;\n    for(int to:edge[no]) if(used[to]) uf.unit(no,to);\n    dp[uf.root(no)] = mn;\n  }\n\n  int v = uf.root(0);\n  cout << dp[v] + accumulate(b.begin(),b.end(),0LL) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        if (aa.first - aa.second == bb.first - bb.second)\n        {\n            if (abs(aa.first - a[v]) < abs(bb.first - a[v]))\n            {\n                return aa.first > bb.first;\n            }\n            return abs(aa.first - a[v]) < abs(bb.first - a[v]);\n        }\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 100005;\nconst long long inf = 1000000000000000ll;\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt;\n} graph[M << 1];\nint n, m, head[N], id[N], fa[N], cnt = 0;\nlong long a[N], b[N], f[N], g[N];\npair<int, int> vec[N];\n\nvoid addedge (int u, int v) {\n\tedge e = {v, head[u]};\n\tgraph[head[u] = cnt++] = e;\n}\n\nint findroot (int x) {\n\treturn fa[x] == x ? x : fa[x] = findroot(fa[x]);\n}\n\nstruct node {\n\tlong long cost, lim;\n\tint id;\n\tbool operator < (node rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n} ;\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) fa[i] = i, head[i] = -1;\n\tfor (int i = 1; i <= n; i++) read(a[i]), read(b[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\taddedge(u, v);\n\t\taddedge(v, u);\n\t}\n\n\tfor (int i = 1; i <= n; i++) vec[i] = make_pair(a[i], i);\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) id[vec[i].second] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u = vec[i].second;\n\t\tlong long sum = 0ll;\n\t\tvector<node> tmp;\n\t\tf[u] = -inf, g[u] = b[u];\n\t\tfor (int j = head[u]; ~j; j = graph[j].nxt) {\n\t\t\tint v = graph[j].to, rv = findroot(v);\n\t\t\tif (id[v] < id[u] && rv != u) {\n\t\t\t\tnode ch = {g[rv], f[rv], rv};\n\t\t\t\tfa[rv] = u, g[u] += g[rv];\n\t\t\t\ttmp.push_back(ch);\n\t\t\t}\n\t\t}\n\n\t\tnode rt = {b[u], a[u], u};\n\t\ttmp.push_back(rt);\n\t\tsort(tmp.begin(), tmp.end());\n\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\tif (j && tmp[j - 1].id != u) f[u] = max(f[u], sum + max(a[u], tmp[j].lim));\n\t\t\telse f[u] = max(f[u], sum + tmp[j].lim);\n\t\t\tsum += tmp[j].cost;\n\t\t}\n\t\tf[u] = max(f[u], sum);\n\t}\n\n\twrite(f[vec[n].second]), putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, M;\nint A[100000], B[100000];\nvector<int> G[100000];\nint U[100000], R[100000];\nint repr[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\nvector<int> G2[100000];\nbool used[100000];\nlong long dp[100000], sum[100000];\n\nvoid dfs(int x) {\n  if (G2[x].empty()) dp[x] = B[x];\n  sum[x] = B[x];\n  for (int t : G2[x]) {\n    dfs(t);\n    sum[x] += sum[t];\n  }\n  for (int t : G2[x]) {\n    dp[x] = min(dp[x], max(dp[t] + (sum[x]-sum[t]), A[x]+sum[x]-B[x]-sum[t]));\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, N) cin >> A[i] >> B[i];\n  rep(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) U[i] = i, R[i] = 1, repr[i] = i;\n  vector<P> ord;\n  rep(i, N) ord.pb(P(A[i], i));\n  sort(all(ord));\n  for (P p : ord) {\n    int x = p._2;\n    used[x] = true;\n    for (int t : G[x]) if (used[t] && !same(x, t)) {\n      assert(repr[find(x)] == x);\n      int c = repr[find(t)];\n      unite(x, t);\n      repr[find(x)] = x;\n      G2[x].pb(c);\n      //cout<<x<<\"->\"<<c<<\"\\n\";\n    }\n  }\n  rep(i, N) dp[i] = INF;\n  int root = ord.back()._2;\n  assert(root == repr[find(0)]);\n  dfs(root);\n  long long m = dp[root];\n  rep(i, N) m = max(m, A[i]);\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct unionfind_t {\n  int n;\n  vector<int> parent, rank;\n  unionfind_t(int _n): n(_n), parent(n), rank(n, 0) {\n    iota(parent.begin(), parent.end(), 0);\n  }\n  int find(int v) {\n    if (v == parent[v]) return v;\n    return parent[v] = find(parent[v]);\n  }\n  int join(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) return a;\n    if (rank[a] > rank[b]) swap(a, b);\n    parent[a] = b;\n    if (rank[a] == rank[b]) ++rank[b];\n    return b;\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n\n  struct node_t {\n    int min_stand, cost;\n  };\n  vector<node_t> nodes(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d\", &nodes[i].min_stand, &nodes[i].cost);\n  }\n\n  vector<vector<int>> adj(n);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b), --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  struct dp_t {\n    lint total;\n    lint worst_state;\n  };\n\n  vector<dp_t> dp(n);\n  unionfind_t uf(n);\n\n  vector<int> sorted_by_min_stand(n);\n  iota(sorted_by_min_stand.begin(), sorted_by_min_stand.end(), 0);\n  sort(sorted_by_min_stand.begin(), sorted_by_min_stand.end(),\n       [&nodes](int a, int b) {\n         return nodes[a].min_stand < nodes[b].min_stand;\n       });\n  vector<bool> mark(n, false);\n  for (int v : sorted_by_min_stand) {\n    static vector<int> cnts; cnts.clear();\n    mark[v] = true;\n    for (int u : adj[v])\n      if (mark[u]) {\n        cnts.push_back(uf.find(u));\n      }\n    sort(cnts.begin(), cnts.end());\n    cnts.resize(unique(cnts.begin(), cnts.end()) - cnts.begin());\n\n    lint cnts_total = 0LL;\n    for (int cnt : cnts)\n      cnts_total += dp[cnt].total;\n\n    dp_t result;\n    result.total = cnts_total + nodes[v].cost;\n    result.worst_state =\n      min(-cnts_total - nodes[v].min_stand,\n          -cnts_total - nodes[v].cost);\n\n    for (int cnt : cnts) {\n      lint others_total = cnts_total - dp[cnt].total;\n\n      result.worst_state =\n        max(result.worst_state,\n            min({dp[cnt].worst_state - others_total - nodes[v].cost,\n                  -others_total - nodes[v].min_stand,\n                  -others_total - nodes[v].cost}));\n    }\n\n    int joined_cnt = v;\n    for (int cnt : cnts) joined_cnt = uf.join(joined_cnt, cnt);\n    dp[joined_cnt] = result;\n  }\n  printf(\"%lld\\n\", -dp[uf.find(0)].worst_state);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define double long double\n    const int INF=0x3f3f3f3f;\n    const ll LLINF=0x3f3f3f3f3f3f3f3fll;\n    ll qread()\n    {\n        ll ans=0;char c=getchar();int f=1;\n        while(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) {num=-num;putchar('-');}\n        if(num>9) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);puts(\"\");}\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define pr pair<int,int>\n    #define PB push_back\n    #define vc vector\n    void chmax(ll &x,const ll y) {x=x>y?x:y;}\n    void chmin(ll &x,const ll y) {x=x<y?x:y;}\n    const int MAX_N=1e5+10;\n    const ll MOD=998244353;\n\t\n\tstruct DSU\n\t{\n\t\tint fa[MAX_N];DSU(){memset(fa,0,sizeof fa);}\n\t\tint findfa(int x){return x==fa[x]?x:findfa(fa[x]);}\n\t}dsu;\n\tll b[MAX_N],c[MAX_N];\n\tvc<int> son[MAX_N];\n\tll g[MAX_N];\n\tvoid dp(int x)\n\t{\n\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t{\n\t\t\tint y=son[x][t];dp(y);\n\t\t\tb[x]+=b[y];\n\t\t}\n\t\tif(son[x].size())\n\t\t{\n\t\t\tg[x]=LLINF;\n\t\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=son[x][t];\n\t\t\t\tchmin(g[x], max(g[y],c[x])+(b[x]-b[y]) );\n\t\t\t}\n\t\t}\n\t\telse g[x]=b[x]+c[x];\n\t}\n\tint pos[MAX_N];bool cmp(int x,int y){return c[x]<c[y];}\n\tvc<int> to[MAX_N];\n    void main()\n    {\n\t\tint n=qread(),m=qread();for(int i=1;i<=n;i++) c[i]=qread(),b[i]=qread(),c[i]=max(c[i]-b[i],0ll);\n\t\tfor(int i=1;i<=n;i++) pos[i]=i;sort(pos+1,pos+n+1,cmp);\n\t\tfor(int i=1;i<=m;i++){int x=qread(),y=qread();to[x].PB(y);to[y].PB(x);}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=pos[i];dsu.fa[x]=x;\n\t\t\tfor(int t=0;t<(int)to[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=to[x][t],tt=dsu.findfa(y);\n\t\t\t\tif(dsu.fa[y]!=0 and tt!=x) dsu.fa[tt]=x,son[x].PB(tt);\n\t\t\t}\n\t\t}\n\t\tdp(pos[n]);write(g[pos[n]]);\n    }\n};\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<P, Int> T;\nInt n, k, v,m;\nInt a[216000];\nInt b[216000];\nInt c[216000];\nInt u[216000];\nInt us[216000];\nInt vs[216000];\nInt memo[216000];\nInt sum[216000];\nInt res = 1LL << 40;\nvector<P> edges;\nvector<int> child[108000];\nint init(){\n\tfor(int i = 0;i < 216000;i++)u[i] = i;\n}\n\nint r(int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nint unite(int x, int y){\n\tx = r(x);\n\ty = r(y);\n\tif(x != y)u[y]= x;\n}\n\nint dp(int x){\n\tInt &ans = memo[x];\n\tsum[x] = b[x];\n\tfor(int i = 0;i < child[x].size();i++){\n\t\tint to = child[x][i];\n\t\tdp(to);\n\t\tsum[x] += sum[to];\n\t}\n\tans = c[x] + sum[x];\n\tfor(int i = 0;i < child[x].size();i++){\n\t\tint to = child[x][i];\n\t\tans = min(ans, sum[x] - sum[to] + max(c[x], memo[to]));\n\t}\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i], b[i]);\n\t\tc[i] = a[i] - b[i];\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> us[i] >> vs[i];us[i]--,vs[i]--;\n\t\tedges.push_back(P(max(c[us[i]],c[vs[i]]),i));\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(int i = 0;i < edges.size();i++){\n\t\tint cost = edges[i].first;\n\t\tint ind = edges[i].second;\n\t\tint u = us[ind], v = vs[ind];\n\t\tif(r(u) == r(v))continue;\n\t\tif(c[u] < c[v])swap(u,v);\n\t\tchild[u].push_back(r(v));\n\t\tunite(u, v);\n\t}\n\tcout << dp(r(1)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    ll min_a = 1e18;\n    for (int i = 0; i < cp.size(); i++) min_a = min(min_a, cp[i].first);\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (cp[0].first == min_a)\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvvll in_Graph(ll nodeNum, ll edgeNum, bool isDirected){\n\tvvll to(nodeNum);\n\tREP(i, edgeNum){\n\t\tll v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tto[v].push_back(u);\n\t\tif (!isDirected) to[u].push_back(v);\n\t}\n\treturn std::move(to);\n}\n\nvpll AB;\nvvll to;\n\nstruct UnionFindTree{\n\tvll par;\n\tvll size;\n\tvll cost;\n\tvll Ws;\n\tusing pque = priority_queue<pll, vpll, greater<pll>>;\n\tvector<pque> borderQs;\n\n\tUnionFindTree(ll num): par(num), size(num, 1),\n\t\tcost(num), Ws(num), borderQs(num){\n\t\tREP(i, num) par[i] = i;\n\t}\n\tbool Same(ll x, ll y) { return Root(x) == Root(y); }\n\tll Root(ll x) { return (par[x] == x) ? x : par[x]=Root(par[x]); }\n\tll Size(ll x){ return size[Root(x)]; }\n\tvoid Unite(ll x, ll y){//x勝ち側\n\t\tx = Root(x);\n\t\ty = Root(y);\n\t\tif (x == y) return;\n\t\t//ll c = cost[x];\n\n\t\t//Ws[x]の更新\n\t\tll W;\n\t\tif (Ws[y] == 0){//未発火時\n\t\t\tW = Ws[x] + AB[y].second;\n\t\t}\n\t\telse{\n\t\t\tW = Ws[x] + Ws[y] - cost[y];\n\t\t}\n\t\tWs[x] = W;\n\n\t\t//bordersのマージ\n\t\tif (Ws[y] == 0){//未発火時\n\t\t\tEACH(v, to[y]){\n\t\t\t\tll a, b; tie(a, b) = AB[v];\n\t\t\t\tborderQs[x].push(pll(a-b, v));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpque *bQ, *bQD;\n\t\t\tbQ  = &(borderQs[x]);\n\t\t\tbQD = &(borderQs[y]);\n\t\t\twhile (!bQD->empty()){\n\t\t\t\tbQ->push(bQD->top());\n\t\t\t\tbQD->pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpar[y] = x;\n\t\tsize[x] = size[y] = size[x] + size[y];\n\t}\n};\n\n\nvoid solve()\n{\n\tll N, M;  cin >> N >> M;\n\tAB = cinv2(N);\n\tto = in_Graph(N, M, false);\n\n\tpriority_queue<pll, vpll, greater<pll>> areaQ; //pair<次に進むのに必要なコスト,ノード>\n\tREP(v, N){\n\t\tll a, b; tie(a, b) = AB[v];\n\t\tll c = a-b;\n\t\tareaQ.push(pll(c, v));\n\t}\n\n\tUnionFindTree uft(N);\n\n\tll ans = -1;\n\twhile (!areaQ.empty()){\n\t\tll newc, v; tie(newc,v) = areaQ.top();  areaQ.pop(); //newc:次に進むのに必要なコスト\n\n\t\tif (uft.Ws[v]==0){//未発火時\n\t\t\tuft.cost[v] = max(0LL, newc);\n\t\t\tuft.Ws[v] = max(AB[v].first, AB[v].second);\n\t\t\t//自分の周りを全てbordersに入れる\n\t\t\tEACH(u, to[v]){\n\t\t\t\tll a, b; tie(a, b) = AB[u];\n\t\t\t\tuft.borderQs[v].push(pll(a-b, u));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tll addCost = newc - uft.cost[v];\n\t\t\tuft.Ws[v] += addCost;\n\t\t\tuft.cost[v] += addCost;\n\t\t\t//ll diff = newc - uft.cost[v];\n\t\t\t//uft.Ws[v] += diff;\n\t\t\t//uft.cost[v] = newc;\n\t\t}\n\t\t////自分の周りを全てbordersに入れる\n\t\t//EACH(u, to[v]){\n\t\t//\tll a, b; tie(a, b) = AB[u];\n\t\t//\tuft.borderQs[v].push(pll(a-b, u));\n\t\t//}\n\n\t\twhile (!uft.borderQs[v].empty()){\n\t\t\tll u_c, u; tie(u_c, u) = uft.borderQs[v].top();\n\t\t\tif (u_c > uft.Ws[v]) break;//取り出せない\n\t\t\tuft.borderQs[v].pop();\n\t\t\tif (uft.Same(v, u)) continue;\n\t\t\tuft.Unite(v, u);\n\t\t}\n\n\t\tif (uft.borderQs[v].empty()){\n\t\t\tans = uft.Ws[v];\n\t\t\tbreak;//ans出力へ\n\t\t}\n\n\t\tll needCost = uft.borderQs[v].top().first - uft.Ws[v] + uft.cost[v];\n\t\tareaQ.push(pll(needCost, v));\n\t}\n\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, m, a[100007], b[100007], c[100007], l[100007], f[100007], dp[100007], sum[100007];\nvector<int>e[100007], s[100007];\nbool vis[100007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint cmp(int a, int b)\n{\n\treturn c[a] < c[b];\n}\nint find(int x)\n{\n\tif (f[x] == x)return x;\n\treturn f[x] = find(f[x]);\n}\nint dfs(int w)\n{\n\tsum[w] = b[w];\n\tfor (int i = 0, lim = s[w].size(); i < lim; i++)\n\t\tdfs(s[w][i]), sum[w] += sum[s[w][i]];\n\tdp[w] = sum[w] + c[w];\n\tfor (int i = 0, lim = s[w].size(); i < lim; i++)\n\t\tdp[w] = min(dp[w], sum[w] - sum[s[w][i]] + max(c[w], dp[s[w][i]]));\n\treturn 0;\n}\nsigned main()\n{\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\ta[i] = read();\n\t\tb[i] = read();\n\t\tc[i] = max(a[i] - b[i], 0LL);\n\t\tl[i] = f[i] = i;\n\t}\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint a = read(), b = read();\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tsort(l + 1, l + n + 1, cmp);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint x = l[i];\n\t\tvis[x] = 1;\n\t\tfor (int j = 0, lim = e[x].size(); j < lim; j++)\n\t\t\tif (x != find(e[x][j]) && vis[e[x][j]])\n\t\t\t\ts[x].push_back(find(e[x][j])), f[find(e[x][j])] = x;\n\t}\n\tdfs(l[n]);\n\tcout << dp[l[n]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nvoid unite_que(priority_queue<Pii, vector<Pii>, greater<Pii>> &q1, priority_queue<Pii, vector<Pii>, greater<Pii>> &q2){\n    if(q2.size() > q1.size()) q1.swap(q2);\n    while(!q2.empty()){\n        q1.push(q2.top());\n        q2.pop();\n    }\n}\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, dat;\n    vector<priority_queue<Pii, vector<Pii>, greater<Pii>>> que;\n\n    Union_find(int N, vector<int> v){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        dat = v;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        dat[x] += dat[y];\n        unite_que(que[x], que[y]);\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int v, int w, Union_find &UF){\n        if(UF.union_size(v) > 1) return;\n        while(!UF.que[UF.find(v)].empty()){\n            int par = UF.find(v);\n            Pii p = UF.que[par].top();\n            if(p.first > UF.dat[par] + w) break;\n            UF.que[par].pop();\n            UF.unite(par, p.second);\n        }\n    }\n\n};\n\nvoid init(Graph &G, Union_find &UF, vec &A, int N){\n    UF.que = vector<priority_queue<Pii, vector<Pii>, greater<Pii>>>(N);\n    REP(i, N) REP(k, G.G[i].size()) UF.que[i].push(Pii(A[G.G[i][k].to], G.G[i][k].to));\n}\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    int S = 0;\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        S += B[i];\n        A[i] -= B[i];\n    }\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1, 0);\n    }\n    if(N == 1){\n        cout << max(A[0] + B[0], B[0]) << endl;\n        return 0;\n    }\n\n    int w1 = -1, w2 = 1000000000;\n    while(w2 - w1 > 1){\n        int w = (w1 + w2 + 1) / 2;\n        Union_find UF(N, B);\n        init(G, UF, A, N);\n        REP(i, N) if(w >= A[i]) G.dfs(i, w, UF);\n        //cout << w << \",\" << UF.union_size(0) << endl;\n        if(UF.union_size(0) == N) w2 = w;\n        else w1 = w;\n    }\n    cout << w2 + S << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m, x, y;\nint a[N], b[N];\nint f[N], d[N];\nint F(int x) {\n\treturn f[x] == x ? x : (f[x] = F(f[x]));\n}\n\n#define V vector<int>\n#define pb push_back\n#define si size()\nV e[N];\n\nint cmp(int x, int y) {\n\treturn a[x] - b[x] < a[y] - b[y];\n}\n\nll sumb[N], g[N];\n\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tfo(i, 1, n) scanf(\"%d %d\", &a[i], &b[i]), a[i] = max(0, a[i] - b[i]);\n\tfo(i, 1, m) {\n\t\tscanf(\"%d %d\", &x, &y);\n\t\te[x].pb(y); e[y].pb(x);\n\t}\n\tfo(i, 1, n) f[i] = i, sumb[i] = b[i], g[i] = a[i];\n\tfo(i, 1, n) d[i] = i;\n\tsort(d + 1, d + n + 1, cmp);\n\tfo(i, 1, n) {\n\t\tint x = d[i];\n\t\tff(j, 0, e[x].si) {\n\t\t\tint y = e[x][j];\n\t\t\tif(F(x) != F(y)) {\n\t\t\t\tint u = f[x], v = f[y];\n\t\t\t\tf[v] = u;\n\t\t\t\tsumb[u] += sumb[v];\n\t\t\t\tg[u] = min(g[u], max(g[v], a[u] - sumb[v]));\n\t\t\t} \n\t\t}\n\t}\n\tpp(\"%lld\\n\", g[d[1]] + sumb[d[1]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll N = 100005, inf = 1e9;\n\nll n, m, a[N], b[N], inv[N], s;\n\nvector<ll> adj[N];\npll o[N];\n\nll p[N], v[N];\nbool c[N];\n\nll Find (ll X) {\n\tif(p[X] == X) return X;\n\treturn p[X] = Find(p[X]);\n}\n\nbool can (ll X) {\n\tfor(ll i=1;i<=n;i++) {\n\t\tp[i] = i;\n\t\tv[i] = b[i];\n\t}\n\tfor(ll i=1;i<=n;i++) {\n\t\tll I = o[i].Y;\n\t\tc[I] = (a[I]-b[I] <= X);\n\t\tfor(auto &T : adj[I]) {\n\t\t\tif(inv[T] >= i) continue;\n\t\t\tT = Find(T);\n\t\t\tif(c[T] && a[I]-b[I] <= v[T] + X) c[I] = true;\n\t\t\tv[I] += v[T];\n\t\t\tp[T] = I;\n\t\t}\n\t}\n\treturn c[Find(1)];\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\to[i] = {a[i]-b[i], i};\n\t\ts += b[i];\n\t}\n\tsort(o+1, o+1+n);\n\tfor(ll i=1;i<=n;i++) {\n\t\tinv[o[i].Y] = i;\n\t}\n\tfor(ll i=1;i<=m;i++) {\n\t\tll A, B;\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tll S = 0, E = inf;\n\twhile(S<E) {\n\t\tll M = (S+E)/2;\n\t\tcan(M) ? E = M : S = M+1;\n\t}\n\tprintf(\"%lld\\n\",S+s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nstruct Edge\n{\n\tint to;\n\tint nxt;\n}edge[MAXN << 1];\n\nint n,m,id;\nint first[MAXN];\nint fa[MAXN];\n\npair<int,int> p[MAXN];\n\nll f[MAXN];\nll a[MAXN];\nll b[MAXN];\nll sum[MAXN];\nll suf[MAXN];\n\nbool vis[MAXN];\n\nint getroot(int u)\n{\n\treturn u == fa[u] ? u : fa[u] = getroot(fa[u]);\n}\n\nvoid addE(int u,int v)\n{\n\tedge[++id] = (Edge){v,first[u]};\n\tfirst[u] = id;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i] = max(0ll,a[i] - b[i]);\n\t\tp[i] = make_pair(a[i],i);\n\t}\n\tfor (int u,v,i = 1;i <= m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddE(u,v);\n\t\taddE(v,u);\n\t}\n\tsort(p + 1,p + n + 1);\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tfa[i] = i;\n\t\tsum[i] = b[i];\n\t}\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tint u = p[i].second;\n\t\tvis[u] = 1;\n\t\tvector<pair<ll,ll> > t;\n\t\tfor (int j = first[u];j;j = edge[j].nxt)\n\t\t{\n\t\t\tint v = edge[j].to;\n\t\t\tif (vis[v] && getroot(v) != u)\n\t\t\t{\n\t\t\t\tt.push_back(make_pair(f[getroot(v)] - sum[getroot(v)],sum[getroot(v)]));\n\t\t\t\tsum[u] += sum[getroot(v)];\n\t\t\t\tfa[getroot(v)] = u;\n\t\t\t}\n\t\t}\n\t\tsort(t.begin(),t.end());\n\t\tif (!t.size())\n\t\t{\n\t\t\tf[u] = a[u] + b[u];\n\t\t\tcontinue;\n\t\t}\n\t\tsuf[t.size()] = 0;\n\t\tll all = 0;\n\t\tfor (int j = t.size() - 1;j >= 0;j--)\n\t\t{\n\t\t\tsuf[j] = max(t[j].first + t[j].second,suf[j + 1] + t[j].second);\n\t\t\tall += t[j].second;\n\t\t}\n\t\tll sum = 0,tot = 0;\n\t\tf[u] = 1e18;\n\t\tfor (int j = 0;j < t.size();j++)\n\t\t{\n\t\t\tf[u] = min(f[u],max(max(tot,sum + suf[j + 1]),max(all - t[j].second + a[u] + b[u],all + b[u] + t[j].first)));\n\t\t\ttot = max(tot,sum + t[j].first + t[j].second);\n\t\t\tsum += t[j].second;\n\t\t}\n\t\tif (t.size() == 1)\n\t\t\tf[u] = min(f[u],max(a[u] + b[u],b[u] + t[0].first + t[0].second));\n\t}\n\tprintf(\"%lld\\n\",f[getroot(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint A[111111],B[111111];\n\nvint G[111111];\n\nstruct UnionFindTree{\n    vector<int>par,sz,sumB,ans;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        sumB.resize(n);\n        ans.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        sumB[x]+=sumB[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,N){\n        cin>>A[i]>>B[i];\n        chmax(A[i],B[i]);\n    }\n    rep(i,M){\n        int a,b;cin>>a>>b;a--;b--;G[a].pb(b);G[b].pb(a);\n    }\n\n    vpint lis;\n    rep(i,N)lis.pb({A[i]-B[i],i});\n    sort(all(lis));\n\n    UnionFindTree uf(N);\n    rep(i,N){\n        int v=lis[i].se;\n\n        int uku=lis[i].fi;\n        uf.sumB[v]=B[v];\n        for(auto u:G[v]){\n            if(uf.sumB[uf.find(u)]==0||uf.areSame(u,v))continue;\n            int tmp=uf.ans[uf.find(u)];\n            chmax(tmp,lis[i].fi-uf.sumB[uf.find(u)]);\n            chmin(uku,tmp);\n            uf.unite(v,u);\n        }\n        uf.ans[uf.find(v)]=uku;\n    }\n\n    cout<<uf.ans[uf.find(lis.back().se)]+accumulate(B,B+N,0ll)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing LL = long long;\n\nconst int N = 100000;\n\nstruct Info\n{\n    LL sum, need;\n};\n\nint n, m, a[N], b[N], ord[N], par[N];\nInfo info[N];\nstd::vector<int> graph[N];\n\nbool by_a(int i, int j)\n{\n    return a[i] < a[j];\n}\n\nint find(int u)\n{\n    if (par[u] != u) {\n        par[u] = find(par[u]);\n    }\n    return par[u];\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\n#endif\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d%d\", a + i, b + i);\n        ord[i] = i;\n    }\n    for (int i = 0; i < m; ++ i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        u --;\n        v --;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    std::sort(ord, ord + n, by_a);\n    LL need = 0;\n    memset(par, -1, sizeof(par));\n    for (int idx = 0; idx < n; ++ idx) {\n        int r = ord[idx];\n        par[r] = r;\n        std::vector<Info> sons;\n        LL tot_sum = 0;\n        for (int v : graph[r]) {\n            if (~par[v] && find(r) != find(v)) {\n                int u = find(v);\n                sons.push_back(info[u]);\n                tot_sum += info[u].sum;\n                par[u] = r;\n            }\n        }\n        need = tot_sum + std::max(a[r], b[r]);\n        for (auto s : sons) {\n            need = std::min(need, tot_sum - s.sum + std::max((LL)a[r], s.need + b[r]));\n        }\n        info[r].sum = tot_sum + b[r];\n        info[r].need = need;\n    }\n    printf(\"%lld\\n\", need);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 100005;\nconst long long inf = 1000000000000000ll;\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt;\n} graph[M << 1];\nint n, m, head[N], id[N], fa[N], cnt = 0;\nlong long a[N], b[N], f[N], g[N];\npair<int, int> vec[N];\n\nvoid addedge (int u, int v) {\n\tedge e = {v, head[u]};\n\tgraph[head[u] = cnt++] = e;\n}\n\nint findroot (int x) {\n\treturn fa[x] == x ? x : fa[x] = findroot(fa[x]);\n}\n\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) fa[i] = i, head[i] = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(a[i]), read(b[i]);\n\t\ta[i] = max(a[i] - b[i], 0ll);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\taddedge(u, v);\n\t\taddedge(v, u);\n\t}\n\n\tfor (int i = 1; i <= n; i++) vec[i] = make_pair(a[i], i);\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) id[vec[i].second] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u = vec[i].second;\n\t\tvector<int> child;\n\t\tf[u] = inf, g[u] = b[u];\n\t\tfor (int j = head[u]; ~j; j = graph[j].nxt) {\n\t\t\tint v = graph[j].to, rv = findroot(v);\n\t\t\tif (id[v] < id[u] && rv != u) {\n\t\t\t\tfa[rv] = u, g[u] += g[rv];\n\t\t\t\tchild.push_back(rv);\n\t\t\t}\n\t\t}\n\n\t\tf[u] = min(f[u], a[u] + g[u]);\n\t\tfor (int j = 0; j < child.size(); j++) {\n\t\t\tint v = child[j];\n\t\t\tf[u] = min(f[u], max(a[u], f[v]) + g[u] - g[v]);\n\t\t}\n\t}\n\n\twrite(f[vec[n].second]), putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],rk[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(const int&x,const int&y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:par[x]=getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tsort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)rk[id[i]]=i;\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&rk[y]<i) par[y]=x,T[x].pb(y);\n\t}\n\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define pb push_back\n#define mp make_pair\n#define Chkmax(a,b) a=a>b?a:b\n#define Chkmin(a,b) a=a<b?a:b\ntypedef unsigned long long uint64;\ntypedef unsigned int uint32;\ntypedef long long ll;\n\nusing namespace std;\n\nnamespace IO\n{\n    const uint32 Buffsize=1<<15,Output=1<<23;\n    static char Ch[Buffsize],*S=Ch,*T=Ch;\n    inline char getc()\n    {\n        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);\n    }\n    static char Out[Output],*nowps=Out;\n    \n    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}\n\n    template<typename T>inline void read(T&x)\n    {\n        x=0;static char ch;T f=1;\n        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;\n        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);\n        x*=f;\n    }\n\n    template<typename T>inline void write(T x,char ch='\\n')\n    {\n        if(!x)*nowps++='0';\n        if(x<0)*nowps++='-',x=-x;\n        static uint32 sta[111],tp;\n        for(tp=0;x;x/=10)sta[++tp]=x%10;\n        for(;tp;*nowps++=sta[tp--]^48);\n        *nowps++=ch;\n    }\n}\nusing namespace IO;\n\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n    FILE*DSA=freopen(\"water.in\",\"r\",stdin);\n    FILE*SDU=freopen(\"water.out\",\"w\",stdout);\n#endif\n}\n\nconst int MAXN=1e5+7;\n\nstatic int n,m;\n\nvector<int>ed[MAXN];\n\nstatic int a[MAXN],b[MAXN];\n\nvoid init()\n{\n\tread(n);read(m);\n\tRep(i,1,n)read(a[i]),read(b[i]),a[i]=max(0,a[i]-b[i]);\n\tstatic int u,v;\n\tRep(i,1,m)read(u),read(v),ed[u].pb(v),ed[v].pb(u);\n}\n\nstatic ll dp[MAXN],sm[MAXN];\n\nstatic int fa[MAXN],sta[MAXN];\n\ninline int Find(int u){return u==fa[u]?u:fa[u]=Find(fa[u]);}\n\ninline void getdp(int u)\n{\n\tsm[u]=b[u];dp[u]=a[u];\n\tfor(register int v:ed[u])\n\t{\n\t\tint ver=Find(v);\n\t\tif(ver!=u&&a[ver]<=a[u])\n\t\t{\n\t\t\tChkmin(dp[u],max(dp[ver],a[u]-sm[ver]));\n\t\t\tsm[u]+=sm[ver];\n\t\t\tfa[ver]=u;\n\t\t}\n\t}\n}\n\ninline bool cmp(int x,int y){return a[x]<a[y];}\n\ninline void solve()\n{\n\tRep(i,1,n)fa[i]=sta[i]=i;sort(sta+1,sta+n+1,cmp);\n\ta[0]=-1;\n\tRep(i,1,n)getdp(sta[i]);\n\tcout<<sm[sta[n]]+dp[sta[n]]<<endl;\n}\n\nint main()\n{\n\tinit();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            const int V = S[top[uf.find(to)]];\n            if (V < S[i]) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    std::vector<ll> s(N, 0LL), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        std::set<int> used;\n        for (const int to : T[v]) {\n            assert(used.find(to) == used.end());\n            used.insert(to);\n            self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]);\n        }\n        f[v] += s[v];\n    };\n    std::vector<int> R;\n    for (int i = 0; i < N; i++) {\n        if (T.rev_edge[i].empty()) { R.push_back(i); }\n    }\n    ll ans = 0;\n    for (const int r : R) {\n        if (T.edge[r].empty()) { continue; }\n        dfs(dfs, r), SHOW(r, f[r]), ans += f[r];\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n//const int inf = 0x3f3f3f3f,oo = inf;\nconst ll inf = 0x3f3f3f3f3f3f3f3f;\n#define pi 3.14159265358979323846\n#define IL inline\n#define RG register\n#define rep(i,a,b) for(RG int i=(a);i<int(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define Dep(i,a,b) for(RG int i=(a);i>=(b);--i)\n#define pc putchar\n#define gc getchar\nIL ll read(){\n    RG ll x=0;char f=0;RG char c=gc();\n    for(;!isdigit(c);c=gc())f|=(c=='-');\n    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n    return f?-x:x;\n}\nIL double readdb(){\n    RG double x=0,p=0.1;RG char f=0,c=gc();\n    for(;!isdigit(c);c=gc())f|=(c=='-');\n    for(;isdigit(c);c=gc())x=x*10+(c^48);\n    if(c=='.')for(c=gc();isdigit(c);c=gc(),p/=10)x=x+(c^48)*p;\n    return f?-x:x;\n}\nIL void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);pc(x%10+'0');}\nIL void writeln(ll x){write(x);puts(\"\");}\nIL void writeln(ll x,char c,ll y){write(x);pc(c);writeln(y);}\nIL void writeln(ll x,char c,ll y,char d,ll z){write(x);pc(c);write(y);pc(d);writeln(z);}\n#undef gc\n#undef pc\n#define debug(x) printf(#x\" = %d\\n\",x);\n#define rd() read()\n#define rdb() readdb()\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define fin(x) freopen(#x\".in\",\"r\",stdin)\n#define fout(x) freopen(#x\".out\",\"w\",stdout)\n#define y1 ____y1\n#define hash __hash\n#define union _union\n#define int ll\n#define fi first\n#define se second\nconst int maxn = 1e5+233;\nstruct node{\n\tint a,b,id;\n\tbool operator < (const node &w) const{\n\t\treturn a < w.a;\n\t}\n}p[maxn];\nint a[maxn],b[maxn],sum[maxn],fa[maxn];\nvector<int> edge[maxn];\nint vis[maxn],cur[maxn],ans[maxn];\nint n,m;\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nsigned main(){\n\tn = read();m = read();\n\tRep(i,1,n){\n\t\ta[i] = rd();\n\t\tb[i] = rd();\n\t\ta[i] = max(a[i],b[i]);\n\t\tsum[i] = b[i];\n\t\tp[i] = (node){a[i],b[i],i};\n\t}\n\tRep(i,1,m){\n\t\tint x = rd(),y = rd();\n\t\tedge[x] . push_back(y);\n\t\tedge[y] . push_back(x);\n\t}\n\tRep(i,1,n){\n\t\tfa[i] = i;\n\t\tans[i] = inf;\n\t} \n\tsort(p+1,p+1+n);\n\tint j;\n\tfor(int i=1;i<=n;i=j+1){\n\t\tj=i;for(;j+1<=n && p[i].a == p[j+1].a;++j);\n\t\tRep(k,i,j) vis[p[k].id] = i;\n\t\tRep(k,i,j){\n\t\t\tint u = p[k].id;\n\t\t\trep(e,0,edge[u].size()){\n\t\t\t\tint v = edge[u][e];\n\t\t\t\tif(!vis[v]) continue;\n\t\t\t\tcur[v] = find(v);\n\t\t\t}\n\t\t} \n\t\tRep(k,i,j){\n\t\t\tint u = p[k].id;\n\t\t\trep(e,0,edge[u].size()){\n\t\t\t\tint v = find(edge[u][e]);\n\t\t\t\tif(!vis[find(v)] || find(u)==v) continue;\n\t\t\t\tfa[v] = find(u);\n\t\t\t\tsum[find(u)]+=sum[v];\n\t\t\t}\n\t\t} \n\t\tRep(k,i,j){\n\t\t\tint u = p[k].id;\n\t\t\trep(e,0,edge[u].size()){\n\t\t\t\tint v = cur[edge[u][e]];\n\t\t\t\tif(!vis[v] || vis[v]==i) continue;\n\t\t\t\tll cost=max(a[u],ans[v]+b[u])+sum[find(u)]-sum[v]-b[u];\n\t\t\t\tans[find(u)] = min(ans[find(u)],cost);\n\t\t\t}\n\t\t\tans[find(u)] = min(ans[find(u)],a[find(u)] + sum[find(u)] - b[u]);\n\t\t}\n\t}writeln(ans[find(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 100001\nusing namespace std;\nint a[N],b[N],c[N],d[N],e[N],g[N],f[N],m,n;long long h[N],x;\ninline bool cmp(int u,int v){return g[a[u]]==g[a[v]]?a[u]<a[v]:g[a[u]]<g[a[v]];}\nint find(int u)\n{\n\tif(!f[u])return u;\n\tint v=find(f[u]);\n\treturn e[u]=max(e[u],e[f[u]]),f[u]=v;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),x=0x7fffffffffffffffll;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%lld\",g+i,h+i),g[i]=g[i]<h[i]?0:g[i]-h[i];\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",a+i,b+i),c[i]=i,g[a[i]]<g[b[i]]||g[a[i]]==g[b[i]]&&a[i]>b[i]?a[i]^=b[i]^=a[i]^=b[i]:0;\n\tsort(c+1,c+m+1,cmp);\n\tfor(int i=1,u;i<=m;i++)if(a[c[i]]!=(u=find(b[c[i]])))e[u]=max((long long)e[u],g[a[c[i]]]-h[u]),f[u]=a[c[i]],h[a[c[i]]]+=h[u];\n\tfor(int i=1;i<=n;i++)x=min(x,max(g[i],e[i])+h[find(i)]);\n\treturn 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, M;\n#define MAXN 100000\nlong long B[MAXN], C[MAXN];\ntypedef tuple<pair<long long, int>, int, int> T;\nvector<T> E;\n\nint Rank[MAXN], Par[MAXN], Boss[MAXN];\nvector<int> Kids[MAXN]; int Root;\n\ntypedef pair<long long, long long> P;\n\nvoid init() {\n  for(int v = 0; v < N; ++v) {\n    Rank[v] = 0; Par[v] = Boss[v] = v;\n  }\n}\nint find(int v) {\n  if(Par[v] == v) return v;\n  else return Par[v] = find(Par[v]);\n}\nvoid unite(int u, int v) {\n  u = find(u); v = find(v);\n  if(u == v) return;\n  if(Rank[u] > Rank[v]) swap(u, v);\n  Par[u] = v;\n  if(Rank[u] == Rank[v]) ++Rank[v];\n  if(make_pair(C[Boss[u]], Boss[u])\n      > make_pair(C[Boss[v]], Boss[v])) {\n    Kids[Boss[u]].push_back(Boss[v]);\n    Boss[v] = Boss[u];\n  } else {\n    Kids[Boss[v]].push_back(Boss[u]);\n  }\n  Root = Boss[v];\n}\n\nP dp(int v) {\n  long long b = B[v];\n  vector<P> ps;\n  for(int w : Kids[v]) {\n    auto p = dp(w);\n    ps.push_back(p); b += p.second;\n  }\n  long long q = C[v] + b;\n  for(int i = 0; i < (int)ps.size(); ++i) {\n    q = min(q, max(ps[i].first, C[v]) + b - ps[i].second);\n  }\n  return {q, b};\n}\n\nint main() {\n  cin >> N >> M;\n  for(int v = 0; v < N; ++v) {\n    long long a, b; cin >> a >> b;\n    B[v] = b; C[v] = max(a - b, 0LL);\n  }\n  for(int e = 0; e < M; ++e) {\n    int u, v; cin >> u >> v; --u; --v;\n    E.emplace_back(\n      max(make_pair(C[u], u), make_pair(C[v], v)),\n      u, v);\n  }\n  sort(E.begin(), E.end());\n  init();\n  for(int e = 0; e < M; ++e) {\n    unite(get<1>(E[e]), get<2>(E[e]));\n  }\n  cout << dp(Root).first << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    bool operator< (const Info &t) const {return cost < t.cost;}\n};\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nvoid unlock(int x) ;\nvoid merge(int x , int y) ;\n\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) unlock(y);\n            else {\n                out[p].insert(y);\n                modifycost(y , (int)max(limit[y] - money[p] , 0LL));                \n            }\n        }\n    }\n}\n\n\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n    while(out[y].size()) {\n        x = *out[y].begin();\n        if(find(x) == y) {\n            out[y].erase(*out[y].begin());\n            continue;\n        }\n        if(money[y] + init >= limit[x]) {\n            out[y].erase(*out[y].begin());\n            unlock(x);\n            y = find(y);\n            continue;\n        }\n        modifycost(x , (int)max(limit[x] - money[y] , 0LL));\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\nstruct edge{int x,y,w;}e[MN+5];\nbool cmp(const edge&a,const edge&b){return a.w<b.w;}\nint a[MN+5],b[MN+5],f[MN+5];long long s[MN+5],ss[MN+5];\nint gf(int k){return f[k]?f[k]=gf(f[k]):k;}\nint main()\n{\n\tint n,m,i;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d%d\",&a[i],&b[i]),s[i]=max(a[i],b[i]),ss[i]=b[i];\n\tfor(i=1;i<=m;++i)scanf(\"%d%d\",&e[i].x,&e[i].y),e[i].w=max(a[e[i].x]-b[e[i].x],a[e[i].y]-b[e[i].y]);\n\tsort(e+1,e+m+1,cmp);\n\tfor(i=1;i<=m;++i)if((e[i].x=gf(e[i].x))!=(e[i].y=gf(e[i].y)))\n\t{\n\t\ts[e[i].x]=min(max(s[e[i].x],1LL*e[i].w)+ss[e[i].y],max(s[e[i].y],1LL*e[i].w)+ss[e[i].x]);\n\t\tss[e[i].x]+=ss[e[i].y];\n\t\tf[e[i].y]=e[i].x;\n\t}\n\tprintf(\"%lld\",s[gf(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] <= cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint A[N],B[N],fa[N],id[N],to[N << 1],nex[N << 1],beg[N],vis[N];\nll Sum[N],dp[N];\nint e;\n\nbool Cmp(const int &lhs,const int &rhs) {\n\treturn A[lhs] < A[rhs];\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\ninline int find(int x) {\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read(),m = read();\n\tFor(i,1,n) {\n\t\tA[i] = read(),B[i] = read(),A[i] = max(A[i] - B[i],0);\n\t\tfa[i] = id[i] = i,Sum[i] = B[i],dp[i] = A[i];\n\t}\n\tFor(i,1,m) {\n\t\tint x = read(),y = read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tsort(id + 1,id + n + 1,Cmp);\n\tFor(i,1,n) {\n\t\tvis[id[i]] = true;\n\t\tfor(int j = beg[id[i]];j;j = nex[j]) {\n\t\t\tif(!vis[to[j]]) continue;\n\t\t\tint x = find(id[i]),y = find(to[j]);\n\t\t\tif(x == y) continue;\n\t\t\tfa[y] = x,Sum[x] += Sum[y];\n\t\t\tchkmin(dp[x],max(dp[y],A[x] - Sum[y]));\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",dp[id[n]] + Sum[id[n]]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n, m;\nvector<int> g[N];\nint a[N], b[N];\nint p[N];\nbool used[N];\nlong long sum[N];\npriority_queue<pair<int, int> > st[N];\n\nint find(int x) { return p[x] < 0 ? x : p[x] = find(p[x]); }\n\n\nbool can(long long x) {\n  for (int i = 0; i < n; ++i) {\n    while (!st[i].empty())\n      st[i].pop();\n    for (int u : g[i])\n      st[i].push(make_pair(-a[u], u));\n    sum[i] = b[i];\n  }\n  fill(p, p+n, -1);\n  fill(used, used+n, 0);\n  int cnt = 0;\n  stack<int> stak;\n  for (int i = 0; i < n; ++i) {\n    if (x >= a[i]) {\n      stak.push(i);\n      used[i] = 1;\n    }\n  }\n  // cerr << \" cek \" << x << endl;\n  while (!stak.empty()) {\n    int v = stak.top();\n    stak.pop();\n    v = find(v);\n    // cerr << \" sumber \" << v << endl;\n    while (!st[v].empty()) {\n      auto it = st[v].top();\n      int u = it.second;\n      if (a[u] > sum[v] + x) break;\n      st[v].pop();\n      used[u] = 1;\n      u = find(u);\n      // cerr << \" tambah \" << u << endl;\n      if (u == v) continue;\n      if (st[u].size() > st[v].size()) swap(u, v);\n      while (!st[u].empty()) {\n        st[v].push(st[u].top());\n        st[u].pop();\n      }\n      sum[v] += sum[u];\n      p[u] = v;\n    }\n  }\n  for (int i = 0; i < n; ++i) if (!used[i]) return false;\n  return true;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i)\n    scanf(\"%d %d\", a+i, b+i);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v); --u, --v; \n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  long long lo = 0, hi = 0;\n  for (int i = 0; i < n; ++i)\n    a[i] -= b[i];\n  for (int i = 0; i < n; ++i)\n    if (a[i] > hi) hi = a[i];\n  long long all = 0;\n  for (int i = 0; i < n; ++i)\n    all += b[i];\n  while (lo < hi) {\n    long long mid = (lo + hi) >> 1;\n    if (can(mid))\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  // cerr << lo << endl;\n  printf(\"%lld\\n\", lo+all);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\n#define sz(v) ((int)v.size())\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstruct func{\n\tlint out;\n\tlint B, A; // f(W) = max(W + B, A)\n};\n\nint n, m, a[MAXN], b[MAXN];\nvector<int> gph[MAXN];\nfunc val[MAXN];\n\nstruct edg{\n\tint s, e, x;\n\tbool operator<(const edg &ed)const{\n\t\treturn e < ed.e;\n\t}\n}ed[MAXN];\n\nint rev[MAXN];\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\ta[i] = max(a[i], b[i]);\n\t}\n\tvector<int> ord(n);\n\tiota(ord.begin(), ord.end(), 1);\n\tsort(ord.begin(), ord.end(), [&](const int &x, const int &y){\n\t\treturn a[x] - b[x] < a[y] - b[y];\n\t});\n\tfor(int i=0; i<sz(ord); i++) rev[ord[i]] = i;\n\tfor(int i=0; i<m; i++){\n\t\tscanf(\"%d %d\",&ed[i].s,&ed[i].e);\n\t\ted[i].s = rev[ed[i].s];\n\t\ted[i].e = rev[ed[i].e];\n\t\tif(ed[i].s > ed[i].e) swap(ed[i].s, ed[i].e);\n\t}\n\tsort(ed, ed + m);\n\tdisj.init(n);\n\tfor(int i=0; i<m; i++){\n\t\ted[i].s = ord[ed[i].s];\n\t\ted[i].e = ord[ed[i].e];\n\t\tif(disj.uni(ed[i].s, ed[i].e)){\n\t\t\tgph[ed[i].e].push_back(ed[i].s);\n\t\t}\n\t}\n\tdisj.init(n);\n\tfor(auto &x : ord){\n\t\tvector<func> vect;\n\t\tfor(auto &i : gph[x]){\n\t\t\tint p = disj.find(i);\n\t\t\tvect.push_back(val[p]);\n\t\t}\n\t\tif(vect.empty()){\n\t\t\tval[x] = (func){a[x], b[x], a[x]};\n\t\t\tcontinue;\n\t\t}\n\t\tlint bsum = 0;\n\t\tfor(auto &i : vect) bsum += i.B;\n\t\tfunc ret = {(lint)1e18, b[x] + bsum, a[x] + bsum};\n\t\tfor(auto &i : vect){\n\t\t\tlint cur_out = max(i.out + b[x], 1ll * a[x]);\n\t\t\tcur_out += bsum - i.B;\n\t\t\tret.out = min(ret.out, cur_out);\n\t\t}\n\t//\tprintf(\"%d = %lld %lld %lld\\n\", x, ret.A, ret.B, ret.out);\n\t\tfor(auto &i : gph[x]) disj.uni(i, x);\n\t\tval[disj.find(x)] = ret;\n\t}\n\tcout << val[disj.find(ord.back())].out << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nvoid optimize_cpp_stdio() {\n    std::ios::sync_with_stdio(false);\n    std::cout.tie(nullptr);\n    std::cin.tie(nullptr);\n}\n\nint main() {\n    optimize_cpp_stdio();\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i] >> b[i];\n        c[i] = std::max(a[i] - b[i], 0);\n    }\n    std::vector<std::vector<int>> G(n);\n    for (int i = 0, u, v; i < m; i++) {\n        std::cin >> u >> v;\n        G[--u].push_back(--v);\n        G[v].push_back(u);\n    }\n    std::vector<int> parent(n);\n    std::iota(parent.begin(), parent.end(), 0);\n    std::function<int(int)> find = [&](int x) {\n        return x == parent[x] ? x : parent[x] = find(parent[x]);\n    };\n    std::vector<int> sorted(n);\n    std::iota(sorted.begin(), sorted.end(), 0);\n    std::sort(sorted.begin(), sorted.end(), [&](int lhs, int rhs) {\n        return c[lhs] < c[rhs];\n    });\n    std::vector<bool> vis(n);\n    std::vector<int> dp = c, cost = b;\n    for (int u : sorted) {\n        vis[u] = true;\n        for (int v : G[u]) {\n            v = find(v);\n            if (not vis[v] || u == v) continue;\n            parent[v] = u;\n            cost[u] += cost[v];\n            dp[u] = std::min(dp[u], std::max(dp[v], c[u] - cost[v]));\n        }\n    }\n    int root = sorted.back();\n    std::cout << dp[root] + cost[root] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,t) for(int i=s;i<=(t);++i) \nusing namespace std; \n\nconst int N=1e5+50; \n\nbool vis[N]; \nint n,m,a[N],b[N],p[N],id[N]; \nlong long sum[N],f[N]; \nvector<int> g[N];\n\nint find(int x){ return p[x]==x?x:p[x]=find(p[x]); }\n\nint main(int argc,char *argv[]){\n\tscanf(\"%d%d\",&n,&m); \n\trep(i,1,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]); \n\t\ta[i]=max(0,a[i]-b[i]); \n\t\tsum[i]=b[i];\n\t}\n\trep(i,1,m){\n\t\tint u,v; \n\t\tscanf(\"%d%d\",&u,&v); \n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\trep(i,1,n)p[i]=i,id[i]=i;\n\tsort(id+1,id+n+1,[](int x,int y){ return a[x]<a[y]; }); \n\trep(k,1,n){\n\t\tint v=id[k]; \n\t\tvis[v]=true;\n\t\tvector<int> son;\n\t\tfor(int d:g[v])if(vis[d]&&find(d)!=find(v)){\n\t\t\tsum[v]+=sum[find(d)];\n\t\t\tson.push_back(find(d)); \n\t\t\tp[find(d)]=find(v); \n\t\t}\n\t\tf[v]=sum[v]+a[v];\n\t\t\n\t\tfor(int d:son){\n\t\t\tf[v]=min(f[v],sum[v]-sum[d]+max(1ll*a[v],f[d])); \n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[id[n]]);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    vector<int> sc(cp.size(), 0);\n    sc[0] = 1;\n    for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[0].first - cp[0].second) sc[j] = 1;\n    sc[sc.size() - 1] = 1;\n    for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[cp.size() - 1].first - cp[cp.size() - 1].second) sc[j] = 1;\n    for (int i = 1; i + 1 < cp.size(); i++)\n    {\n        if (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second)\n        {\n            sc[i] = 1;\n            for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[i].first - cp[i].second) sc[j] = 1;\n        }\n        if (a[v] - b[v] < cp[i].first - cp[i].second && a[v] - b[v] >= cp[i - 1].first - cp[i - 1].second)\n        {\n            sc[i] = 1;\n            for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[i].first - cp[i].second) sc[j] = 1;\n        }\n    }\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (sc[i])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nstruct edge{\n\tint to,next;\n}e[N*2];\nint n,m,tot,head[N];\nint a[N],b[N],id[N],fa[N];\nlong long qd[N],S[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint get(int x){\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint vis[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tid[i]=i,fa[i]=i,qd[i]=a[i],S[i]=b[i]; \n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint x=id[i]; vis[x]=1;\n\t\tfor (int j=head[x];j;j=e[j].next)\n\t\t\tif (vis[e[j].to]){\n\t\t\t\tint X=get(x),Y=get(e[j].to);\n\t\t\t\tif (X==Y) continue;\n\t\t\t\tfa[Y]=X; S[X]+=S[Y];\n\t\t\t\tqd[X]=min(qd[X],qd[Y]+max(0ll,a[x]-S[Y]-qd[Y]));\n\t\t\t}\n\t}\n\tint x=get(1);\n\tprintf(\"%lld\",qd[x]+S[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inc(l,i,r) for (int i=l;i<=r;i++)\n#define dec(r,i,l) for (int i=r;i>=l;i--)\n#define SIZE(V) ((int) V.size())\n#define forE(p,u) for (edge *p=head[u];p;p=p->nxt)\n#define forV(i,V) for (int i=0;i<SIZE(V);i++)\n#define pb push_back\n#define In inline\n#define fi first\n#define se second\n#define mp make_pair\n#define It iterator\n#define ___ putchar(10);\n#define cnt(x) __builtin_popcount(x)\n#define show(x) cout << #x << \" = \" << x << endl;\n#define mid ((l+r) >> 1)\n#define N 100100\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate<typename T>\ninline void read(T &x) {\n\tstatic char c;\n\tfor (c=getchar();!isdigit(c);c=getchar());\n\tfor (x=0;isdigit(c);c=getchar()) x = (x<<1) + (x<<3) + c - '0';\n}\n\nstruct edge {int to;  edge *nxt;} *head[N], e[N];\n\nint edge_tot = 0;\ninline void AE(int u,int v) {\n\thead[u] = &(e[edge_tot++] = (edge) {v,head[u]});\n\thead[v] = &(e[edge_tot++] = (edge) {u,head[v]});\n}\n\nint n, m, A[N], B[N], fa[N];\npii a[N];\nll sumB[N], dp[N];\nvector<int> T[N];\n\nint getfa(int x) {return fa[x] == x ? x : fa[x] = getfa(fa[x]);}\ninline void merge(int x,int y) {fa[getfa(x)] = getfa(y);}\n\nvoid dfs(int u,int from) {\n\tsumB[u] = B[u];\n\tdp[u] = A[u];\n\tforE(p,u) if (p->to != from) {\n\t\tdfs(p->to,u);\n\t\tsumB[u] += sumB[p->to];\n\t\tdp[u] = min(dp[u], max(dp[p->to], A[u] - sumB[p->to]));\n\t}\n}\n\nint main() {\n//\tfreopen(\"rescue.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tread(n);   read(m);\n\tinc(1,i,n) read(A[i]), read(B[i]), a[i] = mp(A[i]-B[i],i), A[i] = max(A[i]-B[i], 0);\n\twhile (m--) {\n\t\tint u, v;  read(u);  read(v);\n\t\tAE(u,v);\n\t}\n\tsort(a+1,a+n+1);\n\t\n\tinc(1,i,n) {\n\t\tfa[a[i].se] = a[i].se;\n\t\tforE(p,a[i].se)\tif (fa[p->to] && getfa(p->to) != getfa(a[i].se)) {\n\t\t\tT[a[i].se].pb(getfa(p->to));\n\t\t\tmerge(p->to, a[i].se);\n\t\t}\n\t}\n\tedge_tot = 0;\n\tmemset(head,0,sizeof(edge*) * (n+1));\n\tinc(1,i,n) forV(j,T[i]) AE(i,T[i][j]);\n\t\n\tdfs(a[n].se, 0);\n\t\n\tprintf(\"%lld\\n\",dp[a[n].se] + sumB[a[n].se]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#include <ext/pb_ds/tree_policy.hpp>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/rope>\n//using namespace __gnu_pbds;\n//using namespace __gnu_cxx;\n//\n//template<class T> using Tree = tree<T, null_type, less<T>, rb_t_tag,t_order_statistics_node_update>;\n/***********************************************/\n/* Dear online judge:\n * I've read the problem, and tried to solve it.\n * Even if you don't accept my solution, you should respect my effort.\n * I hope my code compiles and gets accepted.\n *  ___  __     _______    _______      \n * |\\  \\|\\  \\  |\\  ___ \\  |\\  ___ \\     \n * \\ \\  \\/  /|_\\ \\   __/| \\ \\   __/|    \n *  \\ \\   ___  \\\\ \\  \\_|/__\\ \\  \\_|/__  \n *   \\ \\  \\\\ \\  \\\\ \\  \\_|\\ \\\\ \\  \\_|\\ \\ \n *    \\ \\__\\\\ \\__\\\\ \\_______\\\\ \\_______\\\n *     \\|__| \\|__| \\|_______| \\|_______|\n */\nconst long long mod = 1000000007;\n//const long long mod = 998244353;\n\n// watch this\n//using ll = long long;\n//typedef long long LL;\n#define ll long long\n#undef ll\n\nconst int mxN = 100010;\n\nvector<int> g[mxN];\nvector<int> tree[mxN];\n\nstruct DSU {\n\tvector<int> p, sz;\n\tDSU(int N) {\n\t\tp.resize(N);\n\t\tsz.resize(N, 1);\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tp[i] = i;\n\t}\n\tint par(int x) {\n\t\tif (x == p[x])\n\t\t\treturn x;\n\t\treturn p[x] = par(p[x]);\n\t}\n\tbool mrg(int x, int y) {\n\t\tx = par(x), y = par(y);\n\t\tif (x == y)\n\t\t\treturn false;\n//\t\tif (sz[x] < sz[y]) {\n//\t\t\tswap(x, y);\n//\t\t}\n\t\tp[y] = p[x];\n\t\tsz[x] += sz[y];\n\t\treturn true;\n\t}\n};\n\nlong long A[mxN], B[mxN], srt[mxN];\nlong long dp[mxN];\nlong long sum[mxN];\n\nvoid dfs(int u) {\n\tsum[u] = B[u];\n\tfor (auto v : tree[u])\n\t\tdfs(v), sum[u] += sum[v];\n\tdp[u] = max(0ll, A[u] - B[u]);\n\tfor (auto v : tree[u]) {\n\t\tdp[u] = min(dp[u], max(dp[v], A[u] - B[u] - sum[v]));\n\t}\n//\tcerr << u << ' ' << dp[u] << '\\n';\n}\n\nbool can[mxN];\n\nint main(int argc, char** argv) {\n\t//#ifdef ONLINE_JUDGE\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t//#endif\n\n\tint N, M, u, v;\n\tcin >> N >> M;\n\tvector<int> ord(N);\n\tfor (int i = 1; i <= N; i++)\n\t\tcin >> A[i] >> B[i], srt[i] = max(A[i] - B[i], 0ll), ord[i - 1] = i;\n\tsort(begin(ord), end(ord), [&](int a,int b) {return srt[a] < srt[b];});\n//\tswap(ord[1], ord[2]);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> u >> v;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tDSU dsu(N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto o : g[ord[i]])\n\t\t\tif (can[o]) {\n\t\t\t\tint p = dsu.par(o);\n\t\t\t\tif (p != ord[i])\n\t\t\t\t\ttree[ord[i]].push_back(p), dsu.mrg(ord[i], p);\n\t\t\t}\n\t\tcan[ord[i]] = true;\n//\t\tcerr << ord[i] << \":\\n\";\n//\t\tfor (auto o : tree[ord[i]])\n//\t\t\tcerr << o << ' ';\n//\t\tcerr << '\\n';\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tif (dsu.par(i) == i)\n\t\t\tdfs(i), cout << dp[i] + sum[i] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint a[100005],b[100005],n;\n\nnamespace Heap {\n\nint ch[100005][2],num[100005],tot;\n\nint newnode(int x) {\n  num[++tot]=x;\n  ch[tot][0]=ch[tot][1]=0;\n  return tot;\n}\n\nint merge(int x,int y) {\n  if (!x) return y;\n  if (!y) return x;\n  if (a[num[x]]>a[num[y]]) swap(x,y);\n  ch[x][1]=merge(ch[x][1],y);\n  swap(ch[x][0],ch[x][1]);\n  return x;\n}\n\nint pop(int x) {\n  return merge(ch[x][0],ch[x][1]);\n}\n\n}\n\nint root[100005];\n\nnamespace SETS {\n\nint fa[100005],size[100005];\nll sum[100005];\n\nvoid init(int n) {\n  for(int i=1;i<=n;i++) {\n  \tfa[i]=i;\n  \tsize[i]=1;\n  \tsum[i]=b[i];\n  }\n}\n\nint find_father(int x) {\n  return (fa[x]==x)?x:fa[x]=find_father(fa[x]);\n}\n\nbool check(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  return x!=y;\n}\n\nvoid merge(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  if (x==y) return;\n  fa[y]=x;\n  sum[x]+=sum[y];\n  size[x]+=size[y];\n  root[x]=Heap::merge(root[x],root[y]);\n}\n\n}\n\nbool vis[100005];\n\nbool bfs(int s,int d) {\n  vis[s]=1;\n  while (root[s]) {\n  \tint x=Heap::num[root[s]];\n  \tif (!SETS::check(s,x)) {\n  \t\troot[s]=Heap::pop(root[s]);\n  \t\tcontinue;\n\t  }\n  \tif (a[x]>d+SETS::sum[s]) break;\n  \tvis[x]=1;\n  \troot[s]=Heap::pop(root[s]);\n  \tSETS::merge(s,x);\n  }\n  return SETS::size[s]==n;\n}\n\nvector <int> e[100005];\n\nbool check(int d) {\n  memset(vis,0,sizeof(vis));\n  Heap::tot=0;\n  SETS::init(n);\n  for(int i=1;i<=n;i++) {\n  \troot[i]=0;\n  \tfor(int j=0;j<e[i].size();j++) {\n  \t\tint u=Heap::newnode(e[i][j]);\n  \t\troot[i]=Heap::merge(root[i],u);\n\t  }\n  }\n  for(int i=1;i<=n;i++)\n    if (a[i]<=d&&!vis[i]&&bfs(i,d)) return 1;\n  return 0; \n}\n\nint main() {\n  int m;\n  scanf(\"%d%d\",&n,&m);\n  int l=0,r=0;\n  ll s=0;\n  for(int i=1;i<=n;i++) {\n    scanf(\"%d%d\",&a[i],&b[i]);\n    a[i]-=b[i];\n    s+=b[i];\n    r=max(r,a[i]);\n  }\n  for(int i=1;i<=m;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[x].push_back(y);\n  \te[y].push_back(x);\n  }\n  while (l<r) {\n  \tint mid=((l+r)>>1);\n  \tif (check(mid)) r=mid; else l=mid+1;\n  }\n  printf(\"%lld\\n\",s+l);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\ntypedef long long ll;\ntypedef double dd;\n#define For(i,j,k) for (int i=(int)j;i<=(int)k;++i)\n#define Forr(i,j,k) for (int i=(int)j;i>=(int)k;--i)\n#define Set(a,p) memset(a,p,sizeof(a))\nusing namespace std;\n\ntemplate<typename T>bool chkmax(T &a,T b) { return a<b?a=b,1:0; }\ntemplate<typename T>bool chkmin(T &a,T b) { return a>b?a=b,1:0; }\n\nconst int maxn=1e5+1e2;\nstruct node {\n\tint to,nxt;\n}e[maxn<<1];\nint n,m;\nint tot;\nint a[maxn],b[maxn],c[maxn];\nint head[maxn],fa[maxn],Ord[maxn],vis[maxn];\nll sum[maxn],dp[maxn];\nvector<int>g[maxn];\n\ninline void file() {\n\tfreopen(\"ARC098F.in\",\"r\",stdin);\n\tfreopen(\"ARC098F.out\",\"w\",stdout);\n}\n\ninline int read() {\n\tint x=0,p=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)) { if (c=='-') p=-1; c=getchar();}\n\twhile (isdigit(c)) { x=(x<<1)+(x<<3)+(c-'0'); c=getchar();}\n\treturn x*p;\n}\n\nint find(int x) {\n\tif (x!=fa[x]) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\ninline bool cmp(int x,int y) { return c[x]<c[y]; }\n\ninline void add(int from,int to) {\n\te[++tot]=(node){to,head[from]}; head[from]=tot;\n}\n\nvoid dfs(int u) {\n\tsum[u]=b[u];\n\tfor (int i=head[u];i!=0;i=e[i].nxt) {\n\t\tint v=e[i].to;\n\t\tdfs(v); sum[u]+=sum[v];\n\t}\n\tdp[u]=sum[u]+1ll*c[u];\n\tfor (int i=head[u];i!=0;i=e[i].nxt) {\n\t\tint v=e[i].to;\n\t\tchkmin(dp[u],sum[u]-sum[v]+max((ll)c[u],dp[v]));\n\t}\n}\n\nint main() {\n//\tfile();\n\tn=read(); m=read();\n\tFor (i,1,n) a[i]=read(),b[i]=read(),c[i]=max(a[i]-b[i],0);\n//\tFor (i,1,n) cout << c[i] << \" \" ; cout << endl;\n\tFor (i,1,m) {\n\t\tint x=read(),y=read();\n\t\tg[x].push_back(y); g[y].push_back(x);\n\t}\n\tFor (i,1,n) fa[i]=i,Ord[i]=i;\n\tsort(Ord+1,Ord+n+1,cmp);\n//\tFor (i,1,n) cout << Ord[i] << \" \" ; cout << endl;\n\tFor (i,1,n) {\n\t\tint u=Ord[i];\n\t\tvis[u]=1;\n\t\tFor (j,0,g[u].size()-1) {\n\t\t\tint v=g[u][j];\n\t\t\tif (vis[v]) {\n\t\t\t\tv=find(v);\n\t\t\t\tif (v!=u) {\n\t\t\t\t\tfa[v]=u; add(u,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdfs(Ord[n]);\n\tprintf(\"%lld\",dp[Ord[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tregister int x=0;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9')\tch=getchar();\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\nconst int N=2e5+5;\nint n,m,now,a[N],b[N],v[N],fa[N],id[N],vi[N],nex[N],head[N];\nvoid addedges(int x,int y){\n\tnex[++now]=head[x];\n\thead[x]=now,v[now]=y;\n}\nvector<int>d[N];\nlong long f[N],s[N];\nbool com(int x,int y){\n\treturn a[x]<a[y];\n}\nint find(int x){\n\treturn fa[x]?fa[x]=find(fa[x]):x;\n}\nvoid dfs(int x){\n\tint si=d[x].size();\n\tfor(int i=0;i<si;i++){\n\t\tint v=d[x][i];\n\t\tdfs(v),s[x]+=s[v];\n\t}\n\ts[x]+=b[x],f[x]=s[x]+a[x];\n\tfor(int i=0;i<si;i++){\n\t\tint v=d[x][i];\n\t\tf[x]=min(f[x],s[x]-s[v]+max(f[v],1LL*a[x]));\n\t}\n}\nint main(){\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//freopen(\"1.in\",\"r\",stdin);\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++)\ta[i]=read(),b[i]=read(),a[i]=max(a[i]-b[i],0);\n\tfor(int i=1;i<=m;i++){\n\t\tint x=read(),y=read();\n\t\taddedges(x,y),addedges(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)\tid[i]=i;\n\tsort(id+1,id+n+1,com);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];\tvi[x]=1;\n\t\tfor(int j=head[x];j;j=nex[j])\n\t\t\tif(vi[v[j]]){\n\t\t\t\tint y=find(v[j]);\n\t\t\t\tif(y==x)\tcontinue;\n\t\t\t\td[x].push_back(y),fa[y]=x;\n\t\t\t}\n\t}\n\tdfs(id[n]);\n\tprintf(\"%lld\\n\",f[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long u,v,data;\n\tbool operator < (const node &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nnode edge[200001];\nlong long n,m,a[100001],b[100001],head[100001],rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tMx[i]=max(a[i]-b[i],0);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>edge[i].u>>edge[i].v;\n\t\tif (a[edge[i].u]>a[edge[i].v])\n\t\t\tswap(edge[i].u,edge[i].v);\n\t\tedge[i].data=a[edge[i].v];\n\t}\n\tsort(edge+1,edge+m+1);\n\tfor (int i=1;i<=m;++i)\n\t\tif (find(edge[i].u)!=find(edge[i].v))\n\t\t\tunionn(edge[i].u,edge[i].v);\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\nconst int maxN = 1e5 + 5;\nll a[maxN], b[maxN], f[maxN];\nbool vis[maxN];\nint N, M, root[maxN], l[maxN], e, idx[maxN];\nstruct edge{\n\tint v, las;\n}G[maxN << 1];\nvoid add(int u, int v) {\n\tG[e].v = v; G[e].las = l[u]; l[u] = e++;\n}\nint getrt(int v) {\n\tif(root[v] != 0) {\n\t\tint rt = getrt(root[v]);\n\t\troot[v] = rt; v = rt;\n\t}\n\treturn v;\n}\nbool cmp(ll x, ll y) {return a[x] < a[y];}\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= N; ++i) \n\tscanf(\"%lld%lld\", &a[i], &b[i]), a[i] = max(0ll, a[i] - b[i]), l[i] = -1, idx[i] = i;\n\tfor(int i = 1; i <= M; ++i) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v); add(u, v); add(v, u);\n\t}\n\tsort(idx + 1, idx + 1 + N, cmp);\n\tfor(int i = 1; i <= N; ++i) {\n\t\tint k = idx[i]; f[k] = a[k]; vis[k] = 1;\n\t\tfor(int j = l[k]; j != -1; j = G[j].las) {\n\t\t\tif(vis[G[j].v]) {\n\t\t\t\tint v = G[j].v;\n\t\t\t\tint rt = getrt(v);\n\t\t\t\tif(rt == k) continue;\n\t\t\t\troot[rt] = k;\n\t\t\t\tb[k] += b[rt];\n\t\t\t\tf[k] = min(f[k], max(f[rt], a[k] - b[rt]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << b[idx[N]] + f[idx[N]] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n\nusing std::sort;\nusing std::min;\nusing std::max;\ntypedef long long ll;\nconst int N = 100010;\nint _w;\n\nint n, m, a[N], b[N];\n\nnamespace G {\n\tint head[N], nxt[N*2], to[N*2], eid;\n\tvoid init() {\n\t\teid = 0;\n\t\tmemset(head, -1, sizeof head);\n\t}\n\tvoid link( int u, int v ) {\n\t\tto[eid] = v, nxt[eid] = head[u], head[u] = eid++;\n\t\tto[eid] = u, nxt[eid] = head[v], head[v] = eid++;\n\t}\n}\n\nnamespace Tree {\n\tint head[N], nxt[N], to[N], eid;\n\tvoid init() {\n\t\teid = 0;\n\t\tmemset(head, -1, sizeof head);\n\t}\n\tvoid link( int u, int v ) {\n\t\tto[eid] = v, nxt[eid] = head[u], head[u] = eid++;\n\t}\n}\n\nnamespace DSU {\n\tint pa[N];\n\tvoid init() {\n\t\tfor( int i = 1; i <= n; ++i )\n\t\t\tpa[i] = i;\n\t}\n\tint find( int u ) {\n\t\treturn u == pa[u] ? u : pa[u] = find( pa[u] );\n\t}\n\tvoid link( int u, int v ) {\n\t\tu = find(u), v = find(v);\n\t\tpa[u] = v;\n\t}\n}\n\nbool cmp( int u, int v ) {\n\treturn a[u] < a[v];\n}\n\nint prelude() {\n\tstatic int rk[N], vis[N];\n\tmemset(vis, 0, sizeof vis);\n\tfor( int i = 1; i <= n; ++i ) rk[i] = i;\n\tsort(rk+1, rk+n+1, cmp);\n\tDSU::init();\n\tTree::init();\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tusing namespace G;\n\t\tint u = rk[i];\n\t\tvis[u] = 1;\n\t\tfor( int e = head[u]; ~e; e = nxt[e] ) {\n\t\t\tint v = to[e];\n\t\t\tif( !vis[v] ) continue;\n\t\t\tv = DSU::find(v);\n\t\t\tif( u != v ) {\n\t\t\t\tTree::link(u, v);\n\t\t\t\tDSU::link(v, u);\n\t\t\t}\n\t\t}\n\t}\n\treturn rk[n];\n}\n\nll f[N], s[N];\n\nvoid dfs( int u ) {\n\tusing namespace Tree;\n\ts[u] = b[u];\n\tfor( int i = head[u]; ~i; i = nxt[i] ) {\n\t\tint v = to[i];\n\t\tdfs(v);\n\t\ts[u] += s[v];\n\t}\n\tf[u] = s[u] + a[u];\n\tfor( int i = head[u]; ~i; i = nxt[i] ) {\n\t\tint v = to[i];\n\t\tf[u] = min( f[u], s[u] - s[v] + max<ll>(f[v], a[u]) );\n\t}\n}\n\nvoid solve( int rt ) {\n\tdfs(rt);\n\tprintf( \"%lld\\n\", f[rt] );\n}\n\nint main() {\n\t_w = scanf( \"%d%d\", &n, &m );\n\tfor( int i = 1; i <= n; ++i ) {\n\t\t_w = scanf( \"%d%d\", a+i, b+i );\n\t\ta[i] = max( a[i] - b[i], 0 );\n\t}\n\tG::init();\n\tfor( int i = 0; i < m; ++i ) {\n\t\tint u, v;\n\t\t_w = scanf( \"%d%d\", &u, &v );\n\t\tG::link(u, v);\n\t}\n\tsolve( prelude() );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    for (int i = 0; i < cp.size(); i++) cp[i].first = max(cp[i].first, cp[i].second);\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || cp[i].first < a[v] - b[v])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first, a[v] - b[v]) + b[v];\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in, cp[i].first - cp[i].second) + cp[i].second;\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = max(0LL, A[i]-B[i]);\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\n\t\tif(sz > 1) for(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tcat w_mi = max(A[c]+s, B[c]+s+W[comp_adj[j]])-1, w_mx = OVER9000;\n\t\t\tvector< pair<cat, cat> > Vs;\n\t\t\tfor(int k = 0; k < sz; k++)\n\t\t\t\tif(k != j) Vs.push_back(make_pair(W[comp_adj[k]], sumB[comp_adj[k]]));\n\t\t\tsort(begin(Vs), end(Vs));\n\t\t\tvector<bool> vis(sz-1);\n\t\t\tint a = sz-1;\n\t\t\twhile(w_mx-w_mi > 1) {\n\t\t\t\tcat w_cur = (w_mi + w_mx) / 2;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int l = sz-2; l >= 0; l--) {\n\t\t\t\t\tif(vis[l]) continue;\n\t\t\t\t\tif(Vs[l].ff > w_cur) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta = min(a, l-1);\n\t\t\t\t\tif(a >= 0 && Vs[a].ff > w_cur-Vs[l].ss) {\n\t\t\t\t\t\tvis[a] = true;\n\t\t\t\t\t\tw_cur -= Vs[a].ss;\n\t\t\t\t\t\ta--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvis[l] = true;\n\t\t\t\t\tw_cur -= Vs[l].ss;\n\t\t\t\t}\n\t\t\t\tif(ok) w_mx = (w_mi + w_mx) / 2;\n\t\t\t\telse w_mi = (w_mi + w_mx) / 2;\n\t\t\t}\n\t\t\t// cout << j << \" \" << i << endl;\n\t\t\tW[c] = min(W[c], w_mx);\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\t\telse {\n\t\t\tW[c] = min(W[c], max(m+B[c], max(A[c], B[c]+s)));\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\n//UF\nint par1[100021];\nint rank1[100021];\n//n要素で初期化\nvoid init(int n){\n   for(int i=0;i<n;i++){\n       par1[i]=i;\n       rank1[i]=0;\n   }\n}\n//木の根を求める\nint find(int x){\n    if(par1[x] ==x){\n         return x;\n    }else{\n         return par1[x]=find(par1[x]);\n    }\n}\n//xとyの属する集合を併合\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n\n    if(rank1[x]<rank1[y]){\n         par1[x]=y;\n    }else{\n         par1[y]=x;\n         rank1[x]++;\n    }\n}\n//xとyが同じ集合に属するか否か\nbool same(int x,int y){\n     return find(x)==find(y);\n}\n\n\n\nint N,M;\nLL A[100001];\nLL B[100001];\nLL C[100001];\nLL dp[100001];\nLL s[100001];\nbool used[100001];\n\nvector<int>G[100001];\ntypedef pair<LL,LL>P;\nvector<P>v;\nint main(){\n\tcin>>N>>M;\n\tREP(i,N){\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]=max(A[i],B[i]);\n\n\t}\n\n\tREP(i,M){\n\t\tint u,vv;\n\t\tcin>>u>>vv;\n\t\tu--;vv--;\n\t\tG[u].push_back(vv);\n\t\tG[vv].push_back(u);\n\t}\n\tinit(N+10);\n\tREP(i,N){\n\t\tdp[i]=B[i];//得られたお金\n\t\ts[i]=C[i]-B[i];//最後の資金\n\t\tused[i]=false;\n\t\t\t\tv.push_back(P(s[i],i));\n\t}\n\t\tsort(v.begin(),v.end());\n\tREP(i,v.size()){\n\t\tint x=v[i].second;\n\t\tused[x]=true;\n\t\tvector<int>k;\n\t\tREP(j,G[x].size()){\n\t\t\tif(used[G[x][j]]==true){\n\t\t\t\tk.push_back(find(G[x][j]));\n\t\t\t}\n\t\t}\n\t\tsort(k.begin(),k.end());\n\t\tk.erase(unique(k.begin(), k.end()), k.end());\n\t\t//要素のソート\n\t\tvector<P>u;\n\t\tREP(j,k.size()){\n\t\t\tu.push_back(P(dp[k[j]],k[j]));\n\t\t}\n\t\tsort(u.begin(),u.end());\n\t\tREP(j,u.size()){\n\t\t\tif(same(x,u[j].second))continue;\n\t\t\tif(s[find(x)]<=s[u[j].second]){\n\t\t\t\tLL a=s[find(x)];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else if(s[u[j].second]+dp[u[j].second]>=(C[x]-B[x])){\n\t\t\t\tLL a=s[u[j].second];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else if(((C[x]-B[x])-dp[u[j].second])<=s[find(x)]){\n\t\t\t\tLL a=(C[x]-B[x])-dp[u[j].second];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else{\n\t\t\t\tLL a=s[find(x)];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}\n\t\t\t//cout<<\"x=\"<<x<<\" dp[find(x)]=\"<<dp[find(x)]<<\" s[x]=\"<<s[find(x)]<<endl;\n\t\t}\n\t\t//cout<<\"xx=\"<<x<<\" dp[find(x)]=\"<<dp[find(x)]<<\" s[x]=\"<<s[find(x)]<<endl;\n\t}\n\tcout<<dp[find(0)]+s[find(0)]<<endl;\n\t/*REP(i,5){\n\t\tcout<<\"f\"<<dp[find(i)]<<endl;\n\t}*/\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i];\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n\t\tif(sz < 10) {\n\t\t\tvector<int> P(sz);\n\t\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\t\tbool is_ok = false;\n\t\t\twhile(true) {\n\t\t\t\tcat w = W[c];\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tw -= B[c];\n\t\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tw = W[c];\n\t\t\t\tok = true;\n\t\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t\t}\n\t\t\tassert(is_ok);\n\t\t}\n\t\t\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef unsigned int uint;\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nconst int MX = 200005;\n\nstruct UF{\n\tint t[MX];\n\tll ans[MX], tB[MX];\n\tint find(int x){ return t[x] ? t[x] = find(t[x]) : x; }\n\tint merge(int a, int b){ // a <- b\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return false;\n\t\tt[b] = a; tB[a] += tB[b]; return true;\n\t}\n}uf;\n\nint N, M;\npii D[MX];\nvector<int> G[MX];\nint P[MX], chk[MX];\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d%d\", &D[i].first, &D[i].second);\n\tfor(int i = 1; i <= M; i++){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i = 1; i <= N; i++) P[i] = i;\n\tsort(P+1, P+N+1, [](int l, int r){ \n\t\treturn D[l].first < D[r].first;\n\t});\n\tfor(int i = 1; i <= N; i++) uf.tB[i] = D[i].second;\n\tfor(int i = 1; i <= N; i++){\n\t\tint cur = P[i], A = D[cur].first, B = D[cur].second;\n\t\tll ans = max(A-B, 0);\n\t\tfor(int c : G[cur]){\n\t\t\tif(!chk[c]) continue;\n\t\t\tint u = uf.find(c);\n\t\t\tans = min(ans, max(uf.ans[u], A - (B+uf.tB[u])));\n\t\t}\n\t\tuf.ans[cur] = ans;\n\t\tfor(int c : G[cur]) if(chk[c]) uf.merge(cur, c);\n\t\tchk[cur] = 1;\n\t}\n\tint p = uf.find(1);\n\tprintf(\"%lld\\n\", uf.ans[p] + uf.tB[p]);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\nint32_t N,M;\nint32_t A[100000],B[100000];\n\n#include <vector>\n\nclass union_find\n{\nprivate:\n\tstd::vector<int>parent;\n\tstd::vector<int>rank;\npublic:\n\tunion_find(int siz)\n\t{\n\t\tparent.resize(siz);\n\t\trank.resize(siz);\n\t\tfor (int i = 0; i < siz; ++i)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tvoid unite(int x, int y)\n\t{\n\t\tint xr = find(x);\n\t\tint yr = find(y);\n\t\tif (rank[xr] > rank[yr])\n\t\t{\n\t\t\tparent[yr] = xr;\n\t\t}\n\t\telse if (rank[xr] > rank[yr])\n\t\t{\n\t\t\tparent[xr] = yr;\n\t\t}\n\t\telse if (xr != yr)\n\t\t{\n\t\t\tparent[yr] = xr;\n\t\t\t++rank[xr];\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\tbool check(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\n\n#include <queue>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <iterator>\n\nusing COST_T = uint32_t;\nstruct edge {\n\tuint32_t to;\n\tedge() {}\n\tedge(uint32_t to_)\n\t\t:to(to_) {}\n};\nstd::vector<edge> graph[100000];\n\n\nuint32_t getmoney[100000];\nusing P = std::pair<COST_T, uint32_t>;\nusing P_que = std::priority_queue<P, std::vector<P>, std::greater<P>>;\nP_que frontline[100000];\n\nbool Dijkstra(uint32_t PENALTY_MAX)\n{\n\tunion_find tree(N);\n\tfor (uint32_t i = 0; i < N; i++)\n\t{\n\t\tgetmoney[i] = PENALTY_MAX + B[i];\n\t\tfrontline[i] = P_que{};\n\t\tfor (auto& e : graph[i]) {\n\t\t\tfrontline[i].emplace(A[e.to]-B[e.to], e.to);\n\t\t}\n\t}\n\n\tfor (uint32_t START = 0; START < N; START++)\n\t{\n\t\tif (tree.find(START) != START) { continue; }\n\t\tif (getmoney[START] < A[START]) { continue; }\n\n\n\t\twhile(!frontline[tree.find(START)].empty())\n\t\t{\n\t\t\tauto v = frontline[tree.find(START)].top(); frontline[tree.find(START)].pop();\n\n\t\t\tif (tree.check(START, v.second)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (v.first > getmoney[tree.find(START)]) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tP_que frontline_next;\n\t\t\tauto x = tree.find(START);\n\t\t\tauto y = tree.find(v.second);\n\t\t\tif (frontline[x].size() < frontline[y].size()) {\n\t\t\t\tstd::swap(x, y);\n\t\t\t}\n\t\t\twhile (!frontline[y].empty()) {\n\t\t\t\tfrontline[x].emplace(frontline[y].top());\n\t\t\t\tfrontline[y].pop();\n\t\t\t}\n\t\t\tauto getmoney_next = getmoney[x] + getmoney[y] - PENALTY_MAX;\n\n\t\t\ttree.unite(START, v.second);\n\t\t\tfrontline[tree.find(START)] = std::move(frontline_next);\n\t\t\tgetmoney[tree.find(START)] = std::move(getmoney_next);\n\t\t}\n\t\tif (frontline[tree.find(START)].empty()) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N>>M;\n\n\tfor (size_t i = 0; i < N; i++)\n\t{\n\t\tin >> A[i] >> B[i];\n\t}\n\tfor (size_t i = 0; i < M; i++)\n\t{\n\t\tint a, b;\n\t\tin >> a >> b; --a; --b;\n\t\tgraph[a].emplace_back(b);\n\t\tgraph[b].emplace_back(a);\n\t}\n\n\tusing BS_INT = int64_t;\n\tBS_INT ok_range = 1000000000, ng_range = -1;\n\twhile (std::abs(ok_range - ng_range) > 1) {\n\t\tBS_INT mid = (ok_range + ng_range) / 2;\n\t\tbool is_ok = false;\n\n\t\t//ここに書く\n\n\t\tif (Dijkstra(mid)) {\n\t\t\tok_range = mid;\n\t\t}\n\t\telse {\n\t\t\tng_range = mid;\n\t\t}\n\t}\n\tout << std::accumulate(all_range(B),(int64_t)0)+ok_range << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,u,v,a[100001],b[100001],c[100001],s[100001],d[100001];\nlong long x[100001][491],y[100001][491],f[100001],sr[100001];\nbool bo[100001];\ninline int read()\n{\n    int sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(int x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(int x,int y)\n{\n\treturn c[x]<c[y];\n}\ninline int find(int x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(int u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register int i=1;i<=y[u][0];++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register int i=1;i<=y[u][0];++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register int i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register int i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u][++x[u][0]]=v;\n\t\tx[v][++x[v][0]]=u;\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t{\n\t\tint u=d[i];\n\t\tfor (register int j=1;j<=x[u][0];++j)\n\t\t{\n\t\t\tint v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u][++y[u][0]]=vv;\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef pair<P, Int> T;\nInt n, k, v,m;\nInt a[216000];\nInt b[216000];\nInt c[216000];\nInt u[216000];\nInt us[216000];\nInt vs[216000];\nInt sum[216000];\n\nvector<P> edges;\nvector<Int> child[108000];\nInt init(){\n\tfor(Int i = 0;i < 216000;i++)u[i] = i;\n}\n\nInt r(Int x){\n\tif(u[x] == x)return x;\n\treturn u[x] = r(u[x]);\n}\n\nInt unite(Int x, Int y){\n\tx = r(x);\n\ty = r(y);\n\tif(x != y)u[y]= x;\n}\n\nInt dp(Int x){\n\tsum[x] = b[x];\n\tInt ans = c[x];\n\tfor(Int i = 0;i < child[x].size();i++){\n\t\tInt to = child[x][i];\n\t\tInt tmp = dp(to);\n\t\tans = min(ans, -sum[to] + max(c[x], tmp));\n\t\tsum[x] += sum[to];\n\t}\n\tans += sum[x];\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tcin >> n >> m;\n\tfor(Int i = 0;i < n;i++){\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i], b[i]);\n\t\tc[i] = a[i] - b[i];\n\t}\n\tfor(Int i = 0;i < m;i++){\n\t\tcin >> us[i] >> vs[i];us[i]--,vs[i]--;\n\t\tedges.push_back(P(max(c[us[i]],c[vs[i]]),i));\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(Int i = 0;i < edges.size();i++){\n\t\tInt cost = edges[i].first;\n\t\tInt ind = edges[i].second;\n\t\tInt u = us[ind], v = vs[ind];\n\t\tif(r(u) == r(v))continue;\n\t\tif(c[u] < c[v])swap(u,v);\n\t\tchild[r(u)].push_back(r(v));\n\t\tunite(u, v);\n\t}\n\tcout << dp(r(0)) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst LL Infll = 0x3f3f3f3f3f3f3f3f;\nconst int MN = 100005;\n\nint N, M, A[MN], B[MN], P[MN];\nstd::vector<int> G[MN], T[MN];\n\nint fa[MN];\ninline int ff(int x) { return fa[x] ? fa[x] = ff(fa[x]) : x; }\n\nLL f[MN], s[MN];\n\nvoid DFS(int u) {\n\ts[u] = B[u], f[u] = Infll;\n\tfor (auto v : T[u]) DFS(v), s[u] += s[v];\n\tfor (auto v : T[u]) f[u] = std::min(f[u], s[u] - s[v] + std::max((LL)A[u], f[v]));\n\tif (T[u].empty()) f[u] = A[u] + B[u];\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 1; i <= N; ++i)\n\t\tscanf(\"%d%d\", &A[i], &B[i]),\n\t\tA[i] = std::max(A[i] - B[i], 0),\n\t\tP[i] = i;\n\tfor (int i = 1, x, y; i <= M; ++i)\n\t\tscanf(\"%d%d\", &x, &y),\n\t\tG[x].push_back(y),\n\t\tG[y].push_back(x);\n\tstd::sort(P + 1, P + N + 1, [](int i, int j) { return A[i] < A[j]; });\n\tfor (int i = 1; i <= N; ++i) {\n\t\tint u = P[i];\n\t\tfor (auto v : G[u])\n\t\t\tif (A[v] < A[u] && ff(v) != u)\n\t\t\t\tT[u].push_back(ff(v)),\n\t\t\t\tfa[ff(v)] = u;\n\t}\n\tDFS(P[N]);\n\tprintf(\"%lld\\n\", f[P[N]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=2005; \n\nint n,k,q,a[N],b[N],m,ans=1e9; \nvector<int> v,g;\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\t//freopen(\"dat.in\",\"r\",stdin); \n#endif\n\tread(n),read(k),read(q);\n\trep(i,1,n){\n\t\tread(a[i]); \n\t\tb[i]=a[i]; \n\t}\n\tm=n;\n\tsort(b+1,b+m+1); \n\tm=unique(b+1,b+m+1)-b-1; \n\trep(d,0,m){\n\t\tint x=b[d];\n\t\tv.clear(),g.clear(); \n\t\trep(i,1,n+1){\n\t\t\tif(a[i]>x)v.pb(a[i]); \n\t\t\telse if(!v.empty()){\n\t\t\t\tsort(all(v));\n\t\t\t\tfor(size_t j=0;j+k<=v.size();++j)g.pb(v[j]); \n\t\t\t\tv.clear();\n\t\t\t}\n\t\t}\n\t\tif((int)g.size()<q)break;\n\t\tsort(all(g)); \n\t\tcmin(ans,g[q-1]-g[0]); \n\t}\n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <set>\ntypedef long long ll;\nusing namespace std;\nconst int N = 1e5+5;\n\nint n, m;\nvector<int> E[N];\nint A[N], B[N], pos[N], vis[N], fa[N];\nlong long sum[N], add[N];\ninline bool cmp(int x, int y) { return A[x] < A[y]; }\ninline int find(int x) { return (x == fa[x]) ? x : (fa[x] = find(fa[x])); }\nint main() {\n    while(~scanf(\"%d %d\", &n, &m)) {\n        for(int i = 1; i <= n; ++i) E[i].clear();\n        for(int i = 1; i <= n; ++i) {\n            pos[i] = i; vis[i] = 0; fa[i] = i;\n            scanf(\"%d %d\", &A[i], &B[i]);\n            A[i] = max(0, A[i] - B[i]);\n            add[i] = A[i];\n            sum[i] = B[i];\n        }\n\n        sort(pos+1, pos+n+1, cmp);\n        for(int i = 0; i < m; ++i) {\n            int a, b; scanf(\"%d %d\", &a, &b);\n            E[a].push_back(b);\n            E[b].push_back(a);\n        }\n\n        for(int i = 1; i <= n; ++i) {\n            vis[pos[i]] = 1;\n            for(int j = 0; j < E[pos[i]].size(); ++j) {\n                int tt = E[pos[i]][j];\n                if(vis[tt]) {\n                    int f1 = find(pos[i]); int f2 = find(tt);\n                    if(f1 != f2) {\n                        sum[f1] += sum[f2];\n                        fa[f2] = f1; \n                        add[f1] = min(add[f1], add[f2] + max(0ll, A[f1] - add[f2] - sum[f2])); \n                    }\n                }\n            }\n        }\n        printf(\"%lld\\n\", sum[pos[n]] + add[pos[n]]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<set>\nusing namespace std;\ntypedef long long ll;\n#define N 500002\nstruct edge{int to,nxxt;}e[N<<1];\nvector<int>v[N];\nint head[N],cnt=1,m,n,a[N],b[N],w[N],id[N],f[N];\nbool vis[N];\nll sum[N],dp[N];\nbool cmp(int x,int y){return w[x]<w[y];}\ninline void ins(int u,int v)\n{e[cnt].to=v;e[cnt].nxxt=head[u];head[u]=cnt++;}\nint getroot(int t){return f[t]==0?t:f[t]=getroot(f[t]);}\nvoid dfs(int te)\n{sum[te]=b[te];\n\tfor(int i=0;i<v[te].size();i++)\n\t{\n\t\tint j=v[te][i];dfs(j);sum[te]+=sum[j];\n\t}dp[te]=b[te]+w[te];if(!v[te].empty())dp[te]=1e9;\n\tfor(int i=0;i<v[te].size();i++)\n\t{int j=v[te][i];\n\t\tdp[te]=min(dp[te],sum[te]-sum[j]+max(1ll*w[te],dp[j]));\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),w[i]=max(0,a[i]-b[i]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tins(x,y),ins(y,x);\n\t}\n\tfor(int i=1;i<=n;i++)id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=id[i];\n\t\tfor(int j=head[i];j;j=e[j].nxxt)\n\t\t{\n\t\t\tint y=e[j].to;\n\t\t\tint xx=getroot(x),yy=getroot(y);\n\t\t\tif(xx!=yy&&vis[yy])\n\t\t\t{\n\t\t\t\tf[yy]=xx;\n\t\t\t\tv[x].push_back(yy);\n\t\t\t}\n\t\t}vis[getroot(x)]=1;\n\t}dfs(id[n]);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint a[N],b[N],n,m,vis[N],fa[N],c[N];\ntypedef long long ll;\nvector<int>g[N];\nll sum[N],mn[N];\nbool cmp(const int&x,const int&y){return a[x]<a[y];}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i){cin>>a[i]>>b[i];c[i]=i;}\n\tsort(c+1,c+n+1,cmp);\n\tfor(int i=1;i<=m;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg[x].push_back(y);g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;++i)fa[i]=i,sort(g[i].begin(),g[i].end(),cmp);\n\tfor(int i=1;i<=n;++i){\n\t\tint u=c[i];sum[u]=b[u];mn[u]=max(0,a[u]-b[u]);\n\t\tvis[u]=1;\n\t\tfor(int j:g[u])if(vis[j]){\n\t\t\tint v=find(j);if(u==v)continue;\n\t\t\tsum[u]+=sum[v];mn[u]=min(mn[u],max(a[u]-sum[v]-b[u],mn[v]));\n\t\t\tfa[v]=u;\n\t\t}\n\t}\n\tcout<<sum[c[n]]+mn[c[n]]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll aa, pll bb){\n        return aa.first - aa.second < bb.first - bb.second;\n    });\n    ll min_cost_in = 1e18;\n    vector<int> sc(cp.size(), 0);\n    sc[0] = 1;\n    for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[0].first - cp[0].second) sc[j] = 1;\n    sc[sc.size() - 1] = 1;\n    for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[cp.size() - 1].first - cp[cp.size() - 1].second) sc[j] = 1;\n    for (int i = 1; i + 1 < cp.size(); i++)\n    {\n        if (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second)\n        {\n            sc[i] = 1;\n            for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[i].first - cp[i].second) sc[j] = 1;\n        }\n        if (a[v] - b[v] < cp[i].first - cp[i].second && a[v] - b[v] >= cp[i - 1].first - cp[i - 1].second)\n        {\n            sc[i] = 1;\n            for (int j = 0; j < cp.size(); j++) if (cp[j].first - cp[j].second == cp[i].first - cp[i].second) sc[j] = 1;\n        }\n    }\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (sc[i])\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nstruct node\n{\n\tint x,y,next;\n}e[100010];int len,last[100010];\ninline void ins(int x,int y)\n{\n\tlen++;\n\te[len].x=x;e[len].y=y;\n\te[len].next=last[x];last[x]=len;\n}\nint a[100010],b[100010];\nbool cmp(node u,node v){return a[u.x]<a[v.x];}\nint rt,fa[100010];\ninline int findfa(int x)\n{\n\tif(fa[x]!=x)fa[x]=findfa(fa[x]);\n\treturn fa[x];\n}\nlong long uf,tot[100010],s[100010];\ninline void dfs(int x)\n{\n\tfor(int k=last[x];k;k=e[k].next)\n\t{\n\t\tint y=e[k].y;\n\t\ts[y]=s[x]+max(0LL,a[x]-a[y]-tot[y]);\n\t\tdfs(y);\n\t}\n}\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    int n=read(),m=read();\n    for(int i=1;i<=n;i++){a[i]=read(),b[i]=read();a[i]=max(0,a[i]-b[i]),uf+=b[i];}\n    for(int i=1;i<=m;i++)\n    {\n    \tint x=read(),y=read();if(a[x]<a[y])swap(x,y);\n    \te[i].x=x,e[i].y=y;\n    }sort(e+1,e+m+1,cmp);\n    for(int i=1;i<=n;i++)fa[i]=i,tot[i]=b[i];\n    for(int i=1;i<=m;i++)\n    {\n    \tint fx=findfa(e[i].x),fy=findfa(e[i].y);\n    \tif(fx!=fy){fa[fy]=fx,rt=fx,tot[fx]+=tot[fy];ins(fx,fy);}\n    }dfs(rt);\n    long long ans=a[1]+s[1]+uf;\n    for(int i=2;i<=n;i++)ans=min(ans,a[i]+s[i]+uf);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i];\n\t\tVs[i].ss = i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n/*\t\tvector<int> P(sz);\n\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\tbool is_ok = false;\n\t\twhile(true) {\n\t\t\tcat w = W[c];\n\t\t\tbool ok = true;\n\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t}\n\t\t\tif(w < B[c]) ok = false;\n\t\t\tw -= B[c];\n\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\tif(ok) is_ok = true;\n\t\t\tw = W[c];\n\t\t\tok = true;\n\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t}\n\t\t\tif(w < B[c]) ok = false;\n\t\t\tif(ok) is_ok = true;\n\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t}\n\t\tassert(is_ok);\n*/\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) const {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    friend bool operator< (Info a , Info b)  {return a.cost < b.cost;}\n};\n\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nvoid unlock(int x) ;\nvoid merge(int x , int y) ;\n\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            out[p].insert(y);\n            modifycost(y , (int)max(limit[y] - money[p] , 0LL));\n        }\n    }\n}\n\n\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n    while(out[y].size()) {\n        x = *out[y].begin();\n        if(find(x) == y) {\n            out[y].erase(*out[y].begin());\n            continue;\n        }\n        if(money[y] + init >= limit[x]) {\n            out[y].erase(*out[y].begin());\n            unlock(x);\n            y = find(y);\n            continue;\n        }\n        modifycost(x , (int)max(limit[x] - money[y] , 0LL));\n        break;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#define re register\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define MAXN 400007\n#define mo 19930726\n#define ll long long\nusing namespace std;\ntypedef unsigned long long ull;\n#define ms(arr) memset(arr, 0, sizeof(arr))\nconst int inf = 0x3f3f3f3f;\nint head[MAXN],fa[MAXN],a[MAXN],b[MAXN],c[MAXN],n,m,vis[MAXN],id[MAXN],cnt,num;\nll s[MAXN],f[MAXN];\nstruct po{\n\tint nxt,to;\n}edge[MAXN<<1];\nvector<int> v[MAXN];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\ninline bool cmp(int x,int y) {return c[x]<c[y];}\ninline void add_edge(int from,int to){\n\tedge[++num].nxt=head[from];edge[num].to=to;head[from]=num;\n}\nvoid dfs(int u){\n\ts[u]=b[u];\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tdfs(v);\n\t\ts[u]+=s[v];\n\t}\n\tf[u]=s[u]+c[u];\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tf[u]=min(f[u],s[u]-s[v]+max(f[v],1ll*c[u]));\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tc[i]=max(0,a[i]-b[i]);\n\t\tfa[i]=id[i]=i;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[x].push_back(y); v[y].push_back(x);\n\t}\n\tsort(id,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];vis[x]=1;\n\t\tfor(int j=0;j<v[x].size();j++) {\n\t\t\tint y=v[x][j];\n\t\t\tif(!vis[y]) continue;\n\t\t\ty=find(y);\n\t\t\tif(x!=y){\n\t\t\t\tfa[y]=x;add_edge(x,y);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(id[n]);\n\tcout<<f[id[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tll a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].a,&a[i].b);\n\tif(n==1) return printf(\"%lld\",a[i].b),0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e17,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e17;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mid+siz[find(1)],r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\t// iostream is too mainstream\n\t#include <cstdio>\n\t// bitch please\n\t#include <iostream>\n\t#include <algorithm>\n\t#include <cstdlib>\n\t#include <vector>\n\t#include <set>\n\t#include <map>\n\t#include <queue>\n\t#include <stack>\n\t#include <list>\n\t#include <cmath>\n\t#include <iomanip>\n\t#include <time.h>\n\t#define dibs reserve\n\t#define OVER9000 1234567890123456789LL\n\t#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n\t#define tisic 47\n\t#define soclose 1e-8\n\t#define chocolate win\n\t// so much chocolate\n\t#define patkan 9\n\t#define ff first\n\t#define ss second\n\t#define abs(x) (((x) < 0)?-(x):(x))\n\t#define uint unsigned int\n\t#define dbl long double\n\t#define pi 3.14159265358979323846\n\tusing namespace std;\n\t// mylittledoge\n\n\tusing cat = long long;\n\n\t#ifdef DONLINE_JUDGE\n\t\t// palindromic tree is better than splay tree!\n\t\t#define lld I64d\n\t#endif\n\n\tint main() {\n\t\tcin.sync_with_stdio(0);\n\t\tcin.tie(0);\n\t\tcout << fixed << setprecision(10);\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tvector< vector<int> > G(N);\n\t\tvector<cat> A(N), B(N);\n\t\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tG[--u].push_back(--v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tvector< pair<cat, int> > Vs(N);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tVs[i].ff = A[i];\n\t\t\tVs[i].ss = -i;\n\t\t}\n\t\tsort(begin(Vs), end(Vs));\n\n\t\tvector< vector<int> > comp(N);\n\t\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\t\tvector<int> inC(N);\n\t\tfor(int i = 0; i < N; i++) inC[i] = i;\n\t\tvector<bool> live(N, false);\n\t\tvector<cat> sumB(N, 0), W(N);\n\t\tcat ans = 0;\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint c = -Vs[i].ss;\n\t\t\tvector<int> comp_adj;\n\t\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\t\tcomp_adj.push_back(inC[*it]);\n\t\t\tsort(begin(comp_adj), end(comp_adj));\n\t\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\t\tint sz = cae - begin(comp_adj);\n\t\t\tcomp_adj.resize(sz);\n\n\t\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\t\tcat s = 0, m = 0;\n\t\t\tfor(int k = 0; k < sz; k++) {\n\t\t\t\ts += sumB[comp_adj[k]];\n\t\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t\t}\n\t\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\t\tfor(int j = 0; j < sz; j++) {\n\t\t\t\ts -= sumB[comp_adj[j]];\n\t\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\t\ts += sumB[comp_adj[j]];\n\t\t\t}\n\n\t\t\tif(sz < 10) {\n\t\t\t\tvector<int> P(sz);\n\t\t\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\t\t\tbool is_ok = false;\n\t\t\t\twhile(true) {\n\t\t\t\t\tcat w = W[c];\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\t\tw -= B[c];\n\t\t\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\t\t\tif(ok) is_ok = true;\n\t\t\t\t\tw = W[c];\n\t\t\t\t\tok = true;\n\t\t\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\t\tif(ok) is_ok = true;\n\t\t\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t\t\t}\n\t\t\t\tassert(is_ok);\n\t\t\t}\n\n\t\t\tsumB[c] = B[c];\n\t\t\tfor(int j = 0; j < sz; j++) {\n\t\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\t\tALL_THE(comp[a], it) {\n\t\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\t\tinC[*it] = b;\n\t\t\t\t}\n\t\t\t\tsumB[b] += sumB[a];\n\t\t\t}\n\t\t\tans = W[inC[c]] = W[c];\n\t\t\tlive[c] = true;\n\t\t}\n\t\tcout << ans << \"\\n\";\n\t\treturn 0;}\n\n\t// look at my code\n\t// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n#define VEC(TYPE, A, NAME, INIT) vector<TYPE> NAME(A, INIT)\n#define VEC2(TYPE, A, B, NAME, INIT) vector<vector<TYPE>> NAME(A, vector<TYPE>(B, (INIT)))\n#define cInf 9e18\n\nclass UnionFind\n{\n  public:\n\texplicit UnionFind(ll size)\n\t\t: mParent(size, -1)\n\t\t, mRank(size, 0)\n        , mData(size, -1)\n\t\t, mData2(size, -1)\n\t\t{}\n\tbool unionSet(ll x, ll y)\n\t{\n\t\tif ((x = root(x)) == (y = root(y)))\n\t\t\treturn false;\n\t\tif( mRank[x] < mRank[y] )\n\t\t{\n\t\t\tmParent[y] += mParent[x];\n\t\t\tmParent[x] = y;\n            unionData( mData[y], mData[x] );\n\t\t\tmData2[y] += mData2[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmParent[x] += mParent[y];\n\t\t\tmParent[y] = x;\n\t\t\tif( mRank[x] == mRank[y] ) ++mRank[x];\n            unionData( mData[x], mData[y] );\n\t\t\tmData2[x] += mData2[y];\n\t\t}\n\t\treturn true;\n\t}\n\tbool isEqualSet(ll x, ll y)\n\t{\n\t\treturn root(x) == root(y);\n\t}\n\tll root(ll x)\n\t{\n\t\treturn mParent[x] < 0 ? x : mParent[x] = root(mParent[x]);\n\t}\n\tll size(ll x)\n\t{\n\t\treturn -mParent[root(x)];\n\t}\n\n    void unionData( ll& parent, ll& child )\n    {\n        parent = max( parent, child );\n    }\n    void setData( ll x, ll data )\n    {\n        mData[root(x)] = data;\n    }\n    ll getData( ll x )\n    {\n        return mData[root(x)];\n    }\n\tvoid setData2( ll x, ll data2 )\n\t{\n\t\tmData2[root(x)] = data2;\n\t}\n\tll getData2( ll x )\n\t{\n\t\treturn mData2[root(x)];\n\t}\n\n  public:\n\tvector<ll> mParent; // = mSize\n\tvector<ll> mRank;\n\tvector<ll> mData;\n\tvector<ll> mData2;\n};\n\nstruct Node{\n    ll a = 0;\n    ll b = 0;\n\tll c = 0;\n\tll idx = 0;\n};\nbool operator<(const Node& l, const Node& r)\n{ return l.c != r.c ? l.c < r.c : l.idx < r.idx; }\nbool operator>(const Node& l, const Node& r)\n{ return l.c != r.c ? l.c > r.c : l.idx > r.idx; }\n\nint main()\n{\n    ll n, m;\n    cin >> n >> m;\n\tVEC( Node, n, node, Node() );\n\tREP(i,n)\n\t{\n\t\tnode[i].idx = i;\n\t\tcin >> node[i].a >> node[i].b;\n\t\tnode[i].c = max( 0ll, node[i].a-node[i].b );\n\t}\n\tvector< vector<ll> > edge(n);\n\tREP( i, m )\n\t{\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tedge[a-1].push_back( b-1 );\n\t\tedge[b-1].push_back( a-1 );\n\t}\n\n\tsort( ALL(node) );\n\n\tUnionFind uf(n);\n\tREP( i,n )\n\t{\n\t\tauto& nod = node[i];\n\t\tuf.setData2( nod.idx, nod.b );\n\t\tll dataMin = cInf;\n\t\tbool is[100010] = { false };\n\t\tvector<ll> vec;\n\t\tfor( auto e : edge[nod.idx] )\n\t\t{\n\t\t\tif( uf.getData(e) < 0 )\n\t\t\t{ continue; }\n\t\t\tauto r = uf.root(e);\n\t\t\tif( !is[r] )\n\t\t\t{\n\t\t\t\tis[r] = true;\n\t\t\t\tvec.push_back(uf.root(e));\n\t\t\t}\n\t\t}\n\t\tll sum = 0;\n\t\tfor( auto e : vec ){ sum += uf.getData2(e); }\n\t\tfor( auto e : vec )\n\t\t{\n\t\t\tauto data = uf.getData(e);\n\t\t\tdata = nod.c <= data ? data + nod.b : nod.a;\n\t\t\tdata += sum - uf.getData2(e);\n\t\t\tdataMin = min( dataMin, data );\n\t\t}\n\t\t\n\t\tif( dataMin == cInf )\n\t\t{\n\t\t\tdataMin = max( nod.a, nod.b );\n\t\t}\n\t\tuf.setData( nod.idx, dataMin );\n\t\t\n\t\tfor( auto e : vec )\n\t\t{\n\t\t\tuf.unionSet( nod.idx, e );\n\t\t}\n\t}\n\t\n\tcout << uf.getData(0) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 100005;\nconst long long inf = 1000000000000000ll;\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt;\n} graph[M << 1];\nint n, m, head[N], id[N], fa[N], cnt = 0;\nlong long a[N], b[N], f[N], g[N];\npair<int, int> vec[N];\n\nvoid addedge (int u, int v) {\n\tedge e = {v, head[u]};\n\tgraph[head[u] = cnt++] = e;\n}\n\nint findroot (int x) {\n\treturn fa[x] == x ? x : fa[x] = findroot(fa[x]);\n}\n\nstruct node {\n\tlong long cost, lim;\n\tint id;\n\tbool operator < (node rhs) const {\n\t\t//return cost - lim < rhs.cost - rhs.lim;\n\t\tif (cost - lim < rhs.cost - rhs.lim) return true;\n\t\telse if (cost - lim > rhs.cost - rhs.lim) return false;\n\t\telse return id < rhs.id;\n\t}\n} ;\n\nint main () {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++) fa[i] = i, head[i] = -1;\n\tfor (int i = 1; i <= n; i++) read(a[i]), read(b[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\taddedge(u, v);\n\t\taddedge(v, u);\n\t}\n\n\tfor (int i = 1; i <= n; i++) vec[i] = make_pair(a[i], i);\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) id[vec[i].second] = i;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u = vec[i].second;\n\t\tlong long sum = 0ll;\n\t\tvector<node> tmp;\n\t\tf[u] = inf, g[u] = b[u];\n\t\tfor (int j = head[u]; ~j; j = graph[j].nxt) {\n\t\t\tint v = graph[j].to, rv = findroot(v);\n\t\t\tif (id[v] < id[u] && rv != u) {\n\t\t\t\tnode ch = {g[rv], max(a[u], f[rv]), rv};\n\t\t\t\tfa[rv] = u, g[u] += g[rv];\n\t\t\t\ttmp.push_back(ch);\n\t\t\t}\n\t\t}\n\n\t\tnode rt = {b[u], a[u], u};\n\t\ttmp.push_back(rt);\n\t\tsort(tmp.begin(), tmp.end());\n\t\tdo {\n\t\t\tlong long F = -inf;\n\t\t\tsum = 0ll;\n\t\t\tfor (int j = 0; j < tmp.size(); j++) {\n\t\t\t\tif (j && tmp[j - 1].id != u) F = max(F, sum + tmp[j].lim);\n\t\t\t\telse if (tmp[j].id == u) F = max(F, sum + tmp[j].lim);\n\t\t\t\telse F = max(F, sum + f[tmp[j].id]);\n\t\t\t\tsum += tmp[j].cost;\n\t\t\t}\n\t\t\tF = max(F, sum), f[u] = min(f[u], F);\n\t\t} while (next_permutation(tmp.begin(), tmp.end()));\n\t}\n\n\twrite(f[vec[n].second]), putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <functional>\nusing namespace std;\n\nlong long N, M, A[100009], B[100009], T[100009], dp[100009], ans[100009]; vector<int>Z[100009], X[100009]; vector<pair<int, int>>P;\n\nclass MergeTech {\npublic:\n\tvector<vector<int>>G; vector<int>group; vector<pair<int, int>> maxn;\n\tvoid init(int size_) {\n\t\tG.resize(size_, vector<int>(0, 0));\n\t\tgroup.resize(size_, 0);\n\t\tmaxn.resize(size_, make_pair(0, 0));\n\t\tfor (int i = 0; i < size_; i++) {\n\t\t\tG[i].push_back(i);\n\t\t\tgroup[i] = i;\n\t\t\tmaxn[i] = make_pair(A[i], i);\n\t\t}\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u]; v = group[v];\n\t\tif (G[u].size() < G[v].size()) swap(u, v); if (u == v) return;\n\t\tmaxn[u] = max(maxn[u], maxn[v]);\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tpair<int, int> maxv(int pos) {\n\t\treturn maxn[group[pos]];\n\t}\n};\n\nvoid dfs1(int pos) {\n\tdp[pos] = B[pos];\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tdfs1(X[pos][i]);\n\t\tdp[pos] += dp[X[pos][i]];\n\t}\n}\n\nvoid dfs2(int pos) {\n\tvector<tuple<long long, long long, long long>>D;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tdfs2(X[pos][i]);\n\t\tD.push_back(make_tuple(ans[X[pos][i]] - dp[X[pos][i]], ans[X[pos][i]], dp[X[pos][i]]));\n\t}\n\tsort(D.begin(), D.end(), greater<tuple<long long, long long, long long>>());\n\tif (D.size() == 0) {\n\t\tans[pos] = max(A[pos], B[pos]);\n\t\treturn;\n\t}\n\n\tlong long minx = (1LL << 60);\n\tfor (int i = 0; i < D.size(); i++) {\n\t\tvector<tuple<long long, long long, long long>>E = D;\n\t\tget<1>(E[i]) = max(get<1>(E[i]) + B[pos], A[pos]); get<2>(E[i]) += B[pos]; get<0>(E[i]) = get<1>(E[i]) - get<2>(E[i]);\n\t\tsort(E.begin(), E.end(), greater<tuple<long long, long long, long long>>());\n\n\t\tlong long ret = 0;\n\t\tfor (int j = E.size() - 1; j >= 0; j--) {\n\t\t\tret += get<2>(E[j]); ret = max(ret, get<1>(E[j]));\n\t\t}\n\t\tminx = min(minx, ret);\n\t}\n\tans[pos] = minx;\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 1; i <= N; i++) {\n\t\tcin >> A[i] >> B[i]; P.push_back(make_pair(A[i], i));\n\t}\n\tfor (int i = 1; i <= M; i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tZ[u].push_back(v);\n\t\tZ[v].push_back(u);\n\t}\n\tsort(P.begin(), P.end());\n\tfor (int i = 0; i < P.size(); i++) T[P[i].second] = i;\n\tMergeTech UF; UF.init(N + 2);\n\tfor (int i = 0; i < P.size(); i++) {\n\t\tpair<int, int>V = make_pair(-1, -1); int pos = P[i].second;\n\t\tfor (int j = 0; j < Z[pos].size(); j++) {\n\t\t\tif (UF.same(pos, Z[pos][j]) == true) continue;\n\n\t\t\tpair<int, int>V = make_pair(-1, -1);\n\t\t\tif (T[pos] > T[Z[pos][j]]) {\n\t\t\t\tV = max(V, UF.maxv(Z[pos][j]));\n\t\t\t\tX[pos].push_back(V.second);\n\t\t\t\tUF.unite(pos, Z[pos][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint root = P[P.size() - 1].second;\n\tdfs1(root);\n\tdfs2(root);\n\tcout << ans[root] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,a[N],b[N],pos[N],fa[N],h[N];\nll f[N],g[N];\nvector<int> e[N];\nbool cmp(int x,int y){return a[x]<a[y];}\nint find(int x){return (x==fa[x]) ? x : fa[x]=find(fa[x]);}\nvoid merge(int x,int y){\n\ty=find(y);fa[y]=x;\n\tg[x]+=g[y];\n\tf[x]=min(f[x],max(f[y],a[x]-g[y]));\n}\nint main(){\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=read();b[i]=read();a[i]=max(a[i]-b[i],0);\n\t\tpos[i]=fa[i]=i;f[i]=a[i];g[i]=b[i];\n\t}\n\twhile (m--){\n\t\tint u=read(),v=read();\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tsort(pos+1,pos+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint x=pos[i];h[x]=1;\n\t\tfor (auto y : e[x])\n\t\tif (h[y]&&(find(y)!=x)) merge(x,y);\n\t}\n\tprintf(\"%lld\\n\",f[find(1)]+g[find(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-09 19:16:44\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\n#include<vector>\nconst int N=100010;\ni64 n,m,a[N],b[N],f[N],F[N],rk[N],s[N];\nint getf(int u){ return u==F[u]?u:F[u]=getf(F[u]); }\nstd::vector<int> E[N],e[N];\nint cmp(int x,int y){ return a[x]-b[x]>a[y]-b[y]; }\nvoid dfs(int u)\n{\n\ts[u]=b[u]; f[u]=a[u]-b[u];\n\tfr(i,0,e[u].size()-1)\n\t{\n\t\tdfs(e[u][i]);\n\t\ts[u]+=s[e[u][i]]; f[u]=std::min(f[u],std::max(a[u]-b[u]-s[e[u][i]],f[e[u][i]]));\n\t}\n}\nint main()\n{\n\tn=read(); m=read();\n\tfr(i,1,n){ a[i]=read(); b[i]=read(); a[i]=std::max(a[i],b[i]); }\n\tfr(i,1,m)\n\t{\n\t\tint u=read(),v=read();\n\t\tE[u].push_back(v); E[v].push_back(u);\n\t}\n\tfr(i,1,n) rk[i]=i;\n\tstd::sort(rk+1,rk+n+1,cmp);\n\tfd(I,n,1)\n\t{\n\t\tint i=rk[I]; F[i]=i;\n\t\tfr(j,0,E[i].size()-1) if(F[E[i][j]])\n\t\t{\n\t\t\tint p=getf(E[i][j]);\n\t\t\tif(p!=i){ F[p]=i; e[i].push_back(p); }\n\t\t}\n\t}\n\tdfs(rk[1]);\n\tprintf(\"%lld\\n\",f[rk[1]]+s[rk[1]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<bitset>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<stack>\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define SIZE(a) ll(a.size())\n#define vll vector<ll> \n#define MEMSET(a, n, m) for(ll i=0;i<=n;i++) a[i] = m\n#define BIT(n) (ll(1)<<n)\n#define UNIQUE(v) v.erase(unique(v.begin(),v.end()),v.end()) \n#define UNIQUE_ARRAY(a,n) n = unique(a + 1, a + x + 1) - a - 1\n#define SORT(a,n) sort(a+1,a+n+1)\n#define SORT_O(a,n,order) sort(a+1,a+n+1,order)\n#define PER(i,y,x) for(ll i=y;i>=x;i--)\ntypedef long long ll;\nusing namespace std;\n\nll const MAX = 200005;\nll parent[MAX];\nll rk[MAX];\nll get_money[MAX];\nll min_money[MAX];\n\n\nvoid init(ll n) {\n\tfor (ll i = 1; i <= n; i++) {\n\t\tparent[i] = i;\n\t\trk[i] = 1;\n\t}\n}\n\nll find(ll x) {\n\tif (parent[x] == x) {\n\t\treturn x;\n\t}\n\tparent[x] = find(parent[x]);\n\treturn parent[x];\n}\n\nbool same(ll x, ll y) {\n\treturn find(x) == find(y);\n}\n\nvoid unite(ll x, ll y) {\n\tif (!same(x, y)) {\n\t\tx = parent[x];\n\t\ty = parent[y];\n\t\tif (rk[x] < rk[y]) {\n\t\t\tparent[x] = y;\n\t\t}\n\t\telse {\n\t\t\tparent[y] = x;\n\t\t\tif (rk[x] == rk[y]) {\n\t\t\t\trk[x]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nstruct edge\n{\n\tlong long val; long long from; long long to;\n\tbool operator<(const edge& rhs) const {\n\treturn val > rhs.val;\n\t}\n};\npriority_queue<edge> pq;\n\nll a[MAX], b[MAX];\n\nvoid uni(ll f, ll t) {\n\tif (a[f] > a[t]) {\n\t\tswap(f, t);\n\t}\n\tll bf = find(f); ll bt = find(t);\n\tll money = get_money[bf] + get_money[bt];\n\tll min_val1 = max(min_money[bf], a[t] - get_money[bf]);\n\tll min_val = min(min_val1, min_money[bt]);\n\tunite(f, t);\n\tll r = find(f);\n\tmin_money[r] = min_val;\n\tget_money[r] = money;\n}\n\nll make_mst(ll n) {\n\tREP(i, 1, n) {\n\t\tmin_money[i] = a[i];\n\t\tget_money[i] = b[i];\n\t}\n\tll cnt = n - 1;\n\twhile (cnt > 0) {\n\t\tedge cur = pq.top();\n\t\tpq.pop();\n\t\tll f = cur.from; ll t = cur.to;\n\t\tif (!same(f, t)) {\n\t\t\tuni(f, t);\n\t\t\tcnt--;\n\t\t}\n\t}\n\treturn min_money[find(1)];\n}\n\nint main() {\n\tll n, m;\n\tcin >> n >> m;\n\tll ttl = 0;\n\tREP(i, 1, n) {\n\t\tcin >> a[i] >> b[i];\n\t\tttl += b[i];\n\t\ta[i] -= b[i];\n\t}\n\tREP(i, 1, m) {\n\t\tll u, v;\n\t\tcin >> u >> v;\n\t\tpq.push({ max(a[v], a[u]), u, v });\n\t}\n\tinit(n);\n\tll ans = 0;\n\tans = make_mst(n);\n\tcout << max(ans,ll(0)) + ttl << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dsu {\n    int n;\n    vector<int> p;\n    \n    Dsu(int _n) { n = _n; p.resize(n); init(); }\n    inline void init() {\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n    }\n    inline int find(int x) {\n        return p[x] == x ? x: p[x] = find(p[x]);\n    }\n    inline bool join(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        p[y] = x; return true;\n    }\n    inline bool check(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nusing ll=long long ;\nvoid solve() {\n    int n,m;\n    cin >> n >> m;\n    vector<int> a(n), b(n);\n    vector<vector<int>> g(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i] >> b[i];\n    }\n    for (int _ = 0; _ < m; _++) {\n        int x,y;\n        cin >> x >> y;\n        x--;y--;\n        g[x].emplace_back(y);\n        g[y].emplace_back(x);\n    }\n    vector<int> id(n);\n    iota(id.begin(), id.end(), 0);\n    sort(id.begin(), id.end(), [&](int i, int j){\n            return a[i]-b[i] < a[j]-b[j];\n            });\n    Dsu d(n);\n    vector<ll> base(n);\n    vector<ll> need(n);\n    for (int i = 0; i < n; i++) {\n        base[i] = b[i];\n        need[i] = max(a[i], b[i]);\n    }\n    vector<bool> trk(n, false);\n    for (int u: id) {\n        trk[u] = true;\n        set<int> s;\n        for (int v: g[u]) {\n            if (trk[v]) {\n                s.insert(d.find(v));\n            }\n        }\n        if (s.empty()) continue;\n        for (int v: s) {\n            base[u] += base[v];\n            d.join(u, v);\n        }\n        ll leaving_need = max(a[u]-b[u], 0);\n        ll optim = 1e18;\n        for (int v: s) {\n            ll leaving = max(need[v], leaving_need);\n            ll before = base[u] - base[v];\n            optim = min(optim, leaving + before);\n        }\n        need[u] = optim;\n    }\n    ll res = need[d.find(0)];\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define PII pair<int, int>\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\nusing namespace std;\ntemplate<typename T> inline void gmax(T &x, T y){x = x > y ? x : y;}\ntemplate<typename T> inline void gmin(T &x, T y){x = x < y ? x : y;}\nconst int MAXN = 100010;\nint n, m;\nLL a[MAXN], b[MAXN], v[MAXN];\nint id[MAXN];\nvector<int> G[MAXN];\ninline bool cmp(const int &a, const int &b){return v[a] < v[b];}\nint f[MAXN];\ninline int find(int x){return f[x] == x ? f[x] : f[x] = find(f[x]);}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld%lld\", &a[i], &b[i]), v[i] = max(a[i] - b[i], 0LL), id[i] = i;\n\tsort(id + 1, id + n + 1, cmp);\n\tfor(int i = 1; i <= m; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].PB(y);\n\t\tG[y].PB(x);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tint x = id[i];\n\t\tf[x] = x;\n\t\tLL tmp = v[x];\n\t\tfor(unsigned j = 0; j < G[x].size(); j++){\n\t\t\tint y = G[x][j];\n\t\t\tif(f[y] || (y = find(y)) == x) continue;\n\t\t\tf[y] = x;\n\t\t\tb[x] += b[y];\n\t\t\tgmin(v[x], max(v[y], tmp) - b[y]); \n\t\t}\n\t\tv[x] += b[x];\n\t}\n\tprintf(\"%lld\\n\", v[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n    ifstream t(\"/proc/self/status\");\n    cerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = (sum << 3) + (sum << 1) - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n, m;\n\nstruct node\n{\n\tint u, A, B, val;\n\n\tinline bool operator < (const node &rhs) const { return this->val < rhs.val; }\n\n\tnode() { }\n\tnode(int _u, int _A, int _B): u(_u), A(_A), B(_B), val(max(_A - _B, 0)) { }\n}a[MAXN + 5];\n\nint A[MAXN + 5], B[MAXN + 5], val[MAXN + 5];\n\nvector<int> adj[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>(), m = read<int>();\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint A0 = read<int>(), B0 = read<int>();\n\t\ta[i] = node(i, A0, B0);\n\t\tA[i] = A0, B[i] = B0, val[i] = max(A0 - B0, 0);\n\t}\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint u = read<int>(), v = read<int>();\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n}\n\nnamespace DSU\n{\n\tint fa[MAXN + 5];\n\n\tinline void init(int N) { for(int i = 1; i <= N; ++i) fa[i] = i; }\n\tinline int get_fa(int u) { return u == fa[u] ? u : fa[u] = get_fa(fa[u]); }\n\tinline void link(int u, int v) { fa[get_fa(v)] = get_fa(u); }\n}\n\ninline void solve()\n{\n\tsort(a + 1, a + n + 1);\n\n\tstatic LL f[MAXN + 5], sum[MAXN + 5];\n\tstatic int rnk[MAXN + 5];\n\n\tDSU::init(n);\n\tfor(int i = 1; i <= n; ++i) f[i] = val[i], sum[i] = B[i], rnk[a[i].u] = i;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint u = a[i].u;\n\t\tfor(auto v0 : adj[u])\n\t\t{\n\t\t\tint v = DSU::get_fa(v0);\n\t\t\tif(u != v && rnk[u] > rnk[v])\n\t\t\t{\n\t\t\t\tchkmin(f[u], max(f[v], val[u] - sum[v]));\n\t\t\t\tsum[u] += sum[v];\n\t\t\t\tDSU::link(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", f[a[n].u] + sum[a[n].u]);\n}\n\nint main()\n{\n//\tfreopen(\"F.in\", \"r\", stdin);\n//\tfreopen(\"F.out\", \"w\", stdout);\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\nstruct edge{\n\tint to,next;\n}e[N*2];\nint n,m,tot,head[N];\nint a[N],b[N],id[N],fa[N];\nlong long qd[N],S[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot;\n}\nint get(int x){\n\treturn fa[x]==x?x:fa[x]=get(fa[x]);\n}\nint vis[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0);\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tid[i]=i,fa[i]=i,qd[i]=a[i],S[i]=b[i]; \n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint x=id[i]; vis[x]=1;\n\t\tfor (int j=head[x];j;j=e[j].next)\n\t\t\tif (vis[e[j].to]){\n\t\t\t\tint X=get(x),Y=get(e[j].to);\n\t\t\t\tif (X==Y) continue;\n\t\t\t\tfa[Y]=X; S[X]+=S[Y];\n\t\t\t\tqd[X]=min(qd[X],qd[Y]+max(0ll,a[x]-S[Y]-qd[Y]));\n\t\t\t}\n\t}\n\tint x=get(1);\n\tprintf(\"%lld\",qd[x]+S[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,m,x,y,a[100001],b[100001],f[100001],p[100001],bz[100001],o;\nll c[100001],dp[100001],sum[100001];\nint hed[100001],too[200001],nxt[200001],tot;\nvoid link(int x,int y)\n{\n\tnxt[++tot]=hed[x];\n\ttoo[tot]=y;\n\thed[x]=tot;\n}\nint find(int x)\n{\n\treturn f[x]=(x==f[x]?x:find(f[x]));\n}\nbool cmp(int x,int y)\n{\n\treturn c[x]<c[y];\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d %d\",&a[i],&b[i]),c[i]=max(0,a[i]-b[i]),p[i]=f[i]=i,sum[i]=b[i];\n\tfor (int i=1;i<=m;i++)scanf(\"%d %d\",&x,&y),link(x,y),link(y,x);\n\tsort(p+1,p+1+n,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tvector<int> son;\n\t\tint u=p[i];\n\t\tbz[u]=1;\n\t\tfor (int vv=hed[u];vv;vv=nxt[vv])\n\t\t{\n\t\t\tint v=too[vv];\n\t\t\tif (bz[v])\n\t\t\t{\n\t\t\t\tint x=find(u),y=find(v);\n\t\t\t\tif (x!=y)sum[u]+=sum[y],f[y]=u,son.push_back(y);\n\t\t\t}\n\t\t}\n\t\tdp[u]=c[u]+sum[u];\n\t\tfor (int j=0;j<son.size();j++)o=son[j],dp[u]=min(dp[u],sum[u]-sum[o]+max(c[u],dp[o]));\n\t}\n\tprintf(\"%lld\\n\",dp[find(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "//嘘解法。2分探索 + 全域木 (A_iが小さい順に見ていく. プリム法.)\n//そりゃあダメですね。\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <tuple>\n#define int long long\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint n, m;\nint a[100001], b[100001];\t//超頂点nを用意. a[n] = b[n] = 0;\nvector<int> et[100001];\nvector<int> ec[100001];\n\nbool check(int zankin) {\n\tstatic bool visited[100001];\n\tint i;\n\tfor (i = 0; i <= n; i++) visited[i] = false;\n\t\n\tqueue<int> que;\n\tfor (i = 0; i <= n; i++) {\n\t\tif (a[i] <= zankin) {\n\t\t\tque.push(i);\n\t\t\tvisited[i] = true;\n\t\t\tzankin += b[i];\n\t\t}\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (i = 0; i < et[v].size(); i++) {\n\t\t\tint nv = et[v][i];\n\t\t\tif (!visited[nv] && a[nv] <= zankin) {\n\t\t\t\tque.push(nv);\n\t\t\t\tvisited[nv] = true;\n\t\t\t\tzankin += b[nv];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (i = 0; i <= n; i++) if (!visited[i]) return false;\n\treturn true;\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tfor (i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tet[u].push_back(v); ec[u].push_back(a[v]);\n\t\tet[v].push_back(u); ec[v].push_back(a[u]);\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tet[n].push_back(i);\n\t\tec[n].push_back(a[i]);\n\t}\n\t\n\tint st = -1, ed = 1e+16, mid;\t//(st, ed], xxxooo\n\twhile (ed - st >= 2) {\n\t\tmid = (st + ed) / 2;\n\t\tif (check(mid)) { ed = mid; }\n\t\telse { st = mid; }\n\t}\n\t\n\tint bsum = 0;\n\tfor (i = 0; i < n; i++) bsum += b[i];\n\t\n\tcout << ed + bsum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000000000000ll\nusing namespace std;\nint i,j,k,l,n,m,x,y,last[N],to[2*N],Next[2*N],fa[N],id[N],V[N],v[N];\nint tot,q[N];\nlong long A[N],s[N];\nstruct node {\n\tint x,y;\n}a[N];\ninline void add(int x,int y) {\n\tNext[++tot]=last[x]; last[x]=tot; to[tot]=y;\n}\ninline bool cmp(int x,int y) {\n\treturn a[x].x<a[y].x;\n}\ninline int get(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=get(fa[x]);\n}\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i=1;i<=n;i++) scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tfor (i=1;i<=m;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tfor (i=1;i<=n;i++) fa[i]=id[i]=i,V[i]=0;\n\tsort(id+1,id+1+n,cmp);\n\tfor (i=1;i<=n;i++) {\n\t\tint r=0;\n\t\tV[id[i]]=1;\n\t\tfor (j=last[id[i]];j;j=Next[j]) {\n\t\t\tif (!V[to[j]]) continue;\n\t\t\tif (v[get(to[j])]!=id[i]) {\n\t\t\t\tq[++r]=get(to[j]),v[get(to[j])]=id[i];\n\t\t\t}\n\t\t}\n\t\tlong long S=0,M=inf;\n\t\tif (!r) {\n\t\t\tA[id[i]]=s[id[i]]=a[id[i]].y;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j=1;j<=r;j++) S+=s[q[j]];\n\t\tfor (j=1;j<=r;j++) M=min(M,max(1ll*a[id[i]].x,A[q[j]]+a[id[i]].y)+S-s[q[j]]);\n\t\tfor (j=1;j<=r;j++) fa[q[j]]=id[i];\n\t\ts[id[i]]=S+a[id[i]].y;\n\t\tA[id[i]]=M;\n\t}\n\tprintf(\"%I64d\\n\",A[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N],A[N],dp[N],fa[N];\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tn=read<int>(),m=read<int>();\n\tFor(i,1,n)a[i]=read<int>(),b[i]=read<int>();\n\tint x,y;\n\tFor(i,1,m)\n\t{\n\t\tx=read<int>(),y=read<int>();\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nbool cmp(int x,int y)\n{\n\treturn  A[x]<A[y];\n}\nint id[N],sum[N],vis[N];\nvoid work()\n{\n\tFor(i,1,n)dp[i]=A[i]=max(a[i]-b[i],0),sum[i]=b[i];\n\tFor(i,1,n)id[i]=fa[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tint u,x,y;\n\tFor(i,1,n)\n\t{\n\t\tu=id[i];\n\t\tx=find(u);\n\t\tfor(int v:E[u])if(vis[v])\n\t\t{\n\t\t\ty=find(v);\n\t\t\tif(x==y)continue;\n\t\t\tfa[y]=x,sum[x]+=sum[y];\n\t\t\tcmin(dp[x],max(dp[y],A[x]-sum[y]));\n\t\t}\n\t\tvis[u]=1;\n\t}\n\twrite(dp[id[n]]+sum[id[n]],'\\n');\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\ntypedef pair<int, int> P;\nvector<int> G[N];\nP p[N];\nint fa[N], a[N], b[N], vis[N], dp[N];\nlong long sz[N];\nint F(int x) { return x == fa[x] ? x : (fa[x] = F(fa[x])); }\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n        p[i] = P(max(0, a[i] - b[i]), i);\n        fa[i] = i;\n        sz[i] = b[i];\n    }\n    for(int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    sort(p + 1, p + n + 1);\n    for(int i = 1; i <= n; i++) {\n        int x = p[i].second, mn = p[i].first;\n        vis[x] = 1;\n        for(int v : G[x]) {\n            if(vis[v]) {\n                int fv = F(v);\n                mn = min(mn, max(p[i].first - sz[fv], dp[fv]));\n            }\n        }\n        for(int v : G[x]) {\n            if(vis[v]) {\n                int fv = F(v);\n                if(fv == x) continue;\n                fa[fv] = x;\n                sz[x] += sz[fv];\n            }\n        }\n        dp[x] = mn;\n    }\n    cout << dp[F(1)] + sz[F(1)] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nint par[N],n,sum[N],v[N],b[N],m;\nvector<int>g[N];\nvector<pair<int,int>>temp;\nbool vis[N];\nint get(int u){return par[u] == u ? u : par[u] = get(par[u]);}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0,a;i < n;i++){\n\t\tpar[i] = i;\n\t\tscanf(\"%d%d\",&a,b + i);\n\t\ttemp.push_back({a - b[i],i});\n\t}\n\tfor(int i = 0,a,b;i < m;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[--a].push_back(--b);\n\t\tg[b].push_back(a);\n\t}\n\tsort(temp.begin(),temp.end());\n\tfor(auto i : temp){\n\t\tint need = max(0,i.first),at = i.second;\n\t\tsum[at] = b[at];\n\t\tv[at] = need;\n\t\tvis[at] = 1;\n\t\tfor(auto j : g[at]){\n\t\t\tint from = get(j);\n\t\t\tif(from == at || !vis[from])continue;\n\t\t\tsum[at]+=sum[from];\n\t\t\tif(sum[from] + v[from] >= need)v[at] = min(v[at],v[from]);\n\t\t\telse v[at] = min(v[at],need - sum[from]);\n\t\t\tpar[from] = at;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",sum[temp.back().second] + v[temp.back().second]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ld double\n#define ull unsigned long long\n#define ll long long\n#define pii pair <int, int>\n#define iiii pair <int, pii>\n#define mp make_pair\n#define INF 1000000000\n#define MOD 1000000007\n#define rep(i, x) for(int (i) = 0; (i) < (x); (i)++)\ninline int getint() {\n  int x = 0, p = 1; char c = getchar();\t\n  while (c <= 32) c = getchar();\n  if (c == 45) p = -p, c = getchar();\n  while (c > 32) x = x * 10 + c - 48, c = getchar();\n  return x * p;\n}\nusing namespace std;\n//ruogu_alter\nconst int N = 1e5 + 5;\nint n, m, a[N], b[N], c[N], id[N], par[N];\nll f[N], s[N];\nbool vis[N];\nvector<int> g[N];\n//\nint findset(int x) {\n  return par[x] == x ? x : par[x] = findset(par[x]);\n}\nbool cmp(int x, int y) {\n  return a[x] < a[y];\n}\nint main() {\n  n = getint(); m = getint();\n  rep(i, n) {\n    a[i] = getint(), b[i] = getint();\n    a[i] = max(a[i] - b[i], 0);\n    par[i] = id[i] = i;\n    f[i] = a[i] + b[i]; s[i] = b[i];\n  }\n  rep(i, m) {\n    int x = getint() - 1, y = getint() - 1;\n    g[x].emplace_back(y);\n    g[y].emplace_back(x);\n  }\n  sort(id, id + n, cmp);\n  rep(ii, n) {\n    int x = id[ii]; vis[x] = true;\n    rep(i, g[x].size()) {\n      int to = findset(g[x][i]);\n      if (!vis[to] || to == x) continue;\n      f[x] = min(f[x] + s[to], s[x] + max(f[to], 1ll * a[x]));\n      s[x] += s[to]; par[to] = x;\n    }\n  }\n  cout << f[findset(0)] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, m, cnt, top, s, maxi, now, sta[Maxn], a[Maxn], b[Maxn], w[Maxn], head[Maxn];\nlong long sum[Maxn], mini[Maxn];\nvector <int> Ve[Maxn];\nqueue <int> Qu;\nbool vis[Maxn], vis2[Maxn];\nstruct edg\n{\n\tint nxt, to;\n}edge[2 * Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs(int u)\n{\n\tvis2[u] = true;\n\tsta[++top] = u;\n\tif (w[u] > maxi) maxi = w[u], now = u;\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tif (!vis[to] && !vis2[to])\n\t\t\tdfs(to);\n\t}\n}\nvoid dfs2(int u)\n{\n\tmini[u] = 0x3f3f3f3f3f3f3f3f;\n\tsum[u] = b[u];\n\tfor (vector <int> :: iterator it = Ve[u].begin(); it != Ve[u].end(); it++)\n\t{\n\t\tint to = *it;\n\t\tdfs2(to);\n\t\tsum[u] += sum[to];\n\t\tmini[u] = min(mini[u], max((long long) w[u], mini[to]) - sum[to]);\n\t}\n\tif (!Ve[u].size()) mini[u] = w[u] + b[u];\n\telse mini[u] += sum[u];\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0, a[i] - b[i]);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (w[i] > maxi) maxi = w[i], s = i;\n\tQu.push(s);\n\twhile (!Qu.empty())\n\t{\n\t\tint u = Qu.front();\n\t\tvis[u] = true;\n\t\tQu.pop();\n\t\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tnow = -1, maxi = -1;\n\t\t\tint to = edge[i].to;\n\t\t\tif (vis[to] || vis2[to]) continue;\n\t\t\tdfs(to);\n\t\t\tif (now != -1)\n\t\t\t{\n\t\t\t\tVe[u].push_back(now);\n\t\t\t\tQu.push(now);\n\t\t\t}\n\t\t}\n\t\twhile (top) vis2[sta[top--]] = false;\n\t}\n\tdfs2(s);\n\tprintf(\"%lld\", mini[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define LL long long \n#define N 300000\n#define INF 0x3f3f3f3f\n\nLL n,m,x,y,a[N],b[N],c[N],d[N],f[N],fa[N],sum[N],tot,head[N];\nbool vis[N];\nstruct edge{LL v,nxt;}e[N];\nvector<LL> vec[N];\n\nvoid add(LL x,LL y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool cmp(LL x,LL y){return c[x]<c[y];}\n\nLL gfa(LL x){return !fa[x]?x:fa[x]=gfa(fa[x]);}\n\nvoid dp(LL u){\n\tsum[u]=b[u]; f[u]=INF;\n\tfor (LL i=0,v;i<(LL)vec[u].size();++i){dp(v=vec[u][i]); sum[u]+=sum[v];}\n\tif (!vec[u].size()){f[u]=b[u]+c[u]; return;}\n\tfor (LL i=0,v;i<(LL)vec[u].size();++i){\n\t\tv=vec[u][i];\n\t\tf[u]=min(f[u],sum[u]-sum[v]+max(c[u],f[v]));\n\t}\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor (LL i=1;i<=n;++i){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]=max(a[i],b[i]);\n\t\tc[i]=a[i]-b[i];\n\t\td[i]=i;\n\t}\n\tfor (LL i=1;i<=m;++i){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tfor (LL i=1;i<=n;++i){\n\t\tLL x=d[i];\n\t\tfor (LL j=head[x];j;j=e[j].nxt)\n\t\t\tif (vis[e[j].v]){\n\t\t\t\tLL y=gfa(e[j].v);\n\t\t\t\tif (x!=y){fa[y]=x; vec[x].push_back(y);}\n\t\t\t}\n\t\tvis[x]=1;\n\t}\n\tdp(d[n]);\n\tprintf(\"%lld\\n\",f[d[n]]);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60) + 1e9;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass UF{\npublic:\n  Int V;\n  vector<Int> par,rnk,sz;\n  UF(){}\n  UF(Int V):V(V),par(V),rnk(V,0),sz(V,1){for(Int i=0;i<V;i++)par[i]=i;}\n  \n  Int find(Int x){\n    assert(x < V);\n    if(par[x]==x)return x;\n    return par[x]=find(par[x]);\n  }\n  \n  void unite(Int x,Int y){\n    x=find(x), y=find(y);\n    if(x==y)return;\n    if(rnk[x]<rnk[y])par[x]=y, sz[y] += sz[x];\n    else{\n      par[y]=x;\n      sz[x] += sz[y];\n      if(rnk[x]==rnk[y])rnk[x]++;\n    }\n  }\n\n  bool same(Int x,Int y){return find(x)==find(y);}\n\n  Int size(Int x){return sz[find(x)];}\n};\n\n\nInt n;\nvector<vector<Int> > G;\nvector<Int> A, B;\n\nInt solve(){\n  vector<Int> ord(n); iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](Int a,Int b){return A[a] - B[a] < A[b] - B[b];});\n  vector<Int> dp(n,INF);\n  \n  UF uf(n);\n  for(Int i=0;i<n;i++) uf.sz[i] = B[i];\n  \n  vector<Int> used(n, 0);\n  for(Int v:ord){\n    assert(v == uf.find(v));\n    Int c = max(0LL, A[v] - B[v]);\n    used[v] = 1;\n    Int mn = INF;\n    for(Int to:G[v]){\n      to = uf.find(to);\n      if(used[to] == 0) continue;\n      Int a = max(0LL, c - uf.size(to));\n      Int b = dp[to];\n      Min(mn, max(a, b));\n      uf.unite(v, to);\n    }\n    v = uf.find(v);\n    if(mn == INF) mn = c;\n    dp[v] = mn;\n  }\n\n  Int res = accumulate(B.begin(), B.end(), 0LL);\n  assert(res == uf.size(0));\n  Int last = uf.find(ord.back());\n  res += max(0LL, dp[last]);\n  return res;\n}\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int m;\n  cin>>n>>m;\n  G.resize(n);\n  A.resize(n); B.resize(n);\n  for(Int i=0;i<n;i++) cin>>A[i]>>B[i];\n  \n  for(Int i=0;i<m;i++){\n    Int u, v;\n    cin>>u>>v; u--, v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  Int ans = solve();\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n\n#include <vector>\n#include <set>\n#include <bitset>\n#include <map>\n#include <deque>\n#include <string>\n\n#include <algorithm>\n#include <numeric>\n#include <random>\n\n#include <cstdio>\n#include <cassert>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n\nusing namespace std;\n\n#define forn(i, n) for (ll i = 0; i < (ll) (n); ++i)\n#define sz(a) static_cast<int>((a).size())\n#define endl '\\n'\n\nusing ll = long long;\n\nconst ll INF = static_cast<ll>(1e9) + 7;\nconst int MAXN = static_cast<int>(1e6) + 17;\n\nint n, k, q;\nint a[MAXN];\n\nbool read() {\n    if (!(cin >> n >> k >> q))\n        return false;\n\n    forn (i, n)\n        cin >> a[i];\n\n    return true;\n}\n\nbool check(const vector< vector<int> >& kek, int x) {\n    int res = 0;\n\n    for (auto& v : kek)\n        res += min(int(upper_bound(v.begin(), v.end(), x) - v.begin()), max(0, sz(v) - k + 1));\n\n    return res >= q;\n}\n\nll calc(int x) {\n    vector< vector<int> > kek;\n    kek.push_back(vector<int>());\n\n    forn (i, n)\n        if (a[i] < x) {\n            if (!kek.back().empty())\n                kek.push_back(vector<int>());\n        } else {\n            kek.back().push_back(a[i]);\n        }\n\n    for (auto& v : kek)\n        sort(v.begin(), v.end());\n\n    if (!check(kek, INF))\n        return INF;\n\n    ll l = x, r = INF;\n\n    for (; l < r; ) {\n        auto m = (l + r) / 2;\n\n        if (check(kek, m))\n            r = m;\n        else\n            l = m + 1;\n    }\n\n    return r - x;\n}\n\nvoid solve() {\n    ll ans = INF;\n\n    forn (i, n)\n        ans = min(ans, calc(a[i]));\n\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    std::mt19937 rand('S' + 'E' + 'R' + 'E' + 'Z' + 'H' + 'K' + 'A');\n\n#ifdef SEREZHKA\n    freopen(\"file.in\", \"r\", stdin);\n#endif\n\n    while (read())\n        solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll a[100005],b[100005];\n\nstruct quickfind{\n\tint par[200005];\n\tll val[200005];\n\tpriority_queue<P,vector<P>,greater<P> > que[200005];\n\tquickfind(){\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\tval[i]=b[i];\n\t\t\twhile(que[i].size())que[i].pop();\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\n\tll getval(int x){\n\t\treturn val[find(x)];\n\t}\n\n\tvoid insert(int x,P y){\n\t\tque[find(x)].push(y);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)return;\n\t\tif(que[x].size()<que[y].size()){\n\t\t\tpar[x]=y;\n\t\t\tval[y]+=val[x];\n\t\t\twhile(que[x].size()){\n\t\t\t\tque[y].push(que[x].top());\n\t\t\t\tque[x].pop();\n\t\t\t}\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tval[x]+=val[y];\n\t\t\twhile(que[y].size()){\n\t\t\t\tque[x].push(que[y].top());\n\t\t\t\tque[y].pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nquickfind qi;\nint n,m;\n\nvector<int> G[100005];\nbool flag[200005];\nbool searched[200005];\nll maxi=0;\n\nbool C(ll val){\n\tmemset(flag,false,sizeof(flag));\n\tmemset(searched,false,sizeof(searched));\n\tmaxi=0;\n\tqi.init(n);\n\tfor(int i=0;i<n;i++){\n\t\tif(val+b[i]>=a[i]){\n\t\t\tif(val<=52){\n\t\t\t\t//printf(\"st %lld %d\\n\",val,i);\n\t\t\t}\n\t\t\tflag[i]=true;\n\t\t\tmaxi=max(maxi,b[i]+val);\n\t\t}\n\t}\n\tqueue<int> nxt;\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfor(int i=0;i<n;i++){\n\t\tif(flag[i]){\n\t\t\tsearched[i]=true;\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tint v=G[i][j];\n\t\t\t\tif(flag[v]){\n\t\t\t\t\t//printf(\"unite %d-%d\\n\",i,v);\n\t\t\t\t\tqi.unite(i,v);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(i));\n\t\t\t\t}else if(val+qi.getval(i)>=a[v]-b[v]){\n\t\t\t\t\t//printf(\"unite %d-%d\\n\",i,v);\n\t\t\t\t\tflag[v]=true;\n\t\t\t\t\tqi.unite(i,v);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(i));\n\t\t\t\t\tnxt.push(v);\n\t\t\t\t}else{\n\t\t\t\t\t//printf(\"que in%d->%d\\n\",i,v);\n\t\t\t\t\tque.push(P(a[v],v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile(nxt.size() || que.size()){\n\t\tif(nxt.size()){\n\t\t\tint v=nxt.front();\n\t\t\tnxt.pop();\n\t\t\tif(searched[v])continue;\n\t\t\tif(val<=52){\n\t\t\t\t//printf(\"%lld %lld %d\\n\",val,qi.getval(v),v);\n\t\t\t}\n\t\t\tsearched[v]=true;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint nv=G[v][i];\n\t\t\t\tif(flag[nv]){\n\t\t\t\t\tqi.unite(v,nv);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(v));\n\t\t\t\t}else if(val+qi.getval(v)>=a[nv]-b[nv]){\n\t\t\t\t\tflag[nv]=true;\n\t\t\t\t\tqi.unite(v,nv);\n\t\t\t\t\tmaxi=max(maxi,val+qi.getval(v));\n\t\t\t\t\tnxt.push(nv);\n\t\t\t\t}else{\n\t\t\t\t\tque.push(P(a[nv],nv));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\t//printf(\"f-que %d\\n\",p.second);\n\t\t\tif(p.first-b[p.second]>maxi)continue;\n\t\t\tint v=p.second;\n\t\t\tif(flag[v])continue;\n\t\t\t//printf(\"que %d\\n\",v);\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint nv=G[v][i];\n\t\t\t\tif(flag[nv] && val+qi.getval(nv)>=p.first-b[v]){\n\t\t\t\t\tflag[v]=true;\n\t\t\t\t\tnxt.push(v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(!flag[i])return false;\n\t}\n\t//printf(\"%lld\\n\",val);\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tll all=0;\n\tll l=-1,r=0;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tr+=(a[i]+b[i]);\n\t\tall+=b[i];\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\twhile(l+1LL<r){\n\t\tll mid=(l+r)/2LL;\n\t\tif(C(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tprintf(\"%lld\\n\",r+all);\n\t//printf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\nusing namespace std;\nstruct node\n{\n\tint x,id;\n}c[100010];\nint n,m,a[100010],b[100010],fa[100010];\nlong long f[100010],s[100010];\nbool used[100010];\nint cnt,head[100010],to[200010],nxt[200010];\nvector<int> v;\nvoid add(int x,int y)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n}\nbool cmp(node x,node y)\n{\n\treturn x.x<y.x;\n}\nint find(int x)\n{\n\tif (fa[x]!=x)\n\t{\n\t\tfa[x]=find(fa[x]);\n\t}\n\treturn fa[x];\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tc[i].x=max(a[i]-b[i],0);\n\t\tc[i].id=i;\n\t}\n\tsort(c+1,c+n+1,cmp);\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfa[i]=i;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint x=c[i].id;\n\t\tv.clear();\n\t\ts[x]=b[x];\n\t\tused[x]=true;\n\t\tfor (int j=head[x];j;j=nxt[j])\n\t\t{\n\t\t\tint y=to[j];\n\t\t\ty=find(y);\n\t\t\tif (!used[y] || y==find(x))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv.push_back(y);\n\t\t\ts[x]+=s[y];\n\t\t\tfa[y]=x;\n\t\t}\n\t\tf[x]=s[x]+c[i].x;\n\t\tfor (int j=0;j<v.size();j++)\n\t\t{\n\t\t\tint y=v[j];\n\t\t\tf[x]=min(f[x],s[x]-s[y]+max(1LL*c[i].x,f[y]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[c[n].id]);\n    return 0;\n}\n//羽毛似雪无瑕点，顾影秋池舞白云。\n//——李绅《忆放鹤》"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\nusing namespace std;\n\n#define ABS(a) (((a) >= 0) ? (a) : -(a))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) > (b) ? (b) : (a))\n#define FOR(i, a, b) for (int i = a; i < b; ++i)\n#define RFOR(i, a, b) for (int i = a; i > b; --i)\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> Pair;\n\n// UnionFindTree begin\nclass UnionFindTree {\n public:\n  int size_;\n  vector<int> parent_, rank_;\n\n  UnionFindTree() : size_(0), parent_(), rank_() {}\n  UnionFindTree(int size) : size_(size), parent_(size), rank_(size, 0) {\n    REP(i, size) { parent_[i] = i; }\n  }\n\n  int Find(int x) {\n   if (parent_[x] == x) {\n     return x;\n   } else {\n     int f = Find(parent_[x]);\n     parent_[x] = f;\n     return f;\n   }\n  }\n  void Unite(int x, int y) {\n    x = Find(x);\n    y = Find(y);\n    if (x == y) { return; }\n    if (rank_[x] < rank_[y]) {\n      parent_[x] = y;\n    } else if (rank_[x] > rank_[y]) {\n      parent_[y] = x;\n    } else {\n      parent_[x] = y;\n      rank_[y] += 1;\n    }\n  }\n  bool Same(int x, int y) { return (Find(x) == Find(y)); }\n\n};\n// UnionFindTree end\n\nconst int kMaxN = 100000;\nconst int kMaxM = 100000;\n\nint N, M;\nint A[kMaxN], B[kMaxN];\nint U[kMaxM], V[kMaxM];\nint ans = 0;\n\nsigned main() {\n  cin >> N >> M;\n  REP(i, N) { cin >> A[i] >> B[i]; }\n  REP(i, M) {\n    int u, v;\n    cin >> u >> v;\n    U[i] = u-1; V[i] = v-1;\n  }\n\n  int C[kMaxN];\n  REP(i, N) { C[i] = MAX(A[i]-B[i], 0); }\n  int es[kMaxM];\n  REP(i, M) { es[i] = i; }\n  auto comp = [&C](int i, int j) {\n    return MAX(C[U[i]], C[V[i]]) < MAX(C[U[j]], C[V[j]]);\n  };\n  sort(es, es+M, comp);\n  // REP(i, M) { cout << U[es[i]] << \" \" << V[es[i]] << endl; }\n  UnionFindTree uft(N);\n  int money[kMaxN];\n  REP(i, N) { money[i] = C[i] + B[i]; }\n  int bsum[kMaxN];\n  REP(i, N) { bsum[i] = B[i]; }\n\n  REP(i, M) {\n    int u = U[es[i]], v = V[es[i]];\n    if (!uft.Same(u, v)) {\n      int uu = uft.Find(u), vv = uft.Find(v);\n      uft.Unite(u, v);\n      int uv = uft.Find(u);\n      money[uv] = MIN(\n        MAX(money[uu], C[v])+bsum[vv], MAX(money[vv], C[u])+bsum[uu]);\n      bsum[uv] = bsum[uu]+bsum[vv];\n    }\n    // REP(i, N) { cout << money[i] << \" \"; }\n    // cout << endl;\n  }\n  ans = money[uft.Find(0)];\n\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 100100;\n\nint n,m,a[maxn],b[maxn],p[maxn],id[maxn];\nll f[maxn],s[maxn];\nvector<int> g[maxn];\n\nint cmp(int i,int j) {\n    return a[i] > a[j];\n}\n\nint get(int x) {\n    return ((x==p[x]) ? x : p[x] = get(p[x]));\n}\n\nint main() {\n  //  freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>m;\n    for (int i=1;i<=n;i++) {\n        cin>>a[i]>>b[i];\n        a[i] = max(a[i]-b[i],0); // all of node always need atleast ai-bi\n        id[i] = i;\n        p[i] = i;\n        s[i] = b[i]; // amount of money need to donate\n        f[i] = a[i]; // amount of money need to add more to donate all\n    }\n    for (int i=1;i<=m;i++) {\n        int x,y;\n        cin>>x>>y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    sort(id+1,id+n+1,cmp);\n    for (int i=1;i<=n;i++) {\n        int u = id[i];\n        for (auto v : g[u]) {\n            int x = get(u), y= get(v);\n           // cout<<u<<\" \"<<v<<\" \"<<x<<\" \"<<y<<endl;\n            if (x==y) continue;\n            p[y] = x;\n            s[x] += s[y];\n            ll need = max(0ll,a[x] - s[y]);\n            if (need < f[y]) f[x] = min(f[x],need);\n            else f[x] = min(f[x],f[y]);\n        }\n    }\n    int root = get(1);\n    cout<<f[root] + s[root]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n \ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nstruct node{\n\tint a,b,id;\n\tbool operator < (node &o){ return a<o.a; }\n}x[N];\nint cur[N],pa[N],n,m,u,v;\nll f[N],s[N]; vi e[N];\n\nint getpa(int x){\n\treturn pa[x]==x?x:pa[x]=getpa(pa[x]);\n}\n\nint main(){\n\tread(n),read(m);\n\trep(i,1,n){\n\t\tread(x[i].a),read(x[i].b);\n\t\tx[i].id=i;\n\t}\n\tsort(x+1,x+n+1);\n\trep(i,1,n)cur[x[i].id]=i;\n\trep(i,1,m){\n\t\tread(u),read(v);\n\t\te[cur[u]].pb(cur[v]);\n\t\te[cur[v]].pb(cur[u]);\n\t}\n\trep(i,1,n){\n\t\tpa[i]=i,s[i]=x[i].b;\n\t\tf[i]=max(x[i].a,x[i].b);\n\t}\n\trep(u,1,n){\n\t\tll mn=max(x[u].a,x[u].b),S=0;\n\t\tfor(auto v:e[u])\n\t\t\tif(v<u&&getpa(u)!=getpa(v)){\n\t\t\t\tmn=min(mn,max((ll)x[u].a,x[u].b+f[getpa(v)])-s[getpa(v)]);\n\t\t\t\tS+=s[getpa(v)];\n\t\t\t\tpa[getpa(v)]=getpa(u);\n\t\t\t}\n\t\ts[getpa(u)]=S+x[u].b;\n\t\tf[getpa(u)]=S+mn;\n\t}\n\tcout<<f[getpa(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = INT_MAX;\nconst ll MOD = 1e9+7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int N,M;cin>>N>>M;\n  vll A(N),B(N);\n  vector<pair<ll,int> > C(N);\n  vll Bsum(N);\n  vll Q(N);\n  repeat(i,N){\n    cin>>A[i]>>B[i];\n    C[i]={max(A[i]-B[i],0ll),i};\n    Bsum[i]=B[i];\n  }\n  sort(C.begin(),C.end());\n  vector<vint> g(N);\n  repeat(i,M){\n    int u,v;cin>>u>>v;u--;v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  vector<bool> used(N,false);\n  UnionFind uf(N);\n  repeat(i,N){\n    int v = C[i].second;\n    used[v]=true;\n    set<int> V;\n    for(int u:g[v])if(used[u])V.insert(uf.root(u));\n    ll Bsumsum=Bsum[v];\n    for(int u:V)Bsumsum += Bsum[u];\n    Q[v]=Bsumsum+C[i].first;\n    for(int u:V){\n      Q[v]=min(Q[v],max(Q[u],C[i].first)+Bsumsum-Bsum[u]);\n      uf.unionSet(v,u);\n    }\n    Q[uf.root(v)]=Q[v];\n    Bsum[uf.root(v)]=Bsumsum;\n  }\n  cout << Q[uf.root(0)] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int N = 500200;\nconst int mod = 1e9 + 7;\n\nll n, m, a[N], b[N], u, v;\nvector<int> g[N];\nll s;\nll dp[N];\ninline bool cmp(int i, int j) {\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint tmr, used[N];\n\ninline ll calc(ll root) {\n    if(dp[root] != -1) return dp[root];\n    ++tmr;\n    ll val = max(0ll, a[root] - b[root]);\n    set<pair<ll, ll> > q;\n    used[root] = tmr;\n    q.insert({val, root});\n    while(!q.empty()) {\n        int v = q.begin()->second;\n        q.erase(q.begin());\n        if(a[v] - b[v] <= val) {\n            val += b[v];\n        } else {\n            val = a[v];\n        }\n        for(int to : g[v]) {\n            if(used[to] != tmr) {\n                used[to] = tmr;\n                q.insert({a[to] - b[to], to});\n            }\n        }\n    }\n    return dp[root] = val;\n}\n\n\nint main() {\n    ios::sync_with_stdio(0); cin.tie(0);\n    memset(dp, -1 , sizeof dp);\n    cin >> n >> m;\n    fo(i, n) cin >> a[i] >> b[i], s += b[i];\n    fo(i, m) {\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    vector<int> roots;\n    fo(i, n) roots.pb(i);\n    sort(roots.begin(), roots.end(), &cmp);\n    ll ans = 1e18;\n    for(int s : roots) {\n        ll cur = calc(s);\n        ans = min(ans, cur);\n        if(clock() * 1.0 > 1.0 * CLOCKS_PER_SEC) break;\n    }\n    random_shuffle(roots.begin(), roots.end());\n\n    for(int s : roots) {\n        ll cur = calc(s);\n        ans = min(ans, cur);\n        if(clock() * 1.0 > 1.7 * CLOCKS_PER_SEC) break;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int N = 1e5 + 11;\nint n, m;\nint fa[N], id[N];\nLL a[N], b[N], c[N], sum[N], f[N];\nbool vis[N];\nvector<int> to[N], son;\nint find(int x){\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\nbool cmp(int x, int y){\n\treturn c[x] < c[y];\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i = 1;i <= n; i++){\n\t\tscanf(\"%lld%lld\", &a[i], &b[i]);\n\t\tc[i] = max(0ll, a[i] - b[i]);\n\t}\n\tint u, v;\n\tfor(int i = 1;i <= m; i++){\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tto[u].push_back(v);\n\t\tto[v].push_back(u);\n\t}\n\tfor(int i = 1;i <= n; i++){\n\t\tfa[i] = i, id[i] = i;\n\t}\n\tsort(id + 1, id + 1 + n, cmp);\n\tfor(int i = 1;i <= n; i++){\n\t\tint u = id[i];\n\t\tint sz = to[u].size();\n\t\tsum[u] = b[u];\n\t\tvis[u] = 1;\n\t\tson.clear();\n \t\tfor(int j = 0;j < sz; j++){\n\t\t\tint v = to[u][j];\n\t\t\tint fu = find(u), fv = find(v);\n\t\t\tif(fu == fv || !vis[v])continue;\n\t\t\tsum[u] += sum[fv];\n\t\t\tfa[fv] = fu;\n\t\t\tson.push_back(fv);\n\t\t}\n\t\tf[u] = c[u] + sum[u];\n\t\tsz = son.size();\n\t\tfor(int j = 0;j < sz; j++){\n\t\t\tint v = son[j];\n\t\t\tf[u] = min(f[u], sum[u] - sum[v] + max(c[u], f[v]));\n\t\t}\n\t}\n\tcout<<f[id[n]]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,m,f[N],id[N],a[N],b[N],c[N],tot,head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dp[N],s[N];\nvector<int>e[N];\nbool vis[N];\nint getf(int x){return f[x]==x?x:f[x]=getf(f[x]);}\nbool cmp(int x,int y){return c[x]<c[y];}\nvoid dfs(int u)\n{\n    s[u]=b[u];\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];\n        dfs(v);\n        s[u]+=s[v];\n    }\n    dp[u]=s[u]+c[u];\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];\n        dp[u]=min(dp[u],s[u]-s[v]+max(dp[v],(ll)c[u]));\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&a[i],&b[i]);\n        c[i]=max(a[i]-b[i],0);\n        f[i]=id[i]=i;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;scanf(\"%d%d\",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    sort(id+1,id+1+n,cmp);\n    for(int i=1;i<=n;i++)\n    {\n        int x=id[i];vis[x]=true;\n        for(int j=0;j<e[x].size();j++)\n        {\n            int y=e[x][j];if(!vis[y]) continue;\n            y=getf(y);\n            if(x!=y)\n            {\n                f[y]=x;\n                add(x,y);\n            }\n        }\n    }\n    dfs(id[n]);\n    printf(\"%lld\\n\",dp[id[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=1e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n}\nint n,m,a[N],b[N],A[N];\nll dp[N];\nint fa[N];\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nvector<int>E[N];\n#define pb push_back\nvoid input()\n{\n\tn=read<int>(),m=read<int>();\n\tFor(i,1,n)a[i]=read<int>(),b[i]=read<int>();\n\tint x,y;\n\tFor(i,1,m)\n\t{\n\t\tx=read<int>(),y=read<int>();\n\t\tE[x].pb(y),E[y].pb(x);\n\t}\n}\nbool cmp(int x,int y)\n{\n\treturn  A[x]<A[y];\n}\nint id[N],vis[N];\nll sum[N];\nvoid work()\n{\n\tFor(i,1,n)dp[i]=A[i]=max(a[i]-b[i],0),sum[i]=b[i];\n\tFor(i,1,n)id[i]=fa[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tint u,x,y;\n\tFor(i,1,n)\n\t{\n\t\tu=id[i];\n\t\tx=find(u);\n\t\tfor(int v:E[u])if(vis[v])\n\t\t{\n\t\t\ty=find(v);\n\t\t\tif(x==y)continue;\n\t\t\tfa[y]=x,sum[x]+=sum[y];\n\t\t\tcmin(dp[x],max(dp[y],A[x]-sum[y]));\n\t\t}\n\t\tvis[u]=1;\n\t}\n\twrite(dp[id[n]]+sum[id[n]],'\\n');\n}\nint main()\n{\n//\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\nconst int maxN = 100011;\n\nint n, m, i, x, y, R;\nint a[maxN], b[maxN];\nint gr[maxN];\nvector<int> list[maxN], adj[maxN];\nbool used[maxN];\nll ans, act;\nll add[maxN], sum[maxN];\n\nvector< pair<int, int> > ord;\nint dad[maxN];\n\nint Find(int x) {\n    if (dad[x] == x) return x;\n    dad[x] = Find(dad[x]);\n    return dad[x];\n}\n\nbool Merge(int x, int y) {\n    x = Find(x);\n    y = Find(y);\n    if (x == y) return false;\n    dad[x] = y;\n    adj[y].pb(x);\n\n\n    return true;\n}\n\nvoid make_tree() {\n    int i;\n    \n    for (i = 1; i <= n; i++) dad[i] = i;\n    sort(ord.begin(), ord.end());\n\n    for (auto node : ord) {\n        used[node.second] = true;\n        for (auto to : list[node.second]) {\n            if (!used[to]) continue;\n            Merge(to, node.second);\n        }\n    }\n\n    R = ord.back().second;\n}\n\nvoid dfs(int node) {\n    int i;\n    \n    for (auto to : adj[node])\n        dfs(to);\n\n    for (auto to : adj[node]) {\n        sum[node] += sum[to];\n        add[node] = min(add[node], add[to] + max(0LL, a[node] - b[node] - add[to] -\n                    sum[to]));\n    }\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d%d\", &n, &m);\n    for (i = 1; i <= n; i++) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n        a[i] = max(a[i], b[i]);\n        ord.pb(mp(a[i] - b[i], i));\n   }\n\n    for (i = 1; i <= m; i++) {\n        scanf(\"%d%d\", &x, &y);\n        list[x].pb(y);\n        list[y].pb(x);\n    }\n\n    make_tree();\n\n    for (i = 1; i <= n; i++) {\n        add[i] = a[i] - b[i];\n        sum[i] = b[i];\n    }\n    dfs(R);\n\n    printf(\"%lld\", sum[R] + add[R]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct node{\n    int x,v;\n    node(int a=0,int b=0){x=a;v=b;}\n}p[100010];\nint h[100010],nex[200010],to[200010],a[100010],b[100010],fa[100010],M;\nll s[100010],f[100010];\nbool v[100010];\nvoid add(int a,int b){\n    M++;\n    to[M]=b;\n    nex[M]=h[a];\n    h[a]=M;\n}\nbool operator<(node a,node b){return a.v<b.v;}\nint get(int x){return x==fa[x]?x:(fa[x]=get(fa[x]));}\nint main(){\n    int n,m,i,j,x,y;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=n;i++){\n        scanf(\"%d%d\",a+i,b+i);\n        a[i]=max(a[i]-b[i],0);\n        p[i]=node(i,a[i]);\n    }\n    while(m--){\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);\n        add(y,x);\n    }\n    sort(p+1,p+n+1);\n    for(i=1;i<=n;i++){\n        fa[i]=i;\n        s[i]=b[i];\n        f[i]=a[i];\n    }\n    for(i=1;i<=n;i++){\n        v[p[i].x]=1;\n        for(j=h[p[i].x];j;j=nex[j]){\n            if(v[to[j]]){\n                x=get(p[i].x);\n                y=get(to[j]);\n                if(x==y)continue;\n                fa[y]=x;\n                s[x]+=s[y];\n                f[x]=min(f[x],max(f[y],a[x]-s[y]));\n            }\n        }\n    }\n    x=get(1);\n    printf(\"%lld\",f[x]+s[x]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n//    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, ll, ll>> pq;// -cost, from, to\n  auto poss = [&](ll rem) {\n    DisjointSet<> dsu(n);\n    fill(ALL(vis), false);\n    VEVE(i, 0, n) {\n      dsu.sum[i] = recv[i];\n      if (need[i] <= rem) {\n        vis[i] = true;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    while (not pq.empty()) {\n      ll cost, fr, to;\n      tie(cost, fr, to) = pq.top();\n      pq.pop();\n      cost = -cost;\n      if (dsu.IsSameSet(fr, to))\n        continue;\n      if (dsu.sum[dsu.Find(fr)] + rem >= cost) {\n        dsu.Unite(fr, to);\n        if (not vis[to]) {\n          vis[to] = true;\n          dsu.sum[dsu.Find(to)] += recv[to];\n          RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n        }\n      }\n    }\n    VEVE(i, 0, n) if (not vis[i]) return false;\n    return true;\n  };\n  poss(0);\n  ll low = 0, hig = 1e9;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\ntypedef vector<int> vi;\n#define pb push_back\ntypedef long long ll;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,a[N],b[N],fa[N],id[N];\nll s[N],f[N];\nvi E[N];\nbool vis[N];\n\nint getf(int x) {\n\treturn x==fa[x]?x:fa[x]=getf(fa[x]);\n}\n\nbool cmp(int x,int y) {\n\treturn a[x]<a[y];\n}\n\nint main() {\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) {\n\t\ta[i]=gi(),b[i]=gi();\n\t\ta[i]=max(a[i]-b[i],0);\n\t\tid[i]=fa[i]=i;s[i]=b[i];f[i]=a[i];\n\t}\n\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),E[u].pb(v),E[v].pb(u);\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++) {\n\t\tint u=id[i];vis[u]=1;\n\t\tfor(auto v:E[u])\n\t\t\tif(vis[v]) {\n\t\t\t\tint x=getf(u),y=getf(v);\n\t\t\t\tif(x!=y) {\n\t\t\t\t\ts[x]+=s[y];fa[y]=x;f[x]=min(f[x],max(f[y],a[x]-s[y]));\n\t\t\t\t}\n\t\t\t}\n\t}\n\tint x=getf(1);cout<<f[x]+s[x];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=200005;\nint n,m;\nLL A[Maxn],B[Maxn];\nLL dp[Maxn][2],S[Maxn];\nvector<int> G[Maxn],nG[Maxn];\nint par[Maxn],ord[Maxn];\nbool O[Maxn];\nint findset(int x){\n\treturn par[x]=(par[x]==x)?x:findset(par[x]);\n}\nbool cmp(int x,int y){\n\treturn A[x]<A[y];\n}\nvoid dfs(int x){\n\tS[x]=B[x];\n\tfor (int i=0;i<nG[x].size();i++){\n\t\tdfs(nG[x][i]);\n\t\tS[x]+=S[nG[x][i]];\n\t}\n}\nvoid dfs2(int x){\n\tdp[x][0]=S[x]-B[x]+max(A[x],B[x]);\n\tfor (int i=0;i<nG[x].size();i++){\n\t\tdfs2(nG[x][i]);\n\t}\n\tdp[x][1]=dp[x][0];\n\tLL totS=S[x]-B[x];\n\tfor (int i=0;i<nG[x].size();i++){\n\t\tint v=nG[x][i];\n\t\tdp[x][1]=min(dp[x][1],max(totS-S[v]+max(A[x],B[x]),totS-S[v]+B[x]+dp[v][1]));\n\t}\n}\nint main(){\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++){\n\t\tA[i]=read();B[i]=read();\n\t}\n\tfor (int i=0;i<m;i++){\n\t\tint u,v;u=read();v=read();\n\t\tG[u].pb(v);G[v].pb(u);\n\t}\n\tfor (int i=1;i<=n;i++) ord[i]=i;\n\tfor (int i=1;i<=n;i++) par[i]=i;\n\tsort(ord+1,ord+1+n,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tint v=ord[i];\n\t\tvector<int> tmp;\n\t\tfor (int j=0;j<G[v].size();j++){\n\t\t\tif (O[G[v][j]])tmp.pb(findset(G[v][j]));\n\t\t}\n\t\tsort(tmp.begin(),tmp.end());\n\t\ttmp.resize(unique(tmp.begin(),tmp.end())-tmp.begin());\n\t\tfor (int j=0;j<tmp.size();j++){\n\t\t\tnG[v].pb(tmp[j]);\n\t\t\t//cout<<\"Add\"<<' '<<v<<' '<<tmp[j]<<endl;\n\t\t\tpar[tmp[j]]=v;\n\t\t}\n\t\tO[v]=1;\n\t}\n\tint rt=ord[n];\n\tdfs(rt);\n\tdfs2(rt);\n\tprintf(\"%lld\\n\",dp[rt][1]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define REP(i,m,n) for(int i=(int)(m); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define RREP(i,m,n) for(int i=(int)(m); i>=(int)(n); i--)\n#define rrep(i,n) RREP(i,n-1,0)\n#define all(v) v.begin(), v.end()\nconst int inf = 1e9+7;\nconst ll longinf = 1LL<<60;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-10;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n, k, q; cin >> n >> k >> q;\n  vector<ll> A(n); rep(i, n) cin >> A[i];\n  ll mn = longinf;\n  rep(i, n) {\n    ll tmp = A[i];\n    priority_queue<ll, vector<ll>, greater<ll>> que;\n    vector<ll> v;\n    rep(j, n) {\n      if(A[j] < tmp) {\n        while((int)que.size() >= k) {\n          v.push_back(que.top()); que.pop();\n        }\n        while(!que.empty()) que.pop();\n      } else {\n        que.push(A[j]);\n      }\n    }\n    while((int)que.size() >= k) {\n      v.push_back(que.top()); que.pop();\n    }\n    sort(all(v));\n    if((int)v.size() < q) continue;\n    mn = min(v[q-1]-v[0], mn);\n  }\n  cout << mn << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define ll long long\nusing namespace std;\nconst int N=1e5+5;\nint n,m,x,y,a[N],b[N],w[N],f[N];\nvector<int>e[N];\nll s[N],g[N];\nbool ex[N];\nbool cmp(int x,int y){return a[x]<a[y];}\nint F(int x){return x==f[x]?x:f[x]=F(f[x]);}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\tfo(i,1,n)cin>>a[i]>>b[i],a[i]=max(a[i]-b[i],0),w[i]=f[i]=i;\n\tfo(i,1,m)cin>>x>>y,e[x].push_back(y),e[y].push_back(x);\n\tsort(w+1,w+n+1,cmp);\n\tfo(i,1,n){\n\t\tint x=w[i],leaf=1;ex[x]=1;\n\t\ts[x]=b[x];\n\t\tg[x]=1e18;\n\t\tfor(int j:e[x])if(ex[j]&&F(j)!=x){\n\t\t\tint y=f[j];\n\t\t\tf[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tg[x]=min(g[x],max(g[y],-s[y]+a[x]));\n\t\t\tleaf=0;\n\t\t}\n\t\tif(leaf)g[x]=a[x];\n\t}\n\tcout<<g[w[n]]+s[w[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m;\nint a[maxn],b[maxn],id[maxn];\nstruct edge{int v,nxt;}e[maxn<<1];\nint head[maxn],ecnt=0,vis[maxn];\nvoid add(int u,int v)\n{\n\te[++ecnt]=(edge){v,head[u]},head[u]=ecnt;\n\te[++ecnt]=(edge){u,head[v]},head[v]=ecnt;\n}\nbool cmp(const int &x,const int &y){return a[x]<a[y];}\nvector<int>G[maxn];\nint fa[maxn];\nlong long sum[maxn],dp[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dfs(int u,int pre)\n{\n\t\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t\tsum[u]+=sum[v];\n\t}\n\tsum[u]+=b[u];\n\tdp[u]=sum[u]+a[u];\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max(dp[v],a[u]*1LL));\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),a[i]=max(0,a[i]-b[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=id[i];\n\t\tvis[u]=1;\n\t\tfor(auto v:G[u])\n\t\tif(vis[v]&&find(u)!=find(v))\n\t\t{\n\t\t\tadd(u,find(v));\n\t\t\tfa[find(v)]=u;\n\t\t}\n\t}\n\tdfs(id[n],0);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nvector<int> g[100010];\nint a[100010],b[100010];\n\nint num[100010],low[100010];\nint cnt;\nvector<P> avs;\nint root=0;\n\nll sumb[100010];\n\nvoid dfs(int v,int prev){\n  num[v]=low[v]=++cnt;\n  int dcnt=0;\n  bool is_art=false;\n  for(int i=0;i<g[v].size();i++){\n    int nv=g[v][i];\n    if(num[nv]==-1){\n      dcnt++;\n      dfs(nv,v);\n      sumb[v]+=sumb[nv]+b[nv];\n      low[v]=min(low[v],low[nv]);\n      if(v!=root&&num[v]<=low[nv])is_art=true;\n    }else if(nv!=prev){\n      low[v]=min(low[v],num[nv]);\n    }\n  }\n  if((v==root&&dcnt>1)||is_art)avs.push_back(P(v,prev));\n}\nvoid art_points(){\n  memset(num,-1,sizeof(num));\n  cnt=0;\n  dfs(root,-1);\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)cin>>a[i]>>b[i];\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);g[b].push_back(a);\n  }\n  art_points();\n  ll res=0,tot=0;\n  rep(i,n){\n    res+=b[i];\n    tot+=b[i];\n  }\n  rep(i,n)maxch(res,a[i]);\n  rep(i,avs.size()){\n    ll mn=INF;\n    ll s=0;\n    int v=avs[i].fi;\n    int par=avs[i].se;\n    for(int nv : g[v]){\n      if(nv==par)continue;\n      minch(mn,a[v]+sumb[nv]);\n      s+=sumb[nv];\n    }\n    minch(mn,a[v]+tot-s-b[v]);\n    maxch(res,mn);\n  }\n  cout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i)\n    cin >> a[i] >> b[i];\n  vector<pair<int, pair<int, int>>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    cin >> u >> v;\n    --u; --v;\n    edges[i] = make_pair(min(a[u], a[v]), make_pair(u, v));\n  }\n  sort(edges.begin(), edges.end());\n  vector<int> f(n);\n  iota(f.begin(), f.end(), 0);\n  function<int(int)> find = [&](int x) { return f[x] == x ? x : f[x] = find(f[x]); };\n  function<void(int, int)> unite = [&](int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y)\n      f[x] = y;\n  };\n  vector<vector<int>> g(n);\n  for (const auto& pr : edges) {\n    int u, v;\n    tie(u, v) = pr.second;\n    //cerr << u << ' ' << v << \": \" << pr.first << '\\n';\n    if (find(u) != find(v)) {\n      unite(u, v);\n      g[u].push_back(v);\n      g[v].push_back(u);\n      //cerr << \"added\\n\";\n    }\n  }\n  ll ans = 1LL << 60;\n  for (int i = 0; i < n; ++i) {\n    vector<bool> vis(n);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    ll s = 0, h = 0;\n    q.emplace(a[i] - b[i], i);\n    while (!q.empty()) {\n      int u = q.top().second; q.pop();\n      //cerr << u << ' ';\n      h = max(h, a[u] - (s += b[u]));\n      vis[u] = true;\n      for (int v : g[u])\n        if (!vis[v])\n          q.emplace(a[v] - b[v], v);\n    }\n    //cerr << \": \" << (h + s) << '\\n';\n    ans = min(ans, h);\n  }\n  ans += accumulate(b.begin(), b.end(), 0LL);\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\ntypedef long long ll;\nint n, m;\nconst int maxn = 1e5 + 10;\nint a[maxn], b[maxn], c[maxn], fa[maxn];\nll sumb[maxn], dp[maxn];\nvector<int> ver, G[maxn], E[maxn];\nbool cmp(const int & i, const int & j) { return c[i] < c[j] || (c[i] == c[j] && i < j);}\nint getfa(int x) { return fa[x] == x ? x : fa[x] = getfa(fa[x]);}\nvoid dfs(int x)\n{\n\tsumb[x] = b[x];\n\tfor(auto v : E[x])\n\t{\n\t\tdfs(v);\n\t\tsumb[x] += sumb[v];\n\t}\n\tdp[x] = sumb[x] + c[x];\n\tfor(auto v : E[x])\n\t\tdp[x] = min(dp[x], sumb[x] - sumb[v] + max((ll)c[x], dp[v]));\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t\tc[i] = max(a[i] - b[i], 0);\n\t\tver.push_back(i); \n\t\tfa[i] = i;\n\t}\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tsort(ver.begin(), ver.end(), cmp);\n\tfor(auto u : ver)\n\t\tfor(auto v : G[u])\n\t\t{\n\t\t\tint fv = getfa(v);\n\t\t\tif(c[fv] > c[u] || (c[fv] == c[u] && fv >= u))\n\t\t\t\tcontinue;\n\t\t\tfa[fv] = u;\n\t\t\tE[u].push_back(fv);\n\t\t}\n\tint rt = ver.back();\n\tdfs(rt);\n\tprintf(\"%lld\\n\", dp[rt]);\n\treturn 0;\n}\n\t\n\t "
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=998244353;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nconst int MAXN = 1e5 + 5; \nint N,M,a[MAXN],b[MAXN],p[MAXN]; \nint pa[MAX_N]; \nint getf(int x) { while (x != pa[x]) x = pa[x] = pa[pa[x]]; return x; } \nvector<int> G[MAX_N]; \nlong long f[MAX_N], sum[MAX_N];\nbool vis[MAX_N]; \nint main () { \n\tN = gi(), M = gi();\n\tfor (int i = 1; i <= N; i++) { \n\t\ta[i] = gi(), b[i] = gi(); \n\t\ta[i] = max(a[i] - b[i], 0);\n\t\tp[i] = i, pa[i] = i; \n\t} \n\tsort(&p[1], &p[N + 1], [](const int &l, const int &r) { return a[l] < a[r]; } ); \n\tfor (int i = 1; i <= M; i++) { \n\t\tint u = gi(), v = gi(); \n\t\tG[u].push_back(v), G[v].push_back(u); \n\t} \n\tfor (int i = 1; i <= N; i++) { \n\t\tvector<int> son;\n\t\tint x = p[i]; \n\t\tvis[x] = 1, sum[x] = b[x]; \n\t\tfor (auto v : G[x]) {\n\t\t\tif (!vis[v] || getf(x) == getf(v)) continue; \n\t\t\tson.push_back(getf(v)); \n\t\t\tsum[x] += sum[getf(v)]; \n\t\t\tpa[getf(v)] = x; \n\t\t} \n\t\tf[x] = sum[x] + a[x]; \n\t\tfor (auto v : son) f[x] = min(f[x], sum[x] - sum[v] + max(1ll * a[x], f[v])); \n\t} \n\tprintf(\"%lld\\n\", f[p[N]]); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define ivorysi\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE,id[MAXN],ra[MAXN],f[MAXN];\nint64 A[MAXN],B[MAXN],C[MAXN],dp[MAXN],siz[MAXN];\nvector<int> son[MAXN];\nint getfa(int x) {\n    return f[x] == x ? x : f[x] = getfa(f[x]);\n}\nbool cmp(int s,int t) {\n    return C[s] < C[t];\n}\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    read(N);read(M);\n    for(int i = 1 ; i <= N ; ++i) {\n\tread(A[i]);read(B[i]);C[i] = max(A[i] - B[i],0LL);\n\tid[i] = i;\n    }\n    sort(id + 1,id + N + 1,cmp);\n    for(int i = 1 ; i <= N ; ++i) ra[id[i]] = i;\n    int u,v;\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(u);read(v);\n\tadd(u,v);add(v,u);\n    }\n}\nvoid dfs1(int u) {\n    siz[u] += B[u];\n    for(auto v : son[u]) {\n\tdfs1(v);\n\tsiz[u] += siz[v];\n    }\n}\nvoid dfs2(int u) {\n    if(son[u].size() == 0) {\n\tdp[u] = B[u] + C[u];\n\treturn;\n    }\n    dp[u] = 1e18;\n    for(auto v : son[u]) {\n\tdfs2(v);\n\tdp[u] = min(siz[u] - siz[v] + max(C[u],dp[v]),dp[u]);\n    }\n}\nvoid Solve() {\n    for(int i = 1 ; i <= N ; ++i) f[i] = i;\n    for(int i = 1 ; i <= N ; ++i) {\n\tint u = id[i];\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(ra[getfa(v)] < ra[u] && getfa(v) != u) {\n\t\tson[u].pb(getfa(v));\n\t\tf[getfa(v)] = u;\n\t    }\n\t}\n    }\n    dfs1(id[N]);\n    dfs2(id[N]);\n    out(dp[id[N]]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  vector<ll> sum;\n  UnionFind(int n) : v(n, -1), sum(n,0){}\n  void init(){ for(int i = 0;i < (int)v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x]; }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    sum[x] += sum[y];\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nll N,M;\nll A[100010],B[100010];\nvector<ll> g[100010];\nll X[100010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N>>M;\n  vector<ll> ord;\n  rep(i,N){\n    cin>>A[i]>>B[i];\n    ord.push_back(i);\n  }\n  rep(i,M){\n    ll a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  sort(all(ord),[=](const ll& a,const ll& b){ return A[a]-B[a] < A[b]-B[b]; });\n  UnionFind uf(N);\n  rep(i,N){\n    uf.sum[i]=B[i];\n    X[i]=INF;\n  }\n\n  for(ll v : ord){\n    X[v]=max(0LL,A[v]-B[v]);\n    for(ll nv : g[v]){\n      ll f=uf.find(nv);\n      if(X[f]==INF)continue;\n      ll tot=uf.sum[f]+X[f];\n      minch(X[v],X[f]+max(0LL,A[v]-B[v]-tot));\n    }\n    for(ll nv : g[v]){\n      ll f=uf.find(nv);\n      if(X[f]==INF)continue;\n      uf.unite(v,nv);\n    }\n    ll f=uf.find(v);\n    X[f]=X[v];\n  }\n  cout<<X[uf.find(0)]+uf.sum[uf.find(0)]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1){\n                s[u1].insert({a[v1]-b[v1],v1});\n                s[v1].insert({a[u1]-b[u1],u1});\n            }\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        \n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing LL = long long;\n\nconst int N = 100000;\n\nstruct Info\n{\n    LL sum, need;\n};\n\nint n, m, a[N], b[N], ord[N], par[N];\nInfo info[N];\nstd::vector<int> graph[N];\n\nbool by_a(int i, int j)\n{\n    return std::max(a[i] - b[i], 0) < std::max(a[j] - b[j], 0);\n}\n\nint find(int u)\n{\n    if (par[u] != u) {\n        par[u] = find(par[u]);\n    }\n    return par[u];\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"D.in\", \"r\", stdin);\n#endif\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d%d\", a + i, b + i);\n        ord[i] = i;\n    }\n    for (int i = 0; i < m; ++ i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        u --;\n        v --;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    std::sort(ord, ord + n, by_a);\n    LL need = 0;\n    memset(par, -1, sizeof(par));\n    for (int idx = 0; idx < n; ++ idx) {\n        int r = ord[idx];\n        par[r] = r;\n        std::vector<Info> sons;\n        LL tot_sum = 0;\n        for (int v : graph[r]) {\n            if (~par[v] && find(r) != find(v)) {\n                int u = find(v);\n                sons.push_back(info[u]);\n                tot_sum += info[u].sum;\n                par[u] = r;\n            }\n        }\n        need = tot_sum + std::max(a[r], b[r]);\n        for (auto s : sons) {\n            need = std::min(need, tot_sum - s.sum + std::max((LL)a[r], s.need + b[r]));\n        }\n        info[r].sum = tot_sum + b[r];\n        info[r].need = need;\n    }\n    printf(\"%lld\\n\", need);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    if (n==1) cout << 1/0;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\ntemplate<typename T> using max_heap = priority_queue<T>;\ntemplate<typename T> using min_heap = priority_queue<T, vector<T>, greater<T>>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __numeric {\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type floor(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d - ((n < 0) && (n % d));\n    }\n    template<typename T>\n    typename enable_if<is_integral<T>::value, T>::type ceil(T n, T d) {\n        assert(d != 0);\n        if (d < 0) tie(n, d) = mp(-n, -d);\n        return n / d + ((n > 0) && (n % d));\n    }\n};\nusing namespace __numeric;\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\nstruct monostate {\n    friend istream& operator>>(istream& is, const monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const monostate& ms) { return os; }\n    friend monostate operator+(const monostate& a, const monostate& b) { return a; }\n} ms;\n#pragma GCC diagnostic pop\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// union_find {{{\nstruct union_find {\n    struct node {\n        int par, rnk, size;\n        node(int id = 0) : par(id), rnk(0), size(1) {}\n    };\n\n    vector<node> uf;\n    union_find(int N = 0) : uf(N) {\n        for (int i = 0; i < N; i++)\n            uf[i] = node(i);\n    }\n\n    int rep(int i) {\n        if (i != uf[i].par)\n            uf[i].par = rep(uf[i].par);\n        return uf[i].par;\n    }\n\n    bool unio(int a, int b) {\n        a = rep(a), b = rep(b);\n        if (a == b) return false;\n        if (uf[a].rnk < uf[b].rnk) swap(a, b);\n        uf[b].par = a;\n        uf[a].size += uf[b].size;\n        if (uf[a].rnk == uf[b].rnk) uf[a].rnk++;\n        return true;\n    }\n\n    node& operator[](int i) { return uf[rep(i)]; }\n\n    friend void pr(const union_find& u) {\n        pr(\"{\"); bool f = 1;\n        for (int i = 0; i < sz(u.uf); i++) if (u.uf[i].par == i) {\n            if (!f) pr(\", \"); else f = 0;\n            pr(\"[ \", i, \" | rank=\", u.uf[i].rnk, \" size=\", u.uf[i].size, \" ]\");\n        }\n        pr(\"}\");\n    }\n};\n// }}}\n\nint main() {\n    setIO();\n\n    int N, M; re(N, M);\n\n    vi need(N), give(N);\n    F0R (i, N) {\n        re(need[i], give[i]);\n        need[i] = max(0, need[i] - give[i]);\n    }\n\n    vvi adj(N);\n    F0R (_, M) {\n        int a, b; re(a, b); --a, --b;\n        adj[a].pb(b);\n        adj[b].pb(a);\n    }\n\n    vi start(N);\n\n    vi order(N);\n    F0R (i, N) order[i] = i;\n    sort_by(order, need[a] < need[b]);\n\n    vb done(N);\n    union_find uf(N);\n\n    vll gain(N);\n\n    trav (u, order) {\n        vi ccs;\n        trav (v, adj[u])\n            if (done[v])\n                ccs.pb(uf.rep(v));\n        dedup(ccs);\n\n        int u_need = need[u];\n        gain[u] = give[u];\n        trav (c, ccs) {\n            ckmin(u_need, (int)max((ll)need[c], need[u] - gain[c]));\n            gain[u] += gain[c];\n        }\n\n        done[u] = 1;\n        trav (c, ccs) uf.unio(u, c);\n\n        need[uf.rep(u)] = u_need;\n        gain[uf.rep(u)] = gain[u];\n    }\n\n    //pd(need);\n    //pd(gain);\n\n    int c = uf.rep(order.back());\n    //pd(c, need[c]);\n    ps(need[c] + gain[c]);\n\n    // did you check N=1? did you mix up N,M?\n    // check your \"infinity\" and \"null\" values agivest the bounds\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct unionfind_t {\n  int n;\n  vector<int> parent, rank;\n  unionfind_t(int _n): n(_n), parent(n), rank(n, 0) {\n    iota(parent.begin(), parent.end(), 0);\n  }\n  int find(int v) {\n    if (v == parent[v]) return v;\n    return parent[v] = find(parent[v]);\n  }\n  int join(int a, int b) {\n    a = find(a);\n    b = find(b);\n    if (a == b) return a;\n    if (rank[a] > rank[b]) swap(a, b);\n    parent[a] = b;\n    if (rank[a] == rank[b]) ++rank[b];\n    return b;\n  }\n};\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n\n  struct node_t {\n    lint min_stand, cost;\n  };\n  lint cost_sum = 0LL;\n  vector<node_t> nodes(n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld %lld\", &nodes[i].min_stand, &nodes[i].cost);\n    cost_sum += nodes[i].cost;\n  }\n\n  vector<vector<int>> adj(n);\n  for (int i = 0; i < m; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b), --a, --b;\n    adj[a].push_back(b);\n    adj[b].push_back(a);\n  }\n\n  struct dp_t {\n    lint total;\n    lint worst_state;\n  };\n\n  vector<dp_t> dp(n);\n  unionfind_t uf(n);\n\n  vector<int> sorted_by_min_stand(n);\n  iota(sorted_by_min_stand.begin(), sorted_by_min_stand.end(), 0);\n  sort(sorted_by_min_stand.begin(), sorted_by_min_stand.end(),\n       [&nodes](int a, int b) {\n         return nodes[a].min_stand - nodes[a].cost <\n           nodes[b].min_stand - nodes[b].cost;\n       });\n  vector<bool> mark(n, false);\n  for (int v : sorted_by_min_stand) {\n    static vector<int> cnts; cnts.clear();\n    mark[v] = true;\n    for (int u : adj[v])\n      if (mark[u]) {\n        cnts.push_back(uf.find(u));\n      }\n    sort(cnts.begin(), cnts.end());\n    cnts.resize(unique(cnts.begin(), cnts.end()) - cnts.begin());\n\n    lint cnts_total = 0LL;\n    for (int cnt : cnts)\n      cnts_total += dp[cnt].total;\n\n    dp_t result;\n    result.total = cnts_total + nodes[v].cost;\n    result.worst_state = -cnts_total - nodes[v].min_stand;\n\n    for (int cnt : cnts) {\n      lint others_total = cnts_total - dp[cnt].total;\n\n      result.worst_state =\n        max(result.worst_state,\n            min({-others_total - nodes[v].cost + dp[cnt].worst_state,\n                 -others_total - nodes[v].min_stand}));\n    }\n\n    int joined_cnt = v;\n    for (int cnt : cnts) joined_cnt = uf.join(joined_cnt, cnt);\n    dp[joined_cnt] = result;\n  }\n  printf(\"%lld\\n\", max(cost_sum, -dp[uf.find(0)].worst_state));\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, m, cnt, top, s, maxi, now, sta[Maxn], a[Maxn], b[Maxn], w[Maxn], head[Maxn];\nlong long sum[Maxn], mini[Maxn];\nvector <int> Ve[Maxn];\nqueue <int> Qu;\nbool vis[Maxn], vis2[Maxn];\nstruct edg\n{\n\tint nxt, to;\n}edge[2 * Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs(int u)\n{\n\tvis2[u] = true;\n\tsta[++top] = u;\n\tif (w[u] > maxi) maxi = w[u], now = u;\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tif (!vis[to] && !vis2[to])\n\t\t\tdfs(to);\n\t}\n}\nvoid dfs2(int u)\n{\n\tmini[u] = 0x3f3f3f3f3f3f3f3f;\n\tsum[u] = b[u];\n\tfor (vector <int> :: iterator it = Ve[u].begin(); it != Ve[u].end(); it++)\n\t{\n\t\tint to = *it;\n\t\tdfs2(to);\n\t\tsum[u] += sum[to];\n\t\tmini[u] = min(mini[u], max((long long) w[u], mini[to]) - sum[to]);\n\t}\n\tif (!Ve[u].size()) mini[u] = w[u] + b[u];\n\telse mini[u] += sum[u];\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0, a[i] - b[i]);\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (w[i] > maxi) maxi = w[i], s = i;\n\tQu.push(s);\n\twhile (!Qu.empty())\n\t{\n\t\tint u = Qu.front();\n\t\tvis[u] = true;\n\t\tQu.pop();\n\t\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tnow = -1, maxi = -1;\n\t\t\tint to = edge[i].to;\n\t\t\tif (vis[to] || vis2[to]) continue;\n\t\t\tdfs(to);\n\t\t\tif (now != -1)\n\t\t\t{\n\t\t\t\tVe[u].push_back(now);\n\t\t\t\tQu.push(now);\n\t\t\t}\n\t\t}\n\t\twhile (top) vis2[sta[top--]] = false;\n\t}\n\tdfs2(s);\n\tprintf(\"%lld\", mini[s]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int N=100010;\nconst LL LINF=1ll<<60;\nint n,m;\nint cost[N];\nint h[N],tot;\nstruct Edge{\n\tint v,next;\n}e[N*2];\nstruct Node{\n\tint u,t;\n}p[N];\ninline LL min(LL x,LL y){\n\treturn x<y?x:y;\n}\ninline LL max(LL x,LL y){\n\treturn x>y?x:y;\n}\nvoid addEdge(int u,int v){\n\te[++tot]=(Edge){v,h[u]}; h[u]=tot;\n\te[++tot]=(Edge){u,h[v]}; h[v]=tot;\n}\nvoid readData(){\n\tscanf(\"%d%d\",&n,&m);\n\tint a,b;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tcost[i]=b;\n\t\tp[i]=(Node){i,max(a-b,0)};\n\t}\n\tint u,v;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\taddEdge(u,v);\n\t}\n}\nint bel[N];\nbool active[N];\nLL f[N],sum[N];\nbool cmpThreshold(const Node &x,const Node &y){\n\treturn x.t<y.t;\n}\nint find(int x){\n\treturn bel[x]==x?x:(bel[x]=find(bel[x]));\n}\nvoid solve(){\n\tsort(p+1,p+1+n,cmpThreshold);\n\tfor(int i=1;i<=n;i++) bel[i]=i;\n\tfor(int ii=1;ii<=n;ii++){\n\t\tint u=p[ii].u;\n\t\tactive[u]=true;\n\t\tsum[u]=cost[u];\n\t\tf[u]=LINF;\n\t\tbool haveSon=false;\n\t\tfor(int i=h[u],v;i;i=e[i].next){\n\t\t\tv=find(e[i].v);\n\t\t\tif(v!=u&&active[v]){\n\t\t\t\tactive[v]=false;\n\t\t\t\thaveSon=true;\n\t\t\t\tbel[v]=u;\n\t\t\t\tsum[u]+=sum[v];\n\t\t\t\tf[u]=min(f[u],max(f[v],p[ii].t-sum[v]));\n\t\t\t}\n\t\t}\n\t\tif(!haveSon)\n\t\t\tf[u]=0;\n\t}\n\tint last=p[n].u;\n\tprintf(\"%lld\\n\",sum[last]+f[last]);\n}\nint main(){\n\treadData();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<climits>\n#include<bitset>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ninline int read(){\n    int f=1,ans=0;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n    return f*ans;\n}\nconst int MAXN=1e5+11;\nvector<int> vec[MAXN],vec1[MAXN];\nint N,M,f[MAXN],vis[MAXN],A[MAXN],B[MAXN],C[MAXN],S[MAXN],p[MAXN];\nstruct Union{\n    int f[MAXN];void init(){for(int i=1;i<=N;i++) f[i]=i;return;}\n    int find(int x){return f[x]==x?x:f[x]=find(f[x]);}\n}SS;\nbool cmp(int x,int y){return C[x]<C[y];}\nvoid dfs(int u){\n    S[u]=B[u];for(auto v:vec[u]){dfs(v),S[u]+=S[v];}\n    f[u]=S[u]+C[u];for(auto v:vec[u]) f[u]=min(f[u],S[u]-S[v]+max(f[v],C[u]));\n    return;\n}\nsigned main(){\n    N=read(),M=read();for(int i=1;i<=N;i++) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0ll),p[i]=i;\n    for(int i=1;i<=M;i++){int u=read(),v=read();vec1[u].pb(v),vec1[v].pb(u);}SS.init();\n    sort(p+1,p+N+1,cmp);\n    for(int i=1;i<=N;i++){\n        int u=p[i];\n        for(auto v:vec1[u]) if(vis[v]&&SS.find(v)!=u) {vec[u].pb(SS.find(v)),SS.f[SS.find(v)]=u;}vis[u]=1;\n    }dfs(p[N]);printf(\"%lld\\n\",f[p[N]]);return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// do the game in reverse order\n// you start with a certain amount (minimize this amount)\n// pick any vertex\n// do these operations as many times as possible\n// 1. get the donation money, and check if there is enough money for this node\n// 2. check if there is enough money for this node, then move to an adjacent node\n// note: you can only get the donation money for one node at most once\n\n// binary search + disjoint set is possible?\n// order the edges by the amount needed to traverse this edge\n\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <string.h>\n\nint t1,t2;\n\nint n,m;\n\nstd::vector<int> g[100005];\n\nint a[100005];\nint b[100005];\n\n// disjoint set stuff\nstd::vector<int> todo;\nbool todo2[100005];     // determine if a vertex is in todo\n\nstd::priority_queue<std::pair<int,int> > pq[100005];\nint endval;\nint up[100005];\nint sz[100005];\nlong long money[100005];\nbool active[100005];\n\nint getroot(int u)\n{\n    if (u==up[u]) return u;\n    return up[u]=getroot(up[u]);\n}\n\nvoid join2(int u,int v)\n{\n    up[v]=u;\n    sz[u]+=sz[v];\n    money[u]+=money[v]-endval;\n    active[u]=1;\n    while (!pq[v].empty()) {\n        pq[u].push(pq[v].top());\n        pq[v].pop();\n    }\n}\n\nint join(int u,int v)\n{\n    // return the root of their union\n    u=getroot(u);\n    v=getroot(v);\n    if (u==v) return u;\n    if (sz[u]>=sz[v]) {\n        join2(u,v);\n        return u;\n    }\n    else {\n        join2(v,u);\n        return v;\n    }\n}\n\nbool good(int x)\n{\n    endval=x;\n    memset(active,0,sizeof active);\n    // make the pq\n    for (int i=1; i<=n; i++) {\n        up[i]=i;\n        sz[i]=1;\n        money[i]=x+b[i];\n        if (money[i]>=a[i]) active[i]=1;\n        while (!pq[i].empty()) pq[i].pop();\n        for (int j:g[i]) pq[i].push({b[j]-a[j],j});\n    }\n    // do vertices\n    for (int i=1; i<=n; i++) {\n        int u=getroot(i);\n        if (!active[u]) continue;\n        //printf(\"start at %d\\n\",i);\n        // do this vertex\n        while (!pq[u].empty() && -pq[u].top().first<=money[u]) {\n            int v=pq[u].top().second;\n            pq[u].pop();\n            //printf(\"do %d -> %d\\n\",u,v);\n            u=join(u,v);\n        }\n    }\n    // check\n    for (int i=2; i<=n; i++) {\n        if (getroot(1)!=getroot(i)) return 0;\n    }\n    return 1;\n}\n\nint lo=0;\nint hi=0x3f3f3f3f;\nint mid;\n\nlong long ans;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1; i<=n; i++) scanf(\"%d%d\",a+i,b+i);\n    for (int i=0; i<m; i++) {\n        scanf(\"%d%d\",&t1,&t2);\n        g[t1].push_back(t2);\n        g[t2].push_back(t1);\n    }\n    //good(0); return 0;\n    while (lo<hi) {\n        mid=(lo+hi)/2;\n        if (good(mid)) hi=mid;\n        else lo=mid+1;\n        //printf(\"%d %d\\n\",lo,hi);\n    }\n    ans=lo;\n    for (int i=1; i<=n; i++) ans+=b[i];\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef long long ll;\ntypedef pair<int, int> i_i;\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint main() {\n\tint N, M; cin >> N >> M;\n    vector<int> a(N), b(N);\n    rep(u, N) scanf(\"%d%d\", &a[u], &b[u]);\n    vector<vector<int>> G(N);\n    while (M--) {\n        int u, v; scanf(\"%d%d\", &u, &v), u--, v--;\n        G[u].pb(v), G[v].pb(u);\n    }\n    vector<i_i> au(N);\n    rep(u, N) au[u] = i_i(a[u], u);\n    sort(au.begin(), au.end());\n    ll tot = 0;\n    rep(u, N) tot += b[u];\n    vector<ll> B(N), W(N);\n    vector<bool> act(N);\n    union_find uf(N);\n    for (i_i unko: au) {\n        int u = unko.second;\n        act[u] = true;\n        ll sum = b[u], mi = max(tot, tot - b[u] + a[u]);\n        for (int v: G[u]) if (act[v] && !uf.same(u, v)) {\n            int V = uf.find(v);\n            sum += B[V];\n            mi = min(mi, max(W[V], max(tot - B[V] + a[v], tot - B[V] - b[u] + a[u])));\n            uf.unite(u, v);\n        }\n        int U = uf.find(u);\n        B[U] = sum, W[U] = mi;\n    }\n    cout << W[uf.find(0)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm>\n#include <vector> \nusing namespace std; \ninline int gi() {\n    register int data = 0, w = 1;\n    register char ch = 0;\n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 1e5 + 5; \nint N, M, a[MAX_N], b[MAX_N], p[MAX_N]; \nint pa[MAX_N]; \nint getf(int x) { while (x != pa[x]) x = pa[x] = pa[pa[x]]; return x; } \nvector<int> G[MAX_N]; \nlong long f[MAX_N], sum[MAX_N];\nbool vis[MAX_N]; \nint main () { \n\tN = gi(), M = gi();\n\tfor (int i = 1; i <= N; i++) { \n\t\ta[i] = gi(), b[i] = gi(); \n\t\ta[i] = max(a[i] - b[i], 0);\n\t\tp[i] = i, pa[i] = i; \n\t} \n\tsort(&p[1], &p[N + 1], [](const int &l, const int &r) { return a[l] < a[r]; } ); \n\tfor (int i = 1; i <= M; i++) { \n\t\tint u = gi(), v = gi(); \n\t\tG[u].push_back(v), G[v].push_back(u); \n\t} \n\tfor (int i = 1; i <= N; i++) { \n\t\tvector<int> son;\n\t\tint x = p[i]; \n\t\tvis[x] = 1, sum[x] = b[x]; \n\t\tfor (auto v : G[x]) {\n\t\t\tif (!vis[v] || getf(x) == getf(v)) continue; \n\t\t\tson.push_back(getf(v)); \n\t\t\tsum[x] += sum[getf(v)]; \n\t\t\tpa[getf(v)] = x; \n\t\t} \n\t\tf[x] = sum[x] + a[x]; \n\t\tfor (auto v : son) f[x] = min(f[x], sum[x] - sum[v] + max(1ll * a[x], f[v])); \n\t} \n\tprintf(\"%lld\\n\", f[p[N]]); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int node = Aux[point].second;\n                    for(int j = 0; j < G[node].size(); j++)\n                    {\n                        int neighb = G[node][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(neighb), Father(node));\n                            Use[neighb] = 1;\n                            Q.push(neighb);\n                            total += B[neighb];\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 10000000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef unsigned long long ul;\nll a[1 << 17], b[1 << 17];\nll sum[1 << 17], ans[1 << 17];\nstruct uf {\n\tvector<int> par, ran;\n\tuf(int n) {\n\t\tpar.resize(n);\n\t\tran.resize(n);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nvector<int> G[1 << 17];\nvector<pair<LP,int>> v;\n\nint trans[1 << 17];\nint main() {\n\tint n, m; cin >> n >> m;\n\tuf u(n);\n\tv.resize(n);\n\trep(i, n) {\n\t\tcin >> v[i].first.first >> v[i].first.second;\n\t\tv[i].second = i;\n\t}\n\tsort(v.begin(), v.end());\n\trep(i, n) {\n\t\ta[i] = v[i].first.first, b[i] = v[i].first.second;\n\t\tsum[i] = b[i];\n\t\ttrans[v[i].second] = i;\n\t}\n\trep(i, m) {\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tu = trans[u], v = trans[v];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\trep(i, n) {\n\t\tvector<LP> s;\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (to > i)continue;\n\t\t\tif(u.same(i,to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto = u.find(to);\n\t\t\t\ts.push_back({ sum[to], ans[to] });\n\t\t\t\tu.unite(i, to);\n\t\t\t}\n\t\t}\n\t\tint len = s.size();\n\t\tint par = u.find(i);\n\t\tll csum = 0;\n\t\trep(j, len) {\n\t\t\tcsum += s[j].first;\n\t\t}\n\t\tll mi = max(a[i] + csum, b[i] + csum);\n\t\trep(j, len) {\n\t\t\tll z = max(a[i] + csum - s[j].first, b[i] + csum - s[j].first + s[j].second);\n\t\t\tmi = min(mi, z);\n\t\t}\n\t\tans[par] = mi;\n\t}\n\tint pp = u.find(n - 1);\n\tcout << ans[pp] << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.05.2018 15:10:27       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n  public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i] >> b[i];\n  }\n  vector<vector<int>> graph(n);\n  for (int i = 0; i < m; i++) {\n    int x, y;\n    cin >> x >> y;\n    x--; y--;\n    graph[x].push_back(y);\n    graph[y].push_back(x);\n  }\n  vector<int> add(n);\n  iota(add.begin(), add.end(), 0);\n  sort(add.begin(), add.end(), [&](int i, int j) {\n    return a[add[i]] - b[add[i]] < a[add[j]] - b[add[j]];\n  });\n  dsu d(n);\n  vector<long long> sum_b(n);\n  vector<long long> ans(n);\n  for (int i = 0; i < n; i++) {\n    sum_b[i] = b[i];\n    ans[i] = max(a[i], b[i]);\n  }\n  vector<int> was(n, 0);\n  for (int i : add) {\n    set<int> s;\n    for (int j : graph[i]) {\n      if (was[j]) {\n        s.insert(d.get(j));\n      }\n    }\n    for (int j : s) {\n      sum_b[i] += sum_b[j];\n      d.unite(j, i);\n    }\n    if (!s.empty()) {\n      long long best = (long long) 1e18;\n      for (int j : s) {\n        long long sum_b_without = sum_b[i] - sum_b[j];\n        long long cur = max(ans[j] + sum_b_without, a[i] + sum_b_without - b[i]);\n        best = min(best, cur);\n      }\n      ans[i] = best;\n    }\n    was[i] = 1;\n  }\n  cout << ans[d.get(0)] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nclass UnionFind{\nprivate:\n  vector<int> node;\n\npublic:\n  UnionFind(int n){\n    node=vector<int>(n);\n    rep(i,n) node[i]=i;\n  }\n  int root(int x){\n    if(node[x]==x) return x;\n    else return node[x]=root(node[x]);\n  }\n  bool uni(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    node[y]=x;\n    return true;\n  }\n};\n\nstruct sta{\n  LL cost;\n  LL w; \n  LL totalb;\n};\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<LL> a(n), b(n);\n  rep(i,n) cin >> a[i] >> b[i];\n  vector<vector<int>> e(n);\n  int u,v;\n  rep(i,m){\n    cin >> u >> v;\n    e[u-1].push_back(v-1);\n    e[v-1].push_back(u-1);\n  }\n  vector<int> p(n);\n  iota(all(p), 0);\n  sort(all(p),[&](const int &l, const int &r){\n    return a[l]-b[l] < a[r]-b[r];\n  });\n  vector<bool> merged(n, false);\n  UnionFind uf(n);\n  vector<sta> tmp(n);\n  rep(i,n){\n    int x = p[i];\n    merged[x] = true;\n    sta mi = {LINF, 0, 0};\n    for(auto ad:e[x]){\n      if(!merged[ad]) continue;\n      ad = uf.root(ad);\n      if(tmp[ad].cost+max(a[x]-b[x]-tmp[ad].w,0LL)<mi.cost){\n        mi=tmp[ad];\n      }\n    }\n    sta now = {0, 0, 0};\n    if(mi.cost==LINF) now.cost = max(a[x]-b[x],0LL);\n    else now.cost = mi.cost+max(a[x]-b[x]-mi.w,0LL);\n    now.totalb = b[x];\n    for(auto ad:e[x]){\n      if(!merged[ad]) continue;\n      LL t = tmp[uf.root(ad)].totalb;\n      if(uf.uni(x,ad)){\n        now.totalb+=t;\n      }\n    }\n    now.w = now.cost + now.totalb;\n    tmp[uf.root(x)] = now;\n    // cout << x SP now.cost SP now.w SP now.totalb << endl;\n  }\n  cout << tmp[uf.root(0)].w << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->S<=val[u]){\n        q.push({u,s[u].begin()->F});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nint rt[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nstruct pt{int a,id;}w[MAXN];\nint n,m,A[MAXN],B[MAXN];\nbool cmp(pt n1,pt n2){return n1.a<n2.a;}\nvector<int> vec[MAXN];\nLL sum[MAXN];\nvoid init(int x)\n{\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)init(a[k].y),sum[x]+=sum[a[k].y];\n}\nLL ans;\nvoid cal(int x,LL ls1,LL ls2)//留下来的速度  上面会用掉的速度 \n{\n\tif(x==10)\n\t{\n\t\tint gg;\n\t\tgg++;\n\t}\n\tLL down=sum[x]-B[x];//不考虑我走完要多少速度 \n\tLL nx=max(ls1,(LL)max(A[x],B[x]));\n\tLL canuse=min(down,nx-max(A[x],B[x]));//可以提供给子树的 \n\tans=min(ans,nx-ls1+down-canuse+ls2);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tcal(y,nx-B[x]-min(canuse,down-sum[y]),down-sum[y]+ls2+nx-ls1-min(canuse,down-sum[y]));\n\t}\n}\nint ri[MAXN];\nbool is[MAXN];\nint main()\n{\n//\tfreopen(\"subtask_1_09.in\",\"r\",stdin);\n\tfreopen(\"rescue.in\",\"r\",stdin);\n\tfreopen(\"rescue.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)w[i].a=A[i]=read(),B[i]=read(),w[i].id=i;\n\tsort(w+1,w+1+n,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(y);vec[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tis[w[i].id]=true; \n\t\tfor(int j=0;j<vec[w[i].id].size();j++)\n\t\t{\n\t\t\tint x=vec[w[i].id][j];\n\t\t\tint p=findrt(w[i].id),q=findrt(x);\n\t\t\tif(p!=q&&is[q])ins(w[i].id,q),ri[q]++,rt[q]=p;\n\t\t}\n\t}\n//\tfor(int i=1;i<=len;i++)printf(\"YES %d %d\\n\",a[i].x,a[i].y);\n//\tfor(int i=1;i<=n;i++)pr1(A[i]),pr2(B[i]);\n\tint root;\n\tfor(int i=1;i<=n;i++)if(!ri[i])root=i;\n\tinit(root);\n\tans=(1LL<<63-1);\n\tcal(root,0,0);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// tourist氏.\n// https://atcoder.jp/contests/arc098/submissions/2567315\n// 正答者の解答を勉強する.\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Disjoint Set Union.\nclass dsu{\npublic:\n    vector<int> p;\n    int n;\n    \n    dsu(int _n) : n(_n){\n        p.resize(n);\n        iota(p.begin(), p.end(), 0);\n    }\n    \n    inline int get(int x){\n        return (x == p[x] ? x : (p[x] = get(p[x])));\n    }\n    \n    inline bool unite(int x, int y){\n        x = get(x);\n        y = get(y);\n        if(x != y){\n            p[x] = y;\n            return true;\n        }\n        return false;\n    }\n};\n\nint main(){\n    \n    // 1. 入力情報取得.\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    vector<int> a(N), b(N);\n    for(int i = 0; i < N; i++) scanf(\"%d %d\", &a[i], &b[i]);\n    \n    // 2. グラフ構築.\n    vector<vector<int>> graph(N);\n    for(int i = 0; i < M; i++){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    \n    vector<int> add(N);\n    iota(add.begin(), add.end(), 0); // 0 ～ N - 1 を 代入.\n    sort(add.begin(), add.end(), [&](int i, int j){ return a[i] - b[i] < a[j] - b[j]; });\n    \n    // 3. Disjoint Set Union.\n    dsu d(N);\n    vector<long long> sum_b(N);\n    vector<long long> ans(N);\n    for(int i = 0; i < N; i++){\n        sum_b[i] = b[i];\n        ans[i] = max(a[i], b[i]);\n    }\n    \n    // 4. ゲームのクリアが可能となる最小の初期の所持金W を 計算.\n    vector<int> was(N, 0);\n    for(int i : add){\n        set<int> s;\n        for(int j : graph[i]) if(was[j]) s.insert(d.get(j));\n        for(int j : s){\n            sum_b[i] += sum_b[j];\n            d.unite(j, i);\n        }\n        if(!s.empty()){\n            long long best = (long long) 1e18;\n            for(int j : s){\n                long long sum_b_without = sum_b[i] - sum_b[j];\n                long long cur = max(ans[j] + sum_b_without, a[i] + sum_b_without - b[i]);\n                best = min(best, cur);\n            }\n            ans[i] = best;\n        }\n        was[i] = 1;\n    }\n    \n    // 5. 出力 ～ 後処理.\n    printf(\"%lld\\n\", ans[d.get(0)]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e5+10;\nint a[maxn],b[maxn],w[maxn],id[maxn],pos[maxn];\nint sum[maxn],fa[maxn],dp[maxn];\nint Begin[maxn],Next[maxn<<1],to[maxn<<1],e;\ninline void add_edge(int x,int y){\n\tto[++e]=y;\n\tNext[e]=Begin[x];\n\tBegin[x]=e;\n}\ninline bool cmp(const int A,const int B){\n\treturn w[A]<w[B];\n}\nint find(int x){\n\tif(fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tint n=read(),m=read();\n\tREP(i,1,n){\n\t\ta[i]=read(),b[i]=read();\n\t\tw[i]=max(a[i]-b[i],0);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tREP(i,1,n) pos[id[i]]=i;\n\twhile(m--){\n\t\tint x=read(),y=read();\n\t\tif(pos[x]<pos[y]) add_edge(y,x);\n\t\telse add_edge(x,y);\n\t}\n\tREP(i,1,n){\n\t\tint u=id[i];\n\t\tdp[u]=w[u],fa[u]=u,sum[u]=b[u];\n\t\tfor(int j=Begin[u];j;j=Next[j]){\n\t\t\tint v=to[j];\n\t\t\tif(u==find(v)) continue;\n\t\t\tv=find(v);\n\t\t\tchkmin(dp[u],max(dp[v],w[u]-sum[v]));\n\t\t\tfa[v]=u;\n\t\t\tsum[u]+=sum[v];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[id[n]]+sum[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nvoid optimize_cpp_stdio() {\n    std::ios::sync_with_stdio(false);\n    std::cout.tie(nullptr);\n    std::cin.tie(nullptr);\n}\n\nint main() {\n    optimize_cpp_stdio();\n    int n, m;\n    std::cin >> n >> m;\n    std::vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i] >> b[i];\n        c[i] = std::max(a[i] - b[i], 0);\n    }\n    std::vector<std::vector<int>> G(n);\n    for (int i = 0, u, v; i < m; i++) {\n        std::cin >> u >> v;\n        G[--u].push_back(--v);\n        G[v].push_back(u);\n    }\n    std::vector<int> parent(n);\n    std::iota(parent.begin(), parent.end(), 0);\n    std::function<int(int)> find = [&](int x) {\n        return x == parent[x] ? x : parent[x] = find(parent[x]);\n    };\n    std::vector<int> sorted(n);\n    std::iota(sorted.begin(), sorted.end(), 0);\n    std::sort(sorted.begin(), sorted.end(), [&](int lhs, int rhs) {\n        return c[lhs] < c[rhs];\n    });\n    std::vector<bool> vis(n);\n    std::vector<int64_t> dp(c.begin(), c.end());\n    std::vector<int64_t> cost(b.begin(), b.end());\n    for (int u : sorted) {\n        vis[u] = true;\n        for (int v : G[u]) {\n            v = find(v);\n            if (not vis[v] || u == v) continue;\n            parent[v] = u;\n            cost[u] += cost[v];\n            dp[u] = std::min(dp[u], std::max(dp[v], c[u] - cost[v]));\n        }\n    }\n    int root = sorted.back();\n    std::cout << dp[root] + cost[root] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define INF 3e15\n#define mod 1000000007\n#define eps 1e-6\n#define abs(x) ((x)>=0?(x):-(x))\n#define y1 solai\n#define fi first\n#define se second\ntypedef long long ll;\nvoid read(ll &x)\n{\n\tscanf(\"%lld\",&x);\n}\nvoid read(ll &x, ll &y)\n{\n\tscanf(\"%lld%lld\",&x,&y);\n}\nvoid read(ll &x, ll &y, ll &z)\n{\n\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n}\nvoid print(ll x)\n{\n\tprintf(\"%lld \",x);\n}\nvoid println(ll x)\n{\n\tprintf(\"%lld\\n\",x);\n}\nconst ll N=100000;\nll n,m,x,y,l,r,mid,ans,sum,a[N+10],b[N+10],li[N+10],w[N+10],p[N+10],ra[N+10],su[N+10];\nvector<ll>v[N+10];\nset<pair<ll,ll> >s[N+10];\n/*ll fin(ll a)\n{\n\tif(a==p[a])\n\t\treturn a;\n\treturn p[a]=fin(p[a]);\n}\nvoid uni(ll a, ll b)\n{\n\ta=fin(a),b=fin(b);\n\tif(a==b)\n\t\treturn;\n\tif(r[a]>r[b])\n\t\tr[a]+=r[b],su[a]+=su[b],p[b]=a;\n\telse\n\t\tr[b]+=r[a],su[b]+=su[a],p[a]=b;\n}\nvoid dfs(ll x)\n{\n\tw[x]=1;\n\tll rt=fin(x);\n\tsu[rt]+=b[x];\n\tfor(ll to:v[x])\n\t\tif(fin(x)!=fin(to))\n\t\t\ts[rt].insert({a[to]-b[to],to});\n\twhile(!s[rt].empty())\n\t{\n\t\tll need=s[rt].begin()->fi,to=s[rt].begin()->se;\n\t\tif(fin(x)==fin(to))\n\t\t\ts[rt].erase(s[rt].begin());\n\t\telse if(fin(x)!=fin(to)&&su[rt]>=need)\n\t\t{\n\t\t\tuni(rt,s[rt].begin()->se);\n\t\t\tdfs(s[rt].begin()->se);\n\t\t\trt=fin(x);\n\t\t\ts[rt].erase(s[rt].begin());\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n}*/\nbool cmp(ll x, ll y)\n{\n\treturn a[x]-b[x]<a[y]-b[y];\n}\nint main()\n{\n\t//freopen(\"c.cpp\",\"r\",stdin);\n \n\tcin>>n>>m;\n\tfor(ll i=1;i<=n;i++)\n\t\tread(a[i],b[i]),sum+=b[i],li[i]=i,p[i]=i,ra[i]=1,su[i]=b[i];\n\tfor(ll i=1;i<=m;i++)\n\t\tread(x,y),v[x].pb(y),v[y].pb(x);\n\tsort(li+1,li+n+1,&cmp);\n\tll res=INF;\n\tll t=ll(1e6)/(n+m);\n\tt*=7;\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0;\n\t\tans=0;\n\t\tq.push({-a[li[i]]+b[li[i]],li[i]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0,cur=rand()%n+1;\n\t\tans=0;\n\t\tq.push({-a[li[cur]]+b[li[cur]],li[cur]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\t/*for(ll i=1;i<=n;i++)\n\t\tif(!w[li[i]])\n\t\t\tans=a[li[i]]-b[li[i]],dfs(li[i]);*/\n\tcout<<res+sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\ntypedef long long ll;\nint n,m,f[Maxn],id[Maxn];\nll g[Maxn],sum[Maxn];\nvector<int>edge[Maxn],son[Maxn];\nstruct node{\n\tint a,b,c;\n}w[Maxn];\ninline int Getfa(int x){return f[x]=(f[x]==x?x:Getfa(f[x]));}\nvoid dfs1(int x){\n\tsum[x]=w[x].b;\n\tfor(int y:son[x]){\n\t\tdfs1(y);\n\t\tsum[x]+=sum[y];\n\t}\n}\nvoid dfs2(int x){\n\tg[x]=sum[x]+w[x].c;\n\tfor(int y:son[x]){\n\t\tdfs2(y);\n\t\tg[x]=min(g[x],sum[x]-sum[y]+max(ll(w[x].c),g[y]));\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&w[i].a,&w[i].b);\n\t\tw[i].c=max(w[i].a-w[i].b,0);\n\t\tf[i]=id[i]=i;\n\t}\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tauto cmp=[&](int a,int b){\n\t\treturn w[a].c<w[b].c||(w[a].c==w[b].c&&a<b);\n\t};\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int y:edge[id[i]])\n\t\t\tif(cmp(Getfa(y),id[i])){\n\t\t\t\tson[id[i]].push_back(Getfa(y));\n\t\t\t\tf[Getfa(y)]=id[i];\n\t\t\t}\n\tdfs1(id[n]);\n\tdfs2(id[n]);\n\tcout<<g[id[n]]<<\"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> par;\nint get(int a) {\n\tif (par[a] < 0) return a;\n\treturn par[a] = get(par[a]);\n}\n\nvoid merge(int a, int b) {\n\ta = get(a);\n\tb = get(b);\n\tassert(a != b);\n\tpar[a] = b;\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n), b(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tif (n == 1) {\n\t\tcout << b[0] << '\\n';\n\t\texit(0);\n\t}\n\tvector<vector<int>> edges(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\n\tpar = vector<int>(n, -1);\n\tvector<int> order(n);\n\tiota(order.begin(), order.end(), 0);\n\tsort(order.begin(), order.end(), [&](int i, int j) {\n\t\treturn a[i] - b[i] < a[j] - b[j];\n\t});\n\tvector<ll> bsums(n);\n\tvector<ll> ans(n);\n\tvector<bool> done(n, false);\n\tfor (int i = 0; i < n; i++) {\n\t\tbsums[i] = b[i];\n\t}\n\tfor (int i : order) {\n\t\tset<int> children;\n\t\tfor (int j : edges[i]) {\n\t\t\tj = get(j);\n\t\t\tif (done[j]) children.insert(j);\n\t\t}\n\t\tfor (int j : children) {\n\t\t\tbsums[i] += bsums[j];\n\t\t\tmerge(j, i);\n\t\t}\n\t\tif (!children.empty()) {\n\t\t\tll best = 1e18;\n\t\t\tfor (int j : children) {\n\t\t\t\tbest = min(best, bsums[i] - bsums[j] + max<ll>(ans[j], a[i] - b[i]));\n\t\t\t}\n\t\t\tans[i] = best;\n\t\t} else {\n\t\t\tans[i] = max(a[i], b[i]);\n\t\t}\n\t\tdone[i] = true;\n\t}\n\tcout << ans[order.back()] << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 200010\n#define int long long\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nstruct edge{int v,next;}vs[N<<1];\nint n,m,A[N],B[N],ee,st[N],fa[N],Rt[N];\nint c[N<<1][2],tot,sum;\nint aa[N],bb[N],Ss[N],cc[N];\ninline int newnode(int a,int b,int c)\n{\n\tint g=++tot;aa[g]=a; bb[g]=b;\n\tcc[g]=c; return g; \n}\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline int getfa(int x)\n{\n\treturn fa[x]==x? x:fa[x]=getfa(fa[x]);\n}\ninline int merge(int x,int y)\n{\n\tif(!x||!y) return x|y;\n\tif(aa[x]-bb[x]>aa[y]-bb[y]) swap(x,y);\n\tif(rand()&1) c[x][1]=merge(c[x][1],y);\n\telse c[x][0]=merge(c[x][0],y);\n\treturn x;\n}\ninline void travel(int S,int x)\n{\n\tif(S+Ss[x]<A[x]) return ;\n\twhile(aa[Rt[x]]-bb[Rt[x]]<=S+Ss[x]&&Rt[x])\n\t{\n\t\tint f1=getfa(cc[Rt[x]]);\n\t\tif(f1==x) {Rt[x]=merge(c[Rt[x]][0],c[Rt[x]][1]); continue;}\n\t\tfa[f1]=x; Rt[x]=merge(c[Rt[x]][0],c[Rt[x]][1]);\n\t\tRt[x]=merge(Rt[x],Rt[f1]);\n\t\tSs[x]+=Ss[f1];\n\t}\n}\ninline bool check(int X)\n{\n\tfor(int i=1;i<=n;i++) Ss[i]=B[i];\n\tfor(int i=1;i<=n;i++) Rt[i]=0;\n\tmemset(c,0,sizeof c);\n\ttot=0; for(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++) for(int j=st[i];j;j=vs[j].next)\n\t\tRt[i]=merge(Rt[i],newnode(A[vs[j].v],B[vs[j].v],vs[j].v));\n\tfor(int i=1;i<=n;i++) if(getfa(i)==i) travel(X,i);\n\tint sc=0; for(int i=1;i<=n;i++) if(getfa(i)==i) sc++;\n\treturn sc==1;\n}\nsigned main()\n{\n\t// freopen(\"read.in\",\"r\",stdin);\n\tn=read(); m=read();\n\tfor(int i=1;i<=n;i++)\n\t\tA[i]=read(), B[i]=read(), sum+=B[i];\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u=read(), v=read();\n\t\taddedge(u,v); addedge(v,u);\n\t}\n\tint L=0,R=0x3fffffff,Ans;\n\twhile(L<=R)\n\t{\n\t\tint mid=(L+R)>>1;\n\t\tif(check(mid)) R=mid-1,Ans=mid;\n\t\telse L=mid+1;\n\t}\n\tcout << sum+Ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e5+10;\nint a[maxn],b[maxn],w[maxn],id[maxn],pos[maxn];\nll sum[maxn],dp[maxn];\nint fa[maxn];\nint Begin[maxn],Next[maxn<<1],to[maxn<<1],e;\ninline void add_edge(int x,int y){\n\tto[++e]=y;\n\tNext[e]=Begin[x];\n\tBegin[x]=e;\n}\ninline bool cmp(const int A,const int B){\n\treturn w[A]<w[B];\n}\nint find(int x){\n\tif(fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main(){\n\tint n=read(),m=read();\n\tREP(i,1,n){\n\t\ta[i]=read(),b[i]=read();\n\t\tw[i]=max(a[i]-b[i],0);\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tREP(i,1,n) pos[id[i]]=i;\n\twhile(m--){\n\t\tint x=read(),y=read();\n\t\tif(pos[x]<pos[y]) add_edge(y,x);\n\t\telse add_edge(x,y);\n\t}\n\tREP(i,1,n){\n\t\tint u=id[i];\n\t\tdp[u]=w[u],fa[u]=u,sum[u]=b[u];\n\t\tfor(int j=Begin[u];j;j=Next[j]){\n\t\t\tint v=to[j];\n\t\t\tif(u==find(v)) continue;\n\t\t\tv=find(v);\n\t\t\tchkmin(dp[u],max(dp[v],w[u]-sum[v]));\n\t\t\tfa[v]=u;\n\t\t\tsum[u]+=sum[v];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[id[n]]+sum[id[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing P = pair<ll, int>;\n\nint n;\nVV<int> g;\nV<ll> lw, us;\n\nV<set<P>> gx;\n\nV<int> ig;\nVV<int> gi;\nvoid uf_init() {\n    ig = V<int>(n); gi = VV<int>(n);\n    for (int i = 0; i < n; i++) {\n        ig[i] = i; gi[i] = {i};\n    }\n}\n\nbool uf_same(int a, int b) {\n    return ig[a] == ig[b];\n}\n\nvoid uf_merge(int a, int b) {\n    if (uf_same(a, b)) return;\n    int x = ig[a], y = ig[b];\n    if (gi[x].size() < gi[y].size()) swap(x, y);\n    for (int j: gi[y]) {\n        ig[j] = x;\n    }\n    gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n    gi[y].clear();\n\n    us[x] += us[y];\n    us[y] = 0;\n\n    if (gx[x].size() > gx[y].size()) swap(gx[x], gx[y]);\n    for (auto d: gx[y]) {\n        gx[x].insert(d);\n    }\n    gx[y].clear();\n}\n\nll ans;\nV<bool> vis;\npriority_queue<P, V<P>, greater<P>> que;\n\nvoid on(int p) {\n    vis[p] = true;\n    for (int d: g[p]) {\n        if (vis[d]) {\n            uf_merge(p, d);\n        }\n    }\n    int x = ig[p];\n    while (gx[x].size()) {\n        auto tp = *(gx[x].begin());\n        gx[x].erase(gx[x].begin());\n        if (vis[tp.second]) continue;\n        if (tp.first <= ans+us[x]) {\n            on(tp.second);\n            break;\n        } else {\n            que.push(P(tp.first - us[x], tp.second));\n            break;\n        }\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int m;\n    cin >> n >> m;\n    g = VV<int>(n);\n    lw = V<ll>(n); us = V<ll>(n);\n    ll off = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> lw[i] >> us[i]; lw[i] -= us[i];\n        off += us[i];\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b); g[b].push_back(a);\n    }\n    uf_init();\n    \n    gx = V<set<P>>(n);\n    for (int i = 0; i < n; i++) {\n        for (int d: g[i]) {\n            gx[i].insert(P(lw[d], d));\n        }\n    }\n    vis = V<bool>(n);\n\n    for (int i = 0; i < n; i++) {\n        que.push(P(lw[i], i));\n    }\n    \n    ans = 0;\n    while (que.size()) {\n        P tp = que.top(); que.pop();\n        int p = tp.second;\n        if (vis[p]) continue;\n        ans = max(ans, tp.first);\n        on(p);\n    }\n    cout << ans+off << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nCerberus97\nHanit Banga\n*/\n\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nll a[N], b[N], temp[N];\nint parent[N], sz[N];\nvector<int> g[N];\nvector<int> pend[N];\n\nbool check(ll s_mon, int n);\nint dsu_find(int x);\nvoid dsu_join(int x, int y);\n\nint main() {\n\tfast_cin();\n\tint n, m;\n\tcin >> n >> m;\n\tll bsum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tbsum += b[i];\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\tint lo = 0, hi = 1e9;\n\twhile (lo <= hi) {\n\t\tint mid = (lo + hi) / 2;\n\t\tif (check(mid, n)) {\n\t\t\thi = mid - 1;\n\t\t} else {\n\t\t\tlo = mid + 1;\n\t\t}\n\t}\n\tcout << hi + 1 + bsum;\n\t// cout << check(100, n) << endl;\n}\n\nbool check(ll s_mon, int n) {\n\tmemset(temp, 0, sizeof(temp));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tparent[i] = i;\n\t\tsz[i] = 1;\n\t\tpend[i].clear();\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\t// cout << i << ' ';\n\t\tif (dsu_find(i) != i or s_mon < a[i] - b[i]) {\n\t\t\t// cout << \"skipped\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\t// cout << endl;\n\t\tint ind = i;\n\t\tll w = s_mon;\n\t\tpriority_queue<pll, vector<pll>, greater<pll>> pq;\n\t\tpq.push({a[i] - b[i], i});\n\t\twhile (!pq.empty()) {\n\t\t\tauto cur = pq.top();\n\t\t\t// cout << cur.first << ' ' << cur.second << ' ' << dsu_find(cur.second) << ' ' << w << endl;\n\t\t\tpq.pop();\n\t\t\tint comp = dsu_find(cur.second);\n\t\t\tif (cur.first > w) {\n\t\t\t\tpend[ind].pb(cur.second);\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tpend[ind].pb(pq.top().second);\n\t\t\t\t\tpq.pop();\n\t\t\t\t}\n\t\t\t} else if (sz[comp] == 1) {\n\t\t\t\tdsu_join(ind, cur.second);\n\t\t\t\tind = dsu_find(ind);\n\t\t\t\tw += b[cur.second];\n\t\t\t\tfor (auto &v : g[cur.second]) {\n\t\t\t\t\tif (dsu_find(v) != ind) {\n\t\t\t\t\t\tpq.push({a[v] - b[v], v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw += temp[comp];\n\t\t\t\tdsu_join(ind, cur.second);\n\t\t\t\tind = dsu_find(ind);\n\t\t\t\tfor (auto &v : pend[comp]) {\n\t\t\t\t\tif (dsu_find(v) != ind) {\n\t\t\t\t\t\tpq.push({a[v] - b[v], v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttemp[ind] = w - s_mon;\n\t\t// cout << ind << ' ' << dsu_find(ind) << ' ' << sz[ind] << endl;\n\t\tif (sz[ind] == n) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint dsu_find(int x) {\n\tif (x == parent[x]) {\n\t\treturn x;\n\t}\n\tparent[x] = dsu_find(parent[x]);\n\treturn parent[x];\n}\n\nvoid dsu_join(int x, int y) {\n\tx = dsu_find(x);\n\ty = dsu_find(y);\n\tif (x == y) {\n\t\treturn;\n\t}\n\tif (sz[x] < sz[y]) {\n\t\tparent[x] = y;\n\t\tsz[y] += sz[x];\n\t} else {\n\t\tparent[y] = x;\n\t\tsz[x] += sz[y];\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tint bsum = 0;\n\tREP(i, n) bsum += b[i];\n\n\tauto check = [&](int w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<int> sum(b);\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tint nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tif (nowsum < nowP.first) break;\n\t\t\t\tint now = nowP.second;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (start != now) {\n\t\t\t\t\tint t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + b[start];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if(!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uf.size(0) == n;\n\t};\n\n\tint l = -1, r = INFLL;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\tOUT(r + bsum)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nint n,m;\nint A[100010],B[100010];\nlong long dp[100010],S[100010];\nbool cmp(int x,int y)\n{\n\treturn S[x]-dp[x]<S[y]-dp[y];\n}\nvector<int>e[100010],son[100010];\nint id[100010];\nbool cmp2(int x,int y)\n{\n\treturn A[x]<A[y];\n}\nbool book[100010];\nint fa[100010];\nint find(int x)\n{\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\nint work()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i;\n\tsort(id+1,id+n+1,cmp2);\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint u=id[j];\n\t\tbook[u]=true;\n\t\tfa[u]=u;\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint v=e[u][i];\n\t\t\tif(book[v])\n\t\t\t{\n\t\t\t\tint f=find(v);\n\t\t\t\tif(f!=u)\n\t\t\t\t{\n\t\t\t\t\tfa[f]=u;\n\t\t\t\t\tson[u].push_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn id[n];\n}\nlong long res1[100010],res2[100010];\nvoid solve(int u)\n{\n\tS[u]=B[u];\n\tif(!son[u].size()){\n\t\tdp[u]=A[u]+B[u];\n\t\treturn ;\n\t}\n\tfor(int i=0;i<son[u].size();i++)\n\t{\n\t\tsolve(son[u][i]);\n\t\tS[u]+=S[son[u][i]];\n\t}\n\tsort(son[u].begin(),son[u].end(),cmp);\n\tlong long nsum=0;\n\tfor(int i=0;i<son[u].size();i++)\n\t{\n\t\tint v=son[u][i];\n\t\tres1[i]=max(nsum+dp[v],i>0?res1[i-1]:0);\n\t\tnsum+=S[v];\n\t}\n\tres2[son[u].size()]=0;\n\tfor(int i=son[u].size()-1;i>=0;i--)\n\t{\n\t\tint v=son[u][i];\n\t\tres2[i]=max(dp[v],res2[i+1]+S[v]);\n\t}\n\tdp[u]=1e18;nsum=0;\n\tfor(int i=0;i<son[u].size();i++)\n\t{\n\t\tint v=son[u][i];\n\t\tlong long val=0;\n\t\tif(i>0)val=max(val,res1[i-1]);\n\t\tval=max(val,nsum+res2[i+1]);\n\t\tval=max(val,A[u]+S[u]-S[v]);\n\t\tval=max(val,S[u]-S[v]+dp[v]);\n\t\tdp[u]=min(dp[u],val);\n\t\tnsum+=S[v];\n\t}\n\treturn ;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d %d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i]-B[i],0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tint rt=work();\n\tsolve(rt);\n\tprintf(\"%lld\\n\",dp[rt]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m;\nvector<int> lis[100100];\nint par[100100];\nll X[100100], Y[100100], A[100100];\nint ord[100100], rnk[100100], vis[100100];\n\nint fin(int a) {\n    return par[a] = ((par[a]==a)?a:fin(par[a]));\n}\nvoid uni(int a, int b) {\n    a = fin(a), b = fin(b);\n    if (a==b) return;\n    par[b] = a;\n}\n\nll tmp[100100];\nvoid reo(ll A[]) {\n    int i;\n    for (i=0;i<n;i++) tmp[i] = A[ord[i]];\n    for (i=0;i<n;i++) A[i] = tmp[i];\n}\n\nint main() {\n    int i;\n\n    scanf(\"%d%d\",&n,&m);\n    for (i=0;i<n;i++) {\n        ll a, b;\n        scanf(\"%lld%lld\",&a,&b);\n        X[i] = max(a,b), Y[i] = b;\n    }\n    for (i=0;i<n;i++) par[i] = ord[i] = i;\n    sort(ord,ord+n,[](int a, int b){return X[a]-Y[a]<X[b]-Y[b];});\n    for (i=0;i<n;i++) rnk[ord[i]] = i;\n    reo(X);reo(Y);reo(A);\n    for (i=0;i<m;i++) {\n        int a, b;\n        scanf(\"%d%d\",&a,&b);a=rnk[--a];b=rnk[--b];\n        if (a<b) swap(a,b);\n        lis[a].push_back(b);\n    }\n    for (i=0;i<n;i++) {\n        //printf(\"%d(%d): %lld, %lld\\n\",i+1,ord[i]+1,X[i],Y[i]);\n\n        ll sum = 0, rx = X[i], ry = Y[i];\n        int cnt = 0;\n        vector<int> can;\n        for (int &v : lis[i]) {\n            if (!vis[fin(v)]) {\n                cnt++;\n                can.push_back(fin(v));\n            }\n            vis[fin(v)] = 1;\n        }\n        sort(can.begin(),can.end(),[](int a, int b){return Y[a]<Y[b];});\n        for (int &v : can) {\n            //printf(\" %d: %lld, %lld\\n\",v,X[v],Y[v]);\n            vis[fin(v)] = 0;\n            if (!(--cnt)) {\n                X[i] = max(X[i],rx+sum);\n                sum += ry;\n            }\n            X[i] = max(X[i],X[fin(v)]+sum);\n            Y[i] += Y[fin(v)];\n            sum += Y[fin(v)];\n            uni(i,v);\n        }\n        //printf(\"-> %lld, %lld\\n\\n\",X[i],Y[i]);\n    }\n    printf(\"%lld\\n\",X[n-1]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <cmath>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\nconst li infl = ~0LLU >> 2;\ntemplate <class T>\ninline void Min(T &x, T y) {\n  if (y < x) x = y;\n}\n\n// const int mod = 1e9 + 7;\n// inline int Add(int x) { return x >= mod ? x - mod : x; }\n// inline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\n// inline int Sub(int x) { return x < 0 ? x + mod : x; }\n// inline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\n// inline int Mul(int x, int y) { return (int)((li)x * y % mod); }\n// inline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\n// int Pow(int x, int y) {\n//   int z = 1;\n//   for (; y; y >>= 1) {\n//     if (y & 1) z = Mul(z, x);\n//     x = Mul(x, x);\n//   }\n//   return z;\n// }\n// int Inv(int x) {\n//   return Pow(x, mod - 2);\n// }\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\n\nint n, m;\nint A[maxn], B[maxn], ord[maxn];\nint par[maxn];\nli best[maxn];\nli sum[maxn];\nvector<int> g[maxn];\nbool light[maxn];\n\nint Find(int x) {\n  while (x != par[x]) {\n    par[x] = par[par[x]];\n    x = par[x];\n  }\n  return x;\n}\n\nint main(void) {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d\", A + i, B + i);\n    ord[i] = i;\n  }\n  sort(ord, ord + n, [](int i, int j) {\n      return A[i] < A[j];\n    });\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n\n  for (int i = 0; i < n; ++i) {\n    light[i] = false;\n    par[i] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    int u = ord[i];\n    vector<int> list;\n    for (int v : g[u]) {\n      if (light[v]) {\n        list.push_back(Find(v));\n      }\n    }\n    sort(list.begin(), list.end());\n    list.erase(unique(list.begin(), list.end()), list.end());\n\n    sum[u] = 0;\n    for (int v : list) {\n      sum[u] += sum[v];\n    }\n    best[u] = sum[u] + max(A[u], B[u]);\n    li min_extra = infl;\n    for (int v : list) {\n      li extra = max<li>(A[u], B[u] + best[v]) - sum[v];\n      Min(min_extra, extra);\n    }\n    Min(best[u], min_extra + sum[u]);\n\n    sum[u] += B[u];\n\n    for (int v : list) {\n      par[v] = u;\n    }\n\n    light[u] = true;\n  }\n\n  printf(\"%lld\\n\", best[Find(0)]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nstruct UF\n{\n\tvector<int> par; // 親のインデックスを記憶する配列\n\tvector<int> sz; // サイズを記憶する。\n\tvector<int> rank;\n\t// 初期化\n\tUF(int n):par(n),sz(n),rank(n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpar[i] = i;sz[i] = 1;rank[i] = 0;\n\t\t}\n\t}\n\t// 親を求める\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t// xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsz[y] += sz[x];\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tsz[x] += sz[y];\n\t\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t// xとyが同じ集合ならtrue\n\tbool same(int x, int y) { return find(x) == find(y); }\n\t// 素の集合のサイズを求める\n\tint size(int n){return sz[find(n)];}\n};\n\nll n,m;\nll a[111111];\nll b[111111];\nll c[111111];\nvector<pair<ll,pair<ll,ll>>> edge;\nvector<vector<int>> v(111111);\n\nll dfs(ll node){\n\tll ret = LLINF;\n\tll tmp_sum = b[node];\n\tvector<ll> seica(v[node].size());\n\tREP(i,v[node].size()){\n\t\tseica[i] = max(dfs(v[node][i]),c[node]);\n\t\ttmp_sum += b[v[node][i]];\n\t}\n\tREP(i,v[node].size()){\n\t\tret = min(ret,seica[i]+tmp_sum-b[v[node][i]]);\n\t}\n\t\n\tret = min(ret,c[node]+tmp_sum);\n\t\n\tb[node] = tmp_sum;\n\treturn ret;\n}\n\nint main(){\n\t\t\n\tcin >> n >> m;\n\tll ma = -1;\n\tll node;\n\tREP(i,n){\n\t\tcin >> a[i] >> b[i];\n\t\tc[i] = max(0LL,a[i] - b[i]);\n\t\tif(ma < c[i]){ma = c[i],node = i;}\n\t}\n\tREP(i,m){\n\t\tint x,y;cin >> x >> y;\n\t\tx--;y--;\n\t\tedge.PB(MP(max(c[x],c[y]),MP(x,y)));\n\t}\n\t\n\tsort(ALL(edge));\n\t\n\tUF uf(n);\n\t\n\tREP(i,m){\n\t\tll A = edge[i].SE.FI;\n\t\tll B = edge[i].SE.SE;\n\t\tif(uf.same(A,B))continue;\n\t\tif(c[A] < c[B]){\n\t\t\tv[B].PB(uf.find(A));\n\t\t\tuf.par[uf.find(A)] = B;\n\t\t}\n\t\telse{\n\t\t\tv[A].PB(uf.find(B));\n\t\t\tuf.par[uf.find(B)] = A;\n\t\t}\n\t\tuf.unite(A,B);\n\t}\n\t\n\tcout << dfs(node) << endl;\n\t\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\nusing namespace std;\n\nconst int N=1e5+5;\nint n,m,val[N],p[N],a[N],b[N],s[N],dp[N];\nvector<int>adj[N],g[N];\npii order[N];\nbool vis[N];\n\nint Find(int x)\n{\n    if(x==p[x]) return x;\n    return p[x]=Find(p[x]);\n}\n\nvoid dfs(int u)\n{\n    s[u]=b[u];\n    for(auto&v:g[u])\n    {\n        dfs(v);\n        s[u]+=s[v];\n    }\n    if(g[u].empty()) dp[u]=max(a[u],b[u]);\n    else dp[u]=1e18;\n    for(auto&v:g[u]) dp[u]=min(dp[u],max(dp[v],val[u])+s[u]-s[v]);\n}\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        p[i]=i;\n        cin>>a[i]>>b[i];\n        val[i]=max(a[i]-b[i],0ll);\n        order[i]=mp(val[i],i);\n    }\n    sort(order+1,order+n+1);\n    while(m--)\n    {\n        int u,v;\n        cin>>u>>v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int u=order[i].se;\n        vis[u]=true;\n        for(auto&v:adj[u])\n        {\n            if(!vis[v]) continue;\n            v=Find(v);\n            if(v==u) continue;\n            g[u].push_back(v);\n            p[v]=u;\n        }\n    }\n    int r=order[n].se;\n    dfs(r);\n    cout<<dp[r];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nint n;\nint A[100005],B[100005];\nstruct uf{\n  static const int MAXN=100005;\n  int par[MAXN];\n  lint dp[MAXN],size[MAXN];\n  void init(){\n    memset(par,-1,sizeof(par));\n    REP(i,n){\n      dp[i]=A[i];\n      size[i]=B[i];\n    }\n  }\n  int root(int a){\n    if(par[a]==-1) return a;\n    return par[a]=root(par[a]);\n  }\n  void unite(int v,set<int> S){\n\n    for(auto u:S) chmin(dp[v],max(dp[u],A[v]-size[u]));\n    for(auto u:S){\n      size[v]+=size[u];\n      assert(par[u]==-1);\n      par[u]=v;\n    }\n  }\n  bool same(int a,int b){\n    return root(a)==root(b);\n  }\n};\n\nuf u;\n\nconst lint INF=1e18;\nint m;\nvector<int> g[100005];\n\nint perm[100005];\nint main(){\n  cin>>n>>m;\n  REP(i,n){\n    scanf(\"%d%d\",&A[i],&B[i]);\n    A[i]=max(0,A[i]-B[i]);\n  }\n  debug(A,A+n);\n  u.init();\n  REP(i,m){\n    int a,b;scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    g[a].pb(b);\n    g[b].pb(a);\n  }\n  REP(i,n) perm[i]=i;\n  sort(perm,perm+n,[&](int a,int b) {\n      return mp(A[a],a)<mp(A[b],b);\n      });\n  REP(i,n){\n    int v=perm[i];\n    dump(v);\n    set<int> S;\n    for(auto to:g[v]) if(mp(A[v],v)>mp(A[to],to) && !u.same(v,to)){\n      S.insert(u.root(to));\n    }\n    u.unite(v,S);\n  }\n  int r=u.root(0);\n  REP(i,n) assert(u.same(i,0));\n  dump(u.dp[r]);\n  lint res=u.dp[r]+accumulate(B,B+n,0ll);\n  cout<<res<<endl;\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <fstream>\n#include <algorithm>\n#include <list>\n#include <random>\n#include <ctime>\n#include <cmath>\n#include <random>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define mmin(a, b) a = min(a, (b))\n#define mmax(a, b) a = max(a, (b))\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define ALL(a) a.begin(),a.end()\n#define sqr(x) (x) * (x)\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define cint const int & \n#define SZ(a) ((int)(a.size()))\n#define watch(x) cout << (#x) << \" = \" << x << endl;\n\nconst double PI = 2 * acos(0.0);\n\ntemplate<class T>\nvoid show(const vector<T> &a) {\n\tfor (T x : a)\n\t\tcout << x << \" \";\n\tcout << endl;\n}\n\nconst int N = 1e5 + 9;\n\nint parent[N];\nint is_free[N];\nll bsum[N];\nvi g[N];\nint n, m;\nll a[N], b[N];\n\nset<pair<ll, int>> neibs[N];\nll gw;\nll gb;\n\nvoid make_set(int v) {\n\tneibs[v].clear();\n\tparent[v] = v;\n\tis_free[v] = a[v] - b[v] + gb <= gw;\n\tbsum[v] = b[v];\n\tfor (int to : g[v])\n\t\tneibs[v].insert(mp(a[to] - b[to], to));\n}\n\nint find_set(int v) {\n\tif (parent[v] == v) return v;\n\treturn parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n\ta = find_set(a);\n\tb = find_set(b);\n\tif (a == b) return;\n\tassert(is_free[a]);\n\tis_free[b] = 1;\n\tif (SZ(neibs[a]) < SZ(neibs[b]))\n\t\tswap(b, a);\n\tbsum[a] += bsum[b];\n\tparent[b] = a;\n\tneibs[a].insert(ALL(neibs[b]));\n}\n\n\nbool check(ll w) {\n\tgw = w;\n\t//watch(gw);\n\tgb = accumulate(b + 1, b + n + 1, 0LL);\n\tfill(parent, parent + n + 1, 0);\n\tfill(bsum, bsum + n + 1, 0);\n\tfill(is_free, is_free + n + 1, 0);\n\tfori(i, n)\n\t\tmake_set(i + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint v = find_set(i);\n\t\t//watch(i);\n\t\t//watch(v);\n\t\tif (!is_free[v]) continue;\n\t\twhile (1) {\n\t\t\tv = find_set(v);\n\t\t\tif (neibs[v].empty()) break;\n\t\t\tint u = find_set((*neibs[v].begin()).second);\n\t\t\t//watch(u);\n\t\t\tif (is_free[u] || a[u] - b[u] - bsum[v] + gb <= gw) {\n\t\t\t\t//cout << \"added\" << endl;\n\t\t\t\tneibs[v].erase(neibs[v].begin());\n\t\t\t\t/*watch(v);\n\t\t\t\twatch(u);\n\t\t\t\tcout << a[u] << \" - \" << b[u] << \" - \" << bsum[v] << \" + \" << gb << \" = \" << a[u] - b[u] + bsum[v] + gb << endl;*/\n\t\t\t\tunion_sets(v, u);\n\t\t\t} else break;\n\t\t}\n\t\tv = find_set(v);\n\t\t////cout << \"become = \" << v << endl;\n\t\t//for (auto x : neibs[v])\n\t\t//\twatch(x.second);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!is_free[find_set(i)]) return 0;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcnt += parent[i] == i;\n\treturn cnt == 1;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tmmax(a[i], b[i]);\n\t}\n\tfori(iter, m) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[u].pb(v);\n\t\tg[v].pb(u);\n\t}\n\n\n\n\tll l = 0, r = 1e18;\n\twhile (l < r) {\n\t\tll m = (l + r) >> 1;\n\t\tif (check(m))\n\t\t\tr = m;\n\t\telse\n\t\t\tl = m + 1;\n\t\tif (l == r - 1) {\n\t\t\tif (check(l)) r = l;\n\t\t\telse l = r;\n\t\t}\n\t}\n\tcout << l << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(!used[u]) continue;\n\tInt pu=uf.find(u);\n\tif(!uf.pq[pu].empty())\n\t  pq.emplace(uf.pq[pu].top().first,pu);\n      }\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg&&!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=s-1;\n  Int r=s+*max_element(a.begin(),a.end());\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Mask2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(5) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(4);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tfriend mll operator / (ll a, const mll &b) { return mll(a)/b; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = 1000000007LL;// 998244353LL;//1000000007LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\nvvll in_Graph(ll nodeNum, ll edgeNum, bool isDirected){\n\tvvll to(nodeNum);\n\tREP(i, edgeNum){\n\t\tll v, u;\n\t\tcin >> v >> u;\n\t\tv--; u--;\n\t\tto[v].push_back(u);\n\t\tif (!isDirected) to[u].push_back(v);\n\t}\n\treturn std::move(to);\n}\n\nvpll AB;\nvvll to;\n\nstruct UnionFindTree{\n\tvll par;\n\tvll size;\n\tvll cost;\n\tvll Ws;\n\tusing pque = priority_queue<pll, vpll, greater<pll>>;\n\tvector<pque> borderQs;\n\n\tUnionFindTree(ll num): par(num), size(num, 1),\n\t\tcost(num), Ws(num), borderQs(num){\n\t\tREP(i, num) par[i] = i;\n\t}\n\tbool Same(ll x, ll y) { return Root(x) == Root(y); }\n\tll Root(ll x) { return (par[x] == x) ? x : par[x]=Root(par[x]); }\n\tll Size(ll x){ return size[Root(x)]; }\n\tvoid Unite(ll x, ll y){//x勝ち側\n\t\tx = Root(x);\n\t\ty = Root(y);\n\t\tif (x == y) return;\n\t\t//ll c = cost[x];\n\n\t\t//Ws[x]の更新\n\t\tll W;\n\t\tif (Ws[y] == 0){//未発火時\n\t\t\tW = Ws[x] + AB[y].second;\n\t\t}\n\t\telse{\n\t\t\tW = Ws[x] + Ws[y] - cost[y];\n\t\t}\n\t\tWs[x] = W;\n\n\t\t//bordersのマージ\n\t\tif (Ws[y] == 0){//未発火時\n\t\t\tEACH(v, to[y]){\n\t\t\t\tll a, b; tie(a, b) = AB[v];\n\t\t\t\tborderQs[x].push(pll(a-b, v));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpque *bQ, *bQD;\n\t\t\tbQ  = &(borderQs[x]);\n\t\t\tbQD = &(borderQs[y]);\n\t\t\twhile (!bQD->empty()){\n\t\t\t\tbQ->push(bQD->top());\n\t\t\t\tbQD->pop();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpar[y] = x;\n\t\tsize[x] = size[y] = size[x] + size[y];\n\t}\n};\n\n\nvoid solve()\n{\n\tll N, M;  cin >> N >> M;\n\tAB = cinv2(N);\n\tto = in_Graph(N, M, false);\n\n\tpriority_queue<pll, vpll, greater<pll>> areaQ; //pair<コスト,ノード>\n\tREP(v, N){\n\t\tll a, b; tie(a, b) = AB[v];\n\t\tll c = a-b;\n\t\tareaQ.push(pll(c, v));\n\t}\n\n\tUnionFindTree uft(N);\n\n\tll ans = -1;\n\twhile (!areaQ.empty()){\n\t\tll newc, v; tie(newc,v) = areaQ.top();  areaQ.pop();\n\n\t\tif (uft.Ws[v]==0){//未発火時\n\t\t\tuft.cost[v] = max(0LL, newc);\n\t\t\tuft.Ws[v] = max(AB[v].first, AB[v].second);\n\t\t}\n\t\telse{\n\t\t\tll diff = newc - uft.cost[v];\n\t\t\tuft.Ws[v] += diff;\n\t\t\tuft.cost[v] = newc;\n\t\t}\n\t\t//自分の周りを全てbordersに入れる\n\t\tEACH(u, to[v]){\n\t\t\tll a, b; tie(a, b) = AB[u];\n\t\t\tuft.borderQs[v].push(pll(a-b, u));\n\t\t}\n\n\t\twhile (!uft.borderQs[v].empty()){\n\t\t\tll u_c, u; tie(u_c, u) = uft.borderQs[v].top();\n\t\t\tif (u_c > uft.Ws[v]) break;//取り出せない\n\t\t\tuft.borderQs[v].pop();\n\t\t\tif (uft.Same(v, u)) continue;\n\t\t\tuft.Unite(v, u);\n\t\t}\n\n\t\tif (uft.borderQs[v].empty()){\n\t\t\tans = uft.Ws[v];\n\t\t\tbreak;//ans出力へ\n\t\t}\n\n\t\tll needCost = uft.borderQs[v].top().first - uft.Ws[v] + uft.cost[v];\n\t\tareaQ.push(pll(needCost, v));\n\t}\n\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=2005;\nint d[N],a[N],c[N],b[N],n,k,q,ans=1000000000;\nint solve(int x){\n\tint cnt=0,tot=0;\n\tfor (int i=1;i<=n+1;i++){\n\t\tif (a[i]<x){\n\t\t\tif (cnt>=k){ \n\t\t\t\tstd::sort(c+1,c+cnt+1);\n\t\t\t\tfor (int j=1;j+k-1<=cnt;j++) d[++tot]=c[j];\n\t\t\t}\n\t\t\tcnt=0;\n\t\t}else c[++cnt]=a[i];\n\t}\n\tif (tot<q) return ans;\n\tstd::sort(d+1,d+tot+1);\n\treturn d[q]-d[1];\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&k,&q);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]),b[i]=a[i];\n\tstd::sort(b+1,b+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tans=std::min(ans,solve(b[i]));\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 120000;\n\nint n, m;\nll a[MAXN];\nll b[MAXN];\nint en[MAXN];\nint p[MAXN];\nint sz[MAXN];\n\nvector<int> eds[MAXN];\n\nset<pair<ll, int> > ss[MAXN];\nll sum[MAXN];\n\nint get(int x) {\n\tif (x == p[x])\n\t\treturn x;\n\treturn p[x] = get(p[x]);\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i] = max(a[i], b[i]);\n\t}\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tll l = -1;\n\tll r = 1e9;\n\twhile (r - l > 1) {\n\t\tll mid = (l + r) >> 1;\n\t\tfill(en, en + n, 0);\n\t\tiota(p, p + n, 0);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tss[i].clear();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!en[i] && a[i] <= b[i] + mid) {\n\t\t\t\ten[i] = 1;\n\t\t\t\tsum[i] = mid + b[i];\n\t\t\t\tqueue<int> qu;\n\t\t\t\tqu.push(i);\n\t\t\t\twhile (!qu.empty()) {\n\t\t\t\t\tint x = qu.front();\n\t\t\t\t\tqu.pop();\n\t\t\t\t\tfor (int j: eds[x])\n\t\t\t\t\t\tif (get(j) != i)\n\t\t\t\t\t\t\tss[i].emplace(a[j] - b[j], j);\n\t\t\t\t\twhile (!ss[i].empty() && ss[i].begin()->first <= sum[i]) {\n\t\t\t\t\t\tint x = ss[i].begin()->second;\n\t\t\t\t\t\tss[i].erase(ss[i].begin());\n\t\t\t\t\t\tif (!en[x]) {\n\t\t\t\t\t\t\tsum[i] += b[x];\n\t\t\t\t\t\t\ten[x] = 1;\n\t\t\t\t\t\t\tp[x] = i;\n\t\t\t\t\t\t\tqu.push(x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tx = get(x);\n\t\t\t\t\t\t\tif (x == i)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tsum[i] += sum[x] - mid;\n\t\t\t\t\t\t\tif (ss[x].size() > ss[i].size())\n\t\t\t\t\t\t\t\tswap(ss[x], ss[i]);\n\t\t\t\t\t\t\tfor (auto e: ss[x])\n\t\t\t\t\t\t\t\tss[i].insert(e);\n\t\t\t\t\t\t\tss[x].clear();\n\t\t\t\t\t\t\tp[x] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (accumulate(en, en + n, 0) == n)\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid;\n\t}\n\tcout << r + accumulate(b, b + n, 0ll) << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, ll, ll>> pq;// -cost, from, to\n  auto poss = [&](ll rem) {\n    DisjointSet<> dsu(n);\n    fill(ALL(vis), false);\n    VEVE(i, 0, n) {\n      if (need[i] <= rem) {\n        dsu.sum[i] = rem + recv[i];\n        vis[i] = true;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    while (not pq.empty()) {\n      ll cost, fr, to;\n      tie(cost, fr, to) = pq.top();\n      pq.pop();\n      cost = -cost;\n      if (dsu.IsSameSet(fr, to))\n        continue;\n      if (dsu.sum[dsu.Find(fr)] >= cost) {\n        dsu.Unite(fr, to);\n        if (not vis[to]) {\n          vis[to] = true;\n          dsu.sum[dsu.Find(to)] += recv[to];\n          RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n        } else {\n//          dsu.sum[dsu.Find(to)] -= rem;\n        }\n      }\n    }\n    VEVE(i, 0, n) if (not vis[i]) return false;\n    return true;\n  };\n  poss(0);\n  ll low = 0, hig = 1e9;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int UF_MAX = 1e5 + 3;\n\nclass UF{\n\tint x[UF_MAX];\n\tLL p[UF_MAX];\n\tpriority_queue<pair<LL,int>,vector<pair<LL,int>>,greater<pair<LL,int>>> Q[UF_MAX];\n\t\npublic:\n\n\tvoid clear(){\n\t\tfill(x,x+UF_MAX,-1);\n\t\tfill(p,p+UF_MAX,0);\n\t\trepp(i,0,UF_MAX) while(!Q[i].empty()) Q[i].pop();\n\t}\n\t\n\tint boss(int a){\n\t\tint s = a;\n\t\twhile(x[s] > -1) s = x[s];\n\t\tif(s != a) x[a] = s;\n\t\treturn s;\n\t}\n\t\n\tvoid uni(int a , int b){\n\t\tint s = boss(a);\n\t\tint t = boss(b);\n\t\tif(s != t){\n\t\t\tif(Q[s].size() < Q[t].size()) swap(s,t);\n\t\t\twhile(!Q[t].empty()){\n\t\t\t\tQ[s].push(Q[t].top());\n\t\t\t\tQ[t].pop();\n\t\t\t}\n\t\t\tif(x[s] < x[t]){\n\t\t\t\tx[s] += x[t];\n\t\t\t\tx[t] = s;\n\t\t\t\tp[s] += p[t];\n\t\t\t} else {\n\t\t\t\tx[t] += x[s];\n\t\t\t\tx[s] = t;\n\t\t\t\tp[t] += p[s];\n\t\t\t\tswap(Q[s],Q[t]);\n\t\t\t}\n\t\t}\n\t}\n\n\tLL get_p(int a){\n\t\treturn p[boss(a)];\n\t}\n\n\tint get_q(int a){\n\t\ta = boss(a);\n\t\treturn Q[a].empty()?-1:Q[a].top().second;\n\t}\n\n\tvoid set(int a , LL b){\n\t\tp[a] = b;\n\t}\n\n\tvoid push(int a , int b , LL c){\n\t\tQ[a].push({c,b});\n\t}\n\n\tvoid pop(int a){\n\t\tQ[boss(a)].pop();\n\t}\n};\n\nconst int MC = 1e5 + 3;\nint N,M;\nLL A[MC],B[MC],S;\nvector<int> V[MC];\nUF uf;\n\nbool eval(LL z){\n\tvector<int> used(N,0);\n\tqueue<int> Q;\n\tuf.clear();\n\trepp(i,0,N){\n\t\tfor(auto u : V[i]) uf.push(i,u,A[u]);\n\t\tif(z >= A[i]){\n\t\t\tQ.push(i);\n\t\t\tuf.set(i,B[i]);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint k = Q.front(); Q.pop();\n\t\tfor(int u = uf.get_q(k) ; u >= 0 && z + uf.get_p(k) >= A[u] ; u = uf.get_q(k)){\n\t\t\tif(!used[u]){\n\t\t\t\tQ.push(u);\n\t\t\t\tuf.set(u,B[u]);\n\t\t\t\tused[u] = 1;\n\t\t\t}\n\t\t\tuf.pop(k);\n\t\t\tuf.uni(k,u);\n\t\t}\n\t}\n\tint c = 0;\n\trepp(i,0,N) c += used[i];\n\treturn c == N;\n}\n\nLL BS(LL x , LL y){\n\tif(x-y<2) return x;\n\tLL z = (x+y)/2;\n\treturn eval(z)?BS(z,y):BS(x,z);\n}\n\nint main(){\n\tcin >> N >> M;\n\trepp(i,0,N){\n\t\tcin >> A[i] >> B[i];\n\t\tS += B[i];\n\t\tA[i] -= B[i];\n\t}\n\trepp(i,0,M){\n\t\tint x,y; cin >> x >> y;\n\t\tV[--x].push_back(--y);\n\t\tV[y].push_back(x);\n\t}\n\tcout << S + BS(1e9,-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, m, cnt, top, s, maxi, now, fa[Maxn], node[Maxn], sta[Maxn], a[Maxn], b[Maxn], w[Maxn], head[Maxn];\nlong long sum[Maxn], mini[Maxn];\nvector <int> Ve[Maxn];\nbool vis[Maxn];\nstruct edg\n{\n\tint nxt, to;\n}edge[2 * Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs(int u)\n{\n\tmini[u] = 0x3f3f3f3f3f3f3f3f;\n\tsum[u] = b[u];\n\tfor (vector <int> :: iterator it = Ve[u].begin(); it != Ve[u].end(); it++)\n\t{\n\t\tint to = *it;\n\t\tdfs(to);\n\t\tsum[u] += sum[to];\n\t\tmini[u] = min(mini[u], max((long long) w[u], mini[to]) - sum[to]);\n\t}\n\tif (!Ve[u].size()) mini[u] = w[u] + b[u];\n\telse mini[u] += sum[u];\n}\nint get_fa(int x)\n{\n\treturn x == fa[x] ? x : fa[x] = get_fa(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0, a[i] - b[i]), node[i] = fa[i] = i;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t}\n\tsort(node + 1, node + 1 + n, [](int x, int y){return w[x] < w[y];});\n\tfor (int j = 1; j <= n; j++)\n\t{\n\t\tint u = node[j];\n\t\tvis[u] = true;\n\t\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tint to = edge[i].to;\n\t\t\tif (vis[to] && get_fa(to) != u)\n\t\t\t\tVe[u].push_back(get_fa(to)), fa[get_fa(to)] = u;\n\t\t}\n\t}\n\tdfs(node[n]);\n\tprintf(\"%lld\", mini[node[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=3e5+99;\nstruct node{int id;ll a,b;}p[N];\nint n,m,fa[N],vis[N],cur[N];\nll a[N],b[N],sum[N],ans[N];\nvector<int>g[N];\nbool cmp(node a,node b){return a.a<b.a;}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i],b[i]);\n\t\tp[i]=(node){i,a[i],b[i]};\n\t\tsum[i]=b[i];\n\t}\n\tfor(int i=1,x,y;i<=m;i++)scanf(\"%d%d\",&x,&y),g[x].push_back(y),g[y].push_back(x);\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<=n;i++)fa[i]=i,ans[i]=1e18;\n\tfor(int i=1,j;i<=n;i=j+1)\n\t{\n\t\tj=i;while(p[j+1].a==p[i].a)j++;\n\t\tfor(int k=i;k<=j;k++)vis[p[k].id]=1;\n\t\tfor(int k=i;k<=j;k++)\n\t\t{\n\t\t\tint x=p[k].id;\n\t\t\tfor(int t=0;t<g[x].size();t++)\n\t\t\t{\n\t\t\t\tint to=find(g[x][t]);\n\t\t\t\tif(!vis[to])continue;\n\t\t\t\tcur[g[x][t]]=to;\n\t\t\t}\n\t\t}\n\t\tfor(int k=i;k<=j;k++)\n\t\t{\n\t\t\tint x=p[k].id;\n\t\t\tfor(int t=0;t<g[x].size();t++)\n\t\t\t{\n\t\t\t\tint to=find(g[x][t]);\n\t\t\t\tif(!vis[to]||find(x)==to)continue;\n\t\t\t\tint y=find(x),z=find(to);\n\t\t\t\tfa[z]=y;\n\t\t\t\tsum[y]+=sum[to];\n\t\t\t}\n\t\t}\n\t\tfor(int k=i;k<=j;k++)\n\t\t{\n\t\t\tint x=p[k].id;\n\t\t\tfor(int t=0;t<g[x].size();t++)\n\t\t\t{\n\t\t\t\tint to=cur[g[x][t]];\n\t\t\t\tif(!vis[to]||i==vis[to])continue;\n\t\t\t\tll now=find(x),cst=max(a[x],ans[to]+b[x])+sum[now]-sum[to]-b[x];\n\t\t\t\tans[now]=min(ans[now],cst);\n\t\t\t}\n\t\t\tint y=find(x);\n\t\t\tans[y]=min(ans[y],a[y]+sum[y]-b[x]);\n\t\t}\n\t}\n\tcout<<ans[find(1)]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100100;\nint a[N],b[N],n,m,vis[N],fa[N],c[N];\ntypedef long long ll;\nvector<int>g[N];\nll sum[N],mn[N];\nbool cmp(const int&x,const int&y){\n\tif(a[x]!=a[y])return a[x]<a[y];\n\treturn b[x]>b[y];\n}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i){cin>>a[i]>>b[i];c[i]=i;}\n\tsort(c+1,c+n+1,cmp);\n\tfor(int i=1;i<=m;++i){\n\t\tint x,y;cin>>x>>y;\n\t\tg[x].push_back(y);g[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;++i)fa[i]=i;//,sort(g[i].begin(),g[i].end(),cmp);\n\tfor(int i=1;i<=n;++i){\n\t\tint u=c[i];sum[u]=b[u];mn[u]=max(0,a[u]-b[u]);\n\t\tvis[u]=1;\n\t\tfor(int j:g[u])if(vis[j]){\n\t\t\tint v=find(j);if(u==v)continue;\n\t\t\tsum[u]+=sum[v];mn[u]=min(mn[u],max(a[u]-sum[v]-b[u],mn[v]));\n\t\t\tfa[v]=u;\n\t\t}\n\t}\n\tcout<<sum[c[n]]+mn[c[n]]<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    if (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n            else if (mol[par[i]].size()!=n){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]!=-1) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],s[N],q[N];\nll sum;int n,m,l,r,mid,ans,mx;\n//inline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n//void merge(int u,int v){\n//\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n//\twhile(!Q[v].empty()){\n//\t\tR pi p=Q[v].top();Q[v].pop();\n//\t\tif(find(p.se)!=find(u))Q[u].push(p);\n//\t}\n//}\n//bool ck(){\n//\tint h=1,t=0,u;\n//\tfp(u,1,n){\n//\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n//\t\tif(dx[u]<=0)q[++t]=u;\n//\t\twhile(!Q[u].empty())Q[u].pop();\n//\t\tgo(u)Q[u].push(pi(dx[v],v));\n//\t}\n//\twhile(h<=t){\n//\t\tu=q[h++];if(find(u)!=u)continue;\n//\t\twhile(!Q[u].empty()){\n//\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n//\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n//\t\t\tif(s[u]+s[p.se]>=mx)return true;\n//\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,merge(u,p.se);\n//\t\t}\n//\t}\n//\tR int rt=find(1);\n//\tfp(i,2,n)if(find(i)!=rt)return false;\n//\treturn true;\n//}\nbool ok(R int s){\n\tif(a[s]-b[s]-mid>0)return false;\n\tfp(i,1,n)dx[i]=a[i]-b[i]-mid;\n\tstatic int vis[N];\n\tfp(i,1,n)vis[i]=0;ll sum=b[s];\n\tpriority_queue<pi,vector<pi>,greater<pi> >q;\n\tvis[s]=1;go(s)if(sum>=dx[v])q.push(pi(dx[v],v)),vis[v]=1;\n\twhile(!q.empty()){\n\t\tR int u=q.top().se;q.pop();\n\t\tif(dx[u]>sum)break;\n\t\tsum+=b[u];if(sum>mx)return true;\n\t\tgo(u)if(!vis[v]&&dx[v]<=sum)q.push(pi(dx[v],v));\n\t}\n\tfp(i,1,n)if(!vis[i])return false;\n\treturn true;\n}\nbool ck(){\n\tfp(i,1,n)if(ok(i))return true;\n\treturn false;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 3e6 + 10;\nconst int maxn = 300020;\nconst ll mod = 1e9 + 7;\nconst ull base = 907;\n\nstruct node{\n\tint next,to;\n};\nnode e[maxn * 2];\nint head[maxn],cnt;\t\nint n,m,dfstime;\n\nint a[maxn],b[maxn],vis[maxn],tag[maxn];\nint id;\nll sum[maxn],sumf[maxn],f[maxn],mn[maxn];\n\nvoid clear(){\n\trep(i,1,n) head[i] = 0;\n\tcnt = 0;\n}\nvoid adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nvoid init(){\n\trep(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y),adde(y,x);\n\t}\n}\nvoid findroot(int x){\n\tif ( max(0,a[id] - b[id]) < max(0,a[x] - b[x]) ) id = x;\n\tvis[x] = dfstime;\n\tfore(i,x){\n\t\tif ( vis[e[i].to] == dfstime || tag[e[i].to] ) continue;\n\t\tfindroot(e[i].to);\n\t}\t\n}\nll ans = 0;\nint solve(int x){\n\t++dfstime, id = x , findroot(x);\n\tint rt = id;\n\ttag[rt] = 1;\n\n\tsum[rt] = b[rt];\n\tf[rt] = max(a[rt] - b[rt],0);\n\tfore(i,rt){\n\t\tif ( tag[e[i].to] ) continue;\n\t\tint to = solve(e[i].to); //注意e[i].to不是下一块的根！\n\t\tsum[rt] += sum[to];\n\t\tf[rt] = min(f[rt],max(f[to],a[rt] - b[rt] - sum[to]));\n\t}\n\tif ( x == 1 ) ans = f[rt] + sum[rt];\n\treturn rt;\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,n) scanf(\"%d %d\",&a[i],&b[i]);\n\tinit();\n\tsolve(1);\n\tcout<<ans<<endl;\n//\trep(i,1,n) cout<<i<<\" : \"<<f[i]<<\" \"<<sum[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvector<int> par;\nint get(int a) {\n\tif (par[a] < 0) return a;\n\treturn par[a] = get(par[a]);\n}\n\nvoid merge(int a, int b) {\n\ta = get(a);\n\tb = get(b);\n\tassert(a != b);\n\tpar[a] = b;\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n), b(n);\n\tfor (int i = 0; i < n; i++) cin >> a[i] >> b[i];\n\tvector<vector<int>> edges(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\n\tpar = vector<int>(n, -1);\n\tvector<int> order(n);\n\tiota(order.begin(), order.end(), 0);\n\tsort(order.begin(), order.end(), [&](int i, int j) {\n\t\treturn a[i] - b[i] < a[j] - b[j];\n\t});\n\tvector<ll> bsums(n);\n\tvector<ll> ans(n);\n\tvector<bool> done(n, false);\n\tfor (int i = 0; i < n; i++) {\n\t\tbsums[i] = b[i];\n\t}\n\tfor (int i : order) {\n\t\tset<int> children;\n\t\tfor (int j : edges[i]) {\n\t\t\tj = get(j);\n\t\t\tif (done[j]) children.insert(j);\n\t\t}\n\t\tfor (int j : children) {\n\t\t\tbsums[i] += bsums[j];\n\t\t\tmerge(j, i);\n\t\t}\n\t\tif (!children.empty()) {\n\t\t\tll best = 1e18;\n\t\t\tfor (int j : children) {\n\t\t\t\tbest = min(best, bsums[i] - bsums[j] + max<ll>(ans[j], a[i] - b[i]));\n\t\t\t}\n\t\t\tans[i] = best;\n\t\t} else {\n\t\t\tans[i] = max(a[i], b[i]);\n\t\t}\n\t\tdone[i] = true;\n\t}\n\tcout << ans[order.back()] << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\ntypedef long long ll;\ntypedef pair<int, int> pi;\nconst int INF = 0x3f2f1f0f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 10;\n\nstruct UF{\n\tvector<int> UNF;\n\tvector<int> Ans;\n\tvector<ll> Sum;\n\tUF(int n, int a[], int b[]) {\n\t\tUNF = vector<int>(n, 0);\n\t\tAns = vector<int>(n, 0);\n\t\tSum = vector<ll>(n, 0);\n\t\tfor(int i=0; i<n; i++) UNF[i] = i;\n\t\tfor(int i=0; i<n; i++) Ans[i] = max(0, a[i] - b[i]);\n\t\tfor(int i=0; i<n; i++) Sum[i] = b[i];\n\t}\n\tint F(int v) {return UNF[v] == v ? v : UNF[v] = F(UNF[v]);}\n\tbool U(int a, int b, int Ab, int Bb) { // b have bigger A[]\n\t\ta = F(a); b = F(b);\n\t\tif(a == b) return false;\n\t\tUNF[a] = b;\n\t\tSum[b] += Sum[a];\n\t\tint ans = Ans[a];\n\t\tif(Ans[a] + Sum[a] >= max(0, Ab - Bb)) Ans[b] = min(Ans[b], Ans[a]);\n\t\telse Ans[b] = min(1ll * Ans[b], Ans[a] + (max(0, Ab - Bb) - Ans[a] - Sum[a]));\n\t\treturn true;\n\t}\n};\nstruct ND{\n\tint ix, a, b;\n\tND(int ix_, int a_, int b_) : ix(ix_), a(a_), b(b_) {}\n};\nint N, M;\nint A[MAX_N], B[MAX_N];\nvector<ND> Ns;\nvector<int> Ed[MAX_N];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i=0; i<N; i++) {\n\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\tNs.emplace_back(i, A[i], B[i]);\n\t}\n\tsort(ALL(Ns), [&](ND &x, ND &y) {return max(0, x.a-x.b) < max(0, y.a-y.b);});\n\tfor(int i=0; i<M; i++) {\n\t\tint x, y; scanf(\"%d%d\", &x, &y); x--; y--;\n\t\tEd[x].push_back(y);\n\t\tEd[y].push_back(x);\n\t}\n\t\n\tUF uf = UF(N, A, B);\n\tvector<bool> vis(N, false);\n\tfor(int n=0; n<N; n++) {\n\t\tint v = Ns[n].ix, a = Ns[n].a, b = Ns[n].b;\n\t\tfor(int w : Ed[v]) if(vis[w]) uf.U(w, v, A[v], B[v]);\n\t\t//printf(\"v %d : Ans %d Sum %lld\\n\", v, uf.Ans[v], uf.Sum[v]);\n\t\tvis[v] = true;\n\t}\n\tprintf(\"%lld\\n\", uf.Ans[uf.F(0)] + uf.Sum[uf.F(0)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, m, cnt, top, s, maxi, now, fa[Maxn], node[Maxn], sta[Maxn], a[Maxn], b[Maxn], w[Maxn], head[Maxn];\nlong long sum[Maxn], mini[Maxn];\nvector <int> Ve[Maxn];\nbool vis[Maxn];\nstruct edg\n{\n\tint nxt, to;\n}edge[2 * Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs(int u)\n{\n\tmini[u] = 0x3f3f3f3f3f3f3f3f;\n\tsum[u] = b[u];\n\tfor (vector <int> :: iterator it = Ve[u].begin(); it != Ve[u].end(); it++)\n\t{\n\t\tint to = *it;\n\t\tdfs(to);\n\t\tsum[u] += sum[to];\n\t\tmini[u] = min(mini[u], max((long long) w[u], mini[to]) - sum[to]);\n\t}\n\tif (!Ve[u].size()) mini[u] = w[u] + b[u];\n\telse mini[u] += sum[u];\n}\nint get_fa(int x)\n{\n\treturn x == fa[x] ? x : fa[x] = get_fa(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0, a[i] - b[i]), node[i] = fa[i] = i;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y);\n\t\tadd(y, x);\n\t}\n\tsort(node + 1, node + 1 + n, [](int x, int y){return w[x] < w[y];});\n\tfor (int j = 1; j <= n; j++)\n\t{\n\t\tint u = node[j];\n\t\tvis[u] = true;\n\t\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tint to = edge[i].to;\n\t\t\tif (vis[to] && get_fa(to) != u)\n\t\t\t\tVe[u].push_back(get_fa(to)), fa[get_fa(to)] = u;\n\t\t}\n\t}\n\tdfs(node[n]);\n\tprintf(\"%lld\", mini[node[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    friend bool operator< (Info a , Info b)  {return a.cost < b.cost;}\n};\n\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\n\nvoid unlock(int x) ;\nvoid merge(int x , int y) ;\n\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) unlock(y);\n            else {\n                out[p].insert(y);\n                modifycost(y , (int)max(limit[y] - money[p] , 0LL));                \n            }\n        }\n    }\n}\n\n\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x];\n\n    //while(out[y].size()) \n    for(auto it = out[y].begin() ; it != out[y].end() ; ){\n//        x = *out[y].begin();\n        x = *it;\n        if(find(x) == y) {\n//            out[y].erase(*out[y].begin());\n            it = out[y].erase(it);\n            continue;\n        }\n        if(money[y] + init >= limit[x]) {\n//            out[y].erase(*out[y].begin());\n            it = out[y].erase(it);\n            unlock(x);\n            y = find(y);\n            it = out[y].begin();\n            continue;\n        }\n        modifycost(x , (int)max(limit[x] - money[y] , 0LL));\n//        break;\n        it++;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        point.erase(point.begin());\n        if(unlocked[x]) continue;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 1;\nint par[N],n,b[N],m;\nlong long sum[N],v[N];\nvector<int>g[N];\nvector<pair<int,int>>temp;\nbool vis[N];\nint get(int u){return par[u] == u ? u : par[u] = get(par[u]);}\nint main(){\n\t//freopen(\"readin.txt\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0,a;i < n;i++){\n\t\tpar[i] = i;\n\t\tscanf(\"%d%d\",&a,b + i);\n\t\ttemp.push_back({a - b[i],i});\n\t}\n\tfor(int i = 0,a,b;i < m;i++){\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tg[--a].push_back(--b);\n\t\tg[b].push_back(a);\n\t}\n\tsort(temp.begin(),temp.end());\n\tfor(auto i : temp){\n\t\tint need = max(0,i.first),at = i.second;\n\t\tsum[at] = b[at];\n\t\tv[at] = need;\n\t\tvis[at] = 1;\n\t\tfor(auto j : g[at]){\n\t\t\tint from = get(j);\n\t\t\tif(from == at || !vis[from])continue;\n\t\t\tsum[at]+=sum[from];\n\t\t\t// if(sum[from] + v[from] >= need)v[at] = min(v[at],v[from]);\n\t\t\t// else v[at] = min(v[at],need - sum[from]);\n\t\t\tv[at] = min(v[at],max(v[from],need - sum[from]));\n\t\t\tpar[from] = at;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum[temp.back().second] + v[temp.back().second]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nint n,m,a[N],b[N],u,v,x,i,g[N],id[N];\nvector<int>e[N];\nlong long f[N],su[N];\nint gfa(int x){return g[x]==x?x:g[x]=gfa(g[x]);}\ninline bool cmp(const int&x,const int&y){return a[x]-b[x]<a[y]-b[y];}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m;for(i=1;i<=n;++i)cin>>a[i]>>b[i],g[i]=id[i]=i;\n\tfor(i=1;i<=m;++i)cin>>u>>v,e[u].push_back(v),e[v].push_back(u);\n\tsort(id+1,id+n+1,cmp);\n\tfor(i=1;i<=n;++i){\n\t\tu=id[i];su[u]=b[u];f[u]=1ll<<60;\n\t\tfor(int v:e[u])if(su[v]){\n\t\t\tx=gfa(v);if(x==u)continue;\n\t\t\tf[u]=min(f[u],max(f[x],a[u]-su[x]-b[u]));su[u]+=su[x];g[x]=u;\n\t\t}\n\t\tif(su[u]==b[u])f[u]=max(a[u]-b[u],0);\n\t}\n\tcout<<f[u]+su[u]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int MAXN=100100;\nvector<int> arrive[MAXN];\nint a[MAXN],b[MAXN],p[MAXN];\nint fa[MAXN];\nint f[MAXN],s[MAXN],vis[MAXN];\nint n,m;\ninline int find(register int x)\n{\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\ninline void Addedge(register int u,register int v)\n{\n\tarrive[u].push_back(v);\n\treturn;\n}\ninline bool cmp_(register int x,register int y)\n{\n\treturn a[x]<a[y];\n}\nsigned main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(register int i=1;i<=n;i++) cin>>a[i]>>b[i],a[i]=max(a[i]-b[i],0LL),p[i]=fa[i]=i;\n\tsort(p+1,p+n+1,cmp_);\n\tfor(register int i=1,x,y;i<=m;i++) cin>>x>>y,Addedge(x,y),Addedge(y,x);\n\tfor(register int i=1;i<=n;i++)\n\t{\n\t\tvector<int> sonnow;\n\t\tregister int now=p[i];\n\t\tvis[now]=1,s[now]=b[now];\n\t\tfor(register int i=0;i<(int)arrive[now].size();i++)\n\t\t{\n\t\t\tregister int val=arrive[now][i];\n\t\t\tif((!vis[val])||find(now)==find(val)) continue;\n\t\t\tsonnow.push_back(find(val));\n\t\t\ts[now]+=s[find(val)];\n\t\t\tfa[find(val)]=now;\n\t\t}\n\t\tf[now]=s[now]+a[now];\n\t\tfor(register int i=0;i<(int)sonnow.size();i++) f[now]=min(f[now],s[now]-s[sonnow[i]]+max(a[now],f[sonnow[i]]));\n\t}\n\tcout<<f[p[n]]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,u,v,a[100001],b[100001],c[100001],s[100001],d[100001];\nint x[100001][491],y[100001][491],f[100001],sr[100001];\nbool bo[100001];\ninline int read()\n{\n    int sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(int x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(int x,int y)\n{\n\treturn c[x]<c[y];\n}\ninline int find(int x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(int u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register int i=1;i<=y[u][0];++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register int i=1;i<=y[u][0];++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register int i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register int i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u][++x[u][0]]=v;\n\t\tx[v][++x[v][0]]=u;\n\t}\n\tfor (register int i=1;i<=n;++i)\n\t{\n\t\tint u=d[i];\n\t\tfor (register int j=1;j<=x[u][0];++j)\n\t\t{\n\t\t\tint v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u][++y[u][0]]=vv;\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr int MAX_N = 1E5;\nconstexpr LL INF = 1E18;\nint n, m;\nvector<int> e[MAX_N];\nint a[MAX_N], b[MAX_N];\nint fa[MAX_N];\nint p[MAX_N];\nLL f[MAX_N], s[MAX_N];\nint find(int x) {\n    while (fa[x] >= 0 && fa[fa[x]] >= 0)\n        x = fa[x] = fa[fa[x]];\n    return fa[x] >= 0 ? fa[x] : x;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i] >> b[i];\n        a[i] = max(a[i] - b[i], 0);\n    }\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u;\n        --v;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    fill(fa, fa + n, -1);\n    iota(p, p + n, 0);\n    sort(p, p + n, [&](int i, int j) {return a[i] < a[j];});\n    for (int i = 0; i < n; ++i) {\n        int u = p[i];\n        f[u] = a[u];\n        s[u] = b[u];\n        for (int v : e[u]) {\n            if (a[v] > a[u])\n                continue;\n            v = find(v);\n            if (u == v)\n                continue;\n            fa[v] = u;\n            s[u] += s[v];\n            f[u] = min(f[u], max((LL)a[u], f[v]) - s[v]);\n        }\n        f[u] += s[u];\n    }\n    cout << f[find(0)] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\n\nnamespace _DSU {\n\tconstexpr int BUF = 212345 * 2;\n\tint ptr = 0;\n\tint mem[BUF];\n\tint* get(int size) {\n\t\tptr += size;\n\t\treturn mem + ptr - size;\n\t}\n\tvoid reset() {\n\t\tptr = 0;\n\t}\n}\nconstexpr int N = 112345;\nLL A[N];\nLL B[N];\nint C[N];\nclass UF {\nprivate:\n\tint *par, *rank;\npublic:\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tUF(int n) :par(_DSU::get(n + 10)), rank(_DSU::get(n + 10)) {\n\t\tfor (int i = 0; i<n; i++) {\n\t\t\tpar[i] = i, rank[i] = 0;\n\t\t}\n\t}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y)return false;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\npair<LL, int> w[N];\ntypedef vector<int> V;\ntypedef vector<V> VV;\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i : range(n)) {\n\t\tcin >> A[i] >> B[i];\n\t\tif (A[i] < B[i])A[i] = B[i];\n\t\tA[i] -= B[i];\n\t\tw[i] = { A[i] ,i };\n\t}\n\tsort(w, w + n);\n\tVV g(n);\n\tfor (int i : range(m)) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tUF uf(n);\n\tfor (int i : range(n)) {\n\t\tint v = w[i].second;\n\t\tC[v] = 1;\n\t\tLL nA = A[v];\n\t\tLL nB = B[v];\n\t\tfor (int u : g[v]) {\n\t\t\tif (C[u] == 0)continue;\n\t\t\tu = uf.find(u);\n\t\t\tif (uf.same(v, u))continue;\n\t\t\tnB += B[u];\n\t\t\tLL d = max(A[v]-(A[u] + B[u]), 0ll);\n\t\t\tchmin(nA, A[u] + d);\n\t\t\tuf.unite(v, u);\n\t\t}\n\t\tv = uf.find(v);\n\t\tA[v] = nA;\n\t\tB[v] = nB;\n\t}\n\t{\n\t\tint u = uf.find(0);\n\t\tcout << A[u]+B[u] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define INF 3e15\n#define mod 1000000007\n#define eps 1e-6\n#define abs(x) ((x)>=0?(x):-(x))\n#define y1 solai\n#define fi first\n#define se second\ntypedef long long ll;\nvoid read(ll &x)\n{\n\tscanf(\"%lld\",&x);\n}\nvoid read(ll &x, ll &y)\n{\n\tscanf(\"%lld%lld\",&x,&y);\n}\nvoid read(ll &x, ll &y, ll &z)\n{\n\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n}\nvoid print(ll x)\n{\n\tprintf(\"%lld \",x);\n}\nvoid println(ll x)\n{\n\tprintf(\"%lld\\n\",x);\n}\nconst ll N=100000;\nll n,m,x,y,l,r,mid,ans,sum,a[N+10],b[N+10],li[N+10],w[N+10],p[N+10],ra[N+10],su[N+10];\nvector<ll>v[N+10];\nset<pair<ll,ll> >s[N+10];\n/*ll fin(ll a)\n{\n\tif(a==p[a])\n\t\treturn a;\n\treturn p[a]=fin(p[a]);\n}\nvoid uni(ll a, ll b)\n{\n\ta=fin(a),b=fin(b);\n\tif(a==b)\n\t\treturn;\n\tif(r[a]>r[b])\n\t\tr[a]+=r[b],su[a]+=su[b],p[b]=a;\n\telse\n\t\tr[b]+=r[a],su[b]+=su[a],p[a]=b;\n}\nvoid dfs(ll x)\n{\n\tw[x]=1;\n\tll rt=fin(x);\n\tsu[rt]+=b[x];\n\tfor(ll to:v[x])\n\t\tif(fin(x)!=fin(to))\n\t\t\ts[rt].insert({a[to]-b[to],to});\n\twhile(!s[rt].empty())\n\t{\n\t\tll need=s[rt].begin()->fi,to=s[rt].begin()->se;\n\t\tif(fin(x)==fin(to))\n\t\t\ts[rt].erase(s[rt].begin());\n\t\telse if(fin(x)!=fin(to)&&su[rt]>=need)\n\t\t{\n\t\t\tuni(rt,s[rt].begin()->se);\n\t\t\tdfs(s[rt].begin()->se);\n\t\t\trt=fin(x);\n\t\t\ts[rt].erase(s[rt].begin());\n\t\t}\n\t\telse\n\t\t\treturn;\n\t}\n}*/\nbool cmp(ll x, ll y)\n{\n\treturn a[x]-b[x]<a[y]-b[y];\n}\nint main()\n{\n\t//freopen(\"c.cpp\",\"r\",stdin);\n \n\tcin>>n>>m;\n\tfor(ll i=1;i<=n;i++)\n\t\tread(a[i],b[i]),sum+=b[i],li[i]=i,p[i]=i,ra[i]=1,su[i]=b[i];\n\tfor(ll i=1;i<=m;i++)\n\t\tread(x,y),v[x].pb(y),v[y].pb(x);\n\tsort(li+1,li+n+1,&cmp);\n\tll res=INF;\n\tll t=ll(1e6)/(n+m);\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0;\n\t\tans=0;\n\t\tq.push({-a[li[i]]+b[li[i]],li[i]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\tfor(ll i=1;i<=min(t,n);i++)\n\t{\n\t\tpriority_queue<pair<ll,ll> >q;\n\t\tll bal=0,cur=rand()%n+1;\n\t\tans=0;\n\t\tq.push({-a[li[cur]]+b[li[cur]],li[cur]});\n\t\tfor(ll j=1;j<=n;j++)\n\t\t\tw[j]=0;\n\t\tfor(;!q.empty();)\n\t\t{\n\t\t\tx=q.top().se,y=-q.top().fi;\n\t\t\tq.pop();\n\t\t\tif(w[x])\n\t\t\t\tcontinue;\n\t\t\tw[x]=1;\n\t\t\tif(bal<y)\n\t\t\t\tans+=y-bal,bal=y;\n\t\t\tbal+=b[x];\n\t\t\tfor(ll to:v[x])\n\t\t\t{\n\t\t\t\tll need=a[to]-b[to];\n\t\t\t\tif(!w[to])\n\t\t\t\t\tq.push({-need,to});\n\t\t\t}\n\t\t}\n\t\tres=min(res,ans);\n\t}\n\t/*for(ll i=1;i<=n;i++)\n\t\tif(!w[li[i]])\n\t\t\tans=a[li[i]]-b[li[i]],dfs(li[i]);*/\n\tcout<<res+sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing i64=long long;\nconst int N=100007;\nint a[N],b[N],p[N],fa[N],vis[N];i64 f[N],sum[N];\nstd::vector<int>e[N];\nint read(){int x;scanf(\"%d\",&x);return x;}\nint find(int x){return x==fa[x]? x:fa[x]=find(fa[x]);}\nint main ()\n{\n    int n=read(),m=read();\n    for(int i=1;i<=n;++i) a[i]=read(),b[i]=read(),a[i]=std::max(a[i]-b[i],0),p[i]=fa[i]=i;\n    std::sort(p+1,p+n+1,[](int i,int j){return a[i]<a[j];});\n    for(int i=1,u,v;i<=m;++i) u=read(),v=read(),e[u].push_back(v),e[v].push_back(u);\n    for(int i=1;i<=n;++i)\n    {\n\tstd::vector<int>son;int u=p[i];\n        vis[u]=1,sum[u]=b[u]; \n        for(int v:e[u]) if(vis[v]&&find(u)^find(v)) son.push_back(fa[v]),sum[u]+=sum[fa[v]],fa[fa[v]]=u;\n        f[u]=sum[u]+a[u];\n        for(int v:son) f[u]=std::min(f[u],sum[u]-sum[v]+std::max((i64)a[u],f[v])); \n    }\n    printf(\"%lld\\n\",f[p[n]]);\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 1e5+7;\n\nint p[MAXN];\nint parent(int u) {\n    if (u==p[u]) return u;\n    return p[u] = parent(p[u]);\n}\n\nint a[MAXN], b[MAXN], c[MAXN];\nint done[MAXN];\n\nvector< int >edg[MAXN];\nvector< int >child[MAXN];\n\nLL bsum[MAXN];\nvoid dfs(int u) {\n    bsum[u] = b[u];\n    for (int v : child[u]) {\n        dfs(v);\n        bsum[u] += bsum[v];\n    }\n//    cout << \"bsum[\" << u << \"] = \" << bsum[u] << endl;\n}\n\nint root;\nLL solve(int u, LL upore) {\n    if (child[u].empty()) return max(upore, bsum[root]+c[u]);\n\n    LL ans = 1e18;\n    for (int v : child[u]) {\n        LL tmp = bsum[root]-bsum[v]+c[u];\n        ans = min(ans, solve(v, max(upore, tmp)));\n    }\n\n//    cout << \"ans[\" << u << \"] = \" << ans << endl;\n    return ans;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector< int >order(n);\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n\n        c[i] = max(a[i]-b[i], 0);\n        order[i-1] = i;\n        p[i] = i;\n    }\n\n    sort(order.begin(), order.end(), [&](int i, int j) {\n        return c[i] < c[j];\n    });\n\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        cin >> u >> v;\n        edg[u].push_back(v);\n        edg[v].push_back(u);\n    }\n\n    for (int u : order) {\n//        cout << \"c[\" << u << \"] = \" << c[u] << endl;\n        for (int v : edg[u]) {\n            if (done[v]) {\n                int pv = parent(v);\n                if (pv != u) {\n                    child[u].push_back(pv);\n                    p[pv] = u;\n//                    cout << \"parent[\" << pv << \"] = \" << u << endl;\n                }\n            }\n        }\n        done[u] = 1;\n//        cout << u << \" done\" << endl;\n    }\n\n    root = order.back();\n    dfs(root);\n    cout << solve(root, 0) << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nstruct node{\n\tLL y,next;\n}e[500010];LL len=0,last[500010];\nvoid ins(LL x,LL y)\n{\n\te[++len].y=y;\n\te[len].next=last[x];last[x]=len;\n}\nLL n,m,fa[500010],f[500010],sum[500010];\nLL findfa(LL x) {return fa[x]==x?x:fa[x]=findfa(fa[x]);}\nLL a[500010],b[500010],pos[500010],vis[500010];\nbool cmp(LL x,LL y) {return a[x]<a[y];}\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&m);\n\tfor(LL i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld %lld\",&a[i],&b[i]);\n\t\ta[i]=max(0LL,a[i]-b[i]);\n\t}\n\tfor(LL i=1;i<=m;i++)\n\t{\n\t\tLL x,y;scanf(\"%lld %lld\",&x,&y);\n\t\tins(x,y);ins(y,x);\n\t}\n\tfor(LL i=1;i<=n;i++) fa[i]=i,sum[i]=b[i],pos[i]=i,f[i]=a[i];\n\tsort(pos+1,pos+n+1,cmp);\n\tmemset(vis,false,sizeof(vis));\n\tfor(LL j=1;j<=n;j++)\n\t{\n\t\tLL x=pos[j];vis[x]=1;\n\t\tfor(LL i=last[x];i;i=e[i].next)\n\t\t{\n\t\t\tLL y=e[i].y;\n\t\t\tif(vis[y])\n\t\t\t{\n\t\t\t\tLL tx=findfa(x),ty=findfa(y);\n\t\t\t\tif(tx==ty) continue;\n\t\t\t\tsum[tx]+=sum[ty];fa[ty]=tx;\n\t\t\t\tf[tx]=min(f[tx],f[ty]+max(0LL,a[x]-f[ty]-sum[ty]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum[pos[n]]+f[pos[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pii pair <int , int>\n#define F first\n#define S second\nconst int N = 1e5 + 5, inf = 1e9 + 1;\nint A[N], B[N], par[N], C, n, m;\nlong long W[N], Sum;\nvector <int> g[N];\npriority_queue <pii, vector<pii>, greater<pii>> pq[N];\n\nvoid init(int w) {\n    C = n;\n    for (int v = 1; v <= n; v++) {\n        par[v] = v, W[v] = B[v];\n        while (!pq[v].empty()) pq[v].pop();\n        for (int u : g[v]) pq[v].push({A[u] - B[u], u});\n    }\n}\nint getpar(int v) {return par[v] = (par[v] == v ? v : getpar(par[v]));}\nvoid Union(int u, int v) {\n    u = getpar(u);\n    if (u == v) return ;\n    par[u] = v, W[v] += W[u], C--;\n    if (pq[u].size() > pq[v].size()) swap(pq[u], pq[v]);\n    while (!pq[u].empty()) pq[v].push(pq[u].top()), pq[u].pop();\n}\nbool check(int w) {\n    init(w);\n    for (int v = 1; v <= n; v++) if (par[v] == v && w + W[v] >= A[v]) {\n        while (!pq[v].empty()) {\n            int u = pq[v].top().S;\n            if (A[u] - B[u] > W[v] + w) break ;\n            pq[v].pop(), Union(u, v);\n        }\n    }\n    return C == 1;\n}\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> A[i] >> B[i], Sum += B[i];\n    for (int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        g[u].push_back(v), g[v].push_back(u);\n    }\n    int dw = -1, up = inf;\n    while (up - dw > 1) {\n        int md = (up+dw)>>1;\n        if (check(md)) up = md;\n        else dw = md;\n    }\n    cout << Sum + up << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n \nconst int N = 1e5 + 5;\n\nint A[N], B[N], P[N];\nll S[N], W[N];\nvector< pair<int, pii> > E;\n\nint GetPar(int v) { return P[v] == v ? v : P[v] = GetPar(P[v]); }\nvoid Merge(int v, int u) {\n\tif (A[v] - B[v] < A[u] - B[u]) swap(v, u);\n\tint pv = GetPar(v), pu = GetPar(u);\n\tif (pv == pu) return;\n\tW[pv] = min(W[pv], max(0LL, (W[pu] + S[pu] >= A[v] - B[v] ? W[pu] : A[v] - B[v] - S[pu])));\n\tS[pv] += S[pu];\n\tP[pu] = pv;\n}\n\nint main() {\n \n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\n\t\n\tint n, m; cin >> n >> m;\n\tfor (int i = 1; i <= n; i++) cin >> A[i] >> B[i], P[i] = i, S[i] = B[i], W[i] = max(0, A[i] - B[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint v, u; cin >> v >> u;\n\t\tE.push_back(make_pair(max(A[v] - B[v], A[u] - B[u]), make_pair(v, u)));\n\t}\n\tsort(all(E));\n\tfor (auto e : E) {\n\t\tint v = e.second.first, u = e.second.second;\n\t\tMerge(v, u);\n\t}\n\tcout << max(0LL, W[GetPar(1)] + S[GetPar(1)]) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int mxn=1000010;\nint M,n,m,head[mxn],fa[mxn],stk[mxn],rnk[mxn],a[mxn],b[mxn];\nLL f[mxn],g[mxn];\nbool cmp(const int &x,const int &y){return a[x]<a[y];}\nstruct ed{int to,nxt;}edge[mxn];\nvoid addedge(int u,int v){\n\tedge[++M]=(ed){v,head[u]},head[u]=M;\n\tedge[++M]=(ed){u,head[v]},head[v]=M;\n}\nint find(int x){\n\tif (fa[x]==x) return x;\n\telse return fa[x]=find(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) fa[i]=i,stk[i]=i;\n\tfor (int i=1;i<=n;++i)\n\t\tscanf(\"%d%d\",&a[i],&b[i]),a[i]=max(a[i]-b[i],0);\n\tsort(stk+1,stk+n+1,cmp);\n\tfor (int i=1;i<=n;++i) rnk[stk[i]]=i;\n\tfor (int i=1,x,y;i<=m;++i)\n\t\tscanf(\"%d%d\",&x,&y),addedge(x,y);\n\tfor (int j=1,u;j<=n;++j){\n\t\tu=stk[j],g[u]=b[u];\n\t\tLL mn=a[u];\n\t\tfor (int i=head[u];i;i=edge[i].nxt){\n\t\t\tint v=edge[i].to,fx=find(v);\n\t\t\tif (fx!=u&&rnk[v]<rnk[u])\n\t\t\t\tg[u]+=g[fx],mn=min(mn,max(1ll*a[u],f[fx])-g[fx]),fa[fx]=u;\n\t\t}\n\t\tf[u]=g[u]+mn;\n\t}\n\tprintf(\"%lld\\n\",f[stk[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a; i <= b; ++i)\nusing namespace std;\n\ntemplate <typename tn> void read (tn & a) {\n\ttn x = 0, f = 1; char c = getchar();\n\twhile (c < '0' || c > '9'){ if (c == '-') f = -1; c = getchar(); }\n\twhile (c >= '0' && c <= '9'){ x = x * 10 + c - '0'; c = getchar(); }\n\ta = f == 1 ? x : -x;\n}\n\nconst int MAXN = 100100;\nconst int Ln = 22;\nconst int INF = 2e9;\nint n, m;\nint a[MAXN], b[MAXN];\nvector<int> g[MAXN];\nint f[MAXN], fa[MAXN], bsum[MAXN], p[MAXN];\nbool vis[MAXN];\n\nint find (int x) { return fa[x] == 0 || fa[x] == x ? x : fa[x] = find(fa[x]); }\nbool cmp (int i, int j) { return a[i] < a[j]; }\n\nint main() {\n\tread(n);\n\tread(m);\n\trep(i, 1, n) read(a[i]), read(b[i]);\n\trep(i, 1, m) {\n\t\tint u, v;\n\t\tread(u);\n\t\tread(v);\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\trep(i, 1, n) {\n\t\ta[i] -= b[i];\n\t\tif (a[i] < 0) a[i] = 0;\n\t\tfa[i] = i;\n\t\tp[i] = i;\n\t\tvis[i] = 0;\n\t}\n\tsort(p + 1, p + 1 + n, cmp);\n\trep(i, 1, n) {\n\t\tint x = p[i];\n\t\tf[x] = a[x];\n\t\tbsum[x] = b[x]; \n\t\tvis[x] = 1;\n\t\trep(j, 0, (int) g[x].size() - 1) {\n\t\t\tint v = g[x][j];\n\t\t\tif (vis[v]) {\n\t\t\t\tint y = find(v);\n\t\t\t\tif (x != y) {\n//\t\t\t\t\tcerr<<\"   \"<<y<<\"\\n\";\n\t\t\t\t\tfa[y] = x;\n\t\t\t\t\tbsum[x] += bsum[y];\n\t\t\t\t\tf[x] = min(f[x], max(f[y], a[x] - bsum[y]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//          cerr<<i<<\" \"<<x<<\" \"<<f[x]<<\"\\n\";\n\t}\n\tcout << f[p[n]] + bsum[p[n]]<<\"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\nconst int _=1e2;\nconst int maxn=1e5+_;\nconst int maxm=1e5+_;\n\nint A[maxn],B[maxn],id[maxn];\nbool cmp(int n1,int n2){return A[n1]<A[n2];}\nvector<int>vec[maxn];\nstruct node\n{\n\tint x,y,next;\n}a[maxm];int len,last[maxn];\nvoid ins(int x,int y)\n{\n\tlen++;\n\ta[len].x=x;a[len].y=y;\n\ta[len].next=last[x];last[x]=len;\n}\nint F[maxn];\nLL f[maxn],sum[maxn];//进入这棵树搞完最少要多少速度，这棵树里面的总消耗速度\nvoid dfs(int x)\n{\n\tif(last[x]==0){f[x]=A[x]+B[x];sum[x]=B[x];return ;}\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tdfs(y);\n\t\tsum[x]+=sum[y];\n\t}\n\tf[x]=(1LL<<62);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tf[x]=min(f[x],max(f[y],(LL)A[x])+sum[x]-sum[y]);\n\t}\n}\n\nint fa[maxn];\nint findfa(int x)\n{\n\tif(x==fa[x])return x;\n\tfa[x]=findfa(fa[x]);return fa[x];\n}\nint main()\n{\n\tint n,m,x,y;\n\tscanf(\"%d%d\",&n,&m); len=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&A[i],&B[i]);\n\t\tA[i]=max(A[i]-B[i],0);\n\t\tid[i]=i;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tvec[x].push_back(y);\n\t\tvec[y].push_back(x);\n\t}\n\t\t\n\tsort(id+1,id+n+1,cmp);\n\tmemset(F,-1,sizeof(F));\n\tfor(int t=1;t<=n;t++)\n\t{\n\t\tint i=id[t]; fa[i]=i;\n\t\tfor(int k=0;k<vec[i].size();k++)\n\t\t{\n\t\t\tint j=vec[i][k],fj=findfa(j);\n\t\t\tif(F[fj]==0)F[fj]=i,fa[fj]=i;\n\t\t}\n\t\tF[i]=0;\n\t}\n\tint rt;\n\tfor(int i=1;i<=n;i++)\n\t\tif(F[i]==0)rt=i;\n\t\telse ins(F[i],i);\n\t\t\n\tdfs(rt);\n\tprintf(\"%lld\\n\",f[rt]);\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\n//UF\nint par1[100021];\nint rank1[100021];\n//n要素で初期化\nvoid init(int n){\n   for(int i=0;i<n;i++){\n       par1[i]=i;\n       rank1[i]=0;\n   }\n}\n//木の根を求める\nint find(int x){\n    if(par1[x] ==x){\n         return x;\n    }else{\n         return par1[x]=find(par1[x]);\n    }\n}\n//xとyの属する集合を併合\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n\n    if(rank1[x]<rank1[y]){\n         par1[x]=y;\n    }else{\n         par1[y]=x;\n         rank1[x]++;\n    }\n}\n//xとyが同じ集合に属するか否か\nbool same(int x,int y){\n     return find(x)==find(y);\n}\n\n\n\nint N,M;\nLL A[100001];\nLL B[100001];\nLL C[100001];\nLL dp[100001];\nLL s[100001];\nbool used[100001];\n\nvector<int>G[100001];\ntypedef pair<LL,LL>P;\nvector<P>v;\nint main(){\n\tcin>>N>>M;\n\tREP(i,N){\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]=max(A[i],B[i]);\n\t\tv.push_back(P(A[i],i));\n\t}\n\tsort(v.begin(),v.end());\n\tREP(i,M){\n\t\tint u,vv;\n\t\tcin>>u>>vv;\n\t\tu--;vv--;\n\t\tG[u].push_back(vv);\n\t\tG[vv].push_back(u);\n\t}\n\tinit(N+10);\n\tREP(i,N){\n\t\tdp[i]=B[i];//得られたお金\n\t\ts[i]=C[i]-B[i];//最後の資金\n\t\tused[i]=false;\n\t}\n\tREP(i,v.size()){\n\t\tint x=v[i].second;\n\t\tused[x]=true;\n\t\tvector<int>k;\n\t\tREP(j,G[x].size()){\n\t\t\tif(used[G[x][j]]==true){\n\t\t\t\tk.push_back(find(G[x][j]));\n\t\t\t}\n\t\t}\n\t\tsort(k.begin(),k.end());\n\t\tk.erase(unique(k.begin(), k.end()), k.end());\n\t\t//要素のソート\n\t\tvector<P>u;\n\t\tREP(j,k.size()){\n\t\t\tu.push_back(P(dp[k[j]],k[j]));\n\t\t}\n\t\tREP(j,u.size()){\n\t\t\tif(s[find(x)]<=s[u[j].second]){\n\t\t\t\tLL a=s[find(x)];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else if(s[u[j].second]+dp[u[j].second]>=(C[x]-B[x])){\n\t\t\t\tLL a=s[u[j].second];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else if((C[x]-B[x])-dp[u[j].second]<=s[find(x)]){\n\t\t\t\tLL a=(C[x]-B[x])-dp[u[j].second];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}else{\n\t\t\t\tLL a=s[find(x)];\n\t\t\t\tLL b=dp[find(x)]+dp[u[j].second];\n\t\t\t\tunite(find(x),u[j].second);\n\t\t\t\ts[find(x)]=a;\n\t\t\t\tdp[find(x)]=b;\n\t\t\t}\n\t\t\t//cout<<\"x=\"<<x<<\" dp[x]=\"<<dp[x]<<\" s[x]=\"<<s[x]<<endl;\n\t\t}\n\t}\n\tcout<<dp[find(0)]+s[find(0)]<<endl;\n\t/*REP(i,5){\n\t\tcout<<\"f\"<<dp[find(i)]<<endl;\n\t}*/\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = A[i];\n\t\tVs[i].ss = -i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = -Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\n\t\tif(sz > 1) for(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tcat w_mi = max(A[c]+s, B[c]+s+W[comp_adj[j]])-1, w_mx = OVER9000;\n\t\t\tvector< pair<cat, cat> > Vs;\n\t\t\tfor(int k = 0; k < sz; k++)\n\t\t\t\tif(k != j) Vs.push_back(make_pair(W[comp_adj[k]], sumB[comp_adj[k]]));\n\t\t\tsort(begin(Vs), end(Vs));\n\t\t\tvector<bool> vis(sz-2);\n\t\t\tint a = sz-1;\n\t\t\twhile(w_mx-w_mi > 1) {\n\t\t\t\tcat w_cur = (w_mi + w_mx) / 2;\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int l = sz-2; l >= 0; l--) {\n\t\t\t\t\tif(vis[l]) continue;\n\t\t\t\t\tif(Vs[l].ff > w_cur) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta = min(a, l-1);\n\t\t\t\t\tif(a >= 0 && Vs[a].ff > w_cur-Vs[l].ss) {\n\t\t\t\t\t\tvis[a] = true;\n\t\t\t\t\t\tw_cur -= Vs[a].ss;\n\t\t\t\t\t\ta--;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvis[l] = true;\n\t\t\t\t\tw_cur -= Vs[l].ss;\n\t\t\t\t}\n\t\t\t\tif(ok) w_mx = (w_mi + w_mx) / 2;\n\t\t\t\telse w_mi = (w_mi + w_mx) / 2;\n\t\t\t}\n\t\t\t// cout << j << \" \" << i << endl;\n\t\t\tW[c] = min(W[c], w_mx);\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\t\telse {\n\t\t\tW[c] = min(W[c], max(m+B[c], max(A[c], B[c]+s)));\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long v,nxt;\n};\nnode edge[200001];\nstruct reads\n{\n\tlong long num,data;\n\tbool operator < (const reads &a)const\n\t{\n\t\treturn data>a.data;\n\t}\n};\nreads t[100001];\nlong long n,m,a[100001],b[100001],head[100001],len,rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].nxt=head[x];\n\thead[x]=len;\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tt[i].num=i;\n\t\tt[i].data=a[i];\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(t+1,t+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=head[t[i].num];j>0;j=edge[j].nxt)\n\t\t\tif (a[t[i].num]<a[edge[j].v]&&find(t[i].num)!=find(edge[j].v))\n\t\t\t\tunionn(t[i].num,edge[j].v);\n\t}\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 101000\nusing namespace std;\nstruct point {\n\tlong long a, b, num;\n\tbool operator<(const point &p)const {\n\t\treturn a < p.a;\n\t}\n}w[N_];\nlong long A[N_], B[N_];\nvector<long long>E[N_];\nlong long SB[N_], M[N_], mmm;\nlong long UF[N_], chk[N_];\nlong long n, m, v[N_];\nlong long Find(long long a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nstruct TT {\n\tlong long sb, m;\n\tbool operator <(const TT &p)const {\n\t\treturn sb - m < p.sb - p.m;\n\t}\n};\nlong long G[N_], BB[N_], EE[N_];\nvoid Go(long long a, vector<long long> &T) {\n\tchk[a] = 1;\n\tif (T.empty()) {\n\t\tSB[a] = B[a];\n\t\tM[a] = max(A[a], B[a]);\n\t\treturn;\n\t}\n\tlong long sz = T.size();\n\tvector<TT> U(sz);\n\tmmm = A[a];\n\tlong long c = 0;\n\tfor (auto &t : T) {\n\t\tUF[t] = a;\n\t\tU[c++] = { SB[t], M[t] };\n\t}\n\tsort(U.begin(), U.end());\n\tlong long mm = 0, sb = 0;\n\tlong long i;\n\tfor (i = 0; i < sz; i++) {\n\t\tmm = max(mm, sb + U[i].m);\n\t\tG[i] = sb + U[i].m;\n\t\tsb += U[i].sb;\n\t}\n\tmm = max(mm, sb + max(A[a], B[a]));\n\tfor (i = 0; i < sz; i++) {\n\t\tif (i == 0 || G[i] > BB[i - 1])BB[i] = G[i];\n\t\telse BB[i] = BB[i - 1];\n\t}\n\tfor (i = sz - 1; i >= 0; i--) {\n\t\tif (i == sz - 1 || G[i] > EE[i + 1])EE[i] = G[i];\n\t\telse EE[i] = EE[i + 1];\n\t}\n\n\tfor (i = 0; i < sz; i++) {\n\t\tlong long t = sb - U[i].sb + B[a] + U[i].m;\n\t\tt = max(t, sb - U[i].sb + max(A[a], B[a]));\n\t\tif (i != 0)t = max(t, BB[i - 1]);\n\t\tif (i != sz - 1)t = max(t, EE[i + 1] - U[i].sb);\n\t\tmm = min(mm, t);\n\t}\n\n\tsb += B[a];\n\tM[a] = mm;\n\tSB[a] = sb;\n}\nint main() {\n\tlong long i, a, b;\n\tscanf(\"%lld%lld\", &n, &m);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld\", &w[i].a, &w[i].b);\n\t\tA[i] = w[i].a, B[i] = w[i].b;\n\t\tUF[i] = i;\n\t\tw[i].num = i;\n\t}\n\tsort(w + 1, w + n + 1);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long a = w[i].num;\n\t\tvector<long long>T;\n\t\tfor (auto &x : E[a]) {\n\t\t\tif (!chk[x])continue;\n\t\t\tlong long t = Find(x);\n\t\t\tif (!v[t]) {\n\t\t\t\tT.push_back(t);\n\t\t\t\tv[t] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : T)v[t] = 0;\n\t\tGo(a, T);\n\t}\n\tprintf(\"%lld\\n\", M[w[n].num]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n#define VEVE(i, a, b) for (ll i = a, __##i = b; i < __##i; ++i)\n#define DYDY(i, a, b) for (ll i = a, __##i = b; i > __##i; --i)\n#define RARA(x, seq) for (auto &x : seq)\n#define SIZE(x) ((ll)(x.size()))\n#define ALL(x) x.begin(), x.end()\n\ntypedef int64_t ll;\ntypedef double dd;\n\ntemplate <template <class> class Alloc = allocator> struct DisjointSet {\n  vector<int, Alloc<int>> tree;\n  vector<ll> sum;\n\n  DisjointSet(int n) : tree(n, -1), sum(n, 0) {}\n\n  bool Unite(int a, int b) {\n    a = Find(a);\n    b = Find(b);\n    if (a == b)\n      return false;\n    if (-tree[b] > -tree[a])\n      swap(a, b);\n    // merge smaller tree (b) to (a)\n    tree[a] += tree[b];\n    sum[a] += sum[b];\n    tree[b] = a;\n    return true;\n  }\n\n  int GetSize(int a) {\n    return -tree[Find(a)];\n  }\n\n  bool IsSameSet(int a, int b) {\n    return Find(a) == Find(b);\n  }\n\n  int Find(int node) {\n    return tree[node] < 0 ? node : (tree[node] = Find(tree[node]));\n  }\n};\n\nvoid Solve(ll) {\n  ll n, m;\n  if (not(cin >> n >> m))\n    return;\n  vector<ll> need(n), recv(n);\n  VEVE(i, 0, n) {\n    cin >> need[i] >> recv[i];\n    need[i] -= recv[i];\n    need[i] = max(ll(0), need[i]);\n  }\n  vector<vector<ll>> adj(n);\n  VEVE(e, 0, m) {\n    ll u, v;\n    cin >> u >> v;\n    --u, --v;\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n  vector<bool> vis(n);\n  priority_queue<tuple<ll, ll, ll>> pq;// -cost, from, to\n  auto poss = [&](ll rem) {\n    DisjointSet<> dsu(n);\n    fill(ALL(vis), false);\n    VEVE(i, 0, n) {\n      if (need[i] <= rem) {\n        dsu.sum[i] = rem + recv[i];\n        vis[i] = true;\n        RARA(to, adj[i]) pq.emplace(-need[to], i, to);\n      }\n    }\n    while (not pq.empty()) {\n      ll cost, fr, to;\n      tie(cost, fr, to) = pq.top();\n      pq.pop();\n      cost = -cost;\n      if (dsu.IsSameSet(fr, to))\n        continue;\n      if (dsu.sum[dsu.Find(fr)] >= cost) {\n        dsu.Unite(fr, to);\n        if (not vis[to]) {\n          vis[to] = true;\n          dsu.sum[dsu.Find(to)] += recv[to];\n          RARA(v, adj[to]) pq.emplace(-need[v], to, v);\n        } else {\n          dsu.sum[dsu.Find(to)] -= rem;\n        }\n      }\n    }\n    VEVE(i, 0, n) if (not vis[i]) return false;\n    return true;\n  };\n  poss(0);\n  ll low = 0, hig = 1e9;\n  while (low <= hig) {\n    const ll mid = (low + hig) / 2;\n    if (poss(mid)) {\n      hig = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  const ll res = hig + 1 + accumulate(ALL(recv), ll(0));\n  cout << res << endl;\n}\n\nvoid Init() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n}\n\n}\n\nint32_t main() {\n#ifdef AZN\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  Init();\n  ll tests = 11;\n  VEVE(test, 1, tests + 1) Solve(test);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nll A[101010],B[101010];\npair<ll,int> C[101010];\nvector<int> E[101010];\nll BS[101010];\nll Q[101010];\nint did[101010];\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<500000> uf;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]={max(A[i]-B[i],0LL),i};\n\t\tBS[i]=B[i];\n\t}\n\tFOR(i,M) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tsort(C,C+N);\n\tFOR(i,N) {\n\t\tx=C[i].second;\n\t\tdid[x]=1;\n\t\tvector<int> V;\n\t\tFORR(e,E[x]) if(did[e]==1) V.push_back(uf[e]);\n\t\tsort(ALL(V));\n\t\tV.erase(unique(ALL(V)),V.end());\n\t\t\n\t\tll BSS=BS[x];\n\t\tFORR(e,V) BSS+=BS[e];\n\t\t\n\t\tQ[x]=C[i].first+BSS;\n\t\tFORR(e,V) Q[x]=min(Q[x],max(Q[e],C[i].first)+BSS-BS[e]);\n\t\tFORR(e,V) uf(e,x);\n\t\tQ[uf[x]]=Q[x];\n\t\tBS[uf[x]]=BSS;\n\t\t\n\t}\n\tcout<<Q[uf[0]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#define N 100005\nusing namespace std;\nint a[N],b[N],c[N],d[N],e[N],g[N],f[N],m,n;long long h[N],x;\ninline bool cmp(int u,int v){return g[a[u]]==g[a[v]]?a[u]<a[v]:g[a[u]]<g[a[v]];}\nint find(int u)\n{\n\tif(!f[u])return u;\n\tint v=find(f[u]);\n\treturn e[u]=max(e[u],e[f[u]]),f[u]=v;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),x=0x7fffffffffffffffll;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%lld\",g+i,h+i),g[i]=g[i]<h[i]?0:g[i]-h[i];\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",a+i,b+i),c[i]=i,g[a[i]]<g[b[i]]||g[a[i]]==g[b[i]]&&a[i]<b[i]?a[i]^=b[i]^=a[i]^=b[i]:0;\n\tsort(c+1,c+m+1,cmp);\n\tfor(int i=1,u;i<=m;i++)if(a[c[i]]!=(u=find(b[c[i]])))e[u]=max((long long)e[u],g[a[c[i]]]-h[u]),f[u]=a[c[i]],h[a[c[i]]]+=h[u];\n\tfor(int i=1,u;i<=n;i++)u=find(i),x=min(x,max(g[i],e[i])+h[u]);\n\treturn 0*printf(\"%lld\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define PII pair<int, int>\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\nusing namespace std;\ntemplate<typename T> inline void gmax(T &x, T y){x = x > y ? x : y;}\ntemplate<typename T> inline void gmin(T &x, T y){x = x < y ? x : y;}\nconst int MAXN = 100010;\nint n, m;\nLL a[MAXN], b[MAXN], v[MAXN];\nint id[MAXN];\nvector<int> G[MAXN];\ninline bool cmp(const int &a, const int &b){return v[a] < v[b];}\nint f[MAXN];\ninline int find(int x){return f[x] == x ? f[x] : f[x] = find(f[x]);}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld%lld\", &a[i], &b[i]), v[i] = max(a[i] - b[i], 0LL), id[i] = i;\n\tsort(id + 1, id + n + 1, cmp);\n\tfor(int i = 1; i <= m; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].PB(y);\n\t\tG[y].PB(x);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tint x = id[i];\n\t\tf[x] = x;\n\t\tLL tmp = v[x];\n\t\tfor(unsigned j = 0; j < G[x].size(); j++){\n\t\t\tint y = G[x][j];\n\t\t\tif(!f[y] || (y = find(y)) == x) continue;\n\t\t\tf[y] = x;\n\t\t\tb[x] += b[y];\n\t\t\tgmin(v[x], max(v[y], tmp) - b[y]); \n\t\t}\n\t\tv[x] += b[x];\n\t}\n\tprintf(\"%lld\\n\", v[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable : 4996)\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\n\tvoid init(int sz) {\n\t\tpar.resize(sz, -1);\n\t}\n\tint root(int pos) {\n\t\tif (par[pos] == -1) return pos;\n\t\tpar[pos] = root(par[pos]);\n\t\treturn par[pos];\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = root(u); v = root(v);\n\t\tif (u == v) return;\n\n\t\tpar[u] = v;\n\t}\n\tbool same(int u, int v) {\n\t\tif (root(u) == root(v)) return true;\n\t\treturn false;\n\t}\n};\n\nclass MergeTech {\npublic:\n\tvector<int> group;\n\tvector<pair<long long, int>> maxv;\n\tvector<vector<int>> G;\n\tvector<long long> cost, BB;\n\n\tvoid init(vector<long long> B) {\n\t\tgroup.resize(B.size(), 0);\n\t\tmaxv.resize(B.size(), make_pair(0, 0));\n\t\tG.resize(B.size(), vector<int>(0, 0));\n\t\tcost = B;\n\t\tBB = B;\n\t\tfor (int i = 0; i < B.size(); i++) { group[i] = i; maxv[i] = make_pair(B[i], i); G[i].push_back(i); }\n\t}\n\tbool same(int u, int v) {\n\t\tif (group[u] == group[v]) return true;\n\t\treturn false;\n\t}\n\tvoid unite(int u, int v) {\n\t\tu = group[u];\n\t\tv = group[v]; if (G[u].size() < G[v].size()) swap(u, v);\n\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tgroup[G[v][i]] = u;\n\t\t\tmaxv[u] = max(maxv[u], make_pair(BB[G[v][i]], G[v][i]));\n\t\t\tG[u].push_back(G[v][i]);\n\t\t}\n\t\tG[v].clear();\n\t\tcost[u] += cost[v];\n\t\tcost[v] = 0;\n\t}\n\tlong long getval(int pos) {\n\t\tpos = group[pos];\n\t\treturn cost[pos];\n\t}\n\tlong long getmax(int pos) {\n\t\tpos = group[pos];\n\t\treturn maxv[pos].second;\n\t}\n};\n\nlong long N, M, A[1 << 17], B[1 << 17], U[1 << 17], V[1 << 17];\nlong long Subtree[1 << 17];\nvector<tuple<long long, int, int, int>> L;\nvector<int> Y[1 << 17];\nMergeTech UF1, UF2;\n\nint dfs(int pos, long long rem) {\n\tif (A[pos] > rem || B[pos] > rem || Subtree[pos] > rem) return 0;\n\t\n\tint ans = 0; if (Y[pos].size() == 0) ans = 1;\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tif (A[pos] > rem - Subtree[pos] + Subtree[Y[pos][i]] + B[pos]) continue;\n\n\t\tlong long val = rem - Subtree[pos] + Subtree[Y[pos][i]];\n\t\tif (A[pos] <= rem - Subtree[pos] + B[pos]) val += B[pos];\n\t\tans |= dfs(Y[pos][i], val);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &M);\n\tfor (int i = 0; i < N; i++) scanf(\"%lld%lld\", &A[i], &B[i]);\n\tfor (int i = 0; i < M; i++) { scanf(\"%lld%lld\", &U[i], &V[i]); U[i]--; V[i]--; }\n\tfor (int i = 0; i < M; i++) L.push_back(make_tuple(max(A[U[i]], A[V[i]]), max(U[i], V[i]), U[i], V[i]));\n\tsort(L.begin(), L.end());\n\tvector<long long>AA(N, 0); for (int i = 0; i < N; i++) AA[i] = A[i];\n\tvector<long long>BB(N, 0); for (int i = 0; i < N; i++) BB[i] = B[i];\n\t\n\tUF1.init(AA); UF2.init(BB);\n\tfor (int i = 0; i < L.size(); i++) {\n\t\tint r1 = get<2>(L[i]), r2 = get<3>(L[i]);\n\t\tif (UF1.same(r1, r2) == false) {\n\t\t\tif (make_pair(A[r1], r1) > make_pair(A[r2], r2)) {\n\t\t\t\tint t = UF1.getmax(r2);\n\t\t\t\tY[r1].push_back(r2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = UF1.getmax(r1);\n\t\t\t\tY[r2].push_back(r1);\n\t\t\t}\n\t\t\tUF1.unite(get<2>(L[i]), get<3>(L[i]));\n\t\t}\n\t}\n\n\tvector<pair<long long, int>> I;\n\tfor (int i = 0; i < N; i++) I.push_back(make_pair(A[i], i));\n\tsort(I.begin(), I.end());\n\n\tfor (int i = 0; i < I.size(); i++) {\n\t\tfor (int j : Y[I[i].second]) {\n\t\t\tUF2.unite(I[i].second, j);\n\t\t}\n\t\tSubtree[I[i].second] = UF2.getval(I[i].second);\n\t}\n\n\tdfs(I[I.size() - 1].second, 1000005500);\n\n\tlong long cl = 0, cr = (1LL << 60), cm, minx = (1LL << 60);\n\tfor (int i = 0; i < 70; i++) {\n\t\tcm = (cl + cr) / 2;\n\t\tint J = dfs(I[I.size() - 1].second, cm);\n\t\tif (J == 1) { minx = min(minx, cm); cr = cm; }\n\t\telse { cl = cm; }\n\t}\n\tcout << minx << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nint rt[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nstruct pt{int a,id;}w[MAXN];\nint n,m,A[MAXN],B[MAXN];\nbool cmp(pt n1,pt n2){return n1.a<n2.a;}\nvector<int> vec[MAXN];\nLL sum[MAXN];\nvoid init(int x)\n{\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)init(a[k].y),sum[x]+=sum[a[k].y];\n}\nLL ans;\nvoid cal(int x,LL ls1,LL ls2)//留下来的速度  上面会用掉的速度 \n{\n\tLL down=sum[x]-B[x];//不考虑我走完要多少速度 \n\tLL nx=max(ls1,(LL)max(A[x],B[x]));\n\tLL canuse=min(down,nx-max(A[x],B[x]));\n\tans=min(ans,nx-ls1+down-canuse+ls2);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tcal(y,nx-B[x]-canuse,down-sum[y]+ls2+nx-ls1-canuse);\n\t}\n}\nint ri[MAXN];\nbool is[MAXN];\nint main()\n{\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)w[i].a=A[i]=read(),B[i]=read(),w[i].id=i;\n\tsort(w+1,w+1+n,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(y);vec[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tis[w[i].id]=true; \n\t\tfor(int j=0;j<vec[w[i].id].size();j++)\n\t\t{\n\t\t\tint x=vec[w[i].id][j];\n\t\t\tint p=findrt(w[i].id),q=findrt(x);\n\t\t\tif(p!=q&&is[q])ins(w[i].id,q),ri[q]++,rt[q]=p;\n\t\t}\n\t}\n//\tfor(int i=1;i<=len;i++)printf(\"YES %d %d\\n\",a[i].x,a[i].y);\n\tint root;\n\tfor(int i=1;i<=n;i++)if(!ri[i])root=i;\n\tinit(root);\n\tans=(1LL<<63-1);\n\tcal(root,0,0);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define PII pair<int, int>\n#define MP make_pair\n#define PB push_back\n#define FF first\n#define SS second\nusing namespace std;\ntemplate<typename T> inline void gmax(T &x, T y){x = x > y ? x : y;}\ntemplate<typename T> inline void gmin(T &x, T y){x = x < y ? x : y;}\nconst int MAXN = 100010;\nint n, m;\nLL a[MAXN], b[MAXN], v[MAXN];\nint id[MAXN];\nvector<int> G[MAXN];\ninline bool cmp(const int &a, const int &b){return v[a] < v[b];}\nint f[MAXN];\ninline int find(int x){return f[x] == x ? f[x] : f[x] = find(f[x]);}\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld%lld\", &a[i], &b[i]), v[i] = max(a[i] - b[i], 0LL), id[i] = i;\n\tsort(id + 1, id + n + 1, cmp);\n\tfor(int i = 1; i <= m; i++){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].PB(y);\n\t\tG[y].PB(x);\n\t}\n\tfor(int i = 1; i <= n; i++){\n\t\tint x = id[i];\n\t\tf[x] = x;\n\t\tLL tmp = v[x];\n\t\tfor(unsigned j = 0; j < G[x].size(); j++){\n\t\t\tint y = G[x][j];\n\t\t\tif(f[y] || (y = find(y)) == x) continue;\n\t\t\tf[y] = x;\n\t\t\tb[x] += b[y];\n\t\t\tgmin(v[x], max(v[y], tmp) - b[y]); \n\t\t}\n\t\tv[x] += b[x];\n\t}\n\tprintf(\"%lld\\n\", v[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 100233;\nint n, m, fa[N], p[N], visit[N];\nll a[N], b[N], f[N], s[N];\nvector<int> G[N], E[N];\nint F(int x) {while (x != fa[x]) x = fa[x] = fa[fa[x]]; return x;}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &a[i], &b[i]);\n  }\n  for (int i = 1, x, y; i <= m; i++) {\n    scanf(\"%d%d\", &x, &y);\n    G[x].push_back(y);\n    G[y].push_back(x);\n  }\n  for (int i = 1; i <= n; i++) {\n    fa[i] = p[i] = i;\n  }\n  sort(p + 1, p + 1 + n, [&](const int &x, const int &y){return a[x] - b[x] < a[y] - b[y];});\n  for (int i = 1; i <= n; i++) {\n    int x = p[i], z;\n    visit[x] = 1;\n    s[x] = b[x];\n    for (auto y : G[x]) if (visit[y]) {\n      if ((z = F(y)) == x) continue;\n      fa[z] = x;\n      s[x] += s[z];\n      E[x].push_back(z);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    int x = p[i];\n    if (E[x].empty()) f[x] = max(a[x], b[x]);\n    else f[x] = 1ll << 60;\n    for (auto y : E[x]) {\n      f[x] = min(f[x], max(f[y], a[x] - b[x]) + s[x] - s[y]);\n    }\n  }\n  printf(\"%lld\\n\", f[p[n]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' && ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1e5 + 5;\nstruct Node { int a, b, c, id; } t[MAXN];\nstruct Edges { int to, next; } e[MAXN * 2];\nvector <int> G[MAXN];\nint head[MAXN], tot;\nint fa[MAXN];\nint vis[MAXN], sum[MAXN], f[MAXN];\n\ninline void addedge(int from, int to) {\n  e[++tot] = (Edges){to, head[from]};\n  head[from] = tot;\n  e[++tot] = (Edges){from, head[to]};\n  head[to] = tot;\n}\ninline void Addedge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nint Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); }\ninline bool cmp(Node x, Node y) { return x.c < y.c; }\ninline bool cmpp(Node x, Node y) { return x.id < y.id; }\n\nvoid Dfs(int now, int fa) {\n  sum[now] = t[now].b;\n  for (auto i : G[now])\n    if (i != fa)\n      Dfs(i, now), sum[now] += sum[i];\n  f[now] = sum[now] + t[now].c;\n  for (auto i : G[now])\n    if (i != fa)\n      f[now] = min(f[now], sum[now] - sum[i] + max(f[i], t[now].c));\n}\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n, m; read(n), read(m);\n  for (RI i = 1; i <= n; ++i)\n    read(t[i].a), read(t[i].b), t[i].c = max(t[i].a - t[i].b, 0), t[i].id = i;\n  sort(t + 1, t + 1 + n, cmp);\n  for (RI i = 1, x, y; i <= m; ++i)\n    read(x), read(y), addedge(x, y);\n  for (RI i = 1; i <= n; ++i) fa[i] = i;\n  for (RI i = 1; i <= n; ++i) {\n    vis[t[i].id] = 1;\n    for (RI j = head[t[i].id]; j; j = e[j].next)\n      if (vis[e[j].to]) {\n        int ft = Find(e[j].to);\n        if (t[i].id != ft) {\n          fa[ft] = t[i].id;\n          Addedge(t[i].id, ft);\n        }\n      }\n  }\n  int root = t[n].id;\n  sort(t + 1, t + 1 + n, cmpp);\n  Dfs(root, 0);\n  printf(\"%d\\n\", f[root]);\n\n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long v,nxt;\n};\nnode edge[200001];\nstruct reads\n{\n\tlong long num,data;\n\tbool operator < (const reads &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nreads t[100001];\nlong long n,m,a[100001],b[100001],head[100001],len,rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].nxt=head[x];\n\thead[x]=len;\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tt[i].num=i;\n\t\tt[i].data=a[i];\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(t+1,t+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=head[t[i].num];j>0;j=edge[j].nxt)\n\t\t\tif (a[t[i].num]>=a[edge[j].v]&&find(t[i].num)!=find(edge[j].v))\n\t\t\t\tunionn(edge[j].v,t[i].num);\n\t}\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nll A[101010],B[101010];\npair<ll,int> C[101010];\nvector<int> E[101010];\nll BS[101010];\nll Q[101010];\nint did[101010];\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank;\n\tUF() {rank=vector<int>(um,0); for(int i=0;i<um;i++) par.push_back(i);}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<500000> uf;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,N) {\n\t\tcin>>A[i]>>B[i];\n\t\tC[i]={max(A[i]-B[i],0LL),i};\n\t\tBS[i]=B[i];\n\t}\n\tFOR(i,M) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tsort(C,C+N);\n\tFOR(i,N) {\n\t\tx=C[i].second;\n\t\tdid[x]=1;\n\t\tvector<int> V;\n\t\tFORR(e,E[x]) if(did[e]==1) V.push_back(uf[e]);\n\t\tsort(ALL(V));\n\t\tV.erase(unique(ALL(V)),V.end());\n\t\t\n\t\tvector<ll> BSV;\n\t\tll BSS=BS[x];\n\t\tFORR(e,V) BSS+=BS[e];\n\t\tQ[x]=C[i].first+BSS;\n\t\tFORR(e,V) Q[x]=min(Q[x],max(Q[e],C[i].first)+BSS-BS[e]);\n\t\t\n\t\tFORR(e,V) {\n\t\t\tBS[e]=BS[x]=BS[x]+BS[e];\n\t\t\tQ[e]=Q[x];\n\t\t\tuf(e,x);\n\t\t}\n\t}\n\tcout<<Q[uf[0]]<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m;\nint a[maxn],b[maxn],id[maxn];\nstruct edge{int v,nxt;}e[maxn<<1];\nint head[maxn],ecnt=0;\nvoid add(int u,int v)\n{\n\te[++ecnt]=(edge){v,head[u]},head[u]=ecnt;\n\te[++ecnt]=(edge){u,head[v]},head[v]=ecnt;\n}\nbool cmp(const int &x,const int &y){return a[x]<a[y];}\nvector<int>G[maxn];\nint fa[maxn];\nlong long sum[maxn],dp[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dfs(int u,int pre)\n{\n\tsum[u]+=b[u];\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t\tsum[u]+=sum[v];\n\t}\n\tdp[u]=sum[u]+a[u];\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max(dp[v],a[u]*1LL));\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),a[i]=max(0,a[i]-b[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=id[i];\n\t\tfor(auto v:G[u])\n\t\tif(find(u)!=find(v))\n\t\t{\n\t\t\tadd(u,v);\n\t\t\tfa[find(u)]=find(v);\n\t\t}\n\t}\n\tdfs(id[n],0);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ninline void write(LL x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x);putchar(' ');}\ninline void pr2(LL x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nint rt[MAXN];\nint findrt(int x){return rt[x]==x?rt[x]:rt[x]=findrt(rt[x]);}\nstruct edge{int x,y,next;}a[2*MAXN];int len,last[MAXN];\nvoid ins(int x,int y){len++;a[len].x=x;a[len].y=y;a[len].next=last[x];last[x]=len;}\nstruct pt{int a,id;}w[MAXN];\nint n,m,A[MAXN],B[MAXN];\nbool cmp(pt n1,pt n2){return n1.a<n2.a;}\nvector<int> vec[MAXN];\nLL sum[MAXN];\nvoid init(int x)\n{\n\tsum[x]=B[x];\n\tfor(int k=last[x];k;k=a[k].next)init(a[k].y),sum[x]+=sum[a[k].y];\n}\nLL ans;\nvoid cal(int x,LL ls1,LL ls2)//留下来的速度  上面会用掉的速度 \n{\n\tif(x==10)\n\t{\n\t\tint gg;\n\t\tgg++;\n\t}\n\tLL down=sum[x]-B[x];//不考虑我走完要多少速度 \n\tLL nx=max(ls1,(LL)max(A[x],B[x]));\n\tLL canuse=min(down,nx-max(A[x],B[x]));//可以提供给子树的 \n\tans=min(ans,nx-ls1+down-canuse+ls2);\n\tfor(int k=last[x];k;k=a[k].next)\n\t{\n\t\tint y=a[k].y;\n\t\tcal(y,nx-B[x]-min(canuse,down-sum[y]),down-sum[y]+ls2+nx-ls1-min(canuse,down-sum[y]));\n\t}\n}\nint ri[MAXN];\nbool is[MAXN];\nint main()\n{\n//\tfreopen(\"subtask_1_09.in\",\"r\",stdin);\n//\tfreopen(\"rescue.out\",\"w\",stdout);\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)w[i].a=A[i]=read(),B[i]=read(),w[i].id=i;\n\tsort(w+1,w+1+n,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tvec[x].push_back(y);vec[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)rt[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tis[w[i].id]=true; \n\t\tfor(int j=0;j<vec[w[i].id].size();j++)\n\t\t{\n\t\t\tint x=vec[w[i].id][j];\n\t\t\tint p=findrt(w[i].id),q=findrt(x);\n\t\t\tif(p!=q&&is[q])ins(w[i].id,q),ri[q]++,rt[q]=p;\n\t\t}\n\t}\n//\tfor(int i=1;i<=len;i++)printf(\"YES %d %d\\n\",a[i].x,a[i].y);\n\tfor(int i=1;i<=n;i++)pr1(A[i]),pr2(B[i]);\n\tint root;\n\tfor(int i=1;i<=n;i++)if(!ri[i])root=i;\n\tinit(root);\n\tans=(1LL<<63-1);\n\tcal(root,0,0);\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long ll;\nint limit[N] , bonus[N] , need[N];\n\nint n , m;\nvector<int> adj[N];\n\nstruct CmpLimit { \n    bool operator() (int x , int y) const {return limit[x] < limit[y];}\n};\n\nint par[N] , *unlocked = par , init = 0;\nll money[N];\nset<int , CmpLimit> out[N];\n\nstruct Info {\n    int x , cost;\n    Info() {}\n    Info(int x , int cost) : x(x) , cost(cost) {}\n    friend bool operator< (Info a , Info b)  {return a.cost < b.cost;}\n};\n\nset<Info> point;\nvoid modifycost(int pos , int val) {\n    if(unlocked[pos] || need[pos] <= val)\n        return;\n    point.erase(Info(pos , need[pos]));\n    point.insert(Info(pos , need[pos] = val));\n}\nint find(int x) {return x == par[x] ? x : par[x] = find(par[x]);}\nvoid merge(int x , int y) {\n    x = find(x) , y = find(y);\n    if(x == y) return ;\n\n    if(out[x].size() > out[y].size()) swap(x , y);\n    for(auto t : out[x]) if(find(t) != y) out[y].insert(t);\n    out[x].clear();\n    par[x] = y , money[y] += money[x] , money[x] = 0;\n\n}\nvoid unlock(int x) {\n    par[x] = x;\n    money[x] = bonus[x];\n    point.erase(Info(x , need[x]));\n\n    for(auto y : adj[x]) {\n        int p = find(x);\n        if(find(y) == p) continue;\n\n        if(unlocked[y]) merge(x , y);\n        else {\n            if(money[p] + init >= limit[y]) \n                unlock(y);\n            else \n                out[p].insert(y);  \n        }\n    }\n    x = find(x);\n    while(out[x].size()) {\n        int t = *out[x].begin();\n        if(find(t) == x) {\n            out[x].erase(out[x].begin());\n            continue;\n        }\n        if(money[x] + init >= limit[t]) {\n            out[x].erase(out[x].begin());\n            unlock(t);\n            x = find(x);\n            continue;\n        }\n        break;\n    }\n    for(auto it = out[x].begin() ; it != out[x].end() ; ) {\n        int t = *it;\n        if(find(t) == x)\n            it = out[x].erase(it);\n        else\n            modifycost(t , limit[t] - money[x]) , ++it;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\" , &n , &m);\n    for(int i = 1 ; i <= n ; ++i) {\n        scanf(\"%d %d\" , limit + i , bonus + i);\n        limit[i] -= bonus[i] , need[i] = max(0 , limit[i]);\n        point.insert(Info(i , need[i]));\n    }\n    for(int i = 1 , x , y; i <= m ; ++i) {\n        scanf(\"%d %d\" , &x , &y);\n        adj[x].push_back(y) , adj[y].push_back(x);\n    }\n    while(point.size()) {\n        int x = point.begin()->x , c = point.begin()->cost;\n        init = max(init , c);\n        unlock(x);\n    }\n    ll ans = init;\n    for(int i = 1 ; i <= n ; ++i) ans += bonus[i];\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  vector<ll> sum;\n  UnionFind(int n) : v(n, -1), sum(n,0){}\n  void init(){ for(int i = 0;i < (int)v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    sum[x] += sum[y];\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nll N,M;\nll A[100010],B[100010];\nvector<ll> g[100010];\nll X[100010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N>>M;\n  vector<ll> ord;\n  rep(i,N){\n    cin>>A[i]>>B[i];\n    ord.push_back(i);\n  }\n  rep(i,M){\n    ll a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  sort(all(ord),[=](const ll& a,const ll& b){ return A[a]-B[a] < A[b]-B[b]; });\n  UnionFind uf(N);\n  rep(i,N){\n    uf.sum[i]=B[i];\n    X[i]=INF;\n  }\n\n  for(ll v : ord){\n    X[v]=max(0LL,A[v]-B[v]);\n    for(ll nv : g[v]){\n      ll f=uf.find(nv);\n      if(X[f]==INF)continue;\n      ll tot=uf.sum[f]+X[f];\n      minch(X[v],X[f]+max(0LL,A[v]-B[v]-tot));\n    }\n    for(ll nv : g[v]){\n      ll f=uf.find(nv);\n      if(X[f]==INF)continue;\n      uf.unite(v,nv);\n    }\n    ll f=uf.find(v);\n    X[f]=X[v];\n  }\n  cout<<X[uf.find(0)]+uf.sum[uf.find(0)]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <typeinfo>\n#include <unordered_set>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REPD(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\nclass UnionFind{\n  int num_components;\n  std::vector<int> parent;\n  std::vector<int> weight;\n  std::vector<int> rank;\npublic:\n  UnionFind(int N) : num_components(N),\n                     parent(std::vector<int>(N)),\n                     weight(std::vector<int>(N, 1)),\n                     rank(std::vector<int>(N, 0)){\n    for(int i = 0; i < N; i++) parent[i] = i;\n  }\n  \n  int find(int x){\n    if(x == parent[x]) return x;\n    else return parent[x] = find(parent[x]);\n  }\n  \n  int size(int x){\n    return weight[find(x)];\n  }\n\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n    \n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    num_components--;\n    if(rank[x] < rank[y]){\n      weight[y] += weight[x];\n      parent[x] = y;\n    }else{\n      weight[x] += weight[y];\n      parent[y] = x;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\n  \n  int count(){\n    return num_components;\n  }\n};\n\nint main(int argc, char *argv[])\n{\n  int N, M;\n  cin >> N >> M;\n  vector<vector<int>> G(N);\n  vector<ll> A(N);\n  vector<ll> B(N);\n  vector<pair<pair<ll, ll>, int>> vs;\n  REP(i, N) {\n    cin >> A[i] >> B[i];\n    vs.push_back(make_pair(make_pair(A[i], B[i]), i));\n  }\n  sort(ALL(vs));\n\n  REP(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  UnionFind uf(N);\n  vector<ll> sum(N, -1);\n  vector<ll> dp(N, -1);\n\n  REP(i, N) {\n    int v = vs[i].second;\n\n    vector<int> cs;\n    for (const auto &w : G[v]) {\n      int wc = uf.find(w);\n      if (sum[wc] < 0) continue;\n      cs.push_back(wc);\n    }\n    sort(ALL(cs));\n    cs.erase(unique(ALL(cs)), cs.end());\n\n    ll csum = 0;\n    for (int c : cs) {\n      csum += sum[c];\n    }\n\n    if (int(cs.size()) == 0) {\n      dp[uf.find(v)] = max(A[v], B[v]);\n      sum[uf.find(v)] = B[v];\n    } else {\n      ll res = csum + max(A[v], B[v]);\n      for (int c : cs) {\n        res = min(res, max(A[v], dp[c] + B[v]) + csum - sum[c]);\n      }\n\n      for (int w : G[v]) {\n        int wc = uf.find(w);\n        if (sum[wc] < 0) continue;\n        uf.unite(v, wc);\n      }\n      sum[uf.find(v)] = csum + B[v];\n      dp[uf.find(v)] = res;\n    }\n  }\n  cout << dp[uf.find(vs[N - 1].second)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nint a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\nll dfs(int v)\n{\n    ll mx = 0, summ = 0;\n    for (auto u : tree[v])\n    {\n        ll c = dfs(u);\n        if (c > mx) mx = c;\n        summ += c;\n    }\n    summ += b[v];\n    if (mx + b[v] < a[v]) summ += a[v] - mx - b[v];\n    return summ;\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    //cout << root << endl;\n    //for (int i = 0; i < n; i++)\n    //    for (auto v : tree[i]) cout << i << \" \" << v << endl;\n    cout << dfs(root);\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    if (mol[u].size()==1){\n        for (auto y : g[u]) q.push({y,u});\n    }\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)1e9+10;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1){\n                continue;\n            }\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(u1,v1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        \n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n            else if (mol[par[i]].size()!=n){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]!=-1 && z!=par[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define maxn 1000010\n#define ll long long\nusing namespace std;\nint n,m,x,y,a[maxn],b[maxn],c[maxn],f[maxn],vis[maxn];\nll ans[maxn],sum[maxn];\nvector<int>vec[maxn];\nbool cmp(int x,int y){return a[x]-b[x]<a[y]-b[y];}\nint find(int x){return f[x]==x?x:f[x]=find(f[x]);}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tc[i]=f[i]=i;\n\t\tans[i]=max(0,a[i]-b[i]);\n\t\tsum[i]=b[i];\n\t}\n\tfor(register int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tvec[x].push_back(y);\n\t\tvec[y].push_back(x);\n\t}\n\tsort(c+1,c+n+1,cmp);\n\tfor(register int i=1;i<=n;i++){\n\t\tint u=c[i];\n\t\tvis[u]=1;\n\t\tfor(auto v:vec[u]){\n\t\t\tif(!vis[v])continue;\n\t\t\tint x=find(u),y=find(v);\n\t\t\tif(x!=y){\n\t\t\t\tf[y]=x;\n\t\t\t\tsum[x]+=sum[y];\n\t\t\t\tans[x]=min(ans[x],ans[y]+max(0ll,a[x]-b[x]-ans[y]-sum[y]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans[find(1)]+sum[find(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,u,v,a[100001],b[100001],c[100001],s[100001],f[100001],sr[100001],d[100001];\nvector<long long>x[100001],y[100001];\nbool bo[100001];\ninline long long read()\n{\n    long long sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(long long x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(long long x,long long y)\n{\n\treturn c[x]<c[y];\n}\ninline long long find(long long x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(long long u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register long long i=0;i<y[u].size();++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register long long i=0;i<y[u].size();++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register long long i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u].push_back(v);\n\t\tx[v].push_back(u);\n\t}\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\tlong long u=d[i];\n\t\tfor (register long long j=0;j<x[u].size();++j)\n\t\t{\n\t\t\tlong long v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u].push_back(vv);\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\n\nusing std::max;\nusing std::min;\nusing std::sort;\n\ntypedef long long LL;\ntypedef double Doub;\n\nconst int sta(0), deb(0);\n\nstruct Read\n{\n    inline int operator ~()\n    {\n        int c, s(0);\n        for(; !isdigit(c = getchar());)\n            s = c == '-';\n        int r(c & 15);\n        for(; isdigit(c = getchar());)\n            r = r * 10 + (c & 15);\n        return s? -r: r;\n    }\n\n    inline Read &operator >>(int& a)\n    {return a = ~*this, *this;}\n} read;\n\ntypedef std::vector<int> VI;\n\nconst int mxN(100233);\n\nint n, m, a[mxN], b[mxN], val[mxN], no[mxN];\nVI vs[mxN];\n\ninline void init()\n{\n    if(sta == 1 || sta == 2)\n        freopen(\"rescue.in\", \"r\", stdin);\n    if(sta == 1)\n        freopen(\"rescue.out\", \"w\", stdout);\n\n    read >> n >> m;\n    for(int i(1); i <= n; ++i)\n    {\n        read >> a[i] >> b[i];\n        val[i] = max(0, a[i]-b[i]);\n        no[i] = i;\n    }\n    for(int _(m); _--;)\n    {\n        int u, v;\n        read >> u >> v;\n        vs[u].push_back(v);\n        vs[v].push_back(u);\n    }\n}\n\ninline bool cmp(int i, int j)\n{   return val[i] < val[j];}\n\nint fat[mxN];\n\nint getF(int x) {return fat[x]!=x? fat[x] = getF(fat[x]): x;}\n\nint main()\n{\n    init();\n\n    sort(no+1, no+n+1, cmp);\n    static LL sB[mxN], g[mxN];\n    for(int _(1); _<=n; ++_)\n    {\n        int u(no[_]);\n        fat[u] = u;\n        VI sons;\n        for(unsigned i(0); i<vs[u].size(); ++i)\n            if(fat[vs[u][i]])\n                sons.push_back(getF(vs[u][i]));\n        sort(sons.begin(), sons.end());\n        sons.resize(unique(sons.begin(), sons.end())-sons.begin());\n        if(deb)\n            for(unsigned i(0); i<sons.size(); ++i)\n                printf(\"%d--%d\\n\", u, sons[i]);\n        LL d(b[u]+val[u]);\n        for(unsigned i(0); i<sons.size(); ++i)\n        {\n            int v(sons[i]);\n            sB[u] += sB[v];\n            if(deb && max((LL)a[u], b[u] + g[v])-sB[v] < d)\n                printf(\"%d->%d %lld\\n\", u, v,  max((LL)a[u], b[u] + g[v])-sB[v]);\n            d = min(d, max((LL)a[u], b[u] + g[v])-sB[v]);\n            fat[v] = u;\n        }\n        g[u] = sB[u] + d;\n        sB[u] += b[u];\n        if(deb)\n            printf(\"%lld ; %lld\\n\", sB[u], g[u]);\n    }\n\n    printf(\"%lld\\n\", g[no[n]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 100054, M = N * 2;\n\nint V, E, Es = 0;\nint a[N], d[N], o[N];\nint to[M], first[N], next[M];\nint p[N];\nbool used[N];\nll D[N], f[N];\n\ninline int doz(int x) {return ~(x >> 31) & x;}\ninline void down(ll &x, const ll y) {x > y ? x = y : 0;}\ninline ll max(const ll x, const ll y) {return x < y ? y : x;}\nint ancestor(int x) {return p[x] == x ? x : (p[x] = ancestor(p[x]));}\n\ninline void addedge(int u, int v) {\n\tto[++Es] = v, next[Es] = first[u], first[u] = Es;\n\tto[++Es] = u, next[Es] = first[v], first[v] = Es;\n}\n\nint main() {\n\tint i, j, u, v; ll c;\n\tscanf(\"%d%d\", &V, &E);\n\tfor (i = 1; i <= V; ++i) scanf(\"%d%d\", a + i, d + i), a[i] = doz(a[i] - d[i]), D[i] = d[i];\n\tfor (i = 0; i < E; ++i) scanf(\"%d%d\", &u, &v), addedge(u, v);\n\tstd::iota(p, p + (V + 1), 0), std::iota(o, o + V, 1);\n\tstd::sort(o, o + V, [] (const int x, const int y) {return a[x] < a[y];});\n\tfor (i = 0; i < V; ++i) {\n\t\tused[u = o[i]] = true, c = a[u];\n\t\tfor (j = first[u]; j; j = next[j])\n\t\t\tif (used[to[j]] && (v = ancestor(to[j])) != u)\n\t\t\t\tp[v] = u, D[u] += D[v], down(c, max(f[v], a[u]) - D[v]);\n\t\tf[u] = D[u] + c;\n\t}\n\tprintf(\"%lld\\n\", f[u]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long v,nxt;\n};\nnode edge[200001];\nstruct reads\n{\n\tlong long num,data;\n\tbool operator < (const reads &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nreads t[100001];\nlong long n,m,a[100001],b[100001],head[100001],len,rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].nxt=head[x];\n\thead[x]=len;\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tt[i].num=i;\n\t\tt[i].data=a[i];\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(t+1,t+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tfor (int j=head[t[i].num];j>0;j=edge[j].nxt)\n\t\t\tif (a[t[i].num]>a[edge[j].v]&&find(t[i].num)!=find(edge[j].v))\n\t\t\t\tunionn(edge[j].v,t[i].num);\n\t}\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\n\nint n, m;\nint a[N], b[N];\nint par[N];\nbool vis[N];\nlong long sum[N], res[N];\nvector<int> G[N];\n\nint find(int u) { return u == par[u] ? u : par[u] = find(par[u]); }\n\nvoid join(int u, int v) { par[find(u)] = find(v); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tpar[i] = i, sum[i] = b[i], res[i] = max(a[i], b[i]);\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tvector<int> vec;\n\tfor (int i = 1; i <= n; ++i) vec.push_back(i);\n\tsort(vec.begin(), vec.end(), [&] (int x, int y) {\n\t\treturn a[x] - b[x] < a[y] - b[y];\n\t});\n\tfor (auto i : vec) {\n\t\tset<int> s;\n\t\tfor (auto j : G[i]) {\n\t\t\tif (vis[j]) s.insert(find(j));\n\t\t}\n\t\tfor (auto j : s) {\n\t\t\tjoin(j, i), sum[i] += sum[j];\n\t\t}\n\t\tif (s.size()) {\n\t\t\tlong long mn = 1e18;\n\t\t\tfor (auto j : s) {\n\t\t\t\tmn = min(mn, max(0LL + a[i] - b[i], res[j]) + sum[i] - sum[j]);\n\t\t\t}\n\t\t\tres[i] = mn;\n\t\t}\n\t\tvis[i] = 1;\n\t}\n\tcout << res[find(vec.back())];\n}"
  },
  {
    "language": "C++",
    "code": "#include\t<iostream>\n#include\t<vector>\n#include\t<sstream>\n#include\t<iomanip>\n#include\t<algorithm>\n\nusing namespace std;\n\n#define\tMaxN 100000\n\nlong\tA[ MaxN ];\nlong\tB[ MaxN ];\nlong\tC[ MaxN ];\nint\t\tP[ MaxN ];\nlong\tF[ MaxN ];\nlong\tS[ MaxN ];\nvector< int >\twEdges[ MaxN ];\n\nint\nGet( int x ) {\n    return ( x == P[ x ] ) ? x : P[ x ] = Get( P[ x ] );\n}\n\nvoid\nMain() {\n\tint\tN;\tcin >> N;\n\tint\tM;\tcin >> M;\n\n\tint\twSortedIndex[ MaxN ];\n\tfor ( auto i = 0; i < N; i++ ) {\n        cin >> A[ i ] >> B[ i ];\n        C[ i ] = max( A[ i ] - B[ i ], long( 0 ) );\n        wSortedIndex[ i ] = i;\n        P[ i ] = i;\n        S[ i ] = B[ i ];\n        F[ i ] = C[ i ];\n    }\n    auto\twRoot = distance( C, max_element( C, C+ N ) );\n\n\tfor ( auto i = 0; i < M; i++ ) {\n\t\tint\twU;\tcin >> wU;\twU--;\n\t\tint\twV;\tcin >> wV;\twV--;\n\t\twEdges[ wU ].emplace_back( wV );\n\t\twEdges[ wV ].emplace_back( wU );\n\t}\n\t\n    sort( wSortedIndex, wSortedIndex + N, []( int l, int r ) { return C[ l ] < C[ r ]; } );\n\t\n\tvector< bool >\twVisited( N, false );\n\n    for ( auto i = 0; i < N; i++ ) {\n        int u = wSortedIndex[ i ];\n        wVisited[ u ] = true;\n        for ( auto v : wEdges[ u ] ) {\n        \tif ( wVisited[ v ] ) {\n\t\t\t\tint x = Get( u );\n\t\t\t\tint\ty = Get( v );\n\t\t\t\tif ( x == y ) continue;\n\t\t\t\tP[ y ] = x; S[ x ] += S[ y ];\n\t\t\t\tF[ x ] = min( F[ x ], max( C[ u ] - S[ y ], F[ y ] ) );\n            }\n        }\n    }\n    cout << F[ wRoot ] + S[ wRoot ] << endl;\n}\n\nint\nmain() {\n\tMain();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing P = pair<ll, int>;\nusing Q = priority_queue<P, V<P>, greater<P>>;\n\nint n;\nVV<int> g;\nV<ll> lw, us;\n\nV<Q> gx;\n\nV<int> ig;\nVV<int> gi;\nvoid uf_init() {\n    ig = V<int>(n); gi = VV<int>(n);\n    for (int i = 0; i < n; i++) {\n        ig[i] = i; gi[i] = {i};\n    }\n}\n\nbool uf_same(int a, int b) {\n    return ig[a] == ig[b];\n}\n\nvoid uf_merge(int a, int b) {\n    if (uf_same(a, b)) return;\n    int x = ig[a], y = ig[b];\n    if (gi[x].size() < gi[y].size()) swap(x, y);\n    for (int j: gi[y]) {\n        ig[j] = x;\n    }\n    gi[x].insert(gi[x].end(), gi[y].begin(), gi[y].end());\n    gi[y].clear();\n\n    us[x] += us[y];\n    us[y] = 0;\n\n    if (gx[x].size() < gx[y].size()) swap(gx[x], gx[y]);\n    while (gx[y].size()) {\n        gx[x].push(gx[y].top()); gx[y].pop();\n    }\n}\n\nll ans;\nV<bool> vis;\nQ que;\n\nvoid on(int p) {\n    vis[p] = true;\n    for (int d: g[p]) {\n        if (vis[d]) {\n            uf_merge(p, d);\n        }\n    }\n    int x = ig[p];\n    while (gx[x].size()) {\n        auto tp = gx[x].top();\n        if (vis[tp.second]) {\n            gx[x].pop();\n            continue;\n        }\n        if (tp.first <= ans+us[x]) {\n            on(tp.second);\n        } else {\n            que.push(P(tp.first - us[x], tp.second));\n        }\n        break;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int m;\n    cin >> n >> m;\n    g = VV<int>(n);\n    lw = V<ll>(n); us = V<ll>(n);\n    ll off = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> lw[i] >> us[i]; lw[i] -= us[i];\n        off += us[i];\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        g[a].push_back(b); g[b].push_back(a);\n    }\n    uf_init();\n\n    gx = V<Q>(n);\n    for (int i = 0; i < n; i++) {\n        for (int d: g[i]) {\n            gx[i].push(P(lw[d], d));\n        }\n    }\n    vis = V<bool>(n);\n\n    for (int i = 0; i < n; i++) {\n        que.push(P(lw[i], i));\n    }\n\n    ans = 0;\n    while (que.size()) {\n        P tp = que.top(); que.pop();\n        int p = tp.second;\n        if (vis[p]) continue;\n        ans = max(ans, tp.first);\n        on(p);\n    }\n    cout << ans+off << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint n, m, z[100005], par[100005], tb, tc;\nlong long x[100005], y[100005], ta;\nvector< int > v[100005];\n\nint find(int a) {\n\treturn par[a] == a ? a : par[a] = find(par[a]);\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld\", &ta, x + i);\n\t\ty[i] = max(ta - x[i], 0LL);\n\t\tz[i] = i;\n\t}\n\tsort(z + 1, z + n + 1, [](const int &a, const int &b) {return y[a] < y[b];});\n\twhile (m--) {\n\t\tscanf(\"%d%d\", &tb, &tc);\n\t\tv[tb].push_back(tc);\n\t\tv[tc].push_back(tb);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ttb = z[i];\n\t\tpar[tb] = tb;\n\t\tta = y[tb];\n\t\tfor (int j: v[tb])\n\t\t\tif (par[j] && (j = find(j)) != tb) {\n\t\t\t\tpar[j] = tb;\n\t\t\t\tx[tb] += x[j];\n\t\t\t\ty[tb] = min(y[tb], max(y[j], ta) - x[j]);\n\t\t\t}\n\t\ty[tb] += x[tb];\n\t}\n\tprintf(\"%lld\\n\", y[z[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tll a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].a,&a[i].b);\n\tif(n==1) return printf(\"%lld\",a[1].a),0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e17,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e17;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mx,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define forup(i,l,r) for (register int i = l ; i <= r ; i += lowbit(i))\n#define fordown(i,id) for (register int i = id ; i ; i -= lowbit(i))\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&(-x))\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pr;\n\nconst ld inf = 2e18;\nconst int N = 3e6 + 10;\nconst int maxn = 300020;\nconst ll mod = 1e9 + 7;\nconst ull base = 907;\n\nstruct node{\n\tint next,to;\n};\nnode e[maxn * 2];\nint head[maxn],cnt;\t\nint n,m,dfstime;\n\nint a[maxn],b[maxn],vis[maxn],tag[maxn];\nint id,fa[maxn],p[maxn];\nll sum[maxn],sumf[maxn],f[maxn],mn[maxn];\n\nvoid clear(){\n\trep(i,1,n) head[i] = 0;\n\tcnt = 0;\n}\nvoid adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\nvoid init(){\n\trep(i,1,m){\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadde(x,y),adde(y,x);\n\t}\n}\nvoid findroot(int x){\n\tif ( max(0,a[id] - b[id]) < max(0,a[x] - b[x]) ) id = x;\n\tvis[x] = dfstime;\n\tfore(i,x){\n\t\tif ( vis[e[i].to] == dfstime || tag[e[i].to] ) continue;\n\t\tfindroot(e[i].to);\n\t}\t\n}\nll ans = 0;\nint solve(int x){\n\t++dfstime, id = x , findroot(x);\n\tint rt = id;\n\ttag[rt] = 1;\n\n\tsum[rt] = b[rt];\n\tf[rt] = max(a[rt] - b[rt],0);\n\tfore(i,rt){\n\t\tif ( tag[e[i].to] ) continue;\n\t\tint to = solve(e[i].to); //注意e[i].to不是下一块的根！\n\t\tsum[rt] += sum[to];\n\t\tf[rt] = min(f[rt],max(f[to],a[rt] - b[rt] - sum[to]));\n\t}\n\tif ( x == 1 ) ans = f[rt] + sum[rt];\n\treturn rt;\n}\nint getfa(int x){\n\treturn x == fa[x] ? x : fa[x] = getfa(fa[x]); \n}\nbool cmp(int x,int y){\n\treturn max(a[x] - b[x],0) < max(a[y] - b[y],0);\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,1,n) scanf(\"%d %d\",&a[i],&b[i]), p[i] = i , fa[i] = i;\n\tinit();\n\tsort(p + 1,p + n + 1,cmp);\n\trep(i,1,n){\n\t\tint x = p[i];\n\t\tsum[x] = b[x];\n\t\tf[x] = max(a[x] - b[x],0);\n\t\tfore(j,x){\n\t\t\tint to = getfa(e[j].to);\n\t\t\tif ( !tag[to] ) continue;\n\t\t\tsum[x] += sum[to];\n\t\t\tf[x] = min(f[x],max(f[to],a[x] - b[x] - sum[to]));\n\t\t\tfa[to] = x;\n\t\t}\n\t\ttag[x] = 1;\n\t}\n\t//solve(1);\n\tcout<<f[p[n]] + sum[p[n]]<<endl;\n//\trep(i,1,n) cout<<i<<\" : \"<<f[i]<<\" \"<<sum[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\n//UF\nint par1[100021];\nint rank1[100021];\n//n要素で初期化\nvoid init(int n){\n   for(int i=0;i<n;i++){\n       par1[i]=i;\n       rank1[i]=0;\n   }\n}\n//木の根を求める\nint find(int x){\n    if(par1[x] ==x){\n         return x;\n    }else{\n         return par1[x]=find(par1[x]);\n    }\n}\n//xとyの属する集合を併合\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n\n    if(rank1[x]<rank1[y]){\n         par1[x]=y;\n    }else{\n         par1[y]=x;\n         rank1[x]++;\n    }\n}\n//xとyが同じ集合に属するか否か\nbool same(int x,int y){\n     return find(x)==find(y);\n}\n\n\n\nint N,M;\nLL A[100001];\nLL B[100001];\nLL dp[100001];\nLL s[100001];\nbool used[100001];\n\nvector<int>G[100001];\ntypedef pair<LL,LL>P;\nvector<P>v;\nint main(){\n\tcin>>N>>M;\n\tREP(i,N){\n\t\tcin>>A[i]>>B[i];\n\t\tv.push_back(P(A[i],i));\n\t}\n\tsort(v.begin(),v.end());\n\tREP(i,M){\n\t\tint u,vv;\n\t\tcin>>u>>vv;\n\t\tu--;vv--;\n\t\tG[u].push_back(vv);\n\t\tG[vv].push_back(u);\n\t}\n\tinit(N+10);\n\tREP(i,N){\n\t\tdp[i]=max(A[i],B[i]);\n\t\ts[i]=B[i];\n\t\tused[i]=false;\n\t}\n\tREP(i,v.size()){\n\t\tint x=v[i].second;\n\t\tused[x]=true;\n\t\tvector<int>k;\n\t\tREP(j,G[x].size()){\n\t\t\tif(used[G[x][j]]==true){\n\t\t\t\tk.push_back(find(G[x][j]));\n\t\t\t}\n\t\t}\n\t\tsort(k.begin(),k.end());\n\t\tk.erase(unique(k.begin(), k.end()), k.end());\n\t\tLL c=0;\n\t\tREP(j,k.size()){\n\t\t\tc+=s[k[j]];\n\t\t\t//cout<<s[k[j]]<<\" c \"<<c<<endl;\n\t\t}\n\t\tif(k.size()==0)continue;\n\t\t//cout<<c<<endl;\n\t\t//要素のソート\n\t\t/*vector<P>u;\n\t\tREP(j,k.size()){\n\t\t\tu.push_back(P(dp[k[j]],s[k[j]]));\n\t\t}\n\t\tsort(u.begin(),u.end());*/\n\t\t//xが最後\n\t\tdp[x]=dp[x]+c;\n\t\ts[x]=s[x]+c;\n\t\tREP(j,k.size()){\n\t\t\t//j番目の要素が最後\n\t\t\tif(max(A[x],B[x])-B[x]>=dp[k[j]]){\n\t\t\t\t//x-->jで行ける\n\t\t\t\tdp[x]=min(dp[x],A[x]+c-s[k[j]]);\n\t\t\t}else{\n\t\t\t\tdp[x]=min(dp[x],dp[k[j]]+B[x]+(c-s[k[j]]));\n\t\t\t}\n\t\t}\n\t\t\n\t\t//unite\n\t\tREP(j,k.size()){\n\t\t\tunite(x,k[j]);\n\t\t}\n\t\t//cout<<\"x=\"<<x<<\" dp[x]=\"<<dp[x]<<\" s[x]=\"<<s[x]<<endl;\n\t\tdp[find(x)]=dp[x];\n\t\ts[find(x)]=s[x];\n\t}\n\tcout<<dp[find(0)]<<endl;\n\t/*REP(i,5){\n\t\tcout<<\"f\"<<dp[find(i)]<<endl;\n\t}*/\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "const int N = 400005;\nconst int LG = 21;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e9;\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <time.h>\n#include <unordered_set>\n#include <bitset>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vi;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n#define popcountll(x) __builtin_popcountll(x)\n#define fi first\n#define se second\n#define re return\n#define uniq(x) sort(all(x)); (x).resize(unique(all(x)) - (x).begin())\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nint cx[4] = {-1, 0, 1, 0};\nint cy[4] = {0, -1, 0, 1};\n\nll inq(ll x, ll y)\n{\n    if (!y) re 1 % MOD;\n    ll l = inq(x, y / 2);\n    if (y % 2) re l * l % MOD * x % MOD;\n    re l * l % MOD;\n}\n\nll rev(ll x)\n{\n    return inq(x, MOD - 2);\n}\n\nbool __precomputed_combinatorics = 0;\nvector<ll> __fact, __ufact, __rev;\n\nvoid __precompute_combinatorics()\n{\n    __precomputed_combinatorics = 1;\n    __fact.resize(N);\n    __ufact.resize(N);\n    __rev.resize(N);\n    __rev[1] = 1;\n    for (int i = 2; i < N; i++) __rev[i] = MOD - __rev[MOD % i] * (MOD / i) % MOD;\n    __fact[0] = 1, __ufact[0] = 1;\n    for (int i = 1; i < N; i++) __fact[i] = __fact[i - 1] * i % MOD, __ufact[i] = __ufact[i - 1] * __rev[i] % MOD;\n}\n\nll fact(int x)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[x];\n}\n\nll cnk(int n, int k)\n{\n    if (!__precomputed_combinatorics) __precompute_combinatorics();\n    return __fact[n] * __ufact[n - k] % MOD * __ufact[k] % MOD;\n}\n\nvoid __fast_IO()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n}\n\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n//##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**##**\n\nint n, m;\nvector<int> graph[N];\nvector<int> tree[N];\nll a[N], b[N];\n\nbool comp(int i, int j)\n{\n    return a[i] - b[i] < a[j] - b[j];\n}\n\nint top[N], root[N], sz[N];\n\nint Root(int x)\n{\n    if (x == root[x]) re x;\n    re Root(root[x]);\n}\n\npair<ll, ll> dfs(int v)\n{\n    if (tree[v].size() == 0) return {max(a[v], b[v]), b[v]};\n    vector<pll> cp;\n    for (auto u : tree[v])\n    {\n        cp.push_back(dfs(u));\n    }\n    sort(all(cp));\n    ll pay = b[v];\n    for (auto e : cp) pay += e.second;\n    sort(all(cp), [&](pll a, pll b){\n        if (a.first - a.second == b.first - b.second)\n            return a.first > b.first;\n        return a.first - a.second < b.first - b.second;\n    });\n    ll min_cost_in = 1e18;\n    for (int i = 0; i < cp.size(); i++)\n    {\n        if (i == 0 || i == cp.size() - 1 || (a[v] - b[v] >= cp[i].first - cp[i].second && a[v] - b[v] < cp[i + 1].first - cp[i + 1].second))\n        {\n            swap(cp[0], cp[i]);\n            ll cost_in = max(cp[0].first + b[v], a[v]);\n            for (int i = 1; i < cp.size(); i++)\n            {\n                cost_in = max(cost_in + cp[i].second, cp[i].first);\n            }\n            min_cost_in = min(min_cost_in, cost_in);\n            swap(cp[0], cp[i]);\n        }\n    }\n    return {min_cost_in, pay};\n}\n\nsigned main()\n{\n    __fast_IO();\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i];\n    }\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    vector<int> vertices(n), allowed(n);\n    for (int i = 0; i < n; i++) vertices[i] = i, root[i] = i, sz[i] = 1, top[i] = i;\n    sort(all(vertices), comp);\n    for (int i = 0; i < vertices.size(); i++)\n    {\n        int v = vertices[i];\n        for (auto u : graph[v])\n        {\n            if (!allowed[u]) continue;\n            int x = Root(v), y = Root(u);\n            if (x == y) continue;\n            tree[v].push_back(top[y]);\n            if (sz[x] > sz[y])\n            {\n                swap(x, y);\n            }\n            sz[y] += sz[x];\n            root[x] = y;\n            top[y] = v;\n        }\n        allowed[v] = 1;\n    }\n    int root = vertices.back();\n    cout << dfs(root).first;\n}\n\n/* Note:\nCheck constants at the beginning of the code.\nN is set to 4e5 but be careful in problems with large constant factor.\nCheck corner cases.\nNo def int long long for now.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* UnionFind */\n\nstruct UnionFind{\n  vector<int> data, tree_size;\n  UnionFind(int s):data(s,-1),tree_size(s,1) {}\n  \n  int root(int x){\n    if(data[x]==-1) return x;\n    return data[x]=root(data[x]);\n  }\n  \n  bool set(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    data[y]=x;\n    tree_size[x] += tree_size[y];\n    tree_size[y] = 0;\n    return true;\n  }\n  \n  bool check(int x,int y){\n    x=root(x);\n    y=root(y);\n    return x==y;\n  }\n  \n  int size(int x){\n    return tree_size[root(x)];\n  }\n  \n};\n\nint main(){\n  int n, m;\n  int a[SIZE], b[SIZE];\n  vector<pair<pair<int,int> ,int> > vec;\n  vector<int> g[SIZE];\n  pair<ll,ll> dp[SIZE];\n  \n  scanf(\"%d%d\", &n, &m);\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\", a+i, b+i);\n    vec.push_back({{a[i], -b[i]}, i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  for(int i=0;i<m;i++){\n    int u, v;\n    scanf(\"%d%d\", &u,&v);\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  UnionFind uf(n);\n\n  bool used[SIZE] = {};\n  \n  for(int i=0;i<n;i++){\n    int p = vec[i].second;\n    vector<int> uni;\n    \n    for(int j=0;j<g[p].size();j++){\n      if (used[g[p][j]])\n        uni.push_back(uf.root(g[p][j]));\n    }\n    used[p] = true;\n\n    sort(uni.begin(), uni.end());\n    uni.erase(unique(uni.begin(), uni.end()), uni.end());\n    \n    ll sum = 0;\n\n    for(int j=0;j<uni.size();j++){\n      sum += dp[uni[j]].second;\n    }\n    sum += b[p];\n\n    pair<ll,ll> calc = {LLINF, LLINF};\n    \n    for(int j=0;j<uni.size();j++){\n      int q = uni[j];\n      ll nowcost = dp[q].first;\n\n      nowcost += b[p];\n      nowcost = max(nowcost, (ll)a[p]);\n      nowcost += sum - (dp[q].second + b[p]);\n\n      calc = min(calc, make_pair(nowcost, sum));\n    }\n\n    calc = min(calc, make_pair(max(a[p], b[p]) + (sum - b[p]), sum));\n    \n    for(int j=0;j<uni.size();j++){\n      uf.set(p, uni[j]);\n      //assert(p == uf.root(uni[j]));\n    }\n\n    dp[uf.root(p)] = calc;\n    //assert(p == uf.root(p));\n\n    //debug(uf.root(p));\n    //debug(calc.first);\n  }\n  \n  printf(\"%lld\\n\", dp[uf.root(0)].first);\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e5+100;\nvector <int> g[N];\nll a[N],b[N];\nll vis[N];\nll par[N];\nvector <int> mol[N];\nset <pii> s[N];\nll val[N];\nqueue <pii> q;\nvoid mrg(ll u,ll v){\n    if (mol[u].size()<mol[v].size()) swap(u,v);\n    for (auto y : mol[v]){\n        for (auto t : g[y]){\n            q.push({y,t});\n        }\n        mol[u].pb(y);\n        par[y]=u;\n        val[u]+=b[y];\n    }\n    while (s[u].size() && s[u].begin()->F<=val[u]){\n        q.push({u,s[u].begin()->S});\n        s[u].erase(s[u].begin());\n    }\n    return ;\n}\nint32_t main(){\n    sync;\n    ll n,m;\n    cin >> n >> m;\n    for (int i=1;i<=n;i++){\n        cin >> a[i] >> b[i];\n    }\n    for (int i=1;i<=m;i++){\n        ll u,v;\n        cin >> u >> v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    if (n==1){\n        cout << max(a[1],b[1]) << endl;\n        return 0;\n    }\n    ll l=-1,r=(ll)2e9;\n    while(r-l>1){\n        ll mid=(r+l)/2;\n        for (int i=1;i<=n;i++){\n            s[i].clear();\n            par[i]=i;\n            mol[i].clear();\n            mol[i].pb(i);\n            val[i]=b[i]+mid;\n            if (b[i]+mid<a[i]) val[i]=-1;\n        }\n        for (int i=1;i<=n;i++) for (auto u : g[i]) q.push({i,u});\n        while(q.size()){\n            ll v=q.front().F,u=q.front().S;\n            q.pop();\n            if (par[u]==par[v]) continue;\n            ll u1=par[u],v1=par[v];\n            if (val[u1]==-1 && val[v1]==-1) continue;\n            if (val[u1]==-1){\n                if (val[v1]>=a[u1]-b[u1]){\n                    val[u1]=b[u1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[v1].insert({a[u1]-b[u1],u1});\n                }\n                continue;\n            }\n            if (val[v1]==-1){\n                if (val[u1]>=a[v1]-b[v1]){\n                    val[v1]=b[v1]+mid;\n                    mrg(v1,u1);\n                }\n                else{\n                    s[u1].insert({a[v1]-b[v1],v1});\n                }\n                continue;\n            }\n            mrg(u1,v1);\n        }\n        ll p1=0;\n        for (int i=1;i<=n;i++){\n            if (mol[i].size()==n) p1=1;\n            if (par[i]==i && val[i]==-1){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]>=a[i]-b[i]) cout << 1/0;\n                }\n            }\n            else if (mol[par[i]].size()!=n){\n                for (auto u : g[i]){\n                    ll z=par[u];\n                    if (val[z]!=-1 && z!=par[i]) cout << 1/0;\n                }\n            }\n        }\n        if (p1) r=mid;\n        else l=mid;\n    }\n    for (int i=1;i<=n;i++) r+=b[i];\n    cout << r << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, m);\n\tVEC_ROW(int, n, a, b);\n\tVEC_ROW(int, m, u, v);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, m) {\n\t\t--u[i]; --v[i];\n\t\tg[u[i]].emplace_back(v[i]);\n\t\tg[v[i]].emplace_back(u[i]);\n\t}\n\tll bsum = 0;\n\tREP(i, n) bsum += b[i];\n\n\tauto check = [&](int w) -> bool {\n\t\tstd::priority_queue<PAIR, std::vector<PAIR>, std::greater<PAIR>> pq;\n\t\tREP(i, n) pq.push(PAIR(a[i] - b[i], i));\n\t\tstd::vector<bool> used(n, false);\n\n\t\tstd::vector<ll> sum(n);\n\t\tREP(i, n) sum[i] = b[i];\n\t\tUnionFind uf(n);\n\n\t\twhile (!pq.empty()) {\n\t\t\tPAIR startP = pq.top(); pq.pop();\n\t\t\tint start = startP.second;\n\t\t\tif (used[start]) continue;\n\t\t\tll nowsum = w;\n\n\t\t\tstd::set<PAIR> set;\n\t\t\tset.insert(PAIR(a[start] - b[start], start));\n\t\t\twhile (!set.empty()) {\n\t\t\t\tPAIR nowP = *set.begin(); set.erase(set.begin());\n\t\t\t\tif (nowsum < nowP.first) break;\n\t\t\t\tint now = nowP.second;\n\t\t\t\tused[now] = true;\n\t\t\t\tif (start != now) {\n\t\t\t\t\tif (uf.same(start, now)) continue;\n\t\t\t\t\tll t = sum[uf.find(start)] + sum[uf.find(now)];\n\t\t\t\t\tuf.unite(start, now);\n\t\t\t\t\tsum[uf.find(start)] = t;\n\t\t\t\t\tnowsum = w + t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnowsum = w + b[start];\n\t\t\t\t}\n\t\t\t\tfor (auto& to : g[now]) if(!uf.same(now, to)) {\n\t\t\t\t\tPAIR p = PAIR(a[to] - b[to], to);\n\t\t\t\t\tif (!set.count(p)) set.insert(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn uf.size(0) == n;\n\t};\n\n\tint l = -1, r = INFINT;\n\twhile (r - l > 1) {\n\t\tint m = (l + r) / 2;\n\t\tif (check(m)) r = m;\n\t\telse l = m;\n\t}\n\tOUT(r + bsum)BR;\n\treturn 0;\n}\n/*\n逆を考える\n- 今いる頂点vからB[v]円を回収する．これは各頂点1度しかできない．\n- 今いる頂点vに対して所持金がA[v]以上のとき，vに隣接する頂点に移動する．\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define reg register\n#define pb push_back\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,M,id[MN],rk[MN],par[MN];\nll f[MN],sz[MN],A[MN],B[MN],C[MN];\nvector<int> G[MN],T[MN];\nbool cmp(const int&x,const int&y){return C[x]<C[y];}\nint getf(int x){return x==par[x]?x:getf(par[x]);}\nvoid rw(ll &x,ll y){if(y<x)x=y;}\nvoid dfs(int x)\n{\n\t#define y T[x][i]\n\treg int i;sz[x]=B[x];f[x]=1e15;\n\tif(!T[x].size())return (void)(f[x]=B[x]+C[x]);\n\tfor(i=T[x].size()-1;~i;--i)dfs(y),sz[x]+=sz[y];\n\tfor(i=T[x].size()-1;~i;--i)rw(f[x],sz[x]-sz[y]+max(C[x],f[y]));\n\t#undef y\n}\nint main()\n{\n\tN=read();M=read();\n\treg int i,j,x,y;\n\tfor(i=1;i<=N;++i) par[i]=id[i]=i;\n\tfor(i=1;i<=N;++i) A[i]=read(),B[i]=read(),C[i]=max(A[i]-B[i],0LL);\n\tfor(i=1;i<=M;++i) x=read(),y=read(),G[x].pb(y),G[y].pb(x);\n\tstd::sort(id+1,id+N+1,cmp);\n\tfor(i=1;i<=N;++i)rk[id[i]]=i;\n\tint cnt=0;\n\tfor(i=1;i<=N;++i)for(j=G[x=id[i]].size()-1;~j;--j)\n\t{\n\t\ty=getf(G[x][j]);\n\t\tif(y!=x&&rk[y]<i) par[y]=x,T[x].pb(y),++cnt;\n\t}\n\tif(cnt!=N-1) return 0*puts(\"error\");\n\tdfs(id[N]);\n\treturn 0*printf(\"%lld\\n\",f[id[N]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, m, a[MAXN], b[MAXN], sec[MAXN];\nvector<int> adj[MAXN];\nint par[MAXN];\nll ans[MAXN], sumB[MAXN];\npair<ll, ll> gec[MAXN];\n\nbool cmp(int u, int v){return a[u] < a[v];}\n\nint getPar(int v){return par[v]==v? v: par[v]=getPar(par[v]);}\n\nbool mark[MAXN];\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) cin >> a[i] >> b[i], a[i] = max(a[i], b[i]);\n\twhile (m--){\n\t\tint u, v; cin >> u >> v, u--, v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tiota(sec, sec + n, 0);\n\tsort(sec, sec + n, cmp);\n\n\tiota(par, par + n, 0);\n\tfor (int i = 0; i < n; i++){\n\t\tint v = sec[i];\n\t\tmark[v] = true;\n\t\tsumB[v] = b[v];\n\n\t\tint tt = 0;\n\t\tfor (int u:adj[v]){\n\t\t\tif (!mark[u]) continue;\n\t\t\tint pu = getPar(u);\n\t\t\tif (pu == v) continue;\n\n\t\t\tgec[tt++] = {ans[pu], sumB[pu]};\n\t\t\tpar[pu] = v;\n\t\t\tsumB[v] += sumB[pu];\n\t\t}\n\n\t\tans[v] = sumB[v] + (a[v] - b[v]);\n\t\tfor (int j = 0; j < tt; j++){\n\t\t\tauto x = gec[j];\n\t\t\tans[v] = min(ans[v], max((ll)a[v], x.F+b[v]) + (sumB[v] - b[v] - x.S));\n\t\t}\n\t}\n\n\tcout << ans[sec[n-1]] << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll N = 100005, inf = 1e9;\n\nll n, m, a[N], b[N], inv[N], s;\n\nvector<ll> adj[N];\npll o[N];\n\nll p[N], v[N];\nbool c[N];\n\nll Find (ll X) {\n\tif(p[X] == X) return X;\n\treturn p[X] = Find(p[X]);\n}\n\nbool can (ll X) {\n\tfor(ll i=1;i<=n;i++) {\n\t\tp[i] = i;\n\t\tv[i] = b[i];\n\t}\n\tfor(ll i=1;i<=n;i++) {\n\t\tll I = o[i].Y;\n\t\tc[I] = (a[I] <= X + b[I]);\n\t\tfor(auto &T : adj[I]) {\n\t\t\tif(inv[T] >= i) continue;\n\t\t\tT = Find(T);\n\t\t\tif(c[T] && a[I] <= v[T] + X + b[I]) c[I] = true;\n\t\t\tv[I] += v[T];\n\t\t\tp[T] = I;\n\t\t}\n\t}\n\treturn c[Find(1)];\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\to[i] = {a[i], i};\n\t\ts += b[i];\n\t}\n\tsort(o+1, o+1+n);\n\tfor(ll i=1;i<=n;i++) {\n\t\tinv[o[i].Y] = i;\n\t}\n\tfor(ll i=1;i<=m;i++) {\n\t\tll A, B;\n\t\tscanf(\"%lld%lld\",&A,&B);\n\t\tadj[A].push_back(B);\n\t\tadj[B].push_back(A);\n\t}\n\tll S = 0, E = inf;\n\twhile(S<E) {\n\t\tll M = (S+E)/2;\n\t\tcan(M) ? E = M : S = M+1;\n\t}\n\tprintf(\"%lld\\n\",S+s);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\n#define ll long long\n\ntypedef class Item {\n  public:\n    ll a, b;\n    int id;\n  \n    Item() {  }\n    Item(ll a, ll b, int id) : a(a), b(b), id(id) { }\n\n    void read() {\n      scanf(\"%lld%lld\", &a, &b);\n      a = max(a, b);\n    }\n    bool operator < (Item x) const {\n      return a - b < x.a - x.b;\n    }\n} Item;\n\ntypedef class dp_t {\n  public:\n    ll f, b;\n\n    dp_t() {  }\n    dp_t(ll f, ll b) : f(f), b(b) {  }\n    dp_t(Item x) : f(x.a), b(x.b) { }\n\n    dp_t operator + (dp_t t) const {\n      return dp_t(max(f, b + t.f), b + t.b);\n    }\n} dp_t;\n\n#define ll long long\n\nconst int N = 1e5 + 5;\nconst ll llf = (signed ll) (~0ull >> 3);\n\nint n, m;\nItem it[N], oit[N];\nvector<int> G[N];\nvector<int> Tr[N];\n\nint uf[N];\nint find(int x) {\n  return uf[x] == x ? x : (uf[x] = find(uf[x]));\n} \n\nll f[N], sb[N];\nvoid dfs(int p) {\n  sb[p] = oit[p].b;\n  for (auto e : Tr[p]) {\n    dfs(e);\n    sb[p] += sb[e];\n  }\n  if (Tr[p].empty()) {\n    f[p] = oit[p].a;\n  } else {\n    f[p] = llf;\n    vector<Item> a;\n    vector<dp_t> pr, sf;\n    for (auto e : Tr[p]) {\n      a.emplace_back(f[e], sb[e], e);\n    }\n    sort(a.begin(), a.end());\n    pr.emplace_back(-llf, 0);\n    for (auto x : a) {\n      pr.push_back(pr.back() + x);\n    }\n    reverse(a.begin(), a.end());\n    sf.emplace_back(-llf, 0);\n    for (auto x : a) {\n      sf.push_back(dp_t(x) + sf.back());\n    }\n    reverse(a.begin(), a.end());\n    reverse(sf.begin(), sf.end());\n    int deg = Tr[p].size();\n    for (int i = 0; i < deg; i++) {\n      int e = a[i].id;\n      auto t = pr[i] + sf[i + 1] + oit[p] + dp_t(f[e], sb[e]);\n      f[p] = min(f[p], t.f);\n    }\n  }\n}\n\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    it[i].read();\n    it[i].id = i;\n    oit[i] = it[i];\n  }\n  sort(it + 1, it + n + 1);\n  for (int i = 1, u, v; i <= m; i++) {\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  for (int i = 1; i <= n; i++) {\n    int p = it[i].id;\n    uf[p] = p;\n    for (auto e : G[p]) {\n      if (find(e) && (find(p) ^ find(e))) {\n        e = find(e);\n        Tr[p].push_back(e);\n        uf[e] = p;\n      }\n    }\n  }\n  int rt = find(1);\n  dfs(rt);\n  printf(\"%lld\\n\", f[rt]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef long double llf;\ntypedef pair<int, int> pi;\nconst int MAXN = 100005;\n#define sz(v) ((int)v.size())\n\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstruct func{\n\tlint out;\n\tlint B, A; // f(W) = max(W + B, A)\n}val[MAXN];\n\nvector<int> gph[MAXN];\nint n, m, a[MAXN], b[MAXN];\nint rev[MAXN];\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%d %d\",&a[i],&b[i]);\n\t\ta[i] = max(a[i], b[i]);\n\t}\n\tvector<int> ord(n);\n\tiota(ord.begin(), ord.end(), 1);\n\tsort(ord.begin(), ord.end(), [&](const int &x, const int &y){\n\t\treturn a[x] - b[x] < a[y] - b[y];\n\t});\n\tfor(int i=0; i<sz(ord); i++) rev[ord[i]] = i;\n\tfor(int i=0; i<m; i++){\n\t\tint s, e;\n\t\tscanf(\"%d %d\",&s,&e);\n\t\ts = rev[s]; e = rev[e];\n\t\tif(s > e) swap(s, e);\n\t\tgph[ord[e]].push_back(ord[s]);\n\t}\n\tdisj.init(n);\n\tfor(auto &x : ord){\n\t\tvector<func> vect;\n\t\tfor(auto &i : gph[x]){\n\t\t\tint p = disj.find(i);\n\t\t\tif(disj.find(x) == p) continue;\n\t\t\tvect.push_back(val[p]);\n\t\t\tdisj.uni(i, x);\n\t\t}\n\t\tlint bsum = 0;\n\t\tfor(auto &i : vect) bsum += i.B;\n\t\tfunc ret = {(lint)1e18, b[x] + bsum, a[x] + bsum};\n\t\tfor(auto &i : vect){\n\t\t\tlint cur_out = max(i.out + b[x], 1ll * a[x]);\n\t\t\tcur_out += bsum - i.B;\n\t\t\tret.out = min(ret.out, cur_out);\n\t\t}\n\t\tif(vect.empty()) ret.out = a[x];\n\t\tval[disj.find(x)] = ret;\n\t}\n\tcout << val[disj.find(ord.back())].out << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],s[N],q[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR pi p=Q[v].top();Q[v].pop();\n\t\tif(find(p.se)!=find(u))Q[u].push(p);\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n\t\t\tif(s[u]+s[p.se]>=mx)return true;\n\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,++cnt,merge(u,p.se);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N, M;\npair <int, int> Nodes[100005];\nint A[100005], B[100005], Pos[100005];\nvector <int> G[100005], GG[100005];\nbool Active[100005];\nint TT[100005], R[100005];\npair <int, int> Sz[100005];\nlong long Sum[100005], DP[100005];\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n        //Val[y] += Val[x];\n        Sz[y] = max(Sz[y], Sz[x]);\n    }\n    else\n        TT[y] = x, Sz[x] = max(Sz[x], Sz[y]);\n    if(R[x] == R[y])\n        ++R[x];\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n    {\n        cin >> A[i] >> B[i];\n        TT[i] = i;\n        Sz[i] = make_pair(max(0, A[i] - B[i]), i);\n        A[i] = max(0, A[i] - B[i]);\n        Nodes[i] = make_pair(A[i], i);\n    }\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    sort(Nodes + 1, Nodes + N + 1);\n    for(int i = 1; i <= N; i++)\n        Pos[Nodes[i].second] = i;\n}\n\nvoid buildTree()\n{\n    for(int i = 1; i <= N; i++)\n    {\n        int node = Nodes[i].second;\n        Active[node] = 1;\n        for(int j = 0; j < G[node].size(); j++)\n        {\n            int neighb = G[node][j];\n            if(Pos[neighb] > Pos[node])\n                continue;\n            if(Father(node) != Father(neighb))\n            {\n                GG[Sz[Father(node)].second].push_back(Sz[Father(neighb)].second);\n                Unite(Father(node), Father(neighb));\n            }\n        }\n    }\n}\n\nvoid DFS(int node)\n{\n    Sum[node] = B[node];\n    int cnt = 0;\n    for(int i = 0; i < GG[node].size(); i++)\n    {\n        int neighb = GG[node][i];\n        DFS(neighb);\n        Sum[node] += Sum[neighb];\n        ++cnt;\n    }\n    DP[node] = 1000000000000000;\n    if(cnt == 0)\n    {\n        DP[node] = A[node] + B[node];\n        return;\n    }\n    for(int i = 0; i < GG[node].size(); i++)\n    {\n        int neighb = GG[node][i];\n        long long s = Sum[node] - Sum[neighb];\n        DP[node] = min(DP[node], max(0LL, DP[neighb] - A[node]) + s + A[node]);\n    }\n}\nint main()\n{\n    Read();\n    buildTree();\n    DFS(Nodes[N].second);\n    cout << DP[Nodes[N].second] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 101000\nusing namespace std;\nstruct point{\n\tint a, b, num;\n\tbool operator<(const point &p)const {\n\t\treturn a < p.a;\n\t}\n}w[N_];\nint A[N_], B[N_];\nvector<int>E[N_];\nlong long SB[N_], M[N_], mmm;\nint UF[N_], chk[N_];\nint n, m, v[N_];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nstruct TT {\n\tlong long sb, m;\n\tbool operator <(const TT &p)const {\n\t\treturn sb - m < p.sb - p.m;\n\t}\n};\nlong long G[N_], BB[N_], EE[N_];\nvoid Go(int a, vector<int> &T) {\n\tchk[a] = 1;\n\tif (T.empty()) {\n\t\tSB[a] = B[a];\n\t\tM[a] = max(A[a], B[a]);\n\t\treturn;\n\t}\n\tint sz = T.size();\n\tvector<TT> U(sz);\n\tmmm = A[a];\n\tint c = 0;\n\tfor (auto &t : T) {\n\t\tUF[t] = a;\n\t\tU[c++] = { SB[t], M[t] };\n\t}\n\tsort(U.begin(), U.end());\n\tlong long mm = 0, sb = 0;\n\tint i;\n\tfor (i = 0; i < sz; i++) {\n\t\tmm = max(mm, sb + U[i].m);\n\t\tG[i] = sb + U[i].m;\n\t\tsb += U[i].sb;\n\t}\n\tmm = max(mm, sb + max(A[a], B[a]));\n\tfor (i = 0; i < sz; i++) {\n\t\tif (i == 0 || G[i] > BB[i - 1])BB[i] = G[i];\n\t\telse BB[i] = BB[i - 1];\n\t}\n\tfor (i = sz - 1; i >= 0; i--) {\n\t\tif (i == sz - 1 || G[i] > EE[i + 1])EE[i] = G[i];\n\t\telse EE[i] = EE[i + 1];\n\t}\n\n\tfor (i = 0; i < sz; i++) {\n\t\tlong long t = sb - U[i].sb + B[a] + U[i].m;\n\t\tt = max(t, sb - U[i].sb + max(A[a], B[a]));\n\t\tif (i != 0)t = max(t, BB[i - 1]);\n\t\tif (i != sz - 1)t = max(t, EE[i + 1] - U[i].sb);\n\t\tmm = min(mm, t);\n\t}\n\n\tsb += B[a];\n\tM[a] = mm;\n\tSB[a] = sb;\n}\nint main() {\n\tint i, a, b;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", &w[i].a, &w[i].b);\n\t\tA[i] = w[i].a, B[i] = w[i].b;\n\t\tUF[i] = i;\n\t\tw[i].num = i;\n\t}\n\tsort(w + 1, w + n + 1);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tE[a].push_back(b);\n\t\tE[b].push_back(a);\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint a = w[i].num;\n\t\tvector<int>T;\n\t\tfor (auto &x : E[a]) {\n\t\t\tif (!chk[x])continue;\n\t\t\tint t = Find(x);\n\t\t\tif (!v[t]) {\n\t\t\t\tT.push_back(t);\n\t\t\t\tv[t] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (auto &t : T)v[t] = 0;\n\t\tGo(a, T);\n\t}\n\tprintf(\"%lld\\n\",M[w[n].num]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\nstruct edge{int x,y,w;}e[MN+5];\nbool cmp(const edge&a,const edge&b){return a.w<b.w;}\nint a[MN+5],b[MN+5],f[MN+5];long long s[MN+5],ss[MN+5];\nint gf(int k){return f[k]?f[k]=gf(f[k]):k;}\nint main()\n{\n\tint n,m,i;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i)scanf(\"%d%d\",&a[i],&b[i]),s[i]=max(a[i],b[i]),ss[i]=b[i];\n\tfor(i=1;i<=m;++i)scanf(\"%d%d\",&e[i].x,&e[i].y),e[i].w=max(a[e[i].x]-b[e[i].x],a[e[i].y]-b[e[i].y]);\n\tsort(e+1,e+m+1,cmp);\n\tfor(i=1;i<=m;++i)if((e[i].x=gf(e[i].x))!=(e[i].y=gf(e[i].y)))\n\t{\n\t\ts[e[i].x]=min(max(s[e[i].x],1LL*e[i].w)+ss[e[i].y],max(s[e[i].y],1LL*e[i].w)+ss[e[i].x]);\n\t\tss[e[i].x]+=ss[e[i].y];\n\t\tf[e[i].y]=e[i].x;\n\t}\n\tprintf(\"%d\",s[gf(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\n\nint n, m, a[maxn], b[maxn], h[maxn], ecnt, pos[maxn], sfa[maxn], vis[maxn], w[maxn];\nll f[maxn], dp[maxn];\nstruct enode{\n\tint v, n;\n\tenode() {}\n\tenode(int _v, int _n):v(_v), n(_n) {}\n}e[maxn << 1];\n\ninline void addedge(int u, int v) { ecnt ++; e[ecnt] = enode(v,h[u]); h[u] = ecnt; }\n\ninline bool cmp(int x, int y) { return w[x] < w[y]; }\n\nint findfa(int u) { return (sfa[u] == u) ? (u) : (sfa[u] = findfa(sfa[u])); }\n\nint lis[maxn];\n\ninline void upmin(ll &x, ll y) { x = min(x,y); }\n\nint main() {\n\tscanf(\"%d%d\", &n, &m); ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 1;i <= n;i ++) scanf(\"%d%d\", &a[i], &b[i]), w[i] = max(0,a[i] - b[i]);\n\tfor(int i = 1;i <= m;i ++) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\taddedge(u,v);\n\t\taddedge(v,u);\n\t}\n\tfor(int i = 1;i <= n;i ++) pos[i] = i, sfa[i] = i;\n\tsort(pos + 1,pos + n + 1,cmp);\n\tfor(int i = 1;i <= n;i ++) {\n\t\tint u = pos[i]; vis[u] = 1;\n\t\tf[u] = b[u]; int tot = 0;\n\t\tfor(int j = h[u];~ j;j = e[j].n) {\n\t\t\tint v = e[j].v, r;\n\t\t\tif(!vis[v] || findfa(v) == findfa(u)) continue;\n\t\t\tr = findfa(v);\n\t\t\tf[u] += f[r];\n\t\t\tsfa[r] = u;\n\t\t\tlis[++ tot] = r;\n\t\t}\n\t\tdp[u] = f[u] + w[u];\n\t\tfor(int j = 1;j <= tot;j ++) {\n\t\t\tint v = lis[j];\n\t\t\tll now = f[u] - f[v] + max((ll)w[u],dp[v]);\n\t\t\tupmin(dp[u],now);\n\t\t}\n\t}\n\tll Ans = dp[pos[n]];\n\tprintf(\"%lld\\n\", Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#define re register\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define MAXN 100507\n#define mo 19930726\n#define ll long long\nusing namespace std;\ntypedef unsigned long long ull;\n#define ms(arr) memset(arr, 0, sizeof(arr))\nconst int inf = 0x3f3f3f3f;\nint head[MAXN],fa[MAXN],a[MAXN],b[MAXN],c[MAXN],n,m,vis[MAXN],id[MAXN],cnt,num;\nll s[MAXN],f[MAXN];\nstruct po{\n\tint nxt,to;\n}edge[MAXN<<1];\nvector<int> v[MAXN];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\ninline bool cmp(int x,int y) {return c[x]<c[y];}\ninline void add_edge(int from,int to){\n\tedge[++num].nxt=head[from];edge[num].to=to;head[from]=num;\n}\nvoid dfs(int u){\n\ts[u]=b[u];\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tdfs(v);\n\t\ts[u]+=s[v];\n\t}\n\tf[u]=s[u]+c[u];\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tf[u]=min(f[u],s[u]-s[v]+max(f[v],1ll*c[u]));\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i]>>b[i];\n\t\tc[i]=max(0,a[i]-b[i]);\n\t\tfa[i]=id[i]=i;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[x].push_back(y); v[y].push_back(x);\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];vis[x]=1;\n\t\tfor(int j=0;j<v[x].size();j++) {\n\t\t\tint y=v[x][j];\n\t\t\tif(!vis[y]) continue;\n\t\t\ty=find(y);\n\t\t\tif(x!=y){\n\t\t\t\tfa[y]=x;add_edge(x,y);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(id[n]);\n\tcout<<f[id[n]];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, M;\nint A[100000], B[100000];\nvector<int> G[100000];\nint U[100000], R[100000];\nint repr[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\nvector<int> G2[100000];\nbool used[100000];\nlong long dp[100000], sum[100000];\n\nvoid dfs(int x) {\n  if (G2[x].empty()) dp[x] = B[x];\n  sum[x] = B[x];\n  for (int t : G2[x]) {\n    dfs(t);\n    sum[x] += sum[t];\n  }\n  for (int t : G2[x]) {\n    dp[x] = min(dp[x], max(dp[t] + (sum[x]-sum[t]), A[x]+sum[x]-B[x]-sum[t]));\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, N) cin >> A[i] >> B[i];\n  rep(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) U[i] = i, R[i] = 1, repr[i] = i;\n  vector<P> ord;\n  rep(i, N) ord.pb(P(A[i], i));\n  sort(all(ord));\n  for (P p : ord) {\n    int x = p._2;\n    used[x] = true;\n    for (int t : G[x]) if (used[t] && !same(x, t)) {\n      int c = repr[find(t)];\n      unite(x, t);\n      repr[find(x)] = x;\n      G2[x].pb(c);\n      //cout<<x<<\"->\"<<c<<\"\\n\";\n    }\n  }\n  rep(i, N) dp[i] = INF;\n  int root = ord.back()._2;\n  assert(root == repr[find(0)]);\n  dfs(root);\n  cout << dp[root] << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin >> n >> m;\n  vector<int> a(n), b(n);\n  for (int i = 0; i < n; ++i)\n    cin >> a[i] >> b[i];\n  vector<vector<int>> g(n);\n  while (m--) {\n    int u, v;\n    cin >> u >> v;\n    --u; --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  ll ans = 1LL << 60;\n  for (int i = 0; i < n; ++i) {\n    vector<bool> vis(n);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    ll s = 0, h = 0;\n    q.emplace(a[i] - b[i], i);\n    while (!q.empty()) {\n      int u = q.top().second; q.pop();\n      if (!vis[u]) vis[u] = true;\n      else continue;\n      //cerr << u << ' ';\n      h = max(h, a[u] - (s += b[u]));\n      for (int v : g[u])\n        if (!vis[v])\n          q.emplace(a[v] - b[v], v);\n    }\n    //cerr << \": \" << (h + s) << '\\n';\n    ans = min(ans, h);\n  }\n  ans += accumulate(b.begin(), b.end(), 0LL);\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n      \n      if(q.empty()){\n\tfor(Int i=0;i<n;i++) if(used[i]) push(i);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=s+*min_element(a.begin(),a.end())-1;\n  Int r=s+*max_element(a.begin(),a.end())+1;\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],s[N],q[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR pi p=Q[v].top();Q[v].pop();\n\t\tif(find(p.se)!=find(u))Q[u].push(p);\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n\t\t\tif(s[u]+s[p.se]>=mx)return true;\n\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,++cnt,merge(u,p.se);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n\nint n, m, z[100005], par[100005], tb, tc;\nlong long x[100005], y[100005], sum[100005], dp[100005], ta;\nvector< int > v[100005], vv[100005];\n\nint find(int a) {\n\treturn par[a] == a ? a : par[a] = find(par[a]);\n}\n\nvoid dfs(int a) {\n\tsum[a] = x[a];\n\tif (vv[a].empty())\n\t\tdp[a] = sum[a] + y[a];\n\telse {\n\t\tfor (int i: vv[a]) {\n\t\t\tdfs(i);\n\t\t\tsum[a] += sum[i];\n\t\t}\n\t\tdp[a] = LLONG_MAX;\n\t\tfor (int i: vv[a])\t\n\t\t\tdp[a] = min(dp[a], max(dp[i], y[a]) + sum[a] - sum[i]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld%lld\", &ta, x + i);\n\t\ty[i] = max(ta - x[i], 0LL);\n\t\tz[i] = i;\n\t}\n\tsort(z + 1, z + n + 1, [](const int &a, const int &b) {return y[a] < y[b];});\n\twhile (m--) {\n\t\tscanf(\"%d%d\", &tb, &tc);\n\t\tv[tb].push_back(tc);\n\t\tv[tc].push_back(tb);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\ttb = z[i];\n\t\tpar[tb] = tb;\n\t\tfor (int j: v[tb])\n\t\t\tif (par[j] && find(j) != tb) {\n\t\t\t\tvv[tb].push_back(par[j]);\n\t\t\t\tpar[par[j]] = tb;\n\t\t\t}\n\t}\n\tdfs(z[n]);\n\tprintf(\"%lld\\n\", dp[z[n]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 300000\n#define INF 0x3f3f3f3f\n\nint n,m,x,y,a[N],b[N],c[N],d[N],f[N],fa[N],sum[N],tot,head[N];\nbool vis[N];\nstruct edge{int v,nxt;}e[N];\nvector<int> vec[N];\n\nvoid add(int x,int y){e[++tot].v=y; e[tot].nxt=head[x]; head[x]=tot;}\n\nbool cmp(int x,int y){return c[x]<c[y];}\n\nint gfa(int x){return !fa[x]?x:fa[x]=gfa(fa[x]);}\n\nvoid dp(int u){\n\tsum[u]=b[u]; f[u]=INF;\n\tfor (int i=0,v;i<(int)vec[u].size();++i){dp(v=vec[u][i]); sum[u]+=sum[v];}\n\tif (!vec[u].size()){f[u]=b[u]+c[u]; return;}\n\tfor (int i=0,v;i<(int)vec[u].size();++i){\n\t\tv=vec[u][i];\n\t\tf[u]=min(f[u],sum[u]-sum[v]+max(c[u],f[v]));\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\ta[i]=max(a[i],b[i]);\n\t\tc[i]=a[i]-b[i];\n\t\td[i]=i;\n\t}\n\tfor (int i=1;i<=m;++i){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;++i){\n\t\tint x=d[i];\n\t\tfor (int j=head[x];j;j=e[j].nxt)\n\t\t\tif (vis[e[j].v]){\n\t\t\t\tint y=gfa(e[j].v);\n\t\t\t\tif (x!=y){fa[y]=x; vec[x].push_back(y);}\n\t\t\t}\n\t\tvis[x]=1;\n\t}\n\tdp(d[n]);\n\tprintf(\"%d\\n\",f[d[n]]);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "/*\n  mail: mleautomaton@foxmail.com\n  author: MLEAutoMaton\n  This Code is made by MLEAutoMaton\n*/\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define int ll\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=200010,Inf=1e18+10;\nint n,m,a[N],b[N],sum[N],f[N],p[N],dp[N],vis[N];\nint find(int x){return f[x]!=x?f[x]=find(f[x]):f[x];}\nvector<int>G[N];\nbool cmp(int A,int B){return a[A]<a[B];}\nsigned main(){\n\tn=gi();m=gi();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=gi();b[i]=gi();a[i]=max(a[i]-b[i],0ll);\n\t\tp[i]=f[i]=i;sum[i]=b[i];dp[i]=a[i];\n\t}\n\tfor(int i=1;i<=m;i++){int u=gi(),v=gi();G[u].push_back(v);G[v].push_back(u);}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=p[i];vis[u]=1;\n\t\tfor(int v:G[u])\n\t\t\tif(vis[v]){\n\t\t\t\tint x=find(u),y=find(v);\n\t\t\t\tif(x!=y){\n\t\t\t\t\tf[y]=x;sum[x]+=sum[y];\n\t\t\t\t\tdp[x]=min(dp[x],max(dp[y],a[x]-sum[y]));\n\t\t\t\t}\n\t\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[find(1)]+sum[find(1)]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR int w=Q[v].top().se;Q[v].pop();\n\t\tif(find(w)!=find(u))Q[u].push(pi(dx[w],w));\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tif(h>t)return false;\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR int v=Q[u].top().se;if(dx[v]>s[u])break;\n\t\t\tQ[u].pop();if(find(v)==find(u))continue;\n\t\t\tif(s[u]+s[v]>=mx)return true;\n\t\t\ts[u]+=s[v],fa[find(v)]=u,++cnt,merge(u,v);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tl=1,r=1e9;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll a[100005],b[100005];\n\n// union-find-simple-ver\n\nstruct uftree{\n\tint par[200005];\n\tint rank[200005];\n\tll dp[200005];\n\tll bsum[200005];\n\tuftree(){\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x]=y;\n\t\t\tbsum[y]+=bsum[x];\n\t\t}else{\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t\tpar[y]=x;\n\t\t\tbsum[x]+=bsum[y];\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\n\nuftree uf;\nint n,m;\n\nvector<int> G[100005];\nbool flag[200005];\nll maxi=0;\nvector<P> vi;\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tll all=0;\n\tuf.init(n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tall+=b[i];\n\t\tvi.push_back(P(max(0LL,a[i]-b[i]),i));\n\t\tuf.bsum[i]=b[i];\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--;\n\t\tv--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tsort(vi.begin(),vi.end());\n\tfor(int i=0;i<vi.size();i++){\n\t\tll mini=vi[i].first;\n\t\tint v=vi[i].second;\n\t\tfor(int j=0;j<G[v].size();j++){\n\t\t\tif(!flag[G[v][j]])continue;\n\t\t\tint nv=uf.find(G[v][j]);\n\t\t\tmini=min(mini,max(uf.dp[nv],(ll)vi[i].first-uf.bsum[nv]));\n\t\t}\n\t\tflag[v]=true;\n\t\tfor(int j=0;j<G[v].size();j++){\n\t\t\tif(flag[G[v][j]]){\n\t\t\t\tuf.unite(v,G[v][j]);\n\t\t\t}\n\t\t}\n\t\tuf.dp[uf.find(v)]=mini;\n\t}\n\tprintf(\"%lld\\n\",uf.dp[uf.find(0)]+all);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define ivorysi\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n#define pii pair<int,int>\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 + c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {putchar('-');x = -x;}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nint N,M;\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE,id[MAXN],ra[MAXN],f[MAXN];\nint64 A[MAXN],B[MAXN],C[MAXN],dp[MAXN],siz[MAXN];\nvector<int> son[MAXN];\nint getfa(int x) {\n    return f[x] == x ? x : f[x] = getfa(f[x]);\n}\nbool cmp(int a,int b) {\n    return C[a] <= C[b];\n}\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvoid Init() {\n    read(N);read(M);\n    for(int i = 1 ; i <= N ; ++i) {\n\tread(A[i]);read(B[i]);C[i] = max(A[i] - B[i],0LL);\n\tid[i] = i;\n    }\n    sort(id + 1,id + N + 1,cmp);\n    for(int i = 1 ; i <= N ; ++i) ra[id[i]] = i;\n    int u,v;\n    for(int i = 1 ; i <= M ; ++i) {\n\tread(u);read(v);\n\tadd(u,v);add(v,u);\n    }\n}\nvoid dfs1(int u) {\n    siz[u] += B[u];\n    for(auto v : son[u]) {\n\tdfs1(v);\n\tsiz[u] += siz[v];\n    }\n}\nvoid dfs2(int u) {\n    if(son[u].size() == 0) {\n\tdp[u] = B[u] + C[u];\n\treturn;\n    }\n    dp[u] = 1e18;\n    for(auto v : son[u]) {\n\tdfs2(v);\n\tdp[u] = min(siz[u] - siz[v] + max(C[u],dp[v]),dp[u]);\n    }\n}\nvoid Solve() {\n    for(int i = 1 ; i <= N ; ++i) f[i] = i;\n    for(int i = 1 ; i <= N ; ++i) {\n\tint u = id[i];\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(ra[getfa(v)] < ra[u] && getfa(v) != u) {\n\t\tson[u].pb(getfa(v));\n\t\tf[getfa(v)] = u;\n\t    }\n\t}\n    }\n    dfs1(id[N]);\n    dfs2(id[N]);\n    out(dp[id[N]]);enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,M;\nint A[111111],B[111111];\n\nvint G[111111];\n\nstruct UnionFindTree{\n    vector<int>par,sz,sumB,ans;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        sumB.resize(n);\n        ans.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        sumB[x]+=sumB[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nsigned main(){\n    cin>>N>>M;\n    rep(i,N){\n        cin>>A[i]>>B[i];\n        chmax(A[i],B[i]);\n    }\n    rep(i,M){\n        int a,b;cin>>a>>b;a--;b--;G[a].pb(b);G[b].pb(a);\n    }\n\n    vpint lis;\n    rep(i,N)lis.pb({A[i]-B[i],i});\n    sort(all(lis));\n\n    UnionFindTree uf(N);\n    rep(i,N){\n        int v=lis[i].se;\n\n        int uku=lis[i].fi;\n        uf.sumB[v]=B[v];\n        for(auto u:G[v]){\n            if(uf.sumB[uf.find(u)]==0)continue;\n            int tmp=uf.ans[uf.find(u)];\n            chmax(tmp,lis[i].fi-uf.sumB[uf.find(u)]);\n            chmin(uku,tmp);\n            uf.unite(v,u);\n        }\n        uf.ans[uf.find(v)]=uku;\n    }\n\n    cout<<uf.ans[uf.find(lis.back().se)]+accumulate(B,B+N,0ll)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int N=2e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\npriority_queue<pi,vector<pi>,greater<pi> >Q[N];\nint fa[N],dx[N],a[N],b[N],q[N];ll s[N];\nll sum;int n,m,l,r,mid,ans,mx;\ninline int find(R int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid merge(int u,int v){\n\tif(Q[u].size()<Q[v].size())Q[u].swap(Q[v]);\n\twhile(!Q[v].empty()){\n\t\tR pi p=Q[v].top();Q[v].pop();\n\t\tif(find(p.se)!=find(u))Q[u].push(p);\n\t}\n}\nbool ck(){\n\tint h=1,t=0,u;\n\tfp(u,1,n){\n\t\tfa[u]=u,s[u]=b[u],dx[u]=a[u]-b[u]-mid;\n\t\tif(dx[u]<=0)q[++t]=u;\n\t}\n\tfp(u,1,n){\n\t\twhile(!Q[u].empty())Q[u].pop();\n\t\tgo(u)Q[u].push(pi(dx[v],v));\n\t}\n\tR int cnt=0;\n\twhile(h<=t){\n\t\tu=q[h++];if(find(u)!=u)continue;\n\t\twhile(!Q[u].empty()){\n\t\t\tR pi p=Q[u].top();if(p.fi>s[u])break;\n\t\t\tQ[u].pop();if(find(p.se)==find(u))continue;\n\t\t\tif(s[u]+s[p.se]>=mx)return true;\n\t\t\ts[u]+=s[p.se],fa[find(p.se)]=u,++cnt,merge(u,p.se);\n\t\t}\n\t}\n\treturn cnt==n-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,1,n)scanf(\"%d%d\",&a[i],&b[i]),cmax(mx,a[i]),sum+=b[i];\n\tfor(R int i=1,u,v;i<=m;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tmid=0;if(ck())return printf(\"%lld\\n\",sum),0;\n\tfp(i,1,n)cmax(r,a[i]-b[i]);\n\tl=1;\n\twhile(l<=r){\n\t\tmid=(l+r)>>1;\n\t\tck()?(ans=mid,r=mid-1):l=mid+1;\n\t}\n\tprintf(\"%lld\\n\",sum+ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\n#define ll long long\n//#define file\nusing namespace std;\n\nint a[200001][2],ls[100001],A[100001],B[100001],C[100001],fa[100001],n,m,i,j,k,l,len;\nll f[100001],sum[100001];\nbool bz[100001];\n\nvoid New(int x,int y) {++len;a[len][0]=y;a[len][1]=ls[x];ls[x]=len;}\nbool cmp(int x,int y) {return C[x]>C[y];}\nint gf(int t) {if (fa[t]==t) return fa[t];fa[t]=gf(fa[t]);return fa[t];}\nnamespace G{\n\tint a[200001][2],ls[100001],b[100001],len,i,j,k,l,x,y;\n\t\n\tvoid New(int x,int y) {++len;a[len][0]=y;a[len][1]=ls[x];ls[x]=len;}\n\tvoid work()\n\t{\n\t\tfo(i,1,n) b[i]=i;\n\t\tsort(b+1,b+n+1,cmp);\n\t\tfd(l,n,1)\n\t\t{\n\t\t\tbz[b[l]]=1;\n\t\t\tfor (i=ls[b[l]]; i; i=a[i][1])\n\t\t\tif (bz[a[i][0]])\n\t\t\t{\n\t\t\t\tx=gf(b[l]),y=gf(a[i][0]);\n\t\t\t\tif (x!=y)\n\t\t\t\tfa[fa[y]]=fa[x],::New(x,y),::New(y,x);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int Fa,int t)\n{\n\tint i;\n\t\n\tf[t]=9223372036854775807ll,sum[t]=B[t];\n\tfor (i=ls[t]; i; i=a[i][1])\n\tif (a[i][0]!=Fa)\n\tdfs(t,a[i][0]),sum[t]+=sum[a[i][0]];\n\t\n\tf[t]=sum[t]+C[t];\n\tfor (i=ls[t]; i; i=a[i][1])\n\tif (a[i][0]!=Fa)\n\tf[t]=min(f[t],sum[t]-sum[a[i][0]]+max(C[t],f[a[i][0]]));\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"arc098F.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d%d\",&n,&m);\n\tfo(i,1,n) scanf(\"%d%d\",&A[i],&B[i]),A[i]=max(A[i],B[i]),fa[i]=i,C[i]=A[i]-B[i];\n\tfo(i,1,m) scanf(\"%d%d\",&j,&k),G::New(j,k),G::New(k,j);\n\t\n\tG::work();\n\tdfs(0,G::b[1]);\n\tprintf(\"%lld\\n\",f[G::b[1]]);\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint a[100005],b[100005],n;\n\nnamespace Heap {\n\nint ch[200005][2],num[200005],tot;\nint d[200005];\n\nint newnode(int x) {\n  num[++tot]=x;\n  ch[tot][0]=ch[tot][1]=0;\n  d[tot]=1;\n  return tot;\n}\n\nint merge(int x,int y) {\n  if (!x) return y;\n  if (!y) return x;\n  if (a[num[x]]>a[num[y]]) swap(x,y);\n  ch[x][1]=merge(ch[x][1],y);\n  if (d[ch[x][0]]<d[ch[x][1]]) swap(ch[x][0],ch[x][1]);\n  d[x]=d[ch[x][1]]+1;\n  return x;\n}\n\nint pop(int x) {\n  return merge(ch[x][0],ch[x][1]);\n}\n\n}\n\nint root[100005];\n\nnamespace SETS {\n\nint fa[100005],size[100005];\nll sum[100005];\n\nvoid init(int n) {\n  for(int i=1;i<=n;i++) {\n  \tfa[i]=i;\n  \tsize[i]=1;\n  \tsum[i]=b[i];\n  }\n}\n\nint find_father(int x) {\n  return (fa[x]==x)?x:fa[x]=find_father(fa[x]);\n}\n\nbool check(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  return x!=y;\n}\n\nvoid merge(int x,int y) {\n  x=find_father(x);y=find_father(y);\n  if (x==y) return;\n  fa[y]=x;\n  sum[x]+=sum[y];\n  size[x]+=size[y];\n  root[x]=Heap::merge(root[x],root[y]);\n}\n\n}\n\nbool vis[100005];\n\nbool bfs(int s,int d) {\n  vis[s]=1;\n  while (root[s]) {\n  \tint x=Heap::num[root[s]];\n  \tif (!SETS::check(s,x)) {\n  \t\troot[s]=Heap::pop(root[s]);\n  \t\tcontinue;\n\t  }\n  \tif (a[x]>d+SETS::sum[s]) break;\n  \tvis[x]=1;\n  \troot[s]=Heap::pop(root[s]);\n  \tSETS::merge(s,x);\n  }\n  return SETS::size[s]==n;\n}\n\nvector <int> e[100005];\n\nbool check(int d) {\n  memset(vis,0,sizeof(vis));\n  Heap::tot=0;\n  SETS::init(n);\n  for(int i=1;i<=n;i++) {\n  \troot[i]=0;\n  \tfor(int j=0;j<e[i].size();j++) {\n  \t\tint u=Heap::newnode(e[i][j]);\n  \t\troot[i]=Heap::merge(root[i],u);\n\t  }\n  }\n  for(int i=1;i<=n;i++)\n    if (a[i]<=d&&!vis[i]&&bfs(i,d)) return 1;\n  return 0; \n}\n\nint main() {\n  int m;\n  scanf(\"%d%d\",&n,&m);\n  int l=0,r=0;\n  ll s=0;\n  for(int i=1;i<=n;i++) {\n    scanf(\"%d%d\",&a[i],&b[i]);\n    a[i]-=b[i];\n    s+=b[i];\n    r=max(r,a[i]);\n  }\n  for(int i=1;i<=m;i++) {\n  \tint x,y;\n  \tscanf(\"%d%d\",&x,&y);\n  \te[x].push_back(y);\n  \te[y].push_back(x);\n  }\n  while (l<r) {\n  \tint mid=((l+r)>>1);\n  \tif (check(mid)) r=mid; else l=mid+1;\n  }\n  printf(\"%lld\\n\",s+l);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define int long long\nint n,m,a[100100],b[100100],fa[100100],id[100100],vis[100100],sum[100100],cnt[100100];\nstd::vector<int> e[100100]; \nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n} \nint find(int x){\n\tif(x==fa[x])return x;\n\treturn fa[x]=find(fa[x]);\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]=std::max(a[i]-b[i],0ll);\n\t\tcnt[i]=a[i];\n\t\tsum[i]=b[i];\n\t\tfa[i]=id[i]=i;\n\t\tvis[i]=0;\n\t}\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\te[x].push_back(y);\n\t\te[y].push_back(x);\n\t}\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=id[i];\n\t\tvis[x]=1;\n\t\tfor(int j=0;j<e[x].size();j++){\n\t\t\tint upup=e[x][j];\n\t\t\tif(vis[upup]){\n\t\t\t\tint rx=find(x),ry=find(upup);\n\t\t\t\tif(rx!=ry){\n\t\t\t\t\tfa[ry]=rx;\n\t\t\t\t\tsum[rx]+=sum[ry];\n\t\t\t\t\tcnt[rx]=std::min(cnt[rx],cnt[ry]+std::max(0ll,a[rx]-cnt[ry]-sum[ry]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",cnt[id[n]]+sum[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <map>\n#include <set>\n#include <string>\n#include <iostream>\n#include <cassert>\n#include <cmath>\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.resize(n);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nint main() {\n        int n, m;\n        scanf(\"%d%d\", &n, &m);\n        UnionFind uf(n);\n        vector<pair<long long, int>> c(n);\n        vector<int> bs(n);\n        for (int i = 0; i < n; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                c[i] = make_pair(max(0LL, (long long) a - b), i);\n                uf.num[i] = b;\n        }\n        sort(c.begin(), c.end());\n        vector<vector<int>> g(n);\n        for (int i = 0; i < m; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        vector<long long> dp(n);\n        vector<bool> used(n, false);\n        for (int i = 0; i < n; i ++) {\n                long long mi = c[i].first;\n                int u = c[i].second;\n                for (auto v : g[u]) if (used[v]) {\n                        int ch = uf.find(v);\n                        mi = min(mi, max(dp[ch], c[i].first - uf.num[ch]));\n                }\n                used[u] = true;\n                for (auto v : g[u]) if (used[v]) {\n                        uf.unite(u, v);\n                }\n                dp[uf.find(u)] = mi;\n        }\n        printf(\"%lld\\n\", dp[uf.find(0)] + uf.num[uf.find(0)]);\n        return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const Graph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Tree = Graph;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    const int N = read<int>(), M = read<int>();\n    std::vector<ll> A(N), B(N), S(N);\n    for (int i = 0; i < N; i++) { std::cin >> A[i] >> B[i], S[i] = std::max(A[i] - B[i], 0LL); }\n    Graph G(N);\n    for (int i = 0, u, v; i < M; i++) { std::cin >> u >> v, u--, v--, G.addEdge(u, v, true); }\n    std::vector<int> ind(N);\n    std::iota(ind.begin(), ind.end(), 0);\n    std::sort(ind.begin(), ind.end(), [&](const int i, const int j) { return S[i] == S[j] ? i < j : S[i] < S[j]; });\n    std::vector<int> top(N);\n    std::iota(top.begin(), top.end(), 0);\n    UnionFind uf(N);\n    Tree T(N);\n    for (const int i : ind) {\n        for (const int to : G[i]) {\n            const int V = S[top[uf.find(to)]];\n            if (V < S[i] or (V == S[i] and top[uf.find(to)] < i)) { T.addEdge(i, top[uf.find(to)]), uf.unite(to, i), top[uf.find(i)] = i; }\n        }\n    }\n    std::vector<ll> s(N), f(N);\n    auto dfs = [&](auto&& self, const int v) -> void {\n        f[v] = S[v], s[v] = B[v];\n        for (const int to : T[v]) { self(self, to), s[v] += s[to], chmin(f[v], std::max(f[to], S[v]) - s[to]); }\n        f[v] += s[v];\n    };\n    dfs(dfs, top[uf.find(0)]);\n    std::cout << f[top[uf.find(0)]] << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\ninline char gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline int read(){\n\tint x=0; char ch=gc(); bool positive=1;\n\tfor (;!isdigit(ch);ch=gc())if(ch=='-')positive=0;\n\tfor (;isdigit(ch);ch=gc())x=x*10+ch-'0';\n\treturn positive?x:-x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n\tputchar('0'+a%10);\n}\ninline void writeln(int a){\n\tif(a<0){\n\t\ta=-a; putchar('-');\n\t}\n\twrite(a); puts(\"\");\n}\nconst int N=100005;\nvector<int> v[N];\nll ans[N],mx,sum[N];\nint n,m,vis[N],a[N],b[N],q[N],father[N];\ninline bool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\ninline int getfather(int x){\n\treturn father[x]==x?x:father[x]=getfather(father[x]);\n}\nvoid mer(int x,int y){\n\tint t1=getfather(x),t2=getfather(y);\n\tif(t1!=t2){\n\t\tsum[t2]+=sum[t1]; father[t1]=t2;\n\t\tans[t2]=min(ans[t2],ans[t1]+max((ll)0,a[t2]-sum[t1]-ans[t1]));\n\t}\n}\nint main(){\n\tn=read(); m=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read(); b[i]=read(); father[i]=q[i]=i; a[i]=max(a[i]-b[i],0);\n\t}\n\tsort(&q[1],&q[n+1],cmp);\n\tfor(int i=1;i<=m;i++){\n\t\tint a=read(),b=read();\n\t\tv[a].push_back(b); v[b].push_back(a);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint tot=0; vis[q[i]]=1; ans[q[i]]=a[q[i]]; sum[q[i]]=b[q[i]];\n\t\tfor(unsigned j=0;j<v[q[i]].size();j++)if(vis[v[q[i]][j]]){\n\t\t\tmer(v[q[i]][j],q[i]);\n\t\t}\n\t}\n\t//cout<<ans[getfather(1)]<<\" \"<<sum[getfather(1)]<<endl;\n\tcout<<ans[getfather(1)]+sum[getfather(1)]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m;\nll a[100005],b[100005],siz[100005],ans[100005],f[100005];\npll p[100005];\nvector<int> adj[100005];\n\nint getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}\n\nint main(){\n\tn=readint(); m=readint();\n\tfor(int i=1;i<=n;i++) a[i]=readint(),b[i]=readint(),chkmax(a[i],b[i]);\n\tint x,y;\n\tfor(int i=1;i<=m;i++){\n\t\tx=readint(); y=readint();\n\t\tif(x>y) swap(x,y);\n\t\tif(a[x]-b[x]>a[y]-b[y]) adj[x].push_back(y);\n\t\telse adj[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++) p[i]=mp(a[i]-b[i],i);\n\tfor(int i=1;i<=n;i++) f[i]=i,siz[i]=b[i],ans[i]=a[i]-b[i];\n\tsort(p+1,p+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=p[i].se;\n\t\tfor(auto x:adj[u]){\n\t\t\tint fx=getf(x);\n\t\t\tif(fx==u) continue;\n\t\t\tchkmin(ans[u],max(a[u]-b[u]-siz[fx],ans[fx]));\n\t\t\tsiz[u]+=siz[fx];\n\t\t\tf[fx]=u;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans[getf(1)]+siz[getf(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=100010;\nint a[maxn],b[maxn],c[maxn];\nint par[maxn],_rank[maxn];\nvector<int> init_g[maxn],g[maxn];\ninline void init(int n){\n\tfor(int i=1;i<=n;i++)\n\t\tpar[i]=i,_rank[i]=0;\n}\nint find(int x){\n\tif(par[x]==x) return x;\n\treturn par[x]=find(par[x]);\n}\ninline void unite(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x==y) return;\n\tif(_rank[x]<_rank[y])\n\t\tpar[x]=y;\n\telse{\n\t\tpar[y]=x;\n\t\tif(_rank[x]==_rank[y]) _rank[x]++;\n\t}\n}\ninline bool same(int x,int y){\n\treturn find(x)==find(y);\n}\nll sum[maxn],dp[maxn];\nint ord[maxn],root[maxn];\ninline bool cmp(const int& lhs,const int& rhs){\n\treturn c[lhs]<c[rhs];\n}\nvoid dfs(int u){\n\tsum[u]=b[u];\n\tfor(int i=0;i<(int)g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tdfs(v);\n\t\tsum[u]+=sum[v];\n\t}\n\tdp[u]=sum[u]+c[u];\n\tfor(int i=0;i<(int)g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max((ll)c[u],dp[v]));\n\t}\n}\nint main(){\n\tint n,m,u,v;\n\tscanf(\"%d%d\",&n,&m);\n\tinit(n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tc[i]=max(a[i]-b[i],0);\n\t\tord[i]=i;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tinit_g[u].push_back(v);\n\t\tinit_g[v].push_back(u);\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint u=ord[i];\n\t\troot[u]=u;\n\t\tfor(int j=0;j<(int)init_g[u].size();j++){\n\t\t\tint v=init_g[u][j];\n\t\t\tif(ord[v]<i && !same(u,v)){\n\t\t\t\tg[u].push_back(root[find(v)]);\n\t\t\t\tunite(u,v);\n\t\t\t\troot[find(u)]=u;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(ord[n]);\n\tprintf(\"%lld\\n\",dp[ord[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst long long LINF = 1ll << 62;\n\nconst int MAXN = 100005;\nconst int MAXM = 100005;\n\nlong long need[MAXN];\n\nint A[MAXN], B[MAXN], pos[MAXN], rk[MAXN];\n\nint n, m, u, v;\n\nstruct Edge\n{\n\tint to, next;\n}e[2 * MAXM];\nint head[MAXN], te = 1;\n\ninline void addE(int u, int v)\n{\n\te[++te] = (Edge){v, head[u]}, head[u] = te;\n}\n\n//dsu\nlong long sum[MAXN];\nint fa[MAXN];\n\nvoid init()\n{\n\tfor (int i = 1; i <= n; i++)\n\t\tfa[i] = i, sum[i] = B[i];\n}\n\nint find(int x)\n{\n\treturn (fa[x] == x ? x : fa[x] = find(fa[x]));\n}\n\nvoid Union(int x, int y)\n{\n\tsum[x] += sum[y];\n\tfa[y] = x;\n}\n\ninline bool cmp(const int &x, const int &y)\n{\n\treturn A[x] - B[x] < A[y] - B[y];\t\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> A[i] >> B[i];\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> u >> v;\n\t\taddE(u, v), addE(v, u);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tpos[i] = i;\n\tsort(pos + 1, pos + n + 1, cmp);\n\tfor (int i = 1; i <= n; i++)\n\t\trk[pos[i]] = i;\n\tfor (int i = 1; i <= n; i++)\n\t\tneed[i] = LINF;\n\tinit();\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint u = pos[i], x = find(u);\n\t\tfor (int j = head[u]; j != 0; j = e[j].next)\n\t\t{\n\t\t\tint v = e[j].to, y = find(v);\n\t\t\tif (x != y && rk[v] < rk[u])\n\t\t\t{\n\t\t\t\tneed[x] = min(need[x], max(need[y], max(0ll, A[u] - B[u] - sum[y])));\n\t\t\t\tUnion(x, y);\n\t\t\t}\n\t\t}\n\t\tneed[x] = min(need[x], max(0ll, (long long)(A[u] - B[u])));\n\t}\n\tlong long res = need[find(pos[n])] + sum[find(pos[n])];\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2019\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<deque>\nusing namespace std;\nnamespace mine\n{\n    typedef long long ll;\n    #define double long double\n    const int INF=0x3f3f3f3f;\n    const ll LLINF=0x3f3f3f3f3f3f3f3fll;\n    ll qread()\n    {\n        ll ans=0;char c=getchar();int f=1;\n        while(c<'0' or c>'9') {if(c=='-') f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) {num=-num;putchar('-');}\n        if(num>9) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);puts(\"\");}\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define pr pair<int,int>\n    #define PB push_back\n    #define vc vector\n    void chmax(ll &x,const ll y) {x=x>y?x:y;}\n    void chmin(ll &x,const ll y) {x=x<y?x:y;}\n    const int MAX_N=1e5+10;\n    const ll MOD=998244353;\n\t\n\tll b[MAX_N];int c[MAX_N];\n\tvc<int> son[MAX_N];\n\tll g[MAX_N];\n\tvoid dp(int x)\n\t{\n\t\tif(son[x].size())\n\t\t{\n\t\t\tfor(int t=0;t<(int)son[x].size();t++) dp(son[x][t]),b[x]+=b[son[x][t]];\n\t\t\tg[x]=LLINF;\n\t\t\tfor(int t=0;t<(int)son[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=son[x][t];\n\t\t\t\tchmin(g[x], max(g[y],(ll)c[x])+(b[x]-b[y]) );\n\t\t\t}\n\t\t}\n\t\telse g[x]=b[x]+c[x];\n\t}\n\tint pos[MAX_N];bool cmp(int x,int y){return c[x]<c[y];}\n\tvc<int> to[MAX_N];\n\tint fa[MAX_N];int findfa(int x){return x==fa[x]?x:fa[x]=findfa(fa[x]);}\n    void main()\n    {\n\t\tint n=qread(),m=qread();for(int i=1;i<=n;i++) c[i]=qread(),b[i]=qread(),c[i]=max(int(c[i]-b[i]),0);\n\t\tfor(int i=1;i<=n;i++) pos[i]=i;sort(pos+1,pos+n+1,cmp);\n\t\tfor(int i=1;i<=m;i++){int x=qread(),y=qread();to[x].PB(y);to[y].PB(x);}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint x=pos[i];fa[x]=x;\n\t\t\tfor(int t=0;t<(int)to[x].size();t++)\n\t\t\t{\n\t\t\t\tint y=to[x][t],tt=findfa(y);\n\t\t\t\tif(fa[y]!=0 and tt!=x) fa[tt]=x,son[x].PB(tt);\n\t\t\t}\n\t\t}\n\t\tdp(pos[n]);write(g[pos[n]]);\n    }\n};\nsigned main()\n{\n    srand(time(0));\n    mine::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define pb push_back\n#define mp make_pair\n#define Chkmax(a,b) a=a>b?a:b\n#define Chkmin(a,b) a=a<b?a:b\ntypedef unsigned long long uint64;\ntypedef unsigned int uint32;\ntypedef long long ll;\n\nusing namespace std;\n\nnamespace IO\n{\n    const uint32 Buffsize=1<<15,Output=1<<23;\n    static char Ch[Buffsize],*S=Ch,*T=Ch;\n    inline char getc()\n    {\n        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);\n    }\n    static char Out[Output],*nowps=Out;\n    \n    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}\n\n    template<typename T>inline void read(T&x)\n    {\n        x=0;static char ch;T f=1;\n        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;\n        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);\n        x*=f;\n    }\n\n    template<typename T>inline void write(T x,char ch='\\n')\n    {\n        if(!x)*nowps++='0';\n        if(x<0)*nowps++='-',x=-x;\n        static uint32 sta[111],tp;\n        for(tp=0;x;x/=10)sta[++tp]=x%10;\n        for(;tp;*nowps++=sta[tp--]^48);\n        *nowps++=ch;\n    }\n}\nusing namespace IO;\n\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n    FILE*DSA=freopen(\"water.in\",\"r\",stdin);\n    FILE*SDU=freopen(\"water.out\",\"w\",stdout);\n#endif\n}\n\nconst int MAXN=5e5+7;\n\nstatic int n,m;\n\nvector<int>ed[MAXN];\n\nstatic int a[MAXN],b[MAXN];\n\nvoid init()\n{\n\tread(n);read(m);\n\tRep(i,1,n)read(a[i]),read(b[i]),a[i]=max(0,a[i]-b[i]);\n\tstatic int u,v;\n\tRep(i,1,m)read(u),read(v),ed[u].pb(v),ed[v].pb(u);\n}\n\nstatic ll dp[MAXN],sm[MAXN];\n\nstatic int fa[MAXN],sta[MAXN];\n\nstatic int flg;\n\ninline int Find(int u)\n{return u==fa[u]?u:fa[u]=Find(fa[u]);}\n\nstatic int vis[MAXN];\n\ninline void getdp(int u)\n{\n\tsm[u]=b[u],dp[u]=a[u];\n\tvis[u]=1;\n\tfor(register int v:ed[u])\n\t{\n\t\tint ver=Find(v);\n\t\tif(ver!=u&&vis[v])\n\t\t{\n\t\t\tChkmin(dp[u],max(dp[ver],a[u]-sm[ver]));\n\t\t\tsm[u]+=sm[ver];\n\t\t\tfa[ver]=u;\n\t\t}\n\t}\n}\n\ninline bool cmp(int x,int y){return a[x]<a[y];}\n\ninline void solve()\n{\n\tRep(i,1,n)fa[i]=sta[i]=i;sort(sta+1,sta+n+1,cmp);\n\ta[0]=-1;\n\tRep(i,1,n)getdp(sta[i]);\n\tcout<<sm[sta[n]]+dp[sta[n]]<<endl;\n}\n\nint main()\n{\n\tinit();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p,s;\n  using P = pair<Int, Int>;\n  vector<priority_queue<P, vector<P>, greater<P> > > pq;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0),s(sz,0),pq(sz){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n    s[x]+=s[y];\n    \n    if(pq[x].size()<pq[y].size())\n      swap(pq[x],pq[y]);\n    while(!pq[y].empty()){\n      pq[x].emplace(pq[y].top());\n      pq[y].pop();\n    }\n  }\n  void add_edge(Int v,Int u,Int c){\n    v=find(v);\n    pq[v].emplace(c,u);\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m;\n  cin>>n>>m;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i]>>b[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<m;i++){\n    Int u,v;\n    cin>>u>>v;\n    u--;v--;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  \n  Int s=accumulate(b.begin(),b.end(),(Int)0);\n  auto check=[&](Int x)->Int{\n    //cout<<x<<\"-------\"<<s<<\":\"<<x-s<<endl;\n    queue<Int> q;\n    vector<Int> used(n);\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++){\n      uf.s[i]=b[i];\n      if(x-s+uf.s[i]<a[i]) continue;\n      q.emplace(i);\n      used[i]=1;\n    }\n    \n    auto ok=[&](Int v,Int u)->Int{\n      Int pv=uf.find(v);\n      Int pu=uf.find(u);\n      if(pv==pu) return 1;\n      //cout<<v<<\"->\"<<u<<\":\"<<(x-s+uf.s[pv]+b[u]>=a[u])<<\":\"<<x-s+uf.s[pv]+b[u]<<\" \"<<a[u]<<endl;\n      return (x-s+uf.s[pv]+b[u]>=a[u]);\n    };\n\n    \n    while(!q.empty()){\n      Int v=q.front();q.pop();\n      //cout<<x<<\":\"<<v<<\":\"<<uf.r[uf.find(v)]<<endl;\n      using P = pair<Int, Int>;\n      priority_queue<P,vector<P>,greater<P> > pq;\n      auto push=[&](Int u){\n\tu=uf.find(u);\n\tif(!uf.pq[u].empty())\n\t  pq.emplace(uf.pq[u].top().first,u);\n      };\n    \n      for(Int u:G[v]){\t\n\tif(ok(v,u)){\n\t  uf.unite(v,u);\n\t  if(!used[u]){\n\t    used[u]=1;\n\t    q.emplace(u);\n\t  }\n\t}else uf.add_edge(v,u,a[u]);\n\n\tif(used[u]) push(u);\n      }\n      \n      push(v);\n      while(!pq.empty()){\n\tInt c,u;\n\ttie(c,u)=pq.top();pq.pop();\n\tu=uf.find(u);\t\n\tInt flg=0;\n\twhile(!uf.pq[u].empty()){\n\t  Int d,w;\n\t  tie(d,w)=uf.pq[u].top();\n\t  if(!uf.same(u,w)&&used[w]) push(w);\n\t  if(ok(u,w)){\n\t    uf.pq[u].pop();\n\t    uf.unite(u,w);\n\t    if(!used[w]){\n\t      used[w]=1;\n\t      q.emplace(w);\n\t    }\n\t    u=uf.find(u);\n\t    flg=1;\n\t  }else break;\n\t}\n\tif(flg) push(u);\n      }\n    }\n\n    //cout<<x<<\"::::::\"<<uf.r[uf.find(0)]<<endl;\n    return uf.r[uf.find(0)]==n;\n  };\n  \n  Int l=s-1;\n  Int r=s+*max_element(a.begin(),a.end());\n  while(l+1<r){\n    Int mid=(l+r)>>1;\n    if(check(mid)) r=mid;\n    else l=mid;\n  }\n  cout<<r<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tlong long v,nxt;\n};\nnode edge[200001];\nstruct reads\n{\n\tlong long num,data;\n\tbool operator < (const reads &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nreads t[100001];\nlong long n,m,a[100001],b[100001],head[100001],len,rt[100001],sz[100001],Mx[100001],used[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nvoid add(int x,int y)\n{\n\tedge[++len].v=y;\n\tedge[len].nxt=head[x];\n\thead[x]=len;\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tt[i].num=i;\n\t\tt[i].data=a[i];\n\t\tMx[i]=max(a[i]-b[i],0ll);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>x>>y;\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tsort(t+1,t+n+1);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tused[t[i].num]=1;\n\t\tfor (int j=head[t[i].num];j>0;j=edge[j].nxt)\n\t\t\tif (a[t[i].num]>=a[edge[j].v]&&used[edge[j].v]&&find(edge[j].v)!=find(t[i].num))\n\t\t\t\tunionn(edge[j].v,t[i].num);\n\t}\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 10;\ntypedef pair<int, int> P;\nvector<int> G[N];\nP p[N];\nint fa[N], a[N], b[N], vis[N], dp[N];\nlong long sz[N];\nint F(int x) { return x == fa[x] ? x : (fa[x] = F(fa[x])); }\nint main() {\n    int n, m;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++) {\n        cin >> a[i] >> b[i];\n        p[i] = P(max(0, a[i] - b[i]), i);\n        fa[i] = i;\n        sz[i] = b[i];\n    }\n    for(int i = 0; i < m; i++) {\n        int u, v; cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    sort(p + 1, p + n + 1);\n    for(int i = 1; i <= n; i++) {\n        int x = p[i].second, mn = p[i].first;\n        vis[x] = 1;\n        for(int v : G[x]) {\n            if(vis[v]) {\n                int fv = F(v);\n                mn = min((long long)mn, max(p[i].first - sz[fv], 1LL * dp[fv]));\n            }\n        }\n        for(int v : G[x]) {\n            if(vis[v]) {\n                int fv = F(v);\n                if(fv == x) continue;\n                fa[fv] = x;\n                sz[x] += sz[fv];\n            }\n        }\n        dp[x] = mn;\n    }\n    cout << dp[F(1)] + sz[F(1)] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\n\nint n, m;\nint a[N], b[N];\nint par[N];\nbool vis[N];\nlong long sum[N], res[N];\nvector<int> G[N];\n\nint find(int u) { return u == par[u] ? u : par[u] = find(par[u]); }\n\nvoid join(int u, int v) { par[find(u)] = find(v); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i] >> b[i];\n\t\tpar[i] = i, res[i] = sum[i] = b[i];\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint u, v; cin >> u >> v;\n\t\tG[u].push_back(v), G[v].push_back(u);\n\t}\n\tvector<int> vec;\n\tfor (int i = 1; i <= n; ++i) vec.push_back(i);\n\tsort(vec.begin(), vec.end(), [&] (int x, int y) {\n\t\treturn a[x] - b[x] < a[y] - b[y];\n\t});\n\tfor (auto i : vec) {\n\t\tset<int> s;\n\t\tfor (auto j : G[i]) {\n\t\t\tif (vis[j]) s.insert(find(j));\n\t\t}\n\t\tfor (auto j : s) {\n\t\t\tjoin(j, i), sum[i] += sum[j];\n\t\t}\n\t\tif (s.size()) {\n\t\t\tlong long mn = 1e18;\n\t\t\tfor (auto j : s) {\n\t\t\t\tmn = min(mn, max(0LL + a[i] - b[i], res[j]) + sum[i] - sum[j]);\n\t\t\t}\n\t\t\tres[i] = mn;\n\t\t}\n\t\tvis[i] = 1;\n\t}\n\tcout << res[find(vec.back())];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,m;\nint a[maxn],b[maxn],ord[maxn];\nbool ok[maxn];\nvector<int>edge[maxn],vec[maxn];\nbool cmp(int x,int y){\n\treturn a[x]-b[x]<a[y]-b[y];\n}\n\nnamespace Dsu{\n\tint f[maxn],rk[maxn];\n\tll v[maxn]; \n\tvoid init(){\n\t\tREP(i,n){\n\t\t\tf[i]=i;\n\t\t\trk[i]=1;\n\t\t\tv[i]=b[i];\n\t\t}\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tif(rk[x]>rk[y])swap(x,y);\n\t\tf[x]=y;\n\t\tv[y]+=v[x];\n\t\tif(rk[x]==rk[y])rk[y]++;\n\t}\n}\n\nbool check(ll val){\n\tREP(i,n)vec[i].clear(),ok[i]=false;\n\tDsu::init();\n\tREP(i,n){\n\t\tint x=ord[i];\n\t\tif(val+b[x]>=a[x])ok[x]=true;\n\t\trep(j,int(edge[x].size())){\n\t\t\tint y=edge[x][j];\n\t\t\tll now=Dsu::v[Dsu::find(y)]+val;\n\t\t\tif(ok[y]&&now+b[x]>=a[x]){\n\t\t\t\tok[x]=true;\n\t\t\t\tint orix=Dsu::find(x),oriy=Dsu::find(y);\n\t\t\t\tDsu::merge(x,y);\n\t\t\t\trep(k,int(vec[orix].size())){\n\t\t\t\t\tDsu::merge(vec[orix][k],x);\n\t\t\t\t\tok[vec[orix][k]]=true;\n\t\t\t\t}\n\t\t\t\trep(k,int(vec[oriy].size())){\n\t\t\t\t\tDsu::merge(vec[oriy][k],y);\n\t\t\t\t\tok[vec[oriy][k]]=true;\n\t\t\t\t}\n\t\t\t\tvec[orix].clear();\n\t\t\t\tvec[oriy].clear();\n\t\t\t}\n\t\t\telse vec[Dsu::find(y)].pb(x),vec[Dsu::find(x)].pb(y);\n\t\t}\n\t}\n\tREP(i,n)if(!ok[i])return false;\n\treturn true;\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tREP(i,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\tord[i]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tREP(i,m){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t}\n\tll l=-1,r=ll(1e9);\n\twhile(r-l>1){\n\t\tll mid=l+r>>1;\n\t\tif(check(mid))r=mid;\n\t\telse l=mid;\n\t}\n\tREP(i,n)r+=b[i]; \n\tprintf(\"%lld\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,t) for(int i=s;i<=(t);++i) \nusing namespace std; \n\nconst int N=1e5+50; \n\nbool vis[N]; \nint n,m,a[N],b[N],p[N],id[N]; \nlong long sum[N],f[N]; \nvector<int> g[N];\n\nint find(int x){ return p[x]==x?x:p[x]=find(p[x]); }\n\nint main(int argc,char *argv[]){\n\tfreopen(\"dat.in\",\"r\",stdin); \n\tscanf(\"%d%d\",&n,&m); \n\trep(i,1,n){\n\t\tscanf(\"%d%d\",&a[i],&b[i]); \n\t\ta[i]=max(0,a[i]-b[i]); \n\t\tsum[i]=b[i];\n\t}\n\trep(i,1,m){\n\t\tint u,v; \n\t\tscanf(\"%d%d\",&u,&v); \n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\trep(i,1,n)p[i]=i,id[i]=i;\n\tsort(id+1,id+n+1,[](int x,int y){ return a[x]<a[y]; }); \n\trep(k,1,n){\n\t\tint v=id[k]; \n\t\tvis[v]=true;\n\t\tvector<int> son;\n\t\tfor(int d:g[v])if(vis[d]&&find(d)!=find(v)){\n\t\t\tsum[v]+=sum[find(d)];\n\t\t\tson.push_back(find(d)); \n\t\t\tp[find(d)]=find(v); \n\t\t}\n\t\tf[v]=sum[v]+a[v];\n\t\t\n\t\tfor(int d:son){\n\t\t\tf[v]=min(f[v],sum[v]-sum[d]+max(1ll*a[v],f[d])); \n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[id[n]]);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,u,v,a[100001],b[100001],c[100001],s[100001],d[100001];\nlong long x[100001][451],y[100005][451],f[100001],sr[100001];\nbool bo[100001];\ninline long long read()\n{\n    long long sum=0,x=1;\n    char ch=getchar();\n    while (ch<'0'||ch>'9')\n\t{\n        if (ch=='-')\n          x=-1;\n        ch=getchar();\n    }\n    while (ch>='0'&&ch<='9')\n\t{\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum*x;\n}\ninline void write(long long x)    \n{\n    if (x<0)\n    {\n    \tputchar('-');\n    \tx=-x;\n\t}\n\tif (x>9)\n      write(x/10);\n    putchar(x%10+'0');\n}\ninline bool cmp(long long x,long long y)\n{\n\treturn c[x]<c[y];\n}\ninline long long find(long long x)\n{\n\tif (x==f[x])\n\t  return x;\n\treturn f[x]=find(f[x]);\n}\ninline void dfs(long long u)\n{\n\ts[u]=b[u];\n\tsr[u]=1e18;\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t{\n\t\tdfs(y[u][i]);\n\t\ts[u]+=s[y[u][i]];\n\t}\n\tfor (register long long i=1;i<=y[u][0];++i)\n\t  sr[u]=min(sr[u],s[u]-s[y[u][i]]+max(c[u],sr[y[u][i]]));\n\tif (sr[u]==1e18)\n\t  sr[u]=b[u]+c[u];\n}\nint main()\n{\n\tn=read();m=read();\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();b[i]=read();\n\t\tif (a[i]-b[i]>0)\n\t\t  c[i]=a[i]-b[i];\n\t\td[i]=f[i]=i;\n\t}\n\tsort(d+1,d+1+n,cmp);\n\tfor (register long long i=1;i<=m;++i)\n\t{\n\t\tu=read();v=read();\n\t\tx[u][++x[u][0]]=v;\n\t\tx[v][++x[v][0]]=u;\n\t}\n\tfor (register long long i=1;i<=n;++i)\n\t{\n\t\tlong long u=d[i];\n\t\tfor (register long long j=1;j<=x[u][0];++j)\n\t\t{\n\t\t\tlong long v=x[u][j],vv=find(v);\n\t\t\tif (bo[v]&&vv!=u)\n\t\t\t{\n\t\t\t\ty[u][++y[u][0]]=vv;\n\t\t\t\tf[vv]=u;\n\t\t\t}\n\t\t}\n\t\tbo[u]=1;\n\t}\n\tdfs(d[n]);\n\twrite(sr[d[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAX_N 100000\n\nusing namespace std;\n\ntypedef long long lint;\n\nint n, m;\n\nlint add[MAX_N + 1];\nlint cost[MAX_N + 1];\nint tata[MAX_N + 1];\n\nvector <int> g[MAX_N + 1];\n\nvoid adda(int a, int b)\n{\n    g[a].push_back(b);\n}\n\nstruct elem\n{\n    int a, b, need, i;\n};\n\nstruct cmp\n{\n    bool operator() (const elem &a, const elem &b) const\n    {\n        return (a.need < b.need);\n    }\n};\n\nelem v[MAX_N + 1];\n\nint getTata(int a)\n{\n    return (tata[a] < 0 ? a : tata[a] = getTata(tata[a]));\n}\n\nint main()\n{\n    cin >> n >> m;\n\n    int i;\n    for(i = 1; i <= n; i ++)\n    {\n        cin >> v[i].a >> v[i].b;\n        v[i].need = v[i].a - v[i].b;\n        v[i].i = i;\n    }\n\n    int a, b;\n    for(i = 1; i <= m; i ++)\n    {\n        cin >> a >> b;\n\n        adda(a, b);\n        adda(b, a);\n    }\n\n    sort(v + 1, v + n + 1, cmp());\n\n    tata[0] = -1;\n    for(i = 1; i <= n; i ++)\n    {\n        int cr = v[i].i;\n        cost[cr] = v[i].b;\n        add[cr] = max(0, v[i].need);\n        tata[cr] = -1;\n      //  cout << cr << \" \" << cost[cr] << \"++++++++\\n\";\n\n        for(auto u : g[cr])\n        {\n            int t = getTata(u);\n            if(t != 0 && t != cr)///If t == 0 the vertex is on an upper level and if t == v[i].i the vertex has already been used, cause we work only with the old root of it's subtree\n            {\n             //   cout << \"BAGA PE \" << t << \" \" << cost[t] << \"\\n\";\n                u = t;\n                tata[u] = cr;\n                cost[cr] += cost[u];\n                add[cr] = min(add[cr], max(add[u], v[i].need - cost[u]));///First time we donate to cr then to u, so we have as an extra all its cost or his need\n            }\n        }\n    }\n\n    cout << cost[v[n].i] + add[v[n].i] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <list>\n#include <string>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <deque>\n#include <stack>\n#include <cassert>\nusing namespace std;\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define ALL(x) (x).begin(),(x).end()\n#define CASET2 int ___T, case_n = 1; scanf(\"%d \", &___T); while ((___T > 0 ? printf(\"Case #%d:\\n\", case_n++) : 0), ___T-- > 0)\n#define CASET1 int ___T, case_n = 1; scanf(\"%d \", &___T); while ((___T > 0 ? printf(\"Case #%d: \", case_n++) : 0), ___T-- > 0)\n#define CASET int ___T; scanf(\"%d \", &___T); while (___T-- > 0)\n#define SZ(X) ((int)(X).size())\n#define LEN(X) strlen(X)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=int(b);i++)\n#define PER1(i,a,b) for(int i=(a);i>=(b);i--)\n#define REPL(i,x) for(int i=0;x[i];i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define RI1(x) scanf(\"%d\",&x)\n#define RI2(x,y) RI1(x), RI1(y)\n#define RI3(x,y...) RI1(x), RI2(y)\n#define RI4(x,y...) RI1(x), RI3(y)\n#define RI5(x,y...) RI1(x), RI4(y)\n#define RI6(x,y...) RI1(x), RI5(y)\n#define GET_MACRO(_1, _2, _3, _4, _5, _6, NAME, ...) NAME\n#define RI(argv...) GET_MACRO(argv, RI6, RI5, RI4, RI3, RI2, RI1)(argv)\n#define DRI(argv...) int argv;RI(argv)\n#define WRI(argv...) while (RI(argv) != EOF)\n#define DWRI(x...) int x; WRI(x)\n#define RS(x) scanf(\"%s\",x)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define X first\n#define Y second\n#define V(x) vector<x >\n\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef long long LL;\nconst int INF = 1000000000;\n\nvoid print(int i) { printf(\"%d\", i); }\nvoid print(LL i);\ntemplate<class T> void PI(T i) { print(i); puts(\"\"); }\ntemplate<class T> void PIS(T i) { print(i); printf(\" \"); }\n\ntemplate<class T>\nvoid PV(T const &v, int N) {\n    REP(i, N) {\n        print(v[i]);\n        printf(\"%c\", i == N-1 ? '\\n' : ' ');\n    }\n}\n\ntemplate<class T> void PV(T const &v) { PV(v, SZ(v)); }\n\ntemplate<class T, class S> bool has_bit(T mask, S i) { return (mask >> i) & 1; }\nlong long shift(int i) { return 1ll << i; }\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\nint popcount(int x) { return __builtin_popcount(x); } \nint popcount(long long x) { return __builtin_popcountll(x); } \n\n#include <unordered_set>\n#include <unordered_map>\n#define EB emplace_back\n#define RL(x) scanf(\"%lld\", &(x))\n#define PL(x) printf(\"%lld\\n\", x)\n#define DRL(x) LL x; RL(x)\nclass DisjointSet {\n    VI par, _size;\n    int N;\n\n    void init() {\n        for(int i = 0; i < N; i++) {\n            par[i] = i;\n            _size[i] = 1;\n        }\n    }\n\npublic:\n    DisjointSet(int _N): par(_N), _size(_N), N(_N) {\n        init();\n    }\n\n    int find(int x) {\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(_size[x] < _size[y]) {\n            par[x] = y;\n            _size[y] += _size[x];\n        } else {\n            par[y] = x;\n            _size[x] += _size[y];\n        }\n    }\n\n    int size(int x) {\n        return _size[find(x)];\n    }\n};\n\nint main() {\n    DRI(N, M);\n    VI A(N), B(N);\n    V(PII) C(N);\n    REP(i, N) {\n        RI(A[i], B[i]);\n        C[i].X = max(0, A[i] - B[i]);\n        C[i].Y = i;\n    }\n    V(VI) adj(N);\n    while (M--) {\n        DRI(u, v);\n        adj[u-1].PB(v-1);\n        adj[v-1].PB(u-1);\n    }\n    sort(ALL(C));\n    DisjointSet ds(N);\n    VI used(N), sum_b(N), root(N);\n    V(LL) dp(N, LLONG_MAX);\n    REP(i, N) {\n        root[i] = i;\n    }\n    for (auto &pr : C) {\n        int v = pr.Y;\n        used[v] = true;\n        unordered_set<int> comps;\n        sum_b[v] = B[v];\n        for (int u : adj[v]) {\n            if (ds.find(u) == ds.find(v)) continue;\n            u = root[ds.find(u)];\n            comps.insert(u);\n            sum_b[v] += sum_b[u];\n            int x = ds.find(v), y = ds.find(u);\n            if (x != y) {\n                ds.unite(v, u);\n                root[ds.find(v)] = max(C[root[x]], C[root[y]]).Y;\n            }\n        }\n        if (comps.empty()) {\n            dp[v] = max(A[v], B[v]);\n        }\n        for (int u : comps) {\n            dp[v] = min(dp[v], sum_b[v] - sum_b[u] + max(dp[u], (LL)C[v].X));\n        }\n    }\n    PL(dp[root[ds.find(0)]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i, v.size()){ cout << v[i] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;}\n#define pb push_back\n#define int long long\n#define INF 1000000000000000000\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\ntemplate<typename T> void readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readv_m1(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n\nint mod = 1000000007;\n//int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n#define AddMult(x, y, z) x = (x + (y) * (z)) % mod\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost = 0){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost = 0){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n};\n\nclass Union_find\n{\npublic:\n    vector<int> par;\n    vector<int> sz, ans, get;\n\n    Union_find(int N, vec A, vec B){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        ans = A;\n        get = B;\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        int tmp = ans[x];\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        get[x] += get[y];\n        ans[x] = tmp;\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n    void unite2(int x, int y, vec &A){\n        if(is_union(x, y)) return;\n        x = find(x); y = find(y);\n        Min(ans[x], max(ans[y], A[x] - get[y]));\n        unite(x, y);\n\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    Graph G(N);\n    vec A(N), B(N);\n    pairs p(N);\n    REP(i, N){\n        cin >> A[i] >> B[i];\n        A[i] = max(0LL, A[i] - B[i]);\n        p[i] = Pii(A[i], i);\n    }\n    Sort(p);\n    int U, V;\n    REP(i, M){\n        cin >> U >> V;\n        G.add_edge2(U - 1, V - 1);\n    }\n\n    Union_find UF(N, A, B);\n    bools used(N, false);\n    REP(i, N){\n        int i0 = p[i].second;\n        for(auto e: G.G[i0]) if(used[e.to]) UF.unite2(i0, e.to, A);\n        used[i0] = true;\n    }\n    int ans = UF.ans[p[N - 1].second];\n    REP(i, N) ans += B[i];\n    cout << ans << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint N, M;\nint A[100005], B[100005], TT[100005], R[100005];\nvector <int> G[100005];\nint Use[100005];\nmap <pair <int, int>, int> X;\nlong long sum;\nint Max;\nset <pair <int, int> > S;\nvoid Read()\n{\n    cin >> N >> M;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i] >> B[i], sum += B[i], Max = max(Max, A[i]);\n    for(int i = 1; i <= M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        G[x].push_back(y);\n        G[y].push_back(x);\n        X[make_pair(x, y)] = 1;\n        X[make_pair(y, x)] = 1;\n    }\n}\nint Father(int x)\n{\n    int init = x;\n    while(TT[x] != x)\n    {\n        x = TT[x];\n    }\n    while(init != x)\n    {\n        int nxt = TT[init];\n        TT[init] = x;\n        init = nxt;\n    }\n    return x;\n}\n\nvoid Unite(int x, int y)\n{\n    if(x == y)\n        return;\n    if(R[x] < R[y])\n    {\n        TT[x] = y;\n    }\n    else\n        TT[y] = x;\n    if(R[x] == R[y])\n        ++R[x];\n}\nbool check(long long W)\n{\n    if(W == 6)\n    {\n        int x;\n        x = 0;\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        S.insert(make_pair(A[i], i));\n        TT[i] = i;\n        R[i] = 1;\n        Use[i] = 0;\n        //V[i].clear();\n    }\n    queue <int> Q;\n    vector <pair <int, int> > Aux;\n    for(int i = 1; i <= N; i++)\n    {\n        Aux.push_back(make_pair(A[i] - B[i], i));\n    }\n    sort(Aux.begin(), Aux.end());\n    for(int i = 1; i <= N; i++)\n    {\n        if(W - (sum - B[i]) >= A[i] && Use[i] == 0)\n        {\n            Use[i] = 1;\n            Q.push(i);\n            //S.erase(make_pair(A[i], i));\n            long long total = W - (sum - B[i]);\n            //auto it = S.begin();\n            int point = 0;\n            while(!Q.empty())\n            {\n                int node = Q.front();\n                Q.pop();\n                for(int i = 0; i < G[node].size(); i++)\n                {\n                    int neighb = G[node][i];\n                    if(A[neighb] - B[neighb] <= total && Father(neighb) != Father(node))\n                    {\n                        Unite(Father(neighb), Father(node));\n                        total += B[neighb];\n                        if(Use[neighb] == 0)\n                        Q.push(neighb);\n                        Use[neighb] = 1;\n                        //S.erase(make_pair(A[neighb], neighb));\n                    }\n                }\n                while(point < Aux.size() && Aux[point].first <= total)\n                {\n                    int n = Aux[point].second;\n                    if(Use[n] == 0)\n                    for(int j = 0; j < G[node].size(); j++)\n                    {\n                        int neighb = G[node][j];\n                        if(Father(neighb) == Father(node))\n                        {\n                            Unite(Father(n), Father(node));\n                            Use[neighb] = 1;\n                            Q.push(neighb);\n                            total += B[neighb];\n                        }\n                    }\n                    ++point;\n                }\n            }\n            vector <pair <int, int> > Aux2;\n            for(int j = 0; j < Aux.size(); j++)\n                if(Use[Aux[j].second] == 0)\n                    Aux2.push_back(Aux[j]);\n            Aux.clear();\n            Aux = Aux2;\n        }\n    }\n    for(int i = 1; i <= N; i++)\n        if(Father(i) != Father(1))\n            return 0;\n    return 1;\n}\n\nvoid Solve()\n{\n    long long left = max(1LL * Max, sum), right = 10000000000000000, sol = right, mid;\n    while(left <= right)\n    {\n        mid = (left + right) / 2;\n        if(check(mid))\n        {\n            sol = mid;\n            right = mid - 1;\n        }\n        else\n            left = mid + 1;\n    }\n    cout << sol << \"\\n\";\n}\nint main()\n{\n    Read();\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100'009;\n\nint p[N];\n\nint find(int x) {\n  if (p[x] != x) {\n    p[x] = find(p[x]);\n  }\n  return p[x];\n}\n\nset<pair<int, int>> s[N];\nlong long sum[N];\nbool was[N];\n\nvoid join(int &root, int y) {\n  int py = find(y);\n  if (py == root) {\n    return;\n  }\n  if ((int)s[py].size() > (int)s[root].size()) {\n    swap(root, py);\n  }\n  p[py] = root;\n  sum[root] += sum[py];\n  for (auto &e : s[py]) {\n    if (!was[e.second]) {\n      s[root].insert(e);\n    }\n  }\n}\n\nint n;\nint a[N];\nint b[N];\nint w[N];\nvector<int> g[N];\n\nbool can(int ss) {\n  for (int i = 0; i < n; ++i) {\n    w[i] = max(0, a[i] - ss - b[i]);\n    p[i] = i;\n    was[i] = false;\n    s[i].clear();\n  }\n  for (int i = 0; i < n; ++i) {\n    if (was[i] || w[i] != 0) {\n      continue;\n    }\n    sum[i] = 0;\n    s[i].emplace(w[i], i);\n    int root = i;\n    while (!s[root].empty()) {\n      int x = s[root].begin()->second;\n      if (sum[root] < w[x]) {\n        break;\n      }\n      was[x] = true;\n      p[x] = root;\n      s[root].erase(s[root].begin());\n      sum[root] += b[x];\n      for (int y : g[x]) {\n        if (!was[y]) {\n          s[root].emplace(w[y], y);\n        } else {\n          join(root, y);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < n; ++i) {\n    if (!was[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n  int m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d %d\", a + i, b + i);\n  }\n  for (int i = 0; i < n; ++i) {\n    g[i].clear();\n  }\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    --x;\n    --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ll = -1, rr = 1'000'000'000;\n  while (rr - ll > 1) {\n    int ss = (ll + rr) / 2;\n    if (can(ss)) {\n      rr = ss;\n    } else {\n      ll = ss;\n    }\n  }\n  long long tot = 0;\n  for (int i = 0; i < n; ++i) {\n    tot += b[i];\n  }\n  printf(\"%lld\\n\", tot + rr);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nint n,m,ed,a[N],fir[N],vis[N],b[N],id[N],c[N],f[N];\nll sum[N],g[N];\nstruct E{int v,nxt;}e[N*2];  \nvoid adde(int x,int y){\n\te[++ed].v=y;e[ed].nxt=fir[x];fir[x]=ed;\n}\nbool cmp(int x,int y){\n\treturn c[x]<c[y]; \n} \nint F(int x){return x==f[x]?x:f[x]=F(f[x]);}\nint main(){\n\t//freopen(\"aa.in\",\"r\",stdin);\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",a+i,b+i);\n\t\tc[i]=max(a[i]-b[i],0);\t\n\t}\n\tfor(i=1;i<=m;++i){\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tadde(x,y);adde(y,x);\n\t}\n\tfor(i=1;i<=n;++i)f[i]=id[i]=i,g[i]=c[i],sum[i]=b[i];\n\tsort(id+1,id+1+n,cmp);\n\tfor(i=1;i<=n;++i){\n\t\tint x=id[i];vis[x]=1;\n\t\tfor(j=fir[x];j;j=e[j].nxt)if(vis[e[j].v]){\n\t\t\tint y=e[j].v;\n\t\t\tif(x==F(y))continue;\n\t\t\t//printf(\"%d %d\\n\",x,y);\n\t\t\t//printf(\"con %d %d ,f %d %d : %d %d\\n\",x,y,f[x],f[y],sum[f[x]],sum[f[y]]);\n\t\t\tg[x]=min(g[x],g[f[y]]+max(c[x]-g[f[y]]-sum[f[y]],0LL));\n\t\t\t//printf(\"g %lld\\n\",g[f[x]]);\t\t\n\t\t\tsum[x]+=sum[f[y]];\n\t\t\tf[f[y]]=x;\n\t\t}\n\t} \n\t//printf(\"fin sum %lld\\n\",sum[F(1)]); \n\tll ans=g[F(1)]+sum[F(1)];\n\tcout<<ans<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#define pb push_back\n#define forall(x,i) for (int i=0;i<x.size();i++)\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\ntypedef long long ll;\n\nint n,m;\nint A[100010],B[100010],C[100010];\nint id[100010];\nbool cmp(int x,int y){return C[x]<C[y];}\nstruct Edge{\n\tint to,nxt;\n}edge[200010];\nint cnt=1,last[100010];\ninline void addedge(int x,int y){\n\tedge[++cnt]=(Edge){y,last[x]},last[x]=cnt;\n\tedge[++cnt]=(Edge){x,last[y]},last[y]=cnt;\n}\nll S[100010],f[100010];\nbool vis[100010];\nint fat[100010];\nint find(int x){return fat[x]?fat[x]=find(fat[x]):x;}\nint main()\n{\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;i++){\n\t\tA[i]=read(),B[i]=read();\n\t\tA[i]=max(A[i],B[i]);\n\t\tC[i]=A[i]-B[i];\n\t\tid[i]=i;\n\t}\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tstatic int e[100010],top; top=0;\n\t\tint x=id[i]; vis[x]=1;\n\t\tS[x]=B[x];\n\t\tfor (int j=last[x],y;j;j=edge[j].nxt){\n\t\t\ty=edge[j].to;\n\t\t\tif (!vis[y]||x==find(y)) continue;\n\t\t\tint k=find(y); S[x]+=S[k]; fat[k]=x;\n\t\t\te[++top]=k;\n\t\t}\n\t\tf[x]=S[x]+C[x];\n\t\tfor (int j=1;j<=top;j++){\n\t\t\tint k=e[j];\n\t\t\tf[x]=min(f[x],S[x]-S[k]+max(0LL+C[x],f[k]));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",f[id[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint x,y;\n\tll w;\n}e[N<<1];\nstruct P{\n\tll a,b;\n}a[N];\nint n,m,fa[N];\nll siz[N];\nbool cmp(edge a,edge b){\n\treturn a.w<b.w;\n}\nint find(int k){\n\tif(fa[k]!=k) fa[k]=find(fa[k]);\n\treturn fa[k];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&a[i].a,&a[i].b);\n\tif(n==1) return printf(\"%lld\",a[1].b),0;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&e[i].x,&e[i].y);\n\t\te[i].w=max(a[e[i].x].a-a[e[i].x].b,a[e[i].y].a-a[e[i].y].b);\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tll l=0,r=1e17,mid,ans;\n\twhile(l<=r){\n\t\tmid=l+r>>1;\n\t\tfor(int i=1;i<=n;i++) fa[i]=i,siz[i]=a[i].b;\n\t\tll mx=-1e17;\n\t\tfor(int i=1;i<=n;i++) if(mid+a[i].b>=a[i].a) mx=max(mx,mid+a[i].b);\n\t\tif(mx<0){\n\t\t\tl=mid+1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=m&&e[i].w<=mx;i++){\n\t\t\tint x=find(e[i].x),y=find(e[i].y);\n\t\t\tif(x!=y){\n\t\t\t\tsiz[x]+=siz[y];\n\t\t\t\tfa[y]=x;\n\t\t\t\tmx=max(mx,mid+siz[x]);\n\t\t\t}\n\t\t}\n\t\tbool t=1;\n\t\tfor(int i=1;i<=n;i++) if(find(i)!=find(1)){\n\t\t\tt=0;break;\n\t\t}\n\t\tif(t) ans=mid+siz[find(1)],r=mid-1;\n\t\telse l=mid+1;\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\n\nvector<int> e[_];\ninline void adde(int a,int b){e[a].emplace_back(b);}\ninline void addde(int a,int b){adde(a,b),adde(b,a);}\n\nint bfa[_];\nint findbfa(int x){return bfa[x]==x?x:bfa[x]=findbfa(bfa[x]);}\n\nint n,m,ps[_];bool ed[_]={0};\nlint lim[_],los[_],res[_],slos[_]={0},f[_];\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty(),m=ty();\n\tfor(int i=1;i<=n;i++)lim[i]=ty(),los[i]=ty(),res[i]=max(lim[i]-los[i],0);\n\tfor(int i=1,a,b;i<=m;i++)a=ty(),b=ty(),addde(a,b);\n\n\tfor(int i=1;i<=n;i++)ps[i]=i;\n\tsort(ps+1,ps+n+1,[](int a,int b){return res[a]<res[b];});\n\n\tfor(int i=1;i<=n;i++)bfa[i]=i,slos[i]=los[i],f[i]=res[i];\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a=ps[i];ed[a]=1;\n\t\tfor(auto b:e[a])\n\t\t{\n\t\t\tif(!ed[b])continue;\n\t\t\tint aa=findbfa(a),bb=findbfa(b);\n\t\t\tif(aa==bb)continue;\n\t\t\tbfa[bb]=aa,slos[aa]+=slos[bb];\n\t\t\tf[aa]=min(f[aa],max(f[bb],res[aa]-slos[bb]));\n\t\t}\n\t}\n\n\tcout<<slos[findbfa(1)]+f[findbfa(1)]<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nconst int N = 1e5 + 5;\ntypedef long long ll;\nconst ll INF = 0x3f3f3f3f3f3f3f3f; \nusing namespace std;\n\nint n, m, a[N], b[N], id[N], pa[N], vis[N];\nll f[N], sum[N]; \nvector<int> g[N], son; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint getf(int x) { return pa[x] == x ? x : pa[x] = getf(pa[x]); }\n\nbool cmp(int x, int y) { return a[x] < a[y]; }\n\nint main()\n{\n\tn = read <int> (), m = read <int> ();\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\ta[i] = read <int> (), b[i] = read <int> ();\n\t\ta[i] = max(a[i] - b[i], 0), id[i] = pa[i] = i; \n\t}\n\tsort(id + 1, id + n + 1, cmp);\n\tfor(int u, v, i = 1; i <= m; i++)\n\t\tu = read <int> (), v = read <int> (), g[u].push_back(v), g[v].push_back(u);\n\tfor(int u, i = 1; i <= n; i++)\n\t{\n\t\tson.clear(), u = id[i];\n\t\tvis[u] = 1, sum[u] = b[u];\n\t\tfor(int v, j = 0; j < g[u].size(); j++)\n\t\t{\n\t\t\tv = g[u][j]; if(!vis[v] || getf(v) == getf(u)) continue;\n\t\t\tsum[u] += sum[getf(v)], son.push_back(getf(v)), pa[getf(v)] = getf(u); \n\t\t}\n\t\tif(!son.size()) { f[u] = a[u] + b[u]; continue; }\n\t\tf[u] = INF; \n\t\tfor(int v, j = 0; j < son.size(); j++)\n\t\t\tv = son[j], f[u] = min(f[u], sum[u] - sum[v] + max(1ll * a[u], f[v])); \n\t}\n\tprintf(\"%lld\\n\", f[id[n]]); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#define MAXN 100010\n\nint n, m, a[MAXN], b[MAXN], c[MAXN], p[MAXN];\nstruct edge {\n    int u, v, w;\n    inline friend bool operator<(const edge &a, const edge &b) {\n        return a.w < b.w;\n    }\n} e[MAXN];\ninline int find(int x) { return x == p[x] ? x : p[x] = find(p[x]); }\nstd::vector<int> next[MAXN];\nlong long sum[MAXN];\n\nlong long dp(int x) {\n    long long ret = c[x];\n    sum[x] = b[x];\n    for (int y : next[x]) {\n        long long res = dp(y);\n        ret = std::min(ret, std::max(0LL + c[x], res) - sum[y]);\n        sum[x] += sum[y];\n    }\n    return ret + sum[x];\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n        a[i] = std::max(a[i], b[i]);\n        c[i] = a[i] - b[i];\n        p[i] = i;\n    }\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d%d\", &e[i].u, &e[i].v);\n        e[i].w = std::max(c[e[i].u], c[e[i].v]);\n    }\n    std::sort(e + 1, e + m + 1);\n    for (int i = 1; i <= m; i++) {\n        int u = e[i].u, v = e[i].v;\n        if (find(u) == find(v)) continue;\n        if (c[u] < c[v]) std::swap(u, v);\n        next[find(u)].push_back(find(v));\n        p[find(v)] = find(u);\n    }\n    printf(\"%lld\\n\", dp(find(1)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n\nint N, M;\nint A[100000], B[100000];\nvector<int> G[100000];\nint U[100000], R[100000];\nint repr[100000];\n\nint find(int x) {\n  if (U[x] == x) return x;\n  return U[x] = find(U[x]);\n}\n\nvoid unite(int x, int y) {\n  x = find(x), y = find(y);\n  if (x == y) return;\n  if (R[x] < R[y]) swap(x, y);\n  U[y] = x;\n  R[x] += R[y];\n  R[y] = 0;\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\nvector<int> G2[100000];\nbool used[100000];\nlong long dp[100000], sum[100000];\n\nvoid dfs(int x) {\n  sum[x] = B[x];\n  if (G2[x].empty()) dp[x] = B[x];\n  for (int t : G2[x]) {\n    dfs(t);\n    sum[x] += sum[t];\n  }\n  //dp[x] = max(dp[x], sum[x]);\n  for (int t : G2[x]) {\n    dp[x] = min(dp[x], max(dp[t] + (sum[x]-sum[t]), max(A[x]+sum[x]-B[x]-sum[t], A[t]+sum[x]-sum[t])));\n  }\n  dp[x] = min(dp[x], sum[x]-B[x]+max(A[x], B[x]));\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N >> M;\n  rep(i, N) cin >> A[i] >> B[i];\n  rep(i, M) {\n    int a, b;\n    cin >> a >> b;\n    a--, b--;\n    G[a].pb(b);\n    G[b].pb(a);\n  }\n  rep(i, N) U[i] = i, R[i] = 1, repr[i] = i;\n  vector<P> ord;\n  rep(i, N) ord.pb(P(A[i], i));\n  sort(all(ord));\n  for (P p : ord) {\n    int x = p._2;\n    used[x] = true;\n    for (int t : G[x]) if (used[t] && !same(x, t)) {\n      assert(repr[find(x)] == x);\n      int c = repr[find(t)];\n      unite(x, t);\n      repr[find(x)] = x;\n      G2[x].pb(c);\n      //cout<<x<<\"->\"<<c<<\"\\n\";\n    }\n  }\n  rep(i, N) dp[i] = INF;\n  int root = ord.back()._2;\n  assert(root == repr[find(0)]);\n  dfs(root);\n  long long m = dp[root];\n  rep(i, N) m = max(m, A[i]);\n  cout << m << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,par[100005],fa[100005];\nlong long a[100005],b[100005],c[100005],s[100005],ans[100005];\nvector<int>E[100005],E1[100005];\nbool vis[100005];\nbool cmp(int x,int y){\n\treturn c[x]<c[y];\n}\nint find(int x){\n\tif(x!=fa[x])fa[x]=find(fa[x]);\n\treturn fa[x];\n}\nvoid dfs(int u){\n\ts[u]=b[u];ans[u]=1e9;\n\tfor(int i=0;i<E1[u].size();i++){\n\t\tint v=E1[u][i];\n\t\tdfs(v);\n\t\ts[u]+=s[v];\n\t}\n\tfor(int i=0;i<E1[u].size();i++){\n\t\tint v=E1[u][i];\n\t\tans[u]=min(ans[u],s[u]-s[v]+max(c[u],ans[v]));\n\t} \n\tif(ans[u]==1e9)ans[u]=b[u]+c[u];\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\tc[i]=max(0LL,a[i]-b[i]);\n\t\tpar[i]=fa[i]=i;\n\t}\n\tsort(par+1,par+n+1,cmp);\n\twhile(m--){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tE[u].push_back(v);\n\t\tE[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint u=par[i];\n\t\tfor(int j=0;j<E[u].size();j++){\n\t\t\tint v=E[u][j];\n\t\t\tif(vis[v]&&find(v)!=u){\n\t\t\t\tE1[u].push_back(find(v));\n\t\t\t\tfa[find(v)]=u;\n\t\t\t}\n\t\t}\n\t\tvis[u]=1;\n\t}\n\tdfs(par[n]);\n\tprintf(\"%lld\\n\",ans[par[n]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100000\nusing namespace std;\ntypedef long long lnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, m; lnt s[MAX_N+5], f[MAX_N+5];\nvector <int> G[MAX_N+5]; bool mrk[MAX_N+5];\nint a[MAX_N+5], b[MAX_N+5], p[MAX_N+5], fa[MAX_N+5];\nbool cmp(const int &x, const int &y) {return a[x] < a[y];}\nint getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(a[i]), read(b[i]), a[i] = max(a[i]-b[i], 0);\n\tfor (int i = 1, u, v; i <= m; i++)\n\t\tread(u), read(v), G[u].push_back(v), G[v].push_back(u);\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i] = fa[i] = i, f[i] = a[i], s[i] = b[i];\n\tsort(p+1, p+n+1, cmp);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint u, fu, fv; mrk[u = p[i]] = true;\n\t\tfor (int v : G[u]) if (mrk[v] && ((fu = getf(u)) ^ (fv = getf(v))))\n\t\t\tfa[fv] = fu, s[fu] += s[fv], f[fu] = min(f[fu], max(f[fv], a[fu]-s[fv]));\n\t}\n\treturn printf(\"%lld\\n\", f[getf(1)]+s[getf(1)]), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long LL;\nusing namespace std;\nconst int N=1e5+5;\nint n,m,fa[N],p[N];\nLL sum[N],f[N],a[N],b[N];\nint head[N],ce;\nbool vis[N];\nstruct edge{int to,nxt;} e[N<<1];\nbool cmp(int x,int y) {return a[x]<a[y];}\nvoid adde(int x,int y) {e[++ce].to=y,e[ce].nxt=head[x],head[x]=ce;}\nint find(int x)\n{\n\tif(x==fa[x]) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\ta[i]=max(a[i]-b[i],0ll);\n\t\tp[i]=fa[i]=i,f[i]=a[i],sum[i]=b[i];\n\t}\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadde(x,y); adde(y,x);\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint u=p[i]; vis[u]=1;\n\t\tfor(int j=head[u];j;j=e[j].nxt)\n\t\t{\n\t\t\tint v=e[j].to;\n\t\t\tif(!vis[v]) continue;\n\t\t\tint x=find(u),y=find(v);\n\t\t\tif(x!=y)\n\t\t\t{\n\t\t\t\tfa[y]=x,sum[x]+=sum[y];\n\t\t\t\tf[x]=min(f[x],max(f[y],a[x]-sum[y]));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",f[find(1)]+sum[find(1)]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 1e5 + 10;\nstruct data {\n  int nt, to;\n} a[N << 1];\nll A[N], B[N], dp[N], s[N];\nint p[N], f[N], vs[N];\nint head[N], cnt = 0;\n\nvoid add(int x, int y) {\n  a[++cnt].to = y;\n  a[cnt].nt = head[x];\n  head[x] = cnt;\n}\n\nbool cmp(int x, int y) {\n  return A[x] < A[y];\n}\n\nint find(int k) {\n  return f[k] == k ? f[k] : f[k] = find(f[k]);\n}\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= n; ++i) {\n    p[i] = f[i] = i;\n    scanf(\"%lld%lld\", &A[i], &B[i]);\n    s[i] = B[i];\n    dp[i] = A[i] = max(A[i] - B[i], 0ll);\n  }\n  sort(p + 1, p + 1 + n, cmp);\n  for(int i = 1, x, y; i <= m; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    add(x, y), add(y, x);\n  }\n  for(int o = 1; o <= n; ++o) {\n    int u = p[o];\n    vs[u] = 1;\n    for(int i = head[u]; i; i = a[i].nt) {\n      int to = a[i].to;\n      if(vs[to]) {\n        int fx = find(u), fy = find(to);\n        if(fx == fy) continue;\n        f[fy] = fx, s[fx] += s[fy];\n        dp[fx] = min(dp[fx], max(dp[fy], A[fx] - s[fy]));\n      }\n    }\n  }\n  printf(\"%lld\\n\", dp[find(1)] + s[find(1)]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nstruct node\n{\n\tint u,v,data;\n\tbool operator < (const node &a)const\n\t{\n\t\treturn data<a.data;\n\t}\n};\nnode edge[200001];\nint n,m,a[100001],b[100001],head[100001],rt[100001],sz[100001],Mx[100001];\nint find(int x)\n{\n\tif (rt[x]==x)\n\t\treturn x;\n\treturn rt[x]=find(rt[x]);\n}\nvoid unionn(int x,int y)\n{\n\tsz[find(y)]+=sz[find(x)];\n\tMx[find(y)]=min(Mx[find(y)],max(Mx[find(x)],a[find(y)]-b[find(y)]-sz[find(x)]));\n\trt[find(x)]=find(y);\n\treturn;\n}\nint main()\n{\n\tcin>>n>>m;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i]>>b[i];\n\t\trt[i]=i;\n\t\tsz[i]=b[i];\n\t\tMx[i]=max(a[i]-b[i],0);\n\t}\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tcin>>edge[i].u>>edge[i].v;\n\t\tif (a[edge[i].u]>a[edge[i].v])\n\t\t\tswap(edge[i].u,edge[i].v);\n\t\tedge[i].data=a[edge[i].v];\n\t}\n\tsort(edge+1,edge+m+1);\n\tfor (int i=1;i<=m;++i)\n\t\tif (find(edge[i].u)!=find(edge[i].v))\n\t\t\tunionn(edge[i].u,edge[i].v);\n\tcout<<Mx[find(1)]+sz[find(1)]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 100100;\n\nint n,m,a[maxn],b[maxn],p[maxn],id[maxn],vis[maxn],root;\nll f[maxn],s[maxn];\nvector<int> g[maxn];\n\nint cmp(int i,int j) {\n    return a[i] < a[j];\n}\n\nint get(int x) {\n    return ((x==p[x]) ? x : p[x] = get(p[x]));\n}\n\nint main() {\n   // freopen(\"in.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin>>n>>m;\n    int ma =0;\n    for (int i=1;i<=n;i++) {\n        cin>>a[i]>>b[i];\n        a[i] = max(a[i]-b[i],0); // all of node always need atleast ai-bi\n        if (a[i] > ma) {\n            ma = a[i];\n            root = i;\n        }\n        id[i] = i;\n        p[i] = i;\n        s[i] = b[i]; // amount of money need to donate\n        f[i] = a[i]; // amount of money need to add more to donate all\n    }\n    for (int i=1;i<=m;i++) {\n        int x,y;\n        cin>>x>>y;\n        g[x].push_back(y);\n        g[y].push_back(x);\n    }\n    sort(id+1,id+n+1,cmp);\n    for (int i=1;i<=n;i++) {\n        int u = id[i];\n        vis[u] = 1;\n        for (auto v : g[u]) if (vis[v]) { // alway keep order to DP\n            int x = get(u), y= get(v);\n           // cout<<u<<\" \"<<v<<\" \"<<x<<\" \"<<y<<endl;\n            if (x==y) continue;\n            p[y] = x; s[x] += s[y];\n            ll need = a[u] - s[y];\n            f[x] = min(f[x],max(need,f[y]));\n        }\n    }\n    cout<<f[root] + s[root]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll LLINF = 1ll << 60;\nconst int N = 100010;\nint n, m, va[N], vb[N], id[N], per[N], uni[N];\nll sum[N], dp[N], ans;\nint getfa(int pos) {\n  return pos == uni[pos] ? pos : uni[pos] = getfa(uni[pos]);\n}\nvector<int> vec[N];\nint main() {\n  int x,y;\n  read(n), read(m);\n  rep (i, 1, n) read(va[i]), read(vb[i]);\n  rep (i, 1, n) per[i] = i;\n  sort(per + 1, per + n + 1, [=](int a,int b) -> bool {\n      return max(va[a] - vb[a], 0) < max(va[b] - vb[b], 0);\n    });\n  rep (i, 1, n) id[per[i]] = i;\n  rep (i, 1, m) {\n    read(x), read(y);\n    if (id[x] < id[y]) swap(x, y);\n    vec[x].push_back(y);\n  }\n  rep (i, 1, n) {\n    uni[i] = i;\n    sum[i] = vb[i];\n    dp[i] = vb[i];\n  }\n  rep (i, 1, n) {\n    int j = per[i];\n    vector<int> tmp;\n    rep (k, 0, (int)vec[j].size()-1)\n      tmp.push_back(getfa(vec[j][k]));\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n    ll ssum = 0;\n    rep (k, 0, (int)tmp.size()-1)\n      ssum += sum[tmp[k]];\n    ssum += vb[j];\n    dp[j] = LLINF;\n    if (tmp.empty()) dp[j] = vb[j];\n    rep (k, 0, (int)tmp.size()-1)\n      dp[j] = min(dp[j], max(dp[tmp[k]], (ll)max(va[j] - vb[j], 0)) + ssum - sum[tmp[k]]);\n    rep (k, 0, (int)tmp.size()-1) {\n      sum[j] += sum[tmp[k]];\n      uni[tmp[k]] = j;\n    }\n  }\n  cout << dp[per[n]] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tvector< vector<int> > G(N);\n\tvector<cat> A(N), B(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i] >> B[i];\n\tfor(int i = 0; i < M; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tG[--u].push_back(--v);\n\t\tG[v].push_back(u);\n\t}\n\tvector< pair<cat, int> > Vs(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tVs[i].ff = max(0LL, A[i]-B[i]);\n\t\tVs[i].ss = -i;\n\t}\n\tsort(begin(Vs), end(Vs));\n\n\tvector< vector<int> > comp(N);\n\tfor(int i = 0; i < N; i++) comp[i].resize(1, i);\n\tvector<int> inC(N);\n\tfor(int i = 0; i < N; i++) inC[i] = i;\n\tvector<bool> live(N, false);\n\tvector<cat> sumB(N, 0), W(N);\n\tcat ans = 0;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint c = -Vs[i].ss;\n\t\tvector<int> comp_adj;\n\t\tALL_THE(G[c], it) if(live[*it])\n\t\t\tcomp_adj.push_back(inC[*it]);\n\t\tsort(begin(comp_adj), end(comp_adj));\n\t\tauto cae = unique(begin(comp_adj), end(comp_adj));\n\t\tint sz = cae - begin(comp_adj);\n\t\tcomp_adj.resize(sz);\n\n\t\t// aspon A[c] + sumB[susedia okrem j]: viem sa pohybovat hocikde\n\t\t// aspon B[c] + sumB[susedia okrem j] + W[j]: viem vyplatit j, c\n\t\t// viem vyplatit zvysne? w (>= W1) -> w-S1 (>= W2), w >= max(W1, W2+S1)  //  w (>= W2) -> w-S2 (>= W1), w >= max(W2, W1+S2)\n\t\tcat s = 0, m = 0;\n\t\tfor(int k = 0; k < sz; k++) {\n\t\t\ts += sumB[comp_adj[k]];\n\t\t\tm = max(m, W[comp_adj[k]]);\n\t\t}\n\t\tW[c] = max(m, max(A[c]+s, B[c]+s));\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\ts -= sumB[comp_adj[j]];\n\t\t\tW[c] = min(W[c], max(m, max(A[c]+s, B[c]+s+W[comp_adj[j]])));\n\t\t\ts += sumB[comp_adj[j]];\n\t\t}\n\n\t\tif(sz < 10) {\n\t\t\tvector<int> P(sz);\n\t\t\tfor(int j = 0; j < sz; j++) P[j] = j;\n\t\t\tbool is_ok = false;\n\t\t\twhile(true) {\n\t\t\t\tcat w = W[c];\n\t\t\t\tbool ok = true;\n\t\t\t\tfor(int j = sz-1; j > 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tw -= B[c];\n\t\t\t\tif(sz > 0 && w < W[comp_adj[P[0]]]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tw = W[c];\n\t\t\t\tok = true;\n\t\t\t\tfor(int j = sz-1; j >= 0; j--) {\n\t\t\t\t\tif(w < W[comp_adj[P[j]]]) ok = false;\n\t\t\t\t\tw -= sumB[comp_adj[P[j]]];\n\t\t\t\t\tif(w < A[c]) ok = false;\n\t\t\t\t}\n\t\t\t\tif(w < B[c]) ok = false;\n\t\t\t\tif(ok) is_ok = true;\n\t\t\t\tif(!next_permutation(begin(P), end(P))) break;\n\t\t\t}\n\t\t\tassert(is_ok);\n\t\t}\n\n\t\tsumB[c] = B[c];\n\t\tfor(int j = 0; j < sz; j++) {\n\t\t\tint a = inC[c], b = comp_adj[j];\n\t\t\tif(comp[a].size() > comp[b].size()) swap(a, b);\n\t\t\tALL_THE(comp[a], it) {\n\t\t\t\tcomp[b].push_back(*it);\n\t\t\t\tinC[*it] = b;\n\t\t\t}\n\t\t\tsumB[b] += sumB[a];\n\t\t}\n\t\tans = W[inC[c]] = W[c];\n\t\tlive[c] = true;\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=100000+10;\n\nint n,m,a[N],b[N],c[N],p[N],rk[N];\nvector<int> G[N],E[N];\nbool cmp(int x,int y) { return c[x]<c[y]; }\n\nint f[N];\nint find(int x) { return x==f[x]?x:f[x]=find(f[x]); }\n\nll dp[N],sum[N];\nvoid dfs(int u) {\n\tsum[u]=b[u],dp[u]=1e18;\n\tif (E[u].empty()) { dp[u]=max(a[u],b[u]); return; }\n\tfor (int v:E[u]) dfs(v),sum[u]+=sum[v];\n\tfor (int v:E[u])\t\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max(1ll*c[u],dp[v]));\n}\n\nint main() {\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;++i) a[i]=read(),b[i]=read();\n\tfor (int i=1;i<=m;++i) {\n\t\tint u=read(),v=read();\n\t\tG[u].emplace_back(v),G[v].emplace_back(u);\n\t}\n\tfor (int i=1;i<=n;++i) c[i]=max(0,a[i]-b[i]),p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor (int i=1;i<=n;++i) rk[p[i]]=f[i]=i;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int v:G[p[i]])\n\t\t\tif (find(v)!=p[i]&&rk[v]<i)\n\t\t\t\tE[p[i]].emplace_back(find(v)),f[find(v)]=p[i];\n\tdfs(p[n]); printf(\"%lld\\n\",dp[p[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint read()\n{\n   int x=0,f=1;char ch=getchar();\n   while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}\n   while (ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n   return x*f;\n}\nconst int N=100005;\nint cnt,head[N],a[N],b[N],id[N],u,v,fa[N],n,m,x,bsum[N],f[N],vis[N];\nstruct node{int to,next;}num[N*2];\nvoid add(int x,int y)\n{num[++cnt].to=y;num[cnt].next=head[x];head[x]=cnt;}\nbool cmp(int A,int B) {return a[A]<a[B];}\nint getfather(int x) {return fa[x]?fa[x]=getfather(fa[x]):x;}\nint main()\n{\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++) a[i]=read(),b[i]=read(),a[i]=max(a[i]-b[i],0),id[i]=i;\n\tfor (int i=1;i<=m;i++) u=read(),v=read(),add(u,v),add(v,u);\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tx=id[i];vis[x]=1;f[x]=a[x];bsum[x]=b[x];\n\t\tfor (int j=head[x];j;j=num[j].next)\n\t\t  if (vis[num[j].to])\n\t\t  {\n\t\t  \t  int y=getfather(num[j].to);\n\t\t  \t  if (x==y) continue;\n\t\t  \t  fa[y]=x;bsum[x]+=bsum[y];\n\t\t  \t  f[x]=min(f[x],max(f[y],a[x]-bsum[y]));\n\t\t  }\n\t}\n\tprintf(\"%d\\n\",bsum[id[n]]+f[id[n]]);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int N=110000;\nint father[N];\nlong long sum[N],w[N];\nint n,m,A[N],B[N],pos[N],in[N];\nint findfather(int k1){\n\tif (father[k1]==k1) return k1; return father[k1]=findfather(father[k1]);\n}\nvector<int> go[N];\nint compare(int k1,int k2){\n\treturn A[k1]<A[k2];\n}\nint pd[N],sign;\nvector<int> C;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d%d\",&A[i],&B[i]);\n\tfor (int i=1;i<=m;i++){\n\t\tint k1,k2; scanf(\"%d%d\",&k1,&k2);\n\t\tgo[k1].push_back(k2);\n\t\tgo[k2].push_back(k1);\n\t}\n\tfor (int i=1;i<=n;i++) pos[i]=i,father[i]=i;\n\tsort(pos+1,pos+n+1,compare);\n\tfor (int i=1;i<=n;i++){\n\t\tint k1=pos[i]; sign++; C.clear();\n\t\tfor (int j=0;j<go[k1].size();j++){\n\t\t\tint k2=go[k1][j];\n\t\t\tif (in[k2]){\n\t\t\t\tint root=findfather(k2);\n\t\t\t\tif (pd[root]!=sign){\n\t\t\t\t\tpd[root]=sign; C.push_back(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<C.size();j++){\n\t\t\tfather[C[j]]=k1;\n\t\t\tsum[k1]+=sum[C[j]];\n\t\t} in[k1]=1;\n\t\tw[k1]=max(A[k1]-B[k1],0);\n\t\tfor (int j=0;j<C.size();j++)\n\t\t\tw[k1]=min(w[k1],max(1ll*A[k1]-B[k1]-sum[C[j]]-w[C[j]],0ll)+w[C[j]]);\n\t\tsum[k1]+=B[k1];\n\t\t//cout<<k1<<\" \"<<w[k1]<<\" \"<<B[k1]<<endl;\n\t\t//for (int j=0;j<C.size();j++) cout<<C[j]<<\" \"; cout<<endl;\n\t}\n\tprintf(\"%lld\\n\",w[findfather(1)]+sum[findfather(1)]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst ll LLINF = 1ll << 60;\nconst int N = 100010;\nint n, m, va[N], vb[N], id[N], per[N], uni[N];\nll sum[N], dp[2][N], ans, rec[N], pre[N], suf[N];\nint getfa(int pos) {\n  return pos == uni[pos] ? pos : uni[pos] = getfa(uni[pos]);\n}\nvector<int> vec[N];\nint main() {\n  int x,y;\n  read(n), read(m);\n  rep (i, 1, n) read(va[i]), read(vb[i]);\n  rep (i, 1, n) per[i] = i;\n  sort(per + 1, per + n + 1, [=](int a,int b) -> bool {\n      if (va[a] != va[b]) return va[a] < va[b];\n      return vb[a] > vb[b];\n    });\n  rep (i, 1, n) id[per[i]] = i;\n  rep (i, 1, m) {\n    read(x), read(y);\n    if (id[x] < id[y]) swap(x, y);\n    vec[x].push_back(y);\n  }\n  rep (i, 1, n) {\n    uni[i] = i;\n    sum[i] = vb[i];\n    dp[0][i] = max(va[i], vb[i]);\n    dp[1][i] = vb[i];\n  }\n  rep (i, 1, n) {\n    int j = per[i];\n    vector<int> tmp;\n    rep (k, 0, (int)vec[j].size()-1)\n      tmp.push_back(getfa(vec[j][k]));\n    sort(tmp.begin(), tmp.end());\n    tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());\n    ll ssum = 0;\n    rep (k, 0, (int)tmp.size()-1)\n      ssum += sum[tmp[k]];\n    dp[0][j] = LLINF;\n    if (tmp.empty()) dp[0][j] = max(va[j], vb[j]);\n    rep (k, 0, (int)tmp.size()-1) {\n      dp[0][j] = min(dp[0][j], ssum - sum[tmp[k]] + max((ll)va[j], dp[0][tmp[k]] + vb[j]));\n    }\n    if ((int)tmp.size() == 1) dp[0][j] = min(dp[0][j], dp[1][tmp[0]] + max(va[j], vb[j]));\n    dp[1][j] = LLINF;\n    if (tmp.empty()) dp[1][j] = vb[j];\n    else if ((int)tmp.size() == 1)\n      dp[1][j] = min(dp[0][tmp[0]] + vb[j], dp[1][tmp[0]] + max(va[j], vb[j]));\n    else {\n      rep (k, 0, (int)tmp.size()-1) {\n\trec[k] = max((ll)va[j], dp[0][tmp[k]] + vb[j]) - sum[tmp[k]];\n      }\n      pre[0] = rec[0];\n      rep (k, 1, (int)tmp.size()-1) pre[k] = min(rec[k], pre[k-1]);\n      suf[(int)tmp.size()-1] = rec[(int)tmp.size()-1];\n      rrp (k, (int)tmp.size()-2, 0) suf[k] = min(rec[k], suf[k+1]);\n      rep (k, 0, (int)tmp.size()-1) {\n\tll v = LLINF;\n\tif (k > 0) v = min(v, pre[k-1]);\n\tif (k < (int)tmp.size()-1) v = min(v, suf[k+1]);\n\tv += ssum - sum[tmp[k]] + dp[1][tmp[k]];\n\tdp[1][j] = min(dp[1][j], v);\n      }\n    }\n    rep (k, 0, (int)tmp.size()-1) {\n      uni[tmp[k]] = j;\n      sum[j] += sum[tmp[k]];\n    }\n  }\n  cout << dp[1][per[n]] << endl;\n  return 0;\n}\n/*\na,b\nmax(va[j], dp[0][b] + vb[j]) + ss - sum[a] - sum[b] + dp[1][a]\n */\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint head2[131072],last2[131072],to2[131072],cnt2=0;\nvoid add2(int u,int v)\n{\n\tcnt2++;\n\tlast2[cnt2]=head2[u];\n\thead2[u]=cnt2;\n\tto2[cnt2]=v;\n}\nint a[131072],b[131072];\nlong long s[131072],ans[131072];\nlong long dfs(int u)\n{\n\ts[u]=a[u]-b[u];\n\tfor(int i=head2[u];i;i=last2[i])\n\t{\n\t\tint v=to2[i];\n\t\tdfs(v);\n\t\ts[u]+=s[v];\n\t}\n\tans[u]=s[u]+b[u];\n\tfor(int i=head2[u];i;i=last2[i])\n\t{\n\t\tint v=to2[i];\n\t\tlong long a2=s[u]-s[v];\n\t\tif(ans[v]>b[u])\n\t\t{\n\t\t\ta2+=ans[v];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta2+=b[u];\n\t\t}\n\t\tif(a2<ans[u])\n\t\t{\n\t\t\tans[u]=a2;\n\t\t}\n\t}\n\treturn ans[u];\n}\nint head[131072],last[262144],to[262144],cnt=0;\nvoid add(int u,int v)\n{\n\tcnt++;\n\tlast[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n}\nstruct node{\n\tint u;\n\tint a;\n\tint b;\n\tbool operator<(node c) const\n\t{\n\t\treturn b<c.b;\n\t}\n};\nnode nn[131072];\nbool vis[131072];\nint fa[131072];\nint findroot(int x)\n{\n\tif(fa[x]==x)\n\t{\n\t\treturn x;\n\t}\n\treturn fa[x]=findroot(fa[x]);\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tnn[i].u=i+1;\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a<b)\n\t\t{\n\t\t\ta=b;\n\t\t}\n\t\tnn[i].a=a;\n\t\tnn[i].b=a-b;\n\t}\n\tsort(nn,nn+n);\n\twhile(m--)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfa[i]=i;\n\t\tvis[i]=false;\n\t}\n\tfor(int t=0;t<n;t++)\n\t{\n\t\tint u=nn[t].u;\n\t\tvis[u]=true;\n\t\ta[u]=nn[t].a;\n\t\tb[u]=nn[t].b;\n\t\tfor(int i=head[u];i;i=last[i])\n\t\t{\n\t\t\tint v=to[i];\n\t\t\tif(!vis[v])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv=findroot(v);\n\t\t\tif(v!=u)\n\t\t\t{\n\t\t\t\tadd2(u,v);\n\t\t\t\tfa[v]=u;\n\t\t\t}\n\t\t}\n\t}\n\tint root=nn[n-1].u;\n\tprintf(\"%lld\\n\",dfs(root));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> P;\ntypedef pair<int, P> Pi;\nll a[100002], b[100002];\nint par[100002];\nint rk[100002];\nll size[100002];\nll mx[100002];\nint num[100002];\nint c;\nP pab[200002];\nvector<int> v[200002];\nvoid add(int x, int y){\n  //v[x].push_back(y);\n  v[y].push_back(x);\n}\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i;\n\t\trk[i]=0;\n      size[i]=b[i];\n      mx[i]=a[i];\n      num[i]=i;\n\t}\n}\n \nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n \nvoid unite(int x, int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(rk[x]<rk[y]){\n\t\tpar[x]=y;\n      add(num[x], c);\n      add(num[y], c);\n      num[y]=c;\n      size[y]+=size[x];\n      mx[y]=max(mx[y], mx[x]);\n      pab[c]=P(mx[y], size[y]);\n\t}else{\n\t\tpar[y]=x;\n      add(num[x], c);\n      add(num[y], c);\n      num[x]=c;\n      size[x]+=size[y];\n      mx[x]=max(mx[y], mx[x]);\n      pab[c]=P(mx[x], size[x]);\n\t\tif(rk[x]==rk[y]) rk[x]++;\n\t}\n  c++;\n}\n \nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\nll x0;\n//bool used0[200002];\nbool dfs(int x){\n  //used0[x]=1;\n  if(v[x].empty()) return true;\n  bool ok=0;\n  for(auto y:v[x]){\n    //if(used0[y]) continue;\n    if(!dfs(y)) continue;\n    if(x0+pab[y].second>=pab[x].first){\n      ok=1;\n    }\n  }\n  return ok;\n}\nint main()\n{\n\tint n, m;\n  cin>>n>>m;\n  c=n;\n  P pa[100000];\n  ll s=0;\n  for(int i=0; i<n; i++){\n    cin>>a[i]>>b[i];\n    a[i]-=b[i];\n    s+=b[i];\n    pa[i]=P(a[i], i);\n    pab[i]=P(a[i], b[i]);\n  }\n  if(n==1){\n    if(a[0]>=0) cout<<a[0]+b[0]<<endl;\n    else cout<<b[0]<<endl;\n    return 0;\n  }\n  sort(pa, pa+n);\n  vector<int> g[100000];\n  for(int i=0; i<m; i++){\n    int u, v;\n    cin>>u>>v;\n    u--; v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  bool used[100000]={};\n  init(n);\n  for(int i=0; i<n; i++){\n    int x=pa[i].second;\n    used[x]=1;\n    for(auto y:g[x]){\n      if(used[y]){\n        if(!same(x, y)) unite(x, y);\n      }\n    }\n  }\n  /*for(int i=0; i<c; i++){\n    cout<<i<<\" \";\n    for(auto y:v[i]) cout<<y<<\" \";\n    cout<<endl;\n  }*/\n  ll x1=0, x2=1e9;\n  while(x1!=x2){\n    x0=(x1+x2)/2;\n    if(dfs(c-1)) x2=x0;\n    else x1=x0+1;\n  }\n  cout<<x1+s<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,m;\nint a[maxn],b[maxn],id[maxn];\nstruct edge{int v,nxt;}e[maxn<<1];\nint head[maxn],ecnt=0,vis[maxn];\nvoid add(int u,int v)\n{\n\te[++ecnt]=(edge){v,head[u]},head[u]=ecnt;\n\te[++ecnt]=(edge){u,head[v]},head[v]=ecnt;\n}\nbool cmp(const int &x,const int &y){return a[x]<a[y];}\nvector<int>G[maxn];\nint fa[maxn];\nlong long sum[maxn],dp[maxn];\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid dfs(int u,int pre)\n{\n\t\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t\tsum[u]+=sum[v];\n\t}\n\tsum[u]+=b[u];\n\tdp[u]=sum[u]+a[u];\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdp[u]=min(dp[u],sum[u]-sum[v]+max(dp[v],a[u]*1LL));\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&a[i],&b[i]),a[i]=max(0,a[i]-b[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)fa[i]=i;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=id[i];\n\t\tvis[u]=1;\n\t\tfor(auto v:G[u])\n\t\tif(!vis[v]&&find(u)!=find(v))\n\t\t{\n\t\t\tadd(u,v);\n\t\t\tfa[find(u)]=find(v);\n\t\t}\n\t}\n\tdfs(id[n],0);\n\tprintf(\"%lld\\n\",dp[id[n]]);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define INF\t0x3f3f3f3f\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint ds[N], rr[N];\n\nint find(int i) {\n\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n}\n\nint join(int i, int j) {\n\ti = find(i);\n\tj = find(j);\n\tif (i == j)\n\t\treturn 0;\n\tif (ds[i] > ds[j]) {\n\t\tds[i] = j;\n\t\trr[j] = rr[i];\n\t} else {\n\t\tif (ds[i] == ds[j])\n\t\t\tds[i]--;\n\t\tds[j] = i;\n\t}\n\treturn 1;\n}\n\nint aa[N], bb[N];\nint ii[M], jj[M];\n\nint compare(const void *a, const void *b) {\n\tint h1 = *(int *) a;\n\tint h2 = *(int *) b;\n\n\treturn aa[ii[h1]] - aa[ii[h2]];\n}\n\nint main() {\n\tstatic int hh[M], ss[N], dp[N];\n\tint n, m, h, i, j;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &aa[i], &bb[i]);\n\tfor (h = 0; h < m; h++) {\n\t\tint tmp;\n\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tif (aa[i] < aa[j] || aa[i] == aa[j] && i < j)\n\t\t\ttmp = i, i = j, j = tmp;\n\t\tii[h] = i, jj[h] = j, hh[h] = h;\n\t}\n\tqsort(hh, m, sizeof *hh, compare);\n\tfor (i = 0; i < n; i++) {\n\t\tds[i] = -1, rr[i] = i;\n\t\tss[i] = bb[i];\n\t}\n\tfor (h = 0; h < m; h++)\n\t\tdp[ii[h]] = INF;\n\tfor (h = 0; h < m; h++) {\n\t\ti = ii[hh[h]], j = rr[find(jj[hh[h]])];\n\t\tif (join(i, j)) {\n\t\t\tdp[i] = min(dp[i], max(dp[j], aa[i] - (bb[i] + ss[j])));\n\t\t\tss[i] = min(ss[i] + ss[j], INF);\n\t\t}\n\t}\n\tans = dp[ii[hh[m - 1]]];\n\tfor (i = 0; i < n; i++)\n\t\tans += bb[i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nlong long av;\nlong long bv;\nlong long node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->av < ((sd*)b)->av){return -1;}\nif(((sd*)a)->av > ((sd*)b)->av){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    long long st;\n    long long fi;\n    long long kr;\n}rs;\n\ntypedef struct{\n    long long st;\n    long long kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st > ((rs*)b)->st){return 1;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nreturn 0;\n}\n\nvoid makemkj(rs g[],mkj x[],long long n){\n    long long i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\ntypedef struct{\n    long long par;\n    long long dep;\n    long long size;\n}node;\n\nnode uft[131072];\n\nvoid resuf(){\n    long long i;\n    for(i=0;i<131072;i++){\n        uft[i].par=i;uft[i].dep=0;uft[i].size=1;\n    }\n    return;\n}\n\nlong long find(long long x){\n    if(uft[x].par==x){return x;}\n    else{uft[x].par=find(uft[x].par);return uft[x].par;}\n}\n\nvoid uni(long long x,long long y){\n    long long xp,yp;\n    xp=find(x);yp=find(y);\n    if(xp==yp){return;}\n    if(uft[xp].dep>uft[yp].dep){\n        uft[yp].par=xp;\n        uft[xp].size+=uft[yp].size;\n    }\n    else{\n        uft[xp].par=yp;\n        uft[yp].size+=uft[xp].size;\n        if(uft[xp].dep==uft[yp].dep){uft[yp].dep++;}\n    }\n    return;\n}\n\nlong long size(long long x){\n    x=find(x);\n    return uft[x].size;\n}\n\nint main(void){\n  resuf();\n  //srand(time(0));\n  long long i,j,n,m,k,a,b,c,h,w,r=0,l,t;\n  long long av[131072],bv[131072],na,nb;\n  rs g[262144];\n  mkj x[131072];\n  sd dat[131072],mdat[131072];\n  bool fl[131072]={0},mfl[131072]={0};\n  scanf(\"%lld%lld\",&n,&m);\n  for(i=0;i<n;i++){\n    scanf(\"%lld%lld\",&dat[i].av,&dat[i].bv);\n    dat[i].av=llmax(0,dat[i].av-dat[i].bv);\n    av[i+1]=dat[i].av;\n    bv[i+1]=dat[i].bv;\n    dat[i].node=i+1;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  for(i=0;i<m;i++){\n    scanf(\"%lld%lld\",&g[i].st,&g[i].fi);\n    g[m+i].st=g[i].fi;\n    g[m+i].fi=g[i].st;\n  }\n  qsort(g,2*m,sizeof(g[0]),sortfnc);\n  makemkj(g,x,2*m);\n  for(i=0;i<n;i++){\n    w=dat[i].node;\n    fl[w]=1;\n    nb=bv[w];\n    c=0;\n    for(j=x[w].st;j<x[w].st+x[w].kz;j++){\n      if(fl[g[j].fi]==0){continue;}\n      t=find(g[j].fi);\n      if(mfl[t]==0){\n        mfl[t]=1;\n        mdat[c].av=av[t];\n        mdat[c].bv=bv[t];\n        mdat[c].node=t;\n        nb+=bv[t];\n        c++;\n      }\n    }\n    for(j=x[w].st;j<x[w].st+x[w].kz;j++){\n      if(fl[g[j].fi]==0){continue;}\n      t=find(g[j].fi);\n      if(mfl[t]==1){\n        mfl[t]=0;\n      }\n    }\n    for(j=x[w].st;j<x[w].st+x[w].kz;j++){\n      if(fl[g[j].fi]==0){continue;}\n      uni(w,g[j].fi);\n    }\n    na=nb+av[w];\n    for(j=0;j<c;j++){\n      t=mdat[j].node;\n      na=llmin(llmax(av[t],av[w])-bv[t]+nb,na);\n    }\n    av[find(w)]=na;\n    bv[find(w)]=nb;\n  }\n  printf(\"%lld\\n\",av[find(1)]);\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nhwll sorted[N_MAX];\nhwll tg[N_MAX];\null tin[N_MAX];\n\null rank[N_MAX];\n\null dp[N_MAX];\null bsum[N_MAX];\nvoid dfs (ull v) {\n\tdp[v] = smax(a[v] - b[v], 0);\n\n\tfor (sll i = tin[v]; i < tin[v + 1]; i++) {\n\t\tull u = tg[i].b;\n\n\t\tdfs(u);\n\t\tif (dp[u] + bsum[u] + b[v] >= a[v]) {\n\t\t\tdp[v] = smin(dp[v], dp[u]);\n\t\t} else {\n\t\t\tdp[v] = smin(dp[v], a[v] - bsum[u] - b[v]);\n\t\t}\n\n\t\tbsum[v] += bsum[u];\n\t}\n\tbsum[v] += b[v];\n\n\t// printf(\"%lld: %lld + %lld\\n\", v, dp[v], bsum[v]);\n}\n\null parent[N_MAX], size[N_MAX];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull p, ull v) {\n\tparent[v] = p;\n\treturn true;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfor (i = 0; i < m; i++) {\n\t\txy[i + m] = (hwll){xy[i].b, xy[i].a};\n\t}\n\tqsort(xy, m * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < m * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tsorted[i] = (hwll){a[i], i};\n\t}\n\tqsort(sorted, n, sizeof(hwll), phwllABcomp);\n\tfor (i = 0; i < n; i++) {\n\t\trank[sorted[i].b] = i;\n\t\t// printf(\"%lld..\\n\", sorted[i].b);\n\t}\n\n\tinit(n);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tull v = sorted[i].b;\n\n\t\tfor (j = gin[v]; j < gin[v + 1]; j++) {\n\t\t\tull u = xy[j].b;\n\n\t\t\tif (rank[u] >= rank[v]) continue;\n\t\t\tif (find(u) == find(v)) continue;\n\n\t\t\tull up = find(u);\n\t\t\t// printf(\"%lld->%lld\\n\", v, up);\n\t\t\ttg[ki++] = (hwll){v, up};\n\t\t\tunite(v, up);\n\t\t}\n\t}\n\n\tqsort(tg, n - 1, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\ttin[i] = j;\n\t\twhile (j < n - 1 && tg[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tull root = sorted[n - 1].b;\n\tdfs(root);\n\n\tresult = dp[root] + bsum[root];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 4;\n\tm = 0;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\txy[i].a--;\n\t\txy[i].b--;\n\t\t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t}\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define INF\t0x3f3f3f3f\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint ds[N], rr[N];\n\nint find(int i) {\n\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n}\n\nint join(int i, int j) {\n\ti = find(i);\n\tj = find(j);\n\tif (i == j)\n\t\treturn 0;\n\tif (ds[i] > ds[j]) {\n\t\tds[i] = j;\n\t\trr[j] = rr[i];\n\t} else {\n\t\tif (ds[i] == ds[j])\n\t\t\tds[i]--;\n\t\tds[j] = i;\n\t}\n\treturn 1;\n}\n\nint aa[N], bb[N];\nint ii[M], jj[M];\n\nint compare(const void *a, const void *b) {\n\tint h1 = *(int *) a;\n\tint h2 = *(int *) b;\n\tint i1 = ii[h1];\n\tint i2 = ii[h2];\n\n\treturn aa[i1] != aa[i2] ? aa[i1] - aa[i2] : i2 - i1;\n}\n\nint main() {\n\tstatic int hh[M], ss[N], dp[N];\n\tint n, m, h, i, j;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &aa[i], &bb[i]);\n\tfor (h = 0; h < m; h++) {\n\t\tint tmp;\n\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tif (aa[i] < aa[j] || aa[i] == aa[j] && i > j)\n\t\t\ttmp = i, i = j, j = tmp;\n\t\tii[h] = i, jj[h] = j, hh[h] = h;\n\t}\n\tqsort(hh, m, sizeof *hh, compare);\n\tfor (i = 0; i < n; i++) {\n\t\tds[i] = -1, rr[i] = i;\n\t\tss[i] = bb[i], dp[i] = max(aa[i] - bb[i], 0);\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\ti = ii[hh[h]], j = rr[find(jj[hh[h]])];\n\t\tif (join(i, j)) {\n\t\t\tdp[i] = min(dp[i], max(dp[j], aa[i] - (bb[i] + ss[j])));\n\t\t\tss[i] = min(ss[i] + ss[j], INF);\n\t\t}\n\t}\n\tans = dp[rr[find(0)]];\n\tfor (i = 0; i < n; i++)\n\t\tans += bb[i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nhwll sorted[N_MAX];\nhwll tg[N_MAX];\null tin[N_MAX];\n\null rank[N_MAX];\n\null dp[N_MAX];\null bsum[N_MAX];\nvoid dfs (ull v) {\n\tdp[v] = smax(a[v] - b[v], 0);\n\n\tfor (sll i = tin[v]; i < tin[v + 1]; i++) {\n\t\tull u = tg[i].b;\n\n\t\tdfs(u);\n\t\tif (dp[u] + bsum[u] + b[v] >= a[v]) {\n\t\t\tdp[v] = smin(dp[v], dp[u]);\n\t\t} else {\n\t\t\tdp[v] = smin(dp[v], a[v] - bsum[u] - b[v]);\n\t\t}\n\n\t\tbsum[v] += bsum[u];\n\t}\n\tbsum[v] += b[v];\n\n\t// printf(\"%lld: %lld + %lld\\n\", v, dp[v], bsum[v]);\n}\n\null parent[N_MAX], size[N_MAX];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull p, ull v) {\n\tparent[v] = p;\n\treturn true;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfor (i = 0; i < m; i++) {\n\t\txy[i + m] = (hwll){xy[i].b, xy[i].a};\n\t}\n\tqsort(xy, m * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < m * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tsorted[i] = (hwll){smax(a[i] - b[i], 0), i};\n\t}\n\tqsort(sorted, n, sizeof(hwll), phwllABcomp);\n\tfor (i = 0; i < n; i++) {\n\t\trank[sorted[i].b] = i;\n\t\t// printf(\"%lld..\\n\", sorted[i].b);\n\t}\n\n\tinit(n);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tull v = sorted[i].b;\n\n\t\tfor (j = gin[v]; j < gin[v + 1]; j++) {\n\t\t\tull u = xy[j].b;\n\n\t\t\tif (rank[u] >= rank[v]) continue;\n\t\t\tif (find(u) == find(v)) continue;\n\n\t\t\tull up = find(u);\n\t\t\t// printf(\"%lld->%lld\\n\", v, up);\n\t\t\ttg[ki++] = (hwll){v, up};\n\t\t\tunite(v, up);\n\t\t}\n\t}\n\tif (ki != n - 1) abort();\n\n\tqsort(tg, n - 1, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\ttin[i] = j;\n\t\twhile (j < n - 1 && tg[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tull root = sorted[n - 1].b;\n\tdfs(root);\n\n\tresult = dp[root] + bsum[root];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 4;\n\tm = 0;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\txy[i].a--;\n\t\txy[i].b--;\n\t\t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t}\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define INF\t0x3f3f3f3f\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint ds[N], rr[N];\n\nint find(int i) {\n\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n}\n\nint join(int i, int j) {\n\ti = find(i);\n\tj = find(j);\n\tif (i == j)\n\t\treturn 0;\n\tif (ds[i] > ds[j]) {\n\t\tds[i] = j;\n\t\trr[j] = rr[i];\n\t} else {\n\t\tif (ds[i] == ds[j])\n\t\t\tds[i]--;\n\t\tds[j] = i;\n\t}\n\treturn 1;\n}\n\nint aa[N], bb[N];\nint ii[M], jj[M];\n\nint compare(const void *a, const void *b) {\n\tint h1 = *(int *) a;\n\tint h2 = *(int *) b;\n\tint i1 = ii[h1];\n\tint i2 = ii[h2];\n\n\treturn aa[i1] != aa[i2] ? aa[i1] - aa[i2] : i1 - i2;\n}\n\nint main() {\n\tstatic int hh[M], ss[N], dp[N];\n\tint n, m, h, i, j;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &aa[i], &bb[i]);\n\t\taa[i] = max(aa[i] - bb[i], 0);\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\tint tmp;\n\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tif (aa[i] < aa[j] || aa[i] == aa[j] && i < j)\n\t\t\ttmp = i, i = j, j = tmp;\n\t\tii[h] = i, jj[h] = j, hh[h] = h;\n\t}\n\tqsort(hh, m, sizeof *hh, compare);\n\tfor (i = 0; i < n; i++) {\n\t\tds[i] = -1, rr[i] = i;\n\t\tdp[i] = aa[i], ss[i] = bb[i];\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\ti = ii[hh[h]], j = rr[find(jj[hh[h]])];\n\t\tif (join(i, j)) {\n\t\t\tdp[i] = min(dp[i], max(dp[j], aa[i] - ss[j]));\n\t\t\tss[i] = min(ss[i] + ss[j], INF);\n\t\t}\n\t}\n\tans = dp[rr[find(0)]];\n\tfor (i = 0; i < n; i++)\n\t\tans += bb[i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nhwll sorted[N_MAX];\nhwll tg[N_MAX];\null tin[N_MAX];\n\null rank[N_MAX];\n\null dp[N_MAX];\null bsum[N_MAX];\nvoid dfs (ull v) {\n\tdp[v] = smax(a[v] - b[v], 0);\n\n\tfor (sll i = tin[v]; i < tin[v + 1]; i++) {\n\t\tull u = tg[i].b;\n\n\t\tdfs(u);\n\t\tif (dp[u] + bsum[u] + b[v] >= a[v]) {\n\t\t\tdp[v] = smin(dp[v], dp[u]);\n\t\t} else {\n\t\t\tdp[v] = smin(dp[v], a[v] - bsum[u] - b[v]);\n\t\t}\n\n\t\tbsum[v] += bsum[u];\n\t}\n\tbsum[v] += b[v];\n\n\t// printf(\"%lld: %lld + %lld\\n\", v, dp[v], bsum[v]);\n}\n\null parent[N_MAX], size[N_MAX];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull p, ull v) {\n\tparent[v] = p;\n\treturn true;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfor (i = 0; i < m; i++) {\n\t\txy[i + m] = (hwll){xy[i].b, xy[i].a};\n\t}\n\tqsort(xy, m * 2, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\tgin[i] = j;\n\t\twhile (j < m * 2 && xy[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tsorted[i] = (hwll){a[i], i};\n\t}\n\tqsort(sorted, n, sizeof(hwll), phwllABcomp);\n\tfor (i = 0; i < n; i++) {\n\t\trank[sorted[i].b] = i;\n\t\t// printf(\"%lld..\\n\", sorted[i].b);\n\t}\n\n\tinit(n);\n\n\tki = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tull v = sorted[i].b;\n\n\t\tfor (j = gin[v]; j < gin[v + 1]; j++) {\n\t\t\tull u = xy[j].b;\n\n\t\t\tif (rank[u] >= rank[v]) continue;\n\t\t\tif (find(u) == find(v)) continue;\n\n\t\t\tull up = find(u);\n\t\t\t// printf(\"%lld->%lld\\n\", v, up);\n\t\t\ttg[ki++] = (hwll){v, up};\n\t\t\tunite(v, up);\n\t\t}\n\t}\n\tif (ki != n - 1) abort();\n\n\tqsort(tg, n - 1, sizeof(hwll), phwllABcomp);\n\ti = j = 0;\n\twhile (i <= n) {\n\t\ttin[i] = j;\n\t\twhile (j < n - 1 && tg[j].a == i) j++;\n\t\ti++;\n\t}\n\n\tull root = sorted[n - 1].b;\n\tdfs(root);\n\n\tresult = dp[root] + bsum[root];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 4;\n\tm = 0;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\txy[i].a--;\n\t\txy[i].b--;\n\t\t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t}\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define INF\t0x3f3f3f3f\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint ds[N], rr[N];\n\nint find(int i) {\n\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n}\n\nint join(int i, int j) {\n\ti = find(i);\n\tj = find(j);\n\tif (i == j)\n\t\treturn 0;\n\tif (ds[i] > ds[j]) {\n\t\tds[i] = j;\n\t\trr[j] = rr[i];\n\t} else {\n\t\tif (ds[i] == ds[j])\n\t\t\tds[i]--;\n\t\tds[j] = i;\n\t}\n\treturn 1;\n}\n\nint aa[N], bb[N];\nint ii[M], jj[M];\n\nint compare(const void *a, const void *b) {\n\tint h1 = *(int *) a;\n\tint h2 = *(int *) b;\n\n\treturn aa[ii[h1]] - aa[ii[h2]];\n}\n\nint main() {\n\tstatic int hh[M], ss[N], dp[N];\n\tint n, m, h, i, j;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &aa[i], &bb[i]);\n\tfor (h = 0; h < m; h++) {\n\t\tint tmp;\n\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tif (aa[i] < aa[j] || aa[i] == aa[j] && i < j)\n\t\t\ttmp = i, i = j, j = tmp;\n\t\tii[h] = i, jj[h] = j, hh[h] = h;\n\t}\n\tqsort(hh, m, sizeof *hh, compare);\n\tfor (i = 0; i < n; i++) {\n\t\tds[i] = -1, rr[i] = i;\n\t\tss[i] = bb[i];\n\t}\n\tfor (h = 0; h < m; h++)\n\t\tdp[ii[h]] = INF;\n\tfor (h = 0; h < m; h++) {\n\t\ti = ii[hh[h]], j = rr[find(jj[hh[h]])];\n\t\tif (join(i, j)) {\n\t\t\tdp[i] = min(dp[i], max(dp[j], aa[i] - (bb[i] + ss[j])));\n\t\t\tss[i] = min(ss[i] + ss[j], INF);\n\t\t}\n\t}\n\tans = dp[rr[find(ii[hh[0]])]];\n\tfor (i = 0; i < n; i++)\n\t\tans += bb[i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define INF\t0x3f3f3f3f\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint ds[N], rr[N];\n\nint find(int i) {\n\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n}\n\nint join(int i, int j) {\n\ti = find(i);\n\tj = find(j);\n\tif (i == j)\n\t\treturn 0;\n\tif (ds[i] > ds[j]) {\n\t\tds[i] = j;\n\t\trr[j] = rr[i];\n\t} else {\n\t\tif (ds[i] == ds[j])\n\t\t\tds[i]--;\n\t\tds[j] = i;\n\t}\n\treturn 1;\n}\n\nint aa[N], bb[N];\nint ii[M], jj[M];\n\nint compare(const void *a, const void *b) {\n\tint h1 = *(int *) a;\n\tint h2 = *(int *) b;\n\tint i1 = ii[h1];\n\tint i2 = ii[h2];\n\n\treturn aa[i1] != aa[i2] ? aa[i1] - aa[i2] : i1 - i2;\n}\n\nint main() {\n\tstatic int hh[M], ss[N], dp[N];\n\tint n, m, h, i, j;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &aa[i], &bb[i]);\n\tfor (h = 0; h < m; h++) {\n\t\tint tmp;\n\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tif (aa[i] < aa[j] || aa[i] == aa[j] && i < j)\n\t\t\ttmp = i, i = j, j = tmp;\n\t\tii[h] = i, jj[h] = j, hh[h] = h;\n\t}\n\tqsort(hh, m, sizeof *hh, compare);\n\tfor (i = 0; i < n; i++) {\n\t\tds[i] = -1, rr[i] = i;\n\t\tss[i] = bb[i], dp[i] = max(aa[i] - bb[i], 0);\n\t}\n\tfor (h = 0; h < m; h++) {\n\t\ti = ii[hh[h]], j = rr[find(jj[hh[h]])];\n\t\tif (join(i, j)) {\n\t\t\tdp[i] = min(dp[i], max(dp[j], aa[i] - (bb[i] + ss[j])));\n\t\t\tss[i] = min(ss[i] + ss[j], INF);\n\t\t}\n\t}\n\tans = dp[rr[find(0)]];\n\tfor (i = 0; i < n; i++)\n\t\tans += bb[i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n#define M\t100000\n#define INF\t0x3f3f3f3f\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint ds[N], rr[N];\n\nint find(int i) {\n\treturn ds[i] < 0 ? i : (ds[i] = find(ds[i]));\n}\n\nint join(int i, int j) {\n\ti = find(i);\n\tj = find(j);\n\tif (i == j)\n\t\treturn 0;\n\tif (ds[i] > ds[j]) {\n\t\tds[i] = j;\n\t\trr[j] = rr[i];\n\t} else {\n\t\tif (ds[i] == ds[j])\n\t\t\tds[i]--;\n\t\tds[j] = i;\n\t}\n\treturn 1;\n}\n\nint aa[N], bb[N];\nint ii[M], jj[M];\n\nint compare(const void *a, const void *b) {\n\tint h1 = *(int *) a;\n\tint h2 = *(int *) b;\n\tint i1 = ii[h1];\n\tint i2 = ii[h2];\n\n\treturn aa[i1] != aa[i2] ? aa[i1] - aa[i2] : i1 - i2;\n}\n\nint main() {\n\tstatic int hh[M], ss[N], dp[N];\n\tint n, m, h, i, j;\n\tlong long ans;\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &aa[i], &bb[i]);\n\tfor (h = 0; h < m; h++) {\n\t\tint tmp;\n\n\t\tscanf(\"%d%d\", &i, &j), i--, j--;\n\t\tif (aa[i] < aa[j] || aa[i] == aa[j] && i < j)\n\t\t\ttmp = i, i = j, j = tmp;\n\t\tii[h] = i, jj[h] = j, hh[h] = h;\n\t}\n\tqsort(hh, m, sizeof *hh, compare);\n\tfor (i = 0; i < n; i++) {\n\t\tds[i] = -1, rr[i] = i;\n\t\tss[i] = bb[i];\n\t}\n\tfor (h = 0; h < m; h++)\n\t\tdp[ii[h]] = INF;\n\tfor (h = 0; h < m; h++) {\n\t\ti = ii[hh[h]], j = rr[find(jj[hh[h]])];\n\t\tif (join(i, j)) {\n\t\t\tdp[i] = min(dp[i], max(dp[j], aa[i] - (bb[i] + ss[j])));\n\t\t\tss[i] = min(ss[i] + ss[j], INF);\n\t\t}\n\t}\n\tans = dp[rr[find(0)]];\n\tfor (i = 0; i < n; i++)\n\t\tans += bb[i];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\tif( args[0].equals(\"gen\") ) {\n\t\t\t\t(new Main()).gen();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\t\n\tvoid gen() {\n\t\tint N = 100000;\n\t\tint E = 100000;\n\t\tRandom rand = new Random();\n\t\tSystem.out.println(N + \" \" + E);\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tint R = rand.nextInt(1000000000) + 1;\n\t\t\tint P = rand.nextInt(1000000000) + 1;\n\t\t\tSystem.out.println(R + \" \" + P);\n\t\t}\n\t\tfor( int i = 0; i < E; ++i ) {\n\t\t\tint F = rand.nextInt(i + 1) + 1; \n\t\t\tint T = i + 2;\n\t\t\tif( i == E - 1 ) {\n\t\t\t\tT = rand.nextInt(i + 1) + 1; \n\t\t\t}\n\t\t\tSystem.out.println(F + \" \" + T);\n\t\t}\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\tTTinit();\n\t\t\t\t__solve(cin);\n//\t\t\t\tTTstep();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tlong TTstart;\n\tvoid TTinit() {\n\t\tTTstart = System.currentTimeMillis();\n\t}\n\t\n\tvoid TTstep() {\n\t\tSystem.err.println(\"step: \" + (System.currentTimeMillis() - TTstart));\n\t}\n\n\tvoid __solve(Scanner cin) {\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tPair pair[] = new Pair[N];\n\t\t\n\t\tlong ret = 0;\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t\tif( nodes[i].req > nodes[i].pay ) {\n\t\t\t\tret = Math.max(ret, nodes[i].req - nodes[i].pay);\n\t\t\t}\n\t\t\tpair[i] = new Pair(i, Math.max(0, nodes[i].req - nodes[i].pay));\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tboolean skip[] = new boolean[N];\n\t\t\n\t\tArrays.sort(pair);\n\t\tfor( int i = 0; i < Math.min(N, 160); ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n\t\t\tret = Math.min(ret, solve(nodes, N, pair[i].key, ret, skip));\n\t\t}\n\t\t\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n//\t\t\tret = Math.min(ret, solve(nodes, N, i, ret, skip));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\t\t\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best, boolean skip[]) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tif( ret >= best ) { return best; }\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\tboolean skipF = false;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = best;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tskipF = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t\tif( skipF ) {\n\t\t\t\t\tskip[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t\tskipF = false;\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tclass Pair implements Comparable<Pair> {\n\t\t\n\t\tint key;\n\t\tint value;\n\t\t\n\t\tPair(int key, int value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif( p.value > value ) { return -1; }\n\t\t\tif( p.value < value ) { return 1; }\n\t\t\tif( p.key > key ) { return -1; }\n\t\t\tif( p.key < key ) { return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.AbstractCollection;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        List<Integer>[] g0;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            g0 = new List[n];\n\n            final int[] A = new int[n];\n            final int[] B = new int[n];\n            for (int i = 0; i < n; i++) {\n                g0[i] = new ArrayList<>();\n                A[i] = in.nextInt();\n                B[i] = in.nextInt();\n            }\n            for (int i = 0; i < m; i++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                g0[a].add(b);\n                g0[b].add(a);\n            }\n\n            long min = Long.MAX_VALUE;\n            int idx = -1;\n            for (int i = 0; i < n; i++) {\n//            if (min > Math.max(A[i], B[i])) {\n//                min = Math.max(A[i], B[i]);\n//                idx = i;\n//            }\n//            if (min > Math.min(A[i], B[i])) {\n//                min = Math.min(A[i], B[i]);\n//                idx = i;\n//            }\n//            if (min > A[i] - B[i]) {\n//                min = A[i] - B[i];\n//                idx = i;\n//            }\n                if (min > -B[i]) {\n                    min = -B[i];\n                    idx = i;\n                }\n//            if (min > A[i]) {\n//                min = A[i];\n//                idx = i;\n//            }\n            }\n\n            long ans = Long.MAX_VALUE;\n//        for (idx = 0; idx < n; idx++) {\n            PriorityQueue<S> q = new PriorityQueue<>();\n            PriorityQueue<S> qa = new PriorityQueue<>();\n            boolean[] vis = new boolean[n];\n            boolean[] vis2 = new boolean[n];\n            vis[idx] = true;\n            vis2[idx] = true;\n            q.add(new S(idx, 0));\n            long cur = 0;\n            while (!q.isEmpty()) {\n                S s = q.poll();\n                cur = Math.max(A[s.idx], B[s.idx] + cur);\n//                dump(ans, s.idx, A[s.idx], B[s.idx]);\n                for (int t : g0[s.idx]) {\n                    if (!vis2[t]) {\n                        q.add(new S(t, A[t] - B[t]));\n                        vis2[t] = true;\n                    }\n                    if (!vis[t]) {\n                        vis[t] = true;\n                        qa.add(new S(t, A[t]));\n                    }\n                }\n                while (!qa.isEmpty() && qa.peek().diff <= cur) {\n                    s = qa.poll();\n                    for (int t : g0[s.idx]) {\n                        if (!vis2[t]) {\n                            q.add(new S(t, A[t] - B[t]));\n                            vis2[t] = true;\n                        }\n                        if (!vis[t]) {\n                            vis[t] = true;\n                            qa.add(new S(t, A[t]));\n                        }\n                    }\n                }\n            }\n            ans = Math.min(ans, cur);\n//        }\n\n            out.println(ans);\n        }\n\n        class S implements Comparable<S> {\n            final int idx;\n            final int diff;\n\n            S(int i, int d) {\n                idx = i;\n                diff = d;\n            }\n\n\n            public int compareTo(S o) {\n                return diff - o.diff;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.AbstractCollection;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        List<Integer>[] g0;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            g0 = new List[n];\n\n            final int[] A = new int[n];\n            final int[] B = new int[n];\n            for (int i = 0; i < n; i++) {\n                g0[i] = new ArrayList<>();\n                A[i] = in.nextInt();\n                B[i] = in.nextInt();\n            }\n            for (int i = 0; i < m; i++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                g0[a].add(b);\n                g0[b].add(a);\n            }\n\n            PriorityQueue<Long> adj = new PriorityQueue<>();\n            long min = Long.MAX_VALUE;\n            int idx = -1;\n            for (int i = 0; i < n; i++) {\n                adj.add((long) Math.max(A[i], B[i]) << 32 | i);\n//            if (min > Math.max(A[i], B[i])) {\n//                min = Math.max(A[i], B[i]);\n//                idx = i;\n//            }\n//            if (min > Math.min(A[i], B[i])) {\n//                min = Math.min(A[i], B[i]);\n//                idx = i;\n//            }\n//            if (min > A[i] - B[i]) {\n//                min = A[i] - B[i];\n//                idx = i;\n//            }\n                if (min > -B[i]) {\n                    min = -B[i];\n                    idx = i;\n                }\n//            if (min > A[i]) {\n//                min = A[i];\n//                idx = i;\n//            }\n            }\n\n            long ans = Long.MAX_VALUE;\n            for (int rep = 0; rep < 100 && !adj.isEmpty(); rep++) {\n//        for (idx = 0; idx < n; idx++) {\n//            dump(adj.peek()>>>32);\n                idx = (int) (adj.poll() & 0xFFFFFFFFL);\n                PriorityQueue<S> q = new PriorityQueue<>();\n                PriorityQueue<S> qa = new PriorityQueue<>();\n                boolean[] vis = new boolean[n];\n                boolean[] vis2 = new boolean[n];\n                vis[idx] = true;\n                vis2[idx] = true;\n                q.add(new S(idx, 0));\n                long cur = 0;\n                while (!q.isEmpty()) {\n                    S s = q.poll();\n                    cur = Math.max(A[s.idx], B[s.idx] + cur);\n//                dump(ans, s.idx, A[s.idx], B[s.idx]);\n                    for (int t : g0[s.idx]) {\n                        if (!vis2[t]) {\n                            q.add(new S(t, A[t] - B[t]));\n                            vis2[t] = true;\n                        }\n                        if (!vis[t]) {\n                            vis[t] = true;\n                            qa.add(new S(t, A[t]));\n                        }\n                    }\n                    while (!qa.isEmpty() && qa.peek().diff <= cur) {\n                        s = qa.poll();\n                        for (int t : g0[s.idx]) {\n                            if (!vis2[t]) {\n                                q.add(new S(t, A[t] - B[t]));\n                                vis2[t] = true;\n                            }\n                            if (!vis[t]) {\n                                vis[t] = true;\n                                qa.add(new S(t, A[t]));\n                            }\n                        }\n                    }\n                }\n                ans = Math.min(ans, cur);\n//        }\n            }\n\n            out.println(ans);\n        }\n\n        class S implements Comparable<S> {\n            final int idx;\n            final int diff;\n\n            S(int i, int d) {\n                idx = i;\n                diff = d;\n            }\n\n\n            public int compareTo(S o) {\n                return diff - o.diff;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\tif( args[0].equals(\"gen\") ) {\n\t\t\t\t(new Main()).gen();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\t\n\tvoid gen() {\n\t\tint N = 100000;\n\t\tint E = 100000;\n\t\tRandom rand = new Random();\n\t\tSystem.out.println(N + \" \" + E);\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tint R = rand.nextInt(1000000000) + 1;\n\t\t\tint P = rand.nextInt(1000000000) + 1;\n\t\t\tSystem.out.println(R + \" \" + P);\n\t\t}\n\t\tfor( int i = 0; i < E; ++i ) {\n\t\t\tint F = rand.nextInt(i + 1) + 1; \n\t\t\tint T = i + 2;\n\t\t\tif( i == E - 1 ) {\n\t\t\t\tT = rand.nextInt(i + 1) + 1; \n\t\t\t}\n\t\t\tSystem.out.println(F + \" \" + T);\n\t\t}\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\tTTinit();\n\t\t\t\t__solve(cin);\n//\t\t\t\tTTstep();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tlong TTstart;\n\tvoid TTinit() {\n\t\tTTstart = System.currentTimeMillis();\n\t}\n\t\n\tvoid TTstep() {\n\t\tSystem.err.println(\"step: \" + (System.currentTimeMillis() - TTstart));\n\t}\n\n\tvoid __solve(Scanner cin) {\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tPair pair[] = new Pair[N];\n\t\t\n\t\tlong ret = 0;\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t\tif( nodes[i].req > nodes[i].pay ) {\n\t\t\t\tret = Math.max(ret, nodes[i].req - nodes[i].pay);\n\t\t\t}\n\t\t\tpair[i] = new Pair(i, Math.max(0, nodes[i].req - nodes[i].pay));\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tboolean skip[] = new boolean[N];\n\t\t\n\t\tArrays.sort(pair);\n\t\tfor( int i = 0; i < Math.min(N, 100); ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n\t\t\tret = Math.min(ret, solve(nodes, N, pair[i].key, ret, skip));\n\t\t\tskip[pair[i].key] = true; \n\t\t}\n\t\t\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n\t\t\tret = Math.min(ret, solve(nodes, N, i, ret, skip));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\t\t\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best, boolean skip[]) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tif( ret >= best ) { return best; }\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\tboolean skipF = false;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = best;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tskipF = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t\tif( skipF ) {\n\t\t\t\t\tskip[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t\tskipF = false;\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tclass Pair implements Comparable<Pair> {\n\t\t\n\t\tint key;\n\t\tint value;\n\t\t\n\t\tPair(int key, int value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif( p.value > value ) { return -1; }\n\t\t\tif( p.value < value ) { return 1; }\n\t\t\tif( p.key > key ) { return -1; }\n\t\t\tif( p.key < key ) { return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\t__solve(cin);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvoid __solve(Scanner cin) {\n\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tlong ret = Long.MAX_VALUE;\n\t\t\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tret = Math.min(ret, solve(nodes, N, i, ret));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = Long.MAX_VALUE;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    static class Node{\n        int v;\n        long A,B;\n        Node(int v,long a,long b){this.v=v;A=a;B=b;}\n    }\n\n    static long[] w0;\n    static long[] w;\n\n    static int[] pare;\n    static int root(int v){\n        if(pare[v]<0)return v;\n        return pare[v] = root(pare[v]);\n    }\n    static void unite(int p,int c){\n        p=root(p);c=root(c);\n        if(p==c)return;\n        pare[p]+=pare[c];\n        pare[c]=p;\n    }\n    static boolean same(int u,int v){\n        return root(u)==root(v);\n    }\n    static class Edge{\n        int from,to;\n        long cost;\n        Edge(int from,int to,long cost){this.from=from;this.to=to;this.cost=cost;}\n    }\n    \n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int M = scan.nextInt();\n        long[] A = new long[N];\n        long[] B = new long[N];\n        w0 = new long[N];\n        w = new long[N];\n        pare=new int[N];\n        for(int i=0;i<N;++i){\n            A[i]=scan.nextLong();\n            B[i]=scan.nextLong();\n            w0[i] = Math.max(0, A[i]-B[i]);\n            w[i] = B[i];\n        }\n        Arrays.fill(pare, -1);\n\n        PriorityQueue<Node> nodeQue[] = new PriorityQueue[N];\n        for(int i=0;i<N;++i)nodeQue[i]=new PriorityQueue<>((a,b)->(int)(((a.A-a.B)-(b.A-b.B))));\n        while(M-->0){\n            int u = scan.nextInt()-1;\n            int v = scan.nextInt()-1;\n            nodeQue[u].add(new Node(v, A[v],B[v]));\n            nodeQue[v].add(new Node(u, A[u],B[u]));\n        }\n        if(N==1){\n            System.out.println(Math.max(A[0], B[0]));\n            return;\n        }\n        PriorityQueue<Edge> que = new PriorityQueue<>((a,b)->a.cost-b.cost==0 ? a.from-b.from : a.cost-b.cost<0 ? -1 : 1);\n        for(int i=0;i<N;++i){\n            Node n = nodeQue[i].peek();\n            // System.out.println(i+\" \"+n.v+\" \"+Math.max(w0[i], w0[i] + n.A-w[i]));\n            que.add(new Edge(i, n.v, Math.max(w0[i], (n.A-n.B)-w[i])));\n        }\n\n\n        while(!que.isEmpty()){\n            Edge e = que.poll();\n            //System.out.println(e.from+\" <<< \"+e.to);\n            if(same(e.from, e.to) || e.cost != Math.max(w0[root(e.from)], A[e.to]-B[e.to]-w[root(e.from)]))continue;\n            // System.out.println(\"success\");\n            w0[root(e.from)] = e.cost;\n            w[root(e.from)] += w[root(e.to)];\n            while(!nodeQue[root(e.to)].isEmpty())nodeQue[root(e.from)].add(nodeQue[root(e.to)].poll());\n            unite(e.from, e.to);\n            // System.out.println(w0[root(e.from)]+\" \"+w[root(e.from)]);\n            while(!nodeQue[root(e.from)].isEmpty() && same(e.from, nodeQue[root(e.from)].peek().v))nodeQue[root(e.from)].poll();\n            if(nodeQue[root(e.from)].isEmpty())break;\n            Node next = nodeQue[root(e.from)].peek();\n            // System.out.println(\"add : \"+ root(e.from)+\" <<< \"+next.v);\n            que.add(new Edge(root(e.from), next.v, Math.max(w0[root(e.from)], next.A-next.B-w[root(e.from)])));\n        }\n        long sum = 0;\n        for(int i=0;i<N;++i)sum+=B[i];\n        // System.out.println();\n        // for(int i=0;i<N;++i)System.out.println(root(i));\n        System.out.println(w0[root(0)]+sum);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = ni();\n\t\t\tb[i] = ni();\n\t\t}\n\t\t\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\t\n\t\t\n\t\tint[][] ai = new int[n][];\n\t\tfor(int i = 0;i < n;i++)ai[i] = new int[]{a[i], i};\n\t\tArrays.sort(ai, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\tif(a[0] != b[0])return a[0] - b[0];\n\t\t\t\treturn a[1] - b[1];\n\t\t\t}\n\t\t});\n\t\t\n\t\tlong[] dp = new long[n];\n\t\tboolean[] done = new boolean[n];\n\t\tboolean[] ved = new boolean[n];\n\t\tDJSet ds = new DJSet(n);\n\t\tfor(int i = 0;i < n;i++)ds.bsum[i] = b[i];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint id = ai[i][1];\n\t\t\t\n\t\t\tlong dpsum = 0;\n\t\t\tint hit = 0;\n\t\t\tlong bs = 0;\n\t\t\tfor(int e : g[id]){\n\t\t\t\tif(!done[e])continue;\n\t\t\t\tif(ved[ds.root(e)])continue;\n\t\t\t\thit++;\n\t\t\t\tbs += ds.bsum[ds.root(e)];\n\t\t\t\t\n\t\t\t\tdpsum += dp[ds.root(e)];\n\t\t\t\tved[ds.root(e)] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int e : g[id]){\n\t\t\t\tved[ds.root(e)] = false;\n\t\t\t}\n\t\t\t\n\t\t\t// x -> y\n\t\t\t// >= dp[x]\n\t\t\t// >= bsum[x]+a[id]\n\t\t\t// >= bsum[x]+b[id]\n\t\t\t\n\t\t\t// y -> x\n\t\t\t// >= a[id]\n\t\t\t// >= b[id] + dp[x]\n\t\t\t\n\t\t\t// yp -> xp -> y -> zp\n\t\t\t// >= b[id] + dp[x]\n\t\t\t// >= a[id] + bsum[x]\n\t\t\t// >= b[id] + bsum[x] + dp[z]\n\t\t\t\n\t\t\t// y -> xp -> yp -> zp\n\t\t\t// >= dp[x]\n\t\t\t// >= a[id] + bsum[x]\n\t\t\t// >= b[id] + bsum[x] + dp[z]\n\t\t\t\n\t\t\t// dp[x] + bsum[so far] <= \n\t\t\t// a[id] + bsum[not last]\n\t\t\t// b[id] + bsum[not last] + last\n\t\t\t\n\t\t\t// a[id] + bsum[not last]\n\t\t\t// b[id] + bsum[not last] + dp[last]\n\t\t\tlong val = Long.MAX_VALUE;\n\t\t\tif(hit == 0){\n\t\t\t\tval = Math.max(a[id], b[id]);\n\t\t\t}else{\n\t\t\t\tfor(int e : g[id]){\n\t\t\t\t\tif(!done[e])continue;\n\t\t\t\t\tval = Math.min(val, \n\t\t\t\t\t\t\tbs - ds.bsum[ds.root(e)] + Math.max(a[id], b[id] + dp[ds.root(e)])\n\t\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tval = Math.min(val, \n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\t\tbs + b[id], \n\t\t\t\t\t\tbs + a[id])\n\t\t\t\t\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int e : g[id]){\n\t\t\t\tif(!done[e])continue;\n\t\t\t\tds.union(e, id);\n\t\t\t}\n\t\t\tdp[ds.root(id)] = val;\n//\t\t\ttr(id, val, bs);\n\t\t\t\n\t\t\tdone[id] = true;\n\t\t}\n\t\tout.println(dp[ds.root(0)]);\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\t\tpublic long[] bsum;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t\tbsum = new long[n];\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t\tbsum[x] += bsum[y];\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\tif( args[0].equals(\"gen\") ) {\n\t\t\t\t(new Main()).gen();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\t\n\tvoid gen() {\n\t\tint N = 100000;\n\t\tint E = 100000;\n\t\tRandom rand = new Random();\n\t\tSystem.out.println(N + \" \" + E);\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tint R = rand.nextInt(1000000000) + 1;\n\t\t\tint P = rand.nextInt(1000000000) + 1;\n\t\t\tSystem.out.println(R + \" \" + P);\n\t\t}\n\t\tfor( int i = 0; i < E; ++i ) {\n\t\t\tint F = rand.nextInt(i + 1) + 1; \n\t\t\tint T = i + 2;\n\t\t\tif( i == E - 1 ) {\n\t\t\t\tT = rand.nextInt(i + 1) + 1; \n\t\t\t}\n\t\t\tSystem.out.println(F + \" \" + T);\n\t\t}\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\tTTinit();\n\t\t\t\t__solve(cin);\n//\t\t\t\tTTstep();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tlong TTstart;\n\tvoid TTinit() {\n\t\tTTstart = System.currentTimeMillis();\n\t}\n\t\n\tvoid TTstep() {\n\t\tSystem.err.println(\"step: \" + (System.currentTimeMillis() - TTstart));\n\t}\n\n\tvoid __solve(Scanner cin) {\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tPair pair[] = new Pair[N];\n\t\t\n\t\tlong ret = 0;\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t\tif( nodes[i].req > nodes[i].pay ) {\n\t\t\t\tret = Math.max(ret, nodes[i].req - nodes[i].pay);\n\t\t\t}\n\t\t\tpair[i] = new Pair(i, Math.max(0, nodes[i].req - nodes[i].pay));\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tArrays.sort(pair);\n\t\tfor( int i = 0; i < Math.min(N, 16); ++i ) {\n\t\t\tret = Math.min(ret, solve(nodes, N, pair[i].key, ret));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\t\t\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tif( ret >= best ) { return best; }\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = best;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tclass Pair implements Comparable<Pair> {\n\t\t\n\t\tint key;\n\t\tint value;\n\t\t\n\t\tPair(int key, int value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif( p.value > value ) { return -1; }\n\t\t\tif( p.value < value ) { return 1; }\n\t\t\tif( p.key > key ) { return -1; }\n\t\t\tif( p.key < key ) { return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\t__solve(cin);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tvoid __solve(Scanner cin) {\n\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tlong ret = Long.MAX_VALUE;\n\t\tboolean skip[] = new boolean[N];\n\t\t\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n\t\t\tret = Math.min(ret, solve(nodes, N, i, ret, skip));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best, boolean skip[]) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\tboolean skipF = false;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = Long.MAX_VALUE;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tskipF = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t\tif( skipF ) {\n\t\t\t\t\tskip[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t\tskipF = false;\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    static class Node{\n        int v;\n        long A,B;\n        Node(int v,long a,long b){this.v=v;A=a;B=b;}\n    }\n\n    static long[] w0;\n    static long[] w;\n\n    static int[] pare;\n    static int root(int v){\n        if(pare[v]<0)return v;\n        return pare[v] = root(pare[v]);\n    }\n    static void unite(int p,int c){\n        p=root(p);c=root(c);\n        if(p==c)return;\n        w[p]+=w[c];\n        pare[p]+=pare[c];\n        pare[c]=p;\n    }\n    static boolean same(int u,int v){\n        return root(u)==root(v);\n    }\n    static class Edge{\n        int from,to;\n        long cost;\n        Edge(int from,int to,long cost){this.from=from;this.to=to;this.cost=cost;}\n    }\n    \n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int M = scan.nextInt();\n        long[] A = new long[N];\n        long[] B = new long[N];\n        w0 = new long[N];\n        w = new long[N];\n        pare=new int[N];\n        for(int i=0;i<N;++i){\n            A[i]=scan.nextLong();\n            B[i]=scan.nextLong();\n            w0[i] = Math.max(0, A[i]-B[i]);\n            w[i] = Math.max(A[i], B[i]);\n        }\n        Arrays.fill(pare, -1);\n\n        PriorityQueue<Node> nodeQue[] = new PriorityQueue[N];\n        for(int i=0;i<N;++i)nodeQue[i]=new PriorityQueue<>((a,b)->(int)(((a.A-a.B)-(b.A-b.B))));\n        while(M-->0){\n            int u = scan.nextInt()-1;\n            int v = scan.nextInt()-1;\n            nodeQue[u].add(new Node(v, A[v],B[v]));\n            nodeQue[v].add(new Node(u, A[u],B[u]));\n        }\n        PriorityQueue<Edge> que = new PriorityQueue<>((a,b)->a.cost-b.cost==0 ? a.from-b.from : a.cost-b.cost<0 ? -1 : 1);\n        for(int i=0;i<N;++i){\n            Node n = nodeQue[i].peek();\n            // System.out.println(i+\" \"+n.v+\" \"+Math.max(w0[i], w0[i] + n.A-w[i]));\n            que.add(new Edge(i, n.v, Math.max(w0[i], w0[i] + (n.A-n.B)-w[i])));\n        }\n\n\n        while(!que.isEmpty()){\n            Edge e = que.poll();\n            // System.out.println(e.from+\" <<< \"+e.to);\n            if(same(e.from, e.to) || e.cost != Math.max(w0[root(e.from)], w0[root(e.from)]+A[e.to]-B[e.to]-w[root(e.from)]))continue;\n            // System.out.println(\"success\");\n            w0[root(e.from)] = e.cost;\n            while(!nodeQue[root(e.to)].isEmpty())nodeQue[root(e.from)].add(nodeQue[root(e.to)].poll());\n            unite(e.from, e.to);\n            // System.out.println(w0[root(e.from)]+\" \"+w[root(e.from)]);\n            while(!nodeQue[root(e.from)].isEmpty() && same(e.from, nodeQue[root(e.from)].peek().v))nodeQue[root(e.from)].poll();\n            if(nodeQue[root(e.from)].isEmpty())break;\n            Node next = nodeQue[root(e.from)].peek();\n            // System.out.println(\"add : \"+ root(e.from)+\" <<< \"+next.v);\n            que.add(new Edge(root(e.from), next.v, Math.max(w0[root(e.from)], w0[root(e.from)] + next.A-next.B-w[root(e.from)])));\n        }\n        long sum = 0;\n        for(int i=0;i<N;++i)sum+=B[i];\n        // System.out.println();\n        // for(int i=0;i<N;++i)System.out.println(root(i));\n        System.out.println(w0[root(0)]+sum);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.AbstractCollection;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        List<Integer>[] g0;\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            g0 = new List[n];\n\n            final int[] A = new int[n];\n            final int[] B = new int[n];\n            for (int i = 0; i < n; i++) {\n                g0[i] = new ArrayList<>();\n                A[i] = in.nextInt();\n                B[i] = in.nextInt();\n            }\n            for (int i = 0; i < m; i++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                g0[a].add(b);\n                g0[b].add(a);\n            }\n\n            PriorityQueue<Long> adj = new PriorityQueue<>();\n            long min = Long.MAX_VALUE;\n            int idx = -1;\n            for (int i = 0; i < n; i++) {\n                adj.add((long) Math.max(A[i], B[i]) << 32 | i);\n//            if (min > Math.max(A[i], B[i])) {\n//                min = Math.max(A[i], B[i]);\n//                idx = i;\n//            }\n//            if (min > Math.min(A[i], B[i])) {\n//                min = Math.min(A[i], B[i]);\n//                idx = i;\n//            }\n//            if (min > A[i] - B[i]) {\n//                min = A[i] - B[i];\n//                idx = i;\n//            }\n                if (min > -B[i]) {\n                    min = -B[i];\n                    idx = i;\n                }\n//            if (min > A[i]) {\n//                min = A[i];\n//                idx = i;\n//            }\n            }\n\n            long ans = Long.MAX_VALUE;\n//        for (int rep = 0; rep < 100 && !adj.isEmpty(); rep++) {\n            for (idx = 0; idx < n; idx++) {\n//            dump(adj.peek()>>>32);\n//            idx = (int)(adj.poll() & 0xFFFFFFFFL);\n                PriorityQueue<S> q = new PriorityQueue<>();\n                PriorityQueue<S> qa = new PriorityQueue<>();\n                boolean[] vis = new boolean[n];\n                boolean[] vis2 = new boolean[n];\n                vis[idx] = true;\n                vis2[idx] = true;\n                q.add(new S(idx, 0));\n                long cur = 0;\n                while (!q.isEmpty()) {\n                    S s = q.poll();\n                    cur = Math.max(A[s.idx], B[s.idx] + cur);\n//                dump(ans, s.idx, A[s.idx], B[s.idx]);\n                    for (int t : g0[s.idx]) {\n                        if (!vis2[t]) {\n                            q.add(new S(t, A[t] - B[t]));\n                            vis2[t] = true;\n                        }\n                        if (!vis[t]) {\n                            vis[t] = true;\n                            qa.add(new S(t, A[t]));\n                        }\n                    }\n                    while (!qa.isEmpty() && qa.peek().diff <= cur) {\n                        s = qa.poll();\n                        for (int t : g0[s.idx]) {\n                            if (!vis2[t]) {\n                                q.add(new S(t, A[t] - B[t]));\n                                vis2[t] = true;\n                            }\n                            if (!vis[t]) {\n                                vis[t] = true;\n                                qa.add(new S(t, A[t]));\n                            }\n                        }\n                    }\n                }\n                ans = Math.min(ans, cur);\n//        }\n            }\n\n            out.println(ans);\n        }\n\n        class S implements Comparable<S> {\n            final int idx;\n            final int diff;\n\n            S(int i, int d) {\n                idx = i;\n                diff = d;\n            }\n\n\n            public int compareTo(S o) {\n                return diff - o.diff;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n@SuppressWarnings(\"unchecked\")\nclass Main{\n\n    static class Node{\n        int v;\n        long A,B;\n        Node(int v,long a,long b){this.v=v;A=a;B=b;}\n    }\n\n    static long[] w0;\n    static long[] w;\n\n    static int[] pare;\n    static int root(int v){\n        if(pare[v]<0)return v;\n        return pare[v] = root(pare[v]);\n    }\n    static void unite(int p,int c){\n        p=root(p);c=root(c);\n        if(p==c)return;\n        pare[p]+=pare[c];\n        pare[c]=p;\n    }\n    static boolean same(int u,int v){\n        return root(u)==root(v);\n    }\n    static class Edge{\n        int from,to;\n        long cost;\n        Edge(int from,int to,long cost){this.from=from;this.to=to;this.cost=cost;}\n    }\n    \n\n    public static void main(String[] args){\n        Scanner scan = new Scanner(System.in);\n        int N = scan.nextInt();\n        int M = scan.nextInt();\n        long[] A = new long[N];\n        long[] B = new long[N];\n        w0 = new long[N];\n        w = new long[N];\n        pare=new int[N];\n        for(int i=0;i<N;++i){\n            A[i]=scan.nextLong();\n            B[i]=scan.nextLong();\n            w0[i] = Math.max(0, A[i]-B[i]);\n            w[i] = B[i];\n        }\n        Arrays.fill(pare, -1);\n\n        PriorityQueue<Node> nodeQue[] = new PriorityQueue[N];\n        for(int i=0;i<N;++i)nodeQue[i]=new PriorityQueue<>((a,b)->(int)(((a.A-a.B)-(b.A-b.B))));\n        while(M-->0){\n            int u = scan.nextInt()-1;\n            int v = scan.nextInt()-1;\n            nodeQue[u].add(new Node(v, A[v],B[v]));\n            nodeQue[v].add(new Node(u, A[u],B[u]));\n        }\n        PriorityQueue<Edge> que = new PriorityQueue<>((a,b)->a.cost-b.cost==0 ? a.from-b.from : a.cost-b.cost<0 ? -1 : 1);\n        for(int i=0;i<N;++i){\n            Node n = nodeQue[i].peek();\n            // System.out.println(i+\" \"+n.v+\" \"+Math.max(w0[i], w0[i] + n.A-w[i]));\n            que.add(new Edge(i, n.v, Math.max(w0[i], (n.A-n.B)-w[i])));\n        }\n\n\n        while(!que.isEmpty()){\n            Edge e = que.poll();\n            //System.out.println(e.from+\" <<< \"+e.to);\n            if(same(e.from, e.to) || e.cost != Math.max(w0[root(e.from)], A[e.to]-B[e.to]-w[root(e.from)]))continue;\n            // System.out.println(\"success\");\n            w0[root(e.from)] = e.cost;\n            w[root(e.from)] += w[root(e.to)];\n            while(!nodeQue[root(e.to)].isEmpty())nodeQue[root(e.from)].add(nodeQue[root(e.to)].poll());\n            unite(e.from, e.to);\n            // System.out.println(w0[root(e.from)]+\" \"+w[root(e.from)]);\n            while(!nodeQue[root(e.from)].isEmpty() && same(e.from, nodeQue[root(e.from)].peek().v))nodeQue[root(e.from)].poll();\n            if(nodeQue[root(e.from)].isEmpty())break;\n            Node next = nodeQue[root(e.from)].peek();\n            // System.out.println(\"add : \"+ root(e.from)+\" <<< \"+next.v);\n            que.add(new Edge(root(e.from), next.v, Math.max(w0[root(e.from)], next.A-next.B-w[root(e.from)])));\n        }\n        long sum = 0;\n        for(int i=0;i<N;++i)sum+=B[i];\n        // System.out.println();\n        // for(int i=0;i<N;++i)System.out.println(root(i));\n        System.out.println(w0[root(0)]+sum);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\tif( args[0].equals(\"gen\") ) {\n\t\t\t\t(new Main()).gen();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\t\n\tvoid gen() {\n\t\tint N = 100000;\n\t\tint E = 100000;\n\t\tRandom rand = new Random();\n\t\tSystem.out.println(N + \" \" + E);\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tint R = rand.nextInt(1000000000) + 1;\n\t\t\tint P = rand.nextInt(1000000000) + 1;\n\t\t\tSystem.out.println(R + \" \" + P);\n\t\t}\n\t\tfor( int i = 0; i < E; ++i ) {\n\t\t\tint F = rand.nextInt(i + 1) + 1; \n\t\t\tint T = i + 2;\n\t\t\tif( i == E - 1 ) {\n\t\t\t\tT = rand.nextInt(i + 1) + 1; \n\t\t\t}\n\t\t\tSystem.out.println(F + \" \" + T);\n\t\t}\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\tTTinit();\n\t\t\t\t__solve(cin);\n//\t\t\t\tTTstep();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tlong TTstart;\n\tvoid TTinit() {\n\t\tTTstart = System.currentTimeMillis();\n\t}\n\t\n\tvoid TTstep() {\n\t\tSystem.err.println(\"step: \" + (System.currentTimeMillis() - TTstart));\n\t}\n\n\tvoid __solve(Scanner cin) {\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tPair pair[] = new Pair[N];\n\t\t\n\t\tlong ret = 0;\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t\tif( nodes[i].req > nodes[i].pay ) {\n\t\t\t\tret = Math.max(ret, nodes[i].req - nodes[i].pay);\n\t\t\t}\n\t\t\tpair[i] = new Pair(i, Math.max(0, nodes[i].req - nodes[i].pay));\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tboolean skip[] = new boolean[N];\n\t\t\n\t\tArrays.sort(pair);\n\t\tfor( int i = 0; i < Math.min(N, 200); ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n\t\t\tret = Math.min(ret, solve(nodes, N, pair[i].key, ret, skip));\n\t\t\tskip[pair[i].key] = true; \n\t\t}\n\t\t\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n//\t\t\tret = Math.min(ret, solve(nodes, N, i, ret, skip));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\t\t\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best, boolean skip[]) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tif( ret >= best ) { return best; }\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\tboolean skipF = false;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = best;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tskipF = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t\tif( skipF ) {\n\t\t\t\t\tskip[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t\tskipF = false;\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tclass Pair implements Comparable<Pair> {\n\t\t\n\t\tint key;\n\t\tint value;\n\t\t\n\t\tPair(int key, int value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif( p.value > value ) { return -1; }\n\t\t\tif( p.value < value ) { return 1; }\n\t\t\tif( p.key > key ) { return -1; }\n\t\t\tif( p.key < key ) { return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\tif( args[0].equals(\"gen\") ) {\n\t\t\t\t(new Main()).gen();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\t\n\tvoid gen() {\n\t\tint N = 100000;\n\t\tint E = 100000;\n\t\tRandom rand = new Random();\n\t\tSystem.out.println(N + \" \" + E);\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tint R = rand.nextInt(1000000000) + 1;\n\t\t\tint P = rand.nextInt(1000000000) + 1;\n\t\t\tSystem.out.println(R + \" \" + P);\n\t\t}\n\t\tfor( int i = 0; i < E; ++i ) {\n\t\t\tint F = rand.nextInt(i + 1) + 1; \n\t\t\tint T = i + 2;\n\t\t\tif( i == E - 1 ) {\n\t\t\t\tT = rand.nextInt(i + 1) + 1; \n\t\t\t}\n\t\t\tSystem.out.println(F + \" \" + T);\n\t\t}\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\tTTinit();\n\t\t\t\t__solve(cin);\n//\t\t\t\tTTstep();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tlong TTstart;\n\tvoid TTinit() {\n\t\tTTstart = System.currentTimeMillis();\n\t}\n\t\n\tvoid TTstep() {\n\t\tSystem.err.println(\"step: \" + (System.currentTimeMillis() - TTstart));\n\t}\n\n\tvoid __solve(Scanner cin) {\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tlong ret = 0;\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t\tif( nodes[i].req > nodes[i].pay ) {\n\t\t\t\tret = Math.max(ret, nodes[i].req - nodes[i].pay);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tboolean skip[] = new boolean[N];\n\t\t\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tif( skip[i] ) { continue; }\n\t\t\tret = Math.min(ret, solve(nodes, N, i, ret, skip));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\t\t\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best, boolean skip[]) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tif( ret >= best ) { return best; }\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\tboolean skipF = false;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = best;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tskipF = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t\tif( skipF ) {\n\t\t\t\t\tskip[next] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t\tskipF = false;\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String args[]) {\n\t\tint rep = 1;\n\t\tif (args.length > 0) {\n\t\t\tif( args[0].equals(\"gen\") ) {\n\t\t\t\t(new Main()).gen();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trep = Integer.parseInt(args[0]);\n\t\t}\n\t\t(new Main()).__solve(rep);\n\t}\n\t\n\tvoid gen() {\n\t\tint N = 100000;\n\t\tint E = 100000;\n\t\tRandom rand = new Random();\n\t\tSystem.out.println(N + \" \" + E);\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tint R = rand.nextInt(1000000000) + 1;\n\t\t\tint P = rand.nextInt(1000000000) + 1;\n\t\t\tSystem.out.println(R + \" \" + P);\n\t\t}\n\t\tfor( int i = 0; i < E; ++i ) {\n\t\t\tint F = rand.nextInt(i + 1) + 1; \n\t\t\tint T = i + 2;\n\t\t\tif( i == E - 1 ) {\n\t\t\t\tT = rand.nextInt(i + 1) + 1; \n\t\t\t}\n\t\t\tSystem.out.println(F + \" \" + T);\n\t\t}\n\t}\n\n\tvoid __solve(int rep) {\n\n\t\ttry (Scanner cin = new Scanner(System.in);) {\n\n\t\t\tfor (int i = 0; i < rep; ++i) {\n\t\t\t\tTTinit();\n\t\t\t\t__solve(cin);\n//\t\t\t\tTTstep();\n\t\t\t}\n\n\t\t}\n\n\t}\n\t\n\tlong TTstart;\n\tvoid TTinit() {\n\t\tTTstart = System.currentTimeMillis();\n\t}\n\t\n\tvoid TTstep() {\n\t\tSystem.err.println(\"step: \" + (System.currentTimeMillis() - TTstart));\n\t}\n\n\tvoid __solve(Scanner cin) {\n\t\t\n\t\tint N = cin.nextInt();\n\t\tint E = cin.nextInt();\n\t\tlong sum = 0;\n\t\t\n\t\tPair pair[] = new Pair[N];\n\t\t\n\t\tlong ret = 0;\n\t\tNode nodes[] = new Node[N];\n\t\tfor( int i = 0; i < N; ++i ) {\n\t\t\tnodes[i] = new Node(cin.nextInt(), cin.nextInt());\n\t\t\tsum += nodes[i].pay;\n\t\t\tif( nodes[i].req > nodes[i].pay ) {\n\t\t\t\tret = Math.max(ret, nodes[i].req - nodes[i].pay);\n\t\t\t}\n\t\t\tpair[i] = new Pair(i, Math.max(0, nodes[i].req - nodes[i].pay));\n\t\t}\n\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tint F = cin.nextInt() - 1;\n\t\t\tint T = cin.nextInt() - 1;\n\t\t\tnodes[F].add(T);\n\t\t\tnodes[T].add(F);\n\t\t}\n\t\t\n\t\tArrays.sort(pair);\n\t\tfor( int i = 0; i < Math.min(N, 50); ++i ) {\n\t\t\tret = Math.min(ret, solve(nodes, N, pair[i].key, ret));\n\t\t}\n\t\t\n\t\tSystem.out.println(ret + sum);\n\t\t\n\t}\n\t\n\tlong solve(Node nodes[], int N, int start, long best) {\n\t\tboolean visited[] = new boolean[N];\n\t\tvisited[start] = true;\n\t\tlong ret = Math.max(0, nodes[start].req - nodes[start].pay);\n\t\tif( ret >= best ) { return best; }\n\t\tlong total = nodes[start].pay;\n\t\t\n\t\tSet<Integer> reach = new HashSet<Integer>();\n\t\tnodes[start].merge(reach, visited);\n\t\t\n\t\tint rest = N - 1;\n\t\t\n\t\twhile( rest > 0 ) {\n\t\t\tList<Integer> add = new ArrayList<Integer>();\n\t\t\tlong diff = best;\n\t\t\tfor( int next : reach ) {\n\t\t\t\tif( visited[next] ) {\n\t\t\t\t\tthrow new RuntimeException(\"implementation error...\");\n\t\t\t\t}\n\t\t\t\tif( total + ret + nodes[next].pay >= nodes[next].req ) {\n\t\t\t\t\ttotal += nodes[next].pay;\n\t\t\t\t\tadd.add(next);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiff = Math.min(diff, nodes[next].req - (total + ret + nodes[next].pay));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( add.isEmpty() ) {\n\t\t\t\tret += diff;\n\t\t\t\tif( ret >= best ) { return best; }\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tvisited[next] = true;\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\tnodes[next].merge(reach, visited);\n\t\t\t}\n\t\t\tfor( int next : add ) {\n\t\t\t\treach.remove(next);\n\t\t\t}\n\t\t\trest -= add.size();\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t}\n\t\n\tclass Node {\n\t\t\n\t\tint req;\n\t\tint pay;\n\t\t\n\t\tList<Integer> edge;\n\t\t\n\t\tNode(int req, int pay) {\n\t\t\tthis.req = req;\n\t\t\tthis.pay = pay;\n\t\t\tedge = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\tvoid add(int target) {\n\t\t\tedge.add(target);\n\t\t}\n\t\t\n\t\tvoid merge(Set<Integer> reach, boolean visited[]) {\n\t\t\tfor( int node : edge ) {\n\t\t\t\tif( visited[node] ) { continue; }\n\t\t\t\treach.add(node);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tclass Pair implements Comparable<Pair> {\n\t\t\n\t\tint key;\n\t\tint value;\n\t\t\n\t\tPair(int key, int value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif( p.value > value ) { return -1; }\n\t\t\tif( p.value < value ) { return 1; }\n\t\t\tif( p.key > key ) { return -1; }\n\t\t\tif( p.key < key ) { return 1; }\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t}\n\t\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ARC98_F {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static List<Con> lcon = new List<Con>();\n\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            group = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n                MakeSet(i);\n            }\n\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                var U = int.Parse(var[0]) - 1;\n                var V = int.Parse(var[1]) - 1;\n                lcon.Add(new Con(U, V, AmB[U], AmB[V]));\n            }\n\n            lcon.Sort((a, b) => (a.C - b.C));\n\n            var tree = new List<int>[N];\n            for (int i = 0; i < N; i++) { tree[i] = new List<int>(); }\n            var sumB = new int[N];\n            for (int i = 0; i < N; i++) { sumB[i] = B[i]; }\n            var ans = new int[N];\n            for (int i = 0; i < N; i++) { ans[i] = AmB[i] + B[i]; }\n\n            int mq = 0;\n            for (int i = 0; i < M; i++) {\n                var u = lcon[i].U;\n                var v = lcon[i].V;\n                var gu = Find(u);\n                var gv = Find(v);\n                if (gu == gv) continue;\n\n                if (AmB[u] < AmB[v]) { var k = u; u = v; v = k; k = gu; gu = gv; gv = k; }\n\n                sumB[gu] += sumB[gv];\n                tree[gu].Add(gv);\n                Union(u, v);\n\n                mq = AmB[gu] + sumB[gu];\n                for (int j = 0; j < tree[gu].Count; j++) {\n                    var k = tree[gu][j];\n                    var q = (ans[k] > AmB[gu]) ? ans[k] : AmB[gu];\n                    q = q + sumB[gu] - sumB[k];\n                    if (q < mq) { mq = q; }\n                }\n                ans[gu] = mq;\n            }\n\n            Console.WriteLine(mq.ToString());\n        }\n\n\n\n        static int[] group;\n        static int Find(int x) {\n            if (group[x] == x) return x;\n            return Find(group[x]);\n        }\n        static void Union(int x, int y) {\n            x = Find(x);\n            y = Find(y);\n            if (x != y) group[y] = x;\n        }\n        static void MakeSet(int x) {\n            group[x] = x;\n        }\n\n    }\n\n    class Con {\n        public int U;\n        public int V;\n        public int C;\n\n        public Con(int u, int v, int c1, int c2) {\n            U = u;\n            V = v;\n            if (c1 > c2) {\n                C = c2;\n            } else {\n                C = c1;\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ARCF {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static int[] U;\n        static int[] V;\n        static Dictionary<int, List<int>> connection = new Dictionary<int, List<int>>();\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n            }\n            U = new int[M];\n            V = new int[M];\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                U[i] = int.Parse(var[0]);\n                V[i] = int.Parse(var[1]);//U<V\n            }\n\n            for (int i = 0; i < N; i++) {\n                connection.Add(i, new List<int>());\n            }\n            for (int i = 0; i < M; i++) {\n                connection[U[i] - 1].Add(V[i] - 1);\n                connection[V[i] - 1].Add(U[i] - 1);\n            }\n\n\n            var p = new int[N];\n            int s = 0;\n            for (int i = 0; i < N; i++) { p[i] = i; s += B[p[i]]; }\n\n            Console.WriteLine(calc(p, s).ToString());\n            Console.ReadLine();\n        }\n\n\n        static int calc(int[] p, int s0) {\n            if (p.Length == 1) { return AmB[p[0]] + B[p[0]]; }\n\n            int mci = 0;\n            int mc = AmB[p[0]];\n            for (int i = 1; i < p.Length; i++) {\n                if (AmB[p[i]] > mc) { mc = AmB[p[i]]; mci = p[i]; }\n            }\n\n            var LL = split(p, mci);\n\n            int mq = int.MaxValue;\n            foreach (var l in LL) {\n                int s = 0;\n                for (int i = 0; i < l.Length; i++) { s += B[l[i]]; }\n\n                var q = calc(l, s);\n                if (q > AmB[mci]) {\n                    q = q + s0 - s;\n                } else {\n                    q = AmB[mci] + s0 - s;\n                }\n                if (q < mq) { mq = q; }\n            }\n\n            return mq;\n        }\n\n        static List<int[]> split(int[] p, int mci) {\n            var r = new List<int[]>();\n\n            var lp = new List<int>(p);\n            lp.Remove(mci);\n\n            while (lp.Count > 0) {\n                var g = new List<int>();\n                var s = new Queue<int>();\n                s.Enqueue(lp[0]);\n                do {\n                    var pp = s.Dequeue();\n                    if (lp.Remove(pp)) {\n                        g.Add(pp);\n                        foreach (int i in connection[pp]) { s.Enqueue(i); }\n                    }\n                } while (s.Count > 0);\n\n                r.Add(g.ToArray());\n            }\n            return r;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ARC98_F {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static List<Con> lcon = new List<Con>();\n\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            group = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n                MakeSet(i);\n            }\n\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                var U = int.Parse(var[0]) - 1;\n                var V = int.Parse(var[1]) - 1;\n                if (U > V) { int k = U; U = V; V = k; }\n                lcon.Add(new Con(U, V, AmB[U], AmB[V]));\n            }\n\n            lcon.Sort((a, b) => (a.C - b.C));\n\n            var tree = new List<int>[N];\n            for (int i = 0; i < N; i++) { tree[i] = new List<int>(); }\n            var sumB = new int[N];\n            for (int i = 0; i < N; i++) { sumB[i] = B[i]; }\n\n            var ss = new List<KeyValuePair<int, int>>();\n            for (int i = 0; i < N; i++) { ss.Add(new KeyValuePair<int, int>(-1, i)); }\n\n            for (int i = 0; i < M; i++) {\n                var u = lcon[i].U;\n                var v = lcon[i].V;\n                var gu = Find(u);\n                var gv = Find(v);\n                if (gu == gv) continue;\n                //if (AmB[u] < AmB[v]) { var k = u; u = v; v = k; k = gu; gu = gv; gv = k; }\n                //AmB[u] >= AmB[v]\n                tree[gu].Add(gv);\n                sumB[gu] += sumB[gv];\n                Union(u, v);\n                ss[gu] = new KeyValuePair<int, int>(i, gu);\n            }\n\n            ss.Sort((a, b) => a.Key - b.Key);\n\n            var ans = new int[N];\n            int mq = 0;\n            for (int i = 0; i < N; i++) {\n                var l = ss[i].Value;\n                mq = AmB[l] + sumB[l];\n                for (int j = 0; j < tree[l].Count; j++) {\n                    var k = tree[l][j];\n                    var q = (ans[k] > AmB[l]) ? ans[k] : AmB[l];\n                    q = q + sumB[l] - sumB[k];\n                    if (q < mq) { mq = q; }\n                }\n                ans[l] = mq;\n            }\n\n            Console.WriteLine(mq.ToString());\n        }\n\n\n\n        static int[] group;\n        static int Find(int x) {\n            if (group[x] == x) return x;\n            group[x] = Find(group[x]);\n            return group[x];\n        }\n        static void Union(int x, int y) {\n            x = Find(x);\n            y = Find(y);\n            group[x] = y;\n        }\n        static void MakeSet(int x) {\n            group[x] = x;\n        }\n\n    }\n\n    class Con {\n        public int U;\n        public int V;\n        public int C;\n\n        public Con(int u, int v, int uc, int vc) {\n            if (uc > vc) {\n                U = u;\n                V = v;\n                C = uc;\n            } else {\n                U = v;\n                V = u;\n                C = vc;\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            //逆からみる\n            //始点含め、初めて訪れると B_v 円もらえる\n            //A_v 円払ったら出られる\n            //なので入れる条件は C_v = max(0,A_v - B_v) 円もっていること\n            //始点を固定してシミュレーションすることにする\n            //はじめ X 円、いける頂点が減ることはない\n            //O(N^2 polylogN) でできた\n\n            // X 円持ってるときに行き放題な領域、これは森で表現できる\n            // C_v の小さいほうから見てC_v>=C_u なら辺を張る、みたいな感じになっている\n            // 親のときは C_v 円でやりたい放題\n            // 子のときは max(dp[u],C_v-S_u) 円でやりたい放題\n\n            var n = ri; var m = ri;\n            var AB = Enumerate(n, x => new long[] { rl, rl });\n            var C = Enumerate(n, x => Max(0, AB[x][0] - AB[x][1]));\n            var G = Enumerate(n, x => new List<int>());\n            foreach (var i in Rep(m)) {\n                var u = ri - 1;\n                var v = ri - 1;\n                G[u].Add(v); G[v].Add(u);\n            }\n            var H = Enumerate(n, x => new List<int>());\n            var r = Enumerate(n, x => x);\n            var s = new DisjointSet(n);\n            foreach (var id in Enumerate(n, x => x).OrderBy(x => C[x] * 1000000L + x)) {\n                foreach (var t in G[id]) {\n                    var v = C[id] * 1000000L + id;\n                    var u = C[t] * 1000000L + t;\n                    if (v >= u && !s.IsUnited(id, t)) {\n                        H[id].Add(r[s[t]]);\n                        s.Unite(id, t);\n                        r[s[id]] = id;\n                    }\n                }\n            }\n            Func<int, KeyValuePair<long, long>> dfs = null;\n            dfs = (cur) => {\n                var sum = AB[cur][1];\n                var ret = C[cur];\n                foreach (var t in H[cur]) {\n                    var res = dfs(t);\n                    sum += res.Key;\n                    ret = Min(ret, Max(res.Value, C[cur] - res.Key));\n                }\n\n                return new KeyValuePair<long, long>(sum, ret);\n            };\n            var ans = dfs(r[s[0]]);\n            Console.WriteLine(ans.Key + ans.Value);\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ARC98_F {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static List<Con> lcon = new List<Con>();\n\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            group = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n                MakeSet(i);\n            }\n\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                var U = int.Parse(var[0]) - 1;\n                var V = int.Parse(var[1]) - 1;\n                lcon.Add(new Con(U, V, AmB[U], AmB[V]));\n            }\n\n            lcon.Sort((a, b) => (a.C - b.C));\n\n            var tree = new List<int>[N];\n            for (int i = 0; i < N; i++) { tree[i] = new List<int>(); }\n            var sumB = new int[N];\n            for (int i = 0; i < N; i++) { sumB[i] = B[i]; }\n            var ans = new int[N];\n            for (int i = 0; i < N; i++) { ans[i] = AmB[i] + B[i]; }\n\n            int mq = 0;\n            for (int i = 0; i < M; i++) {\n                var u = lcon[i].U;\n                var v = lcon[i].V;\n                var gu = Find(u);\n                var gv = Find(v);\n                if (gu == gv) continue;\n\n                if (AmB[u] < AmB[v]) { var k = u; u = v; v = k; k = gu; gu = gv; gv = k; }\n\n                sumB[gu] += sumB[gv];\n                tree[gu].Add(gv);\n\n                mq = AmB[gu] + sumB[gu];\n                for (int j = 0; j < tree[gu].Count; j++) {\n                    var k = tree[gu][j];\n                    var q = (ans[k] > AmB[gu]) ? ans[k] : AmB[gu];\n                    q = q + sumB[gu] - sumB[k];\n                    if (q < mq) { mq = q; }\n                }\n                ans[gu] = mq;\n                Union(u, v);\n            }\n\n            Console.WriteLine(mq.ToString());\n            Console.ReadLine();\n        }\n\n\n\n        static int[] group;\n        static int Find(int x) {\n            if (group[x] == x) return x;\n            return Find(group[x]);\n        }\n        static void Union(int x, int y) {\n            x = Find(x);\n            y = Find(y);\n            if (x != y) group[y] = x;\n        }\n        static void MakeSet(int x) {\n            group[x] = x;\n        }\n\n    }\n\n    class Con {\n        public int U;\n        public int V;\n        public int C;\n\n        public Con(int u, int v, int c1, int c2) {\n            U = u;\n            V = v;\n            if (c1 > c2) {\n                C = c2;\n            } else {\n                C = c1;\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ARC98_F {\n    class Program {\n\n        static long[] A;\n        static long[] B;\n        static long[] AmB;\n        static List<Con> lcon = new List<Con>();\n\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new long[N];\n            B = new long[N];\n            AmB = new long[N];\n            group = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = long.Parse(var[0]);\n                B[i] = long.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n                MakeSet(i);\n            }\n\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                var U = int.Parse(var[0]) - 1;\n                var V = int.Parse(var[1]) - 1;\n                if (U > V) { int k = U; U = V; V = k; }\n\n                lcon.Add(new Con(U, V, AmB[U], AmB[V]));\n            }\n\n            lcon.Sort((a, b) => Math.Sign(a.C - b.C));\n\n            var tree = new List<int>[N];\n            for (int i = 0; i < N; i++) { tree[i] = new List<int>(); }\n\n            var ss = new List<KeyValuePair<int, int>>();\n            for (int i = 0; i < N; i++) { ss.Add(new KeyValuePair<int, int>(-1, i)); }\n\n            var sumB = new long[N];\n            for (int i = 0; i < N; i++) { sumB[i] = B[i]; }\n\n            for (int i = 0; i < M; i++) {\n                var u = lcon[i].U;\n                var v = lcon[i].V;\n                var gu = Find(u);\n                var gv = Find(v);\n                if (gu == gv) continue;\n                tree[gu].Add(gv);\n                sumB[gu] += sumB[gv];\n                Union(u, v);\n                ss[gu] = new KeyValuePair<int, int>(i, gu);\n            }\n\n            ss.Sort((a, b) => a.Key - b.Key);\n\n            var ans = new long[N];\n            for (int i = 0; i < N; i++) { ans[i] = AmB[i] + B[i]; }\n\n            long mq = 0;\n            for (int i = 0; i < N; i++) {\n                var l = ss[i].Value;\n                mq = AmB[l] + sumB[l];\n                for (int j = 0; j < tree[l].Count; j++) {\n                    var k = tree[l][j];\n                    var q = (ans[k] > AmB[l]) ? ans[k] : AmB[l];\n                    q = q + sumB[l] - sumB[k];\n                    if (q < mq) { mq = q; }\n                }\n                ans[l] = mq;\n            }\n\n            Console.WriteLine(mq.ToString());\n        }\n\n        static int[] group;\n        static int Find(int x) {\n            if (group[x] == x) return x;\n            group[x] = Find(group[x]);\n            return group[x];\n        }\n        static void Union(int x, int y) {\n            x = Find(x);\n            y = Find(y);\n            group[y] = x;\n        }\n        static void MakeSet(int x) {\n            group[x] = x;\n        }\n\n    }\n\n    class Con {\n        public int U;\n        public int V;\n        public long C;\n\n        public Con(int u, int v, long uc, long vc) {\n            if (uc > vc) {\n                U = u;\n                V = v;\n                C = uc;\n            } else {\n                U = v;\n                V = u;\n                C = vc;\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int M = re.i();\n        long[] A = new long[N];\n        long[] B = new long[N];\n        for(int i=0;i<N;i++){\n            A[i] = re.i();\n            B[i] = re.i();\n        }\n        Edge[] E = new Edge[M];\n        for(int i=0;i<M;i++){\n            int f = re.i()-1;\n            int t = re.i()-1;\n            E[i] = new Edge(f,t,Math.Max(A[f],A[t]));\n        }\n        Array.Sort(E,(x,y)=>(x.cost>y.cost ? 1 : (x.cost == y.cost ? 0 : -1)));\n        // UnionFind U = new UnioFind(N);\n        // bool[] used = new bool[M];\n        // for(int i=0;i<N;i++){\n        //     if(!U.Same(E[i].f,E[i].t)){\n        //         used[i] = true;\n        //         U.Union(E[i].f,E[i].t);\n        //     }\n        // }\n        UnionFind U = new UnionFind(N,B);\n        long[] Cost = new long[N];\n        for(int i=0;i<N;i++){\n            Cost[i] = B[i];\n        }\n        long count = 0;\n        for(int i=0;i<M;i++){\n            if(!U.Same(E[i].f,E[i].t)){\n                int f = U.Get(E[i].f);\n                int t = U.Get(E[i].t);\n                long cost1 = Math.Max(U.num[f]+Math.Max(Cost[t],A[E[i].t]),U.num[f]-B[E[i].f]+A[E[i].f]);\n                long cost2 = Math.Max(U.num[t]+Math.Max(Cost[f],A[E[i].f]),U.num[t]-B[E[i].t]+A[E[i].t]);\n                U.Union(E[i].f,E[i].t);\n                Cost[f] = Math.Min(cost1,cost2);\n            }\n        }\n        for(int i=0;i<N;i++){\n            count = Math.Max(Cost[i],count);\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nstruct Edge{\n    public int f;\n    public int t;\n    public long cost;\n    public Edge(int f0,int t0,long c){\n        f = f0;\n        t = t0;\n        cost = c;\n    }\n}\nclass UnionFind{\n    int[] par;\n    public long[] num;\n    public UnionFind(int n){\n        par = new int[n];\n        num = new long[n];\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            num[i] = 1;\n        }\n    }\n    public UnionFind(int n,long[] A){\n        par = new int[n];\n        num = new long[n];\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            num[i] = A[i];\n        }\n    }\n    public long Num(int x){\n        return num[Get(x)];\n    }\n    public void Union(int x,int y){\n        int i = Get(x);\n        int j = Get(y);\n        if(i != j){\n            num[i] += num[j];\n            par[j] = i;  \n        } \n    }\n    public bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    public int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ARC98_F {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static List<Con> lcon = new List<Con>();\n\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            group = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n                MakeSet(i);\n            }\n\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                var U = int.Parse(var[0]) - 1;\n                var V = int.Parse(var[1]) - 1;\n                if (U > V) { int k = U; U = V; V = k; }\n\n                lcon.Add(new Con(U, V, AmB[U], AmB[V]));\n            }\n\n            lcon.Sort((a, b) => (a.C - b.C));\n\n            var tree = new List<int>[N];\n            for (int i = 0; i < N; i++) { tree[i] = new List<int>(); }\n\n            var ss = new List<KeyValuePair<int, int>>();\n            for (int i = 0; i < N; i++) { ss.Add(new KeyValuePair<int, int>(-1, i)); }\n\n            var sumB = new int[N];\n            for (int i = 0; i < N; i++) { sumB[i] = B[i]; }\n\n            for (int i = 0; i < M; i++) {\n                var u = lcon[i].U;\n                var v = lcon[i].V;\n                var gu = Find(u);\n                var gv = Find(v);\n                if (gu == gv) continue;\n                tree[gu].Add(gv);\n                sumB[gu] += sumB[gv];\n                Union(u, v);\n                ss[gu] = new KeyValuePair<int, int>(i, gu);\n            }\n\n            ss.Sort((a, b) => a.Key - b.Key);\n\n            var ans = new int[N];\n            for (int i = 0; i < N; i++) { ans[i] = AmB[i] + B[i]; }\n\n            int mq = 0;\n            for (int i = 0; i < N; i++) {\n                var l = ss[i].Value;\n                mq = AmB[l] + sumB[l];\n                for (int j = 0; j < tree[l].Count; j++) {\n                    var k = tree[l][j];\n                    var q = (ans[k] > AmB[l]) ? ans[k] : AmB[l];\n                    q = q + sumB[l] - sumB[k];\n                    if (q < mq) { mq = q; }\n                }\n                ans[l] = mq;\n            }\n\n            Console.WriteLine(mq.ToString());\n            //Console.ReadLine();\n        }\n\n        static int[] group;\n        static int Find(int x) {\n            if (group[x] == x) return x;\n            group[x] = Find(group[x]);\n            return group[x];\n        }\n        static void Union(int x, int y) {\n            x = Find(x);\n            y = Find(y);\n            group[y] = x;\n        }\n        static void MakeSet(int x) {\n            group[x] = x;\n        }\n\n    }\n\n    class Con {\n        public int U;\n        public int V;\n        public int C;\n\n        public Con(int u, int v, int uc, int vc) {\n            if (uc > vc) {\n                U = u;\n                V = v;\n                C = uc;\n            } else {\n                U = v;\n                V = u;\n                C = vc;\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = re.i();\n        int M = re.i();\n        long[] A = new long[N];\n        long[] B = new long[N];\n        for(int i=0;i<N;i++){\n            A[i] = re.i();\n            B[i] = re.i();\n        }\n        Edge[] E = new Edge[M];\n        for(int i=0;i<M;i++){\n            int f = re.i()-1;\n            int t = re.i()-1;\n            E[i] = new Edge(f,t,Math.Max(A[f],A[t]));\n        }\n        Array.Sort(E,(x,y)=>(x.cost>y.cost ? 1 : (x.cost == y.cost ? 0 : -1)));\n        // UnionFind U = new UnioFind(N);\n        // bool[] used = new bool[M];\n        // for(int i=0;i<N;i++){\n        //     if(!U.Same(E[i].f,E[i].t)){\n        //         used[i] = true;\n        //         U.Union(E[i].f,E[i].t);\n        //     }\n        // }\n        UnionFind U = new UnionFind(N,B);\n        long[] Cost = new long[N];\n        for(int i=0;i<N;i++){\n            Cost[i] = B[i];\n        }\n        long count = 0;\n        for(int i=0;i<M;i++){\n            if(!U.Same(E[i].f,E[i].t)){\n                int f = U.Get(E[i].f);\n                int t = U.Get(E[i].t);\n                long cost1 = U.num[f]+Math.Max(Cost[t],A[E[i].t]);\n                long cost2 = U.num[t]+Math.Max(Cost[f],A[E[i].f]);\n                U.Union(E[i].f,E[i].t);\n                Cost[f] = Math.Min(cost1,cost2);\n            }\n        }\n        for(int i=0;i<N;i++){\n            count = Math.Max(Cost[i],count);\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nstruct Edge{\n    public int f;\n    public int t;\n    public long cost;\n    public Edge(int f0,int t0,long c){\n        f = f0;\n        t = t0;\n        cost = c;\n    }\n}\nclass UnionFind{\n    int[] par;\n    public long[] num;\n    public UnionFind(int n){\n        par = new int[n];\n        num = new long[n];\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            num[i] = 1;\n        }\n    }\n    public UnionFind(int n,long[] A){\n        par = new int[n];\n        num = new long[n];\n        for(int i=0;i<n;i++){\n            par[i] = i;\n            num[i] = A[i];\n        }\n    }\n    public long Num(int x){\n        return num[Get(x)];\n    }\n    public void Union(int x,int y){\n        int i = Get(x);\n        int j = Get(y);\n        if(i != j){\n            num[i] += num[j];\n            par[j] = i;  \n        } \n    }\n    public bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    public int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 1000000007;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace ARC98_F {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static List<Con> lcon = new List<Con>();\n\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            group = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n                MakeSet(i);\n            }\n\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                var U = int.Parse(var[0]) - 1;\n                var V = int.Parse(var[1]) - 1;\n                if (U > V) { int k = U; U = V; V = k; }\n                lcon.Add(new Con(U, V, AmB[U], AmB[V]));\n            }\n\n            lcon.Sort((a, b) => (a.C - b.C));\n\n            var tree = new List<int>[N];\n            for (int i = 0; i < N; i++) { tree[i] = new List<int>(); }\n            var sumB = new int[N];\n            for (int i = 0; i < N; i++) { sumB[i] = B[i]; }\n\n            var ss = new List<KeyValuePair<int, int>>();\n            for (int i = 0; i < N; i++) { ss.Add(new KeyValuePair<int, int>(-1, i)); }\n\n            for (int i = 0; i < M; i++) {\n                var u = lcon[i].U;\n                var v = lcon[i].V;\n                var gu = Find(u);\n                var gv = Find(v);\n                if (gu == gv) continue;\n                if (AmB[u] < AmB[v]) { var k = u; u = v; v = k; k = gu; gu = gv; gv = k; }\n                sumB[gu] += sumB[gv];\n                tree[gu].Add(gv);\n                Union(u, v);\n                ss[gu] = new KeyValuePair<int, int>(i, gu);\n            }\n\n            ss.Sort((a, b) => a.Key - b.Key);\n\n            var ans = new int[N];\n            for (int i = 0; i < N; i++) { ans[i] = AmB[i] + B[i]; }\n\n            int mq = 0;\n            for (int i = 0; i < N; i++) {\n                var l = ss[i].Value;\n                mq = AmB[l] + sumB[l];\n                for (int j = 0; j < tree[l].Count; j++) {\n                    var k = tree[l][j];\n                    var q = (ans[k] > AmB[l]) ? ans[k] : AmB[l];\n                    q = q + sumB[l] - sumB[k];\n                    if (q < mq) { mq = q; }\n                }\n                ans[l] = mq;\n            }\n\n            Console.WriteLine(mq.ToString());\n        }\n\n\n\n        static int[] group;\n        static int Find(int x) {\n            if (group[x] == x) return x;\n            return Find(group[x]);\n        }\n        static void Union(int x, int y) {\n            x = Find(x);\n            y = Find(y);\n            if (x != y) group[y] = x;\n        }\n        static void MakeSet(int x) {\n            group[x] = x;\n        }\n\n    }\n\n    class Con {\n        public int U;\n        public int V;\n        public int C;\n\n        public Con(int u, int v, int c1, int c2) {\n            U = u;\n            V = v;\n            if (c1 > c2) {\n                C = c1;\n            } else {\n                C = c2;\n            }\n        }\n    }\n\n}\n"
  },
  {
    "language": "Perl",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ARCF {\n    class Program {\n\n        static int[] A;\n        static int[] B;\n        static int[] AmB;\n        static int[] U;\n        static int[] V;\n        static Dictionary<int, List<int>> connection = new Dictionary<int, List<int>>();\n\n        static void Main(string[] args) {\n            String line;\n            line = Console.ReadLine();\n            String[] var = line.Split(new char[] { ' ' });\n            var N = int.Parse(var[0]);\n            var M = int.Parse(var[1]);\n\n            A = new int[N];\n            B = new int[N];\n            AmB = new int[N];\n            for (int i = 0; i < N; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                A[i] = int.Parse(var[0]);\n                B[i] = int.Parse(var[1]);\n                AmB[i] = A[i] - B[i];\n                if (AmB[i] < 0) { AmB[i] = 0; }\n            }\n            U = new int[M];\n            V = new int[M];\n            for (int i = 0; i < M; i++) {\n                line = Console.ReadLine();\n                var = line.Split(new char[] { ' ' });\n                U[i] = int.Parse(var[0]);\n                V[i] = int.Parse(var[1]);//U<V\n            }\n\n            for (int i = 0; i < N; i++) {\n                connection.Add(i, new List<int>());\n            }\n            for (int i = 0; i < M; i++) {\n                connection[U[i] - 1].Add(V[i] - 1);\n                connection[V[i] - 1].Add(U[i] - 1);\n            }\n\n\n            var p = new int[N];\n            int s = 0;\n            for (int i = 0; i < N; i++) { p[i] = i; s += B[p[i]]; }\n\n            Console.WriteLine(calc(p, s).ToString());\n            Console.ReadLine();\n        }\n\n\n        static int calc(int[] p, int s0) {\n            if (p.Length == 1) { return AmB[p[0]] + B[p[0]]; }\n\n            int mci = 0;\n            int mc = AmB[p[0]];\n            for (int i = 1; i < p.Length; i++) {\n                if (AmB[p[i]] > mc) { mc = AmB[p[i]]; mci = p[i]; }\n            }\n\n            var LL = split(p, mci);\n\n            int mq = int.MaxValue;\n            foreach (var l in LL) {\n                int s = 0;\n                for (int i = 0; i < l.Length; i++) { s += B[l[i]]; }\n\n                var q = calc(l, s);\n                if (q > AmB[mci]) {\n                    q = q + s0 - s;\n                } else {\n                    q = AmB[mci] + s0 - s;\n                }\n                if (q < mq) { mq = q; }\n            }\n\n            return mq;\n        }\n\n        static List<int[]> split(int[] p, int mci) {\n            var r = new List<int[]>();\n\n            var lp = new List<int>(p);\n            lp.Remove(mci);\n\n            while (lp.Count > 0) {\n                var g = new List<int>();\n                var s = new Queue<int>();\n                s.Enqueue(lp[0]);\n                do {\n                    var pp = s.Dequeue();\n                    if (lp.Remove(pp)) {\n                        g.Add(pp);\n                        foreach (int i in connection[pp]) { s.Enqueue(i); }\n                    }\n                } while (s.Count > 0);\n\n                r.Add(g.ToArray());\n            }\n            return r;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"F\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.typecons;\n// import dkh.foundation, dkh.scanner, dkh.container.pairingheap;\n\nalias P = Tuple!(long, \"d\", int, \"p\");\nalias Q = PairingHeap!(P, \"a.d>b.d\");\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n\n    int n, m;\n    sc.read(n, m);\n    int[][] g = new int[][n];\n    long[] lw = new long[n], us = new long[n];\n    foreach (i; 0..n) {\n        sc.read(lw[i], us[i]); lw[i] -= us[i];\n    }\n    long off = us.sum;\n    foreach (i; 0..m) {\n        int a, b;\n        sc.read(a, b); a--; b--;\n        g[a] ~= b; g[b] ~= a;\n    }\n    Q[] gx = new Q[n];\n    foreach (i; 0..n) {\n        foreach (d; g[i]) {\n            gx[i].insert(P(lw[d], d));\n        }\n    }\n\n    int[] ig = new int[n];\n    int[][] gi = new int[][n];\n    foreach (i; 0..n) {\n        ig[i] = i; gi[i] = [i];\n    }\n    auto uf_same = (int a, int b) => ig[a] == ig[b];\n    void uf_merge(int a, int b) {\n        if (uf_same(a, b)) return;\n        int x = ig[a], y = ig[b];\n        if (gi[x].length < gi[y].length) swap(x, y);\n        foreach (d; gi[y]) ig[d] = x;\n        gi[x] ~= gi[y]; gi[y] = [];\n\n        us[x] += us[y];\n        us[y] = 0;\n\n        gx[x].meld(gx[y]);\n    }\n\n    long ans = 0;\n    Q que;\n    foreach (i; 0..n) {\n        que.insert(P(lw[i], i));\n    }\n    bool[] vis = new bool[n];\n    void on(int p) {\n        vis[p] = true;\n        foreach (d; g[p]) {\n            if (vis[d]) uf_merge(p, d);\n        }\n        int x = ig[p];\n        while (gx[x].length) {\n            auto tp = gx[x].front();\n            if (vis[tp.p]) {\n                gx[x].removeFront();\n                continue;\n            }\n            if (tp.d <= ans+us[x]) {\n                on(tp.p);\n            } else {\n                que.insert(P(tp.d - us[x], tp.p));\n            }\n            break;\n        }\n    }\n\n    while (que.length) {\n        P tp = que.front; que.removeFront();\n        int p = tp.p;\n        if (vis[p]) continue;\n        ans = max(ans, tp.d);\n        on(p);\n    }\n    writeln(ans+off);\n    return 0;\n}\n/* IMPORT /mnt/c/Users/yosupo/Programs/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /mnt/c/Users/yosupo/Programs/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /mnt/c/Users/yosupo/Programs/dunkelheit/source/dkh/container/pairingheap.d */\n// module dkh.container.pairingheap;\n\nprivate NP meldPairingHeapNode(alias less, NP)(NP x, NP y) {\n    import std.algorithm : swap;\n    if (!x) return y;\n    if (!y) return x;\n    if (less(x._item, y._item)) swap(x, y);\n    y.next = x.head;\n    x.head = y;\n    return x;\n}\n\n \nstruct PairingHeap(T, alias less = \"a < b\") {\n    import std.functional : binaryFun;\n    private alias _less = binaryFun!less;\n\n    private alias NP = Node*;\n    private static struct Node {\n        T _item;\n        NP head, next;\n        this(T item) {\n            _item = item;\n        }\n    }\n\n    private struct Payload {\n        import std.algorithm : swap;\n        private NP node;\n        private uint len;\n\n        void insert(T item) {\n            len++;\n            node = meldPairingHeapNode!_less(node, new Node(item));\n        }\n        inout(T) front() inout { return node._item; }\n        void removeFront() {\n            len--;\n\n            NP s = node.head;\n            NP t;\n             \n             \n            while (s) {\n                 \n                NP first, second;\n                first = s; s = s.next; first.next = null;\n                if (s) {\n                    second = s; s = s.next; second.next = null;\n                }\n                 \n                auto v = meldPairingHeapNode!_less(first, second);\n                v.next = t;\n                t = v;\n            }\n            node = null;\n             \n            while (t) {\n                NP first = t; t = t.next; first.next = null;\n                node = meldPairingHeapNode!_less(first, node);\n            }\n        }\n        void meld(Payload* r) {\n            len += r.len; r.len = 0;\n            node = meldPairingHeapNode!_less(node, r.node);\n            r.node = null;\n        }\n    }\n    private Payload* _p;\n\n    @property bool empty() const { return !_p || _p.len == 0; }  \n    @property size_t length() const { return (!_p) ? 0 : _p.len; }  \n\n    void insert(T item) {\n        if (!_p) _p = new Payload();\n        _p.insert(item);\n    }  \n    inout(T) front() inout {\n        assert(!empty, \"PairingHeap.front: heap is empty\");\n        return _p.front;\n    }  \n    void removeFront() {\n        assert(!empty, \"PairingHeap.removeFront: heap is empty\");\n        _p.removeFront;\n    }  \n     \n    void meld(PairingHeap r) { _p.meld(r._p); }\n}\n\n \n \n\n \n\n \n/* IMPORT /mnt/c/Users/yosupo/Programs/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Python",
    "code": "import sys,collections as cl\nMax = sys.maxsize\ndef l():\n\treturn list(map(int,input().split()))\ndef m():\n\treturn map(int,input().split())\ndef s(x):\n\ta = []\n\taa = x[i]\n\tsu = 1\n\tfor i in range(len(x)-1):\n\t\tif aa == x[i+1]:\n\t\t\ta.append([aa,su])\n\t\t\taa = x[i+1]\n\t\t\tsu = 1\n\t\telse:\n\t\t\tsu += 1\n\ta.append([aa,su])\n\treturn a\n\nn = int(input())\n\na = l()\n\nans = 0\nl = 0\nr = 0\nsu = 0\nfor i in range(N):\n\twhile(r < N and (su^a[r]) == (su + a[r])):\n\t\tsu += a[r]\n\t\tr += 1\n\tans += r -i\n\tif r == i:\n\t\tr += 1\n\telse:\n\t\tsu -= a[l]\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\n# MOD = 998244353\n\n\nclass UnionFind:\n    def __init__(self, size=None, nodes=None):\n        \"\"\"\n        size か nodes どっちか指定。\n        nodes は set、size は list を使う。\n        :param int size:\n        :param collections.Iterable nodes:\n        \"\"\"\n        assert size is not None or nodes is not None\n        if size is not None:\n            self._parents = [i for i in range(size)]\n            self._ranks = [0 for _ in range(size)]\n            self._sizes = [1 for _ in range(size)]\n        else:\n            self._parents = {k: k for k in nodes}\n            self._ranks = {k: 0 for k in nodes}\n            self._sizes = {k: 1 for k in nodes}\n\n    def unite(self, x, y):\n        \"\"\"\n        x が属する木と y が属する木を併合\n        :param x:\n        :param y:\n        \"\"\"\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n\n        # rank が小さい方が下\n        if self._ranks[x] > self._ranks[y]:\n            # x が root\n            self._parents[y] = x\n            self._sizes[x] += self._sizes[y]\n        else:\n            # y が root\n            self._parents[x] = y\n            self._sizes[y] += self._sizes[x]\n            if self._ranks[x] == self._ranks[y]:\n                self._ranks[y] += 1\n\n    def root(self, x):\n        \"\"\"\n        x が属する木の root\n        :param x:\n        \"\"\"\n        if self._parents[x] == x:\n            return x\n        self._parents[x] = self.root(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x):\n        \"\"\"\n        x が属する木のノード数\n        :param x:\n        \"\"\"\n        return self._sizes[self.root(x)]\n\n\ndef argsort(li, key=None, reverse=False):\n    return [i for _, i in sorted(\n        [(a, i) for i, a in enumerate(li)], key=(lambda t: key(t[0])) if key else None, reverse=reverse\n    )]\n\n\nN, M = list(map(int, sys.stdin.buffer.readline().split()))\nA, B = list(zip(*[map(int, sys.stdin.buffer.readline().split()) for _ in range(N)]))\nVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]\n\n# from libs.debug import plot_graph\n#\n# plot_graph(VU)\n\ngraph = [[] for _ in range(N)]\nfor v, u in VU:\n    v -= 1\n    u -= 1\n    graph[v].append(u)\n    graph[u].append(v)\n\nreqs = [max(a, b) for a, b in zip(A, B)]\nuses = list(B)\n\nidx = argsort(A)\nuf = UnionFind(size=N)\nseen = [False] * N\nans = [INF] * N\nfor v in idx:\n    seen[v] = True\n    roots = set()\n    for u in graph[v]:\n        if not seen[u]:\n            continue\n        roots.add(uf.root(u))\n\n    use_all = uses[v]\n    for r in roots:\n        use_all += uses[r]\n\n    # v が最後\n    req_v = reqs[v] + use_all - uses[v]\n    for r in roots:\n        req_v = min(req_v, max(reqs[r], reqs[v] - uses[v]) + use_all - uses[r])\n\n    for r in roots:\n        uf.unite(v, r)\n    reqs[uf.root(v)] = req_v\n    uses[uf.root(v)] = use_all\nans = reqs[uf.root(0)]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "class dsu:\n    def __init__(self, n=0):\n        self._n = n\n        self.parent_or_size = [-1] * n\n    \n    def merge(self, a: int, b: int) -> int:\n        x = self.leader(a)\n        y = self.leader(b)\n        if x == y:\n            return x\n        if self.parent_or_size[x] > self.parent_or_size[y]:\n            x, y = y, x\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n        return x\n    \n    def same(self, a: int, b: int) -> bool:\n        return self.leader(a) == self.leader(b)\n    \n    def leader(self, a: int) -> int:\n        x = a\n        while self.parent_or_size[x] >= 0:\n            x = self.parent_or_size[x]\n        while a != x:\n            self.parent_or_size[a], a = x, self.parent_or_size[a]\n        return x\n    \n    def size(self, a: int) -> int:\n        return -self.parent_or_size[self.leader(a)]\n    \n    def groups(self):\n        g = [[] for _ in range(self._n)]\n        for i in range(self._n):\n            g[self.leader(i)].append(i)\n        return list(c for c in g if c)\n\nn, m = map(int, input().split())\nvdata = [] # (required, gain)\nfor _ in range(n):\n    a, b = map(int, input().split())\n    vdata.append((max(a - b, 0), b))\nto = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    u -= 1; v -= 1\n    to[u].append(v)\n    to[v].append(u)\ns = dsu(n)\ndp = vdata.copy() # (extra, tot_gain)\nvisited = [False] * n\nfor u in sorted(range(n), key=lambda i: vdata[i][0]):\n    req, gain = vdata[u]\n    frm = {u}\n    for v in to[u]:\n        if visited[v]:\n            frm.add(s.leader(v))\n    mnextra = 10 ** 18\n    for v in frm:\n        e, g = dp[v]\n        e += max(req - (e + g), 0)\n        if e < mnextra:\n            mnextra, mni = e, v\n    extra, tot_gain = mnextra, sum(dp[v][1] for v in frm)\n    for v in frm:\n        s.merge(u, v)\n    dp[s.leader(u)] = extra, tot_gain\n    visited[u] = True\nans = sum(dp[s.leader(0)])\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\n# MOD = 998244353\n\n\nclass UnionFind:\n    def __init__(self, size=None, nodes=None):\n        \"\"\"\n        size か nodes どっちか指定。\n        nodes は set、size は list を使う。\n        :param int size:\n        :param collections.Iterable nodes:\n        \"\"\"\n        assert size is not None or nodes is not None\n        if size is not None:\n            self._parents = [i for i in range(size)]\n            self._ranks = [0 for _ in range(size)]\n            self._sizes = [1 for _ in range(size)]\n        else:\n            self._parents = {k: k for k in nodes}\n            self._ranks = {k: 0 for k in nodes}\n            self._sizes = {k: 1 for k in nodes}\n\n    def unite(self, x, y):\n        \"\"\"\n        x が属する木と y が属する木を併合\n        :param x:\n        :param y:\n        \"\"\"\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n\n        # rank が小さい方が下\n        if self._ranks[x] > self._ranks[y]:\n            # x が root\n            self._parents[y] = x\n            self._sizes[x] += self._sizes[y]\n        else:\n            # y が root\n            self._parents[x] = y\n            self._sizes[y] += self._sizes[x]\n            if self._ranks[x] == self._ranks[y]:\n                self._ranks[y] += 1\n\n    def root(self, x):\n        \"\"\"\n        x が属する木の root\n        :param x:\n        \"\"\"\n        if self._parents[x] == x:\n            return x\n        self._parents[x] = self.root(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x):\n        \"\"\"\n        x が属する木のノード数\n        :param x:\n        \"\"\"\n        return self._sizes[self.root(x)]\n\n\ndef argsort(li, key=None, reverse=False):\n    return [i for _, i in sorted(\n        [(a, i) for i, a in enumerate(li)], key=(lambda t: key(t[0])) if key else None, reverse=reverse\n    )]\n\n\nN, M = list(map(int, sys.stdin.buffer.readline().split()))\nA, B = list(zip(*[map(int, sys.stdin.buffer.readline().split()) for _ in range(N)]))\nVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]\n\n# from libs.debug import plot_graph\n#\n# plot_graph(VU)\n\ngraph = [[] for _ in range(N)]\nfor v, u in VU:\n    v -= 1\n    u -= 1\n    graph[v].append(u)\n    graph[u].append(v)\n\n# 解説\n# C[v] = A[v] - B[v]\n# C の小さい順にグラフを構築して、部分グラフごとに答えを持つ\nreqs = [max(0, a - b) for a, b in zip(A, B)]\nuses = list(B)\n\nidx = argsort(reqs)\nuf = UnionFind(size=N)\nseen = [False] * N\nans = [INF] * N\nfor v in idx:\n    # v: 今までに見た中で C が最大の頂点\n    seen[v] = True\n    roots = set()\n    for u in graph[v]:\n        if not seen[u]:\n            continue\n        roots.add(uf.root(u))\n\n    use_all = uses[v]\n    for r in roots:\n        use_all += uses[r]\n    # v を最初にする場合\n    req_v = reqs[v] + use_all\n    for r in roots:\n        # r のどれかを root とする部分グラフを最初にする場合\n        # C[v] が今まで見たうち最大なので v に来たあとは好きな頂点まで行ける\n        req_v = min(req_v, max(reqs[r], reqs[v]) + use_all - uses[r])\n\n    for r in roots:\n        uf.unite(v, r)\n    reqs[uf.root(v)] = req_v\n    uses[uf.root(v)] = use_all\nans = reqs[uf.root(0)]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\n# MOD = 998244353\n\n\nclass UnionFind:\n    def __init__(self, size=None, nodes=None):\n        \"\"\"\n        size か nodes どっちか指定。\n        nodes は set、size は list を使う。\n        :param int size:\n        :param collections.Iterable nodes:\n        \"\"\"\n        assert size is not None or nodes is not None\n        if size is not None:\n            self._parents = [i for i in range(size)]\n            self._ranks = [0 for _ in range(size)]\n            self._sizes = [1 for _ in range(size)]\n        else:\n            self._parents = {k: k for k in nodes}\n            self._ranks = {k: 0 for k in nodes}\n            self._sizes = {k: 1 for k in nodes}\n\n    def unite(self, x, y):\n        \"\"\"\n        x が属する木と y が属する木を併合\n        :param x:\n        :param y:\n        \"\"\"\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n\n        # rank が小さい方が下\n        if self._ranks[x] > self._ranks[y]:\n            # x が root\n            self._parents[y] = x\n            self._sizes[x] += self._sizes[y]\n        else:\n            # y が root\n            self._parents[x] = y\n            self._sizes[y] += self._sizes[x]\n            if self._ranks[x] == self._ranks[y]:\n                self._ranks[y] += 1\n\n    def root(self, x):\n        \"\"\"\n        x が属する木の root\n        :param x:\n        \"\"\"\n        if self._parents[x] == x:\n            return x\n        self._parents[x] = self.root(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x):\n        \"\"\"\n        x が属する木のノード数\n        :param x:\n        \"\"\"\n        return self._sizes[self.root(x)]\n\n\ndef argsort(li, key=None, reverse=False):\n    return [i for _, i in sorted(\n        [(a, i) for i, a in enumerate(li)], key=(lambda t: key(t[0])) if key else None, reverse=reverse\n    )]\n\n\nN, M = list(map(int, sys.stdin.buffer.readline().split()))\nA, B = list(zip(*[map(int, sys.stdin.buffer.readline().split()) for _ in range(N)]))\nVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]\n\n# from libs.debug import plot_graph\n#\n# plot_graph(VU)\n\ngraph = [[] for _ in range(N)]\nfor v, u in VU:\n    v -= 1\n    u -= 1\n    graph[v].append(u)\n    graph[u].append(v)\n\nreqs = [max(a, b) for a, b in zip(A, B)]\nuses = list(B)\n\nidx = argsort([a - b for a, b in zip(A, B)])\nuf = UnionFind(size=N)\nseen = [False] * N\nans = [INF] * N\nfor v in idx:\n    seen[v] = True\n    roots = set()\n    for u in graph[v]:\n        if not seen[u]:\n            continue\n        roots.add(uf.root(u))\n\n    use_all = uses[v]\n    for r in roots:\n        use_all += uses[r]\n\n    # v が最後\n    req_v = reqs[v] + use_all - uses[v]\n    for r in roots:\n        req_v = min(req_v, max(reqs[r], reqs[v] - uses[v]) + use_all - uses[r])\n\n    for r in roots:\n        uf.unite(v, r)\n    reqs[uf.root(v)] = req_v\n    uses[uf.root(v)] = use_all\nans = reqs[uf.root(0)]\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "N, K, Q = [int(i) for i in input().split(\" \")]\nA = [int(a) for a in input().split(\" \")]\n\n_min = min(A)\nA.sort()\nfor k in range(K):\n    _max = A.pop(0)\nprint(_max - _min)"
  },
  {
    "language": "Python",
    "code": "import sys,random,time,bisect\ninput=sys.stdin.buffer.readline\n\nstart=time.time()\nN=int(input())\nvw=[(-1,-1)]\nfor i in range(N):\n    vw.append(tuple(map(int,input().split())))\n\ndp=[[] for i in range(2**9)]\ndef make_dp(v):\n    t=[[0,0] for i in range(15)]\n    V=v\n    id=0\n    while v>=1:\n        t[id]=vw[v]\n        id+=1\n        v//=2\n    n=id\n    temp=[[0,0] for i in range(2**n)]\n    for i in range(n):\n        for j in range(2**i,2**(i+1)):\n            temp[j][0]=temp[j-2**i][0]+t[i][0]\n            temp[j][1]=temp[j-2**i][1]+t[i][1]\n    temp.sort(key=lambda x:x[1])\n    for i in range(1,2**n):\n        temp[i][0]=max(temp[i][0],temp[i-1][0])\n\n    dp[V]=[0]*(10**5+1)\n    for i in range(2**n-1):\n        L=temp[i][1]\n        R=temp[i+1][1]\n        if L>10**5:\n            break\n        elif R>10**5:\n            R=10**5+1\n        for j in range(L,R):\n            dp[V][j]=temp[i][0]\n    else:\n        L=temp[-1][1]\n        if L<=10**5:\n            for j in range(L,10**5+1):\n                dp[V][j]=temp[-1][0]\n\nMAX=min(2**9,N+1)\nfor i in range(1,MAX):\n    make_dp(i)\n\nQ=int(input())\nquery=[[] for i in range(N+1)]\nfor i in range(Q):\n    v,L=map(int,input().split())\n    query[v].append((L,i))\n\nans=[0]*Q\ntemp=[[0,0] for i in range(2**9)]\nsolved=[False]*(N+1)\n\ndef solve(v):\n    subq=[]\n    t=[]\n    check=[]\n    id=0\n    while v>=2**9:\n        t.append(vw[v])\n        subq.append(v)\n        check.append(id)\n        id+=1\n        v//=2\n    if not subq:\n        subq=[v]\n        check=[0]\n\n    t=t[::-1]\n    n=len(t)\n    for i in range(n):\n        for j in range(2**i,2**(i+1)):\n            temp[j][0]=temp[j-2**i][0]+t[i][0]\n            temp[j][1]=temp[j-2**i][1]+t[i][1]\n\n    for i in range(len(check)):\n        V=subq[i]\n        if not solved[V]:\n            solved[V]=True\n            for L,ID in query[V]:\n                res=0\n                m=n-check[i]\n                for i in range(2**m):\n                    if L>=temp[i][1]:\n                        res=max(res,temp[i][0]+dp[v][L-temp[i][1]])\n                ans[ID]=res\n\nfor i in range(1,N+1):\n    if query[i] and not solved[i]:\n        solve(i)\n\nfor i in range(Q):\n    print(ans[i])\n"
  },
  {
    "language": "Python",
    "code": "import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\n# MOD = 998244353\n\n\nclass UnionFind:\n    def __init__(self, size=None, nodes=None):\n        \"\"\"\n        size か nodes どっちか指定。\n        nodes は set、size は list を使う。\n        :param int size:\n        :param collections.Iterable nodes:\n        \"\"\"\n        assert size is not None or nodes is not None\n        if size is not None:\n            self._parents = [i for i in range(size)]\n            self._ranks = [0 for _ in range(size)]\n            self._sizes = [1 for _ in range(size)]\n        else:\n            self._parents = {k: k for k in nodes}\n            self._ranks = {k: 0 for k in nodes}\n            self._sizes = {k: 1 for k in nodes}\n\n    def unite(self, x, y):\n        \"\"\"\n        x が属する木と y が属する木を併合\n        :param x:\n        :param y:\n        \"\"\"\n        x = self.root(x)\n        y = self.root(y)\n        if x == y:\n            return\n\n        # rank が小さい方が下\n        if self._ranks[x] > self._ranks[y]:\n            # x が root\n            self._parents[y] = x\n            self._sizes[x] += self._sizes[y]\n        else:\n            # y が root\n            self._parents[x] = y\n            self._sizes[y] += self._sizes[x]\n            if self._ranks[x] == self._ranks[y]:\n                self._ranks[y] += 1\n\n    def root(self, x):\n        \"\"\"\n        x が属する木の root\n        :param x:\n        \"\"\"\n        if self._parents[x] == x:\n            return x\n        self._parents[x] = self.root(self._parents[x])\n        return self._parents[x]\n\n    def size(self, x):\n        \"\"\"\n        x が属する木のノード数\n        :param x:\n        \"\"\"\n        return self._sizes[self.root(x)]\n\n\ndef argsort(li, key=None, reverse=False):\n    return [i for _, i in sorted(\n        [(a, i) for i, a in enumerate(li)], key=(lambda t: key(t[0])) if key else None, reverse=reverse\n    )]\n\n\nN, M = list(map(int, sys.stdin.buffer.readline().split()))\nA, B = list(zip(*[map(int, sys.stdin.buffer.readline().split()) for _ in range(N)]))\nVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(M)]\n\n# from libs.debug import plot_graph\n#\n# plot_graph(VU)\n\ngraph = [[] for _ in range(M)]\nfor v, u in VU:\n    v -= 1\n    u -= 1\n    graph[v].append(u)\n    graph[u].append(v)\n\n# 解説\n# C[v] = A[v] - B[v]\n# C の小さい順にグラフを構築して、部分グラフごとに答えを持つ\nreqs = [max(0, a - b) for a, b in zip(A, B)]\nuses = list(B)\n\nidx = argsort(reqs)\nuf = UnionFind(size=N)\nseen = [False] * N\nans = [INF] * N\nfor v in idx:\n    # v: 今までに見た中で C が最大の頂点\n    seen[v] = True\n    roots = set()\n    for u in graph[v]:\n        if not seen[u]:\n            continue\n        roots.add(uf.root(u))\n\n    use_all = uses[v]\n    for r in roots:\n        use_all += uses[r]\n    # v を最初にする場合\n    req_v = reqs[v] + use_all\n    for r in roots:\n        # r のどれかを root とする部分グラフを最初にする場合\n        # C[v] が今まで見たうち最大なので v に来たあとは好きな頂点まで行ける\n        req_v = min(req_v, max(reqs[r], reqs[v]) + use_all - uses[r])\n\n    for r in roots:\n        uf.unite(v, r)\n    reqs[uf.root(v)] = req_v\n    uses[uf.root(v)] = use_all\nans = reqs[uf.root(0)]\nprint(ans)\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::BufRead;\n\nfn main() {\n    let mut sc = new(std::io::stdin());\n\n    let n:usize = sc.next();\n    let m:usize = sc.next();\n    let mut node:Vec<(i64, i64)> = vec![];\n    for _ in 0..n {\n        node.push((sc.next(), sc.next())); // a, b\n    }\n    if n == 1 {\n        let res = if node[0].0 > node[0].1 {\n            node[0].0\n        } else {\n            node[0].1\n        };\n        println!(\"{}\", res);\n        return;\n    }\n    let mut edges:Vec<Vec<(i64, usize, usize)>> = vec![vec![]; n];\n    for _ in 0..m {\n        let mut from:usize = sc.next();\n        let mut to: usize = sc.next();\n        from = from.wrapping_sub(1);\n        to = to.wrapping_sub(1);\n        let w = node[to].0 - node[to].1;\n        edges[from].push((-w, from, to));\n        let w = node[from].0 - node[from].1;\n        edges[to].push((-w, to, from));\n    }\n\n    let mut left = -1i64;\n    let mut right = 1_000_000_010i64;\n    let mut queue = std::collections::BinaryHeap::new();\n    while right - left > 1 {\n        let have = (left + right) / 2;\n\n        queue.clear();\n\n        let mut uf = UnionFind::new(n);\n        let mut rootw = vec![-1i64; n];\n        for i in 0..n {\n            if node[i].0 - node[i].1 <= have {\n                for e in &edges[i] {\n                    queue.push(e.clone());\n                }\n                rootw[i] = have + node[i].1;\n            }\n        }\n        // println!(\"mid: {}\", have);\n        // println!(\"q: {:?}\", queue);\n        let mut used_edges = 0;\n        loop {\n            if let Some((w, from, to)) = queue.pop() {\n                let w = -w;\n                // println!(\"{:?}\", (w, from, to));\n                let cur = rootw[uf.root(from)];\n                assert!(cur >= 0);\n                if w <= cur && uf.root(from) != uf.root(to) {\n                    used_edges += 1;\n                    let add = if rootw[uf.root(to)] == -1 {\n                        for e in &edges[to] {\n                            queue.push(e.clone());\n                        }\n                        node[to].1\n                    } else {\n                        rootw[uf.root(to)] - have\n                    };\n                    assert!(add >= 0);\n                    let nxt = cur + add;\n                    uf.union(from, to);\n                    rootw[uf.root(to)] = nxt;\n                }\n            } else {\n                break;\n            }\n        }\n        // println!(\"used: {}\", used_edges);\n\n        if used_edges >= n - 1 {\n            assert_eq!(used_edges, n-1);\n            right = have;\n        } else {\n            left = have;\n        }\n    }\n\n    assert!(right <= 1_000_000_000);\n    let mut res = right;\n    for (_, b) in node {\n        res += b;\n    }\n    println!(\"{}\", res);\n}\n\n\npub struct Scanner<R: io::Read> {\n    br: io::BufReader<R>,\n    // Read tokens are stored in reversed order per line.\n    buf: Vec<String>,\n}\n\npub fn new<R: io::Read>(r: R) -> Scanner<R> {\n    Scanner::new(r)\n}\n\nimpl<R: io::Read> Scanner<R> {\n    #[inline]\n    fn new(r: R) -> Scanner<R> {\n        Scanner {\n            br: io::BufReader::new(r),\n            buf: vec![],\n        }\n    }\n    #[inline]\n    pub fn next<T>(&mut self) -> T\n        where T: std::str::FromStr,\n              T::Err: std::fmt::Debug\n    {\n        self.next_string().map(|s| s.parse::<T>().expect(\"Parse failed: \")).unwrap()\n    }\n    fn next_string(&mut self) -> Option<String> {\n        self.buf.pop().or_else(|| match self.update() {\n            true => self.next_string(),\n            false => None,\n        })\n    }\n    #[inline]\n    fn update(&mut self) -> bool {\n        let mut s = String::new();\n        let res = self.br.read_line(&mut s);\n        match res.expect(\"I/O error.\") {\n            0 => false,\n            _ => {\n                self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                true\n            }\n        }\n    }\n}\n\npub struct UnionFind {\n    tree: Vec<isize>,\n}\n\nimpl UnionFind {\n    /// Creates n disjoint singleton sets.\n    #[inline]\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind { tree: vec![-1; n] }\n    }\n    /// Returns the root of the tree containing i.\n    pub fn root(&mut self, i: usize) -> usize {\n        if self.tree[i] < 0 {\n            return i;\n        }\n        let j = self.tree[i];\n        let root = self.root(j as usize);\n        // Path decomposition.\n        self.tree[i] = root as isize;\n        root\n    }\n    /// Returns the size of the tree containing i.\n    #[inline]\n    pub fn size(&mut self, i: usize) -> usize {\n        let root = self.root(i);\n        -self.tree[root] as usize\n    }\n    /// Unions i and j.\n    pub fn union(&mut self, i: usize, j: usize) {\n        let mut i = self.root(i);\n        let mut j = self.root(j);\n        if i == j {\n            return;\n        }\n        if -self.tree[i] > -self.tree[j] {\n            let tmp = i;\n            i = j;\n            j = tmp;\n        }\n        // Append i to j since size(i) <= size(j).\n        self.tree[j] += self.tree[i];\n        self.tree[i] = j as isize;\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::HashSet;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, [graph1; $len:expr]) => {{\n        let mut g = vec![vec![]; $len];\n        let ab = read_value!($next, [(usize1, usize1)]);\n        for (a, b) in ab {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        g\n    }};\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n    ($next:expr, usize1) => (read_value!($next, usize) - 1);\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        read_value!($next, [$t; len])\n    }};\n    ($next:expr, $t:ty) => ($next().parse::<$t>().expect(\"Parse error\"));\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => ();//(writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/**\n * Union-Find tree.\n * Verified by https://atcoder.jp/contests/pakencamp-2019-day3/submissions/9253305\n */\nstruct UnionFind { disj: Vec<usize>, rank: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let disj = (0..n).collect();\n        UnionFind { disj: disj, rank: vec![1; n] }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        self.disj[x]\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y { return }\n        if self.rank[x] > self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.disj[x] = y;\n        self.rank[y] += self.rank[x];\n    }\n    #[allow(unused)]\n    fn is_same_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n    #[allow(unused)]\n    fn size(&mut self, x: usize) -> usize {\n        let x = self.root(x);\n        self.rank[x]\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        m: usize,\n        ab: [(i64, i64); n],\n        uv: [(usize1, usize1); m],\n    }\n    let mut ab = ab;\n    let mut aib = vec![];\n    for i in 0..n {\n        let (a, b) = ab[i];\n        let a = max(0, a - b);\n        ab[i].0 = a;\n        aib.push((a, i, b));\n    }\n    aib.sort();\n    let mut g = vec![vec![]; n];\n    for &(u, v) in &uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let mut uf = UnionFind::new(n);\n    let mut dat = vec![(0, 0); n];\n    for &(a, v, b) in &aib {\n        let mut dsum = 0;\n        let mut difmin = a;\n        let mut seen = HashSet::new();\n        for &w in &g[v] {\n            if (ab[w].0, w) >= (a, v) {\n                continue;\n            }\n            let r = uf.root(w);\n            if seen.contains(&r) {\n                continue;\n            }\n            seen.insert(r);\n            let (c, d) = dat[r];\n            difmin = min(difmin, max(c, a - d));\n            dsum += d;\n        }\n        dsum += b;\n        for r in seen {\n            uf.unite(v, r);\n        }\n        let r = uf.root(v);\n        dat[r] = (difmin, dsum);\n        debugln!(\"{} -> {:?}\", r, dat[r]);\n    }\n    debugln!(\"{:?}\", dat);\n    let r = uf.root(0);\n    let (c, d) = dat[r];\n    puts!(\"{}\\n\", c + d);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::BufRead;\n\nfn main() {\n    let mut sc = new(std::io::stdin());\n\n    let n:usize = sc.next();\n    let m:usize = sc.next();\n    let mut node:Vec<(i64, i64)> = vec![];\n    for _ in 0..n {\n        node.push((sc.next(), sc.next())); // a, b\n    }\n    if n == 1 {\n        let res = if node[0].0 > node[0].1 {\n            node[0].0\n        } else {\n            node[0].1\n        };\n        println!(\"{}\", res);\n        return;\n    }\n    let mut edges:Vec<Vec<(i64, usize, usize)>> = vec![vec![]; n];\n    for _ in 0..m {\n        let mut from:usize = sc.next();\n        let mut to: usize = sc.next();\n        from = from.wrapping_sub(1);\n        to = to.wrapping_sub(1);\n        let w = node[to].0 - node[to].1;\n        edges[from].push((-w, from, to));\n        let w = node[from].0 - node[from].1;\n        edges[to].push((-w, to, from));\n    }\n    for i in 0..n {\n        edges[i].sort()\n    }\n\n    let mut left = -1;\n    let mut right = 1_000_000_000;\n    let mut queue = std::collections::BinaryHeap::new();\n    while right - left > 1 {\n        let have = (left + right) / 2;\n\n        queue.clear();\n\n        let mut uf = UnionFind::new(n);\n        let mut rootw = vec![-1; n];\n        for i in 0..n {\n            if node[i].0 - node[i].1 <= have {\n                for e in &edges[i] {\n                    queue.push(e.clone());\n                }\n                rootw[i] = have + node[i].1;\n            }\n        }\n        // println!(\"mid: {}\", have);\n        // println!(\"q: {:?}\", queue);\n        let mut used_edges = 0;\n        loop {\n            if let Some((w, from, to)) = queue.pop() {\n                let w = -w;\n                // println!(\"{:?}\", (w, from, to));\n                let cur = rootw[uf.root(from)];\n                assert!(cur >= 0);\n                if w <= cur && uf.root(from) != uf.root(to) {\n                    used_edges += 1;\n                    let add = if rootw[uf.root(to)] == -1 {\n                        for e in &edges[to] {\n                            queue.push(e.clone());\n                        }\n                        node[to].1\n                    } else {\n                        rootw[uf.root(to)] - have\n                    };\n                    assert!(add >= 0);\n                    let nxt = cur + add;\n                    uf.union(from, to);\n                    rootw[uf.root(to)] = nxt;\n                }\n            } else {\n                break;\n            }\n        }\n        // println!(\"used: {}\", used_edges);\n\n        if used_edges >= n - 1 {\n            assert_eq!(used_edges, n-1);\n            right = have;\n        } else {\n            left = have;\n        }\n    }\n\n    let mut res = right;\n    for (_, b) in node {\n        res += b;\n    }\n    println!(\"{}\", res);\n}\n\n\npub struct Scanner<R: io::Read> {\n    br: io::BufReader<R>,\n    // Read tokens are stored in reversed order per line.\n    buf: Vec<String>,\n}\n\npub fn new<R: io::Read>(r: R) -> Scanner<R> {\n    Scanner::new(r)\n}\n\nimpl<R: io::Read> Scanner<R> {\n    #[inline]\n    fn new(r: R) -> Scanner<R> {\n        Scanner {\n            br: io::BufReader::new(r),\n            buf: vec![],\n        }\n    }\n    #[inline]\n    pub fn next<T>(&mut self) -> T\n        where T: std::str::FromStr,\n              T::Err: std::fmt::Debug\n    {\n        self.next_string().map(|s| s.parse::<T>().expect(\"Parse failed: \")).unwrap()\n    }\n    fn next_string(&mut self) -> Option<String> {\n        self.buf.pop().or_else(|| match self.update() {\n            true => self.next_string(),\n            false => None,\n        })\n    }\n    #[inline]\n    fn update(&mut self) -> bool {\n        let mut s = String::new();\n        let res = self.br.read_line(&mut s);\n        match res.expect(\"I/O error.\") {\n            0 => false,\n            _ => {\n                self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                true\n            }\n        }\n    }\n}\n\npub struct UnionFind {\n    tree: Vec<isize>,\n}\n\nimpl UnionFind {\n    /// Creates n disjoint singleton sets.\n    #[inline]\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind { tree: vec![-1; n] }\n    }\n    /// Returns the root of the tree containing i.\n    pub fn root(&mut self, i: usize) -> usize {\n        if self.tree[i] < 0 {\n            return i;\n        }\n        let j = self.tree[i];\n        let root = self.root(j as usize);\n        // Path decomposition.\n        self.tree[i] = root as isize;\n        root\n    }\n    /// Returns the size of the tree containing i.\n    #[inline]\n    pub fn size(&mut self, i: usize) -> usize {\n        let root = self.root(i);\n        -self.tree[root] as usize\n    }\n    /// Unions i and j.\n    pub fn union(&mut self, i: usize, j: usize) {\n        let mut i = self.root(i);\n        let mut j = self.root(j);\n        if i == j {\n            return;\n        }\n        if -self.tree[i] > -self.tree[j] {\n            let tmp = i;\n            i = j;\n            j = tmp;\n        }\n        // Append i to j since size(i) <= size(j).\n        self.tree[j] += self.tree[i];\n        self.tree[i] = j as isize;\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct UnionFind {\n    parent: Vec<i32>,\n}\n\n#[allow(dead_code)]\nimpl UnionFind {\n    fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: vec![-1; n],\n        }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        let p = self.parent[x];\n        return if p < 0 {\n            x\n        } else {\n            self.parent[x] = self.root(p as usize) as i32;\n            self.parent[x] as usize\n        };\n    }\n    fn union_set(&mut self, x: usize, y: usize) -> bool {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y {\n            return false;\n        }\n        if self.parent[y] < self.parent[x] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.parent[x] += self.parent[y];\n        self.parent[y] = x as i32;\n        true\n    }\n    fn find_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n    fn size(&mut self, x: usize) -> usize {\n        let r = self.root(x);\n        -self.parent[r] as usize\n    }\n}\n\n#[test]\nfn union_find() {\n    let mut ufind = UnionFind::new(10);\n    assert!(ufind.root(0) == 0);\n    assert!(ufind.size(3) == 1);\n    assert!(ufind.union_set(1, 2));\n    assert!(!ufind.union_set(1, 2));\n    ufind.union_set(2, 3);\n    let r = ufind.root(3);\n    assert!(r == 1 || r == 2 || r == 3);\n    assert!(ufind.size(3) == 3);\n}\n\nfn main() {\n    let n = read::<usize>();\n    let m = read::<usize>();\n    let mut aseq = vec![0i64; n];\n    let mut bseq = vec![0i64; n];\n    let mut cseq = vec![0i64; n];\n    for i in 0..n {\n        aseq[i] = read::<i64>();\n        bseq[i] = read::<i64>();\n        cseq[i] = std::cmp::max(0, aseq[i] - bseq[i]);\n    }\n    let mut edges = vec![(0, 0, 0); m];\n    for i in 0..m {\n        let u = read::<usize>() - 1;\n        let v = read::<usize>() - 1;\n        edges[i] = (std::cmp::max(cseq[u], cseq[v]), u, v);\n    }\n    edges.sort();\n    let mut ufind = UnionFind::new(n);\n    let mut dp = vec![0; n];\n    let mut bsums = vec![0; n];\n    let mut cmaxs = vec![0; n];\n    let mut ans = 0;\n    for i in 0..n {\n        dp[i] = bseq[i] + cseq[i];\n        bsums[i] = bseq[i];\n        cmaxs[i] = cseq[i];\n        ans = std::cmp::max(ans, dp[i]);\n    }\n    for i in 0..m {\n        let (_c, mut u, mut v) = edges[i];\n        u = ufind.root(u);\n        v = ufind.root(v);\n        if u == v {\n            continue;\n        }\n        let ndp1 = std::cmp::max(dp[u], cmaxs[v]) + bsums[v];\n        let ndp2 = std::cmp::max(dp[v], cmaxs[u]) + bsums[u];\n        ufind.union_set(u, v);\n        let r = ufind.root(u);\n        dp[r] = *[ndp1, ndp2].iter().min().unwrap();\n        cmaxs[r] = std::cmp::max(cmaxs[u], cmaxs[v]);\n        bsums[r] = bsums[u] + bsums[v];\n        ans = std::cmp::max(ans, dp[r]);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::HashSet;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, [graph1; $len:expr]) => {{\n        let mut g = vec![vec![]; $len];\n        let ab = read_value!($next, [(usize1, usize1)]);\n        for (a, b) in ab {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        g\n    }};\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n    ($next:expr, usize1) => (read_value!($next, usize) - 1);\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        read_value!($next, [$t; len])\n    }};\n    ($next:expr, $t:ty) => ($next().parse::<$t>().expect(\"Parse error\"));\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => ();//(writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/**\n * Union-Find tree.\n * Verified by https://atcoder.jp/contests/pakencamp-2019-day3/submissions/9253305\n */\nstruct UnionFind { disj: Vec<usize>, rank: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let disj = (0..n).collect();\n        UnionFind { disj: disj, rank: vec![1; n] }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        self.disj[x]\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y { return }\n        if self.rank[x] > self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.disj[x] = y;\n        self.rank[y] += self.rank[x];\n    }\n    #[allow(unused)]\n    fn is_same_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n    #[allow(unused)]\n    fn size(&mut self, x: usize) -> usize {\n        let x = self.root(x);\n        self.rank[x]\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        m: usize,\n        ab: [(i64, i64); n],\n        uv: [(usize1, usize1); m],\n    }\n    let mut aib = vec![];\n    for i in 0..n {\n        let (a, b) = ab[i];\n        aib.push((a, i, b));\n    }\n    aib.sort();\n    let mut g = vec![vec![]; n];\n    for &(u, v) in &uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let mut uf = UnionFind::new(n);\n    let mut dat = vec![(0, 0); n];\n    for &(a, v, b) in &aib {\n        let mut dsum = 0;\n        let mut difmin = max(0, a - b);\n        let mut seen = HashSet::new();\n        for &w in &g[v] {\n            if (ab[w].0, w) >= (a, v) {\n                continue;\n            }\n            let r = uf.root(w);\n            if seen.contains(&r) {\n                continue;\n            }\n            seen.insert(r);\n            let (c, d) = dat[r];\n            difmin = min(difmin, max(c, a - b) - d);\n            dsum += d;\n        }\n        dsum += b;\n        for r in seen {\n            uf.unite(v, r);\n        }\n        let r = uf.root(v);\n        dat[r] = (difmin + dsum, dsum);\n        debugln!(\"{} -> {:?}\", r, dat[r]);\n    }\n    debugln!(\"{:?}\", dat);\n    puts!(\"{}\\n\", dat.iter().max().unwrap().0);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::BufRead;\n\nfn main() {\n    let mut sc = new(std::io::stdin());\n\n    let n:usize = sc.next();\n    let m:usize = sc.next();\n    let mut node:Vec<(i32, i32)> = vec![];\n    for _ in 0..n {\n        node.push((sc.next(), sc.next())); // a, b\n    }\n    if n == 1 {\n        let res = if node[0].0 > node[0].1 {\n            node[0].0\n        } else {\n            node[0].1\n        };\n        println!(\"{}\", res);\n        return;\n    }\n    let mut edges:Vec<Vec<(i32, usize, usize)>> = vec![vec![]; n];\n    for _ in 0..m {\n        let mut from:usize = sc.next();\n        let mut to: usize = sc.next();\n        from = from.wrapping_sub(1);\n        to = to.wrapping_sub(1);\n        let w = node[to].0 - node[to].1;\n        edges[from].push((-w, from, to));\n        let w = node[from].0 - node[from].1;\n        edges[to].push((-w, to, from));\n    }\n    for i in 0..n {\n        edges[i].sort()\n    }\n\n    let mut left = -1;\n    let mut right = 1_000_000_000;\n    let mut queue = std::collections::BinaryHeap::new();\n    while right - left > 1 {\n        let have = (left + right) / 2;\n\n        queue.clear();\n\n        let mut uf = UnionFind::new(n);\n        let mut rootw = vec![-1; n];\n        for i in 0..n {\n            if node[i].0 - node[i].1 <= have {\n                for e in &edges[i] {\n                    queue.push(e.clone());\n                }\n                rootw[i] = have + node[i].1;\n            }\n        }\n        // println!(\"mid: {}\", have);\n        // println!(\"q: {:?}\", queue);\n        let mut used_edges = 0;\n        loop {\n            if let Some((w, from, to)) = queue.pop() {\n                let w = -w;\n                // println!(\"{:?}\", (w, from, to));\n                let cur = rootw[uf.root(from)];\n                assert!(cur >= 0);\n                if w <= cur && uf.root(from) != uf.root(to) {\n                    used_edges += 1;\n                    let add = if rootw[uf.root(to)] == -1 {\n                        for e in &edges[to] {\n                            queue.push(e.clone());\n                        }\n                        node[to].1\n                    } else {\n                        rootw[uf.root(to)] - have\n                    };\n                    assert!(add >= 0);\n                    let nxt = cur + add;\n                    uf.union(from, to);\n                    rootw[uf.root(to)] = nxt;\n                }\n            } else {\n                break;\n            }\n        }\n        // println!(\"used: {}\", used_edges);\n\n        if used_edges >= n - 1 {\n            assert_eq!(used_edges, n-1);\n            right = have;\n        } else {\n            left = have;\n        }\n    }\n\n    let mut res = right;\n    for (_, b) in node {\n        res += b;\n    }\n    println!(\"{}\", res);\n}\n\n\npub struct Scanner<R: io::Read> {\n    br: io::BufReader<R>,\n    // Read tokens are stored in reversed order per line.\n    buf: Vec<String>,\n}\n\npub fn new<R: io::Read>(r: R) -> Scanner<R> {\n    Scanner::new(r)\n}\n\nimpl<R: io::Read> Scanner<R> {\n    #[inline]\n    fn new(r: R) -> Scanner<R> {\n        Scanner {\n            br: io::BufReader::new(r),\n            buf: vec![],\n        }\n    }\n    #[inline]\n    pub fn next<T>(&mut self) -> T\n        where T: std::str::FromStr,\n              T::Err: std::fmt::Debug\n    {\n        self.next_string().map(|s| s.parse::<T>().expect(\"Parse failed: \")).unwrap()\n    }\n    fn next_string(&mut self) -> Option<String> {\n        self.buf.pop().or_else(|| match self.update() {\n            true => self.next_string(),\n            false => None,\n        })\n    }\n    #[inline]\n    fn update(&mut self) -> bool {\n        let mut s = String::new();\n        let res = self.br.read_line(&mut s);\n        match res.expect(\"I/O error.\") {\n            0 => false,\n            _ => {\n                self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                true\n            }\n        }\n    }\n}\n\npub struct UnionFind {\n    tree: Vec<isize>,\n}\n\nimpl UnionFind {\n    /// Creates n disjoint singleton sets.\n    #[inline]\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind { tree: vec![-1; n] }\n    }\n    /// Returns the root of the tree containing i.\n    pub fn root(&mut self, i: usize) -> usize {\n        if self.tree[i] < 0 {\n            return i;\n        }\n        let j = self.tree[i];\n        let root = self.root(j as usize);\n        // Path decomposition.\n        self.tree[i] = root as isize;\n        root\n    }\n    /// Returns the size of the tree containing i.\n    #[inline]\n    pub fn size(&mut self, i: usize) -> usize {\n        let root = self.root(i);\n        -self.tree[root] as usize\n    }\n    /// Unions i and j.\n    pub fn union(&mut self, i: usize, j: usize) {\n        let mut i = self.root(i);\n        let mut j = self.root(j);\n        if i == j {\n            return;\n        }\n        if -self.tree[i] > -self.tree[j] {\n            let tmp = i;\n            i = j;\n            j = tmp;\n        }\n        // Append i to j since size(i) <= size(j).\n        self.tree[j] += self.tree[i];\n        self.tree[i] = j as isize;\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n/**\n * Union-Find tree.\n * Verified by yukicoder No.94 (http://yukicoder.me/submissions/82111)\n */\nstruct UnionFind { disj: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let mut disj = vec![0; n];\n        for i in 0 .. n {\n            disj[i] = i;\n        }\n        UnionFind { disj: disj }\n    }\n    fn root(self: &mut Self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        return self.disj[x];\n    }\n    fn unite(self: &mut Self, x: usize, y: usize) {\n        let xr = self.root(x);\n        let yr = self.root(y);\n        self.disj[xr] = yr;\n    }\n    fn is_same_set(self: &mut Self, x: usize, y: usize) -> bool {\n        return self.root(x) == self.root(y);\n    }\n}\n\nconst INF: i64 = 1 << 55;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    input!{\n        n: usize,\n        m: usize,\n        ab: [(i64, i64); n],\n        uv: [(usize1, usize1); m],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (u, v) in uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let c: Vec<i64> = (0..n).map(|i| max(0, ab[i].0 - ab[i].1)).collect();\n    let b: Vec<i64> = (0..n).map(|i| ab[i].1).collect();\n    let mut uf = UnionFind::new(n);\n    let mut pool = Vec::new();\n    for i in 0 .. n {\n        pool.push((c[i], i));\n    }\n    pool.sort();\n    let mut vis = vec![false; n];\n    let mut minc = vec![INF; n];\n    let mut bsum = vec![0; n];\n    for (cur, idx) in pool {\n        vis[idx] = true;\n        minc[idx] = cur;\n        bsum[idx] = b[idx];\n        let mut minc_idx = INF;\n        let mut minc_w = INF;\n        let mut maxc_adj = -INF;\n        for &w in g[idx].iter() {\n            if vis[w] {\n                let r = uf.root(w);\n                maxc_adj = max(maxc_adj, minc[r]);\n            }\n        }\n        for &w in g[idx].iter() {\n            if vis[w] {\n                minc_idx = min(minc_idx, max(c[idx], c[w] - b[idx]));\n                let r = uf.root(w);\n                minc_w = min(minc_w, max(minc[r], c[idx] - bsum[r]));\n            }\n        }\n        for &w in g[idx].iter() {\n            let ridx = uf.root(idx);\n            let rw = uf.root(w);\n            if vis[w] && !uf.is_same_set(idx, w) {\n                uf.unite(ridx, rw);\n                let nr = uf.root(ridx);\n                minc[ridx] = INF;\n                minc[rw] = INF;\n                minc[nr] = min(minc_idx, minc_w);\n                let btmp = bsum[ridx] + bsum[rw];\n                bsum[ridx] = 0;\n                bsum[rw] = 0;\n                bsum[nr] = btmp;\n            }\n        }\n        //eprintln!(\"idx = {}, minc = {:?}, bsum = {:?}\", idx, minc, bsum);\n    }\n    puts!(\"{}\\n\", max(0, minc[uf.root(0)]) + bsum[uf.root(0)]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::BufRead;\n\nfn main() {\n    let mut sc = new(std::io::stdin());\n\n    let n:usize = sc.next();\n    let m:usize = sc.next();\n    let mut node:Vec<(i64, i64)> = vec![];\n    for _ in 0..n {\n        node.push((sc.next(), sc.next())); // a, b\n    }\n    if n == 1 {\n        let res = if node[0].0 > node[0].1 {\n            node[0].0\n        } else {\n            node[0].1\n        };\n        println!(\"{}\", res);\n        return;\n    }\n    let mut edges:Vec<Vec<(i64, usize, usize)>> = vec![vec![]; n];\n    for _ in 0..m {\n        let mut from:usize = sc.next();\n        let mut to: usize = sc.next();\n        from = from.wrapping_sub(1);\n        to = to.wrapping_sub(1);\n        let w = node[to].0 - node[to].1;\n        edges[from].push((-w, from, to));\n        let w = node[from].0 - node[from].1;\n        edges[to].push((-w, to, from));\n    }\n    for i in 0..n {\n        edges[i].sort()\n    }\n\n    let mut left = -1;\n    let mut right = 1_000_000_010;\n    let mut queue = std::collections::BinaryHeap::new();\n    while right - left > 1 {\n        let have = (left + right) / 2;\n\n        queue.clear();\n\n        let mut uf = UnionFind::new(n);\n        let mut rootw = vec![-1; n];\n        for i in 0..n {\n            if node[i].0 - node[i].1 <= have {\n                for e in &edges[i] {\n                    queue.push(e.clone());\n                }\n                rootw[i] = have + node[i].1;\n            }\n        }\n        // println!(\"mid: {}\", have);\n        // println!(\"q: {:?}\", queue);\n        let mut used_edges = 0;\n        loop {\n            if let Some((w, from, to)) = queue.pop() {\n                let w = -w;\n                // println!(\"{:?}\", (w, from, to));\n                let cur = rootw[uf.root(from)];\n                assert!(cur >= 0);\n                if w <= cur && uf.root(from) != uf.root(to) {\n                    used_edges += 1;\n                    let add = if rootw[uf.root(to)] == -1 {\n                        for e in &edges[to] {\n                            queue.push(e.clone());\n                        }\n                        node[to].1\n                    } else {\n                        rootw[uf.root(to)] - have\n                    };\n                    assert!(add >= 0);\n                    let nxt = cur + add;\n                    uf.union(from, to);\n                    rootw[uf.root(to)] = nxt;\n                }\n            } else {\n                break;\n            }\n        }\n        // println!(\"used: {}\", used_edges);\n\n        if used_edges >= n - 1 {\n            assert_eq!(used_edges, n-1);\n            right = have;\n        } else {\n            left = have;\n        }\n    }\n\n    let mut res = right;\n    for (_, b) in node {\n        res += b;\n    }\n    println!(\"{}\", res);\n}\n\n\npub struct Scanner<R: io::Read> {\n    br: io::BufReader<R>,\n    // Read tokens are stored in reversed order per line.\n    buf: Vec<String>,\n}\n\npub fn new<R: io::Read>(r: R) -> Scanner<R> {\n    Scanner::new(r)\n}\n\nimpl<R: io::Read> Scanner<R> {\n    #[inline]\n    fn new(r: R) -> Scanner<R> {\n        Scanner {\n            br: io::BufReader::new(r),\n            buf: vec![],\n        }\n    }\n    #[inline]\n    pub fn next<T>(&mut self) -> T\n        where T: std::str::FromStr,\n              T::Err: std::fmt::Debug\n    {\n        self.next_string().map(|s| s.parse::<T>().expect(\"Parse failed: \")).unwrap()\n    }\n    fn next_string(&mut self) -> Option<String> {\n        self.buf.pop().or_else(|| match self.update() {\n            true => self.next_string(),\n            false => None,\n        })\n    }\n    #[inline]\n    fn update(&mut self) -> bool {\n        let mut s = String::new();\n        let res = self.br.read_line(&mut s);\n        match res.expect(\"I/O error.\") {\n            0 => false,\n            _ => {\n                self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                true\n            }\n        }\n    }\n}\n\npub struct UnionFind {\n    tree: Vec<isize>,\n}\n\nimpl UnionFind {\n    /// Creates n disjoint singleton sets.\n    #[inline]\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind { tree: vec![-1; n] }\n    }\n    /// Returns the root of the tree containing i.\n    pub fn root(&mut self, i: usize) -> usize {\n        if self.tree[i] < 0 {\n            return i;\n        }\n        let j = self.tree[i];\n        let root = self.root(j as usize);\n        // Path decomposition.\n        self.tree[i] = root as isize;\n        root\n    }\n    /// Returns the size of the tree containing i.\n    #[inline]\n    pub fn size(&mut self, i: usize) -> usize {\n        let root = self.root(i);\n        -self.tree[root] as usize\n    }\n    /// Unions i and j.\n    pub fn union(&mut self, i: usize, j: usize) {\n        let mut i = self.root(i);\n        let mut j = self.root(j);\n        if i == j {\n            return;\n        }\n        if -self.tree[i] > -self.tree[j] {\n            let tmp = i;\n            i = j;\n            j = tmp;\n        }\n        // Append i to j since size(i) <= size(j).\n        self.tree[j] += self.tree[i];\n        self.tree[i] = j as isize;\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[allow(dead_code)]\nstruct UnionFind {\n    parent: Vec<i32>,\n}\n\n#[allow(dead_code)]\nimpl UnionFind {\n    fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: vec![-1; n],\n        }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        let p = self.parent[x];\n        return if p < 0 {\n            x\n        } else {\n            self.parent[x] = self.root(p as usize) as i32;\n            self.parent[x] as usize\n        };\n    }\n    fn union_set(&mut self, x: usize, y: usize) -> bool {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y {\n            return false;\n        }\n        if self.parent[y] < self.parent[x] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.parent[x] += self.parent[y];\n        self.parent[y] = x as i32;\n        true\n    }\n    fn find_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n    fn size(&mut self, x: usize) -> usize {\n        let r = self.root(x);\n        -self.parent[r] as usize\n    }\n}\n\n#[test]\nfn union_find() {\n    let mut ufind = UnionFind::new(10);\n    assert!(ufind.root(0) == 0);\n    assert!(ufind.size(3) == 1);\n    assert!(ufind.union_set(1, 2));\n    assert!(!ufind.union_set(1, 2));\n    ufind.union_set(2, 3);\n    let r = ufind.root(3);\n    assert!(r == 1 || r == 2 || r == 3);\n    assert!(ufind.size(3) == 3);\n}\n\nfn main() {\n    let n = read::<usize>();\n    let m = read::<usize>();\n    let mut aseq = vec![0i64; n];\n    let mut bseq = vec![0i64; n];\n    let mut cseq = vec![0i64; n];\n    for i in 0..n {\n        aseq[i] = read::<i64>();\n        bseq[i] = read::<i64>();\n        cseq[i] = std::cmp::max(0, aseq[i] - bseq[i]);\n    }\n    let mut edges = vec![(0, 0, 0); m];\n    for i in 0..m {\n        let u = read::<usize>() - 1;\n        let v = read::<usize>() - 1;\n        edges[i] = (std::cmp::max(cseq[u], cseq[v]), u, v);\n    }\n    edges.sort();\n    let mut ufind = UnionFind::new(n);\n    let mut dp = vec![0; n];\n    let mut bsums = vec![0; n];\n    let mut cmaxs = vec![0; n];\n    for i in 0..n {\n        dp[i] = bseq[i] + cseq[i];\n        bsums[i] = bseq[i];\n        cmaxs[i] = cseq[i];\n    }\n    let mut ans = 0;\n    for i in 0..m {\n        let (_c, mut u, mut v) = edges[i];\n        u = ufind.root(u);\n        v = ufind.root(v);\n        if u == v {\n            continue;\n        }\n        let ndp1 = std::cmp::max(dp[u], cmaxs[v]) + bsums[v];\n        let ndp2 = std::cmp::max(dp[v], cmaxs[u]) + bsums[u];\n        ufind.union_set(u, v);\n        let r = ufind.root(u);\n        dp[r] = *[ndp1, ndp2].iter().min().unwrap();\n        cmaxs[r] = std::cmp::max(cmaxs[u], cmaxs[v]);\n        bsums[r] = bsums[u] + bsums[v];\n        ans = std::cmp::max(ans, dp[r]);\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\nuse std::collections::HashSet;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, [graph1; $len:expr]) => {{\n        let mut g = vec![vec![]; $len];\n        let ab = read_value!($next, [(usize1, usize1)]);\n        for (a, b) in ab {\n            g[a].push(b);\n            g[b].push(a);\n        }\n        g\n    }};\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n    ($next:expr, usize1) => (read_value!($next, usize) - 1);\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        read_value!($next, [$t; len])\n    }};\n    ($next:expr, $t:ty) => ($next().parse::<$t>().expect(\"Parse error\"));\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => ();//(writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/**\n * Union-Find tree.\n * Verified by https://atcoder.jp/contests/pakencamp-2019-day3/submissions/9253305\n */\nstruct UnionFind { disj: Vec<usize>, rank: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let disj = (0..n).collect();\n        UnionFind { disj: disj, rank: vec![1; n] }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        self.disj[x]\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y { return }\n        if self.rank[x] > self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.disj[x] = y;\n        self.rank[y] += self.rank[x];\n    }\n    #[allow(unused)]\n    fn is_same_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n    #[allow(unused)]\n    fn size(&mut self, x: usize) -> usize {\n        let x = self.root(x);\n        self.rank[x]\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        m: usize,\n        ab: [(i64, i64); n],\n        uv: [(usize1, usize1); m],\n    }\n    let mut aib = vec![];\n    for i in 0..n {\n        let (a, b) = ab[i];\n        aib.push((a, i, b));\n    }\n    aib.sort();\n    let mut g = vec![vec![]; n];\n    for &(u, v) in &uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let mut uf = UnionFind::new(n);\n    let mut dat = vec![(0, 0); n];\n    for &(a, v, b) in &aib {\n        let mut dsum = 0;\n        let mut difmin = max(0, a - b);\n        let mut seen = HashSet::new();\n        for &w in &g[v] {\n            if (ab[w].0, w) >= (a, v) {\n                continue;\n            }\n            let r = uf.root(w);\n            if seen.contains(&r) {\n                continue;\n            }\n            seen.insert(r);\n            let (c, d) = dat[r];\n            difmin = min(difmin, max(c, a - b - d));\n            dsum += d;\n        }\n        dsum += b;\n        for r in seen {\n            uf.unite(v, r);\n        }\n        let r = uf.root(v);\n        dat[r] = (difmin, dsum);\n        debugln!(\"{} -> {:?}\", r, dat[r]);\n    }\n    debugln!(\"{:?}\", dat);\n    let r = uf.root(0);\n    let (c, d) = dat[r];\n    puts!(\"{}\\n\", c + d);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::{input, marker::Usize1};\n\n#[allow(dead_code)]\n#[derive(Clone, Copy, Debug)]\nenum ParentOrSize {\n    Parent(usize),\n    Size(usize),\n}\n\n#[allow(dead_code)]\n#[derive(Clone, Debug)]\nstruct UnionFind(Vec<ParentOrSize>);\n\n#[allow(dead_code)]\nimpl UnionFind {\n    pub fn new(len: usize) -> Self {\n        Self(vec![ParentOrSize::Size(1); len])\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.0.is_empty()\n    }\n\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    pub fn find(&mut self, i: usize) -> usize {\n        self.find_and_size(i).0\n    }\n\n    fn find_and_size(&mut self, i: usize) -> (usize, usize) {\n        assert!(i < self.len());\n        match self.0[i] {\n            ParentOrSize::Parent(p) => {\n                let ret = self.find_and_size(p);\n                self.0[i] = ParentOrSize::Parent(ret.0);\n                ret\n            }\n            ParentOrSize::Size(si) => (i, si),\n        }\n    }\n\n    pub fn unite(&mut self, u: usize, v: usize) {\n        let (mut u, su) = self.find_and_size(u);\n        let (mut v, sv) = self.find_and_size(v);\n        if u == v {\n            return;\n        }\n        if su > sv {\n            std::mem::swap(&mut u, &mut v);\n            std::mem::swap(&mut v, &mut u);\n        }\n        self.0[v] = ParentOrSize::Size(su + sv);\n        self.0[u] = ParentOrSize::Parent(v);\n    }\n\n    pub fn same(&mut self, u: usize, v: usize) -> bool {\n        self.find(u) == self.find(v)\n    }\n}\n\nfn main() {\n    input!(\n        n: usize,\n        m: usize,\n        ab: [(i64, i64); n],\n        uv: [(Usize1, Usize1); m]\n    );\n    let mut g = vec![vec![]; n];\n    for (u, v) in uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let b: Vec<_> = ab.iter().map(|(_, b)| b).collect();\n    let c: Vec<_> = ab.iter().map(|(a, b)| a - b).collect();\n\n    let mut ord: Vec<_> = (0..n).collect();\n    ord.sort_by_key(|&i| c[i]);\n\n    let mut ckd = vec![false; n];\n    let mut dp = vec![0; n];\n    let mut sum_b_of_cmp = vec![0; n];\n    let mut uf = UnionFind::new(n);\n    for x in ord {\n        let mut adj: Vec<_> = g[x]\n            .iter()\n            .copied()\n            .map(|y| uf.find(y))\n            .filter(|&y| ckd[y])\n            .collect();\n        adj.sort();\n        adj.dedup();\n        let sum_b_of_cmp_x = b[x] + adj.iter().map(|&y| sum_b_of_cmp[y]).sum::<i64>();\n        let mut ans = c[x].max(0) + sum_b_of_cmp_x;\n        for &y in &adj {\n            let now = dp[y].max(c[x]) + sum_b_of_cmp_x - sum_b_of_cmp[y];\n            if now < ans {\n                ans = now;\n            }\n        }\n        for y in adj {\n            uf.unite(x, y);\n        }\n        let x = uf.find(x);\n        sum_b_of_cmp[x] = sum_b_of_cmp_x;\n        ckd[x] = true;\n        dp[x] = ans;\n    }\n    println!(\"{}\", dp[uf.find(0)]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n/**\n * Union-Find tree.\n * Verified by yukicoder No.94 (http://yukicoder.me/submissions/82111)\n */\nstruct UnionFind { disj: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let mut disj = vec![0; n];\n        for i in 0 .. n {\n            disj[i] = i;\n        }\n        UnionFind { disj: disj }\n    }\n    fn root(self: &mut Self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        return self.disj[x];\n    }\n    fn unite(self: &mut Self, x: usize, y: usize) {\n        let xr = self.root(x);\n        let yr = self.root(y);\n        self.disj[xr] = yr;\n    }\n    fn is_same_set(self: &mut Self, x: usize, y: usize) -> bool {\n        return self.root(x) == self.root(y);\n    }\n}\n\nconst INF: i64 = 1 << 55;\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    input!{\n        n: usize,\n        m: usize,\n        ab: [(i64, i64); n],\n        uv: [(usize1, usize1); m],\n    }\n    let mut g = vec![Vec::new(); n];\n    for (u, v) in uv {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let c: Vec<i64> = (0..n).map(|i| max(0, ab[i].0 - ab[i].1)).collect();\n    let b: Vec<i64> = (0..n).map(|i| ab[i].1).collect();\n    let mut uf = UnionFind::new(n);\n    let mut pool = Vec::new();\n    for i in 0 .. n {\n        pool.push((c[i], i));\n    }\n    pool.sort();\n    let mut vis = vec![false; n];\n    let mut minc = vec![INF; n];\n    let mut bsum = vec![0; n];\n    for (cur, idx) in pool {\n        vis[idx] = true;\n        minc[idx] = cur;\n        bsum[idx] = b[idx];\n        let mut minc_idx = INF;\n        let mut minc_w = INF;\n        let mut maxc_adj = -INF;\n        for &w in g[idx].iter() {\n            if vis[w] {\n                let r = uf.root(w);\n                maxc_adj = max(maxc_adj, minc[r]);\n            }\n        }\n        for &w in g[idx].iter() {\n            if vis[w] {\n                minc_idx = min(minc_idx, max(c[idx], c[w] - b[idx]));\n                let r = uf.root(w);\n                minc_w = min(minc_w, max(max(minc[r], c[idx] - bsum[r]), maxc_adj - bsum[r] - b[idx]));\n            }\n        }\n        for &w in g[idx].iter() {\n            let ridx = uf.root(idx);\n            let rw = uf.root(w);\n            if vis[w] && !uf.is_same_set(idx, w) {\n                uf.unite(ridx, rw);\n                let nr = uf.root(ridx);\n                minc[ridx] = INF;\n                minc[rw] = INF;\n                minc[nr] = min(minc_idx, minc_w);\n                let btmp = bsum[ridx] + bsum[rw];\n                bsum[ridx] = 0;\n                bsum[rw] = 0;\n                bsum[nr] = btmp;\n            }\n        }\n        //eprintln!(\"idx = {}, minc = {:?}, bsum = {:?}\", idx, minc, bsum);\n    }\n    puts!(\"{}\\n\", max(0, minc[uf.root(0)]) + bsum[uf.root(0)]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]